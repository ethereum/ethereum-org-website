---
title: Optimium
description: An introduction to optimiums as a scaling solution currently utilized by the Ethereum community.
lang: en
---

Optimiums are off-scaling solutions that use fraud proofs for security and settle transactions on Ethereum, but store transaction data off-chain. Off-chain data availability reduces transaction fees for users and improves throughput for applications, but comes at the expense of weaker guarantees around security of funds deposited in bridge contracts and resistance to censorship. Unlike [Layer 2 (L2) scaling solutions](/layer-2/), **optimiums do not completely derive critical security properties like safety and liveness from Ethereum** and have greater reliance on the honesty of off-chain actors (e.g., validators and data availability providers).

## Prerequisites {#prerequisites}

A high-level understanding of how blockchains like Ethereum work and minimal familiarity with [Ethereum scaling](/developers/docs/scaling/) will make it easier to grasp the various concepts discussed in this page. Implementing and integrating with scaling solutions, like optimiums, is an advanced topic as the technology is still under active research and development.

### How to navigate this page {#how-to-navigate-this-page}

You may want to read through introductory sections to gain a fundamental understanding of optimiums before moving to other parts. You can also jump to a particular section to find the information you’re looking for. Whatever your preference and reading style, we have a summary of contents—with hyperlinks to section headings—to assist in navigating the contents of this page:

- **[What is an optimium chain?](https://hackmd.io/FgEWwVlaRnGFpVNSKOLYHQ#What-is-an-optimium-chain-overview-of-optimium-chains)**: Provides a high-level explanation of optimiums and highlights similarities and differences between optimiums and similar existing scaling solutions, particularly optimistic rollups and sidechains.
- **[A deep dive into optimium protocols](https://hackmd.io/FgEWwVlaRnGFpVNSKOLYHQ#A-deep-dive-into-the-architecture-of-optimium-chains-optimium-protocol-deep-dive)**: A comprehensive overview of the architecture and design of optimiums—topics covered include block production, block validation, dispute arbitration, and data availability in optimium chains.
- **[Optimiums FAQs for developers](https://hackmd.io/FgEWwVlaRnGFpVNSKOLYHQ#Optimiums-FAQs-for-developers-optimium-frequently-asked-questions-for-developers)**: Get answers to frequently asked questions (FAQs) related to building applications on optimiums—topics covered include EVM-compatibility, interoperability, and transaction fees in optimiums.
- **[Comparisons of optimiums to other scaling solutions](https://hackmd.io/FgEWwVlaRnGFpVNSKOLYHQ#Comparative-advantages-How-do-optimiums-compare-to-other-off-chain-scaling-solutions-optimiums-and-alternative-scaling-solutions)**: A detailed comparison of optimiums to other scaling solutions (validiums, rollups, sidechains, Plasma, and state channels) to assist developers and enterprises in deciding whether an optimium—or a competing scaling solution—best suits their needs.
- **[Build dapps on optimium chains](https://hackmd.io/FgEWwVlaRnGFpVNSKOLYHQ#Build-dapps-on-optimiums-build-dapps-on-optimiums)**: A (non-exhaustive) list of EVM-compatible optimiums you can start building on.
- **[Further reading on optimiums](https://hackmd.io/FgEWwVlaRnGFpVNSKOLYHQ#Further-reading-on-optimiums-further-reading)**: A collection of relevant articles and forum posts you can read to learn more about optimiums and off-chain scaling in general.

## What is an optimium chain? {#overview-of-optimium-chains}

An optimium can be _concisely_ defined as an off-chain protocol that relies on Ethereum to settle transactions and enforce validity of state transitions via fraud proofs, but derives consensus (canonical ordering of transactions) and data availability (availability of transaction data) from a separate source. Optimium chains do not prove validity of state transitions, but allow for claims about state transitions to be challenged on-chain. Ethereum arbitrates disputes between validators asserting conflicting states and can roll back successfully disputed state transitions to protect the off-chain network from executing invalid transactions.

![Optimiums checkpoint state transitions on Ethereum by submitting block headers for inclusion in Ethereum blocks](sidechain-checkpointing-states-on-ethereum.png)

An optimium can be _comprehensively_ defined as an **optimistic sidechain**—that is, a sidechain with additional (security) properties:

- A requirement for validators to submit cryptographic commitments to state updates to an **on-chain light client** (implemented as a smart contract). The light client contract represents the main chain’s (Ethereum) view of the state of accounts and user balances on the sidechain.
- A **dispute protocol** that encodes the optimium’s state transition logic and can re-execute disputed state transitions on-chain to verify fraud proofs during the challenge period.
- A **challenge period** during which invalid updates to the sidechain’s state can be disputed on-chain by honest nodes monitoring the chain. Validators bond collateral before submitting state commitments and can be slashed if a state transition asserted on Ethereum is proven invalid during a dispute.
- A **validating bridge** on Ethereum that confirms validity of transactions that update the sidechain’s state before processing withdrawal requests. The validating bridge guarantees honest users can withdraw assets bridged to the sidechain if they have access to the sidechain’s state and can prove ownership of funds.

The definition describes a blockchain as an optimium based on the off-chain network’s relationship with Ethereum. A blockchain may be described as a “rollup” because it publishes transaction data to an external data availability layer—similar to rollups publishing transaction data on Ethereum—and submits state roots on-chain to a bridge contract to settle transactions on Ethereum. But, without the ability to enforce the off-chain network’s ordering and guarantee data availability, this is a sidechain from Ethereum’s perspective.

If the sidechain implements a fraud proof system on Ethereum, it becomes an optimistic sidechain or optimium. Ethereum cannot _directly_ verify the correctness of a new block header that asserts a new state for the sidechain, but it _can_ verify a fraud proof that proves a newly asserted state is incorrect according to the sidechain’s state transition rules. But Ethereum does not guarantee that the inputs to the state transition function (transaction data) is available to verifiers or users—making it an optimistic sidechain (optimium) from the perspective of the Ethereum network.

![Challenge games prevent dishonest nodes validating an optimium chain from settling invalid transactions on Ethereum](challenge-games.png)

Separating out data availability from the sidechain’s consensus by storing transaction data with a third party _may_ reduce trust assumptions for a user, if the user trusts the security of the data availability layer, but does not translate into guarantees of ownership of funds in the bridge contract enforced by Ethereum itself. The bridge connecting the sidechain with Ethereum is a light client and only reads attestations to data availability and does not verify if the data is actually available before accepting a new block header. If a majority of validators collude to withhold data or revert blocks, Ethereum cannot enforce ownership of funds deposited in the sidechain's bridge.

Since optimiums are developed as a scaling solution for Ethereum, this definition is crucial to understanding the guarantees that users bridging assets from Ethereum to various optimiums have. In other words: “If a user owns an asset on Ethereum, deposits into the optimium’s bridge, and then receives a representation of the asset off-chain, what guarantees does the user have that it can withdraw the original asset back to Ethereum?”

### How are optimiums different from traditional sidechains?

A sidechain is a separate, independent blockchain that connects with another blockchain (a “main chain”)—such as Ethereum—via a two-way bridge. Sidechains bootstrap security independently: a common approach is to implement a Proof of Stake (PoS) consensus protocol that requires staking the network’s native token before joining the validator set (a validator’s stake acts as a bond for honest behavior and can be slashed if it engages in provably dishonest behavior, such as voting for an voting for an incorrect block).

Sidechains are [off-chain scaling solutions](/developers/docs/scaling/#off-chain-scaling) that maintain a separate state and process transactions separately from Ethereum. The core ideas behind off-chain scaling are explored below:

- Users can deposit Ethereum-native assets (e.g., ETH) into a bridge contract, receive a representation of that asset on the off-chain network (e.g., wrapped ETH), and send transactions to nodes operating the off-chain network to spend from their balance. The value of assets issued on the off-chain network is backed by the deposits locked in the bridge contract. Users can also withdraw deposits from the bridge by proving either inclusion of a transaction burning tokens minted on the sidechain or balances of accounts with a Merkle proof.

- The off-chain network makes modifications, such as having faster block times and higher gas limits, to increase scalability (throughput and transaction costs). Bigger blocks reduce congestion (which contributes to gas price surges on Ethereum today) and enable applications to scale transaction volumes. Faster block times reduce latency for transactions and may be reduced further by using a small set of actors (validators and sequencers) to confirm transactions. But these modifications typically come at the expense of decentralization as fewer nodes are capable of validating the chain due to increased hardware/financial requirements to participate in consensus.
- Off-chain scaling protocols maintain a separate state and do not directly scale execution and throughput on Ethereum directly. But they do provide an alternative for users to bridge Ethereum-native assets and execute transactions cheaply and quickly in an optimized off-chain environment. The off-chain network may implement the Ethereum Virtual Machine (EVM) specification for compatibility with existing Ethereum infrastructure, applications, and developer tooling and provide an “Ethereum-like” experience—allowing users can interact with dapps and send tokens as they would on Ethereum and developers can build applications using the same tools.

- Off-chain protocols store only a minimum amount of state data on-chain and amortize the costs of checkpointing states on-chain by batching transactions and submitting commitments to the state from executing batches. Off-chain scaling reduces congestion on the base layer, whilst allowing Ethereum to outsource execution; to illustrate, if an Ethereum block includes a commitment to 1000 transactions, and the commitment is valid, Ethereum would have indirectly processed 1000 transactions without having to increase block sizes or decreasing block times.

The difference between off-chain scaling solutions for Ethereum revolves around the guarantees that users can withdraw bridged assets back to Ethereum without needing to trust another counterparty (i.e., besides Ethereum nodes) for the security of assets deposited in a bridge. Sidechains are not considered a secure scaling solution for Ethereum as the security of assets deposited in bridge contracts depends entirely on the honesty of the sidechain’s validators:

In a sidechain construction, the bridge contract acts as a light client that verifies changes in the sidechain’s state by confirming that a majority of validators signed the latest block header. If the latest block is valid according to the bridge, users can withdraw funds by providing data that proves information about the sidechain’s state (e.g., account balances and inclusion of burn transactions in a block).

This design choice reduces latency on withdrawals from the bridge; users can withdraw as soon as a new block is confirmed by a majority of validators on the sidechain. However, the bridge assumes the validators are approving valid blocks and cannot reliably detect invalid updates to the sidechain’s state. If the majority of validators required to approve a block agree to perform an invalid state transition (e.g., a block minting tokens for a user without collateral deposited in the bridge), the bridge may become insolvent and unable to process withdrawals from honest users.

In contrast, the **validating bridge** used by optimium chains can verify integrity of the sidechain’s state without trusting an external authority (e.g., the sidechain’s validator set) before processing withdrawals. While the bridge optimistically assumes block headers submitted to the light client contract are valid, it can verify a fraud proof that proves a proposed block includes incorrectly executed transactions. Fraud proofs enable anyone to prove that a block includes invalid transactions and provide optimium chains with a 1-of-n security guarantee: if one honest validator is available to dispute invalid state transitions, a dishonest majority of validators cannot trick the light client into accepting a bad block.

Verifying fraud proofs on Ethereum provides an extra layer of defense against settlement of invalid transactions by validators running the optimium chain. Unlike traditional sidechains that settle transactions once a threshold of validators approve blocks, optimium chains settle transactions _after_ the challenge window expires without a fraud proof disputing block headers submitted to the on-chain light client. More specifically, the validating bridge delays withdrawals until it confirms acceptance of block headers by the optimium’s light client contract—reducing the risk of sidechain validators colluding to steal assets by approving invalid state transitions.

![Validating bridges prevent invalid withdrawals from an optimium’s bridge and safeguard deposited assets](validating-bridge-optimiums.png)

Optimium chains can also defend against malicious reorgs by checkpointing state updates on-chain (via block headers submitted to the on-chain light client). Each block header is stored in a finalized Ethereum block and links to the previous block header, which creates a chain of commitments that represents Ethereum’s view of the optimium’s state. If the optimium chain uses a fork-choice rule that dictates a valid block must include a hash of the last Ethereum block, it guarantees everyone observing the optimium chain by reading Ethereum’s state will always have the same view.

This prevents safety failures arising from two nodes observing two different states at the same block height. Such safety failures can occur when an adversary tricks undiscerning nodes into following a malicious fork that reverts previously finalized blocks and performs a double-spend attack (spending funds from historical transactions). A blockchain’s security against malicious reorgs depends on the honesty of the validator set and the economic cost of reverting blocks.

An adversary that wishes to provide an alternative view of history and cause honest nodes to follow a malicious fork must control a threshold of the active stake on Ethereum to revert Ethereum blocks containing block headers submitted by optimium validators. This attack is difficult to execute in principle: (1) Ethereum’s consensus protocol uses a large set validator (composed of thousands of validators) that makes collusion and bribery difficult. (2) The price of ETH places a quantifiable and significant cost on malicious reorgs (attackers need to burn at least ⅓ of staked ETH or millions of dollars to revert finalized blocks). In comparison, traditional sidechains may be susceptible to reorg attacks due to using a smaller validator set and having a low-value native token (which reduces the difficulty of collusion and decreases the cost borne by an attacker in a 51 percent attack).

|                                                                                   ![Preventing reorgs in optimium chains](sidechain-checkpointing-to-ethereum.png)                                                                                    |
| :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| _The blocks in the green rectangle represent the checkpointed (canonical) optimium chain from the perspective of a node observing the finalized Ethereum chain and prevents an adversary from convincing honest nodes to follow a conflicting chain._ |

Optimiums have slightly better security properties than pure sidechains by settling transactions on Ethereum and verifying fraud proofs to secure against invalid state transitions. However, optimium chains are not as secure as Layer 2 (L2) blockchains—off-chain scaling protocols that inherit consensus (canonical ordering of transactions) and data availability (availability of state data) from Ethereum in addition to settling transactions on-chain. Ethereum rollups are the primary example of Layer 2 (L2) scaling solutions and the next section explores the differences between L2s and optimiums

## Why are optimiums not considered a Layer 2 (L2) scaling solution?

Layer 2 (L2) scaling initially referred to any construction that improved throughput on Ethereum by processing transactions off-chain by optimizing usage of Ethereum’s data bandwidth and computational resources. This group included Plasma chains, sidechains, state channels, validiums, and more recently, rollups. But the term “Layer 2” has now come to refer to off-chain networks that inherit consensus, data availability, and settlement guarantees from Ethereum.

Optimiums derive consensus and data availability for one or more separate sources, which means Ethereum cannot guarantee safety and liveness of the chain—except with the cooperation of off-chain actors. This runs against the ethos of Layer 2 scaling: a user should be confident in their ability to withdraw funds as long as Ethereum itself is secure against consensus and data availability faults.

Besides inheriting Ethereum’s consensus, L2s also extend Ethereum’s decentralization—users should only make assumptions about the decentralization of the Ethereum network when assessing the security of assets bridged off-chain from Ethereum to a scaling-focused off-chain network. Note that considerations around social, technical, and architectural decentralization in _Ethereum_ rollups (e.g., centralized vs. decentralized sequencing, control of the bridge contract by a multisig vs. a DAO, permissionless vs. permissioned proposal of state outputs, etc.) are orthogonal to this discussion and are best addressed separately (see [L2Beat’s risk framework](https://l2beat.com/scaling/risk) and [rollup decentralization framework](https://ethereum-magicians.org/t/proposed-milestones-for-rollups-taking-off-training-wheels/11571) for details).

Instead, this definition is concerned with the set of actors that determine the liveness and safety of the off-chain network (which determine security of assets transferred off-chain from Ethereum via bridge):

- **Liveness**: Liveness is the property that "something good evnetually happens" and includes **shain progress** (the chain keeps advancing and nodes can produce new blocks that execute transactions and update the state) and **censorship resistance** (eventual execution of user-generated transactions)
- **Safety**: Safety is the property that "something bad never happens" and includes **block validity** (invalid transactions are never added to the canonical chain) and **resistance to malicious block reorganizations** (an attacker cannot rewrite the history of the chain or reverse finalized transactions).

In a decentralized Layer 2 construction, an honest majority of Ethereum validators can guarantee the safety and liveness of the off-chain protocol—even if the operator or validators in the off-chain network are untrusted. Thus a decentralized rollup is said to “inherit security from Ethereum” as the same assumptions that underpin the security of the Layer 1 chain itself (e.g., infeasibility of finalizing conflicting blocks) apply to the security of the rollup and safety of funds deposited in the rollup’s bridge.

Narrowing the scope of L2 scaling was the result of extensive discussions within the Ethereum community and a recognition that any scaling solution was valuable to the extent in which it preserved and extended Ethereum’s guarantees of decentralization and security. In the case of off-chain scaling solutions, users should only have to trust Ethereum’s security—having to trust any other party to secure assets and transactions in the off-chain network meant such a scaling solution could not scale Ethereum without introducing new trust assumptions and reducing decentralization.

**[Read more on Ethereum’s rollup-centric roadmap](https://ethereum-magicians.org/t/a-rollup-centric-ethereum-roadmap/4698).**

We discuss the basic properties that decentralized L2 protocols satisfy and compare them to optimium chains in the next section:

### Consensus

**Consensus** defines the canonical ordering of transactions in a blockchain and determines transaction finality. Finality (the property that transactions added to the canonical chain are irreversible) is tied to the consensus mechanism, which provides the rule for confirming a transaction’s inclusion in the canonical chain. Bitcoin and other Proof of Work (PoW) chains have _probabilistic finality_ (a user’s transaction can be reverted if a miner builds a longer chain that excludes that transaction) and a [_k_-deep confirmation rule](https://en.bitcoin.it/wiki/Confirmation), where transactions are confirmed after a miner builds upon the block containing the transaction (_k_ is the number of descendant blocks that build on the block containing the confirmed transaction).

Ethereum and other Proof of Stake (PoS) blockchains have _economic finality_, where nodes agree to never revert blocks beyond a certain finalized checkpoint; if the chain reverts a block beyond this checkpoint, accountable safety guarantees that at least ⅓ of validators (weighted by stake) can be slashed—provided ⅔ validators are honest. The cost of reverting blocks past a finalized checkpoint places a quantifiable cost on reorgs and provides a confirmation rule, where a transaction is confirmed after the corresponding block is voted by a supermajority (⅔) of validators (weighted by stake) in two successive epochs (~15 minutes).

![Ethereum finality](ethereum-finality.png)

Layer 2 blockchains inherit consensus from Ethereum by submitting transaction batches for inclusion in Ethereum blocks. A batch of L2 transactions is final when the L1 block that includes the batch is confirmed by a supermajority in two successful epochs; reverting finalized transactions requires burning ⅓ of the active stake to revert the L1 block. Due to this relationship (described as merged consensus), decentralized rollups are able to use Ethereum’s confirmation rule—which decides what blocks are canonical—to provide strong guarantees of transaction finality and resistance to malicious reorgs/double-spend attacks.

![Rollup submitting transaction batches to Ethereum](rollup-batch-submission.jpg)

Optimiums do not submit transaction batches to Ethereum and inherit consensus from wherever transaction data is stored. For example, an optimium that stores transaction data (blocks) with validators has transaction finality when a majority of validators approve the block and add it to the canonical chain. Conversely, an optimium integrated with an external data availability service has transaction finality when a quorum of nodes on the data availability layer confirms the batch. Finality of optimium transactions is dependent on the security of the external data availability protocol against adversarial attempts to revert the ordering of confirmed transaction batches.

#### Settlement vs. finality

Finality is often used interchangeably with settlement due to the way traditional blockchains are designed, even if they are different. Finality asserts inclusion of a transaction or block in the history of the canonical chain, but does not explicitly guarantee validity of transactions and blocks. Settlement asserts the validity of the execution of a transaction or block included in the canonical chain and guarantees that the result of a settled transaction cannot be reversed, except the chain suffers a finality attack.

On Ethereum, finality is roughly with settlement: a block can include invalid transactions, and a supermajority finalizes the block—this is finality. If no one detects the bad block, the output of the block’s transactions (i.e., the effects of applying the transactions to the chain’s state) are “settled”. But the protocol has a rule that says if ⅔ of validators are honest, an honest validator can include evidence of a previous block’s validity in a new block and trigger slashing of ⅓ validators that signed the block. The chain also reverts to the earliest state before the invalid block and discards any other blocks that build on the invalid block.

Since validators have incentive not to include invalid transactions, a finalized block is considered settled from the perspective of an entity observing the chain. But finality and settlement take different notions when off-chain scaling solutions are concerned—especially as off-chain scaling solutions split execution, consensus, and settlement between separate layers.

In the context of optimiums, this difference means a transaction is “final” when its ordering in a batch is confirmed by the external data availability layer, and “settled” when the transaction’s output or effect on the chain’s state is confirmed by the settlement layer. Settlement on Ethereum happens once a commitment to the execution of transactions (a state root) is accepted by the optimium’s on-chain light client contract. Ethereum can guarantee settlement of transactions conducted on an optimium chain that implements the following components on-chain:

- A light client verifier that stores commitments to updates to the optimium’s state (changes in account balances and code). If the state commitment asserting the output of an optimium transaction remains unchallenged, the light client verifier updates to the newest state commitment after the challenge window concludes.
- A dispute protocol that encodes the optimium’s state transition logic and can re-execute transactions to verify disputed state transitions. The dispute protocol accepts fraud proofs from honest challengers during the dispute window—provided an honest validator is available to include the fraud proof transaction in an Ethereum block.

These components combined allow the Ethereum network to provide meaningful guarantees of transaction settlement for optimium chains. Due to the links between state commitments stored on Ethereum (each state commitment is stored inside an Ethereum block and links to the previous state commitment), a user interacting with an optimium chain can be confident that the **output** of a transaction (i.e., the effects of the transaction on the optimium’s state) will not be reverted—provided the following are true:

- Validators are honest and treat the chain of state commitments stored in the on-chain light client on Ethereum as the source of truth for the optimium’s latest finalized state.
- The validator in an optimium is honest and proposes a valid block _b’_ that builds on the head block _b_ and asserts a correct post-state _s’_.

If the aforementioned conditions are true, everyone observing the optimium chain—including users and applications that interact with the optimium’s state (e.g., bridges, exchanges, liquidity providers, fiat offramps) will always have a single view of the optimium’s state. This is critical to enforcing the chain’s safety property—one of which has to do with consistency: two honest nodes should never have conflicting views of the chain at the same block height.

Settlement on Ethereum should, however, not be conflated with finality: the absence of a fraud proof inductively proves the validity of a transaction, allowing applications and users to make decisions based on the result of a transaction. But the acceptance of a state commitment by the optimium’s light client contract does not guarantee hard finality of transactions: an optimium can periodically checkpoint states on-chain by posting state commitments, but a loss of security in the external data availability layer can trigger the reversal of the network to a state before a finalized checkpoint.

Unlike Layer 2 (L2) chains, optimiums cannot use Ethereum’s block confirmation rule (e.g., a rollup user may treat a transaction as finalized if the transaction data is included in an L1 block) and must rely on the security of the data availability layer for protection against chain reorganizations. We illustrate the distinction between finality and settlement for optimium chains on Ethereum:

- Bob has a balance of 25 tokens on the optimium chain and pays Alice 25 tokens for a cup of coffee. Bob’s transaction is included in a batch by the sequencer and submitted to the data availability network. A block including the sequencer’s batch is confirmed by a supermajority of validators on the data availability network—Alice considers Bob’s transaction as final at this point.
- A validator (Max) creates a block b using transaction data from the sequencer’s (now finalized) batch and computes a commitment to the state _s_—asserting the result of Bob’s transaction `(Bob: 0 tokens | Alice: 25 tokens)`—and submits the state commitment to the on-chain light client contract. No one disputes the asserted state transition throughout the seven-day challenge window, and the light client contract updates to the state commitment s—Bob’s transaction is settled at this point. Alice makes decisions based on the new state, such as paying Hermione 25 tokens for a fresh supply of coffee beans.
- Bob goes rogue and bribes Max to create a new block b’ that asserts the state _s’_ `(Bob: 25 tokens | Alice: 0 tokens)`—effectively reverting the result of the earlier transaction—to the on-chain light client contract. Alice needs to create a fraud proof showing that the transition from state s to state _s’_ does not follow the optimium’s validity rule (the fraud proof will show that the output of applying block _b’_ on the pre-state s (the post-state root _s’_) does not match the state s’ asserted by Max).
- Bob goes further and bribes the majority of validators on the data availability network to revert block b and replace it with a block _b’_ that excludes Bob’s transfer of 25 tokens to Alice. Or Max simply withholds the data from Alice (if no data availability service is used). From the dispute protocol’s perspective, Alice cannot create a valid fraud proof; block _b_ from the canonical optimium chain (determined by full nodes on the data availability layer) will not reflect a reduction in Bob’s balance from the initial payment to Alice, so the transition from state _s_ `(Bob: 25 tokens | Alice: 0 tokens)` to state _s’_ `(Bob: 25 tokens | Alice: 0 tokens)` is valid. Alice is obviously the right party in the dispute, but the loss of security in the external data availability layer prevents her from successfully challenging the state transition.
- If the light client contract (inevitably) accepts the state commitment _s’_, Alice’s previous balance of 25 tokens from the transaction with Bob will disappear. Hermione’s balance of 25 tokens from the transaction with Alice will also disappear as the canonical chain (defined by the list of state commitments stored in the light client contract) has no record of Alice ever owning the 25 tokens sent to Hermione.

This hypothetical example highlights a major distinction between optimiums and Layer 2 (L2) scaling solutions (e.g., optimistic rollups): Ethereum cannot enforce canonical ordering of transactions on optimiums, nor the availability of transaction data, and thus cannot fully guarantee critical safety properties, like finality of transactions. To use the previous example, Bob will find it more difficult to revert the state of an optimistic rollup that stores transaction data on Ethereum and inherits L1 consensus:

- The sequencer submits transaction batches by calling the rollup contract’s batch submission function and attaching the compressed transaction data as calldata to the function call. The light client contract confirms inclusion of the sequencer’s batch submission transaction in a finalized Ethereum block, computes a Merkle hash of the batch, and stores the Merkle root as a commitment to the data.
- Alice creates a fraud proof showing that the block b’ does not correctly extend block _b_ and provides a Merkle proof showing inclusion of the input to the fraud proof (i.e., the block b and state root s) in the canonical rollup chain (the canonical rollup chain is defined by the list of batches stored on L1 and confirmed during Ethereum’s consensus operations). The dispute manager contract can verify Alice’s inputs by checking the Merkle proof against the transaction batch root stored in the light client contract.
- Bob cannot game the dispute protocol this time—this requires reverting the Ethereum blocks containing batch submission transactions from the optimium’s sequencer and rewinding the light client contract to store a different Merkle hash for transaction batches. Without any means to construct an alternate view of history, Bob is guaranteed to lose the challenge once the dispute manager contract re-executes the state transition and confirms Max asserted an invalid state transition.

Decoupling an optimium’s consensus from Ethereum consensus produces a safety failure in the previous example: Alice and Max have different views of the canonical optimium chain. Not inheriting Ethereum’s consensus can also affect liveness in optimium chains. Liveness is a security property that asserts freedom from deadlock: (1) The chain should be capable of progressing by processing transactions and adding blocks. (2) The chain should eventually process transactions from users with bounded delays on execution.

Layer 2 blockchains guarantee (1) by publishing the minimum data required to reconstruct the chain’s state on-chain; if the operator goes offline and refuses to produce a new block, anyone can sync with the tip of the chain by deriving blocks from L1 data and produce a new block to advance the chain. L2s guarantee (2) by implementing an escape hatch: users can force inclusion of transactions by sending a transaction to the validating bridge on L1. If the L2 has a fork-choice rule that requires validators to include all transactions sent on L2, users can rely on Ethereum’s control of the L2 ordering to force-include transactions and circumvent a censoring operator.

For optimiums, liveness depends on either the honesty of sidechain validators or the security of the data availability layer. If N validators are involved in an optimistic sidechain, and a transaction t can be censored as long as a threshold m of validators agree to never finalize a block with t, then `m of n` is the number of validators that need to collude to censor a transaction. The same also holds for a data availability layer that uses validators to order transactions for an optimium chain.

### Data availability

[Data availability](/developers/docs/data-availability/) is the guarantee that transaction data required to verify a block and reproduce the chain’s state is available to network participants. Optimiums implement off-chain data availability, where transaction data is stored with an external authority (a data availability provider) and validators only post succinct cryptographic commitments to outputs of transactions (state roots) on-chain. (For readers familiar with cryptography, this is equivalent to saying Ethereum nodes have access to the **hash** of the root of the optimium's state trie but not the **preimage** of the hash, i.e., the original data committed to using a hash function.) Off-chain data availability provides certain benefits for optimium chains:

- **Higher transaction volumes**: Transaction batches can be arbitrarily large, depending on the capacity of the data availability provider, as transaction data is not published on Ethereum. Conversely, off-chain scaling solutions with on-chain data availability must constrain batches to account for limits on Ethereum’s data bandwidth (e.g., limits on transaction `calldata`).
- **Reduced transaction costs for users**: The cost of storing transaction data on Ethereum is a major operating cost for rollups that publish batches on-chain. Off-chain data availability reduces this cost, which reduces the costs passed on to users interacting with applications in an optimium chain.

However, off-chain data availability also presents significant tradeoffs that affect safety and liveness of optimium chains:

(1). **Safety**: Honest validators may lack access to transaction data required to independently verify changes in state or construct fraud proofs to convince the on-chain light client of an invalid state transition (e.g., Alice cannot create a fraud proof to dispute Max’s invalid state transition from the previous example) if validators or data availability providers withhold data. Malicious actors can revert state updates by reverting the ordering of previously finalized transactions on the external data availability layer.

(2). **Liveness**: Forced transaction inclusion mechanisms for anti-censorship protection rely on the security and decentralization of external data availability layers that store an optimium’s transaction data, not Ethereum. Honest validators cannot produce new blocks if the data availability protocol or sidechain validators withhold data required to sync with the head of the chain.

Besides freezing the chain, performing a data withholding attack can prevent users from withdrawing funds from the optimum’s bridge contract; without access to state data, it is impossible to prove details about the optimium’s state—such as balances of accounts on the sidechain, the inclusion of exit transactions (proof of burn) in finalized blocks—to the bridge contract and process withdrawals.

Layer 2 (L2) chains inherit data availability from Ethereum by publishing the minimum amount of transaction data required to reconstruct the state of the L2 on-chain as calldata. Calldata is not persisted directly in Ethereum’s state, but can be retrieved by retracing historical blocks and downloading the transaction trie of past Ethereum blocks that include batch submission transactions from the L2 operator. This provides stronger guarantees of safety and liveness:

- Watcher nodes, like Alice from the previous example, can derive the data needed to create a fraud proof and assist the L2’s validating bridge in enforcing correctness of state transitions. Alice can also compute the Merkle proof required to prove ownership of funds on the off-chain network or inclusion of exit transactions in a submitted batch without relying on off-chain actors to make the data available.
- Users can rely on Ethereum for anti-censorship protection. Honest nodes can prevent the chain from freezing by deriving blocks from L1 and producing new blocks and submitting state roots that update the on-chain light client’s view of the L2 state. This data is guaranteed to be available as long as the majority of Ethereum’s validators never finalize blocks with unavailable data.

**Note**: L2s in the future will no longer use `calldata` and will instead use ephemeral blobs (pruned after a short period) to store transaction data, so L2 nodes cannot rely on L1 to provide the data required to sync with the L2 chain from genesis. However, the availability of transaction data during the challenge window is arguably more important and Ethereum guarantees that this data will be available if the majority of validators are acting honestly.
Read more on data availability vs. data retrievability.

## A deep dive into the architecture of optimium chains {#optimium-protocol-deep-dive}

The architecture of optimium chains can be divided into two broad categories: the off-chain layer and on-chain layer.

### Off-chain layer in optimium chains

#### Off-chain virtual machine (VM)

Like other [off-chain scaling solutions](/developers/docs/scaling/#off-chain-scaling), optimiums execute transactions in a custom virtual machine separate from the [Ethereum Virtual Machine](/developers/docs/evm/) and store a separate state (contract code and accounts). The off-chain VM is where computation happens and may be described as the secondary/upper layer for an optimium protocol.

#### Sequencers

A sequencer is an optional component that optimium chains use to order transactions and provide fast-path confirmations to users. The sequencer is a full node and maintains a copy of the optimium’s state; transactions are applied to the pending state to provide users with confirmation of the result. A transaction has soft finality if the user trusts the sequencer to include the transaction in a new batch.

![Sequencer-user interaction in optimium chains](sequencer-user-interaction-and-batch-submission.png)

At intervals, the sequencer aggregates transactions into a batch and submits the batch to the optimium’s off-chain data availability layer. Transactions have hard finality once the sequencer receives a certificate from the data availability layer attesting to the availability of the batch’s transaction data and inclusion of the batch in the optimium’s canonical chain.

#### Validators

The sequencer is trusted to propose ordered transactions for execution, but is not responsible for executing transactions. The task of executing transactions and settling transaction results is handled by validators. Validators derive blocks by downloading batches submitted by the sequencer to the optimium’s data availability layer and applying batched transactions to the optimium’s state to compute a new root of the Merkle tree representing the state of accounts and balances in the optimium.

The state root functions as a commitment to the optimium’s (claimed) state and is submitted by the validator to the light client contract on Ethereum. The light client contract cannot directly verify a newly submitted state root asserts a valid state. However, validators are required to bond collateral before asserting a new state—which can be slashed if the proposed state is proven incorrect by another validator during a dispute game.

![Validators deriving optimium blocks by downloading transaction data from DA layer](validator-download-transaction-batch-optimiums.png)

#### Challengers

A challenger or watcher node monitors the optimium chain and tracks submission of state commitments asserting new states to the light client bridge on Ethereum. The challenger’s job is to ensure that invalid state transitions are never finalized by the light client bridge. It does this by re-executing transactions and computing the post-state with the asserted by the block proposer. If the validator’s proposed output conflicts with the challenger’s output, it can publish a fraud proof on-chain and initiate a dispute.

![Challenging submitted block headers on Ethereum](challenging-transaction-batches-on-ethereum.png)

### On-chain layer in optimium chains

While an optimium handles execution of transactions off-chain, other aspects of the network’s operation are outsourced to the Ethereum network. These functions are managed by special-purpose smart contracts deployed on Ethereum and may collectively be described as the primary/base layer.

#### Canonical bridging {#canonical-bridging-in-optimiums}

Optimiums will typically have an enshrined or canonical bridge on Ethereum for transferring assets to and from Ethereum—this is a validating bridge that reads Ethereum’s state and validates the integrity of the optimium chain before processing withdrawals. Applications can integrate with the canonical bridge to implement basic functionality like cross-chain asset transfers (locking and withdrawing tokens), or more advanced features like cross-chain messaging.

Deposits and withdrawals between an optimium and other blockchains apart from Ethereum also pass through the canonical bridge. For example, a user bridging from optimium #1 to optimium #2 needs to withdraw from optimium #1’s canonical bridge on Ethereum and deposit into optimium #2’s bridge to complete the cross-chain bridging operation. Bridging through the optimium’s canonical bridge is usually more secure than third-party bridge solutions as the bridge can reject withdrawals proven invalid by a fraud proof.

![Bridging in optimium chains](optimium-bridging-workflow.png)

#### Dispute resolution {#dispute-resolution-in-optimiums}

Optimiums permit validators to publish claims about off-chains state to Ethereum without providing proofs of validity, with a caveat: anyone can challenge the validity of these claims by publishing a fraud proof on-chain. A fraud proof is a mechanism for proving that the claimed result of a computation is incorrect; fraud proofs can be interactive or non-interactive, depending how many rounds of communication it takes to settle a dispute between the parties involved.

This usually takes the form of a dispute played out on-chain, with the dispute protocol as the arbiter. Fraud proofs guarantee the following properties:

- **Safety with an honest minority of validators**: Invalid transactions are never finalized by the canonical optimium chain, provided an honest full node—with access to data for validating state updates—is monitoring the chain and incentivized to dispute invalid state updates. An honest validator is guaranteed to win against an arbitrary number of dishonest validators publishing false claims about the optimium’s state, if the dispute protocol is sound.
- **Liveness (trust-minimized finality) with an honest minority of validators**: Validly executed transactions are always added to the canonical chain contingent on the soundness of the optimium’s dispute game protocol. Dishonest validators may delay transactions by falsely disputing a block’s validity, but the dispute protocol will reliably identify the dishonest party and ensure the optimium’s light client bridge confirms blocks containing valid transactions eventually.

![Dispute invalid state transitions in optimium chains](challenge-games.png)

Non-interactive (single-round) fraud proving requires replaying the disputed state transition, by which the dispute protocol can check whether the result claimed by the challenger, or the proposer, is correct. A validator is liable to be slashed (with some portion of the bonded collateral going to the honest validator) if it incorrectly asserts the wrong result; a challenger can also be slashed if it provides an invalid fraud proof. This design has two benefits:

- Forcing disputers to bond collateral before initiating a dispute prevents _griefing_ and _discouragement attacks_, where a dishonest challenger initiates false challenges and forces honest validators to waste gas fees on sending on-chain transactions or delays confirmation of transaction results (e.g., which can prevent honest users from exiting funds from the optimium’s bridge).
- Sending a portion of the slashed collateral, as opposed to rewarding the winning party with the entire stake, prevents validators from gaming the dispute arbitration protocol. If two validators collude to initiate bogus challenges, both parties still forfeit a considerable chunk of the combined stake.

Single-round fraud proving is easier to implement, but most optimiums use multi-round (interactive) fraud proving for some reasons: (1) Re-executing transactions on-chain increases on-chain footprint as it requires publishing commitments to post-states for a block’s individual transactions (i.e., intermediate state roots). (2) Replaying transactions on-chain also incurs significant gas costs, and may be infeasible if the gas limit for off-chain transactions exceeds the gas limit on the settlement layer (Ethereum).

Multi-round (interactive) fraud proving requires two validators disputing a state transition to participate in an [interactive verification game](https://dl.acm.org/doi/pdf/10.1145/258533.258644) (a.k.a., a _bisection protocol_) mediated on-chain by the optimium’s dispute manager contract. The bisection protocol requires the challenger and asserter to narrow down the disputed state transition to the smallest instruction (opcode) whose result is disputed by the two parties.

After both parties have narrowed down the disputed state transition to a claim about a single step of execution, the challenger is required to provide a one-step proof—the result of executing the disputed instruction—for verification. The dispute manager contract must re-execute the disputed instruction and evaluate the output to determine which validator is making the right claim about the instruction's execution.

The dispute manager contract only executes a single step of execution to resolve a disputed state transition, which reduces the amount of on-chain computation required to adjudicate a dispute—making multi-round fraud proofs more efficient. The requirement to publish intermediate state tree roots for transactions is also no longer required as the dispute protocol only checks the output of one instruction, not the output of a disputed transaction, to verify a fraud proof.

#### Settlement of transactions

Transactions executed off-chain by block producers in an optimium chain are settled after a commitment to the corresponding block is accepted by an Ethereum contract that stores state commitments (state roots) to the outputs of transactions. The chain of commitments stored in the light client bridge provides a view of the optimium’s finalized states for everyone observing the chain.

### Data availability providers {#data-availability-providers}

Forcing sequencers/validators to submit transaction data to an independent data availability provider is the default approach to mitigating the data availability problem in optimiums. An optimium chain can integrate with different types of data availability providers according to different factors, such as cost, security, and efficiency.

#### Decentralized storage networks

Optimiums may store transaction data on [decentralized storage systems](/developers/docs/storage/) like IPFS (InterPlanetary File System). The assumption is that at least one peer in the network will be available to serve up data requests. However, IPFS—similar to traditional peer-to-peer file storage services, like BitTorrent—are opt-in protocols and do not incentivize participants to persist data for any duration.

Decentralized storage networks may be combined with data availability solutions with stronger guarantees that transaction data will be available during the challenge window for verifiers to validate state transitions. Data availability providers typically discard data after a short period, whereas decentralized storage networks can be used to store transaction data indefinitely. This can help with providing access to historical data (e.g., for syncing the chain or analyzing transaction histories).

#### Data availability committees

A data availability committee (DAC) is a group of trusted entities that accept transaction batches from an optimium’s sequencer and promise to keep the data available for a defined period (a _data availability window_). DAC nodes store state data in servers and expose public API methods that interested parties can use to retrieve transaction data for one or more blocks during the availability window.

Members of the DAC attest to the availability of a block’s transaction data by signing a hash of the block with a public-private keypair. The set of signatures from a quorum (e.g., ⅔) of DAC nodes is aggregated to create a data availability certificate and submitted to the optimium’s light client contract as proof that the underlying data behind a new state commitment is available. The contract verifies the data availability certificate by confirming that the number of signatures from the DAC meets the required threshold and those signatures derived from signing keys of nodes approved to participate in the DAC.

The credible threat of a loss of economic capital and loss of reputational capital provides incentives for data availability committees to make data available during the availability window.

- **Loss of economic capital**: As economically rational actors, DAC nodes may favor the future fee opportunity (payments for storing transaction data) over the short-term gain from performing a data withholding attack. This assumes members of a DAC are compensated for providing data availability and the DAC has a protocol for rotating membership of the data availability committee.
- **Loss of reputational capital**: If members of a DAC are publicly identifiable, the cost of losing reputational capital associated with acting maliciously (e.g., censoring withdrawals by withholding Merkle tree data) provides incentive to make data available. This assumes DAC nodes have proper key management procedures in place and cannot be hijacked by an adversary.

DACs are typically more cost-effective and efficient for optimium chains due to being tailored for specific applications and having lower implementation complexity. However, the aforementioned assumptions underlying the security model of a DAC may be insufficient to guarantee security in edge-case scenarios. Some examples:

- If a particular optimium becomes popular enough, the one-time profit of withholding data and bricking fraud proofs may be high enough to reduce the tradeoff from losing out on future income from fees paid by an optimium’s sequencer to temporarily store data blobs. The lack of a requirement for DAC nodes to bond slashable collateral before attesting to data availability also reduces the economic cost of participating in a data withholding attack.
- An adversary can hijack a DAC and perform a data withholding attack by bribing a set of committee members, or compromising private keys of a quorum of DAC nodes. Both attacks are feasible, especially as DACs typically have a small set of participants to reduce the cost of coordination and reduce complexity of bootstrapping the data availability service.

![Sequencer-DAC interaction in optimium chains](data-availability-committee-sequencer-interaction-optimiums.png)

#### Data availability networks

A data availability network has the same task as a data availability committee (DAC): store transaction batches received from an optimium’s sequencer and provide transaction data to anyone that requests it during the availability window. Notwithstanding this similarity, data availability networks and DACs have significant differences:

- A data availability network is a dedicated blockchain specialized in guaranteeing data availability for execution layers that outsource data availability (e.g., optimiums)—whereas a DAC is a small set of entities running servers. Data availability networks may have a consensus mechanism for nodes to agree on ordering of transaction batches and a token that nodes must stake before joining the network.
- A data availability network is usually larger compared to a data availability committee as entry into the validator set is permissionless (the only requirement to join is provision of bonded collateral); DACs restrict participation to appointed members and are smaller in size.
- Data availability networks have economic incentives for full nodes tasked with keeping data available to act honestly. For example, validators can be slashed for failing to prove possession of transaction data during the availability window, or withholding data from users.

Data availability networks can scale horizontally with data availability sampling. Data availability sampling allows resource-constrained light nodes, which do not download block bodies, to verify availability of block data by randomly sampling a published block—with the probability of a successful data withholding attack reducing as more nodes randomly sample chunks. Allowing light nodes to contribute to the security of the network makes it possible to increase the network’s data bandwidth and storage capacity without centralizing verification of data availability. This contributes to more decentralization in data availability networks and increases security against data withholding attacks for optimiums integrated with a data availability network.

However, using a data availability network has some tradeoffs:

- A data availability network often services multiple blockchains, while DACs are traditionally specific to a particular chain (e.g., members of a DAC may be elected by a DAO with holders of the optimium’s governance token). This may result in higher latency and lower efficiency when trying to retrieve transaction data specific to an optimium chain.
- A data availability network requires higher fees from client applications and is harder to design and implement. For instance, proving data withholding attacks is difficult as a refusal to respond to requests for data is indistinguishable from syncing issues from a third-party observer’s perspective. This problem is described in academic literature as the fisherman’s dilemma

Regardless of the data availability provider adopted by an optimium, it is important to reiterate that storing transaction data outside Ethereum means Ethereum _cannot_ completely guarantee the safety and liveness of an optimium chain. This applies to all off-chain constructions that use fraud proofs to enforce validity of state transitions on-chain, but stores transaction data elsewhere, and does not account for individual security models (or trust assumptions) underlying the external data availability layer.

We will use different implementations of a hypothetical blockchain called AliceChain to illustrate:

##### Scenario #1

1. AliceChain uses a sequencer (or sequencer set) to provide fast-path confirmations to users and propose ordered transaction batches for execution and a set of validators to process transactions. AliceChain validators are not required to come to consensus on validity of blocks and only submit state commitments (block headers) to a light client contract on Ethereum to assert new states for AliceChain.
2. AliceChain implements an on-chain dispute protocol capable of replaying disputed state transitions and verifying fraud proofs from challengers. Withdrawals from the Ethereum side of the AliceChain-Ethereum bridge are delayed for a seven-day period. During this period, a challenger can create a fraud proof to roll back an invalid state asserted by an AliceChain validator.
3. AliceChain uses DataChain (a data availability network) for data availability: the sequencer for AliceChain submits transaction batches to DataChain and collects attestations from DataChain validators to create a data availability proof. A threshold of DataChain validators (staking DATA tokens) must attest to the availability of a block’s transaction data before a new block header is accepted by the light client contract.
4. AliceChain is run by a decentralized autonomous organization (DAO) composed of holders of the governance token $ALICE. AliceDAO members can elect to replace DataChain with another data availability network if DataChain validators withhold data or revert blocks to cause a safety/liveness failure.

##### Scenario #2

1. AliceChain uses a sequencer (or sequencer set) to provide fast-path confirmations to users and propose ordered transaction batches for execution and a set of validators to process transactions. AliceChain validators submit block headers to the on-chain light client contract on Ethereum to settle transactions.
2. AliceChain implements an on-chain dispute protocol capable of replaying disputed state transitions and verifying fraud proofs from challengers. Withdrawals from the Ethereum side of the AliceChain-Ethereum bridge are delayed for a seven-day period. During this period, a challenger can create a fraud proof to roll back an invalid state asserted by an AliceChain validator.
3. AliceChain uses a data availability committee (DAC) for data availability. The sequencer for AliceChain submits transaction batches to the DAC and collects attestations to availability of transaction data from a quorum of DAC nodes to create a proof of data availability. The on-chain light client contract verifies DAC signatures before accepting a new block header.
4. Members of the DAC for AliceChain are elected by AliceDAO. AliceDAO can replace committee members via governance—for example, if DAC nodes refuse to provide data availability attestations (stalling the system as state roots cannot be finalized) or withhold transaction data.

##### Scenario #3

1. AliceChain uses a set of validators to process transactions and implements a Proof of Stake protocol for validators (staking $ALICE tokens) to reach consensus on state transitions. AliceChain does not use an external data availability layer and requires a threshold of validators to attest to the validity of a proposed block and availability of the block’s transaction data.
2. AliceChain implements a light client contract that receives commitments (block headers) to changes in the state of AliceChain. The light client contract verifies that signatures on a block header meet the required threshold for validity conditions specified by AliceChain’s fork-choice rule.
3. AliceChain implements an on-chain dispute protocol (capable of replaying disputed state transitions to verify fraud proofs) and imposes a seven-day delay on withdrawals from the Ethereum side of the bridge. During this period, a challenger can create a fraud proof to roll back an invalid state asserted by a majority of validators on AliceChain.
4. A challenger can also prove unavailability of a block to the on-chain dispute protocol by either forcing the block proposer to publish transaction data on-chain, or creating a fraud proof showing that one or more chunks of a block’s data is unavailable. The dispute protocol slashes the block proposer if it fails to provide transaction data, or the fraud proof passes verification.

##### Scenario #4

1. AliceChain implements one of the previous approaches (storing transaction data with a DAC, data availability network, or a majority of AliceChain validators) with the ability to fall back to posting transaction data if the off-chain data availability provider is malfunctioning. For example, a sequencer can post transaction batches on Ethereum if the DAC or a majority of DataChain validators refuses to provide attestations required for a data availability proof.
2. The light client contract can accept a hash of the transaction batch submitted on-chain by a sequencer/validator as a substitute for data availability attestations from the external data layer. Validators can progress the chain, even with an offline or unresponsive data availability provider, by posting assertions along with a hash of transaction data on Ethereum.

In all four scenarios,AliceChain is an optimium or optimistic sidechain from the perspective of an Ethereum user: Ethereum can indeed enforce validity of state transitions if challengers publish fraud proofs on-chain, but the chain cannot guarantee liveness and safety properties for AliceChain (and the security of funds deposited in the bridge) in all cases. We share some examples for context:

#### Scenario #1: AliceChain uses a data availability committee (DAC) to guarantee data availability

1. **A sequencer can collude with the DAC to stall the system.** The DAC refuses to provide transaction data to create Merkle proofs of state (account balances) or inclusion of exit transactions, and the sequencer refuses to include exit transactions from honest users in transaction batches. The sequencer can stall the system by itself by refusing to create transaction batches for the DAC to approve.
2. **A validator can collude with the DAC to stall the system.** The validator refuses to publish a new state commitment that asserts execution of transactions, and the DAC refuses to release transaction data for honest validators to produce a valid block. The DAC can stall the system by itself by withholding signatures and refusing to attest to availability of a new block.
3. **A validator can collude with the DAC/sequencer to steal funds from the system.** The validator publishes a block header that asserts an invalid state and the DAC/sequencer refuses to release transaction data for challengers to create fraud proofs. The trio of a malicious DAC, validator, and a threshold of AliceDAO members can collude to steal funds—governance cannot kick out the DAC for withholding data required to create fraud proofs.
4. **The duo of a malicious majority of DAC nodes and DAO members can collude to hold users’ funds hostage.** Governance cannot remove members of the DAC for withholding signatures (stalling finalization of blocks that may contain exit transactions), or refusing to provide state data for users to create Merkle proofs of account balances or inclusion of exit transactions in blocks.

#### Scenario #2: AliceChain uses a data availability network to guarantee availability of transaction data

1. **A sequencer can collude with the data availability network to stall the system.** The sequencer and data availability network both withhold transaction data required to create Merkle proofs (of balances and exit transactions) and process bridge withdrawals. The sequencer refuses to create transaction batches, or excludes valid exit transactions from transaction batches. A threshold of malicious validators on the data availability network censor withdrawals by withholding signatures from blocks containing exit transactions and preventing honest validators from creating a data availability certificate.
2. **A validator can collude with the data availability network to stall the system.** The validator refuses to publish a new state commitment that asserts execution of transactions, and the data availability network refuses to release transaction data for honest validators to produce a valid block or attests to unavailable blocks. The data availability network can stall the system by itself by withholding signatures and refusing to attest to availability of a new block.
3. **A validator can collude with the data availability network and sequencer to steal funds from the system.** The validator publishes a block header that asserts an invalid state and the data availability network + sequencer withhold transaction data from challengers to brick fraud proofs. The trio of a malicious optimium validator, a malicious majority of the data availability network’s validators, a malicious threshold of AliceDAO members can collude to steal funds—governance cannot kick out the data availability network for withholding data required to create fraud proofs.
4. **The duo of a malicious majority of validators in a data availability network nodes and DAO members can collude to hold users’ funds hostage.** overnance cannot remove the data availability network for withholding signatures and stalling finalization of blocks (e.g., blocks containing exit transactions), or withholding state data and preventing users from creating Merkle proofs of account balances and exit transactions in blocks required to withdraw deposits from the bridge.
5. **An adversary can create a safety or liveness failure even with light nodes participating in data availability sampling (DAS) on the data availability network.** A collusion among a majority of validators or an economic attack on the staking layer in a data availability network can result in successful data withholding attacks that undermine the security of an optimium that relies on a data availability network.

- The detection of a data withholding attack requires 1/N honesty assumption: provided enough nodes randomly sample a block, an honest full node can reconstruct the original block from sampled chunks and create a fraud proof showing that parts of the block are missing. However, the punishment of data withholding requires a 2⁄3-honesty assumption: a majority of validators staked on the data availability network must sign a block that includes a (valid) fraud proof for an unavailable block.
- If the majority of validators are malicious, the protocol cannot slash validators for publishing and attesting to unavailable blocks. Without the possibility of forcing a slashing of dishonest validators for withholding data, honest nodes have little incentive to create fraud proofs to prove unavailability of transaction data.

5. Fraud proofs of data unavailability can protect light nodes observing the optimium chain. For example, an application running on an optimium chain may stop processing transactions if the application developer runs a light node for the optimium’s data availability network and detects validators are asserting new states on Ethereum without releasing transaction data. However, this can also be a form of griefing or a subtle liveness failure (e.g., preventing operation of applications) and may also lead to more complex attacks on applications with time-sensitive logic (e.g., oracles).

#### Scenario #3: AliceChain uses native PoS staking to guarantee availability of transaction data

1. **An attacker controlling a significant portion of validators can execute a safety failure.** The attacker first creates multiple unavailable blocks, until no one is willing to raise data availability challenges due to the costs of sending on-chain transactions to initiate disputes. The attacker then creates an unavailable block that asserts an invalid state (e.g., minting tokens without collateral deposited in the bridge) and submits the block header on-chain.

- Challengers cannot create a fraud proof to dispute the state transition due to unavailability of transaction data to reproduce the state transition. The light client contract accepts the attacker’s proposed state. The bridge becomes insolvent after running out of funds to pay back deposits from honest users.

2. **A threshold of malicious validators can stall the system by withholding signatures from blocks (which may contain bridge exit transactions).** An honest block proposer cannot progress the chain without the required threshold for attestations on a block header.

- The blockchain’s fork-choice rule will need to either be updated to make attestations unnecessary (fraud proofs guarantee an invalid block can be rejected by the light client contract on Ethereum during the challenge window), or a on-chain governance system implemented to remove unresponsive validators from the consensus protocol. Both solutions require trusting the honesty of the chain’s governance—that is, the holders of $ALICE (if on-chain governance is used) or the majority of validators (if off-chain governance is used, a majority of validators will agree to follow a fork that excludes unresponsive validators).

3. Depending on the optimium’s scaling factor (ratio of block data to block headers), forcing block-producing validators to post data on-chain in response to data availability challenges can reduce the usefulness of optimiums as a scaling solution for Ethereum. As off-chain scaling solutions, the idea is to minimize the amount of state Ethereum must process to guarantee security of bridged funds.

- In a worst-case scenario, such as a malicious validator set producing thousands of unavailable blocks, a massive wave of data availability challenges (triggered by users who want access to transaction data required to create Merkle proofs and exit funds) may cripple Ethereum itself due to the amount of data being posted on-chain. This is reminiscent of the mass exit problem in Plasma.

4. **An adversary can still create a safety or liveness failure even with light nodes participating in data availability sampling (DAS) on the sidechain.** A collusion among a majority of validators or an economic attack on the optimium’s staking layer can result in successful data withholding attacks that undermine the optimium chain’s security.

- The detection of a data withholding attack requires 1/N honesty assumption: provided enough nodes randomly sample a block, an honest full node can reconstruct the original block from sampled chunks and create a fraud proof showing that parts of the block are missing. However, the punishment of data withholding requires a 2⁄3-honesty assumption: a majority of validators staked on the data availability network must sign a block that includes a (valid) fraud proof for an unavailable block.
- If the stakes of an optimium’s validators are managed by a contract on Ethereum, an honest validator can trigger slashing by submitting a fraud proof (of data unavailability) along with a block header with the required threshold of signatures. However, if the majority is malicious and refuses to sign the block containing evidence of data withholding, the protocol cannot slash validators for publishing and attesting to unavailable blocks.
- Without the possibility of forcing a slashing of dishonest validators for withholding data, honest nodes have little incentive to create fraud proofs to prove unavailability of transaction data. This means the light client contract on Ethereum cannot detect unavailability of transaction data for new states asserted by a new block header. Nor can challengers cannot create a fraud proof to prove invalidity of transactions if the block header attests to an incorrect state transition.
- Governance can update the optimium’s fork-choice rule to reduce the threshold of validators required to attest to blocks, make attestations unnecessary (fraud proofs guarantee an invalid block can be rejected by the light client contract on Ethereum during the challenge window), or remove unresponsive validators from the consensus protocol. Each solution requires trusting the optimium chain’s governance—that is, the holders of $ALICE (if on-chain governance is used) or the majority of validators (if off-chain governance is used, a majority of validators will agree to restart the chain without unresponsive validators).

5. Fraud proofs of data unavailability can protect light nodes observing the optimium chain. For example, an application running on an optimium chain may stop processing transactions if the application developer runs a light node for the optimium’s data availability network and detects validators are asserting new states on Ethereum without releasing transaction data. However, this can also be a form of griefing or a subtle liveness failure (e.g., preventing operation of applications) and may also lead to more complex attacks on applications with time-sensitive logic (e.g., oracles).

#### Scenario #4: AliceChain uses a external data availability layer with the ability to fall back to on-chain data availability if data availability provider is malfunctioning

Forcing a sequencer or validator to fall back to posting transaction data on-chain may result in an extremely high increase in operating costs depending on the optimium’s scaling factor (ratio of block bodies to block headers) due to the higher costs of on-chain data availability. Increased operating costs will (inevitably) lead to increased transaction fees. This can make data withholding a form of griefing, especially if ultra-low transaction fees is the dominant motivation for the majority of the optimium’s users.

If optimium users are unable to pay the higher costs of executing transactions, they are effectively stuck in the system without a way to withdraw funds back to Ethereum. These costs include the cost of submitting a batch of exit transactions (borne by the sequencer/validator) and the cost of submitting a state commitment (block header) that attests to the execution of exit transactions (borne by the validator).

This edge case is also why “an optimium with a mechanism for switching to optimistic rollup mode” ≠ “a chain with security guarantees equivalent to a Layer 2 (L2) rollup”. The value of an escape hatch that allows an optimium to switch to optimistic rollup mode (posting transaction data + verifying fraud proofs on-chain) is contingent on the ability of users to cover the costs of publishing exit transactions on-chain and asserting validity of bridge exits.

Moreover, an optimium’s users may be incentivized to pay the escape hatch _once_, but an adversary can continue to create unavailable blocks and withhold data—in collusion with the data availability provider—and force users to continually pay the cost of using the escape hatch to exit funds. This represents an ongoing tax on users and a penalty for using the optimium chain with security guarantees and may contribute to the optimium chain becoming unusable for average users.

## Optimiums FAQs for developers {#optimium-frequently-asked-questions-for-developers}

This section outlines some key details and considerations for Ethereum developers and enterprises interested in building applications on optimum protocols and leveraging the scaling benefits of off-chain computation on optimium chains.

### Interoperability: Are optimium chains interoperable with Ethereum? {#optimiums-and-interoperability-with-Ethereum}

Optimiums usually implement a canonical two-way bridge for moving assets and sending messages from and to Ethereum. Applications can integrate with the canonical bridge to implement token bridging and cross-chain messaging functionality. The canonical bridge offers more security than a third-party bridge as the validity of messages routed through the canonical bridge is tightly coupled with the validity of optimium’s state transitions.

Other details about bridging between an optimium chain and Ethereum Mainnet may be important if you are looking to deploy a version of your Ethereum application on an optimium chain:
(1). Messages sent from Ethereum to an optimium (e.g., a bridging transaction that deposits in the canonical bridge and triggers minting of wrapped assets to the user’s off-chain address) are typically executed after a short delay. Imposing a delay on Ethereum → optimium transactions protects against edge-cases from short-term reorgs on Ethereum.
Messages sent in the reverse direction (from an optimium to Ethereum) are subject to a longer delay on execution due to the challenge window requirement—when sent via the optimium’s canonical bridge. Such messages can be executed only after the corresponding block header attesting to the transaction’s execution validity clears the challenge window without a successful challenge.

(2). Developers should avoid basing execution of smart contracts on Ethereum based on bridging transactions (attested by a validator) until the challenge window has passed. If a block is declared invalid by a fraud proof, transactions in the block are re-executed by a validator that asserts a new (valid) state to replace the previous (invalid) state and revert effects of incorrectly executed transactions on the optimium’s state.

(3). Developers can circumvent the latency associated with bridging transactions by running a full node for an optimium chain (or the optimium’s data availability layer) and re-executing transactions from blocks proposed by validators. Confirming a transaction’s result via re-execution provides assurance that the transaction will not be invalidated by a fraud proof during a dispute.

Valid transactions included in a successfully disputed block are not deleted from the chain; another validator will simply re-execute those transactions and post the correct result in a new assertion. An edge-case may occur if a valid transaction is based on the result of an invalid transaction, but this issue should be obvious while re-executing transaction batches.

Running a full node for an optimium can be useful for building applications, such as _fast mode bridges_, designed to help optimium users sidestep the latency imposed on cross-chain transactions by the challenge window. Fast mode bridges allow users to execute cross-chain transactions immediately in exchange for a fee; for example, a fast mode bridge can offer near-instant withdrawals from an optimium chain to Ethereum.

The fast bridge operator first confirms the validity of a user’s exit transaction by re-executing the block, assumes ownership of the pending withdrawal, and credits the user’s address on Ethereum with an amount equal to the value of the user’s withdrawable deposit in the bridge. Once the block header (attesting to the user’s exit transaction) passes the delay window without a dispute, the bridge operator executes the original withdrawal transaction to reimburse funds paid out to the user.

### Compatibility: Are optimiums EVM-compatible? {#optimiums-and-EVM-compatibility}

Like many Ethereum scaling solutions, optimiums are often designed to run programs written or compiled for the EVM (Ethereum Virtual Machine) and prioritize compatibility with Ethereum infrastructure (e.g., wallets, node services, oracles, and block explorers) and developer tooling (e.g., libraries, client software, and development frameworks). Compatibility with the EVM and Ethereum infrastructure crucial benefits for solo developers and project teams:

- Projects can re-deploy Ethereum smart contracts on an optimium chain without having to rewrite extensive portions of the original codebase—saving valuable engineering time when attempting to migrate to an optimium. This also reduces the risk that a bug will surface due to smart contracts behaving differently from the developer’s intention.
- The freedom to (re)use Ethereum infrastructure and tooling preempts the problem of learning to build applications with an unfamiliar development stack. Compatibility with critical infrastructure also reduces the overhead of integrating with third-party services like wallet applications, block explorers, bridges, and more.

Note that EVM-compatibility does not guarantee applications will always work out-of-the-box. Some optimium chains may implement a custom (optimized) version of the EVM for performance reasons, or design a VM that can execute most EVM opcodes but displays subtle differences in internal behavior (e.g., gas accounting). Both of these have implications for smart contract development, so consider reading through each project’s documentation to understand any differences from Ethereum.

### Transaction fees: How do transaction fees work in optimium chains? {#optimiums-and-transaction-fees}

EVM-compatible optimium chains have a similar gas fee model with Ethereum, where the gas fee for a transaction is the product of the current gas price and the total amount of gas used by the transaction (`gasFee =transactionGasPrice * gasUsed`). But optimium chains also need to account for other factors, such as the cost of gas and data on Ethereum and the cost of using a data availability provider to handle transaction data, to price transactions correctly:

1. **Current price of gas on the optimium**: Similar to Ethereum, optimiums vary the cost of gas according to the level of congestion on the chain and computational resources required to execute a transaction. So, gas prices will sharply increase if a surge in transactions occurs and decrease when transaction activity slows, simple ETH transfers will cost less than token transfers and transactions interacting with smart contracts, etc.
2. **Current price of gas on Ethereum**: Gas costs for processing an Ethereum transaction will vary according to different factors, including the current base_fee and the complexity of a transaction. The price of gas on Ethereum affects the cost borne by the validator when submitting block headers and the sequencer when submitting hashes of transaction batches.
3. **Current price of `calldata` on Ethereum**: Optimiums store hashes of transaction batches and block headers on-chain as`calldata`; `calldata` costs are governed by [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559), which stipulates a cost of 16 gas for non-zero bytes and 4 gas for zero bytes of `calldata`, respectively. Calldata costs influence the cost of submitting state roots and transaction batch roots to Ethereum.
4. **Batch storage (data availability) costs**: If an optimium chains uses a data availability provider (i.e., sequencers and validators are not trusted to make transaction data available), the cost of compensating data availability providers will reflect in transaction fees. Each transaction in a batch may be priced differently depending on how much data it contributes to the total batch. Developers may implement techniques for reducing per-transaction data to reduce costs for users interacting with smart contracts on an optimium chain.

Gas prices may also vary depending on the direction in which an optimium transaction is sent.

- Bridging from Ethereum to an optimium chain will incur the cost of a regular Ethereum transaction. An exception is if the transaction executes a call at the destination chain and users are required to pay upfront for gas consumed by the transaction upon delivery to the optimium).
- Bridging from an optimium chain to Ethereum will incur higher gas costs, even if the transaction is only withdrawing assets (and not executing logic on the destination chain), because two transactions are required in this scenario: one transaction to initiate the exit and another transaction to finalize the withdrawal after the challenge window passes.

#### Comparative advantages: How do optimiums compare to other off-chain scaling solutions? {#optimiums-and-alternative-scaling-solutions}

When comparing off-chain scaling solutions, the important question to ask is: “If a user owns an asset on Ethereum and transfers that asset to the off-chain network via a bridge, what guarantees does the user have that the asset can be transferred back to Ethereum?” A follow-up question is: “What technology choices does the designer of the off-chain protocol make to provide this guarantee (ownership of assets bridged off-chain from Ethereum) and what tradeoffs does this choice impose on users?”

Off-chain scaling solutions can be either _security-favoring_ or _scale-favoring_ depending on answers to both questions. **Security-favoring scaling solutions** provide stronger guarantees of ownership of funds, but trade off a degree of scale. **Scale-favoring scaling solutions** provide weaker guarantees of ownership of assets, but provide higher levels of scalability. The “guarantee a user can withdraw assets to Ethereum” combines different properties (liveness and safety) and security typically correlates to the ability of Ethereum to enforce those properties for the off-chain protocol.

![Scale-favoring vs. security-favoring scalingn solutions](scaling-solutions-infographic.png)

**Optimiums are scale-favoring** and can be compared with other scale-favoring off-chain scaling solutions: validiums, sidechains, Plasma chains, and state channels. Scale-favoring scaling solutions are useful for blockchain applications that have very specific requirements of the underlying blockchain:

- The capacity to process a high number of transactions with low latency—think “5,000 transactions per second” (latency refers to how long it takes for a client to know the result of a transaction and doesn’t account for time-to-finality).
- Low execution costs—think “fractions of a cent ($0.001 or $0.0001) for a transaction”.

Both factors (throughput and transaction fees) are tightly coupled with a blockchain’s network and consensus design; for example, processing more transactions with short delays between blocks requires increasing block size limits and modifying the consensus protocol—if one is used—to reduce the time it takes the network to (collectively) determine and/or agree on the result of a transaction. Those factors also affect transaction fees; bigger blocks translates to more space for transactions and reduced competition among users, which means nodes don’t have to prioritize transactions with higher fees.

Ethereum currently doesn’t meet the aforementioned requirements (high throughput and ultra-low costs) due to its design philosophy—which focuses on decentralization and security at the expense of scalability—although [future upgrades](https://ethereum.org/roadmap) are expected to gradually eliminate this tradeoff and make Ethereum cheaper, faster, and highly secure. Scale-favoring off-chain scaling solutions are able to meet these requirements in the interim by adopting certain technology choices and making certain tradeoffs:

- **Validiums**: A [validium](https://ethereum.org/developers/docs/scaling/validium) is a verifiable sidechain: a blockchain that settles transactions on Ethereum and proves the validity of state transitions with zero-knowledge (validity) proofs. Validity proofs attests to the integrity of computations that produce new state roots and update the on-chain light client’s view of the off-chain state. Validiums store transaction data off-chain, which can affect liveness (users may be unable to interact with the off-chain state if transaction data is unavailable), but validity proofs provide safety against settlement of invalid transactions and enable near-instant withdrawals to Ethereum.
- **Plasma chains**: [Plasma chains](https://ethereum.org/developers/docs/scaling/plasma) enable scalable off-chain computation on Ethereum. A Plasma operator deploys a validating bridge to enable movement of assets to the off-chain protocol and periodic commitments to changes in the Plasma state are checkpointed on-chain via Merkle roots. Plasma chains are identical to optimium chains (off-chain data availability + fraud proofs for security), but lack support for general-purpose computation.
- **State channels**: [State channels](https://ethereum.org/developers/docs/scaling/state-channels) allow participants to securely transact off-chain while keeping interaction with Ethereum Mainnet at a minimum. Channel peers can conduct an arbitrary number of off-chain transactions while only submitting two on-chain transactions to open and close the channel. This allows for extremely high transaction throughput and results in lower costs for users. State channels are limited to applications with predefined participation sets and simple logic and payment channels may suffer from liquidity provision issues.
- **Sidechains**: A [sidechain](https://ethereum.org/developers/docs/scaling/sidechains) is a separate blockchain that runs independently from Ethereum and implements a two-way bridge for moving assets between chains. Sidechains make tradeoffs to improve scalability (throughput and latency), such as keeping transaction data off-chain and implementing a separate consensus protocol to finalize transactions. Pure sidechains provide the most scale for applications, but are entirely responsible for securing assets deposited in bridge contracts.

The following table provides a high-level comparison between optimiums, validiums, Plasma chains, state channels, and sidechains:

| Feature                      | **Optimiums**                                                                                                                                                                                                                              | **Validiums**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **Sidechains**                                                                                                                                                                                                                                                                 | **Plasma**                                                                                                                                                                                               | **State channels**                                                                                                                                                                                                                                                                                                              |     |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| **Security**                 | Security (safety) partially guaranteed by Ethereum with fraud proofs; security model is based on cryptoeconomic incentives for and ability of watchers to dispute invalid state transitions.                                               | Security partially guaranteed by Ethereum with validity proof; safety derives from soundness of cryptographic primitives (e.g., collision-resistance of hash functions used in proof circuits and resistance to preimage attacks) and is not vulnerable to certain economic/game-theoretic attacks faced by fraud-proof based systems.                                                                                                                                                                                | Security (liveness and safety) not guaranteed by Ethereum, especially if a separate consensus mechanism and validator set are used; safety derives from cryptoeconomic incentives for sidechain validators to act honestly.                                                    | Security partially guaranteed by Ethereum with fraud proofs; safety derives from cryptoeconomic incentives for and ability of watchers to dispute invalid state transitions.                             | Security partially guaranteed by Ethereum with fraud proofs; safety derives from cryptoeconomic incentives for and ability of watchers to dispute invalid state updates.                                                                                                                                                        |     |
| **Transaction data storage** | Stores cryptographic commitments to transaction data (block headers) on Ethereum and keeps per-transaction data off-chain.                                                                                                                 | Stores only cryptographic commitments to transaction data (block headers) on Ethereum and keeps per-transaction data off-chain.                                                                                                                                                                                                                                                                                                                                                                                       | Stores cryptographic commitments to transactions (block headers) on Ethereum and keeps per-transaction data off-chain.                                                                                                                                                         | Stores cryptographic commitments to transaction data (block headers) on keeps per-transaction data off-chain                                                                                             | Stores transaction (state) data on-chain during opening and closing phases of a channel, but keeps per-transaction data off-chain otherwise.                                                                                                                                                                                    |     |
| **Data availability**        | Data availability is handled off-chain by validators/sequencers or external data availability providers. Off-chain data availability introduces tradeoffs that potentially affect safety and liveness.                                     | Data availability is handled off-chain by validators/sequencers or external data availability providers. Off-chain data availability introduces tradeoffs that potentially affect safety and liveness.                                                                                                                                                                                                                                                                                                                | Data availability is handled off-chain by sidechain validators or external data availability providers. Off-chain data availability introduces tradeoffs that potentially affect safety and liveness.                                                                          | Data availability is handled off-chain by Plasma operator, users, or external data availability providers. Off-chain data availability introduces tradeoffs that potentially affect safety and liveness. | Data availability is handled off-chain by users (channel participants) or external data availability providers. Off-chain data availability introduces tradeoffs that potentially affect safety and liveness.                                                                                                                   |     |
| **Transaction fees**         | Low transaction fees.                                                                                                                                                                                                                      | Low to moderately high transaction fees (due to added costs of generating validity proofs for blocks)                                                                                                                                                                                                                                                                                                                                                                                                                 | Low transaction fees.                                                                                                                                                                                                                                                          | Low transaction fees.                                                                                                                                                                                    | Extremely low transaction fees.                                                                                                                                                                                                                                                                                                 |     |
| **Settlement + finality**    | Transactions are finalized off-chain by external data availability layer and settled on Ethereum after state commitments are accepted on-chain.                                                                                            | Transactions are finalized by data availability layer and settled on-chain after state roots and validity proofs are accepted on-chain.                                                                                                                                                                                                                                                                                                                                                                               | Transactions are finalized and settled off-chain by a majority of sidechain validators.                                                                                                                                                                                        | Transactions are finalized off-chain by Plasma operator and settled on-chain after state commitments are accepted on-chain.                                                                              | Transactions are finalized off-chain by channel participants and settled on-chain after commitments to channel closing states are accepted on-chain.                                                                                                                                                                            |     |
| **Capital efficiency**       | Low capital efficiency (users must wait for the challenge period (seven days or more) to pass before processing withdrawals on Ethereum).                                                                                                  | High capital efficiency (users can execute withdrawals after a validity proof attesting to exit transactions passes on-chain verification).                                                                                                                                                                                                                                                                                                                                                                           | High capital efficiency (users can withdraw funds from bridge contract once blocks containing exit transactions are approved by sidechain's consensus protocol)                                                                                                                | Low capital efficiency (users must wait for the challenge period (seven days or more) to pass before executing withdrawals on Ethereum).                                                                 | Lower capital efficiency as users must wait for the challenge period (seven days or more) to pass before executing withdrawal transactions on Ethereum.                                                                                                                                                                         |     |
| **Scalability**              | Off-chain data availability enables higher levels of throughput, reduces transaction fees, decreases execution latency for transactions.                                                                                                   | Off-chain data availability enables higher levels of throughput, reduces transaction fees, and decreases execution latency for transactions.                                                                                                                                                                                                                                                                                                                                                                          | Off-chain data availability enables higher levels of throughput, reduces transaction fees, and decreases execution latency for transactions.                                                                                                                                   | Off-chain data availability enables higher levels of throughput, reduces transacdtion fees, and decreases execution latency for transactions.                                                            | Off-chain data availability enables higher levels of throughput, reduces transaction fees, and decreases execution latency for transactions.                                                                                                                                                                                    |     |
| **EVM compatibility**        | High degree of compatibility with EVM programs and Ethereum infrastructure allows developers to re-deploy Ethereum-native smart contracts without extensive software rewrites and use existing tooling/infrastructure to create new dapps. | Varies in support for general-purpose (EVM-compatible) computation and Ethereum infrastructure; specialized languages and tooling/infrastructure may be required to develop applications.                                                                                                                                                                                                                                                                                                                             | Varies in support for EVM computation: EVM-compatible sidechains support smart contracts written in Solidity/Vyper and can share Ethereum tooling and infrastructure; non-EVM sidechains require specialized languages and tooling/infrastructure for application development. | Lacks support for smart contract and cannot support general-purpose EVM computation (only basic token transfers, swaps, and a few other transaction types are supported via predicate logic).            | Limited support for general-purpose (EVM) computation; state channels can execute more generic state transition logic and support off-chain execution of smart contracts, but are limited to applications with predefined/limited participant sets (e.g., two-player games) and cannot support parallel transaction processing. |     |
| **Potential use-cases**      | General-purpose applications with high scalability requirements (extremely low fees, fast confirmation times, and high transaction volumes) and low security needs.                                                                        | General-purpose applications with demands for high transaction volumes, low-to-moderate costs, low latency (fast confirmation times), moderate-to-high security, and in certain cases, privacy of data; examples: supply chain tracking, [decentralized identity](/decentralized-identity/), NFT marketplaces, DeFi applications (crypto-native payments, AMM-based exchanges, derivatives trading, spot trading, etc.), [price oracles](/developers/docs/oracles/#retrieving-financial-data), and on-chain games. \| | General-purpose applications with high scalability requirements (extremely low fees, fast confirmation times, and high transaction volumes) and extremely low security needs.                                                                                                  | Niche applications that offer limited functionality and require scalable execution (extremely low fees, fast confirmation times, and high transaction volumes), and have low security needs.             | Niche applications that offer limited functionality and require scalable execution (extremely low fees, fast confirmation times, and high transaction volumes), and have low security needs.                                                                                                                                    |     |

#### Optimiums vs. rollups {#optimiums-vs-rollups}

Optimiums can be compared to security-favoring off-chain scaling solutions, such as rollups. Rollups publish blocks on Ethereum and inherit consensus and data availability from the Ethereum network, but trade off a degree of scale in return for higher guarantees of security compared to scale-favoring scaling solutions. Rollups are primarily divided into two categories: **optimistic rollups** and **zero-knowledge (validity) rollups**.

- **Optimistic rollups**: [Optimistic rollups](https://ethereum.org/developers/docs/scaling/optimistic-rollups) execute transactions outside of Ethereum, but post transaction data to Ethereum as calldata. Optimistic rollups also use fraud proofs to secure against invalid state transitions like optimiums, but have stronger guarantees of safety and liveness due to Ethereum L1 guaranteeing availability of transaction data required to reproduce off-chain states.
- **Zero-knowledge (validity) rollups**: [ZK-rollups](https://ethereum.org/developers/docs/scaling/zk-rollups) process transactions off-chain, but publish compressed transaction data (raw transaction inputs or state diffs representing transaction outputs) on Ethereum. ZK-rollups use cryptographic proofs to prove validity of state transitions on Ethereum and have better liveness properties than validiums—which use validity proofs, but store transaction data off-chain—due to on-chain data availability.

The following table provides a high-level comparison between optimiums, [ZK-rollups](/developers/docs/scaling/zk-rollups/)) and optimistic rollups.

| Feature                      | **Optimiums**                                                                                                                                                                                                                              | **Zero-Knowledge (Validity) Rollups**                                                                                                                                                                                                                                                                                                                             | **Optimistic rollups**                                                                                                                                                                                                                     |     |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --- |
| **Security**                 | Security (safety) partially guaranteed by Ethereum with fraud proofs; security model is based on cryptoeconomic incentives for and ability of watchers to dispute invalid state transitions.                                               | Security fully guaranteed by Ethereum with validity proofs + on-chain data availability; safety derives from soundness of cryptographic primitives (e.g., collision-resistance of hash functions used in proof circuits and resistance to pre-image attacks) and is not vulnerable to certain economic/game-theoretic attacks faced by fraud-proof based systems. | Security fully guaranteed by Ethereum with fraud proofs + on-chain data availability; safety derives from cryptoeconomic incentives for and ability of watchers to dispute invalid state transitions.                                      |     |
| **Transaction data storage** | Stores cryptographic commitments to transaction data (block headers) on Ethereum and keeps per-transaction data off-chain.                                                                                                                 | Stores per-transaction data on Ethereum (raw transaction inputs or state diffs)                                                                                                                                                                                                                                                                                   | Stores full transaction data on Ethereum                                                                                                                                                                                                   |     |
| **Data availability**        | Data availability is handled off-chain by validators/sequencers or external data availability providers. Off-chain data availability introduces tradeoffs that potentially affect safety and liveness.                                     | Data availability is guaranteed by Ethereum L1. On-chain data availability provides stronger guarantees of safety and liveness.                                                                                                                                                                                                                                   | Data availability is guaranteed by Ethereum L1. On-chain data availability provides stronger guarantees of safety and liveness.                                                                                                            |     |
| **Transaction fees**         | Low transaction fees.                                                                                                                                                                                                                      | Low to moderately high transaction fees (due to added costs of generating validity proofs for blocks and publishing transaction data on-chain)                                                                                                                                                                                                                    | Low to moderately high transaction fees (due to added costs of publishing full transaction data on-chain)                                                                                                                                  |     |
| **Settlement + finality**    | Transactions are finalized off-chain by external data availability layer and settled on Ethereum after state commitments (post-challenge window) are accepted on-chain.                                                                    | Transactions are finalized on Ethereum upon confirmation of transaction batches and settled after state roots + validity proofs are accepted on-chain.                                                                                                                                                                                                            | Transactions are finalized on Ethereum upon confirmation of transaction batches and settled after state roots are accepted (post-challenge window) on-chain.                                                                               |     |
| **Capital efficiency**       | Low capital efficiency (users must wait for the challenge period (seven days or more) to pass before processing withdrawals on Ethereum).                                                                                                  | High capital efficiency (users can execute withdrawals after a validity proof attesting to bridge exit transactions passes on-chain verification).                                                                                                                                                                                                                | Low capital efficiency (users must wait for the challenge period (seven days or more) to pass before executing withdrawals on Ethereum).                                                                                                   |     |
| **Scalability**              | Off-chain data availability enables higher levels of throughput, reduces transaction fees, decreases execution latency for transactions.                                                                                                   | On-chain data availability trades off some degree of scalability for decentralization and security (throughput and execution latency may be limited by Ethereum’s data bandwidth)                                                                                                                                                                                 | On-chain data availability trades off some degree of scalability for decentralization and security (throughput and execution latency may be limited by Ethereum’s data bandwidth)                                                          |     |
| **EVM compatibility**        | High degree of compatibility with EVM programs and Ethereum infrastructure allows developers to re-deploy Ethereum-native smart contracts without extensive software rewrites and use existing tooling/infrastructure to create new dapps. | Varies in support for general-purpose (EVM-compatible) computation and compatibility with Ethereum infrastructure, applications, and tooling; specialized languages and tooling/infrastructure may be required to develop applications in some cases.                                                                                                             | High degree of compatibility with EVM programs and Ethereum infrastructure allows developers to re-deploy Ethereum-native smart contracts without extensive software rewrites and use existing tooling/infrastructure to create new dapps. |     |
| **Potential use-cases**      | General-purpose applications with high scalability requirements (extremely low fees, fast confirmation times, and high transaction volumes) and low security needs.                                                                        | General-purpose applications with with demands for scalability (moderate-to-high transaction volumes, low latency (fast confirmation times), and low-to-moderate costs) and high (Ethereum-level) guarantees of security.                                                                                                                                         | General-purpose applications with with demands for scalability (moderate-to-high transaction volumes, low latency (fast confirmation times), and low-to-moderate costs) and high (Ethereum-level) guarantees of security.                  |     |

## Build dapps on optimiums {#build-dapps-on-optimiums}

Multiple projects provide implementations of optimium that you can integrate into your dapps:

**Arbitrum Nova**: _Nova is an optimium chain based on Arbitrum’s AnyTrust technology. AnyTrust chains like Arbitrum Nova are able to provide lower costs and higher throughput for dapps by relying on a data availability committee (DAC) to store and verify transaction data off-chain instead of storing on L1._

- [Website](https://arbitrum.io/anytrust)
- [Protocol overview](https://docs.arbitrum.io/inside-anytrust)
- [Developer documentation](https://docs.arbitrum.io/for-devs/gentle-introduction-dapps)
- [Technology and risk summary](https://l2beat.com/scaling/projects/nova)

**Metis Andromeda**: _Metis Andromeda is an optimium chain that offers low-fee and high-throughput execution for EVM-compatible smart contracts. Transaction data is stored off-chain with a decentralized storage network (MEMO) and only cryptographic commitments (Merkle roots) to transaction batches and state updates are stored on Ethereum._

- [Website](https://www.metis.io/)
- [Protocol overview](https://docs.metis.io/dev/protocol-in-detail/metis-l2-explained)
- [Developer documentation](https://docs.metis.io/dev/)
- [Technology and risk summary](https://l2beat.com/scaling/projects/metis)

**Mantle**: _Mantle is an EVM-compatible optimium that combines rollup-like technology with a decentralized off-chain data availability to power dapps that offer superior UX, low gas fees, and faster finality. Note that both fraud proof technology and data availability service are still under development (no fault proofs in v1—block proposers are trusted to submit valid state roots—and batches are stored with the sequencer)._

- [Website](https://www.mantle.xyz/)
- [Protocol overview](https://docs.mantle.xyz/network/introduction/overview)
- [Developer documentation](https://docs.mantle.xyz/network/for-devs/developing-on-mantle)
- [Technology and risk summary](https://l2beat.com/scaling/projects/mantle)

## Further reading on optimiums {#further-reading}

- [Data Availability Or: How Rollups Learned To Stop Worrying And Love Ethereum](https://ethereum2077.substack.com/p/data-availability-in-ethereum-rollups)
- [A framework for understanding security properties of sidechains](https://ethresear.ch/t/understanding-sidechains/8045)
- [Optimium, AnyTrust, Sidechain](https://mirror.xyz/0xfa892B19c72c2D2C6B10dFce8Ff8E7a955b58A61/rWTCYr0F7X92vucJ5M4kQPqH4d0O6-bnIm15NkMOv10)
- [Sidechains vs. Rollups: Breaking down the differences for dapp development](https://www.infura.io/blog/post/sidechains-vs-rollups-breaking-down-the-differences-for-dapp-development)
- [What are different types of Layer 2s?](https://vitalik.eth.limo/general/2023/10/31/l2types.html)
- [Exploring the scalability needs for blockchain apps](https://polynya.mirror.xyz/vqdR7FHEzc-lfsWjA88s1uqYqLSgQoWvWm-KN39Zb2M)
- [The Ethereum Off-Chain Data Availability Landscape](https://blog.celestia.org/ethereum-off-chain-data-availability-landscape/)
- [How To—And How Not To—Use Data Availability Committees](https://medium.com/offchainlabs/how-to-and-how-not-to-use-data-availability-committees-394a91e977c0)
- [Do Rollups Inherit Security?](https://dba.xyz/do-rollups-inherit-security/)
