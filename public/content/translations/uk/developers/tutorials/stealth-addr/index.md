---
title: "Використання стелс-адрес"
description: "Стелс-адреси дозволяють користувачам передавати активи анонімно. Прочитавши цю статтю, ви зможете: пояснити, що таке стелс-адреси і як вони працюють, зрозуміти, як використовувати стелс-адреси таким чином, щоб зберегти анонімність, і написати вебзастосунок, який використовує стелс-адреси."
author: "Орі Померанц"
tags:
  [
    "Стелс-адреса",
    "конфіденційність",
    "криптографія",
    "rust",
    "wasm"
  ]
skill: intermediate
published: 2025-11-30
lang: uk
sidebarDepth: 3
---

Ви — Білл. З причин, які ми не будемо розглядати, ви хочете зробити пожертву на кампанію "Аліса за королеву світу" і хочете, щоб Аліса знала, що ви зробили пожертву, щоб вона винагородила вас, якщо переможе. На жаль, її перемога не гарантована. Існує конкуруюча кампанія, "Керол за імператрицю Сонячної системи". Якщо Керол переможе і дізнається, що ви зробили пожертву Алісі, у вас будуть проблеми. Тож ви не можете просто переказати 200 ETH зі свого облікового запису на рахунок Аліси.

[ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) має рішення. Цей ERC пояснює, як використовувати [стелс-адреси](https://nerolation.github.io/stealth-utils) для анонімних переказів.

**Попередження**: криптографія, що лежить в основі стелс-адрес, наскільки нам відомо, надійна. Однак існують потенційні атаки по сторонніх каналах. [Нижче](#go-wrong) ви побачите, що можна зробити, щоб зменшити цей ризик.

## Як працюють стелс-адреси {#how}

У цій статті буде зроблено спробу пояснити стелс-адреси двома способами. Перший — [як їх використовувати](#how-use). Цієї частини достатньо, щоб зрозуміти решту статті. Потім є [пояснення математики, що лежить в основі цього](#how-math). Якщо ви цікавитеся криптографією, прочитайте і цю частину.

### Проста версія (як використовувати стелс-адреси) {#how-use}

Аліса створює два приватних ключі й публікує відповідні відкриті ключі (які можна об'єднати в єдину метаадресу подвійної довжини). Білл також створює приватний ключ і публікує відповідний відкритий ключ.

Використовуючи відкритий ключ однієї сторони та приватний ключ іншої, ви можете отримати спільний секрет, відомий лише Алісі та Біллу (його неможливо отримати лише з відкритих ключів). Використовуючи цей спільний секрет, Білл отримує стелс-адресу і може надсилати на неї активи.

Аліса також отримує адресу зі спільного секрету, але оскільки вона знає приватні ключі до опублікованих нею відкритих ключів, вона також може отримати приватний ключ, який дозволяє їй виводити кошти з цієї адреси.

### Математика (чому стелс-адреси працюють саме так) {#how-math}

Стандартні стелс-адреси використовують [криптографію на еліптичних кривих (ECC)](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/#elliptic-curves-building-blocks-of-a-better-trapdoor) для отримання кращої продуктивності з меншою кількістю бітів ключа, зберігаючи при цьому той самий рівень безпеки. Але здебільшого ми можемо ігнорувати це і вдавати, що використовуємо звичайну арифметику.

Існує число, яке всі знають, _G_. Ви можете множити на _G_. Але через природу ECC практично неможливо ділити на _G_. Криптографія з відкритим ключем в Ethereum зазвичай працює так: ви можете використовувати приватний ключ, _P<sub>priv</sub>_, для підпису транзакцій, які потім перевіряються за допомогою відкритого ключа, _P<sub>pub</sub> = GP<sub>priv</sub>_.

Аліса створює два приватних ключі, _K<sub>priv</sub>_ і _V<sub>priv</sub>_. _K<sub>priv</sub>_ буде використовуватися для витрачання грошей зі стелс-адреси, а _V<sub>priv</sub>_ — для перегляду адрес, що належать Алісі. Потім Аліса публікує відкриті ключі: _K<sub>pub</sub> = GK<sub>priv</sub>_ і _V<sub>pub</sub> = GV<sub>priv</sub>_

Білл створює третій приватний ключ, _R<sub>priv</sub>_, і публікує _R<sub>pub</sub> = GR<sub>priv</sub>_ у центральному реєстрі (Білл міг би також надіслати його Алісі, але ми припускаємо, що Керол підслуховує).

Білл обчислює _R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>_, яке, як він очікує, Аліса також знає (пояснено нижче). Це значення називається _S_, спільний секрет. Це дає Біллу відкритий ключ, _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_. З цього відкритого ключа він може обчислити адресу і надіслати на неї будь-які ресурси, які захоче. У майбутньому, якщо Аліса переможе, Білл може повідомити їй _R<sub>priv</sub>_, щоб довести, що ресурси надійшли від нього.

Аліса обчислює _R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_. Це дає їй той самий спільний секрет, _S_. Оскільки вона знає приватний ключ, _K<sub>priv</sub>_, вона може обчислити _P<sub>priv</sub> = K<sub>priv</sub>+hash(S)_. Цей ключ дає їй доступ до активів за адресою, що є результатом _P<sub>pub</sub> = GP<sub>priv</sub> = GK<sub>priv</sub>+G\*hash(S) = K<sub>pub</sub>+G\*hash(S)_.

Ми маємо окремий ключ перегляду, щоб дозволити Алісі передати субпідряд компанії "Служби світового панування Дейва". Аліса готова повідомити Дейву публічні адреси та інформувати її, коли з’являться додаткові гроші, але вона не хоче, щоб він витрачав гроші її кампанії.

Оскільки для перегляду та витрачання використовуються окремі ключі, Аліса може дати Дейву _V<sub>priv</sub>_. Тоді Дейв може обчислити _S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ і таким чином отримати відкриті ключі (_P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_). Але без _K<sub>priv</sub>_ Дейв не зможе отримати приватний ключ.

Підсумовуючи, це значення, відомі різним учасникам.

| Аліса                                                                     | Опубліковано      | Білл                                                                      | Дейв                                                                        |                                                |
| ------------------------------------------------------------------------- | ----------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------- |
| G                                                                         | G                 | G                                                                         | G                                                                           |                                                |
| _K<sub>priv</sub>_                                                        | —                 | —                                                                         | —                                                                           |                                                |
| _V<sub>priv</sub>_                                                        | —                 | —                                                                         | _V<sub>priv</sub>_                                                          |                                                |
| _K<sub>pub</sub> = GK<sub>priv</sub>_                                     | _K<sub>pub</sub>_ | _K<sub>pub</sub>_                                                         | _K<sub>pub</sub>_                                                           |                                                |
| _V<sub>pub</sub> = GV<sub>priv</sub>_                                     | _V<sub>pub</sub>_ | _V<sub>pub</sub>_                                                         | _V<sub>pub</sub>_                                                           |                                                |
| —                                                                         | —                 | _R<sub>priv</sub>_                                                        | —                                                                           |                                                |
| _R<sub>pub</sub>_                                                         | _R<sub>pub</sub>_ | _R<sub>pub</sub> = GR<sub>priv</sub>_                                     | _R<sub>pub</sub>_                                                           |                                                |
| _S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | —                 | _S = R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | _S = _R<sub>pub</sub>V<sub>priv</sub>_ = GR<sub>priv</sub>V<sub>priv</sub>_ |                                                |
| _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | —                 | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_           |                                                |
| _Адреса=f(P<sub>pub</sub>)_                            | —                 | _Адреса=f(P<sub>pub</sub>)_                            | _Адреса=f(P<sub>pub</sub>)_                              | _Адреса=f(P<sub>pub</sub>)_ |
| _P<sub>priv</sub> = K<sub>priv</sub>+hash(S)_          | —                 | —                                                                         | —                                                                           |                                                |

## Коли зі стелс-адресами щось іде не так {#go-wrong}

_На блокчейні немає секретів_. Хоча стелс-адреси можуть забезпечити вам конфіденційність, ця конфіденційність вразлива до аналізу трафіку. Щоб навести тривіальний приклад, уявіть, що Білл поповнює адресу і негайно надсилає транзакцію для публікації значення _R<sub>pub</sub>_. Без _V<sub>priv</sub>_ Аліси ми не можемо бути впевнені, що це стелс-адреса, але варто робити ставку саме на це. Потім ми бачимо іншу транзакцію, яка переказує всі ETH з цієї адреси на адресу фонду кампанії Аліси. Можливо, ми не зможемо цього довести, але, ймовірно, Білл щойно зробив пожертву на кампанію Аліси. Керол, безперечно, так би й подумала.

Біллу легко відокремити публікацію _R<sub>pub</sub>_ від поповнення стелс-адреси (робити це в різний час, з різних адрес). Однак цього недостатньо. Шаблон, який шукає Керол, полягає в тому, що Білл поповнює адресу, а потім фонд кампанії Аліси виводить з неї кошти.

Одне з рішень полягає в тому, щоб кампанія Аліси не виводила гроші напряму, а використовувала їх для оплати третій стороні. Якщо кампанія Аліси надсилає 10 ETH до "Служб світового панування Дейва", Керол знає лише, що Білл зробив пожертву одному з клієнтів Дейва. Якщо у Дейва достатньо клієнтів, Керол не зможе дізнатися, чи зробив Білл пожертву Алісі, яка з нею конкурує, чи Адаму, Альберту чи Ебігейл, до яких Керол байдужа. Аліса може включити хешоване значення в платіж, а потім надати Дейву прообраз, щоб довести, що це була її пожертва. Як варіант, як зазначалося вище, якщо Аліса дасть Дейву свій _V<sub>priv</sub>_, він уже знатиме, від кого надійшов платіж.

Основна проблема цього рішення полягає в тому, що воно вимагає від Аліси дбати про таємницю, коли ця таємниця вигідна Біллу. Аліса, можливо, захоче зберегти свою репутацію, щоб друг Білла Боб також зробив їй пожертву. Але також можливо, що вона не проти викрити Білла, бо тоді він боятиметься того, що станеться, якщо переможе Керол. Білл може в кінцевому підсумку надати Алісі ще більшу підтримку.

### Використання кількох стелс-шарів {#multi-layer}

Замість того, щоб покладатися на Алісу у збереженні конфіденційності Білла, Білл може зробити це сам. Він може згенерувати кілька мета-адрес для вигаданих людей, Боба та Белли. Потім Білл надсилає ETH Бобу, а "Боб" (який насправді є Біллом) надсилає їх Беллі. "Белла" (також Білл) надсилає їх Алісі.

Керол все ще може проводити аналіз трафіку і бачити ланцюжок від Білла до Боба, до Белли і до Аліси. Однак, якщо "Боб" і "Белла" також використовують ETH для інших цілей, не буде схоже, що Білл щось переказав Алісі, навіть якщо Аліса негайно виведе кошти зі стелс-адреси на свою відому адресу кампанії.

## Написання застосунку зі стелс-адресами {#write-app}

У цій статті пояснюється застосунок зі стелс-адресами, [доступний на GitHub](https://github.com/qbzzt/251022-stealth-addresses.git).

### Інструменти {#tools}

Існує [бібліотека стелс-адрес для typescript](https://github.com/ScopeLift/stealth-address-sdk), яку ми могли б використовувати. Однак криптографічні операції можуть бути інтенсивними для процесора. Я вважаю за краще реалізовувати їх компільованою мовою, такою як [Rust](https://rust-lang.org/), і використовувати [WASM](https://webassembly.org/) для запуску коду в браузері.

Ми будемо використовувати [Vite](https://vite.dev/) та [React](https://react.dev/). Це стандартні інструменти; якщо ви з ними не знайомі, можете скористатися [цим посібником](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/). Щоб використовувати Vite, нам потрібен Node.

### Стелс-адреси в дії {#in-action}

1. Встановіть необхідні інструменти: [Rust](https://rust-lang.org/tools/install/) та [Node](https://nodejs.org/en/download).

2. Клонуйте репозиторій GitHub.

   ```sh
   git clone https://github.com/qbzzt/251022-stealth-addresses.git
   cd 251022-stealth-addresses
   ```

3. Встановіть необхідні компоненти та скомпілюйте код Rust.

   ```sh
   cd src/rust-wasm
   rustup target add wasm32-unknown-unknown   
   cargo install wasm-pack   
   wasm-pack build --target web
   ```

4. Запустіть вебсервер.

   ```sh
   cd ../..
   npm install
   npm run dev
   ```

5. Перейдіть до [застосунку](http://localhost:5173/). Ця сторінка застосунку має два фрейми: один для інтерфейсу користувача Аліси, а інший — для Білла. Два фрейми не взаємодіють; вони знаходяться на одній сторінці лише для зручності.

6. В інтерфейсі Аліси натисніть **Generate a Stealth Meta-Address**. Це відобразить нову стелс-адресу та відповідні приватні ключі. Скопіюйте стелс-метаадресу в буфер обміну.

7. В інтерфейсі Білла вставте нову стелс-метаадресу та натисніть **Generate an address**. Це дасть вам адресу для поповнення для Аліси.

8. Скопіюйте адресу та відкритий ключ Білла і вставте їх у поле "Private key for address generated by Bill" в інтерфейсі користувача Аліси. Щойно ці поля будуть заповнені, ви побачите приватний ключ для доступу до активів за цією адресою.

9. Ви можете скористатися [онлайн-калькулятором](https://iancoleman.net/ethereum-private-key-to-address/), щоб переконатися, що приватний ключ відповідає адресі.

### Як працює програма {#how-the-program-works}

#### Компонент WASM {#wasm}

Вихідний код, який компілюється у WASM, написаний на [Rust](https://rust-lang.org/). Ви можете побачити його в [`src/rust_wasm/src/lib.rs`](https://github.com/qbzzt/251022-stealth-addresses/blob/main/src/rust-wasm/src/lib.rs). Цей код є в першу чергу інтерфейсом між кодом JavaScript та [бібліотекою `eth-stealth-addresses`](https://github.com/kassandraoftroy/eth-stealth-addresses).

**`Cargo.toml`**

[`Cargo.toml`](https://doc.rust-lang.org/cargo/reference/manifest.html) у Rust аналогічний [`package.json`](https://docs.npmjs.com/cli/v9/configuring-npm/package-json) у JavaScript. Він містить інформацію про пакет, оголошення залежностей тощо.

```toml
[package]
name = "rust-wasm"
version = "0.1.0"
edition = "2024"

[dependencies]
eth-stealth-addresses = "0.1.0"
hex = "0.4.3"
wasm-bindgen = "0.2.104"
getrandom = { version = "0.2", features = ["js"] }
```

Пакет [`getrandom`](https://docs.rs/getrandom/latest/getrandom/) потрібен для генерації випадкових значень. Це неможливо зробити суто алгоритмічними засобами; для цього потрібен доступ до фізичного процесу як джерела ентропії. Це визначення вказує, що ми отримаємо цю ентропію, звернувшись до браузера, в якому ми працюємо.

```toml
console_error_panic_hook = "0.1.7"
```

[Ця бібліотека](https://docs.rs/console_error_panic_hook/latest/console_error_panic_hook/) надає нам більш змістовні повідомлення про помилки, коли код WASM панікує і не може продовжувати роботу.

```toml
[lib]
crate-type = ["cdylib", "rlib"]
```

Тип виводу, необхідний для створення коду WASM.

**`lib.rs`**

Це фактичний код Rust.

```rust
use wasm_bindgen::prelude::*;
```

Визначення для створення пакета WASM з Rust. Вони задокументовані [тут](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/index.html).

```rust
use eth_stealth_addresses::{
    generate_stealth_meta_address,
    generate_stealth_address,
    compute_stealth_key
};
```

Функції, які нам потрібні з [бібліотеки `eth-stealth-addresses`](https://github.com/kassandraoftroy/eth-stealth-addresses).

```rust
use hex::{decode,encode};
```

Rust зазвичай використовує байтові [масиви](https://doc.rust-lang.org/std/primitive.array.html) (`[u8; <size>]`) для значень. Але в JavaScript ми зазвичай використовуємо шістнадцяткові рядки. [Бібліотека `hex`](https://docs.rs/hex/latest/hex/) перетворює для нас одне представлення в інше.

```rust
#[wasm_bindgen]
```

Генерувати прив'язки WASM, щоб мати можливість викликати цю функцію з JavaScript.

```rust
pub fn wasm_generate_stealth_meta_address() -> String {
```

Найпростіший спосіб повернути об'єкт з декількома полями — це повернути рядок JSON.

```rust
    let (address, spend_private_key, view_private_key) = 
        generate_stealth_meta_address();
```

[`generate_stealth_meta_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_meta_address.html) повертає три поля:

- Метаадреса (_K<sub>pub</sub>_ та _V<sub>pub</sub>_)
- Приватний ключ перегляду (_V<sub>priv</sub>_)
- Приватний ключ для витрат (_K<sub>priv</sub>_)

Синтаксис [кортежу](https://doc.rust-lang.org/std/primitive.tuple.html) дозволяє нам знову розділити ці значення.

```rust
    format!("{{\"address\":\"{}\",\"view_private_key\":\"{}\",\"spend_private_key\":\"{}\"}}",
        encode(address),
        encode(view_private_key),
        encode(spend_private_key)
    )
}
```

Використовуйте макрос [`format!`](https://doc.rust-lang.org/std/fmt/index.html) для генерації рядка у форматі JSON. Використовуйте [`hex::encode`](https://docs.rs/hex/latest/hex/fn.encode.html) для перетворення масивів у шістнадцяткові рядки.

```rust
fn str_to_array<const N: usize>(s: &str) -> Option<[u8; N]> {
```

Ця функція перетворює шістнадцятковий рядок (наданий JavaScript) у байтовий масив. Ми використовуємо її для розбору значень, наданих кодом JavaScript. Ця функція складна через те, як Rust обробляє масиви та вектори.

Вираз `<const N: usize>` називається [дженеріком](https://doc.rust-lang.org/book/ch10-01-syntax.html). `N` — це параметр, який контролює довжину повернутого масиву. Функція насправді викликається як `str_to_array::<n>`, де `n` — це довжина масиву.

Повернене значення — `Option<[u8; N]>`, що означає, що повернутий масив є [опціональним](https://doc.rust-lang.org/std/option/). Це типовий шаблон у Rust для функцій, які можуть завершитися невдачею.

Наприклад, якщо ми викличемо `str_to_array::10("bad060a7")`, функція повинна повернути масив з десяти значень, але вхідні дані мають лише чотири байти. Функція має завершитися невдачею, і вона це робить, повертаючи `None`. Поверненим значенням для `str_to_array::4("bad060a7")` буде `Some<[0xba, 0xd0, 0x60, 0xa7]>`.

```rust
    // decode повертає Result<Vec<u8>, _>
    let vec = decode(s).ok()?;
```

Функція [`hex::decode`](https://docs.rs/hex/latest/hex/fn.decode.html) повертає `Result<Vec<u8>, FromHexError>`. Тип [`Result`](https://doc.rust-lang.org/std/result/) може містити або успішний результат (`Ok(value)`), або помилку (`Err(error)`).

Метод `.ok()` перетворює `Result` на `Option`, значенням якого є або значення `Ok()`, якщо успішно, або `None`, якщо ні. Нарешті, [оператор знака питання](https://doc.rust-lang.org/std/option/#the-question-mark-operator-) перериває поточну функцію та повертає `None`, якщо `Option` порожній. В іншому випадку він розпаковує значення і повертає його (в цьому випадку, для присвоєння значення `vec`).

Це виглядає як дивно заплутаний метод обробки помилок, але `Result` та `Option` гарантують, що всі помилки обробляються, так чи інакше.

```rust
    if vec.len() != N { return None; }
```

Якщо кількість байтів неправильна, це помилка, і ми повертаємо `None`.

```rust
    // try_into споживає vec і намагається створити [u8; N]
    let array: [u8; N] = vec.try_into().ok()?;
```

Rust має два типи масивів. [Масиви](https://doc.rust-lang.org/std/primitive.array.html) мають фіксований розмір. [Вектори](https://doc.rust-lang.org/std/vec/index.html) можуть рости та зменшуватися. `hex::decode` повертає вектор, але бібліотека `eth_stealth_addresses` очікує отримати масиви. [`.try_into()`](https://doc.rust-lang.org/std/convert/trait.TryInto.html#required-methods) перетворює значення в інший тип, наприклад, вектор у масив.

```rust
    Some(array)
}
```

Rust не вимагає використання ключового слова [`return`](https://doc.rust-lang.org/std/keyword.return.html) при поверненні значення в кінці функції.

```rust
#[wasm_bindgen]
pub fn wasm_generate_stealth_address(stealth_address: &str) -> Option<String> {
```

Ця функція отримує публічну метаадресу, яка включає як _V<sub>pub</sub>_, так і _K<sub>pub</sub>_. Вона повертає стелс-адресу, відкритий ключ для публікації (_R<sub>pub</sub>_) та однобайтове значення сканування, яке прискорює ідентифікацію того, які опубліковані адреси можуть належати Алісі.

Значення сканування є частиною спільного секрету (_S = GR<sub>priv</sub>V<sub>priv</sub>_). Це значення доступне Алісі, і його перевірка набагато швидша, ніж перевірка того, чи _f(K<sub>pub</sub>+G\*hash(S))_ дорівнює опублікованій адресі.

```rust
    let (address, r_pub, scan) = 
        generate_stealth_address(&str_to_array::<66>(stealth_address)?);
```

Ми використовуємо [`generate_stealth_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_address.html) з бібліотеки.

```rust
    format!("{{\"address\":\"{}\",\"rPub\":\"{}\",\"scan\":\"{}\"}}",
        encode(address),
        encode(r_pub),
        encode(&[scan])
    ).into()
}
```

Підготуйте вихідний рядок у форматі JSON.

```rust
#[wasm_bindgen]
pub fn wasm_compute_stealth_key(
    address: &str, 
    bill_pub_key: &str, 
    view_private_key: &str,
    spend_private_key: &str    
) -> Option<String> {
    .
    .
    .
}
```

Ця функція використовує [`compute_stealth_key`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.compute_stealth_key.html) з бібліотеки для обчислення приватного ключа для виведення коштів з адреси (_R<sub>priv</sub>_). Для цього обчислення потрібні такі значення:

- Адреса (_Адреса=f(P<sub>pub</sub>)_)
- Відкритий ключ, згенерований Біллом (_R<sub>pub</sub>_)
- Приватний ключ перегляду (_V<sub>priv</sub>_)
- Приватний ключ для витрат (_K<sub>priv</sub>_)

```rust
#[wasm_bindgen(start)]
```

[ `#[wasm_bindgen(start)]` ](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html) вказує, що функція виконується при ініціалізації коду WASM.

```rust
pub fn main() {
    console_error_panic_hook::set_once();
}
```

Цей код вказує, що вивід паніки надсилається до консолі JavaScript. Щоб побачити це в дії, скористайтеся застосунком і надайте Біллу недійсну мета-адресу (просто змініть одну шістнадцяткову цифру). Ви побачите цю помилку в консолі JavaScript:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs:701:9:
assertion `left == right` failed
  left: 0
 right: 1
```

За цим слідує трасування стека. Потім надайте Біллу дійсну метаадресу, а Алісі — недійсну адресу або недійсний відкритий ключ. Ви побачите таку помилку:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/eth-stealth-addresses-0.1.0/src/lib.rs:78:9:
keys do not generate stealth address
```

Знову ж таки, за цим слідує трасування стека.

#### Інтерфейс користувача {#ui}

Інтерфейс користувача написаний з використанням [React](https://react.dev/) і обслуговується [Vite](https://vite.dev/). Ви можете дізнатися про них з [цього посібника](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/). Тут немає потреби в [WAGMI](https://wagmi.sh/), оскільки ми не взаємодіємо безпосередньо з блокчейном або гаманцем.

Єдиною неочевидною частиною інтерфейсу користувача є підключення WASM. Ось як це працює.

**`vite.config.js`**

Цей файл містить [конфігурацію Vite](https://vite.dev/config/).

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import wasm from "vite-plugin-wasm";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), wasm()],
})
```

Нам потрібно два плагіни Vite: [react](https://www.npmjs.com/package/@vitejs/plugin-react) та [wasm](https://github.com/Menci/vite-plugin-wasm#readme).

**`App.jsx`**

Цей файл є основним компонентом застосунку. Це контейнер, який містить два компоненти: `Alice` та `Bill`, інтерфейси користувача для цих користувачів. Важливою частиною для WASM є код ініціалізації.

```jsx
import init from './rust-wasm/pkg/rust_wasm.js'
```

Коли ми використовуємо [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/), він створює два файли, які ми тут використовуємо: файл wasm із фактичним кодом (тут `src/rust-wasm/pkg/rust_wasm_bg.wasm`) та файл JavaScript із визначеннями для його використання (тут `src/rust-wasm/pkg/rust_wasm.js`). Експорт за замовчуванням цього файлу JavaScript — це код, який потрібно запустити для ініціалізації WASM.

```jsx
function App() {
    .
    .
    .
  useEffect(() => {
    const loadWasm = async () => {
      try {
        await init();
        setWasmReady(true)
      } catch (err) {
        console.error('Помилка завантаження wasm:', err)
        alert("Помилка Wasm: " + err)
      }
    }

    loadWasm()
    }, []
  )
```

Хук [`useEffect`](https://react.dev/reference/react/useEffect) дозволяє вказати функцію, яка виконується при зміні змінних стану. Тут список змінних стану порожній (`[]`), тому ця функція виконується лише один раз при завантаженні сторінки.

Функція ефекту має повернутися негайно. Щоб використовувати асинхронний код, такий як `init` WASM (який має завантажити файл `.wasm` і тому займає час), ми визначаємо внутрішню [`async`](https://en.wikipedia.org/wiki/Async/await) функцію і запускаємо її без `await`.

**`Bill.jsx`**

Це інтерфейс користувача для Білла. Він має одну дію: створення адреси на основі стелс-метаадреси, наданої Алісою.

```jsx
import { wasm_generate_stealth_address } from './rust-wasm/pkg/rust_wasm.js'
```

На додаток до експорту за замовчуванням, код JavaScript, згенерований `wasm-pack`, експортує функцію для кожної функції в коді WASM.

```jsx
            <button onClick={() => {
              setPublicAddress(JSON.parse(wasm_generate_stealth_address(stealthMetaAddress)))
            }}>
```

Щоб викликати функції WASM, ми просто викликаємо функцію, експортовану файлом JavaScript, створеним `wasm-pack`.

**`Alice.jsx`**

Код у `Alice.jsx` аналогічний, за винятком того, що Аліса має дві дії:

- Згенерувати метаадресу
- Отримати приватний ключ для адреси, опублікованої Біллом

## Висновок {#conclusion}

Стелс-адреси — не панацея; їх потрібно [використовувати правильно](#go-wrong). Але при правильному використанні вони можуть забезпечити конфіденційність у публічному блокчейні.

[Більше моїх робіт дивіться тут](https://cryptodocguy.pro/).