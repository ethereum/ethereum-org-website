---
title: ERC-20 із захисними механізмами
description: Як допомогти людям уникнути безглуздих помилок
author: Орі Померанц
lang: uk
tags: [ "erc-20" ]
skill: beginner
published: 2022-08-15
---

## Вступ {#introduction}

Однією з чудових особливостей Ethereum є те, що немає центрального органу, який міг би змінити або скасувати ваші транзакції. Однією з найбільших проблем Ethereum є те, що немає центрального органу, який би мав повноваження скасовувати помилки користувачів або незаконні транзакції. У цій статті ви дізнаєтеся про деякі поширені помилки, яких припускаються користувачі з токенами [ERC-20](/developers/docs/standards/tokens/erc-20/), а також про те, як створювати контракти ERC-20, які допомагають користувачам уникнути цих помилок або які надають центральному органу певні повноваження (наприклад, для заморожування рахунків).

Зауважте, що хоча ми будемо використовувати [контракт токена ERC-20 від OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20), у цій статті він не розглядається детально. Ви можете знайти цю інформацію [тут](/developers/tutorials/erc20-annotated-code).

Якщо ви хочете побачити повний вихідний код:

1. Відкрийте [Remix IDE](https://remix.ethereum.org/).
2. Натисніть на іконку клонування з GitHub (![clone github icon](icon-clone.png)).
3. Клонуйте репозиторій GitHub `https://github.com/qbzzt/20220815-erc20-safety-rails`.
4. Відкрийте **contracts > erc20-safety-rails.sol**.

## Створення контракту ERC-20 {#creating-an-erc-20-contract}

Перш ніж ми зможемо додати функціонал захисних механізмів, нам потрібен контракт ERC-20. У цій статті ми будемо використовувати [Майстер контрактів OpenZeppelin](https://docs.openzeppelin.com/contracts/5.x/wizard). Відкрийте його в іншому браузері та дотримуйтесь цих інструкцій:

1. Виберіть **ERC20**.

2. Введіть ці налаштування:

   | Параметр             | Значення         |
   | -------------------- | ---------------- |
   | Ім’я                 | SafetyRailsToken |
   | Символ               | SAFE             |
   | Premint              | 1000             |
   | Особливості          | Немає            |
   | Контроль доступу     | Ownable          |
   | Можливість оновлення | Немає            |

3. Прокрутіть угору та натисніть **Відкрити в Remix** (для Remix) або **Завантажити**, щоб використовувати інше середовище. Я припускатиму, що ви використовуєте Remix. Якщо ви використовуєте щось інше, просто внесіть відповідні зміни.

4. Тепер у нас є повнофункціональний контракт ERC-20. Ви можете розгорнути `.deps` > `npm`, щоб переглянути імпортований код.

5. Скомпілюйте, розгорніть і пограйтеся з контрактом, щоб переконатися, що він функціонує як контракт ERC-20. Якщо вам потрібно навчитися користуватися Remix, [скористайтеся цим посібником](https://remix.ethereum.org/?#activate=udapp,solidity,LearnEth).

## Поширені помилки {#common-mistakes}

### Помилки {#the-mistakes}

Користувачі іноді надсилають токени на неправильну адресу. Хоча ми не можемо читати їхні думки, щоб знати, що вони мали намір зробити, є два типи помилок, які трапляються часто і які легко виявити:

1. Надсилання токенів на власну адресу контракту. Наприклад, [токену OP від Optimism](https://optimism.mirror.xyz/qvd0WfuLKnePm1Gxb9dpGchPf5uDz5NSMEFdgirDS4c) вдалося накопичити [понад 120 000](https://optimism.blockscout.com/address/0x4200000000000000000000000000000000000042) токенів OP менш ніж за два місяці. Це значна сума, яку, імовірно, люди просто втратили.

2. Надсилання токенів на порожню адресу, яка не відповідає [зовнішньому обліковому запису](/developers/docs/accounts/#externally-owned-accounts-and-key-pairs) або [смартконтракту](/developers/docs/smart-contracts). Хоча я не маю статистики про те, як часто це трапляється, [один інцидент міг коштувати 20 000 000 токенів](https://gov.optimism.io/t/message-to-optimism-community-from-wintermute/2595).

### Запобігання переказам {#preventing-transfers}

Контракт ERC-20 від OpenZeppelin містить [хук `_beforeTokenTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L364-L368), який викликається перед переказом токена. За замовчуванням цей хук нічого не робить, але ми можемо додати до нього власний функціонал, наприклад, перевірки, які скасовують операцію в разі виникнення проблеми.

Щоб використати хук, додайте цю функцію після конструктора:

```solidity
    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal virtual
        override(ERC20)
    {
        super._beforeTokenTransfer(from, to, amount);
    }
```

Деякі частини цієї функції можуть бути новими для вас, якщо ви не дуже добре знайомі з Solidity:

```solidity
        internal virtual
```

Ключове слово `virtual` означає, що так само, як ми успадкували функціонал від `ERC20` і перевизначили цю функцію, інші контракти можуть успадковувати від нашого контракту та перевизначати цю функцію.

```solidity
        override(ERC20)
```

Ми маємо явно вказати, що [перевизначаємо](https://docs.soliditylang.org/en/v0.8.15/contracts.html#function-overriding) визначення `_beforeTokenTransfer` з контракту токена ERC20. Загалом, з точки зору безпеки, явні визначення набагато кращі за неявні — ви не зможете забути, що щось зробили, якщо це прямо перед вами. Це також причина, чому нам потрібно вказувати, `_beforeTokenTransfer` якого суперкласу ми перевизначаємо.

```solidity
        super._beforeTokenTransfer(from, to, amount);
```

Цей рядок викликає функцію `_beforeTokenTransfer` контракту або контрактів, від яких ми успадкували її. У цьому випадку це лише `ERC20`, оскільки `Ownable` не має цього хука. Хоча наразі `ERC20._beforeTokenTransfer` нічого не робить, ми викликаємо його на випадок, якщо в майбутньому буде додано новий функціонал (і ми вирішимо повторно розгорнути контракт, оскільки контракти не змінюються після розгортання).

### Програмування вимог {#coding-the-requirements}

Ми хочемо додати до функції такі вимоги:

- Адреса `to` не може дорівнювати `address(this)`, тобто адресі самого контракту ERC-20.
- Адреса `to` не може бути порожньою, вона має бути одним із таких варіантів:
  - Зовнішній обліковий запис (EOA). Ми не можемо безпосередньо перевірити, чи є адреса EOA, але ми можемо перевірити баланс ETH на цій адресі. EOA майже завжди мають баланс, навіть якщо вони більше не використовуються — їх важко очистити до останнього wei.
  - Смартконтракт. Перевірити, чи є адреса смартконтрактом, трохи складніше. Існує опкод `EXTCODESIZE`, який перевіряє довжину зовнішнього коду, але він недоступний безпосередньо в Solidity. Для цього нам доведеться використовувати [Yul](https://docs.soliditylang.org/en/v0.8.15/yul.html), який є асемблером EVM. Існують інші значення, які ми могли б використовувати з Solidity ([`<address>.code` та `<address>.codehash`](https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#members-of-address-types)), але вони коштують дорожче.

Розгляньмо новий код рядок за рядком:

```solidity
        require(to != address(this), "Неможливо надіслати токени на адресу контракту");
```

Це перша вимога: перевірка, що `to` і `this(address)` не є одним і тим самим.

```solidity
        bool isToContract;
        assembly {
           isToContract := gt(extcodesize(to), 0)
        }
```

Таким чином ми перевіряємо, чи є адреса контрактом. Ми не можемо отримати вивід безпосередньо з Yul, тому замість цього ми визначаємо змінну для зберігання результату (у цьому випадку `isToContract`). Принцип роботи Yul полягає в тому, що кожен опкод розглядається як функція. Отже, спочатку ми викликаємо [`EXTCODESIZE`](https://www.evm.codes/#3b), щоб отримати розмір контракту, а потім використовуємо [`GT`](https://www.evm.codes/#11), щоб перевірити, що він не дорівнює нулю (ми маємо справу з беззнаковими цілими числами, тому, звичайно, він не може бути від’ємним). Потім ми записуємо результат у `isToContract`.

```solidity
        require(to.balance != 0 || isToContract, "Неможливо надіслати токени на порожню адресу");
```

І нарешті, ми маємо власне перевірку на порожні адреси.

## Адміністративний доступ {#admin-access}

Іноді корисно мати адміністратора, який може виправляти помилки. Щоб зменшити потенціал для зловживань, цей адміністратор може бути [мультипідписом (multisig)](https://blog.logrocket.com/security-choices-multi-signature-wallets/), щоб кілька людей мали погодити дію. У цій статті ми розглянемо дві адміністративні функції:

1. Заморожування та розморожування рахунків. Це може бути корисно, наприклад, якщо обліковий запис скомпрометовано.
2. Очищення активів.

   Іноді шахраї надсилають шахрайські токени на контракт справжнього токена, щоб отримати легітимність. Наприклад, [дивіться тут](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe?tab=holders). Легітимний контракт ERC-20 — це [0x4200....0042](https://optimism.blockscout.com/token/0x4200000000000000000000000000000000000042). Шахрайський контракт, що видає себе за нього, — це [0x234....bbe](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe).

   Також можливо, що люди помилково надсилають легітимні токени ERC-20 на наш контракт, що є ще однією причиною мати спосіб їх вивести.

OpenZeppelin надає два механізми для ввімкнення адміністративного доступу:

- Контракти [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/access-control#ownership-and-ownable) мають єдиного власника. Функції, які мають [модифікатор](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm) `onlyOwner`, можуть бути викликані лише цим власником. Власники можуть передати право власності комусь іншому або повністю відмовитися від нього. Права всіх інших облікових записів зазвичай ідентичні.
- Контракти [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/access-control#role-based-access-control) мають [керування доступом на основі ролей (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control).

Для простоти в цій статті ми використовуємо `Ownable`.

### Заморожування та розморожування контрактів {#freezing-and-thawing-contracts}

Заморожування та розморожування контрактів вимагає кількох змін:

- [Відображення (mapping)](https://www.tutorialspoint.com/solidity/solidity_mappings.htm) з адрес на [булеві значення](https://en.wikipedia.org/wiki/Boolean_data_type) для відстеження заморожених адрес. Усі значення спочатку дорівнюють нулю, що для булевих значень інтерпретується як false. Це те, чого ми хочемо, оскільки за замовчуванням рахунки не заморожені.

  ```solidity
      mapping(address => bool) public frozenAccounts;
  ```

- [Події (events)](https://www.tutorialspoint.com/solidity/solidity_events.htm) для інформування всіх зацікавлених, коли рахунок заморожено або розморожено. Технічно кажучи, події не є обов’язковими для цих дій, але вони допомагають коду поза ланцюжком (offchain) прослуховувати ці події та знати, що відбувається. Вважається хорошим тоном, якщо смартконтракт генерує їх, коли відбувається щось, що може бути важливим для когось іншого.

  Події індексуються, тому можна буде шукати всі випадки заморожування або розморожування рахунку.

  ```solidity
    // Коли рахунки заморожуються або розморожуються
    event AccountFrozen(address indexed _addr);
    event AccountThawed(address indexed _addr);
  ```

- Функції для заморожування та розморожування рахунків. Ці дві функції майже ідентичні, тому ми розглянемо лише функцію заморожування.

  ```solidity
      function freezeAccount(address addr)
        public
        onlyOwner
  ```

  Функції, позначені як [`public`](https://www.tutorialspoint.com/solidity/solidity_contracts.htm), можуть викликатися з інших смартконтрактів або безпосередньо через транзакцію.

  ```solidity
    {
        require(!frozenAccounts[addr], "Рахунок уже заморожено");
        frozenAccounts[addr] = true;
        emit AccountFrozen(addr);
    }  // freezeAccount
  ```

  Якщо рахунок уже заморожено, операція скасовується. В іншому випадку, заморозьте його та згенеруйте (`emit`) подію.

- Змініть `_beforeTokenTransfer`, щоб запобігти переміщенню грошей із замороженого рахунку. Зауважте, що гроші все ще можна переказувати на заморожений рахунок.

  ```solidity
       require(!frozenAccounts[from], "Рахунок заморожено");
  ```

### Очищення активів {#asset-cleanup}

Щоб вивільнити токени ERC-20, що зберігаються в цьому контракті, нам потрібно викликати функцію контракту токена, якому вони належать, — або [`transfer`](https://eips.ethereum.org/EIPS/eip-20#transfer), або [`approve`](https://eips.ethereum.org/EIPS/eip-20#approve). У цьому випадку немає сенсу витрачати газ на дозволи (allowances), ми можемо просто переказати їх безпосередньо.

```solidity
    function cleanupERC20(
        address erc20,
        address dest
    )
        public
        onlyOwner
    {
        IERC20 token = IERC20(erc20);
```

Це синтаксис для створення об’єкта для контракту, коли ми отримуємо адресу. Ми можемо це зробити, оскільки у нас є визначення для токенів ERC20 як частина вихідного коду (див. рядок 4), і цей файл містить [визначення для IERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol), інтерфейсу для контракту ERC-20 від OpenZeppelin.

```solidity
        uint balance = token.balanceOf(address(this));
        token.transfer(dest, balance);
    }
```

Це функція очищення, тому, імовірно, ми не хочемо залишати жодних токенів. Замість того, щоб отримувати баланс від користувача вручну, ми можемо автоматизувати цей процес.

## Висновок {#conclusion}

Це не ідеальне рішення — не існує ідеального рішення для проблеми «користувач припустився помилки». Однак використання таких перевірок може принаймні запобігти деяким помилкам. Можливість заморожувати рахунки, хоч і небезпечна, може бути використана для обмеження збитків від певних зламів, позбавляючи хакера вкрадених коштів.

[Більше моїх робіт дивіться тут](https://cryptodocguy.pro/).
