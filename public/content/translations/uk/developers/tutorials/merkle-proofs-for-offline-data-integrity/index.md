---
title: "Докази Меркла для цілісності даних в автономному режимі"
description: "Забезпечення цілісності даних ончейн для даних, які здебільшого зберігаються офчейн"
author: "Орі Померанц"
tags: [ "сховище" ]
skill: advanced
lang: uk
published: 2021-12-30
---

## Вступ {#introduction}

В ідеалі ми хотіли б зберігати все в сховищі Ethereum, яке зберігається на тисячах комп’ютерів і має
надзвичайно високу доступність (дані не можуть бути піддані цензурі) і цілісність (дані не можуть бути змінені
несанкціонованим способом), але зберігання 32-байтового слова зазвичай коштує 20 000 газу. Поки я це пишу, ця вартість
еквівалентна $6,60. При 21 центі за байт це занадто дорого для багатьох застосувань.

Щоб розв'язати цю проблему, екосистема Ethereum розробила [багато альтернативних способів зберігання даних у децентралізований спосіб](/developers/docs/storage/). Зазвичай вони передбачають компроміс між доступністю та ціною. Проте, як правило, цілісність гарантована.

У цій статті ви дізнаєтеся, **як** забезпечити цілісність даних, не зберігаючи їх на блокчейні, за допомогою
[доказів Меркла](https://computersciencewiki.org/index.php/Merkle_proof).

## Як це працює? {#how-does-it-work}

Теоретично ми могли б просто зберігати хеш даних ончейн і надсилати всі дані в транзакціях, які їх потребують. Хоча, це все ще занадто дорого. Байт даних для транзакції коштує близько 16 газів, наразі близько півцента, або близько 5 доларів за кілобайт. При 5000 доларів за мегабайт це все ще занадто дорого для багатьох застосувань, навіть без додаткових витрат на хешування даних.

Рішення полягає в тому, щоб багаторазово хешувати різні підмножини даних, тому для даних, які вам не потрібно надсилати, ви можете просто надіслати хеш. Ви робите це за допомогою дерева Меркла, структуру даних дерева, де кожен вузол є хешем вузлів під ним:

![Дерево Меркла](tree.png)

Кореневий хеш — це єдина частина, яку потрібно зберігати ончейн. Щоб підтвердити певне значення, ви надаєте всі хеші, які потрібно об’єднати з ним для отримання кореня. Наприклад, щоб довести `C`, ви надаєте `D`, `H(A-B)` і `H(E-H)`.

![Доказ значення C](proof-c.png)

## Реалізація {#implementation}

[Приклад коду наведено тут](https://github.com/qbzzt/merkle-proofs-for-offline-data-integrity).

### Офчейн-код {#offchain-code}

У цій статті ми використовуємо JavaScript для офчейн-обчислень. Більшість децентралізованих застосунків мають свій офчейн-компонент, написаний на JavaScript.

#### Створення кореня Меркла {#creating-the-merkle-root}

Спочатку нам потрібно надати ланцюжку корінь Меркла.

```javascript
const ethers = require("ethers")
```

[Ми використовуємо хеш-функцію з пакета ethers](https://docs.ethers.io/v5/api/utils/hashing/#utils-keccak256).

```javascript
// Необроблені дані, цілісність яких ми маємо перевірити. Перші два байти
// є ідентифікатором користувача, а останні два байти — це кількість токенів, якими
// користувач володіє на цей час.
const dataArray = [
  0x0bad0010, 0x60a70020, 0xbeef0030, 0xdead0040, 0xca110050, 0x0e660060,
  0xface0070, 0xbad00080, 0x060d0091,
]
```

Кодування кожного запису в одне 256-бітове ціле число призводить до менш читабельного коду, ніж, наприклад, використання JSON. Однак це означає значно меншу обробку для отримання даних у контракті, тому витрати на газ значно нижчі. [JSON можна читати ончейн](https://github.com/chrisdotn/jsmnSol), але це погана ідея, якщо цього можна уникнути.

```javascript
// Масив хеш-значень у вигляді BigInts
const hashArray = dataArray
```

У цьому випадку наші дані початково є 256-бітними значеннями, тому обробка не потрібна. Якщо ми використовуємо складнішу структуру даних, наприклад рядки, нам потрібно переконатися, що ми спочатку хешуємо дані, щоб отримати масив хешів. Зауважте, що це також тому, що нам байдуже, чи знають користувачі інформацію інших користувачів. Інакше нам довелося б хешувати, щоб користувач 1 не знав значення для користувача 0, користувач 2 не знав би значення для користувача 3 тощо.

```javascript
// Перетворення між рядком, який очікує хеш-функція, та
// BigInt, який ми використовуємо в інших місцях.
const hash = (x) =>
  BigInt(ethers.utils.keccak256("0x" + x.toString(16).padStart(64, 0)))
```

Хеш-функція ethers очікує на отримання рядка JavaScript з шістнадцятковим числом, таким як `0x60A7`, і відповідає іншим рядком з такою ж структурою. Однак для решти коду простіше використовувати `BigInt`, тому ми перетворюємо на шістнадцятковий рядок і назад.

```javascript
// Симетричний хеш пари, тому нам неважливо, якщо порядок буде змінено.
const pairHash = (a, b) => hash(hash(a) ^ hash(b))
```

Ця функція симетрична (хеш від `a` [xor](https://en.wikipedia.org/wiki/Exclusive_or) `b`). Це означає, що коли ми перевіряємо доказ Меркла, нам не потрібно турбуватися про те, чи слід помістити значення з доказу до чи після обчисленого значення. Перевірка доказів Меркла виконується ончейн, тому чим менше нам потрібно там робити, тим краще.

Увага:
Криптографія складніша, ніж здається.
Початкова версія цієї статті мала хеш-функцію `hash(a^b)`.
Це була **погана** ідея, оскільки це означало, що якби ви знали легітимні значення `a` та `b`, ви могли б використати `b' = a^b^a'`, щоб довести будь-яке бажане значення `a'`.
З цією функцією вам доведеться обчислювати `b'` так, щоб `hash(a') ^ hash(b')` дорівнювало відомому значенню (наступній гілці на шляху до кореня), що набагато складніше.

```javascript
// Значення, яке позначає, що певна гілка порожня, не
// має значення
const empty = 0n
```

Коли кількість значень не є цілочисельністю від двох, нам потрібно обробляти порожні гілки. Ця програма робить це таким чином, щоб поставити нуль як заповнювач місця.

![Дерево Меркла з відсутніми гілками](merkle-empty-hash.png)

```javascript
// Обчислюємо наступний рівень дерева масиву хешів, беручи хеш
// кожної пари послідовно
const oneLevelUp = (inputArray) => {
  var result = []
  var inp = [...inputArray] // Щоб уникнути перезапису вхідних даних // Додаємо порожнє значення, якщо необхідно (нам потрібно, щоб усі листки були // спарені)

  if (inp.length % 2 === 1) inp.push(empty)

  for (var i = 0; i < inp.length; i += 2)
    result.push(pairHash(inp[i], inp[i + 1]))

  return result
} // oneLevelUp
```

Ця функція «підіймається» на один рівень у дереві Меркла, хешуючи пари значень на поточному рівні. Зауважте, що це не найефективніша реалізація. Ми могли б уникнути копіювання вхідних даних і просто додати `empty`, коли це доречно в циклі, але цей код оптимізовано для читабельності.

```javascript
const getMerkleRoot = (inputArray) => {
  var result

  result = [...inputArray] // Піднімаємося по дереву, поки не залишиться одне значення, тобто // корінь. // // Якщо рівень має непарну кількість записів, // код у oneLevelUp додає порожнє значення, тому, якщо ми маємо, наприклад, // 10 листків, у нас буде 5 гілок на другому рівні, 3 // гілки на третьому, 2 на четвертому, а корінь — п'ятий

  while (result.length > 1) result = oneLevelUp(result)

  return result[0]
}
```

Щоб отримати корінь, піднімайтеся, поки не залишиться лише одне значення.

#### Створення доказу Меркла {#creating-a-merkle-proof}

Доказ Меркла — це значення для хешування разом із доведеним значенням, щоб отримати корінь Меркла. Значення для доведення часто доступне з інших даних, тому я вважаю за краще надавати його окремо, а не як частину коду.

```javascript
// Доказ Меркла складається зі списку значень елементів для
// хешування. Оскільки ми використовуємо симетричну хеш-функцію, нам не
// потрібно знати місцезнаходження елемента, щоб перевірити доказ, лише щоб його створити
const getMerkleProof = (inputArray, n) => {
    var result = [], currentLayer = [...inputArray], currentN = n

    // Поки не досягнемо вершини
    while (currentLayer.length > 1) {
        // Немає рівнів непарної довжини
        if (currentLayer.length % 2)
            currentLayer.push(empty)

        result.push(currentN % 2
               // Якщо currentN непарне, додаємо до доказу значення, що йому передує
            ? currentLayer[currentN-1]
               // Якщо парне, додаємо наступне значення
            : currentLayer[currentN+1])

```

Ми хешуємо `(v[0],v[1])`, `(v[2],v[3])` і т. д. Отже, для парних значень нам потрібен наступний, для непарних – попередній.

```javascript
        // Переходимо на наступний рівень вище
        currentN = Math.floor(currentN/2)
        currentLayer = oneLevelUp(currentLayer)
    }   // поки currentLayer.length > 1

    return result
}   // getMerkleProof
```

### Ончейн-код {#onchain-code}

Нарешті ми маємо код, який перевіряє доказ. Ончейн-код написано на [Solidity](https://docs.soliditylang.org/en/v0.8.11/). Оптимізація тут набагато важливіша, оскільки газ відносно дорогий.

```solidity
//SPDX-License-Identifier: Public Domain
pragma solidity ^0.8.0;

import "hardhat/console.sol";
```

Я написав це за допомогою [середовища розробки Hardhat](https://hardhat.org/), яке дозволяє нам отримувати [консольний вивід із Solidity](https://hardhat.org/docs/cookbook/debug-logs) під час розробки.

```solidity

contract MerkleProof {
    uint merkleRoot;

    function getRoot() public view returns (uint) {
      return merkleRoot;
    }

    // Надзвичайно небезпечно, у робочому коді доступ до
    // цієї функції ПОВИНЕН БУТИ суворо обмежений, ймовірно, лише
    // власником
    function setRoot(uint _merkleRoot) external {
      merkleRoot = _merkleRoot;
    }   // setRoot
```

Встановіть та отримайте функції для кореня Меркла. Дозволяти будь-кому оновлювати корінь Меркла — це _надзвичайно погана ідея_ в робочій системі. Я роблю це тут заради простоти зразка коду. **Не робіть цього в системі, де цілісність даних справді має значення**.

```solidity
    function hash(uint _a) internal pure returns(uint) {
      return uint(keccak256(abi.encode(_a)));
    }

    function pairHash(uint _a, uint _b) internal pure returns(uint) {
      return hash(hash(_a) ^ hash(_b));
    }
```

Ця функція генерує парний хеш. Це просто переклад коду JavaScript для `hash` та `pairHash` на Solidity.

**Примітка:** це ще один випадок оптимізації для читабельності. На основі [визначення функції](https://www.tutorialspoint.com/solidity/solidity_cryptographic_functions.htm), можливо, вдасться зберігати дані як значення [`bytes32`](https://docs.soliditylang.org/en/v0.5.3/types.html#fixed-size-byte-arrays) та уникнути перетворень.

```solidity
    // Перевірка доказу Меркла
    function verifyProof(uint _value, uint[] calldata _proof)
        public view returns (bool) {
      uint temp = _value;
      uint i;

      for(i=0; i<_proof.length; i++) {
        temp = pairHash(temp, _proof[i]);
      }

      return temp == merkleRoot;
    }

}  // MarkleProof
```

У математичному записі перевірка доказу Меркла виглядає так: `H(proof_n, H(proof_n-1, H(proof_n-2, ...` H(proof_1, H(proof_0, value))...)))`. Цей код реалізує його.

## Докази Меркла та ролапи не поєднуються {#merkle-proofs-and-rollups}

Докази Меркла погано працюють з [ролапами](/developers/docs/scaling/#rollups). Причина в тому, що rollups записують всі дані транзакції на L1, але обробляють на L2. Вартість відправки доказу Меркла з транзакцією в середньому становить 638 газів на шар (наразі байт даних виклику коштує 16 газів, якщо він не дорівнює нулю, і 4, якщо він дорівнює нулю). Якщо у нас є 1024 слова даних, доказ Меркла вимагає десяти шарів, або загалом 6380 газів.

Наприклад, якщо подивитися на [Optimism](https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m), запис на L1 коштує близько 100 gwei газу, а на L2 — 0,001 gwei (це звичайна ціна, яка може зростати при перевантаженні мережі). Отже, на вартість одного газу L1 ми можемо витратити сто тисяч газу на перероблювання L2. Якщо припустити, що ми не перезаписуємо сховище, це означає, що ми можемо написати близько п’яти слів для зберігання на L2 за ціною одного газу L1. Для одного доказу Меркла ми можемо записати всі 1024 слова до сховища (якщо припустити, що їх можна обчислити ончейн, а не надавати в транзакції), і при цьому у нас залишиться більша частина газу.

## Висновок {#conclusion}

У реальному житті ви ніколи не зможете реалізувати дерева Меркла самостійно. Існують добре відомі та перевірені бібліотеки, які ви можете використовувати, і, загалом кажучи, краще не реалізовувати криптографічні примітиви самостійно. Але я сподіваюся, що тепер ви краще розумієте докази Меркла і зможете вирішити, коли їх варто використовувати.

Зауважте, що хоча докази Меркла зберігають _цілісність_, вони не зберігають _доступність_. Знання того, що ніхто інший не може забрати ваші активи, є невеликою втіхою, якщо сховище даних вирішить заборонити доступ, ви також не зможете створити дерево Merkle для доступу до них. Тому дерева Меркла найкраще використовувати з якимось децентралізованим сховищем, таким як IPFS.

[Більше моїх робіт дивіться тут](https://cryptodocguy.pro/).
