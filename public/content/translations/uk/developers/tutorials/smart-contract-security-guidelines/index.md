---
title: "Як захистити смарт-контракти"
description: "Перелік правил безпеки при створенні власного dapp-додатку"
author: "Trailofbits"
tags: [ "мова програмування", "Смарт-контракти", "захист" ]
skill: intermediate
lang: uk
published: 2020-09-06
source: Building secure contracts
sourceUrl: https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/guidelines.md
---

Дотримуйтесь цих загальних рекомендацій для створення безпечніших смарт-контрактів.

## Рекомендації щодо дизайну {#design-guidelines}

Зміст контракту слід обговорювати заздалегідь перед написанням будь-якого рядка коду.

### Документація та специфікації {#documentation-and-specifications}

Документація може бути написана на різних рівнях, і повинна оновлюватись під час реалізації контрактів:

- **Простий опис системи англійською мовою**, в якому описано, що роблять контракти, та будь-які припущення щодо кодової бази.
- **Схема й архітектурні діаграми**, включно з взаємодіями контрактів і скінченним автоматом системи. [Принтери Slither](https://github.com/crytic/slither/wiki/Printer-documentation) можуть допомогти згенерувати ці схеми.
- **Ретельна документація коду**; для Solidity можна використовувати [формат Natspec](https://docs.soliditylang.org/en/develop/natspec-format.html).

### Обчислення on-chain та off-chain {#onchain-vs-offchain-computation}

- **Зберігайте якомога більше коду off-chain.** Рівень on-chain має залишатися невеликим. Попередньо обробляйте дані за допомогою коду off-chain так, щоб верифікація on-chain була простою. Потрібен список замовлень? Відсортуйте список off-chain, і тільки потім перевірте його порядок on-chain.

### Можливість оновлення {#upgradeability}

Ми обговорили різні рішення щодо можливості оновлення в [нашій публікації в блозі](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/). Перш ніж писати будь-який код, зробіть усвідомлений вибір на користь підтримки оновлення чи ні. Це рішення вплине на те, як ви структуруєте свій код. Загалом, ми рекомендуємо:

- **Надавайте перевагу [міграції контрактів](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) перед можливістю оновлення.** Системи міграції мають багато тих самих переваг, що й оновлювані системи, але не мають їхніх недоліків.
- **Використовуйте патерн розділення даних, а не delegatecallproxy.** Якщо у вашому проєкті є чітке розділення абстракції, можливість оновлення за допомогою розділення даних потребуватиме лише кількох коригувань. Delegatecallproxy вимагає показник EVM та є дуже схильним до помилок.
- **Задокументуйте процедуру міграції/оновлення перед розгортанням.** Якщо вам доведеться реагувати в стресовій ситуації без будь-яких інструкцій, ви припуститеся помилок. Заздалегідь створіть методику, якої потрібно дотримуватись. Вона повинна включати в себе:
  - Пропозиції, що ініціюють нові контракти
  - Де зберігаються ключі, а також як їх отримати доступ
  - Як перевірити розгортання! Розробка та перевірка скрипту після розгортання.

## Рекомендації щодо впровадження {#implementation-guidelines}

**Прагніть до простоти.** Завжди використовуйте найпростіше рішення, яке відповідає вашій меті. Кожен член Вашої команди має розуміти Ваше рішення.

### Композиція функцій {#function-composition}

Архітектура Вашої кодової бази полегшить перегляд Вашого коду. Уникайте вибір архітектури, які понижують здатність мислити про його точність.

- **Розділіть логіку вашої системи** або за допомогою кількох контрактів, або шляхом групування подібних функцій (наприклад, автентифікація, арифметика тощо).
- **Пишіть невеликі функції з чіткою метою.** Це полегшить перевірку коду та дозволить тестувати окремі компоненти.

### Успадкування {#inheritance}

- **Слідкуйте, щоб успадкування було керованим.** Успадкування слід використовувати для поділу логіки, однак ваш проєкт має бути спрямований на мінімізацію глибини та ширини дерева успадкування.
- **Використовуйте [принтер успадкування](https://github.com/crytic/slither/wiki/Printer-documentation#inheritance-graph) від Slither для перевірки ієрархії контрактів.** Цей інструмент допоможе вам переглянути розмір ієрархії.

### Події {#events}

- **Записуйте всі важливі операції.** Події допоможуть налагодити контракт під час розробки та відстежувати його після розгортання.

### Уникайте відомих пасток {#avoid-known-pitfalls}

- **Пам'ятайте про найпоширеніші проблеми безпеки.** Існує багато онлайн-ресурсів для вивчення поширених проблем, наприклад [Ethernaut CTF](https://ethernaut.openzeppelin.com/), [Capture the Ether](https://capturetheether.com/) або [Not so smart contracts](https://github.com/crytic/not-so-smart-contracts/).
- **Звертайте увагу на розділи з попередженнями в [документації Solidity](https://docs.soliditylang.org/en/latest/).** У цих розділах міститься інформація про неочевидну поведінку мови.

### Залежності {#dependencies}

- **Використовуйте бібліотеки, які пройшли належну перевірку.** Імпорт коду з таких бібліотек зменшить імовірність того, що ви напишете код із помилками. Якщо ви хочете написати контракт ERC20, використовуйте [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20).
- **Використовуйте менеджер залежностей; уникайте копіювання коду.** Якщо ви покладаєтеся на зовнішнє джерело, то повинні підтримувати його в актуальному стані відповідно до першоджерела.

### Тестування та верифікація {#testing-and-verification}

- **Пишіть ретельні юніт-тести.** Розширений набір тестів має вирішальне значення для створення високоякісного програмного забезпечення.
- **Пишіть власні перевірки та властивості для [Slither](https://github.com/crytic/slither), [Echidna](https://github.com/crytic/echidna) та [Manticore](https://github.com/trailofbits/manticore).** Автоматизовані інструменти допоможуть переконатися, що ваш контракт є безпечним. Перегляньте решту даного посібника, щоб дізнатися як написати ефективні перевірки власного коду та властивостей.
- **Використовуйте [crytic.io](https://crytic.io/).** Crytic інтегрується з GitHub, надає доступ до приватних детекторів Slither і запускає власні перевірки властивостей з Echidna.

### Solidity {#solidity}

- **Надавайте перевагу Solidity 0.5 перед версіями 0.4 та 0.6.** На нашу думку, Solidity 0.5 є безпечнішим і має кращі вбудовані практики, ніж 0.4. Як показує практика, Solidity 0.6 є надто нестабільною для виробництва та потребує часу, щоб бути готовою.
- **Використовуйте стабільний випуск для компіляції; використовуйте останній випуск для перевірки попереджень.** Перевірте, що у вашому коді немає зареєстрованих проблем з останньою версією компілятора. Однак Solidity має швидкий цикл випуску та історію помилок компілятора, тому ми не рекомендуємо останню версію для розгортання (див. [рекомендації щодо версії solc](https://github.com/crytic/slither/wiki/Detector-Documentation#recommendation-33) від Slither).
- **Не використовуйте вбудований асемблер.** Робота з асемблером вимагає глибоких знань EVM. Не пишіть код для EVM, якщо ви досконало не _опанували_ «Жовту книгу».

## Рекомендації щодо розгортання {#deployment-guidelines}

Після розробки та розгортаня контракту:

- **Відстежуйте свої контракти.** Слідкуйте за журналами та будьте готові реагувати в разі компрометації контракту або гаманця.
- **Додайте свою контактну інформацію до списку [blockchain-security-contacts](https://github.com/crytic/blockchain-security-contacts).** Цей список допоможе третім сторонам зв'язатися з вами, якщо буде виявлено вразливість у системі безпеки.
- **Захистіть гаманці привілейованих користувачів.** Дотримуйтесь наших [найкращих практик](https://blog.trailofbits.com/2018/11/27/10-rules-for-the-secure-use-of-cryptocurrency-hardware-wallets/), якщо ви зберігаєте ключі в апаратних гаманцях.
- **Майте план реагування на інциденти.** Враховуйте, що ваші смарт-контракти можуть бути скомпрометовані. Навіть якщо у контрактах немає помилок, зловмисник може зламати приватний ключ.
