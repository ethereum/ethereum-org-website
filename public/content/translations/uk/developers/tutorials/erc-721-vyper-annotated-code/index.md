---
title: "Покроковий опис контракту Vyper ERC-721"
description: Контракт ERC-721 від Рюї Накамури та як він працює
author: Орі Померанц
lang: uk
tags: [ "vyper", "erc-721", "python" ]
skill: beginner
published: 2021-04-01
---

## Вступ {#introduction}

Стандарт [ERC-721](/developers/docs/standards/tokens/erc-721/) використовується для володіння невзаємозамінними токенами (NFT).
Токени [ERC-20](/developers/docs/standards/tokens/erc-20/) поводяться як товар, оскільки між окремими токенами немає різниці.
На відміну від цього, токени ERC-721 призначені для активів, які є подібними, але не ідентичними, як-от різні котячі
мультики або права власності на різні об’єкти нерухомості.

У цій статті ми проаналізуємо [контракт ERC-721 від Рюї Накамури](https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC721.vy).
Цей контракт написано мовою [Vyper](https://vyper.readthedocs.io/en/latest/index.html), контрактною мовою, подібною до Python, яка розроблена, щоб ускладнити написання незахищеного коду, ніж у Solidity.

## Контракт {#contract}

```python
# @dev Реалізація стандарту невзаємозамінних токенів ERC-721.
# @author Рюя Накамура (@nrryuya)
# Змінено з: https://github.com/vyperlang/vyper/blob/de74722bf2d8718cca46902be165f9fe0e3641dd/examples/tokens/ERC721.vy
```

Коментарі у Vyper, як і в Python, починаються з гешу (`#`) і продовжуються до кінця рядка. Коментарі, що містять
`@<keyword>`, використовуються [NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) для створення зручної для читання
документації.

```python
from vyper.interfaces import ERC721

implements: ERC721
```

Інтерфейс ERC-721 вбудовано в мову Vyper.
[Ви можете побачити визначення коду тут](https://github.com/vyperlang/vyper/blob/master/vyper/builtin_interfaces/ERC721.py).
Визначення інтерфейсу написано мовою Python, а не Vyper, оскільки інтерфейси використовуються не тільки в
блокчейні, але й під час надсилання транзакції в блокчейн із зовнішнього клієнта, який може бути написаний
мовою Python.

Перший рядок імпортує інтерфейс, а другий вказує, що ми реалізуємо його тут.

### Інтерфейс ERC721Receiver {#receiver-interface}

```python
# Інтерфейс для контракту, що викликається safeTransferFrom()
interface ERC721Receiver:
    def onERC721Received(
```

ERC-721 підтримує два типи переказів:

- `transferFrom`, який дозволяє відправнику вказати будь-яку адресу призначення та покладає відповідальність
  за переказ на відправника. Це означає, що ви можете зробити переказ на недійсну адресу, і в цьому випадку
  NFT буде втрачено назавжди.
- `safeTransferFrom`, який перевіряє, чи є адреса призначення контрактом. Якщо так, контракт ERC-721
  запитує контракт-одержувач, чи хоче він отримати NFT.

Щоб відповідати на запити `safeTransferFrom`, контракт-одержувач має реалізувати `ERC721Receiver`.

```python
            _operator: address,
            _from: address,
```

Адреса `_from` є поточним власником токена. Адреса `_operator` — це адреса, яка
запросила переказ (вони можуть не збігатися через дозволи).

```python
            _tokenId: uint256,
```

Ідентифікатори токенів ERC-721 мають розмір 256 біт. Зазвичай вони створюються шляхом гешування опису того, що
представляє токен.

```python
            _data: Bytes[1024]
```

Запит може містити до 1024 байт даних користувача.

```python
        ) -> bytes32: view
```

Щоб запобігти випадкам, коли контракт випадково приймає переказ, значення, що повертається, — це не булеве значення,
а 256-бітне значення з певним вмістом.

Ця функція є функцією `view`, що означає, що вона може читати стан блокчейну, але не змінювати його.

### Події {#events}

[Події](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e) генеруються для інформування користувачів і серверів за межами блокчейну про події. Зверніть увагу, що вміст подій
недоступний для контрактів у блокчейні.

```python
# @dev Генерується, коли право власності на будь-який NFT змінюється будь-яким механізмом. Ця подія генерується, коли NFT
#      створюються (`from` == 0) і знищуються (`to` == 0). Виняток: під час створення контракту будь-яка
#      кількість NFT може бути створена та призначена без генерації події Transfer. Під час будь-якого
#      переказу затверджена адреса для цього NFT (якщо така є) скидається на «немає».
# @param _from Відправник NFT (якщо адреса нульова, це вказує на створення токена).
# @param _to Одержувач NFT (якщо адреса нульова, це вказує на знищення токена).
# @param _tokenId NFT, який було передано.
event Transfer:
    sender: indexed(address)
    receiver: indexed(address)
    tokenId: indexed(uint256)
```

Це схоже на подію Transfer в ERC-20, за винятком того, що ми повідомляємо `tokenId` замість суми.
Ніхто не є власником нульової адреси, тому за угодою ми використовуємо її для повідомлення про створення й знищення токенів.

```python
# @dev Генерується, коли затверджена адреса для NFT змінюється або підтверджується. Нульова
#      адреса вказує на відсутність затвердженої адреси. Коли генерується подія Transfer, це також
#      вказує, що затверджена адреса для цього NFT (якщо така є) скидається на «немає».
# @param _owner Власник NFT.
# @param _approved Адреса, яку ми затверджуємо.
# @param _tokenId NFT, який ми затверджуємо.
event Approval:
    owner: indexed(address)
    approved: indexed(address)
    tokenId: indexed(uint256)
```

Затвердження ERC-721 схоже на дозвіл ERC-20. Певна адреса має дозвіл на переказ певного
токена. Це дає контрактам механізм для реагування, коли вони приймають токен. Контракти не можуть
прослуховувати події, тому, якщо ви просто перекажете їм токен, вони про це не «дізнаються». Таким чином, власник спочатку подає затвердження, а потім надсилає запит до контракту: «Я затвердив для вас переказ токена
X, будь ласка, виконайте...».

Це архітектурне рішення, яке робить стандарт ERC-721 схожим на стандарт ERC-20. Оскільки
токени ERC-721 не є взаємозамінними, контракт також може визначити, що він отримав певний токен, перевіривши
право власності на нього.

```python
# @dev Генерується, коли оператора вмикають або вимикають для власника. Оператор може керувати
#      всіма NFT власника.
# @param _owner Власник NFT.
# @param _operator Адреса, для якої ми встановлюємо права оператора.
# @param _approved Статус прав оператора (true, якщо права оператора надано, і false, якщо
# їх скасовано).
event ApprovalForAll:
    owner: indexed(address)
    operator: indexed(address)
    approved: bool
```

Іноді корисно мати _оператора_, який може керувати всіма токенами облікового запису певного типу (тими, якими керує
певний контракт), подібно до довіреності. Наприклад, я можу захотіти надати такі повноваження контракту, який перевіряє, чи
я не контактував з ним протягом шести місяців, і якщо так, розподіляє мої активи між моїми спадкоємцями (якщо один з них попросить про це, контракти
нічого не можуть зробити, поки їх не викличе транзакція). У ERC-20 ми можемо просто надати великий дозвіл контракту на успадкування,
але це не працює для ERC-721, оскільки токени не є взаємозамінними. Це еквівалент.

Значення `approved` говорить нам, чи є подія затвердженням, чи скасуванням затвердження.

### Змінні стану {#state-vars}

Ці змінні містять поточний стан токенів: які з них доступні й кому вони належать. Більшість з них — це об’єкти `HashMap`, [односпрямовані зіставлення, які існують між двома типами](https://vyper.readthedocs.io/en/latest/types.html#mappings).

```python
# @dev Зіставлення ID NFT з адресою його власника.
idToOwner: HashMap[uint256, address]

# @dev Зіставлення ID NFT із затвердженою адресою.
idToApprovals: HashMap[uint256, address]
```

Ідентифікатори користувачів і контрактів в Ethereum представлені 160-бітними адресами. Ці дві змінні зіставляють
ID токенів з їхніми власниками та тими, хто має дозвіл на їх переказ (максимум один на кожен токен). В Ethereum
неініціалізовані дані завжди дорівнюють нулю, тому, якщо немає власника або затвердженого відправника, значення для цього токена
дорівнює нулю.

```python
# @dev Зіставлення адреси власника з кількістю його токенів.
ownerToNFTokenCount: HashMap[address, uint256]
```

Ця змінна містить кількість токенів для кожного власника. Немає зіставлення власників із токенами, тому
єдиний спосіб ідентифікувати токени, якими володіє певний власник, — це переглянути історію подій блокчейну
та знайти відповідні події `Transfer`. Ми можемо використовувати цю змінну, щоб знати, коли ми знайшли всі NFT, і нам не
потрібно дивитися ще далі в минуле.

Зверніть увагу, що цей алгоритм працює тільки для інтерфейсів користувачів і зовнішніх серверів. Код, що виконується в самому
блокчейні, не може читати минулі події.

```python
# @dev Зіставлення адреси власника із зіставленням адрес операторів.
ownerToOperators: HashMap[address, HashMap[address, bool]]
```

Обліковий запис може мати більше одного оператора. Простого `HashMap` недостатньо, щоб
відстежувати їх, оскільки кожен ключ веде до одного значення. Натомість можна використовувати
`HashMap[address, bool]` як значення. За замовчуванням значення для кожної адреси — `False`, що означає, що вона
не є оператором. За потреби можна встановити значення на `True`.

```python
# @dev Адреса карбувальника, який може карбувати токени
minter: address
```

Нові токени мають бути створені якимось чином. У цьому контракті є одна сутність, якій дозволено це робити, —
`minter`. Цього, ймовірно, буде достатньо, наприклад, для гри. Для інших цілей може знадобитися
створити складнішу бізнес-логіку.

```python
# @dev Зіставлення ID інтерфейсу з булевим значенням, що вказує на його підтримку
supportedInterfaces: HashMap[bytes32, bool]

# @dev ID інтерфейсу ERC165 для ERC165
ERC165_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000001ffc9a7

# @dev ID інтерфейсу ERC165 для ERC721
ERC721_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000080ac58cd
```

[ERC-165](https://eips.ethereum.org/EIPS/eip-165) визначає механізм, за допомогою якого контракт може розкривати, як додатки
можуть з ним взаємодіяти, і яким стандартам ERC він відповідає. У цьому випадку контракт відповідає стандартам ERC-165 та ERC-721.

### Функції {#functions}

Це функції, які фактично реалізують ERC-721.

#### Конструктор {#constructor}

```python
@external
def __init__():
```

У Vyper, як і в Python, функція-конструктор називається `__init__`.

```python
    """
    @dev Конструктор контракту.
    """
```

У Python і Vyper ви також можете створити коментар, вказавши багаторядковий рядок (який починається і закінчується
`"""`), і не використовувати його жодним чином. Ці коментарі також можуть містити
[NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html).

```python
    self.supportedInterfaces[ERC165_INTERFACE_ID] = True
    self.supportedInterfaces[ERC721_INTERFACE_ID] = True
    self.minter = msg.sender
```

Щоб отримати доступ до змінних стану, використовуйте \`self.<ім’я змінної>\`\` (знову ж таки, як і в Python).

#### Функції перегляду {#views}

Це функції, які не змінюють стан блокчейну, і тому можуть виконуватися
безплатно, якщо вони викликаються ззовні. Якщо функції перегляду викликаються контрактом, вони все одно повинні виконуватися на
кожному вузлі, отже, коштуватимуть газ.

```python
@view
@external
```

Ці ключові слова перед визначенням функції, які починаються зі знака «собачка» (`@`), називаються _декораторами_. Вони
визначають обставини, за яких можна викликати функцію.

- `@view` вказує, що ця функція є функцією перегляду.
- `@external` вказує, що ця конкретна функція може викликатися транзакціями та іншими контрактами.

```python
def supportsInterface(_interfaceID: bytes32) -> bool:
```

На відміну від Python, Vyper є [мовою зі статичною типізацією](https://wikipedia.org/wiki/Type_system#Static_type_checking).
Ви не можете оголосити змінну або параметр функції без визначення типу
даних. У цьому випадку вхідним параметром є `bytes32`, 256-бітне значення
(256 біт — це розмір нативного слова [віртуальної машини Ethereum](/developers/docs/evm/)). Вихідне значення — це булеве
значення. За угодою, імена параметрів функції починаються з символу підкреслення (`_`).

```python
    """
    @dev Ідентифікація інтерфейсу вказана в ERC-165.
    @param _interfaceID ID інтерфейсу
    """
    return self.supportedInterfaces[_interfaceID]
```

Повертає значення з HashMap `self.supportedInterfaces`, яке встановлюється в конструкторі (`__init__`).

```python
### ФУНКЦІЇ ПЕРЕГЛЯДУ ###
```

Існують функції перегляду, які роблять інформацію про токени доступною для користувачів та інших контрактів.

```python
@view
@external
def balanceOf(_owner: address) -> uint256:
    """
    @dev Повертає кількість NFT, що належать `_owner`.
         Видає помилку, якщо `_owner` є нульовою адресою. NFT, призначені нульовій адресі, вважаються недійсними.
    @param _owner Адреса, для якої потрібно запитати баланс.
    """
    assert _owner != ZERO_ADDRESS
```

Цей рядок [стверджує](https://vyper.readthedocs.io/en/latest/statements.html#assert), що `_owner` не є
нульовим. Якщо це так, то виникає помилка, і операція скасовується.

```python
    return self.ownerToNFTokenCount[_owner]

@view
@external
def ownerOf(_tokenId: uint256) -> address:
    """
    @dev Повертає адресу власника NFT.
         Видає помилку, якщо `_tokenId` не є дійсним NFT.
    @param _tokenId Ідентифікатор NFT.
    """
    owner: address = self.idToOwner[_tokenId]
    # Видає помилку, якщо `_tokenId` не є дійсним NFT
    assert owner != ZERO_ADDRESS
    return owner
```

У віртуальній машині Ethereum (EVM) будь-яке сховище, в якому не зберігається значення, дорівнює нулю.
Якщо за адресою `_tokenId` немає токена, то значення `self.idToOwner[_tokenId]` дорівнює нулю. У такому
випадку функція скасовується.

```python
@view
@external
def getApproved(_tokenId: uint256) -> address:
    """
    @dev Отримати затверджену адресу для одного NFT.
         Видає помилку, якщо `_tokenId` не є дійсним NFT.
    @param _tokenId ID NFT, для якого потрібно запитати затвердження.
    """
    # Видає помилку, якщо `_tokenId` не є дійсним NFT
    assert self.idToOwner[_tokenId] != ZERO_ADDRESS
    return self.idToApprovals[_tokenId]
```

Зверніть увагу, що `getApproved` _може_ повертати нуль. Якщо токен дійсний, він повертає `self.idToApprovals[_tokenId]`.
Якщо немає затверджувача, це значення дорівнює нулю.

```python
@view
@external
def isApprovedForAll(_owner: address, _operator: address) -> bool:
    """
    @dev Перевіряє, чи є `_operator` затвердженим оператором для `_owner`.
    @param _owner Адреса, яка володіє NFT.
    @param _operator Адреса, яка діє від імені власника.
    """
    return (self.ownerToOperators[_owner])[_operator]
```

Ця функція перевіряє, чи дозволено `_operator` керувати всіма токенами `_owner` у цьому контракті.
Оскільки може бути декілька операторів, це дворівнева HashMap.

#### Допоміжні функції переказу {#transfer-helpers}

Ці функції реалізують операції, які є частиною передачі або управління токенами.

```python

### ДОПОМІЖНІ ФУНКЦІЇ ПЕРЕКАЗУ ###

@view
@internal
```

Цей декоратор, `@internal`, означає, що функція доступна тільки з інших функцій у межах того ж контракту. За угодою, назви цих функцій також починаються з символу підкреслення (`_`).

```python
def _isApprovedOrOwner(_spender: address, _tokenId: uint256) -> bool:
    """
    @dev Повертає, чи може даний витрачальник передати даний ID токена
    @param spender адреса витрачальника для запиту
    @param tokenId uint256 ID токена, який потрібно передати
    @return bool чи затверджено msg.sender для даного ID токена,
        чи є він оператором власника, чи є власником токена
    """
    owner: address = self.idToOwner[_tokenId]
    spenderIsOwner: bool = owner == _spender
    spenderIsApproved: bool = _spender == self.idToApprovals[_tokenId]
    spenderIsApprovedForAll: bool = (self.ownerToOperators[owner])[_spender]
    return (spenderIsOwner or spenderIsApproved) or spenderIsApprovedForAll
```

Існує три способи, за допомогою яких адреса може отримати дозвіл на передачу токена:

1. Адреса є власником токена
2. Адреса затверджена для витрачання цього токена
3. Адреса є оператором для власника токена

Наведена вище функція може бути функцією перегляду, тому що вона не змінює стан. Щоб зменшити операційні витрати, будь-яка
функція, яка _може_ бути функцією перегляду, _повинна_ нею бути.

```python
@internal
def _addTokenTo(_to: address, _tokenId: uint256):
    """
    @dev Додати NFT до даної адреси
         Видає помилку, якщо `_tokenId` належить комусь.
    """
    # Видає помилку, якщо `_tokenId` належить комусь
    assert self.idToOwner[_tokenId] == ZERO_ADDRESS
    # Змінити власника
    self.idToOwner[_tokenId] = _to
    # Змінити відстеження кількості
    self.ownerToNFTokenCount[_to] += 1


@internal
def _removeTokenFrom(_from: address, _tokenId: uint256):
    """
    @dev Видалити NFT з даної адреси
         Видає помилку, якщо `_from` не є поточним власником.
    """
    # Видає помилку, якщо `_from` не є поточним власником
    assert self.idToOwner[_tokenId] == _from
    # Змінити власника
    self.idToOwner[_tokenId] = ZERO_ADDRESS
    # Змінити відстеження кількості
    self.ownerToNFTokenCount[_from] -= 1
```

Коли виникає проблема з переказом, ми скасовуємо виклик.

```python
@internal
def _clearApproval(_owner: address, _tokenId: uint256):
    """
    @dev Очистити затвердження для даної адреси
         Видає помилку, якщо `_owner` не є поточним власником.
    """
    # Видає помилку, якщо `_owner` не є поточним власником
    assert self.idToOwner[_tokenId] == _owner
    if self.idToApprovals[_tokenId] != ZERO_ADDRESS:
        # Скинути затвердження
        self.idToApprovals[_tokenId] = ZERO_ADDRESS
```

Змінюйте значення тільки в разі необхідності. Змінні стану зберігаються в сховищі. Запис у сховище —
одна з найдорожчих операцій, які виконує EVM (віртуальна машина Ethereum) (з точки зору
[газу](/developers/docs/gas/)). Тому рекомендується звести його до мінімуму, оскільки навіть запис
наявного значення має високу вартість.

```python
@internal
def _transferFrom(_from: address, _to: address, _tokenId: uint256, _sender: address):
    """
    @dev Виконати переказ NFT.
         Видає помилку, якщо `msg.sender` не є поточним власником, авторизованим оператором або затвердженою
         адресою для цього NFT. (ПРИМІТКА: `msg.sender` не дозволено у приватній функції, тому передайте `_sender`.)
         Видає помилку, якщо `_to` є нульовою адресою.
         Видає помилку, якщо `_from` не є поточним власником.
         Видає помилку, якщо `_tokenId` не є дійсним NFT.
    """
```

Ми маємо цю внутрішню функцію, оскільки існує два способи передачі токенів (звичайний і безпечний), але
ми хочемо мати лише одне місце в коді, де ми це робимо, щоб полегшити аудит.

```python
    # Перевірка вимог
    assert self._isApprovedOrOwner(_sender, _tokenId)
    # Видає помилку, якщо `_to` є нульовою адресою
    assert _to != ZERO_ADDRESS
    # Очистити затвердження. Видає помилку, якщо `_from` не є поточним власником
    self._clearApproval(_from, _tokenId)
    # Видалити NFT. Видає помилку, якщо `_tokenId` не є дійсним NFT
    self._removeTokenFrom(_from, _tokenId)
    # Додати NFT
    self._addTokenTo(_to, _tokenId)
    # Зареєструвати переказ
    log Transfer(_from, _to, _tokenId)
```

Щоб згенерувати подію у Vyper, використовуйте оператор `log` ([докладніше тут](https://vyper.readthedocs.io/en/latest/event-logging.html#event-logging)).

#### Функції переказу {#transfer-funs}

```python

### ФУНКЦІЇ ПЕРЕКАЗУ ###

@external
def transferFrom(_from: address, _to: address, _tokenId: uint256):
    """
    @dev Видає помилку, якщо `msg.sender` не є поточним власником, авторизованим оператором або затвердженою
         адресою для цього NFT.
         Видає помилку, якщо `_from` не є поточним власником.
         Видає помилку, якщо `_to` є нульовою адресою.
         Видає помилку, якщо `_tokenId` не є дійсним NFT.
    @notice Той, хто викликає, несе відповідальність за підтвердження того, що `_to` здатний отримувати NFT, інакше
            вони можуть бути назавжди втрачені.
    @param _from Поточний власник NFT.
    @param _to Новий власник.
    @param _tokenId NFT, який потрібно переказати.
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

Ця функція дозволяє здійснювати переказ на довільну адресу. Якщо адреса не є адресою користувача або контракту, який
знає, як передавати токени, будь-який переданий вами токен застрягне на цій адресі й стане марним.

```python
@external
def safeTransferFrom(
        _from: address,
        _to: address,
        _tokenId: uint256,
        _data: Bytes[1024]=b""
    ):
    """
    @dev Передає право власності на NFT з однієї адреси на іншу.
         Видає помилку, якщо `msg.sender` не є поточним власником, авторизованим оператором або
         затвердженою адресою для цього NFT.
         Видає помилку, якщо `_from` не є поточним власником.
         Видає помилку, якщо `_to` є нульовою адресою.
         Видає помилку, якщо `_tokenId` не є дійсним NFT.
         Якщо `_to` — це смарт-контракт, він викликає `onERC721Received` для `_to` і видає помилку, якщо
         повернуте значення не дорівнює `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
         ПРИМІТКА: bytes4 представлено як bytes32 із доповненням
    @param _from Поточний власник NFT.
    @param _to Новий власник.
    @param _tokenId NFT, який потрібно переказати.
    @param _data Додаткові дані без зазначеного формату, що надсилаються у виклику до `_to`.
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

Можна спочатку виконати переказ, тому що, якщо виникне проблема, ми все одно скасуємо операцію,
тому все, що було зроблено під час виклику, буде скасовано.

```python
    if _to.is_contract: # перевірка, чи є `_to` адресою контракту
```

Спочатку перевірте, чи є адреса контрактом (тобто чи має вона код). Якщо ні, припустімо, що це адреса користувача, і користувач зможе використовувати токен або передати його. Але не дозволяйте цьому заколисувати вас
хибним почуттям безпеки. Ви можете втратити токени, навіть із `safeTransferFrom`, якщо ви перекажете
їх на адресу, до якої ніхто не знає приватного ключа.

```python
        returnValue: bytes32 = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data)
```

Зверніться до цільового контракту, щоб дізнатися, чи може він отримувати токени ERC-721.

```python
        # Видає помилку, якщо адресат переказу є контрактом, який не реалізує 'onERC721Received'
        assert returnValue == method_id("onERC721Received(address,address,uint256,bytes)", output_type=bytes32)
```

Якщо адресатом є контракт, але той, який не приймає токени ERC-721 (або який вирішив не приймати цей
конкретний переказ), скасуйте його.

```python
@external
def approve(_approved: address, _tokenId: uint256):
    """
    @dev Встановити або підтвердити затверджену адресу для NFT. Нульова адреса вказує на відсутність затвердженої адреси.
         Видає помилку, якщо `msg.sender` не є поточним власником NFT або авторизованим оператором поточного власника.
         Видає помилку, якщо `_tokenId` не є дійсним NFT. (ПРИМІТКА: це не описано в EIP)
         Видає помилку, якщо `_approved` є поточним власником. (ПРИМІТКА: це не описано в EIP)
    @param _approved Адреса, яка буде затверджена для даного ID NFT.
    @param _tokenId ID токена, який потрібно затвердити.
    """
    owner: address = self.idToOwner[_tokenId]
    # Видає помилку, якщо `_tokenId` не є дійсним NFT
    assert owner != ZERO_ADDRESS
    # Видає помилку, якщо `_approved` є поточним власником
    assert _approved != owner
```

За угодою, якщо ви не хочете мати затверджувача, ви призначаєте нульову адресу, а не свою.

```python
    # Перевірка вимог
    senderIsOwner: bool = self.idToOwner[_tokenId] == msg.sender
    senderIsApprovedForAll: bool = (self.ownerToOperators[owner])[msg.sender]
    assert (senderIsOwner or senderIsApprovedForAll)
```

Щоб встановити схвалення, ви можете бути або власником, або оператором, уповноваженим власником.

```python
    # Встановити затвердження
    self.idToApprovals[_tokenId] = _approved
    log Approval(owner, _approved, _tokenId)


@external
def setApprovalForAll(_operator: address, _approved: bool):
    """
    @dev Вмикає або вимикає затвердження для третьої сторони («оператора») для управління всіма
         активами `msg.sender`. Також генерує подію ApprovalForAll.
         Видає помилку, якщо `_operator` є `msg.sender`. (ПРИМІТКА: це не описано в EIP)
    @notice Це працює, навіть якщо відправник не володіє жодними токенами на даний момент.
    @param _operator Адреса для додавання до набору авторизованих операторів.
    @param _approved True, якщо оператор затверджений, false, щоб скасувати затвердження.
    """
    # Видає помилку, якщо `_operator` є `msg.sender`
    assert _operator != msg.sender
    self.ownerToOperators[msg.sender][_operator] = _approved
    log ApprovalForAll(msg.sender, _operator, _approved)
```

#### Карбування нових токенів і знищення наявних {#mint-burn}

Обліковий запис, який створив контракт, є `minter` — суперкористувачем, якому дозволено карбувати
нові NFT. Однак, навіть йому не дозволяється знищувати наявні токени. Це може зробити тільки власник або уповноважена власником
особа.

```python
### ФУНКЦІЇ КАРБУВАННЯ ТА СПАЛЮВАННЯ ###

@external
def mint(_to: address, _tokenId: uint256) -> bool:
```

Ця функція завжди повертає `True`, тому що в разі збою операція скасовується.

```python
    """
    @dev Функція для карбування токенів
         Видає помилку, якщо `msg.sender` не є карбувальником.
         Видає помилку, якщо `_to` є нульовою адресою.
         Видає помилку, якщо `_tokenId` належить комусь.
    @param _to Адреса, яка отримає викарбувані токени.
    @param _tokenId Ідентифікатор токена для карбування.
    @return Булеве значення, яке вказує, чи була операція успішною.
    """
    # Видає помилку, якщо `msg.sender` не є карбувальником
    assert msg.sender == self.minter
```

Тільки карбувальник (обліковий запис, що створив контракт ERC-721) може карбувати нові токени. Це може стати
проблемою в майбутньому, якщо ми захочемо змінити особу карбувальника. У
робочому контракті вам, ймовірно, знадобиться функція, що дозволяє карбувальнику передавати його привілеї комусь іншому.

```python
    # Видає помилку, якщо `_to` є нульовою адресою
    assert _to != ZERO_ADDRESS
    # Додати NFT. Видає помилку, якщо `_tokenId` належить комусь
    self._addTokenTo(_to, _tokenId)
    log Transfer(ZERO_ADDRESS, _to, _tokenId)
    return True
```

За угодою, карбування нових токенів вважається переказом із нульової адреси.

```python

@external
def burn(_tokenId: uint256):
    """
    @dev Спалює певний токен ERC721.
         Видає помилку, якщо `msg.sender` не є поточним власником, авторизованим оператором або затвердженою
         адресою для цього NFT.
         Видає помилку, якщо `_tokenId` не є дійсним NFT.
    @param _tokenId uint256 id токена ERC721, який потрібно спалити.
    """
    # Перевірка вимог
    assert self._isApprovedOrOwner(msg.sender, _tokenId)
    owner: address = self.idToOwner[_tokenId]
    # Видає помилку, якщо `_tokenId` не є дійсним NFT
    assert owner != ZERO_ADDRESS
    self._clearApproval(owner, _tokenId)
    self._removeTokenFrom(owner, _tokenId)
    log Transfer(owner, ZERO_ADDRESS, _tokenId)
```

Будь-хто, кому дозволено передавати токен, може його спалити. Хоча спалювання здається еквівалентним
переказу на нульову адресу, нульова адреса фактично не отримує токен. Це дозволяє нам
звільнити все сховище, яке використовувалося для токена, що може знизити вартість транзакції.

## Використання цього контракту {#using-contract}

На відміну від Solidity, Vyper не має успадкування. Це навмисний вибір архітектури, щоб зробити
код більш зрозумілим і, отже, більш безпечним. Отже, щоб створити свій власний контракт Vyper ERC-721, ви берете цей
контракт і змінюєте його
для реалізації потрібної вам бізнес-логіки.

## Висновок {#conclusion}

Для повторення, ось деякі з найважливіших ідей цього контракту:

- Щоб отримувати токени ERC-721 за допомогою безпечного переказу, контракти повинні реалізувати інтерфейс `ERC721Receiver`.
- Навіть якщо ви використовуєте безпечний переказ, токени все одно можуть застрягти, якщо ви відправите їх на адресу, приватний ключ
  до якої невідомий.
- Коли виникає проблема з операцією, краще `скасувати` виклик, а не просто повертати
  значення збою.
- Токени ERC-721 існують, коли у них є власник.
- Існує три способи отримати дозвіл на передачу NFT. Ви можете бути власником, бути затвердженим для певного токена
  або бути оператором для всіх токенів власника.
- Минулі події видно тільки за межами блокчейну. Код, що виконується всередині блокчейну, не може їх переглядати.

Тепер переходьте до реалізації безпечних контрактів Vyper.

[Більше моїх робіт дивіться тут](https://cryptodocguy.pro/).

