---
title: Розуміння специфікацій EVM у Yellow Paper
description: Розуміння частини Yellow Paper, формальної специфікації Ethereum, яка пояснює віртуальну машину Ethereum (EVM).
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: uk
published: 15.05.2022
---

[Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) — це формальна специфікація для Ethereum. За винятком випадків, коли вносяться зміни в [процесі EIP](/eips/), він містить точний опис того, як все працює. Він написаний як математична праця, яка містить термінологію, незнайому для програмістів. У цій статті ви дізнаєтеся, як її читати, а отже, й інші пов’язані математичні праці.

## Який Yellow Paper? {#which-yellow-paper}

Як і майже все інше в Ethereum, Yellow Paper з часом розвивається. Щоб мати змогу посилатися на конкретну версію, я завантажив [поточну версію на момент написання статті](yellow-paper-berlin.pdf). Номери розділів, сторінок і рівнянь, які я використовую, стосуватимуться цієї версії. Радимо відкрити його в іншому вікні під час читання цього документа.

### Навіщо EVM? {#why-the-evm}

Оригінальний yellow paper був написаний на самому початку розробки Ethereum. Він описує оригінальний механізм консенсусу на основі підтвердження роботи (proof-of-work), який спочатку використовувався для захисту мережі. Однак у вересні 2022 року Ethereum відмовився від підтвердження роботи (proof-of-work) і почав використовувати консенсус на основі доказу частки (proof-of-stake). Цей посібник буде зосереджений на частинах yellow paper, що визначають віртуальну машину Ethereum. EVM не зазнала змін унаслідок переходу на доказ частки (proof-of-stake) (за винятком значення, що повертається опкодом DIFFICULTY).

## 9 Модель виконання {#9-execution-model}

Цей розділ (с. 12–14) містить більшу частину визначення EVM.

Термін _стан системи_ охоплює все, що потрібно знати про систему для її роботи. У звичайному комп’ютері це означає пам’ять, вміст регістрів тощо.

[Машина Тюрінга](https://en.wikipedia.org/wiki/Turing_machine) — це обчислювальна модель. По суті, це спрощена версія комп’ютера, для якої доведено, що вона має таку саму здатність виконувати обчислення, як і звичайний комп’ютер (усе, що може обчислити комп’ютер, може обчислити й машина Тюрінга, і навпаки). Ця модель полегшує доведення різних теорем про те, що є обчислюваним, а що — ні.

Термін [повнота за Тюрінгом](https://en.wikipedia.org/wiki/Turing_completeness) означає комп’ютер, який може виконувати ті самі обчислення, що й машина Тюрінга. Машини Тюрінга можуть зациклюватися, а EVM — ні, тому що в неї закінчиться газ, тому вона лише квазіповна за Тюрінгом.

## 9.1 Основи {#91-basics}

У цьому розділі наведено основи EVM і її порівняння з іншими обчислювальними моделями.

[Стекова машина](https://en.wikipedia.org/wiki/Stack_machine) — це комп’ютер, який зберігає проміжні дані не в регістрах, а в [**стеку**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)). Це пріоритетна архітектура для віртуальних машин, оскільки її легко реалізувати, а це означає, що помилки та вразливості безпеки є набагато менш імовірними. Пам’ять у стеку поділена на 256-бітові слова. Такий вибір було зроблено, оскільки це зручно для основних криптографічних операцій Ethereum, як-от хешування Keccak-256 та обчислення на еліптичних кривих. Максимальний розмір стека — 1024 елементи (1024 x 256 біт). Коли виконуються опкоди, вони зазвичай отримують свої параметри зі стека. Існують опкоди спеціально для реорганізації елементів у стеку, як-от `POP` (видаляє елемент із вершини стека), `DUP_N` (дублює N-й елемент у стеку) тощо.

EVM також має енергозалежний простір, який називається **пам’яттю**, що використовується для зберігання даних під час виконання. Ця пам’ять організована у вигляді 32-байтових слів. Усі комірки пам’яті ініціалізуються нулем. Якщо ви виконаєте цей код [Yul](https://docs.soliditylang.org/en/latest/yul.html), щоб додати слово до пам’яті, він заповнить 32 байти пам’яті, доповнивши порожній простір у слові нулями, тобто він створює одне слово — з нулями в комірках 0-29, 0x60 у комірці 30 і 0xA7 у комірці 31.

```yul
mstore(0, 0x60A7)
```

`mstore` — один із трьох опкодів, які EVM надає для взаємодії з пам’яттю — він завантажує слово в пам’ять. Два інші — `mstore8`, який завантажує один байт у пам’ять, та `mload`, який переміщує слово з пам’яті до стека.

EVM також має окрему енергонезалежну модель **сховища**, яка підтримується як частина стану системи — ця пам’ять організована у вигляді масивів слів (на відміну від байтових масивів у стеку, що адресуються за словами). У цьому сховищі контракти зберігають постійні дані — контракт може взаємодіяти лише з власним сховищем. Сховище організоване у вигляді зіставлень «ключ-значення».

Хоча це не згадується в цьому розділі Yellow Paper, корисно знати, що існує і четвертий тип пам’яті. **Calldata** — це пам’ять лише для читання з байтовою адресацією, яка використовується для зберігання значення, переданого з параметром `data` транзакції. EVM має спеціальні опкоди для керування `calldata`. `calldatasize` повертає розмір даних. `calldataload` завантажує дані в стек. `calldatacopy` копіює дані в пам’ять.

Стандартна [архітектура фон Неймана](https://en.wikipedia.org/wiki/Von_Neumann_architecture) зберігає код і дані в одній пам’яті. EVM не дотримується цього стандарту з міркувань безпеки — спільне використання енергозалежної пам’яті дає змогу змінювати програмний код. Натомість код зберігається у сховищі.

Є лише два випадки, коли код виконується з пам’яті:

- Коли контракт створює інший контракт (за допомогою [`CREATE`](https://www.evm.codes/#f0) або [`CREATE2`](https://www.evm.codes/#f5)), код для конструктора контракту надходить із пам’яті.
- Під час створення _будь-якого_ контракту виконується код конструктора, а потім повертається код фактичного контракту, також із пам’яті.

Термін «виняткове виконання» означає виняток, який призводить до зупинки виконання поточного контракту.

## 9.2 Огляд комісій {#92-fees-overview}

У цьому розділі пояснюється, як розраховуються комісії за газ. Існує три види витрат:

### Вартість опкоду {#opcode-cost}

Власна вартість конкретного опкоду. Щоб отримати це значення, знайдіть групу вартості опкоду в Додатку H (с. 28, під рівнянням (327)) і знайдіть групу вартості в рівнянні (324). Це дає вам функцію вартості, яка в більшості випадків використовує параметри з Додатка G (с. 27).

Наприклад, опкод [`CALLDATACOPY`](https://www.evm.codes/#37) є членом групи _W<sub>copy</sub>_. Вартість опкоду для цієї групи становить _G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_. Дивлячись на Додаток G, ми бачимо, що обидві константи дорівнюють 3, що дає нам _3+3×⌈μ<sub>s</sub>[2]÷32⌉_.

Нам ще потрібно розшифрувати вираз _⌈μ<sub>s</sub>[2]÷32⌉_. Зовнішня частина, _⌈ \<value\> ⌉_, — це функція стелі, функція, яка для заданого значення повертає найменше ціле число, що не менше за це значення. Наприклад, _⌈2.5⌉ = ⌈3⌉ = 3_. Внутрішня частина — це _μ<sub>s</sub>[2]÷32_. Дивлячись на розділ 3 (Умовні позначення) на с. 3, _μ_ — це стан машини. Стан машини визначено в розділі 9.4.1 на с. 13. Згідно з цим розділом, одним із параметрів стану машини є _s_ для стека. Підсумовуючи, здається, що _μ<sub>s</sub>[2]_ — це комірка №2 у стеку. Дивлячись на [опкод](https://www.evm.codes/#37), комірка №2 у стеку — це розмір даних у байтах. Дивлячись на інші опкоди в групі W<sub>copy</sub>, [`CODECOPY`](https://www.evm.codes/#39) і [`RETURNDATACOPY`](https://www.evm.codes/#3e), вони також мають розмір даних у тій самій комірці. Отже, _⌈μ<sub>s</sub>[2]÷32⌉_ — це кількість 32-байтових слів, необхідних для зберігання даних, що копіюються. Підсумовуючи, власна вартість [`CALLDATACOPY`](https://www.evm.codes/#37) становить 3 одиниці газу плюс 3 за кожне слово даних, що копіюються.

### Вартість виконання {#running-cost}

Вартість виконання коду, який ми викликаємо.

- У випадку [`CREATE`](https://www.evm.codes/#f0) та [`CREATE2`](https://www.evm.codes/#f5) — конструктор для нового контракту.
- У випадку [`CALL`](https://www.evm.codes/#f1), [`CALLCODE`](https://www.evm.codes/#f2), [`STATICCALL`](https://www.evm.codes/#fa) або [`DELEGATECALL`](https://www.evm.codes/#f4) — контракт, який ми викликаємо.

### Вартість розширення пам’яті {#expanding-memory-cost}

Вартість розширення пам’яті (за потреби).

У рівнянні 324 це значення записано як _C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_. Знову поглянувши на розділ 9.4.1, ми бачимо, що _μ<sub>i</sub>_ — це кількість слів у пам’яті. Отже, _μ<sub>i</sub>_ — це кількість слів у пам’яті до опкоду, а _μ<sub>i</sub>'_ — кількість слів у пам’яті після опкоду.

Функція _C<sub>mem</sub>_ визначена в рівнянні 326: _C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_. _⌊x⌋_ — це функція підлоги, функція, яка для заданого значення повертає найбільше ціле число, що не більше за це значення. Наприклад, _⌊2.5⌋ = ⌊2⌋ = 2._ Коли _a < √512_, _a<sup>2</sup> < 512_, і результат функції підлоги дорівнює нулю. Отже, для перших 22 слів (704 байти) вартість зростає лінійно з кількістю необхідних слів пам’яті. Після цієї точки _⌊a<sup>2</sup> ÷ 512⌋_ є додатнім. Коли обсяг необхідної пам’яті достатньо великий, вартість газу стає пропорційною квадрату обсягу пам’яті.

**Примітка**: ці фактори впливають лише на _внутрішню_ вартість газу — вони не враховують ринок комісій або чайові валідаторам, які визначають, скільки повинен заплатити кінцевий користувач. Це лише вартість виконання певної операції на EVM.

[Дізнайтеся більше про газ](/developers/docs/gas/).

## 9.3 Середовище виконання {#93-execution-env}

Середовище виконання — це кортеж, _I_, який містить інформацію, що не є частиною стану блокчейну або EVM.

| Параметр        | Опкод для доступу до даних                                                                                    | Код на Solidity для доступу до даних                                      |
| --------------- | ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                                        | `address(this)`                                                           |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                                         | `tx.origin`                                                               |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                                       | `tx.gasprice`                                                             |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35) і т. д.                           | `msg.data`                                                                |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                                         | `msg.sender`                                                              |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                                      | `msg.value`                                                               |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                                       | `address(this).code`                                                      |
| _I<sub>H</sub>_ | Поля заголовка блоку, як-от [`NUMBER`](https://www.evm.codes/#43) і [`DIFFICULTY`](https://www.evm.codes/#44) | `block.number`, `block.difficulty` і т.д. |
| _I<sub>e</sub>_ | Глибина стека викликів для викликів між контрактами (включаючи створення контракту)        |                                                                           |
| _I<sub>w</sub>_ | Чи дозволено EVM змінювати стан, чи вона працює статично                                                      |                                                                           |

Кілька інших параметрів необхідні для розуміння решти розділу 9:

| Параметр | Визначено в розділі                                            | Значення                                                                                                                                                                                                                                                         |
| -------- | -------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _σ_      | 2 (с. 2, рівняння 1)        | Стан блокчейну                                                                                                                                                                                                                                                   |
| _g_      | 9.3 (с. 13) | Залишок газу                                                                                                                                                                                                                                                     |
| _A_      | 6.1 (с. 8)  | Накопичений підстан (зміни, заплановані на кінець транзакції)                                                                                                                                                                                 |
| _o_      | 9.3 (с. 13) | Вихідні дані — результат, що повертається у випадку внутрішньої транзакції (коли один контракт викликає інший) і викликів функцій перегляду (коли ви просто запитуєте інформацію, тому немає потреби чекати на транзакцію) |

## 9.4 Загальний огляд виконання {#94-execution-overview}

Тепер, коли ми маємо всю попередню інформацію, ми нарешті можемо почати розбиратися в тому, як працює EVM.

Рівняння 137–142 дають нам початкові умови для запуску EVM:

| Символ           | Початкове значення                                                               | Значення                                                                                                                                                                                                                                                                                                            |
| ---------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | Залишок газу                                                                                                                                                                                                                                                                                                        |
| _μ<sub>pc</sub>_ | _0_                                                                              | Лічильник команд, адреса наступної інструкції для виконання                                                                                                                                                                                                                                                         |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | Пам’ять, ініціалізована нулями                                                                                                                                                                                                                                                                                      |
| _μ<sub>i</sub>_  | _0_                                                                              | Найвища використана комірка пам’яті                                                                                                                                                                                                                                                                                 |
| _μ<sub>s</sub>_  | _()_                                                          | Стек, спочатку порожній                                                                                                                                                                                                                                                                                             |
| _μ<sub>o</sub>_  | _∅_                                                                              | Вихідні дані, порожня множина, доки ми не зупинимося з поверненням даних ([`RETURN`](https://www.evm.codes/#f3) або [`REVERT`](https://www.evm.codes/#fd)) або без них ([`STOP`](https://www.evm.codes/#00) або [`SELFDESTRUCT`](https://www.evm.codes/#ff)). |

Рівняння 143 говорить нам, що в кожен момент часу під час виконання є чотири можливі умови, і що з ними робити:

1. `Z(σ,μ,A,I)`. Z представляє функцію, яка перевіряє, чи створює операція недійсний перехід стану (див. [виняткова зупинка](#942-exceptional-halting)). Якщо вона повертає True, новий стан ідентичний старому (за винятком спаленого газу), оскільки зміни не були реалізовані.
2. Якщо виконуваний опкод — [`REVERT`](https://www.evm.codes/#fd), новий стан такий самий, як і старий, і втрачається частина газу.
3. Якщо послідовність операцій завершена, про що свідчить [`RETURN`](https://www.evm.codes/#f3), стан оновлюється до нового стану.
4. Якщо ми не досягли однієї з кінцевих умов 1–3, продовжуємо виконання.

## 9.4.1 Стан машини {#941-machine-state}

У цьому розділі більш детально пояснюється стан машини. Тут зазначено, що _w_ — це поточний опкод. Якщо _μ<sub>pc</sub>_ менше, ніж _||I<sub>b</sub>||_ (довжина коду), то цей байт (_I<sub>b</sub>[μ<sub>pc</sub>]_) є опкодом. В іншому випадку опкод визначається як [`STOP`](https://www.evm.codes/#00).

Оскільки це [стекова машина](https://en.wikipedia.org/wiki/Stack_machine), нам потрібно відстежувати кількість елементів, витягнутих (_δ_) і доданих (_α_) кожним опкодом.

## 9.4.2 Виняткова зупинка {#942-exceptional-halt}

Цей розділ визначає функцію _Z_, яка вказує, коли відбувається ненормальне завершення. Це [булева](https://en.wikipedia.org/wiki/Boolean_data_type) функція, тому вона використовує [_∨_ для логічного «або»](https://en.wikipedia.org/wiki/Logical_disjunction) та [_∧_ для логічного «і»](https://en.wikipedia.org/wiki/Logical_conjunction).

Виняткова зупинка відбувається, якщо істинна будь-яка з цих умов:

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  Як ми бачили в розділі 9.2, _C_ — це функція, що визначає вартість газу. Газу, що залишився, недостатньо для покриття наступного опкоду.

- **_δ<sub>w</sub>=∅_**
  Якщо кількість елементів, які витягуються для опкоду, не визначена, то сам опкод є невизначеним.

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  Спустошення стека, недостатньо елементів у стеку для поточного опкоду.

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  Опкод — [`JUMP`](https://www.evm.codes/#56), а адреса не є [`JUMPDEST`](https://www.evm.codes/#5b). Переходи є дійсними _лише_ тоді, коли місце призначення є [`JUMPDEST`](https://www.evm.codes/#5b).

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  Опкод — [`JUMPI`](https://www.evm.codes/#57), умова істинна (не нульова), тому перехід має відбутися, а адреса не є [`JUMPDEST`](https://www.evm.codes/#5b). Переходи є дійсними _лише_ тоді, коли місце призначення є [`JUMPDEST`](https://www.evm.codes/#5b).

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  Опкод — [`RETURNDATACOPY`](https://www.evm.codes/#3e). У цьому опкоді елемент стека _μ<sub>s</sub>[1]_ — це зміщення для читання в буфері даних, що повертаються, а елемент стека _μ<sub>s</sub>[2]_ — це довжина даних. Ця умова виникає, коли ви намагаєтеся читати за межами буфера даних, що повертаються. Зауважте, що немає схожої умови для calldata або для самого коду. Коли ви намагаєтеся читати за межами цих буферів, ви просто отримуєте нулі.

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  Переповнення стека. Якщо виконання опкоду призведе до того, що стек перевищить 1024 елементи, виконання переривається.

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  Ми працюємо статично ([¬ — це заперечення](https://en.wikipedia.org/wiki/Negation), а _I<sub>w</sub>_ істинне, коли нам дозволено змінювати стан блокчейну)? Якщо так, і ми намагаємося виконати операцію, що змінює стан, цього не станеться.

  Функція _W(w,μ)_ визначена далі в рівнянні 150. _W(w,μ)_ є істинним, якщо істинна одна з цих умов:

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    Ці опкоди змінюють стан: створюючи новий контракт, зберігаючи значення або знищуючи поточний контракт.

  - **_LOG0≤w ∧ w≤LOG4_**
    Якщо нас викликають статично, ми не можемо створювати записи в журналі.
    Опкоди журналу знаходяться в діапазоні між [`LOG0` (A0)](https://www.evm.codes/#a0) та [`LOG4` (A4)](https://www.evm.codes/#a4).
    Число після опкоду журналу вказує, скільки тем містить запис у журналі.

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    Ви можете викликати інший контракт, коли ви статичні, але якщо ви це робите, ви не можете передавати йому ETH.

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  Ви не можете виконати [`SSTORE`](https://www.evm.codes/#55), якщо у вас немає більше ніж G<sub>callstipend</sub> (визначено як 2300 у Додатку G) газу.

## 9.4.3 Валідність місця призначення переходу {#943-jump-dest-valid}

Тут ми формально визначаємо, що таке опкоди [`JUMPDEST`](https://www.evm.codes/#5b). Ми не можемо просто шукати байтове значення 0x5B, оскільки воно може бути всередині PUSH (і, отже, бути даними, а не опкодом).

У рівнянні (153) ми визначаємо функцію _N(i,w)_. Перший параметр, _i_, — це місцезнаходження опкоду. Другий, _w_, — це сам опкод. Якщо _w∈[PUSH1, PUSH32]_, це означає, що опкод є PUSH (квадратні дужки визначають діапазон, що включає кінцеві точки). У цьому випадку наступний опкод знаходиться за адресою _i+2+(w−PUSH1)_. Для [`PUSH1`](https://www.evm.codes/#60) нам потрібно просунутися на два байти (сам PUSH і однобайтове значення), для [`PUSH2`](https://www.evm.codes/#61) нам потрібно просунутися на три байти, оскільки це двобайтове значення, і т. д. Усі інші опкоди EVM мають довжину лише один байт, тому в усіх інших випадках _N(i,w)=i+1_.

Ця функція використовується в рівнянні (152) для визначення _D<sub>J</sub>(c,i)_, що є [множиною](https://en.wikipedia.org/wiki/Set_\(mathematics\)) всіх дійсних місць призначення переходу в коді _c_, починаючи з місцезнаходження опкоду _i_. Ця функція визначена рекурсивно. Якщо _i≥||c||_, це означає, що ми знаходимося в кінці коду або після нього. Ми більше не знайдемо місць призначення переходу, тому просто повертаємо порожню множину.

В усіх інших випадках ми розглядаємо решту коду, переходячи до наступного опкоду і отримуючи множину, що починається з нього. _c[i]_ — це поточний опкод, тому _N(i,c[i])_ — це місцезнаходження наступного опкоду. Тому _D<sub>J</sub>(c,N(i,c[i]))_ — це множина дійсних місць призначення переходу, що починається з наступного опкоду. Якщо поточний опкод не є `JUMPDEST`, просто поверніть цю множину. Якщо це `JUMPDEST`, включіть його в множину результатів і поверніть її.

## 9.4.4 Нормальна зупинка {#944-normal-halt}

Функція зупинки _H_ може повертати три типи значень.

- Якщо ми не на опкоді зупинки, повертається _∅_, порожня множина. За угодою, це значення інтерпретується як булеве «хибно».
- Якщо у нас є опкод зупинки, який не створює вихідних даних (або [`STOP`](https://www.evm.codes/#00), або [`SELFDESTRUCT`](https://www.evm.codes/#ff)), повертається послідовність нульового розміру байтів як значення, що повертається. Зауважте, що це дуже відрізняється від порожньої множини. Це значення означає, що EVM справді зупинилася, просто немає даних для читання, що повертаються.
- Якщо у нас є опкод зупинки, який створює вихідні дані (або [`RETURN`](https://www.evm.codes/#f3), або [`REVERT`](https://www.evm.codes/#fd)), повертається послідовність байтів, визначена цим опкодом. Ця послідовність береться з пам'яті, значення на вершині стека (_μ<sub>s</sub>[0]_) є першим байтом, а значення після нього (_μ<sub>s</sub>[1]_) — довжиною.

## H.2 Набір інструкцій {#h2-instruction-set}

Перш ніж перейти до останнього підрозділу EVM, 9.5, розгляньмо самі інструкції. Вони визначені в Додатку H.2, який починається на с. 29. Усе, що не вказано як те, що змінюється цим конкретним опкодом, має залишатися незмінним. Змінні, які змінюються, позначаються як \<something\>′.

Наприклад, розгляньмо опкод [`ADD`](https://www.evm.codes/#01).

| Значення | Мнемоніка | δ | α | Опис                                                                                                                                                                                                                  |
| -------: | --------- | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     0x01 | ADD       | 2 | 1 | Операція додавання.                                                                                                                                                                                   |
|          |           |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_ — це кількість значень, які ми витягуємо зі стека. У цьому випадку два, оскільки ми додаємо два верхні значення.

_α_ — це кількість значень, які ми повертаємо в стек. У цьому випадку одне — сума.

Отже, нова вершина стека (_μ′<sub>s</sub>[0]_) є сумою старої вершини стека (_μ<sub>s</sub>[0]_) і старого значення під нею (_μ<sub>s</sub>[1]_).

Замість того, щоб переглядати всі опкоди, що може бути нудно, ця стаття пояснює лише ті опкоди, які вводять щось нове.

| Значення | Мнемоніка | δ | α | Опис                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| -------: | --------- | - | - | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     0x20 | KECCAK256 | 2 | 1 | Обчислити хеш Keccak-256.                                                                                                                                                                                                                                                                                                                                                                                                                            |
|          |           |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] . . . (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|          |           |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                                                     |

Це перший опкод, який звертається до пам'яті (в цьому випадку, тільки для читання). Однак він може вийти за поточні межі пам'яті, тому нам потрібно оновити _μ<sub>i</sub>._ Ми робимо це за допомогою функції _M_, визначеної в рівнянні 328 на с. 29.

| Значення | Мнемоніка | δ | α | Опис                                                      |
| -------: | --------- | - | - | --------------------------------------------------------- |
|     0x31 | BALANCE   | 1 | 1 | Отримати баланс даного облікового запису. |
|          |           |   |   | ...       |

Адреса, баланс якої нам потрібно знайти, — це _μ<sub>s</sub>[0] mod 2<sup>160</sup>_. Вершина стека — це адреса, але оскільки адреси мають лише 160 біт, ми обчислюємо значення за [модулем](https://en.wikipedia.org/wiki/Modulo_operation) 2<sup>160</sup>.

Якщо _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_, це означає, що є інформація про цю адресу. У цьому випадку _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_ — це баланс для цієї адреси. Якщо _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_, це означає, що ця адреса неініціалізована, і баланс дорівнює нулю. Ви можете побачити список полів інформації про обліковий запис у розділі 4.1 на с. 4.

Друге рівняння, _A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_, пов'язане з різницею у вартості доступу до теплого сховища (сховища, до якого нещодавно зверталися і яке, ймовірно, кешується) та холодного сховища (сховища, до якого не зверталися і яке, ймовірно, знаходиться в повільнішому сховищі, вилучення з якого дорожче). _A<sub>a</sub>_ — це список адрес, до яких раніше зверталася транзакція, і тому доступ до них має бути дешевшим, як визначено в розділі 6.1 на с. 8. Ви можете прочитати більше про цю тему в [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929).

| Значення | Мнемоніка | δ  | α  | Опис                                                                                                                                            |
| -------: | --------- | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
|     0x8F | DUP16     | 16 | 17 | Дублювати 16-й елемент стека.                                                                                                   |
|          |           |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

Зауважте, що для використання будь-якого елемента стека нам потрібно його витягнути, що означає, що нам також потрібно витягнути всі елементи стека, що знаходяться над ним. У випадку [`DUP<n>`](https://www.evm.codes/#8f) та [`SWAP<n>`](https://www.evm.codes/#9f) це означає необхідність витягнути, а потім вставити до шістнадцяти значень.

## 9.5 Цикл виконання {#95-exec-cycle}

Тепер, коли у нас є всі частини, ми нарешті можемо зрозуміти, як задокументований цикл виконання EVM.

Рівняння (155) говорить, що за даного стану:

- _σ_ (глобальний стан блокчейну)
- _μ_ (стан EVM)
- _A_ (підстан, зміни, що відбудуться після завершення транзакції)
- _I_ (середовище виконання)

Новий стан — _(σ', μ', A', I')_.

Рівняння (156)-(158) визначають стек та зміни в ньому через опкод (_μ<sub>s</sub>_). Рівняння (159) — це зміна газу (_μ<sub>g</sub>_). Рівняння (160) — це зміна лічильника команд (_μ<sub>pc</sub>_). Нарешті, рівняння (161)-(164) вказують, що інші параметри залишаються незмінними, якщо вони не змінені явно опкодом.

Цим EVM повністю визначена.

## Висновок {#conclusion}

Математична нотація є точною і дозволила Yellow Paper детально описати кожну деталь Ethereum. Однак вона має деякі недоліки:

- Її можуть зрозуміти лише люди, що означає, що [тести на відповідність](https://github.com/ethereum/tests) повинні писатися вручну.
- Програмісти розуміють комп’ютерний код.
  Вони можуть розуміти або не розуміти математичну нотацію.

Можливо, з цих причин новіші [специфікації шару консенсусу](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md) написані на Python. Існують [специфікації виконавчого рівня на Python](https://ethereum.github.io/execution-specs), але вони неповні. Доки весь Yellow Paper не буде перекладено на Python або схожу мову, Yellow Paper залишатиметься в силі, і вміння його читати є корисним.
