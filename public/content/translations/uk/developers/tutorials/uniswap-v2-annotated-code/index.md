---
title: "Огляд контракту Uniswap v2"
description: Як працює контракт Uniswap v2? Чому він написаний саме так?
author: Орі Померанц
tags: [ "мова програмування" ]
skill: intermediate
published: 01.05.2021
lang: uk
---

## Вступ {#introduction}

[Uniswap v2](https://app.uniswap.org/whitepaper.pdf) може створювати ринок обміну між будь-якими двома токенами ERC-20. У цій статті ми розглянемо вихідний код контрактів, які реалізують цей протокол, і з’ясуємо, чому вони написані саме так.

### Що робить Uniswap? {#what-does-uniswap-do}

Загалом існує два типи користувачів: постачальники ліквідності та трейдери.

_Постачальники ліквідності_ надають пулу два токени, які можна обміняти (ми їх називатимемо **Token0** та **Token1**). Натомість вони отримують третій токен, що представляє часткове володіння пулом і називається _токеном ліквідності_.

_Трейдери_ надсилають один тип токена в пул і отримують інший (наприклад, надсилають **Token0** і отримують **Token1**) з пулу, наданого постачальниками ліквідності. Обмінний курс визначається відносною кількістю токенів **Token0** і **Token1**, які є в пулі. Крім того, пул бере невеликий відсоток як винагороду для пулу ліквідності.

Коли постачальники ліквідності хочуть повернути свої активи, вони можуть спалити токени пулу та отримати назад свої токени, включно з їхньою часткою винагороди.

[Натисніть тут, щоб переглянути детальніший опис](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/swaps/).

### Чому v2? Чому не v3? {#why-v2}

[Uniswap v3](https://app.uniswap.org/whitepaper-v3.pdf) — це оновлення, яке є набагато складнішим, ніж v2. Легше спочатку вивчити v2, а вже потім перейти до v3.

### Основні та периферійні контракти {#contract-types}

Uniswap v2 складається з двох компонентів: ядра та периферії. Такий поділ дає змогу зробити основні контракти, які зберігають активи й тому _мають_ бути безпечними, простішими та легшими для аудиту. Весь додатковий функціонал, необхідний трейдерам, може бути наданий периферійними контрактами.

## Потоки даних і керування {#flows}

Це потік даних і керування, що відбувається під час виконання трьох основних дій Uniswap:

1. Обмін між різними токенами
2. Додавання ліквідності на ринок і отримання токенів ліквідності ERC-20 для парного обміну як винагороди
3. Спалювання токенів ліквідності ERC-20 та отримання назад токенів ERC-20, які парна біржа дозволяє трейдерам обмінювати

### Обмін {#swap-flow}

Це найпоширеніший потік, який використовують трейдери:

#### Викликач {#caller}

1. Надайте периферійному рахунку дозвіл на суму, що підлягає обміну.
2. Викличте одну з багатьох функцій обміну периферійного контракту (яку саме — залежить від того, чи залучено ETH, чи вказує трейдер суму токенів для депозиту чи суму токенів для повернення тощо).
   Кожна функція обміну приймає `path` — масив бірж для проходження.

#### У периферійному контракті (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02-sol}

3. Визначте суми, якими потрібно торгувати на кожній біржі вздовж шляху.
4. Ітерація шляхом. Для кожного обміну на шляху він надсилає вхідний токен, а потім викликає функцію `swap` біржі.
   У більшості випадків адресою призначення для токенів є наступна парна біржа на шляху. На останній біржі це адреса, надана трейдером.

#### В основному контракті (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

5. Перевірте, що основний контракт не обманюють і що він може підтримувати достатню ліквідність після обміну.
6. Перевірте, скільки додаткових токенів ми маємо крім відомих резервів. Ця сума — це кількість вхідних токенів, які ми отримали для обміну.
7. Надішліть вихідні токени до місця призначення.
8. Викличте `_update`, щоб оновити суми резервів

#### Назад у периферійний контракт (UniswapV2Router02.sol) {#back-in-the-periphery-contract-uniswapv2router02-sol}

9. Виконайте будь-які необхідні очищення (наприклад, спаліть токени WETH, щоб повернути ETH для відправки трейдеру)

### Додати ліквідність {#add-liquidity-flow}

#### Викликач {#caller-2}

1. Надайте периферійному рахунку дозвіл на суми, які потрібно додати до пулу ліквідності.
2. Викличте одну з функцій `addLiquidity` периферійного контракту.

#### У периферійному контракті (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-2}

3. Створіть новий парний обмін за потреби
4. Якщо існує парний обмін, розрахуйте кількість токенів, які потрібно додати. Це має бути ідентичне значення для обох токенів, тобто однакове співвідношення нових токенів до наявних.
5. Перевірте, чи прийнятні суми (викликачі можуть вказати мінімальну суму, нижче якої вони не бажають додавати ліквідність)
6. Викличте основний контракт.

#### В основному контракті (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

7. Карбуйте токени ліквідності та надсилайте їх викликачу
8. Викличте `_update`, щоб оновити суми резервів

### Вилучення ліквідності {#remove-liquidity-flow}

#### Викликач {#caller-3}

1. Надайте периферійному рахунку дозвіл на спалювання токенів ліквідності в обмін на базові токени.
2. Викличте одну з функцій `removeLiquidity` периферійного контракту.

#### У периферійному контракті (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-3}

3. Надішліть токени ліквідності на парний обмін

#### В основному контракті (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-3}

4. Надішліть на адресу призначення базові токени пропорційно до спалених токенів. Наприклад, якщо в пулі є 1000 токенів A, 500 токенів B і 90 токенів ліквідності, і ми отримуємо 9 токенів для спалювання, ми спалюємо 10 % токенів ліквідності, тому повертаємо користувачеві 100 токенів A і 50 токенів B.
5. Спаліть токени ліквідності
6. Викличте `_update`, щоб оновити суми резервів

## Основні контракти {#core-contracts}

Це безпечні контракти, які зберігають ліквідність.

### UniswapV2Pair.sol {#UniswapV2Pair}

[Цей контракт](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol) реалізує фактичний пул, що обмінює токени. Це основний функціонал Uniswap.

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';
```

Це всі інтерфейси, про які контракт має знати, або тому, що контракт їх реалізує (`IUniswapV2Pair` і `UniswapV2ERC20`), або тому, що він викликає контракти, які їх реалізують.

```solidity
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
```

Цей контракт успадковує `UniswapV2ERC20`, який надає функції ERC-20 для токенів ліквідності.

```solidity
    using SafeMath  for uint;
```

[Бібліотека SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math) використовується для запобігання переповненням (overflows) та антипереповненням (underflows). Це важливо, оскільки інакше ми можемо опинитися в ситуації, коли значення має бути `-1`, а натомість дорівнює `2^256-1`.

```solidity
    using UQ112x112 for uint224;
```

Багато обчислень у контракті пулу вимагають дробів. Однак дроби не підтримуються EVM.
Рішення, яке знайшов Uniswap, полягає у використанні 224-бітних значень, зі 112 бітами для цілої частини та 112 бітами для дробу. Отже, `1.0` представлено як `2^112`, `1.5` представлено як `2^112 + 2^111` тощо.

Більш детальна інформація про цю бібліотеку доступна [пізніше в цьому документі](#FixedPoint).

#### Змінні {#pair-vars}

```solidity
    uint public constant MINIMUM_LIQUIDITY = 10**3;
```

Щоб уникнути випадків ділення на нуль, існує мінімальна кількість токенів ліквідності, яка завжди є (але належить нульовому рахунку). Це число — **MINIMUM_LIQUIDITY**, тисяча.

```solidity
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
```

Це селектор ABI для функції передачі ERC-20. Він використовується для передачі токенів ERC-20 на двох рахунках токенів.

```solidity
    address public factory;
```

Це фабричний контракт, який створив цей пул. Кожен пул — це біржа між двома токенами ERC-20, а фабрика — це центральна точка, яка з’єднує всі ці пули.

```solidity
    address public token0;
    address public token1;
```

Це адреси контрактів для двох типів токенів ERC-20, які можуть бути обміняні цим пулом.

```solidity
    uint112 private reserve0;           // використовує один слот сховища, доступний через getReserves
    uint112 private reserve1;           // використовує один слот сховища, доступний через getReserves
```

Резерви, які пул має для кожного типу токена. Ми припускаємо, що обидва представляють однакову вартість, і тому кожен token0 вартий reserve1/reserve0 токенів token1.

```solidity
    uint32  private blockTimestampLast; // використовує один слот сховища, доступний через getReserves
```

Часова мітка для останнього блоку, в якому відбувся обмін, використовується для відстеження курсів обміну в часі.

Однією з найбільших витрат на газ у контрактах Ethereum є сховище, яке зберігається від одного виклику контракту до наступного. Кожна клітинка сховища має довжину 256 біт. Отже, три змінні, `reserve0`, `reserve1` і `blockTimestampLast`, виділяються таким чином, що одне значення сховища може містити всі три (112+112+32=256).

```solidity
    uint public price0CumulativeLast;
    uint public price1CumulativeLast;
```

Ці змінні містять сукупні вартості для кожного токена (кожен у перерахунку на інший). Їх можна використовувати для обчислення середнього обмінного курсу за певний проміжок часу.

```solidity
    uint public kLast; // reserve0 * reserve1, станом на момент одразу після останньої події, пов'язаної з ліквідністю
```

Спосіб, у який парний обмін визначає обмінний курс між token0 і token1, полягає в тому, щоб підтримувати добуток двох резервів постійним під час торгів. `kLast` — це значення. Він змінюється, коли постачальник ліквідності вносить або знімає токени, і трохи збільшується через ринкову комісію в розмірі 0,3%.

Ось простий приклад. Зауважте, що для простоти таблиця містить лише три цифри після десяткової коми, і ми ігноруємо торгову комісію в розмірі 0,3%, тому цифри неточні.

| Подія                                         |  reserve0 |  reserve1 | reserve0 \* reserve1 | Середній обмінний курс (token1 / token0) |
| --------------------------------------------- | --------: | --------: | -------------------: | ----------------------------------------------------------- |
| Початкове налаштування                        | 1 000,000 | 1 000,000 |            1 000 000 |                                                             |
| Трейдер A обмінює 50 token0 на 47,619 token1  | 1 050,000 |   952,381 |            1 000 000 | 0,952                                                       |
| Трейдер B обмінює 10 token0 на 8,984 token1   | 1 060,000 |   943,396 |            1 000 000 | 0,898                                                       |
| Трейдер C обмінює 40 token0 на 34,305 token1  | 1 100,000 |   909,090 |            1 000 000 | 0,858                                                       |
| Трейдер D обмінює 100 token1 на 109,01 token0 |   990,990 | 1 009,090 |            1 000 000 | 0,917                                                       |
| Трейдер E обмінює 10 token0 на 10,079 token1  | 1 000,990 |   999,010 |            1 000 000 | 1,008                                                       |

Оскільки трейдери надають більше token0, відносна вартість token1 зростає, і навпаки, залежно від попиту та пропозиції.

#### Блокування {#pair-lock}

```solidity
    uint private unlocked = 1;
```

Існує клас вразливостей безпеки, що ґрунтуються на [зловживанні повторним входом (reentrancy abuse)](https://medium.com/coinmonks/ethernaut-lvl-10-re-entrancy-walkthrough-how-to-abuse-execution-ordering-and-reproduce-the-dao-7ec88b912c14). Uniswap має передавати довільні токени ERC-20, що означає виклик контрактів ERC-20, які можуть намагатися зловживати ринком Uniswap, що їх викликає.
Маючи змінну `unlocked` як частину контракту, ми можемо запобігти виклику функцій під час їх виконання (в межах однієї транзакції).

```solidity
    modifier lock() {
```

Ця функція є [модифікатором](https://docs.soliditylang.org/en/v0.8.3/contracts.html#function-modifiers) — функцією, яка обгортає звичайну функцію, щоб певним чином змінити її поведінку.

```solidity
        require(unlocked == 1, 'UniswapV2: LOCKED');
        unlocked = 0;
```

Якщо `unlocked` дорівнює одиниці, встановіть його на нуль. Якщо він уже дорівнює нулю, скасуйте виклик, зробіть його невдалим.

```solidity
        _;
```

У модифікаторі `_;` — це початковий виклик функції (з усіма параметрами). Тут це означає, що виклик функції відбувається, тільки якщо `unlocked` дорівнював одиниці під час виклику, і поки він виконується, значення `unlocked` дорівнює нулю.

```solidity
        unlocked = 1;
    }
```

Після повернення основної функції зніміть блокування.

#### Різне функції {#pair-misc}

```solidity
    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }
```

Ця функція надає тим, хто її викликає, поточний стан біржі. Зверніть увагу, що функції Solidity [можуть повертати кілька значень](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values).

```solidity
    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
```

Ця внутрішня функція переказує певну кількість токенів ERC20 з біржі комусь іншому. `SELECTOR` вказує, що функція, яку ми викликаємо, — це `transfer(address,uint)` (див. визначення вище).

Щоб не імпортувати інтерфейс для функції токена, ми створюємо виклик «вручну», використовуючи одну з [функцій ABI](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions).

```solidity
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }
```

Існує два способи, якими виклик переказу ERC-20 може повідомити про збій:

1. Скасування. Якщо виклик зовнішнього контракту скасовується, тоді логічне значення, що повертається, — `false`.
2. Завершитися нормально, але повідомити про збій. У цьому випадку буфер значення, що повертається, має ненульову довжину, і під час декодування як логічне значення він дорівнює `false`.

Якщо трапляється будь-яка з цих умов, відбувається скасування.

#### Події {#pair-events}

```solidity
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
```

Ці дві події генеруються, коли постачальник ліквідності або вносить ліквідність (`Mint`), або виводить її (`Burn`). У будь-якому випадку кількість токенів token0 і token1, які вносяться або виводяться, є частиною події, так само як і ідентифікатор облікового запису, який нас викликав (`sender`). У разі виведення коштів подія також включає ціль, яка отримала токени (`to`), і вона може не збігатися з відправником.

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

Ця подія генерується, коли трейдер обмінює один токен на інший. Знову ж таки, відправник і одержувач можуть не збігатися.
Кожен токен може бути або надісланий на біржу, або отриманий з неї.

```solidity
    event Sync(uint112 reserve0, uint112 reserve1);
```

Нарешті, подія `Sync` генерується кожного разу, коли токени додаються або виводяться, незалежно від причини, щоб надати останню інформацію про резерви (і, отже, обмінний курс).

#### Функції налаштування {#pair-setup}

Передбачається, що ці функції викликаються один раз під час налаштування нової біржової пари.

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

Конструктор гарантує, що ми будемо відстежувати адресу фабрики, яка створила пару. Ця інформація потрібна для `initialize` та для комісії фабрики (якщо така існує).

```solidity
    // викликається один раз фабрикою під час розгортання
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // достатня перевірка
        token0 = _token0;
        token1 = _token1;
    }
```

Ця функція дозволяє фабриці (і тільки фабриці) вказати два токени ERC-20, якими обмінюватиметься ця пара.

#### Внутрішні функції оновлення {#pair-update-internal}

##### \_update

```solidity
    // оновлює резерви та, під час першого виклику за блок, накопичувачі ціни
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

Ця функція викликається кожного разу, коли токени вносяться або виводяться.

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

Якщо balance0 або balance1 (uint256) більше за uint112(-1) (=2^112-1) (тобто відбувається переповнення та повернення до 0 під час конвертації в uint112), виконання \_update припиняється, щоб запобігти переповненню. Для звичайного токена, який можна розділити на 10^18 одиниць, це означає, що кожна біржа обмежена приблизно 5.1\*10^15 кожного з токенів. Досі це не було проблемою.

```solidity
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // переповнення є бажаним
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
```

Якщо час, що минув, не дорівнює нулю, це означає, що це перша транзакція обміну в цьому блоці. У такому випадку нам потрібно оновити накопичувачі вартості.

```solidity
            // * ніколи не переповнюється, а для + переповнення є бажаним
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
```

Кожен акумулятор вартості оновлюється з останньою вартістю (резерв іншого токена/резерв цього токена), помноженою на час, що минув, у секундах. Щоб отримати середню ціну, ви зчитуєте сукупну ціну в двох точках часу і ділите на різницю в часі між ними. Наприклад, припустимо таку послідовність подій:

| Подія                                                      |  reserve0 |  reserve1 | часова мітка | Граничний обмінний курс (reserve1 / reserve0) |       price0CumulativeLast |
| ---------------------------------------------------------- | --------: | --------: | ------------ | ---------------------------------------------------------------: | -------------------------: |
| Початкове налаштування                                     | 1 000,000 | 1 000,000 | 5 000        |                                                            1,000 |                          0 |
| Трейдер А вносить 50 token0 і отримує назад 47,619 token1  | 1 050,000 |   952,381 | 5 020        |                                                            0,907 |                         20 |
| Трейдер B вносить 10 token0 і отримує назад 8,984 token1   | 1 060,000 |   943,396 | 5 030        |                                                            0,890 |       20+10\*0,907 = 29,07 |
| Трейдер C вносить 40 token0 і отримує назад 34,305 token1  | 1 100,000 |   909,090 | 5 100        |                                                            0,826 |    29,07+70\*0,890 = 91,37 |
| Трейдер D вносить 100 token1 і отримує назад 109,01 token0 |   990,990 | 1 009,090 | 5 110        |                                                            1,018 |    91,37+10\*0,826 = 99,63 |
| Трейдер E вносить 10 token0 і отримує назад 10,079 token1  | 1 000,990 |   999,010 | 5 150        |                                                            0,998 | 99,63+40\*1,1018 = 143,702 |

Припустимо, ми хочемо обчислити середню ціну **Token0** між часовими мітками 5030 і 5150. Різниця у значенні `price0Cumulative` становить 143,702-29,07=114,632. Це середнє значення за дві хвилини (120 секунд). Отже, середня ціна становить 114,632/120 = 0,955.

Цей розрахунок ціни є причиною того, що нам потрібно знати старі розміри резервів.

```solidity
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }
```

Нарешті, оновіть глобальні змінні та випустіть подію `Sync`.

##### \_mintFee

```solidity
    // якщо комісія увімкнена, карбуємо ліквідність, еквівалентну 1/6 росту в sqrt(k)
    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
```

У Uniswap 2.0 трейдери сплачують комісію 0,30% за використання ринку. Більшість цієї комісії (0,25% від торгівлі) завжди йде до постачальників ліквідності. Решта 0,05 % може надходити або постачальникам ліквідності, або на адресу, вказану фабрикою, як комісія протоколу, що є платою для Uniswap за їхні зусилля з розробки.

Щоб зменшити обчислення (а отже, і витрати на газ), ця комісія розраховується лише тоді, коли ліквідність додається або видаляється з пулу, а не при кожній транзакції.

```solidity
        address feeTo = IUniswapV2Factory(factory).feeTo();
        feeOn = feeTo != address(0);
```

Прочитайте адресу призначення комісії фабрики. Якщо вона дорівнює нулю, то комісії протоколу немає і не потрібно її розраховувати.

```solidity
        uint _kLast = kLast; // економія газу
```

Змінна стану `kLast` знаходиться в сховищі, тому вона матиме значення між різними викликами контракту.
Доступ до сховища набагато дорожчий, ніж доступ до енергозалежної пам’яті, яка звільняється після завершення виклику функції контракту, тому ми використовуємо внутрішню змінну для економії газу.

```solidity
        if (feeOn) {
            if (_kLast != 0) {
```

Постачальники ліквідності отримують свою частку просто за рахунок зростання вартості їхніх токенів ліквідності. Але комісія протоколу вимагає, щоб нові токени ліквідності були викарбувані та надані на адресу `feeTo`.

```solidity
                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
                uint rootKLast = Math.sqrt(_kLast);
                if (rootK > rootKLast) {
```

Якщо є нова ліквідність, на яку можна збирати комісію протоколу. Ви можете побачити функцію квадратного кореня [пізніше в цій статті](#Math).

```solidity
                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                    uint denominator = rootK.mul(5).add(rootKLast);
                    uint liquidity = numerator / denominator;
```

Це складне обчислення комісій пояснюється в [білій книзі](https://app.uniswap.org/whitepaper.pdf) на сторінці 5. Ми знаємо, що між часом, коли було розраховано `kLast`, і теперішнім моментом, ліквідність не додавалася і не видалялася (оскільки ми виконуємо цей розрахунок щоразу, коли ліквідність додається або видаляється, до її фактичної зміни), тому будь-яка зміна в `reserve0 * reserve1` має походити від комісій за транзакції (без них ми б тримали `reserve0 * reserve1` постійним).

```solidity
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
```

Використовуйте функцію `UniswapV2ERC20._mint`, щоб фактично створити додаткові токени ліквідності та призначити їх `feeTo`.

```solidity
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }
```

Якщо комісія не встановлена, встановіть `kLast` на нуль (якщо він ще не встановлений). Коли цей контракт був написаний, існувала [функція повернення газу](https://eips.ethereum.org/EIPS/eip-3298), яка заохочувала контракти зменшувати загальний розмір стану Ethereum шляхом обнулення сховища, яке їм не було потрібне.
Цей код отримує це відшкодування, коли це можливо.

#### Зовнішньо доступні функції {#pair-external}

Зверніть увагу, що хоча будь-яка транзакція або контракт _може_ викликати ці функції, вони призначені для виклику з периферійного контракту. Якщо ви викликаєте їх безпосередньо, ви не зможете обдурити парний обмін, але можете втратити вартість через помилку.

##### карбування

```solidity
    // цю низькорівневу функцію слід викликати з контракту, який виконує важливі перевірки безпеки
    function mint(address to) external lock returns (uint liquidity) {
```

Ця функція викликається, коли постачальник ліквідності додає ліквідність до пулу. Вона карбує додаткові токени ліквідності як винагороду. Її слід викликати з [периферійного контракту](#UniswapV2Router02), який викликає її після додавання ліквідності в тій самій транзакції (щоб ніхто інший не міг подати транзакцію, яка вимагає нової ліквідності, раніше за законного власника).

```solidity
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // економія газу
```

Це спосіб читання результатів функції Solidity, яка повертає кілька значень. Ми відкидаємо останні повернуті значення, часову мітку блоку, тому що вони нам не потрібні.

```solidity
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0.sub(_reserve0);
        uint amount1 = balance1.sub(_reserve1);
```

Отримайте поточні баланси та подивіться, скільки було додано кожного типу токена.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
```

Розрахуйте комісії протоколу для збору, якщо такі є, і викарбуйте відповідні токени ліквідності. Оскільки параметри для `_mintFee` — це старі значення резерву, комісія розраховується точно на основі змін пулу, що відбулися через комісії.

```solidity
        uint _totalSupply = totalSupply; // економія газу, має бути визначено тут, оскільки totalSupply може оновлюватися в _mintFee
        if (_totalSupply == 0) {
            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
           _mint(address(0), MINIMUM_LIQUIDITY); // назавжди заблокувати перші MINIMUM_LIQUIDITY токени
```

Якщо це перший депозит, створіть токени `MINIMUM_LIQUIDITY` і надішліть їх на нульову адресу, щоб заблокувати їх. Вони ніколи не можуть бути викуплені, що означає, що пул ніколи не буде повністю спорожнений (це рятує нас від ділення на нуль у деяких місцях). Значення `MINIMUM_LIQUIDITY` становить тисячу, що, враховуючи, що більшість ERC-20 поділяються на одиниці 10^-18-ї частини токена, як ETH ділиться на wei, становить 10^-15 від вартості одного токена. Невисока вартість.

Під час першого депозиту ми не знаємо відносної вартості двох токенів, тому ми просто множимо суми і беремо квадратний корінь, припускаючи, що депозит надає нам однакову вартість в обох токенах.

Ми можемо довіряти цьому, оскільки в інтересах вкладника надавати рівну вартість, щоб уникнути втрати вартості через арбітраж.
Припустимо, що вартість двох токенів однакова, але наш вкладник вніс у чотири рази більше **Token1**, ніж **Token0**. Трейдер може скористатися тим фактом, що парна біржа вважає **Token0** ціннішим, щоб витягти з нього вартість.

| Подія                                                             | reserve0 | reserve1 | reserve0 \* reserve1 | Вартість пулу (reserve0 + reserve1) |
| ----------------------------------------------------------------- | -------: | -------: | -------------------: | -----------------------------------------------------: |
| Початкове налаштування                                            |        8 |       32 |                  256 |                                                     40 |
| Трейдер вносить 8 токенів **Token0**, отримує назад 16 **Token1** |       16 |       16 |                  256 |                                                     32 |

Як бачите, трейдер заробив додаткові 8 токенів, які походять від зменшення вартості пулу, що шкодить вкладнику, який ним володіє.

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
```

З кожним наступним депозитом ми вже знаємо обмінний курс між двома активами, і ми очікуємо, що постачальники ліквідності нададуть однакову вартість в обох. Якщо вони цього не зроблять, ми даємо їм токени ліквідності на основі меншої вартості, яку вони надали, як покарання.

Незалежно від того, чи це початковий депозит, чи наступний, кількість токенів ліквідності, які ми надаємо, дорівнює квадратному кореню зміни в `reserve0*reserve1`, і вартість токена ліквідності не змінюється (якщо ми не отримаємо депозит, який не має однакових значень обох типів, у цьому випадку «штраф» розподіляється). Ось ще один приклад з двома токенами, які мають однакове значення, з трьома вдалими депозитами та одним невдалим (внесено тільки один тип токена, тому він не надає ніяких токенів ліквідності).

| Подія                          |                reserve0 |                reserve1 | reserve0 \* reserve1 | Вартість пулу (reserve0 + reserve1) | Токени ліквідності, викарбувані для цього депозиту | Загальна кількість токенів ліквідності | вартість кожного токена ліквідності |
| ------------------------------ | ----------------------: | ----------------------: | -------------------: | -----------------------------------------------------: | -------------------------------------------------: | -------------------------------------: | ----------------------------------: |
| Початкове налаштування         |                   8,000 |                   8,000 |                   64 |                                                 16,000 |                                                  8 |                                      8 |                               2,000 |
| Депозит по чотири кожного типу |                  12,000 |                  12,000 |                  144 |                                                 24,000 |                                                  4 |                                     12 |                               2,000 |
| Депозит по два кожного типу    |                  14,000 |                  14,000 |                  196 |                                                 28,000 |                                                  2 |                                     14 |                               2,000 |
| Депозит з неоднаковою вартістю |                  18,000 |                  14,000 |                  252 |                                                 32,000 |                                                  0 |                                     14 |              ~2,286 |
| Після арбітражу                | ~15,874 | ~15,874 |                  252 |                                ~31,748 |                                                  0 |                                     14 |              ~2,267 |

```solidity
        }
        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
        _mint(to, liquidity);
```

Використовуйте функцію `UniswapV2ERC20._mint`, щоб фактично створити додаткові токени ліквідності та передати їх на правильний рахунок.

```solidity

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 і reserve1 оновлені
        emit Mint(msg.sender, amount0, amount1);
    }
```

Оновіть змінні стану (`reserve0`, `reserve1` і, за потреби, `kLast`) і випустіть відповідну подію.

##### спалювання

```solidity
    // цю низькорівневу функцію слід викликати з контракту, який виконує важливі перевірки безпеки
    function burn(address to) external lock returns (uint amount0, uint amount1) {
```

Ця функція викликається, коли ліквідність виводиться, і відповідні токени ліквідності потрібно спалити.
Її також слід викликати [з периферійного рахунку](#UniswapV2Router02).

```solidity
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // економія газу
        address _token0 = token0;                                // економія газу
        address _token1 = token1;                                // економія газу
        uint balance0 = IERC20(_token0).balanceOf(address(this));
        uint balance1 = IERC20(_token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];
```

Периферійний контракт передав ліквідність для спалювання в цей контракт перед викликом. Таким чином ми знаємо, скільки ліквідності спалити, і можемо переконатися, що вона буде спалена.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // економія газу, має бути визначено тут, оскільки totalSupply може оновлюватися в _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // використання балансів забезпечує пропорційний розподіл
        amount1 = liquidity.mul(balance1) / _totalSupply; // використання балансів забезпечує пропорційний розподіл
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
```

Постачальник ліквідності отримує однакову вартість обох токенів. Таким чином ми не змінюємо обмінний курс.

```solidity
        _burn(address(this), liquidity);
        _safeTransfer(_token0, to, amount0);
        _safeTransfer(_token1, to, amount1);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 і reserve1 оновлені
        emit Burn(msg.sender, amount0, amount1, to);
    }

```

Решта функції `burn` є дзеркальним відображенням функції `mint` вище.

##### обмін

```solidity
    // цю низькорівневу функцію слід викликати з контракту, який виконує важливі перевірки безпеки
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
```

Цю функцію також слід викликати з [периферійного контракту](#UniswapV2Router02).

```solidity
        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // економія газу
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

        uint balance0;
        uint balance1;
        { // область видимості для _token{0,1}, уникає помилок «стек занадто глибокий»
```

Локальні змінні можна зберігати або в пам'яті, або, якщо їх не надто багато, безпосередньо в стеку.
Якщо ми можемо обмежити їх кількість, щоб використовувати стек, ми використовуємо менше газу. Для отримання додаткової інформації див. [жовту книгу, офіційні специфікації Ethereum](https://ethereum.github.io/yellowpaper/paper.pdf), с. 26, рівняння 298.

```solidity
            address _token0 = token0;
            address _token1 = token1;
            require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // оптимістично передаємо токени
            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // оптимістично передаємо токени
```

Цей переказ є оптимістичним, оскільки ми передаємо кошти до того, як переконаємося, що всі умови виконані. Це нормально в Ethereum, тому що якщо умови не будуть виконані пізніше під час виклику, ми скасуємо його та будь-які зміни, які він створив.

```solidity
            if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
```

Повідомте одержувача про обмін, якщо це необхідно.

```solidity
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
```

Отримати поточні баланси. Периферійний контракт надсилає нам токени перед тим, як викликати нас для обміну. Це полегшує контракту перевірку того, що його не обманюють — перевірка, яка _має_ відбуватися в основному контракті (оскільки нас можуть викликати інші суб’єкти, крім нашого периферійного контракту).

```solidity
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // область видимості для reserve{0,1}Adjusted, уникає помилок «стек занадто глибокий»
            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
```

Це перевірка на адекватність, щоб переконатися, що ми не втрачаємо від обміну. За жодних обставин обмін не повинен зменшувати `reserve0*reserve1`. Тут також ми забезпечуємо, щоб під час обміну стягувалася комісія в розмірі 0,3%; перш ніж перевіряти значення K на адекватність, ми множимо обидва баланси на 1000, віднімаючи суми, помножені на 3, це означає, що 0,3% (3/1000 = 0,003 = 0,3%) віднімається з балансу перед порівнянням його значення K зі значенням K поточних резервів.

```solidity
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }
```

Оновіть `reserve0` і `reserve1`, а за необхідності — акумулятори цін і часову мітку, та випустіть подію.

##### Синхронізація або зняття

Можливо, що реальні баланси розсинхронізуються з резервами, які, на думку парної біржі, вона має.
Немає способу вивести токени без згоди контракту, але депозити — це інша справа. Рахунок може переказувати токени на біржу, не викликаючи ні `mint`, ні `swap`.

У цьому випадку є два рішення:

- `sync` — оновити резерви до поточних балансів
- `skim` — вивести зайву суму. Зверніть увагу, що будь-який рахунок може викликати `skim`, оскільки ми не знаємо, хто вніс токени. Ця інформація випромінюється в події, але події не доступні з блокчейну.

```solidity
    // примусово змусити баланси відповідати резервам
    function skim(address to) external lock {
        address _token0 = token0; // економія газу
        address _token1 = token1; // економія газу
        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
    }



    // примусово змусити резерви відповідати балансам
    function sync() external lock {
        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
    }
}
```

### UniswapV2Factory.sol {#UniswapV2Factory}

[Цей контракт](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol) створює парні обміни.

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Factory.sol';
import './UniswapV2Pair.sol';

contract UniswapV2Factory is IUniswapV2Factory {
    address public feeTo;
    address public feeToSetter;
```

Ці змінні стану необхідні для реалізації комісії протоколу (див. [білу книгу](https://app.uniswap.org/whitepaper.pdf), с. 5).
Адреса `feeTo` накопичує токени ліквідності для комісії протоколу, а `feeToSetter` — це адреса, якій дозволено змінювати `feeTo` на іншу адресу.

```solidity
    mapping(address => mapping(address => address)) public getPair;
    address[] public allPairs;
```

Ці змінні відстежують пари, тобто обміни між двома типами токенів.

Перша, `getPair`, — це відображення, яке ідентифікує контракт парного обміну на основі двох токенів ERC-20, які він обмінює. Токени ERC-20 ідентифікуються за адресами контрактів, які їх реалізують, тому ключі та значення є адресами. Щоб отримати адресу парного обміну, яка дозволяє конвертувати `tokenA` в `tokenB`, ви використовуєте `getPair[<адреса tokenA>][<адреса tokenB>]` (або навпаки).

Друга змінна, `allPairs`, — це масив, що містить усі адреси парних бірж, створених цією фабрикою. В Ethereum ви не можете ітерувати по вмісту відображення або отримати список усіх ключів, тому ця змінна є єдиним способом дізнатися, якими біржами керує ця фабрика.

Примітка: причина, чому ви не можете ітерувати по всіх ключах відображення, полягає в тому, що зберігання даних контракту _дороге_, тому чим менше ми його використовуємо і чим рідше змінюємо, тим краще. Ви можете створювати [відображення, які підтримують ітерацію](https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol), але вони вимагають додаткового сховища для списку ключів. У більшості застосунків це не потрібно.

```solidity
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

Ця подія випромінюється, коли створюється новий парний обмін. Вона включає адреси токенів, адресу парної біржі та загальну кількість бірж, керованих фабрикою.

```solidity
    constructor(address _feeToSetter) public {
        feeToSetter = _feeToSetter;
    }
```

Єдине, що робить конструктор, — це вказує `feeToSetter`. Фабрики починають без комісії, і тільки `feeSetter` може це змінити.

```solidity
    function allPairsLength() external view returns (uint) {
        return allPairs.length;
    }
```

Ця функція повертає кількість пар обміну.

```solidity
    function createPair(address tokenA, address tokenB) external returns (address pair) {
```

Це основна функція фабрики — створення парного обміну між двома токенами ERC-20. Зверніть увагу, що будь-хто може викликати цю функцію. Вам не потрібен дозвіл від Uniswap, щоб створити новий парний обмін.

```solidity
        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
```

Ми хочемо, щоб адреса нової біржі була детермінованою, щоб її можна було обчислити заздалегідь поза ланцюгом (це може бути корисно для [транзакцій рівня 2](/developers/docs/scaling/)).
Для цього нам потрібен послідовний порядок адрес токенів, незалежно від порядку, в якому ми їх отримали, тому ми сортуємо їх тут.

```solidity
        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // достатньо однієї перевірки
```

Великі пули ліквідності кращі за малі, оскільки вони мають більш стабільні ціни. Ми не хочемо мати більше одного пулу ліквідності на пару токенів. Якщо біржа вже існує, немає потреби створювати ще одну для тієї ж пари.

```solidity
        bytes memory bytecode = type(UniswapV2Pair).creationCode;
```

Щоб створити новий контракт, нам потрібен код, який його створює (і функція конструктора, і код, який записує в пам’ять байт-код EVM фактичного контракту). Зазвичай у Solidity ми просто використовуємо `addr = new <name of contract>(<constructor parameters>)`, і компілятор дбає про все за нас, але щоб мати детерміновану адресу контракту, нам потрібно використовувати [опкод CREATE2](https://eips.ethereum.org/EIPS/eip-1014).
Коли цей код був написаний, цей опкод ще не підтримувався Solidity, тому було необхідно вручну отримувати код. Це більше не є проблемою, оскільки [Solidity тепер підтримує CREATE2](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2).

```solidity
        bytes32 salt = keccak256(abi.encodePacked(token0, token1));
        assembly {
            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
        }
```

Коли опкод ще не підтримується Solidity, ми можемо викликати його за допомогою [вбудованого асемблера](https://docs.soliditylang.org/en/v0.8.3/assembly.html).

```solidity
        IUniswapV2Pair(pair).initialize(token0, token1);
```

Викличте функцію `initialize`, щоб повідомити новій біржі, які два токени вона обмінює.

```solidity
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair; // заповнити відображення у зворотному напрямку
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }
```

Збережіть інформацію про нову пару у змінних стану та випустіть подію, щоб повідомити світу про нову парну біржу.

```solidity
    function setFeeTo(address _feeTo) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeTo = _feeTo;
    }

    function setFeeToSetter(address _feeToSetter) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeToSetter = _feeToSetter;
    }
}
```

Ці дві функції дозволяють `feeSetter` контролювати одержувача комісії (якщо такий є) та змінювати `feeSetter` на нову адресу.

### UniswapV2ERC20.sol {#UniswapV2ERC20}

[Цей контракт](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol) реалізує токен ліквідності ERC-20. Він схожий на [контракт ERC-20 від OpenZeppelin](/developers/tutorials/erc20-annotated-code), тому я поясню лише ту частину, яка відрізняється — функціонал `permit`.

Транзакції в мережі Ethereum коштують ефір (ETH), що є еквівалентом реальних грошей. Якщо у вас є токени ERC-20, але немає ETH, ви не можете надсилати транзакції, тому ви нічого не можете з ними зробити. Одним із рішень цієї проблеми є [метатранзакції](https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/supporting-meta-transactions).
Власник токенів підписує транзакцію, яка дозволяє комусь іншому вивести токени поза ланцюгом, і надсилає її через Інтернет одержувачу. Одержувач, у якого є ETH, потім подає дозвіл від імені власника.

```solidity
    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
```

Цей хеш є [ідентифікатором для типу транзакції](https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash). Єдиний, який ми тут підтримуємо, — це `Permit` з цими параметрами.

```solidity
    mapping(address => uint) public nonces;
```

Для одержувача неможливо підробити цифровий підпис. Однак тривіально надіслати ту саму транзакцію двічі (це форма [атаки повторного відтворення](https://wikipedia.org/wiki/Replay_attack)). Щоб запобігти цьому, ми використовуємо [nonce](https://wikipedia.org/wiki/Cryptographic_nonce). Якщо nonce нового `Permit` не на одиницю більший за останній використаний, ми вважаємо його недійсним.

```solidity
    constructor() public {
        uint chainId;
        assembly {
            chainId := chainid
        }
```

Це код для отримання [ідентифікатора ланцюга](https://chainid.network/). Він використовує асемблерний діалект EVM під назвою [Yul](https://docs.soliditylang.org/en/v0.8.4/yul.html). Зверніть увагу, що в поточній версії Yul ви повинні використовувати `chainid()`, а не `chainid`.

```solidity
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }
```

Обчисліть [роздільник домену](https://eips.ethereum.org/EIPS/eip-712#rationale-for-domainseparator) для EIP-712.

```solidity
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
```

Це функція, яка реалізує дозволи. Вона отримує як параметри відповідні поля та три скалярні значення для [підпису](https://yos.io/2018/11/16/ethereum-signatures/) (v, r та s).

```solidity
        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
```

Не приймати транзакції після закінчення терміну дії.

```solidity
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
```

`abi.encodePacked(...)` — це повідомлення, яке ми очікуємо отримати. Ми знаємо, яким має бути nonce, тому нам не потрібно отримувати його як параметр.

Алгоритм підпису Ethereum очікує отримати 256 біт для підпису, тому ми використовуємо хеш-функцію `keccak256`.

```solidity
        address recoveredAddress = ecrecover(digest, v, r, s);
```

З дайджесту та підпису ми можемо отримати адресу, яка його підписала, використовуючи [ecrecover](https://coders-errand.com/ecrecover-signature-verification-ethereum/).

```solidity
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
        _approve(owner, spender, value);
    }

```

Якщо все гаразд, розглядати це як [схвалення ERC-20](https://eips.ethereum.org/EIPS/eip-20#approve).

## Периферійні контракти {#periphery-contracts}

Периферійні контракти — це API (інтерфейс прикладного програмування) для Uniswap. Вони доступні для зовнішніх викликів, або з інших контрактів, або з децентралізованих застосунків. Ви могли б викликати основні контракти безпосередньо, але це складніше, і ви можете втратити кошти, якщо припуститеся помилки. Основні контракти містять лише тести, щоб переконатися, що їх не обманюють, а не перевірки на адекватність для будь-кого іншого. Вони знаходяться в периферії, щоб їх можна було оновлювати за потреби.

### UniswapV2Router01.sol {#UniswapV2Router01}

[Цей контракт](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol) має проблеми, і [його більше не слід використовувати](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01). На щастя, периферійні контракти не мають стану і не зберігають жодних активів, тому його легко зняти з експлуатації та запропонувати людям використовувати натомість заміну, `UniswapV2Router02`.

### UniswapV2Router02.sol {#UniswapV2Router02}

У більшості випадків ви будете використовувати Uniswap через [цей контракт](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol).
Ви можете побачити, як його використовувати, [тут](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02).

```solidity
pragma solidity =0.6.6;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';
import '@uniswap/lib/contracts/libraries/TransferHelper.sol';

import './interfaces/IUniswapV2Router02.sol';
import './libraries/UniswapV2Library.sol';
import './libraries/SafeMath.sol';
import './interfaces/IERC20.sol';
import './interfaces/IWETH.sol';
```

Більшість із них ми або зустрічали раніше, або вони досить очевидні. Єдиний виняток — `IWETH.sol`. Uniswap v2 дозволяє обмін будь-якої пари токенів ERC-20, але сам ефір (ETH) не є токеном ERC-20. Він існував до стандарту і передається за допомогою унікальних механізмів. Щоб уможливити використання ETH у контрактах, які застосовуються до токенів ERC-20, люди придумали контракт [«загорнутого» ефіру (WETH)](https://weth.tkn.eth.limo/). Ви надсилаєте цьому контракту ETH, і він карбує вам еквівалентну кількість WETH. Або ви можете спалити WETH і отримати назад ETH.

```solidity
contract UniswapV2Router02 is IUniswapV2Router02 {
    using SafeMath for uint;

    address public immutable override factory;
    address public immutable override WETH;
```

Роутеру потрібно знати, яку фабрику використовувати, а для транзакцій, що вимагають WETH, — який контракт WETH використовувати. Ці значення є [незмінними](https://docs.soliditylang.org/en/v0.8.3/contracts.html#constant-and-immutable-state-variables), що означає, що їх можна встановити лише в конструкторі. Це дає користувачам впевненість, що ніхто не зможе змінити їх так, щоб вони вказували на менш чесні контракти.

```solidity
    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }
```

Цей модифікатор гарантує, що транзакції з обмеженням часу («зробити X до часу Y, якщо можливо») не відбуваються після їхнього часового ліміту.

```solidity
    constructor(address _factory, address _WETH) public {
        factory = _factory;
        WETH = _WETH;
    }
```

Конструктор лише встановлює незмінні змінні стану.

```solidity
    receive() external payable {
        assert(msg.sender == WETH); // приймати ETH лише через fallback з контракту WETH
    }
```

Ця функція викликається, коли ми викуповуємо токени з контракту WETH назад в ETH. Лише контракт WETH, який ми використовуємо, має право це робити.

#### Додавання ліквідності {#add-liquidity}

Ці функції додають токени до парної біржі, що збільшує пул ліквідності.

```solidity

    // **** ДОДАВАННЯ ЛІКВІДНОСТІ ****
    function _addLiquidity(
```

Ця функція використовується для обчислення кількості токенів A і B, які слід внести на парну біржу.

```solidity
        address tokenA,
        address tokenB,
```

Це адреси контрактів токенів ERC-20.

```solidity
        uint amountADesired,
        uint amountBDesired,
```

Це суми, які постачальник ліквідності хоче внести. Вони також є максимальними сумами A і B, які будуть внесені.

```solidity
        uint amountAMin,
        uint amountBMin
```

Це мінімальні прийнятні суми для депозиту. Якщо транзакція не може відбутися з цими сумами або більшими, скасуйте її. Якщо вам не потрібна ця функція, просто вкажіть нуль.

Постачальники ліквідності зазвичай вказують мінімум, оскільки вони хочуть обмежити транзакцію обмінним курсом, близьким до поточного. Якщо обмінний курс коливається занадто сильно, це може означати новини, які змінюють базові вартості, і вони хочуть вручну вирішити, що робити.

Наприклад, уявіть випадок, коли обмінний курс становить один до одного, і постачальник ліквідності вказує такі значення:

| Параметр       | Значення |
| -------------- | -------: |
| amountADesired |     1000 |
| amountBDesired |     1000 |
| amountAMin     |      900 |
| amountBMin     |      800 |

Поки обмінний курс залишається між 0,9 і 1,25, транзакція відбувається. Якщо обмінний курс виходить за межі цього діапазону, транзакція скасовується.

Причина цього запобіжного заходу полягає в тому, що транзакції не є миттєвими: ви їх надсилаєте, і згодом валідатор включить їх у блок (якщо тільки ціна на газ не дуже низька, і в цьому випадку вам доведеться надіслати іншу транзакцію з тим самим nonce і вищою ціною на газ, щоб її перезаписати). Ви не можете контролювати те, що відбувається в проміжку між поданням і включенням.

```solidity
    ) internal virtual returns (uint amountA, uint amountB) {
```

Функція повертає суми, які постачальник ліквідності повинен внести, щоб мати співвідношення, рівне поточному співвідношенню між резервами.

```solidity
        // створити пару, якщо її ще не існує
        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
            IUniswapV2Factory(factory).createPair(tokenA, tokenB);
        }
```

Якщо для цієї пари токенів ще немає біржі, створіть її.

```solidity
        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
```

Отримати поточні резерви в парі.

```solidity
        if (reserveA == 0 && reserveB == 0) {
            (amountA, amountB) = (amountADesired, amountBDesired);
```

Якщо поточні резерви порожні, то це новий парний обмін. Суми, що вносяться, повинні точно відповідати тим, які хоче надати постачальник ліквідності.

```solidity
        } else {
            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
```

Якщо нам потрібно побачити, якими будуть суми, ми отримуємо оптимальну суму за допомогою [цієї функції](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol#L35). Ми хочемо, щоб співвідношення було таким же, як і в поточних резервах.

```solidity
            if (amountBOptimal <= amountBDesired) {
                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
                (amountA, amountB) = (amountADesired, amountBOptimal);
```

Якщо `amountBOptimal` менше суми, яку постачальник ліквідності хоче внести, це означає, що токен B наразі цінніший, ніж думає постачальник ліквідності, тому потрібна менша сума.

```solidity
            } else {
                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
                assert(amountAOptimal <= amountADesired);
                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
                (amountA, amountB) = (amountAOptimal, amountBDesired);
```

Якщо оптимальна сума B більша за бажану суму B, це означає, що токени B наразі менш цінні, ніж думає постачальник ліквідності, тому потрібна більша сума. Однак бажана сума є максимальною, тому ми не можемо цього зробити. Натомість ми обчислюємо оптимальну кількість токенів A для бажаної кількості токенів B.

Зібравши все разом, ми отримуємо цей графік. Припустимо, ви намагаєтеся внести тисячу токенів A (синя лінія) і тисячу токенів B (червона лінія). Вісь X — це обмінний курс, A/B. Якщо x=1, вони рівні за вартістю, і ви вносите по тисячі кожного. Якщо x=2, A вдвічі цінніший за B (ви отримуєте два токени B за кожен токен A), тому ви вносите тисячу токенів B, але лише 500 токенів A. Якщо x=0.5, ситуація зворотна: тисяча токенів A і п'ятсот токенів B.

![Графік](liquidityProviderDeposit.png)

Ви могли б внести ліквідність безпосередньо в основний контракт (використовуючи [UniswapV2Pair::mint](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol#L110)), але основний контракт лише перевіряє, що його не обманюють, тому ви ризикуєте втратити вартість, якщо обмінний курс зміниться між часом, коли ви подасте транзакцію, і часом її виконання. Якщо ви використовуєте периферійний контракт, він визначає суму, яку ви повинні внести, і вносить її негайно, тому обмінний курс не змінюється, і ви нічого не втрачаєте.

```solidity
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
```

Ця функція може бути викликана транзакцією для внесення ліквідності. Більшість параметрів такі ж, як і в `_addLiquidity` вище, за двома винятками:

. `to` — це адреса, яка отримує нові викарбувані токени ліквідності, щоб показати частку постачальника ліквідності в пулі
. `deadline` — це часовий ліміт для транзакції

```solidity
    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
```

Ми обчислюємо суми для фактичного депозиту, а потім знаходимо адресу пулу ліквідності. Щоб заощадити газ, ми не робимо це, запитуючи фабрику, а використовуємо функцію бібліотеки `pairFor` (див. нижче в бібліотеках).

```solidity
        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
```

Перекажіть правильні суми токенів від користувача на парну біржу.

```solidity
        liquidity = IUniswapV2Pair(pair).mint(to);
```

Натомість надайте на адресу `to` токени ліквідності для часткового володіння пулом. Функція `mint` основного контракту бачить, скільки додаткових токенів вона має (порівняно з тим, що було востаннє, коли змінювалася ліквідність), і відповідно карбує ліквідність.

```solidity
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
```

Коли постачальник ліквідності хоче надати ліквідність для парного обміну Token/ETH, є кілька відмінностей. Контракт обробляє обгортання ETH для постачальника ліквідності. Немає потреби вказувати, скільки ETH користувач хоче внести, оскільки користувач просто надсилає їх разом із транзакцією (сума доступна в `msg.value`).

```solidity
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
        (amountToken, amountETH) = _addLiquidity(
            token,
            WETH,
            amountTokenDesired,
            msg.value,
            amountTokenMin,
            amountETHMin
        );
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
        IWETH(WETH).deposit{value: amountETH}();
        assert(IWETH(WETH).transfer(pair, amountETH));
```

Щоб внести ETH, контракт спочатку обгортає його в WETH, а потім переказує WETH у пару. Зверніть увагу, що переказ обгорнутий в `assert`. Це означає, що якщо переказ не вдасться, цей виклик контракту також не вдасться, і тому обгортання насправді не відбувається.

```solidity
        liquidity = IUniswapV2Pair(pair).mint(to);
        // повернути залишок eth, якщо є
        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
    }
```

Користувач уже надіслав нам ETH, тому якщо залишився якийсь залишок (оскільки інший токен менш цінний, ніж думав користувач), нам потрібно повернути гроші.

#### Вилучення ліквідності {#remove-liquidity}

Ці функції видалять ліквідність і повернуть кошти постачальнику ліквідності.

```solidity
    // **** ВИДАЛЕННЯ ЛІКВІДНОСТІ ****
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {
```

Найпростіший випадок видалення ліквідності. Існує мінімальна кількість кожного токена, яку постачальник ліквідності погоджується прийняти, і це має відбутися до закінчення терміну дії.

```solidity
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // надіслати ліквідність парі
        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
```

Функція `burn` основного контракту обробляє повернення токенів користувачеві.

```solidity
        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
```

Коли функція повертає кілька значень, але нас цікавлять лише деякі з них, ось як ми отримуємо лише ці значення. Це дещо дешевше з точки зору газу, ніж читання значення і ніколи його не використання.

```solidity
        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
```

Перетворіть суми з того, як їх повертає основний контракт (спочатку токен із меншою адресою), на те, як їх очікує користувач (відповідно до `tokenA` та `tokenB`).

```solidity
        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
    }
```

Нормально спочатку виконати переказ, а потім перевірити його легітимність, тому що якщо він нелегітимний, ми скасуємо всі зміни стану.

```solidity
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {
        (amountToken, amountETH) = removeLiquidity(
            token,
            WETH,
            liquidity,
            amountTokenMin,
            amountETHMin,
            address(this),
            deadline
        );
        TransferHelper.safeTransfer(token, to, amountToken);
        IWETH(WETH).withdraw(amountETH);
        TransferHelper.safeTransferETH(to, amountETH);
    }
```

Видалення ліквідності для ETH майже таке ж, за винятком того, що ми отримуємо токени WETH, а потім викуповуємо їх за ETH, щоб повернути постачальнику ліквідності.

```solidity
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountA, uint amountB) {
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);
    }


    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountToken, uint amountETH) {
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);
    }
```

Ці функції передають метатранзакції, щоб дозволити користувачам без ефіру виводити кошти з пулу, використовуючи [механізм дозволу](#UniswapV2ERC20).

```solidity

    // **** ВИДАЛЕННЯ ЛІКВІДНОСТІ (підтримка токенів з комісією за переказ) ****
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountETH) {
        (, amountETH) = removeLiquidity(
            token,
            WETH,
            liquidity,
            amountTokenMin,
            amountETHMin,
            address(this),
            deadline
        );
        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
        IWETH(WETH).withdraw(amountETH);
        TransferHelper.safeTransferETH(to, amountETH);
    }

```

Цю функцію можна використовувати для токенів, які мають комісію за переказ або зберігання. Коли токен має такі комісії, ми не можемо покладатися на функцію `removeLiquidity`, щоб дізнатися, скільки токена ми отримаємо назад, тому нам потрібно спочатку вивести кошти, а потім отримати баланс.

```solidity


    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountETH) {
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(
            token, liquidity, amountTokenMin, amountETHMin, to, deadline
        );
    }
```

Остання функція поєднує плату за сховище з метатранзакціями.

#### Торгівля {#trade}

```solidity
    // **** ОБМІН ****
    // вимагає, щоб початкова сума вже була відправлена першій парі
    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {
```

Ця функція виконує внутрішню обробку, яка потрібна для функцій, доступних для трейдерів.

```solidity
        for (uint i; i < path.length - 1; i++) {
```

На момент написання цієї статті існує [388 160 токенів ERC-20](https://eth.blockscout.com/tokens). Якби існував парний обмін для кожної пари токенів, то було б понад 150 мільярдів парних обмінів. Увесь ланцюжок наразі [має лише 0,1 % від цієї кількості акаунтів](https://eth.blockscout.com/stats/accountsGrowth). Натомість функції обміну підтримують концепцію шляху. Трейдер може обміняти A на B, B на C і C на D, тому немає потреби в прямому обміні пари A-D.

Ціни на цих ринках, як правило, синхронізовані, оскільки коли вони несинхронізовані, це створює можливість для арбітражу. Уявіть, наприклад, три токени: A, B і C. Існує три парні обміни, по одному на кожну пару.

1. Початкова ситуація
2. Трейдер продає 24,695 токена A й отримує 25,305 токена B.
3. Трейдер продає 24,695 токена B за 25,305 токена C, залишаючи приблизно 0,61 токена B як прибуток.
4. Потім трейдер продає 24,695 токена C за 25,305 токена A, залишаючи приблизно 0,61 токена C як прибуток. У трейдера також є 0,61 додаткового токена A (25,305, які трейдер отримує в кінці, мінус початкові інвестиції в розмірі 24,695).

| Крок | Обмін A-B                                                   | Обмін B-C                                                   | Обмін A-C                                                   |
| ---- | ----------------------------------------------------------- | ----------------------------------------------------------- | ----------------------------------------------------------- |
| 1    | A:1000 B:1050 A/B=1,05      | B:1000 C:1050 B/C=1,05      | A:1050 C:1000 C/A=1,05      |
| 2    | A:1024,695 B:1024,695 A/B=1 | B:1000 C:1050 B/C=1,05      | A:1050 C:1000 C/A=1,05      |
| 3    | A:1024,695 B:1024,695 A/B=1 | B:1024,695 C:1024,695 B/C=1 | A:1050 C:1000 C/A=1,05      |
| 4    | A:1024,695 B:1024,695 A/B=1 | B:1024,695 C:1024,695 B/C=1 | A:1024,695 C:1024,695 C/A=1 |

```solidity
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            uint amountOut = amounts[i + 1];
```

Отримайте пару, яку ми зараз обробляємо, відсортуйте її (для використання з парою) та отримайте очікувану вихідну суму.

```solidity
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
```

Отримайте очікувані вихідні суми, відсортовані так, як їх очікує парний обмін.

```solidity
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
```

Це останній обмін? Якщо так, надішліть токени, отримані для торгівлі, до місця призначення. Якщо ні, надішліть їх на наступний парний обмін.

```solidity

            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
                amount0Out, amount1Out, to, new bytes(0)
            );
        }
    }
```

Фактично викликайте парний обмін, щоб обміняти токени. Нам не потрібен зворотний виклик для сповіщення про обмін, тому ми не надсилаємо жодних байтів у це поле.

```solidity
    function swapExactTokensForTokens(
```

Ця функція використовується трейдерами безпосередньо для обміну одного токена на інший.

```solidity
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
```

Цей параметр містить адреси контрактів ERC-20. Як пояснювалося вище, це масив, тому що вам, можливо, доведеться пройти через кілька парних обмінів, щоб дістатися від активу, який у вас є, до активу, який ви хочете отримати.

Параметр функції в Solidity може зберігатися або в `memory`, або в `calldata`. Якщо функція є точкою входу до контракту, що викликається безпосередньо користувачем (за допомогою транзакції) або з іншого контракту, то значення параметра можна взяти безпосередньо з даних виклику. Якщо функція викликається внутрішньо, як `_swap` вище, то параметри мають зберігатися в `memory`. З точки зору викликаного контракту `calldata` є лише для читання.

Зі скалярними типами, такими як `uint` або `address`, компілятор сам обирає для нас сховище, але для масивів, які є довшими та дорожчими, ми вказуємо тип сховища, який потрібно використовувати.

```solidity
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
```

Значення, що повертаються, завжди повертаються в пам'яті (`memory`).

```solidity
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
```

Обчисліть суму, яка буде придбана під час кожного обміну. Якщо результат менший за мінімум, який готовий прийняти трейдер, скасуйте транзакцію.

```solidity
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

Нарешті, перекажіть початковий токен ERC-20 на акаунт для першого парного обміну та викличте `_swap`. Це все відбувається в одній транзакції, тому парний обмін знає, що будь-які неочікувані токени є частиною цього переказу.

```solidity
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

Попередня функція, `swapTokensForTokens`, дозволяє трейдеру вказати точну кількість вхідних токенів, які він готовий віддати, і мінімальну кількість вихідних токенів, які він готовий отримати натомість. Ця функція виконує зворотний обмін: вона дозволяє трейдеру вказати кількість вихідних токенів, які він хоче отримати, і максимальну кількість вхідних токенів, які він готовий за них заплатити.

В обох випадках трейдер повинен спочатку надати цьому периферійному контракту дозвіл на переказ коштів.

```solidity
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
    }


    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }



    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }


    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
        // повернути залишки ETH, якщо вони є
        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);
    }
```

Усі ці чотири варіанти передбачають торгівлю між ETH і токенами. Єдина відмінність полягає в тому, що ми або отримуємо ETH від трейдера та використовуємо його для карбування WETH, або отримуємо WETH від останнього обміну на шляху та спалюємо його, повертаючи трейдеру отриманий ETH.

```solidity
    // **** ОБМІН (з підтримкою токенів з комісією за переказ) ****
    // вимагає, щоб початкова сума вже була відправлена першій парі
    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {
```

Це внутрішня функція для обміну токенів, що мають комісію за переказ або зберігання, щоб вирішити ([цю проблему](https://github.com/Uniswap/uniswap-interface/issues/835)).

```solidity
        for (uint i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));
            uint amountInput;
            uint amountOutput;
            { // область видимості для уникнення помилок 'stack too deep'
            (uint reserve0, uint reserve1,) = pair.getReserves();
            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
```

Через комісії за переказ ми не можемо покладатися на функцію `getAmountsOut`, щоб дізнатися, скільки ми отримуємо з кожного переказу (так, як ми це робили перед викликом початкової функції `_swap`). Натомість ми повинні спочатку здійснити переказ, а потім подивитися, скільки токенів ми отримали назад.

Примітка. Теоретично, ми могли б просто використовувати цю функцію замість `_swap`, але в певних випадках (наприклад, якщо переказ у кінцевому підсумку буде скасовано, оскільки наприкінці не вистачить коштів для досягнення необхідного мінімуму), це коштуватиме більше газу. Токени з комісією за переказ досить рідкісні, тому, хоча ми повинні їх підтримувати, немає необхідності, щоб усі обміни припускали, що вони проходять хоча б через один із них.

```solidity
            }
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
            pair.swap(amount0Out, amount1Out, to, new bytes(0));
        }
    }


    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) {
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        payable
        ensure(deadline)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        uint amountIn = msg.value;
        IWETH(WETH).deposit{value: amountIn}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        ensure(deadline)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        _swapSupportingFeeOnTransferTokens(path, address(this));
        uint amountOut = IERC20(WETH).balanceOf(address(this));
        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).withdraw(amountOut);
        TransferHelper.safeTransferETH(to, amountOut);
    }
```

Це ті самі варіанти, що використовуються для звичайних токенів, але замість цього вони викликають `_swapSupportingFeeOnTransferTokens`.

```solidity
    // **** ФУНКЦІЇ БІБЛІОТЕКИ ****
    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {
        return UniswapV2Library.quote(amountA, reserveA, reserveB);
    }

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountOut)
    {
        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
    }

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountIn)
    {
        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);
    }

    function getAmountsOut(uint amountIn, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsOut(factory, amountIn, path);
    }

    function getAmountsIn(uint amountOut, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsIn(factory, amountOut, path);
    }
}
```

Ці функції є просто проксі, які викликають [функції UniswapV2Library](#uniswapV2library).

### UniswapV2Migrator.sol {#UniswapV2Migrator}

Цей контракт використовувався для міграції обмінів зі старої версії v1 на v2. Тепер, коли вони перенесені, він більше не актуальний.

## Бібліотеки {#libraries}

[Бібліотека SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math) добре задокументована, тому немає потреби документувати її тут.

### Math {#Math}

Ця бібліотека містить деякі математичні функції, які зазвичай не потрібні в коді на Solidity, тому вони не є частиною мови.

```solidity
pragma solidity =0.5.16;

// бібліотека для виконання різних математичних операцій

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // вавилонський метод (https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
```

Почніть з x як оцінки, що є вищою за квадратний корінь (ось чому нам потрібно розглядати 1-3 як особливі випадки).

```solidity
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
```

Отримайте ближчу оцінку: середнє значення попередньої оцінки та числа, квадратний корінь якого ми намагаємося знайти, поділене на попередню оцінку. Повторюйте, поки нова оцінка не стане нижчою за наявну. Для отримання додаткової інформації [дивіться тут](https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).

```solidity
            }
        } else if (y != 0) {
            z = 1;
```

Нам ніколи не знадобиться квадратний корінь з нуля. Квадратні корені з одиниці, двох і трьох приблизно дорівнюють одиниці (ми використовуємо цілі числа, тому ігноруємо дробову частину).

```solidity
        }
    }
}
```

### Дроби з фіксованою комою (UQ112x112) {#FixedPoint}

Ця бібліотека обробляє дроби, які зазвичай не є частиною арифметики Ethereum. Вона робить це шляхом кодування числа _x_ як _x\*2^112_. Це дозволяє нам використовувати вихідні коди операцій додавання та віднімання без змін.

```solidity
pragma solidity =0.5.16;

// бібліотека для роботи з двійковими числами з фіксованою комою (https://wikipedia.org/wiki/Q_(number_format))

// діапазон: [0, 2**112 - 1]
// роздільна здатність: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;
```

`Q112` — це кодування одиниці.

```solidity
    // кодувати uint112 як UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // ніколи не переповнюється
    }
```

Оскільки y є `uint112`, максимальне значення, яке він може приймати, — це 2^112-1. Це число все ще можна закодувати як `UQ112x112`.

```solidity
    // ділить UQ112x112 на uint112, повертаючи UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}
```

Якщо ми ділимо два значення `UQ112x112`, результат більше не множиться на 2^112. Тому замість цього ми беремо ціле число для знаменника. Нам би знадобився подібний трюк для множення, але нам не потрібно множити значення `UQ112x112`.

### UniswapV2Library {#uniswapV2library}

Ця бібліотека використовується лише периферійними контрактами

```solidity
pragma solidity >=0.5.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import "./SafeMath.sol";

library UniswapV2Library {
    using SafeMath for uint;

    // повертає відсортовані адреси токенів, що використовуються для обробки значень, що повертаються з пар, відсортованих у цьому порядку
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }
```

Відсортуйте два токени за адресою, щоб ми могли отримати адресу парного обміну для них. Це необхідно, тому що інакше ми мали б дві можливості: одну для параметрів A, B і іншу для параметрів B, A, що призвело б до двох обмінів замість одного.

```solidity
    // обчислює адресу CREATE2 для пари без зовнішніх викликів
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // хеш коду ініціалізації
            ))));
    }
```

Ця функція обчислює адресу парного обміну для двох токенів. Цей контракт створюється за допомогою [коду операції CREATE2](https://eips.ethereum.org/EIPS/eip-1014), тому ми можемо обчислити адресу, використовуючи той самий алгоритм, якщо ми знаємо параметри, які він використовує. Це набагато дешевше, ніж запитувати фабрику, і

```solidity
    // отримує та сортує резерви для пари
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
```

Ця функція повертає резерви двох токенів, які є у парного обміну. Зверніть увагу, що вона може отримувати токени в будь-якому порядку і сортує їх для внутрішнього використання.

```solidity
    // маючи певну кількість активу та резерви пари, повертає еквівалентну кількість іншого активу
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }
```

Ця функція надає вам кількість токена B, яку ви отримаєте в обмін на токен A, якщо немає комісії. Цей розрахунок враховує, що переказ змінює обмінний курс.

```solidity
    // маючи вхідну кількість активу та резерви пари, повертає максимальну вихідну кількість іншого активу
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
```

Наведена вище функція `quote` чудово працює, якщо немає плати за використання парного обміну. Однак, якщо є комісія за обмін у розмірі 0,3 %, сума, яку ви фактично отримаєте, буде меншою. Ця функція розраховує суму після сплати комісії за обмін.

```solidity

        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
```

Solidity не підтримує дроби нативно, тому ми не можемо просто помножити вихідну суму на 0,997. Замість цього ми множимо чисельник на 997, а знаменник на 1000, досягаючи того ж ефекту.

```solidity
    // маючи вихідну кількість активу та резерви пари, повертає необхідну вхідну кількість іншого активу
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }
```

Ця функція робить приблизно те ж саме, але вона отримує вихідну суму і надає вхідну.

```solidity

    // виконує ланцюгові розрахунки getAmountOut для будь-якої кількості пар
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // виконує ланцюгові розрахунки getAmountIn для будь-якої кількості пар
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}
```

Ці дві функції обробляють ідентифікацію значень, коли необхідно пройти через кілька парних обмінів.

### Помічник з переказів {#transfer-helper}

[Ця бібліотека](https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol) додає перевірки успішності для переказів ERC-20 та Ethereum, щоб однаково обробляти скасування (`revert`) і повернення значення `false`.

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.6.0;

// допоміжні методи для взаємодії з токенами ERC20 та надсилання ETH, які не завжди повертають true/false
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));

```

Ми можемо викликати інший контракт одним із двох способів:

- Використовувати визначення інтерфейсу для створення виклику функції
- Використовувати [двійковий інтерфейс програми (ABI)](https://docs.soliditylang.org/en/v0.8.3/abi-spec.html) «вручну» для створення виклику. Саме так вирішив зробити автор коду.

```solidity
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }
```

Для зворотної сумісності з токенами, створеними до стандарту ERC-20, виклик ERC-20 може завершитися невдачею або шляхом скасування (`revert`) (у цьому випадку `success` дорівнює `false`), або шляхом успішного виконання з поверненням значення `false` (у цьому випадку є вихідні дані, і якщо ви декодуєте їх як логічне значення, ви отримаєте `false`).

```solidity


    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }
```

Ця функція реалізує [функціональність `transfer` стандарту ERC-20](https://eips.ethereum.org/EIPS/eip-20#transfer), яка дозволяє акаунту витрачати кошти в межах дозволу, наданого іншим акаунтом.

```solidity

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }
```

Ця функція реалізує [функціональність `transferFrom` стандарту ERC-20](https://eips.ethereum.org/EIPS/eip-20#transferfrom), яка дозволяє акаунту витрачати кошти в межах дозволу, наданого іншим акаунтом.

```solidity

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}
```

Ця функція переказує ефір на акаунт. Будь-який виклик до іншого контракту може спробувати надіслати ефір. Оскільки нам не потрібно викликати жодної функції, ми не надсилаємо жодних даних із викликом.

## Висновок {#conclusion}

Це довга стаття обсягом близько 50 сторінок. Якщо ви дійшли до цього місця, вітаємо! Сподіваємося, що тепер ви зрозуміли, що слід враховувати під час написання реального застосунку (на відміну від коротких прикладів програм) і зможете краще писати контракти для власних сценаріїв використання.

А тепер ідіть, напишіть щось корисне і здивуйте нас.

[Більше моїх робіт дивіться тут](https://cryptodocguy.pro/).
