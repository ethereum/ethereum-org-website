---
title: Вступ до Ethereum для розробників на Python, частина 1
description: Вступ до розробки на Ethereum, особливо корисний для тих, хто знайомий з мовою програмування Python.
author: Марк Гарро
lang: uk
tags: [ "python", "web3.py" ]
skill: beginner
published: 2020-09-08
source: Заклинателі змій
sourceUrl: https://snakecharmers.ethereum.org/a-developers-guide-to-ethereum-pt-1/
---

Отже, ви чули про таку річ, як Ethereum, і готові пірнути в кролячу нору? У цій статті ми швидко розглянемо деякі основи блокчейну, а потім ви зможете взаємодіяти з імітованим вузлом Ethereum: читати дані блоків, перевіряти баланси рахунків і надсилати транзакції. Попутно ми підкреслимо відмінності між традиційними способами створення застосунків і цією новою децентралізованою парадигмою.

## (Необов'язкові) попередні вимоги {#soft-prerequisites}

Ця стаття має на меті бути доступною для широкого кола розробників. Будуть використовуватися [інструменти Python](/developers/docs/programming-languages/python/), але вони лише засіб для демонстрації ідей – не хвилюйтеся, якщо ви не є розробником на Python. Однак я зроблю кілька припущень щодо того, що ви вже знаєте, щоб ми могли швидше перейти до специфіки Ethereum.

Припущення:

- Ви вмієте користуватися терміналом,
- Ви написали кілька рядків коду на Python,
- На вашому комп’ютері встановлено Python версії 3.6 або новішої (наполегливо рекомендується використовувати [віртуальне середовище](https://realpython.com/effective-python-environment/#virtual-environments)), і
- ви користувалися `pip`, інсталятором пакунків Python.
  Знову ж таки, якщо щось із цього не відповідає дійсності або ви не плануєте відтворювати код із цієї статті, ви, імовірно, все одно зможете без проблем стежити за викладом.

## Коротко про блокчейни {#blockchains-briefly}

Існує багато способів описати Ethereum, але в його основі лежить блокчейн. Блокчейни складаються з послідовності блоків, тож почнімо з цього. Простіше кажучи, кожен блок у блокчейні Ethereum — це лише деякі метадані та список транзакцій. У форматі JSON це виглядає приблизно так:

```json
{
   "number": 1234567,
   "hash": "0xabc123...",
   "parentHash": "0xdef456...",
   ...,
   "transactions": [...]
}
```

Кожен [блок](/developers/docs/blocks/) має посилання на попередній блок; `parentHash` — це просто хеш попереднього блоку.

<FeaturedText>Примітка: Ethereum регулярно використовує <a href="https://wikipedia.org/wiki/Hash_function">хеш-функції</a> для створення значень фіксованого розміру («хешів»). Хеші відіграють важливу роль в Ethereum, але поки що ви можете сміливо вважати їх унікальними ідентифікаторами.</FeaturedText>

![Діаграма, що зображує блокчейн, включно з даними всередині кожного блоку](./blockchain-diagram.png)

_Блокчейн — це, по суті, зв’язний список; кожен блок має посилання на попередній._

Ця структура даних не є чимось новим, але правила (тобто однорангові протоколи), які керують мережею, — є. Немає центрального органу влади; мережа рівноправних учасників повинна співпрацювати для підтримки мережі та конкурувати за право вирішувати, які транзакції включати в наступний блок. Отже, коли ви хочете надіслати гроші другові, вам потрібно буде транслювати цю транзакцію в мережу, а потім чекати, доки її буде включено до одного з наступних блоків.

Єдиний спосіб для блокчейну перевірити, що гроші дійсно були надіслані від одного користувача іншому, — це використовувати власну валюту цього блокчейну (тобто створену та керовану ним). У Ethereum ця валюта називається «етер», і блокчейн Ethereum містить єдиний офіційний запис балансів рахунків.

## Нова парадигма {#a-new-paradigm}

Цей новий децентралізований технологічний стек породив нові інструменти для розробників. Такі інструменти існують для багатьох мов програмування, але ми розглядатимемо їх крізь призму Python. Повторимо: навіть якщо Python — не та мова, якій ви віддаєте перевагу, вам не складе труднощів стежити за матеріалом.

Розробники на Python, які хочуть взаємодіяти з Ethereum, найімовірніше, скористаються [Web3.py](https://web3py.readthedocs.io/). Web3.py — це бібліотека, яка значно спрощує спосіб підключення до вузла Ethereum, а також надсилання та отримання даних із нього.

<FeaturedText>Примітка: «вузол Ethereum» і «клієнт Ethereum» використовуються як взаємозамінні поняття. У будь-якому випадку, йдеться про програмне забезпечення, яке запускає учасник мережі Ethereum. Це програмне забезпечення може читати дані блоків, отримувати оновлення, коли до ланцюга додаються нові блоки, транслювати нові транзакції тощо. Технічно, клієнт — це програмне забезпечення, а вузол — це комп'ютер, на якому це програмне забезпечення запущено.</FeaturedText>

[Клієнти Ethereum](/developers/docs/nodes-and-clients/) можна налаштувати так, щоб вони були доступні через [IPC](https://wikipedia.org/wiki/Inter-process_communication), HTTP або WebSocket, тому Web3.py повинен буде віддзеркалювати цю конфігурацію. Web3.py називає ці варіанти підключення **провайдерами**. Вам потрібно буде вибрати одного з трьох провайдерів, щоб зв'язати екземпляр Web3.py з вашим вузлом.

![Діаграма, що показує, як web3.py використовує IPC для підключення вашого застосунку до вузла Ethereum](./web3py-and-nodes.png)

_Налаштуйте вузол Ethereum і Web3.py для зв’язку за тим самим протоколом, наприклад, IPC, як на цій діаграмі._

Щойно Web3.py буде правильно налаштовано, ви зможете почати взаємодіяти з блокчейном. Ось кілька прикладів використання Web3.py як анонс того, що буде далі:

```python
# зчитати дані блоку:
w3.eth.get_block('latest')

# надіслати транзакцію:
w3.eth.send_transaction({'from': ..., 'to': ..., 'value': ...})
```

## Встановлення {#installation}

У цьому покроковому керівництві ми будемо працювати лише в інтерпретаторі Python. Ми не будемо створювати жодних каталогів, файлів, класів чи функцій.

<FeaturedText>Примітка: у наведених нижче прикладах команди, що починаються з `$`, призначені для виконання в терміналі. (Не вводьте символ `$`, він лише позначає початок рядка.)</FeaturedText>

Спочатку встановіть [IPython](https://ipython.org/), щоб отримати зручне середовище для дослідження. IPython пропонує, серед іншого, автодоповнення за допомогою клавіші Tab, що значно полегшує вивчення можливостей Web3.py.

```bash
pip install ipython
```

Web3.py опубліковано під назвою `web3`. Встановіть його так:

```bash
pip install web3
```

Ще один момент: пізніше ми будемо імітувати блокчейн, для чого знадобиться ще кілька залежностей. Ви можете встановити їх за допомогою:

```bash
pip install 'web3[tester]'
```

Тепер ви готові до роботи!

Примітка: пакунок `web3[tester]` працює до версії Python 3.10.xx

## Запустіть пісочницю {#spin-up-a-sandbox}

Відкрийте нове середовище Python, запустивши `ipython` у вашому терміналі. Це схоже на запуск `python`, але з більшою кількістю додаткових можливостей.

```bash
ipython
```

Буде виведено певну інформацію про версії Python та IPython, які ви використовуєте, після чого ви побачите запрошення до введення:

```python
In [1]:
```

Тепер ви бачите інтерактивну оболонку Python. По суті, це пісочниця для експериментів. Якщо ви дійшли до цього етапу, час імпортувати Web3.py:

```python
In [1]: from web3 import Web3
```

## Знайомство з модулем Web3 {#introducing-the-web3-module}

Окрім того, що модуль [Web3](https://web3py.readthedocs.io/en/stable/overview.html#base-api) є шлюзом до Ethereum, він пропонує кілька зручних функцій. Розглянемо кілька з них.

У застосунку Ethereum вам часто доведеться конвертувати номінали валюти. Модуль Web3 надає для цього кілька допоміжних методів: [from_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.from_wei) та [to_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.to_wei).

<FeaturedText>
Примітка: Комп'ютери, як відомо, погано справляються з десятковою математикою. Щоб обійти це, розробники часто зберігають суми в доларах як суми в центах. Наприклад, товар вартістю 5,99 долара може зберігатися в базі даних як 599.

Схожий підхід використовується при обробці транзакцій в <b>етері</b>. Однак, замість двох знаків після коми, етер має 18! Найменша одиниця етеру називається <b>wei</b>, тому саме це значення вказується при надсиланні транзакцій.

1 етер = 1000000000000000000 wei

1 wei = 0.000000000000000001 етера

</FeaturedText>

Спробуйте конвертувати деякі значення в wei та з wei. Зверніть увагу, що [існують назви для багатьох номіналів](https://web3py.readthedocs.io/en/stable/troubleshooting.html#how-do-i-convert-currency-denominations) між етером і wei. Однією з найвідоміших серед них є **gwei**, оскільки саме так часто представляють комісію за транзакції.

```python
In [2]: Web3.to_wei(1, 'ether')
Out[2]: 1000000000000000000

In [3]: Web3.from_wei(500000000, 'gwei')
Out[3]: Decimal('0.5')
```

Інші утилітарні методи в модулі Web3 включають конвертери форматів даних (наприклад, [`toHex`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.toHex)), допоміжні функції для адрес (наприклад, [`isAddress`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.isAddress)) та хеш-функції (наприклад, [`keccak`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.keccak)). Багато з них буде розглянуто пізніше в цій серії. Щоб переглянути всі доступні методи та властивості, скористайтеся автодоповненням IPython, ввівши `Web3`. і двічі натиснувши клавішу Tab після крапки.

## Спілкування з ланцюгом {#talk-to-the-chain}

Допоміжні методи — це чудово, але перейдемо до блокчейну. Наступний крок — налаштувати Web3.py для зв'язку з вузлом Ethereum. Тут ми можемо використовувати провайдери IPC, HTTP або Websocket.

Ми не будемо йти цим шляхом, але приклад повного робочого процесу з використанням HTTP-провайдера може виглядати приблизно так:

- Завантажте вузол Ethereum, наприклад, [Geth](https://geth.ethereum.org/).
- Запустіть Geth в одному вікні терміналу та дочекайтеся синхронізації мережі. Порт HTTP за замовчуванням — `8545`, але його можна налаштувати.
- Вкажіть Web3.py підключатися до вузла через HTTP на `localhost:8545`.
  `w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))`
- Використовуйте екземпляр `w3` для взаємодії з вузлом.

Хоча це один зі «справжніх» способів зробити це, процес синхронізації займає години і не є необхідним, якщо вам просто потрібне середовище для розробки. Web3.py надає четвертий провайдер для цієї мети, **EthereumTesterProvider**. Цей тестовий провайдер пов’язаний з імітованим вузлом Ethereum зі спрощеними дозволами та фальшивою валютою для експериментів.

![Діаграма, що показує, як EthereumTesterProvider пов’язує ваш застосунок web3.py з імітованим вузлом Ethereum](./ethereumtesterprovider.png)

_EthereumTesterProvider підключається до імітованого вузла і є зручним для швидкого створення середовищ розробки._

Цей імітований вузол називається [eth-tester](https://github.com/ethereum/eth-tester), і ми встановили його як частину команди `pip install web3[tester]`. Налаштувати Web3.py для використання цього тестового провайдера дуже просто:

```python
In [4]: w3 = Web3(Web3.EthereumTesterProvider())
```

Тепер ви готові підкорювати ланцюг! Насправді, так ніхто не каже. Я щойно це вигадав. Давайте влаштуємо короткий тур.

## Короткий тур {#the-quick-tour}

Перш за все, перевірка працездатності:

```python
In [5]: w3.is_connected()
Out[5]: True
```

Оскільки ми використовуємо тестовий провайдер, це не дуже цінний тест, але якщо він не вдається, швидше за все, ви зробили помилку при створенні змінної `w3`. Переконайтеся, що ви включили внутрішні дужки, тобто `Web3.EthereumTesterProvider()`.

## Зупинка 1: [рахунки](/developers/docs/accounts/) {#tour-stop-1-accounts}

Для зручності тестовий провайдер створив кілька рахунків і попередньо поповнив їх тестовим етером.

Спочатку подивімося на список цих рахунків:

```python
In [6]: w3.eth.accounts
Out[6]: ['0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
 '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
 '0x6813Eb9362372EEF6200f3b1dbC3f819671cBA69', ...]
```

Якщо ви виконаєте цю команду, ви побачите список з десяти рядків, які починаються з `0x`. Кожен із них є **публічною адресою** і в певному сенсі аналогічний номеру поточного банківського рахунку. Ви б надали цю адресу тому, хто хотів би надіслати вам етер.

Як уже згадувалося, тестовий провайдер попередньо поповнив кожен з цих рахунків деякою кількістю тестового етеру. Давайте дізнаємося, скільки коштів на першому рахунку:

```python
In [7]: w3.eth.get_balance(w3.eth.accounts[0])
Out[7]: 1000000000000000000000000
```

Це дуже багато нулів! Перш ніж сміятися по дорозі до фальшивого банку, згадайте попередній урок про номінали валют. Значення етеру представлені в найменшому номіналі, wei. Конвертуймо це в етер:

```python
In [8]: w3.from_wei(1000000000000000000000000, 'ether')
Out[8]: Decimal('1000000')
```

Один мільйон тестових етерів — все ще непогано.

## Зупинка 2: дані блоку {#tour-stop-2-block-data}

Давайте поглянемо на стан цього імітованого блокчейну:

```python
In [9]: w3.eth.get_block('latest')
Out[9]: AttributeDict({
   'number': 0,
   'hash': HexBytes('0x9469878...'),
   'parentHash': HexBytes('0x0000000...'),
   ...
   'transactions': []
})
```

Про блок повертається багато інформації, але тут варто зазначити лише кілька речей:

- Номер блоку — нуль, незалежно від того, як давно ви налаштували тестовий провайдер. На відміну від реальної мережі Ethereum, яка додає новий блок кожні 12 секунд, ця симуляція чекатиме, поки ви не дасте їй якусь роботу.
- `transactions` — це порожній список з тієї ж причини: ми ще нічого не зробили. Цей перший блок є **порожнім блоком**, призначеним лише для запуску ланцюга.
- Зверніть увагу, що `parentHash` — це просто набір порожніх байтів. Це означає, що це перший блок у ланцюзі, також відомий як **початковий блок**.

## Зупинка 3: [транзакції](/developers/docs/transactions/) {#tour-stop-3-transactions}

Ми застрягли на нульовому блоці, поки не з’явиться транзакція в очікуванні, тож давайте її створимо. Надішлімо кілька тестових етерів з одного рахунку на інший:

```python
In [10]: tx_hash = w3.eth.send_transaction({
   'from': w3.eth.accounts[0],
   'to': w3.eth.accounts[1],
   'value': w3.to_wei(3, 'ether'),
   'gas': 21000
})
```

Зазвичай, на цьому етапі ви б чекали кілька секунд, поки ваша транзакція не буде включена до нового блоку. Повний процес виглядає приблизно так:

1. Надішліть транзакцію та збережіть її хеш. Поки блок, що містить транзакцію, не буде створено та розповсюджено, транзакція є «в очікуванні».
   `tx_hash = w3.eth.send_transaction({ … })`
2. Зачекайте, поки транзакцію буде включено в блок:
   `w3.eth.wait_for_transaction_receipt(tx_hash)`
3. Продовжуйте логіку застосунку. Щоб переглянути успішну транзакцію:
   `w3.eth.get_transaction(tx_hash)`

Наше імітоване середовище миттєво додасть транзакцію до нового блоку, тож ми можемо одразу переглянути її:

```python
In [11]: w3.eth.get_transaction(tx_hash)
Out[11]: AttributeDict({
   'hash': HexBytes('0x15e9fb95dc39...'),
   'blockNumber': 1,
   'transactionIndex': 0,
   'from': '0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
   'to': '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
   'value': 3000000000000000000,
   ...
})
```

Тут ви побачите знайомі деталі: поля `from`, `to` та `value` мають відповідати вхідним даним нашого виклику `send_transaction`. Ще один момент, що підтверджує успішність, — це те, що ця транзакція була включена як перша транзакція (`'transactionIndex': 0`) у блок номер 1.

Ми також можемо легко перевірити успішність цієї транзакції, перевіривши баланси двох залучених рахунків. Три етери мали перейти з одного рахунку на інший.

```python
In [12]: w3.eth.get_balance(w3.eth.accounts[0])
Out[12]: 999996999979000000000000

In [13]: w3.eth.get_balance(w3.eth.accounts[1])
Out[13]: 1000003000000000000000000
```

Останній виглядає добре! Баланс змінився з 1 000 000 до 1 000 003 етерів. Але що сталося з першим рахунком? Здається, він втратив трохи більше, ніж три етери. На жаль, у житті нічого не буває безкоштовним, і використання публічної мережі Ethereum вимагає, щоб ви компенсували іншим учасникам їхню допоміжну роль. З рахунку, який ініціював транзакцію, було вирахувано невелику комісію за транзакцію. Ця комісія складається з кількості спаленого газу (21 000 одиниць газу для переказу ETH), помноженої на базову комісію, яка змінюється залежно від активності мережі, плюс чайові, які отримує валідатор, що включає транзакцію в блок.

Докладніше про [газ](/developers/docs/gas/#post-london)

<FeaturedText>Примітка: у публічній мережі комісії за транзакції є змінними і залежать від попиту в мережі та того, наскільки швидко ви хочете, щоб транзакція була оброблена. Якщо вас цікавить детальний розбір розрахунку комісій, дивіться мою попередню публікацію про те, <a href="https://medium.com/ethereum-grid/ethereum-101-how-are-transactions-included-in-a-block-9ae5f491853f">як транзакції включаються в блок</a>.</FeaturedText>

## І видихніть {#and-breathe}

Ми займаємося цим уже деякий час, тому це чудове місце, щоб зробити перерву. Кроляча нора продовжується, і ми продовжимо її досліджувати в другій частині цієї серії. Деякі майбутні концепції: підключення до реального вузла, смарт-контракти та токени. Маєте додаткові запитання? Дайте мені знати! Ваш відгук вплине на те, куди ми рухатимемося далі. Запити приймаються через [Twitter](https://twitter.com/wolovim).
