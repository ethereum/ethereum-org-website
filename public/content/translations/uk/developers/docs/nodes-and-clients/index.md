---
title: Мережеві вузли та користувачі
description: Огляд вузлів Ethereum і програмного забезпечення клієнтів, а також налаштування вузлів і чому ви повинні це зробити.
lang: uk
sidebarDepth: 2
---

Ethereum - це розподілена мережа комп'ютерів (відомих як вузли), на яких працює програмне забезпечення, що може перевіряти блоки і дані транзакцій. Для перетворення вашого комп'ютера в вузол Ethereum необхідно запустити відповідне програмне забезпечення на ньому. Для створення вузла необхідно використовувати два окремі компоненти програмного забезпечення (відомі як "клієнти").

## Передумови {#prerequisites}

Вам слід розуміти концепцію однорангової мережі та [основи EVM](/developers/docs/evm/), перш ніж заглиблюватися і запускати власний екземпляр клієнта Ethereum. Перегляньте наш [вступ до Ethereum](/developers/docs/intro-to-ethereum/).

Якщо ви не знайомі з темою вузлів, радимо спочатку ознайомитися з нашим простим посібником про [запуск вузла Ethereum](/run-a-node).

## Що таке вузли та клієнти? Чи впливає це оновлення на всі вузли та валідаторів Ethereum? {#what-are-nodes-and-clients}

"Вузол" - це будь-який екземпляр клієнтського програмного забезпечення Ethereum, який з'єднаний з іншими комп'ютерами, на яких також працює програмне забезпечення Ethereum, утворюючи мережу. Клієнт - це реалізація Ethereum, яка перевіряє дані на відповідність правилам протоколу і забезпечує безпеку мережі. Вузол повинен запускати два клієнти: клієнт консенсусу та виконавчий клієнт.

- Клієнт виконавець (також відомий як Execution Engine, клієнт EL або раніше Eth1-клієнт) прослуховує нові транзакції, що транслюються в мережі, виконує їх в EVM, а також зберігає останній стан і базу даних всіх поточних даних Ethereum.
- Клієнт консенсусу (також відомий як Beacon Node, клієнт CL або раніше Eth2-клієнт) реалізує алгоритм консенсусу з доказом частки, який дозволяє мережі досягти згоди на основі перевірених даних від клієнта виконавця. Також існує третій компонент програмного забезпечення, відомий як "валідатор", який може бути доданий до клієнта консенсусу, що дозволяє вузлу приймати участь у забезпеченні безпеки мережі.

Ці клієнти спільно працюють для відстеження головного блоку ланцюжка Ethereum та надають можливість користувачам взаємодіяти з мережею Ethereum. Модульна конструкція, в якій декілька програмних компонентів працюють разом, називається [інкапсульованою складністю](https://vitalik.eth.limo/general/2022/02/28/complexity.html). Такий підхід спростив безперебійне виконання [The Merge](/roadmap/merge), полегшує обслуговування та розробку клієнтського програмного забезпечення, а також дає змогу повторно використовувати окремі клієнти, наприклад, в [екосистемі рівня 2](/layer-2/).

![Схема зв’язаних клієнтів виконання та консенсусу](./eth1eth2client.png)
Спрощена схема зв’язаних клієнтів виконання та консенсусу.

### Різноманітність клієнтів {#client-diversity}

Існують [клієнти виконання](/developers/docs/nodes-and-clients/#execution-clients) та [клієнти консенсусу](/developers/docs/nodes-and-clients/#consensus-clients), написані різними мовами програмування та розроблені різними командами.

Кілька клієнтських впроваджень можуть зробити мережу сильнішою, зменшуючи її залежність від однієї кодової бази. Ідеальна мета полягає в тому, щоб досягти різноманітності без домінування жодного клієнта в мережі, тим самим уникаючи потенційної єдиної точки відмови.
Різноманітність мов також залучає ширшу спільноту розробників і дозволяє їм створювати інтеграції їхньою улюбленою мовою.

Дізнайтеся більше про [різноманітність клієнтів](/developers/docs/nodes-and-clients/client-diversity/).

Спільним для цих впроваджень є те, що всі вони відповідають єдиній специфікації. Специфікації визначають, як функціонує мережа Ethereum і блокчейн. Кожна технічна деталь визначена, а специфікації можна переглянути за посиланнями:

- Спочатку [Жовта книга Ethereum](https://ethereum.github.io/yellowpaper/paper.pdf)
- [Специфікації виконання](https://github.com/ethereum/execution-specs/)
- [Специфікації консенсусу](https://github.com/ethereum/consensus-specs)
- [EIP](https://eips.ethereum.org/), реалізовані в різних [оновленнях мережі](/ethereum-forks/)

### Відстеження вузлів у мережі {#network-overview}

Кілька трекерів пропонують перегляд вузлів мережі Ethereum в реальному часі. Зауважте, що через природу децентралізованих мереж ці сканери можуть надавати лише обмежений огляд мережі і можуть показувати різні результати.

- [Карта вузлів](https://etherscan.io/nodetracker) від Etherscan
- [Ethernodes](https://ethernodes.org/) від Bitfly
- [Nodewatch](https://www.nodewatch.io/) від Chainsafe, сканування вузлів консенсусу
- [Monitoreth](https://monitoreth.io/) від MigaLabs, розподілений інструмент для моніторингу мережі
- [Щотижневі звіти про стан мережі](https://probelab.io) від ProbeLab, з використанням [сканера Nebula](https://github.com/dennis-tra/nebula) та інших інструментів

## Типи вузлів {#node-types}

Якщо ви хочете [запустити власний вузол](/developers/docs/nodes-and-clients/run-a-node/), ви повинні розуміти, що існують різні типи вузлів, які споживають дані по-різному. Фактично, клієнти можуть запускати три різні типи вузлів: легкі, повні та архівні. Існують також варіанти різних стратегій синхронізації, які дозволяють пришвидшити час синхронізації. Синхронізація означає, наскільки швидко можна отримати найсвіжішу інформацію про стан Ethereum.

### Повний вузол {#full-node}

Повні вузли виконують блок-по-блоку перевірку блокчейну, включаючи завантаження та перевірку тіла блоку та даних стану для кожного блоку. Існують різні класи повних вузлів: деякі починають із генезис-блоку та перевіряють кожен блок в усій історії блокчейну. Інші починають перевірку з новішого блоку, який вони вважають дійсним (наприклад, «snap sync» від Geth). Незалежно від того, звідки починається перевірка, повні вузли зберігають лише локальну копію відносно нових даних (зазвичай останні 128 блоків), що дозволяє видаляти старіші дані для економії місця на диску. Старі дані можуть бути відновлені, коли вони потрібні.

- Зберігає повні дані блокчейну (хоча вони періодично обрізаються, тому повний вузол не зберігає всі дані про стан аж до генезису)
- Бере участь у валідації, перевіряє всі блоки та стани.
- Всі стани можуть бути отримані або відновлені з локального сховища або зі снапшотів повним вузлом.
- Обслуговує мережу і надає дані за запитом.

### Архівний вузол {#archive-node}

Архівні вузли (Archive nodes) - це повні вузли, які перевіряють кожний блок від генезиса і ніколи не видаляють жодних завантажених даних.

- Зберігає все, що знаходиться у повному вузлі та створює архів історичних станів. Він потрібен, якщо ви хочете запросити щось на кшталт балансу облікового запису в блоці № 4 000 000 або просто та надійно перевірити власний набір транзакцій, не перевіряючи їх за допомогою трасування.
- Ці дані представляють одиниці терабайт, що робить архівні вузли менш привабливими для звичайних користувачів, але може бути корисним для таких сервісів, як інструменти дослідження блоків, постачання гаманців і аналітика ланцюжків.

Синхронізація клієнтів в будь-якому режимі, окрім архіву, призведе до видалення даних блокчейна. Це означає, що не існує архіву всіх історичних станів, але повний вузол здатен створювати їх на вимогу.

Дізнайтеся більше про [архівні вузли](/developers/docs/nodes-and-clients/archive-nodes).

### Легкий вузол {#light-node}

Замість того, щоб завантажувати кожен блок, легкі вузли завантажують заголовки блоків. Ці заголовки містять лише загальну інформацію про вміст блоків. Будь-яка інша інформація, яка потрібна легкому вузлу, запитується у повного вузла. Після цього легкий вузол може самостійно звіряти отримані дані з кореневими станами в заголовках блоків. Легкі вузли дозволяють користувачам брати участь в мережі Ethereum без потужного обладнання або високої пропускної здатності, необхідних для роботи повних вузлів. Зрештою, легкі вузли можуть працювати на мобільних телефонах або вбудованих пристроях. Легкі вузли не беруть участі в консенсусі (тобто вони не можуть бути валідаторами), але вони можуть отримати доступ до блокчейну Ethereum з тією ж функціональністю та гарантіями безпеки, що й повний вузол.

Легкі клієнти - це область активного розвитку Ethereum, і ми очікуємо, що незабаром з'являться нові легкі клієнти для рівня консенсусу і рівня виконання.
Існують також потенційні маршрути для надання даних легкого клієнта через [мережу пліток](https://www.ethportal.net/). Це вигідно, оскільки мережа пліток може підтримувати мережу легких вузлів, не потребуючи повних вузлів для обслуговування запитів.

Ethereum поки що не підтримує велику кількість легких вузлів, але очікується, що підтримка легких вузлів буде швидко розвиватися в найближчому майбутньому. Зокрема, такі клієнти, як [Nimbus](https://nimbus.team/), [Helios](https://github.com/a16z/helios) та [LodeStar](https://lodestar.chainsafe.io/), наразі значною мірою зосереджені на легких вузлах.

## Для чого запускати вузол Ethereum? Чи впливає це оновлення на всі вузли та валідаторів Ethereum? {#why-should-i-run-an-ethereum-node}

Запуск вузла дозволяє вам безпосередньо, безперешкодно і приватно використовувати Ethereum, одночасно підтримуючи мережу, роблячи її більш надійною і децентралізованою.

### Переваги для вас {#benefits-to-you}

Запуск власного вузла забезпечує вам приватне, незалежне і надійне використання Ethereum. Вам не обов‘язково довіряти мережі, оскільки ви можете перевірити дані самостійно із своїм клієнтом. «Не довіряй, а провіряй» - популярна мантра блокчейну.

- Ваш вузол перевіряє всі транзакції та блоки відповідно до правил консенсусу. Це означає, що ви не повиннні покладатися на інші вузли в мережі чи повністю довіряти їм.
- Ви можете використовувати гаманець Ethereum з власним вузлом. Ви можете використовувати децентралізовані додатки більш безпечно і конфіденційно, тому що вам не доведеться передавати свої адреси і баланси випадковим вузлам. Все можна перевірити за допомогою власного клієнта. [MetaMask](https://metamask.io), [Frame](https://frame.sh/) та [багато інших гаманців](/wallets/find-wallet/) пропонують імпорт RPC, що дозволяє їм використовувати ваш вузол.
- Ви можете запускати і самостійно розміщувати інші сервіси, які залежать від даних з Ethereum. Наприклад, це може бути валідатор ланцюжка Beacon Chain, програмне забезпечення другого шару, інфраструктура, дослідники блоків, платіжні процесори тощо.
- Ви можете надавати власні [кінцеві точки RPC](/developers/docs/apis/json-rpc/). Ви можете навіть публічно пропонувати ці точки доступу спільноті, щоб допомогти їм уникати великих централізованих постачальників.
- Ви можете підключатися до свого вузла за допомогою **міжпроцесної взаємодії (IPC)** або переписати вузол, щоб завантажити програму як плагін. Це забезпечує низьку затримку, що дуже допомагає, наприклад, при обробці великих обсягів даних за допомогою бібліотек web3, або коли вам потрібно замінити свої транзакції якомога швидше (тобто, фронтранінг).
- Ви можете безпосередньо вкладати ETH, щоб захистити мережу і отримувати винагороду. Щоб почати, див. розділ [соло-стейкінг](/staking/solo/).

![Як ви отримуєте доступ до Ethereum через ваш додаток і вузли](./nodes.png)

### Переваги для мережі {#network-benefits}

Різноманітний набір вузлів важливий для працездатності Ethereum, безпеки та операційноі стійкості.

- Повні вузли забезпечують дотримання правил консенсусу, тому їх неможливо обманом змусити прийняти блоки, які їм не відповідають. Це забезпечує додаткову безпеку в мережі, тому що якби всі вузли були легкими, які не виконують повну перевірку, валідатори могли б атакувати мережу.
- У разі атаки, яка долає криптоекономічний захист [proof-of-stake](/developers/docs/consensus-mechanisms/pos/#what-is-pos), соціальне відновлення може бути виконано повними вузлами, які обирають слідувати чесному ланцюжку.
- Більша кількість вузлів у мережі призводить до більш різноманітної та надійної мережі, що є кінцевою метою децентралізації, яка забезпечує стійкість до цензури та надійність системи.
- Повні вузли надають доступ до даних блокчейну для легковажних клієнтів, які на них покладаються. Легкі вузли не зберігають увесь блокчейн, натомість вони перевіряють дані за допомогою [коренів стану в заголовках блоків](/developers/docs/blocks/#block-anatomy). При необхідності вони можуть запитати додаткову інформацію у блоків.

Якщо ви запускаєте повний вузол, то від цього користується весь мережа Ethereum, навіть якщо ви не запускаєте валідатора.

## Запуск власного вузла {#running-your-own-node}

Бажаєте запустити власного клієнта Ethereum?

Щоб отримати просте для початківців введення та дізнатися більше, відвідайте нашу сторінку [Запуск вузла](/run-a-node).

Якщо ви більш технічно підкований користувач, зануртеся в деталі та варіанти, як [розгорнути власний вузол](/developers/docs/nodes-and-clients/run-a-node/).

## Альтернативи {#alternatives}

Створення власного вузла може коштувати вам часу і ресурсів, але вам не завжди потрібно запускати власний екземпляр. У цьому випадку ви можете скористатися стороннім API-провайдером. Щоб отримати огляд використання цих послуг, перегляньте [вузли як послуга](/developers/docs/nodes-and-clients/nodes-as-a-service/).

Якщо хтось запускає вузол Ethereum з загальнодоступним API у вашій спільноті, ви можете вказати свій гаманець до вузла спільноти за допомогою Custom RPC і отримати більше приватності, ніж з будь-якою випадковою довіреною третьою стороною.

З іншого боку, якщо ви запускаєте клієнта, ви можете поділитися ним із друзями, яким він може знадобитися.

## Клієнти виконання {#execution-clients}

Спільнота Ethereum підтримує кілька клієнтів виконання з відкритим вихідним кодом (раніше відомих як «клієнти Eth1» або просто «клієнти Ethereum»), розроблених різними командами, що використовують різні мови програмування. Це робить мережу сильнішою та більш [різноманітною](/developers/docs/nodes-and-clients/client-diversity/). Ідеальна мета - досягти різноманітності без домінування клієнта, щоб зменшити кількість одиничних точок відмови.

В цій таблиці узагальнено список різних клієнтів. Усі вони проходять [тести клієнтів](https://github.com/ethereum/tests) і активно підтримуються, щоб відповідати оновленням мережі.

| Клієнт                                                                                             | Мова                     | Операційні системи    | Мережі                  | Стратегії синхронізації                                                              | Відсікання станів    |
| -------------------------------------------------------------------------------------------------- | ------------------------ | --------------------- | ----------------------- | ------------------------------------------------------------------------------------ | -------------------- |
| [Geth](https://geth.ethereum.org/)                                                                 | Go                       | Linux, Windows, macOS | Mainnet, Sepolia, Hoodi | [Snap](#snap-sync), [Full](#full-sync)                                               | Архівний, Відсічений |
| [Nethermind](https://www.nethermind.io/)                                                           | C#, .NET | Linux, Windows, macOS | Mainnet, Sepolia, Hoodi | [Snap](#snap-sync) (без обслуговування), Fast, [Full](#full-sync) | Архівний, Відсічений |
| [Besu](https://besu.hyperledger.org/en/stable/)                                                    | Java                     | Linux, Windows, macOS | Mainnet, Sepolia, Hoodi | [Snap](#snap-sync), [Fast](#fast-sync), [Full](#full-sync)                           | Архівний, Відсічений |
| [Erigon](https://github.com/ledgerwatch/erigon)                                                    | Go                       | Linux, Windows, macOS | Mainnet, Sepolia, Hoodi | [Full](#full-sync)                                                                   | Архівний, Відсічений |
| [Reth](https://reth.rs/)                                                                           | Rust                     | Linux, Windows, macOS | Mainnet, Sepolia, Hoodi | [Full](#full-sync)                                                                   | Архівний, Відсічений |
| [EthereumJS](https://github.com/ethereumjs/ethereumjs-monorepo) _(бета-версія)_ | TypeScript               | Linux, Windows, macOS | Sepolia, Hoodi          | [Full](#full-sync)                                                                   | Скорочений           |

Щоб дізнатися більше про підтримувані мережі, читайте про [мережі Ethereum](/developers/docs/networks/).

У кожного клієнта є унікальний варіант використання і переваги, тому виберіть одного залежно від своїх вподобань. Різноманітність дозволяє реалізації фокусуватися на різних функціях та користувацьких аудиторіях. Ви можете вибрати клієнта на основі функцій, підтримки, мови програмування або ліцензій.

### Besu {#besu}

Hyperledger Besu - це клієнт Ethereum корпоративного рівня як для загальнодоступних, так і для мереж із контрольованим доступом. Він підтримує всі функції Ethereum Mainnet, від трасування до GraphQL, має великий моніторинг і підтримується ConsenSys як у відкритих каналах спільноти, так і в рамках комерційних угод про рівень обслуговування для підприємств. Написаний на Java та має ліцензію Apache 2.0.

Розширена [документація](https://besu.hyperledger.org/en/stable/) Besu допоможе вам розібратися з усіма деталями його функцій та налаштувань.

### Erigon {#erigon}

Erigon, раніше відомий як Turbo-Geth, починався як форк Go Ethereum, орієнтований на швидкість і ефективність використання дискового простору. Erigon - це повністю перепроєктована реалізація Ethereum, яка наразі написана на мові Go, але в процесі розробки знаходяться реалізації на інших мовах. Мета Erigon – забезпечити більш швидку, модульну та оптимізовану реалізацію Ethereum. Він може виконати повну синхронізацію архівних вузлів, використовуючи близько 2 Тб дискового простору, менш ніж за 3 дні.

### Go Ethereum {#geth}

Go Ethereum (скорочено - Geth) - це одна з оригінальних реалізацій протоколу Ethereum. Наразі, це найпоширеніший клієнт з найбільшою базою користувачів та різноманітністю інструментів для користувачів та розробників. Він написаний на Go, з повністю відкритим вихідним кодом та ліцензований згідно з GNU LGPL v3.

Дізнайтеся більше про Geth в його [документації](https://geth.ethereum.org/docs/).

### Nethermind {#nethermind}

Nethermind - це реалізація Ethereum, створена за допомогою технологічного стеку C# .NET, ліцензована LGPL-3.0, що працює на всіх основних платформах, включаючи ARM. Пропонує відмінну продуктивність з:

- оптимізованою віртуальною машиною
- доступом станів
- мережеві можливості та розширені функції, як-от інформаційні панелі Prometheus/Grafana, підтримка корпоративного журналування seq, трасування JSON-RPC та аналітичні плагіни.

Nethermind також має [детальну документацію](https://docs.nethermind.io), потужну підтримку розробників, онлайн-спільноту та цілодобову підтримку для преміум-користувачів.

### Reth {#reth}

Reth (скорочення від Rust Ethereum) — це реалізація повного вузла Ethereum, яка орієнтована на зручність для користувача, високу модульність, швидкість та ефективність. Reth спочатку був створений і розвинений компанією Paradigm і ліцензований за ліцензіями Apache та MIT.

Reth готовий до використання в робочому середовищі та підходить для використання в критично важливих середовищах, таких як стейкінг або сервіси з високою безвідмовністю. Добре працює у випадках використання, де потрібна висока продуктивність із великим запасом, наприклад, для RPC, MEV, індексації, симуляцій та P2P-діяльності.

Дізнайтеся більше, переглянувши [Reth Book](https://reth.rs/), або [репозиторій Reth на GitHub](https://github.com/paradigmxyz/reth?tab=readme-ov-file#reth).

### У розробці {#execution-in-development}

Ці клієнти все ще перебувають на ранніх стадіях розробки, і їх поки не рекомендується використовувати в робочому середовищі.

#### EthereumJS {#ethereumjs}

Клієнт виконання EthereumJS (EthereumJS) написаний на TypeScript і складається з низки пакунків, що включають основні примітиви Ethereum, представлені класами Block, Transaction і Merkle-Patricia Trie, а також основні компоненти клієнта, включно з реалізацією віртуальної машини Ethereum (EVM), класу блокчейну та мережевого стека DevP2P.

Дізнайтеся більше, прочитавши його [документацію](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master)

## Клієнти консенсусу {#consensus-clients}

Існує кілька клієнтів консенсусу (раніше відомих як клієнти Eth2) для підтримки [оновлень консенсусу](/roadmap/beacon-chain/). Вони відповідають за всю логіку, пов'язану з консенсусом, включно з алгоритмом вибору форка, обробкою атестацій та керуванням винагородами та штрафами в системі [доказу частки володіння](/developers/docs/consensus-mechanisms/pos).

| Клієнт                                                        | Мова       | Операційні системи    | Мережі                                             |
| ------------------------------------------------------------- | ---------- | --------------------- | -------------------------------------------------- |
| [Lighthouse](https://lighthouse.sigmaprime.io/)               | Rust       | Linux, Windows, macOS | Beacon Chain, Hoodi, Pyrmont, Sepolia тощо         |
| [Lodestar](https://lodestar.chainsafe.io/)                    | TypeScript | Linux, Windows, macOS | Beacon Chain, Hoodi, Sepolia тощо                  |
| [Nimbus](https://nimbus.team/)                                | Nim        | Linux, Windows, macOS | Beacon Chain, Hoodi, Sepolia тощо                  |
| [Prysm](https://prysm.offchainlabs.com/docs/)                 | Go         | Linux, Windows, macOS | Beacon Chain, Gnosis, Hoodi, Pyrmont, Sepolia тощо |
| [Teku](https://consensys.net/knowledge-base/ethereum-2/teku/) | Java       | Linux, Windows, macOS | Beacon Chain, Gnosis, Hoodi, Sepolia тощо          |
| [Grandine](https://docs.grandine.io/)                         | Rust       | Linux, Windows, macOS | Beacon Chain, Hoodi, Sepolia тощо                  |

### Lighthouse {#lighthouse}

Lighthouse - це реалізація клієнта консенсусу, написана на мові програмування Rust та розповсюджена за ліцензією Apache-2.0. Цей проект підтримується компанією Sigma Prime і є стабільним та готовим до використання в продукції з моменту старту Beacon Chain. На нього покладаються різні підприємства, стейкінг-пули та індивідуальні користувачі. Цей проект має на меті бути безпечним, продуктивним і сумісним в широкому спектрі середовищ, від настільних ПК до складних автоматизованих розгортань.

Документацію можна знайти в [Lighthouse Book](https://lighthouse-book.sigmaprime.io/)

### Lodestar {#lodestar}

Lodestar - це реалізація клієнта консенсусу, готова до використання в продукції, написана мовою програмування Typescript та розповсюджується за ліцензією LGPL-3.0. Цей проект підтримується компанією ChainSafe Systems і є найновішим серед реалізацій клієнта консенсусу для індивідуальних стейкерів, розробників та дослідників. Lodestar складається з вузла Beacon і клієнта валідатора, які працюють за допомогою реалізацій протоколів Ethereum на мові програмування JavaScript. Lodestar спрямований на поліпшення користування Ethereum за допомогою легковажних клієнтів, розширення доступності для більшої кількості розробників та подальший внесок у різноманітність екосистеми.

Більше інформації можна знайти на [вебсайті Lodestar](https://lodestar.chainsafe.io/)

### Nimbus {#nimbus}

Nimbus - це реалізація клієнта консенсусу, написана мовою програмування Nim і розповсюджується за ліцензією Apache-2.0. Це готовий до використання в продукції клієнт, який використовується індивідуальними стейкерами і стейкінг пулами. Nimbus розроблений з урахуванням ефективного використання ресурсів, що дозволяє легко запускати його на обмежених ресурсах пристроях та корпоративній інфраструктурі з однаковою легкістю, не по жертвуючи стабільністю або продуктивністю винагород. Менший обсяг ресурсів означає, що клієнт має більший резерв безпеки, коли мережа перебуває під навантаженням.

Дізнайтеся більше в [документації Nimbus](https://nimbus.guide/)

### Prysm {#prysm}

Prysm — це повнофункціональний клієнт консенсусу з відкритим кодом, написаний на Go та ліцензований за ліцензією GPL-3.0. Він має додатковий вебінтерфейс і надає пріоритет зручності користувача, документації та можливості налаштування як для домашніх стейкерів, так і для інституційних користувачів.

Щоб дізнатися більше, відвідайте [документацію Prysm](https://prysm.offchainlabs.com/docs/).

### Teku {#teku}

Teku — один із перших клієнтів генезису Beacon Chain. Поряд зі звичайними цілями (безпека, надійність, стабільність, зручність використання, продуктивність) Teku спеціально прагне повністю відповідати всім різноманітним стандартам клієнтів консенсусу.

Teku пропонує дуже гнучкі варіанти розгортання. Вузол маяка та клієнт валідатора можуть працювати разом як єдиний процес, що надзвичайно зручно для соло-стейкерів, або ж вузли можуть працювати окремо для складних операцій зі стейкінгу. Крім того, Teku повністю сумісний із [Web3Signer](https://github.com/ConsenSys/web3signer/) для безпеки ключів підпису та захисту від слешингу.

Teku написаний на Java і ліцензований за ліцензією Apache 2.0. Його розробляє команда Protocols у ConsenSys, яка також відповідає за Besu та Web3Signer. Дізнайтеся більше в [документації Teku](https://docs.teku.consensys.net/en/latest/).

### Grandine {#grandine}

Grandine — це реалізація клієнта консенсусу, написана на Rust та ліцензована за ліцензією GPL-3.0. Він підтримується командою Grandine Core Team і є швидким, високопродуктивним та легким. Він підходить для широкого кола стейкерів: від соло-стейкерів, що працюють на пристроях з низькими ресурсами, таких як Raspberry Pi, до великих інституційних стейкерів, що обслуговують десятки тисяч валідаторів.

Документацію можна знайти в [Grandine Book](https://docs.grandine.io/)

## Режими синхронізації {#sync-modes}

Щоб відстежувати та перевіряти поточні дані в мережі, клієнт Ethereum повинен синхронізуватися з останнім станом мережі. Це робиться шляхом завантаження даних з вузлів, криптографічної перевірки їх цілісності та створення локальної бази даних блокчейнів.

Режими синхронізації має різні підходи до цього процесу з різними компромісами. Клієнти також відрізняються в їх здійсненні алгоритмів синхронізації. Завжди звертайтеся до офіційної документації обраного клієнта для уточнення особливостей реалізації.

### Режими синхронізації рівня виконання {#execution-layer-sync-modes}

Рівень виконання може працювати в різних режимах для різних випадків використання: від повторного виконання глобального стану блокчейну до синхронізації лише з верхівкою ланцюга з довіреної контрольної точки.

#### Повна синхронізація {#full-sync}

Повна синхронізація завантажує всі блоки (включно із заголовками та тілами блоків) і поступово відтворює стан блокчейну, виконуючи кожен блок, починаючи з генезис-блоку.

- Мінімізує довіру та забезпечує найвищу безпеку, перевіряючи кожну транзакцію.
- При збільшенні кількості транзакцій на обробку всіх транзакцій може піти від кількох днів до кількох тижнів.

[Архівні вузли](#archive-node) виконують повну синхронізацію, щоб створити (і зберегти) повну історію змін стану, зроблених кожною транзакцією в кожному блоці.

#### Швидка синхронізація {#fast-sync}

Як і повна синхронізація, швидка синхронізація завантажує всі блоки (включно із заголовками, транзакціями та квитанціями). Однак замість повторної обробки історичних транзакцій швидка синхронізація покладається на квитанції, доки не досягне нещодавньої верхівки, після чого перемикається на імпорт та обробку блоків для забезпечення роботи повного вузла.

- Стратегія швидкої синхронізації.
- Зменшує потребу в обробці на користь використання пропускної здатності.

#### Snap-синхронізація {#snap-sync}

Snap-синхронізація також перевіряє ланцюжок блок за блоком. Однак замість того, щоб починати з генезис-блоку, snap-синхронізація починається з новішої «довіреної» контрольної точки, яка, як відомо, є частиною справжнього блокчейну. Вузол зберігає періодичні контрольні точки, видаляючи дані, старші за певний вік. Ці знімки використовуються для відновлення даних стану за потреби, а не для їх постійного зберігання.

- Найшвидша стратегія синхронізації, наразі стандартна в Ethereum Mainnet.
- Заощаджує використання диска та пропускну здатність мережі без шкоди для безпеки.

[Детальніше про snap-синхронізацію](https://github.com/ethereum/devp2p/blob/master/caps/snap.md).

#### Легка синхронізація {#light-sync}

Легкий користувацький режим завантажує всі заголовки блоків, дані блоків та перевіряє деякі рандомно. Синхронізується лише вершина ланцюжка від довіреної контрольної точки.

- Отримує лише останній стан, покладаючись на розробників та механізм консенсусу.
- Клієнт готовий до використання з поточним станом мережі за кілька хвилин.

**Примітка** Легка синхронізація ще не працює з Ethereum на основі доказу частки володіння — нові версії легкої синхронізації мають з'явитися незабаром!

[Детальніше про легкі клієнти](/developers/docs/nodes-and-clients/light-clients/)

### Режими синхронізації рівня консенсусу {#consensus-layer-sync-modes}

#### Оптимістична синхронізація {#optimistic-sync}

Оптимістична синхронізація — це стратегія синхронізації після злиття, розроблена для опціонального включення та зворотної сумісності, що дозволяє вузлам виконання синхронізуватися за допомогою встановлених методів. Механізм виконання може _оптимістично_ імпортувати блоки маяка без їх повної перевірки, знаходити останню верхівку, а потім починати синхронізацію ланцюга за допомогою вищезазначених методів. Потім, після того, як клієнт виконання наздожене мережу, він повідомить клієнту консенсусу про дійсність транзакцій у Beacon Chain.

[Детальніше про оптимістичну синхронізацію](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md)

#### Синхронізація за контрольною точкою {#checkpoint-sync}

Синхронізація за контрольною точкою, також відома як синхронізація за слабкою суб'єктивністю, створює кращий досвід для користувачів під час синхронізації вузла Beacon. Вона ґрунтується на припущеннях про [слабку суб'єктивність](/developers/docs/consensus-mechanisms/pos/weak-subjectivity/), що дає змогу синхронізувати Beacon Chain із недавньої контрольної точки слабкої суб'єктивності замість генезис-блоку. Синхронізація за контрольною точкою значно прискорює початкову синхронізацію з подібними припущеннями довіри, як і синхронізація з [генезис-блоку](/glossary/#genesis-block).

На практиці це означає, що ваш вузол підключається до віддаленого сервісу для завантаження нещодавніх фіналізованих станів і продовжує перевірку даних із цієї точки. Третя сторона, що надає дані, є довіреною і повинна обиратися ретельно.

Детальніше про [синхронізацію за контрольною точкою](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice)

## Для подальшого читання {#further-reading}

- [Ethereum 101 — частина 2 — Розуміння вузлів](https://kauri.io/ethereum-101-part-2-understanding-nodes/48d5098292fd4f11b251d1b1814f0bba/a) _– Wil Barnes, 13 лютого 2019 р._
- [Запуск повних вузлів Ethereum: посібник для ледь мотивованих](https://medium.com/@JustinMLeroux/running-ethereum-full-nodes-a-guide-for-the-barely-motivated-a8a13e7a0d31) _– Justin Leroux, 7 листопада 2019 р._

## Пов'язані теми {#related-topics}

- [Блоки](/developers/docs/blocks/)
- [Мережі](/developers/docs/networks/)

## Пов'язані посібники {#related-tutorials}

- [Перетворіть свій Raspberry Pi 4 на вузол валідатора, просто прошивши карту MicroSD — посібник зі встановлення](/developers/tutorials/run-node-raspberry-pi/) _— прошийте свій Raspberry Pi 4, підключіть кабель Ethernet, підключіть SSD-диск і увімкніть пристрій, щоб перетворити Raspberry Pi 4 на повний вузол Ethereum, що запускає рівень виконання (Mainnet) та/або рівень консенсусу (Beacon Chain/валідатор)._
