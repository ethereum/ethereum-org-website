---
title: Формальна верифікація смарт-контрактів
description: Огляд формальної верифікації для смарт-контрактів Ethereum
lang: uk
---

[Смарт-контракти](/developers/docs/smart-contracts/) дають змогу створювати децентралізовані, бездовірчі та надійні додатки, які відкривають нові варіанти використання та створюють цінність для користувачів. Оскільки смарт-контракти обробляють великі обсяги цінностей, безпека є критично важливим аспектом для розробників.

Формальна верифікація — це один із рекомендованих методів для підвищення [безпеки смарт-контрактів](/developers/docs/smart-contracts/security/). Формальна верифікація, яка використовує [формальні методи](https://www.brookings.edu/techstream/formal-methods-as-a-path-toward-better-cybersecurity/) для визначення, проєктування та перевірки програм, роками використовується для забезпечення коректності критично важливих апаратних і програмних систем.

При застосуванні до смарт-контрактів формальна верифікація може довести, що бізнес-логіка контракту відповідає заздалегідь визначеній специфікації. Порівняно з іншими методами оцінки коректності коду контракту, як-от тестування, формальна верифікація дає сильніші гарантії того, що смарт-контракт функціонально коректний.

## Що таке формальна верифікація? {#what-is-formal-verification}

Формальна верифікація — це процес оцінки коректності системи відносно формальної специфікації. Простими словами, формальна верифікація дає нам змогу перевірити, чи поведінка системи задовольняє певні вимоги (тобто, чи робить вона те, що ми хочемо).

Очікувана поведінка системи (у цьому випадку смарт-контракту) описується за допомогою формального моделювання, тоді як мови специфікацій дають змогу створювати формальні властивості. Методи формальної верифікації можуть потім перевірити, що реалізація контракту відповідає його специфікації, та отримати математичний доказ коректності першого. Коли контракт задовольняє свою специфікацію, його описують як «функціонально коректний», «коректний за задумом» або «коректний за побудовою».

### Що таке формальна модель? {#what-is-a-formal-model}

У комп’ютерних науках [формальна модель](https://en.wikipedia.org/wiki/Model_of_computation) — це математичний опис обчислювального процесу. Програми абстрагуються в математичні функції (рівняння), причому модель описує, як обчислюються вихідні дані функцій для заданих вхідних даних.

Формальні моделі забезпечують рівень абстракції, на якому можна оцінити аналіз поведінки програми. Існування формальних моделей дає змогу створити _формальну специфікацію_, яка описує бажані властивості відповідної моделі.

Для моделювання смарт-контрактів для формальної верифікації використовуються різні методи. Наприклад, деякі моделі використовуються для міркувань про високорівневу поведінку смарт-контракту. Ці методи моделювання застосовують підхід «чорної скриньки» до смарт-контрактів, розглядаючи їх як системи, що приймають вхідні дані та виконують обчислення на основі цих даних.

Високорівневі моделі зосереджуються на взаємозв’язку між смарт-контрактами та зовнішніми агентами, такими як зовнішні облікові записи (EOA), облікові записи контрактів та середовище блокчейну. Такі моделі корисні для визначення властивостей, які вказують, як контракт має поводитися у відповідь на певні взаємодії з користувачем.

І навпаки, інші формальні моделі зосереджуються на низькорівневій поведінці смарт-контракту. Хоча високорівневі моделі можуть допомогти в міркуваннях про функціональність контракту, вони можуть не враховувати деталі внутрішньої роботи реалізації. Низькорівневі моделі застосовують підхід «білої скриньки» до аналізу програм і покладаються на низькорівневі представлення додатків смарт-контрактів, як-от трасування програм і [графи потоку керування](https://en.wikipedia.org/wiki/Control-flow_graph), для міркувань про властивості, що стосуються виконання контракту.

Низькорівневі моделі вважаються ідеальними, оскільки вони представляють фактичне виконання смарт-контракту в середовищі виконання Ethereum (тобто [EVM](/developers/docs/evm/)). Методи низькорівневого моделювання особливо корисні для встановлення критичних властивостей безпеки в смарт-контрактах і виявлення потенційних уразливостей.

### Що таке формальна специфікація? {#what-is-a-formal-specification}

Специфікація — це просто технічна вимога, яку має задовольняти певна система. У програмуванні специфікації представляють загальні ідеї про виконання програми (тобто, що програма повинна робити).

У контексті смарт-контрактів формальні специфікації стосуються _властивостей_ — формальних описів вимог, які має задовольняти контракт. Такі властивості описуються як «інваріанти» і являють собою логічні твердження про виконання контракту, які повинні залишатися істинними за будь-яких можливих обставин без жодних винятків.

Таким чином, ми можемо розглядати формальну специфікацію як набір тверджень, написаних формальною мовою, які описують заплановане виконання смарт-контракту. Специфікації охоплюють властивості контракту та визначають, як контракт має поводитися в різних обставинах. Мета формальної верифікації — визначити, чи має смарт-контракт ці властивості (інваріанти) і чи не порушуються ці властивості під час виконання.

Формальні специфікації є критично важливими для розробки безпечних реалізацій смарт-контрактів. Контракти, які не реалізують інваріанти або властивості яких порушуються під час виконання, схильні до вразливостей, що можуть зашкодити функціональності або спричинити зловмисні експлойти.

## Типи формальних специфікацій для смарт-контрактів {#formal-specifications-for-smart-contracts}

Формальні специфікації дають змогу математично міркувати про коректність виконання програми. Як і у випадку з формальними моделями, формальні специфікації можуть фіксувати як високорівневі властивості, так і низькорівневу поведінку реалізації контракту.

Формальні специфікації виводяться з використанням елементів [логіки програм](https://en.wikipedia.org/wiki/Logic_programming), що дає змогу формально міркувати про властивості програми. Логіка програм має формальні правила, які виражають (математичною мовою) очікувану поведінку програми. Для створення формальних специфікацій використовуються різні логіки програм, зокрема [логіка досяжності](https://en.wikipedia.org/wiki/Reachability_problem), [темпоральна логіка](https://en.wikipedia.org/wiki/Temporal_logic) та [логіка Гоара](https://en.wikipedia.org/wiki/Hoare_logic).

Формальні специфікації для смарт-контрактів можна умовно класифікувати як **високорівневі** або **низькорівневі** специфікації. Незалежно від того, до якої категорії належить специфікація, вона повинна адекватно й однозначно описувати властивість аналізованої системи.

### Високорівневі специфікації {#high-level-specifications}

Як випливає з назви, високорівнева специфікація (також звана «модельно-орієнтованою специфікацією») описує високорівневу поведінку програми. Високорівневі специфікації моделюють смарт-контракт як [скінченний автомат](https://en.wikipedia.org/wiki/Finite-state_machine) (FSM), який може переходити між станами, виконуючи операції, при цьому для визначення формальних властивостей моделі FSM використовується темпоральна логіка.

[Темпоральні логіки](https://en.wikipedia.org/wiki/Temporal_logic) — це «правила для міркувань про пропозиції, кваліфіковані з погляду часу (наприклад, «Я _завжди_ голодний» або «Я _колись_ зголоднію»).” При застосуванні до формальної верифікації темпоральні логіки використовуються для формулювання тверджень про коректну поведінку систем, змодельованих як скінченні автомати. Зокрема, темпоральна логіка описує майбутні стани, у яких може перебувати смарт-контракт, і як він переходить між станами.

Високорівневі специфікації зазвичай фіксують дві критичні темпоральні властивості для смарт-контрактів: **безпеку** та **жвавість**. Властивості безпеки представляють ідею, що «ніколи не трапляється нічого поганого», і зазвичай виражають інваріантність. Властивість безпеки може визначати загальні вимоги до програмного забезпечення, як-от відсутність [взаємного блокування](https://www.techtarget.com/whatis/definition/deadlock) (deadlock), або виражати специфічні для домену властивості для контрактів (наприклад, інваріанти щодо контролю доступу до функцій, допустимі значення змінних стану або умови для переказів токенів).

Візьмемо, наприклад, таку вимогу безпеки, яка охоплює умови використання `transfer()` або `transferFrom()` у контрактах токенів ERC-20: _«Баланс відправника ніколи не буває нижчим за запитану суму токенів для надсилання»_. Цей опис інваріанту контракту природною мовою можна перекласти у формальну (математичну) специфікацію, яку потім можна ретельно перевірити на валідність.

Властивості жвавості стверджують, що «врешті-решт трапляється щось хороше», і стосуються здатності контракту просуватися через різні стани. Прикладом властивості жвавості є «ліквідність», яка означає здатність контракту переказувати свої баланси користувачам за запитом. Якщо цю властивість порушено, користувачі не зможуть вивести активи, що зберігаються в контракті, як це сталося під час [інциденту з гаманцем Parity](https://www.cnbc.com/2017/11/08/accidental-bug-may-have-frozen-280-worth-of-ether-on-parity-wallet.html).

### Низькорівневі специфікації {#low-level-specifications}

Високорівневі специфікації беруть за відправну точку скінченно-автоматну модель контракту та визначають бажані властивості цієї моделі. На відміну від них, низькорівневі специфікації (також звані «властиво-орієнтованими специфікаціями») часто моделюють програми (смарт-контракти) як системи, що складаються з набору математичних функцій, і описують коректну поведінку таких систем.

Простими словами, низькорівневі специфікації аналізують _трасування програм_ і намагаються визначити властивості смарт-контракту на основі цих трасувань. Трасування — це послідовності виконань функцій, які змінюють стан смарт-контракту; отже, низькорівневі специфікації допомагають визначати вимоги до внутрішнього виконання контракту.

Низькорівневі формальні специфікації можуть бути представлені або як властивості в стилі Гоара, або як інваріанти на шляхах виконання.

### Властивості в стилі Гоара {#hoare-style-properties}

[Логіка Гоара](https://en.wikipedia.org/wiki/Hoare_logic) надає набір формальних правил для міркувань про коректність програм, включно зі смарт-контрактами. Властивість у стилі Гоара представлена трійкою Гоара `{P}c{Q}`, де `c` — це програма, а `P` і `Q` — предикати стану `c` (тобто програми), формально описані як _передумови_ та _післяумови_ відповідно.

Передумова — це предикат, що описує умови, необхідні для коректного виконання функції; користувачі, які викликають контракт, повинні задовольняти цю вимогу. Післяумова — це предикат, що описує умову, яку функція встановлює, якщо вона виконана коректно; користувачі можуть очікувати, що ця умова буде істинною після виклику функції. _Інваріант_ у логіці Гоара — це предикат, який зберігається при виконанні функції (тобто не змінюється).

Специфікації в стилі Гоара можуть гарантувати або _часткову коректність_, або _повну коректність_. Реалізація функції контракту є «частково коректною», якщо передумова виконується до виконання функції, і якщо виконання завершується, післяумова також є істинною. Доказ повної коректності отримується, якщо передумова є істинною до виконання функції, виконання гарантовано завершується, і коли це відбувається, післяумова є істинною.

Отримати доказ повної коректності складно, оскільки деякі виконання можуть затримуватися перед завершенням або взагалі ніколи не завершуватися. З огляду на це, питання про те, чи завершується виконання, є, мабуть, спірним, оскільки механізм газу в Ethereum запобігає нескінченним циклам програм (виконання завершується або успішно, або через помилку «не вистачило газу»).

Специфікації смарт-контрактів, створені з використанням логіки Гоара, матимуть передумови, післяумови та інваріанти, визначені для виконання функцій і циклів у контракті. Передумови часто включають можливість помилкових вхідних даних для функції, а післяумови описують очікувану реакцію на такі вхідні дані (наприклад, генерацію певного винятку). Таким чином, властивості в стилі Гоара є ефективними для забезпечення коректності реалізацій контрактів.

Багато фреймворків формальної верифікації використовують специфікації в стилі Гоара для доведення семантичної коректності функцій. Також можна додавати властивості в стилі Гоара (як твердження) безпосередньо в код контракту за допомогою операторів `require` та `assert` у Solidity.

Оператори `require` виражають передумову або інваріант і часто використовуються для перевірки вхідних даних користувача, тоді як `assert` фіксує післяумову, необхідну для безпеки. Наприклад, належний контроль доступу до функцій (приклад властивості безпеки) можна досягти за допомогою `require` як перевірки передумови щодо ідентичності облікового запису, що викликає. Так само інваріант щодо допустимих значень змінних стану в контракті (наприклад, загальна кількість токенів в обігу) можна захистити від порушення за допомогою `assert` для підтвердження стану контракту після виконання функції.

### Властивості на рівні трасування {#trace-level-properties}

Специфікації на основі трасування описують операції, які переводять контракт між різними станами, та взаємозв'язки між цими операціями. Як пояснювалося раніше, трасування — це послідовності операцій, які певним чином змінюють стан контракту.

Цей підхід спирається на модель смарт-контрактів як систем переходу станів із деякими заздалегідь визначеними станами (описаними змінними стану) разом із набором заздалегідь визначених переходів (описаних функціями контракту). Крім того, для опису операційної семантики контракту часто використовується [граф потоку керування](https://www.geeksforgeeks.org/software-engineering-control-flow-graph-cfg/) (CFG), який є графічним представленням потоку виконання програми. Тут кожне трасування представлено як шлях на графі потоку керування.

В першу чергу, специфікації на рівні трасування використовуються для міркувань про патерни внутрішнього виконання в смарт-контрактах. Створюючи специфікації на рівні трасування, ми стверджуємо допустимі шляхи виконання (тобто переходи станів) для смарт-контракту. Використовуючи такі методи, як символьне виконання, ми можемо формально перевірити, що виконання ніколи не йде шляхом, не визначеним у формальній моделі.

Давайте використаємо приклад контракту [DAO](/dao/), який має деякі загальнодоступні функції для опису властивостей на рівні трасування. Тут ми припускаємо, що контракт DAO дозволяє користувачам виконувати такі операції:

- Вносити кошти

- Голосувати за пропозицію після внесення коштів

- Вимагати повернення коштів, якщо вони не голосують за пропозицію

Прикладами властивостей на рівні трасування можуть бути: _«користувачі, які не вносять кошти, не можуть голосувати за пропозицію»_ або _«користувачі, які не голосують за пропозицію, завжди повинні мати можливість вимагати повернення коштів»_. Обидві властивості стверджують бажані послідовності виконання (голосування не може відбуватися _до_ внесення коштів, а вимога повернення коштів не може відбуватися _після_ голосування за пропозицію).

## Методи формальної верифікації смарт-контрактів {#formal-verification-techniques}

### Перевірка моделей {#model-checking}

Перевірка моделей — це метод формальної верифікації, за якого алгоритм перевіряє формальну модель смарт-контракту на відповідність її специфікації. При перевірці моделей смарт-контракти часто представляються як системи переходу станів, а властивості допустимих станів контракту визначаються за допомогою темпоральної логіки.

Перевірка моделей вимагає створення абстрактного математичного представлення системи (тобто контракту) і вираження властивостей цієї системи за допомогою формул, що ґрунтуються на [пропозиційній логіці](https://www.baeldung.com/cs/propositional-logic). Це спрощує завдання алгоритму перевірки моделей, а саме: довести, що математична модель задовольняє задану логічну формулу.

Перевірка моделей у формальній верифікації в основному використовується для оцінки темпоральних властивостей, які описують поведінку контракту з плином часу. Темпоральні властивості для смарт-контрактів включають _безпеку_ та _жвавість_, які ми пояснювали раніше.

Наприклад, властивість безпеки, пов'язану з контролем доступу (наприклад, _Лише власник контракту може викликати `selfdestruct`_), можна записати у формальній логіці. Після цього алгоритм перевірки моделей може перевірити, чи задовольняє контракт цю формальну специфікацію.

Перевірка моделей використовує дослідження простору станів, що передбачає побудову всіх можливих станів смарт-контракту та спробу знайти досяжні стани, які призводять до порушення властивостей. Однак це може призвести до нескінченної кількості станів (відомої як «проблема вибуху станів»), тому засоби перевірки моделей покладаються на методи абстракції, щоб зробити можливим ефективний аналіз смарт-контрактів.

### Доведення теорем {#theorem-proving}

Доведення теорем — це метод математичного міркування про коректність програм, включно зі смарт-контрактами. Він передбачає перетворення моделі системи контракту та її специфікацій на математичні формули (логічні твердження).

Мета доведення теорем — перевірити логічну еквівалентність між цими твердженнями. «Логічна еквівалентність» (також звана «логічна біімплікація») — це тип відношення між двома твердженнями, за якого перше твердження є істинним _тоді і тільки тоді_, коли істинним є друге твердження.

Необхідне відношення (логічна еквівалентність) між твердженнями про модель контракту та її властивість формулюється як доказове твердження (що називається теоремою). Використовуючи формальну систему висновування, автоматизований доказувач теорем може перевірити валідність теореми. Іншими словами, доказувач теорем може остаточно довести, що модель смарт-контракту точно відповідає його специфікаціям.

Хоча перевірка моделей моделює контракти як системи переходу зі скінченними станами, доведення теорем може обробляти аналіз систем з нескінченними станами. Однак це означає, що автоматизований доказувач теорем не завжди може знати, чи є логічна задача «розв'язною», чи ні.

У результаті часто потрібна допомога людини, щоб спрямувати доказувач теорем у виведенні доказів коректності. Використання людських зусиль у доведенні теорем робить його дорожчим у використанні, ніж перевірка моделей, яка є повністю автоматизованою.

### Символьне виконання {#symbolic-execution}

Символьне виконання — це метод аналізу смарт-контракту шляхом виконання функцій з використанням _символьних значень_ (наприклад, `x > 5`) замість _конкретних значень_ (наприклад, `x == 5`). Як метод формальної верифікації, символьне виконання використовується для формального міркування про властивості на рівні трасування в коді контракту.

Символьне виконання представляє трасування виконання як математичну формулу над символьними вхідними значеннями, інакше кажучи — _предикат шляху_. [SMT-розв’язувач](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories) використовується для перевірки, чи є предикат шляху «виконуваним» (тобто, чи існує значення, яке може задовольнити формулу). Якщо вразливий шлях є виконуваним, SMT-розв’язувач згенерує конкретне значення, яке спрямовує виконання до цього шляху.

Припустимо, функція смарт-контракту приймає на вхід значення `uint` (`x`) і скасовує транзакцію, коли `x` більше `5` і водночас менше `10`. Пошук значення `x`, яке викликає помилку, за допомогою звичайної процедури тестування вимагав би перебору десятків тестових випадків (або більше) без гарантії фактичного знаходження вхідних даних, що викликають помилку.

Навпаки, інструмент символьного виконання виконав би функцію з символьним значенням: `X > 5 ∧ X < 10` (тобто `x` більше 5 І `x` менше 10). Пов’язаний предикат шляху `x = X > 5 ∧ X < 10` потім буде передано SMT-розв’язувачу для розв’язання. Якщо певне значення задовольняє формулу `x = X > 5 ∧ X < 10`, SMT-розв’язувач обчислить його — наприклад, розв’язувач може видати `7` як значення для `x`.

Оскільки символьне виконання покладається на вхідні дані програми, а набір вхідних даних для дослідження всіх досяжних станів потенційно нескінченний, це все ще є формою тестування. Однак, як показано на прикладі, символьне виконання є більш ефективним, ніж звичайне тестування, для знаходження вхідних даних, що викликають порушення властивостей.

Крім того, символьне виконання дає менше хибнопозитивних спрацьовувань, ніж інші методи на основі властивостей (наприклад, фазинг), які випадково генерують вхідні дані для функції. Якщо під час символьного виконання спрацьовує стан помилки, то можна згенерувати конкретне значення, яке викликає помилку, і відтворити проблему.

Символьне виконання також може надати певний ступінь математичного доказу коректності. Розглянемо наступний приклад функції контракту із захистом від переповнення:

```
function safe_add(uint x, uint y) returns(uint z){

  z = x + y;
  require(z>=x);
  require(z>=y);

  return z;
}
```

Трасування виконання, що призводить до цілочисельного переповнення, повинно задовольняти формулу: `z = x + y AND (z >= x) AND (z >= y) AND (z < x OR z < y)`. Таку формулу навряд чи можна розв'язати, отже, вона слугує математичним доказом того, що функція `safe_add` ніколи не переповнюється.

### Навіщо використовувати формальну верифікацію для смарт-контрактів? {#benefits-of-formal-verification}

#### Потреба в надійності {#need-for-reliability}

Формальна верифікація використовується для оцінки коректності критично важливих для безпеки систем, збій яких може мати руйнівні наслідки, такі як смерть, травми або фінансовий крах. Смарт-контракти — це високоцінні додатки, що контролюють величезні обсяги цінностей, і прості помилки в проєктуванні можуть призвести до [незворотних втрат для користувачів](https://www.freecodecamp.org/news/a-hacker-stole-31m-of-ether-how-it-happened-and-what-it-means-for-ethereum-9e5dc29e33ce/amp/). Однак формальна верифікація контракту перед розгортанням може підвищити гарантії того, що він працюватиме як очікувалося, коли буде запущений у блокчейні.

Надійність є дуже бажаною якістю будь-якого смарт-контракту, особливо тому, що код, розгорнутий у віртуальній машині Ethereum (EVM), зазвичай є незмінним. Оскільки оновлення після запуску не є легкодоступними, необхідність гарантувати надійність контрактів робить формальну верифікацію необхідною. Формальна верифікація здатна виявляти складні проблеми, такі як цілочисельне недоповнення та переповнення, повторне входження та погана оптимізація газу, які можуть прослизнути повз аудиторів і тестувальників.

#### Доведення функціональної коректності {#prove-functional-correctness}

Тестування програм — це найпоширеніший метод доведення того, що смарт-контракт задовольняє певні вимоги. Це передбачає виконання контракту з вибіркою даних, які він, як очікується, буде обробляти, та аналіз його поведінки. Якщо контракт повертає очікувані результати для вибіркових даних, то розробники мають об'єктивний доказ його коректності.

Однак цей підхід не може довести коректне виконання для вхідних значень, які не є частиною вибірки. Тому тестування контракту може допомогти виявити помилки (тобто, якщо деякі шляхи коду не повертають бажаних результатів під час виконання), але **воно не може остаточно довести відсутність помилок**.

І навпаки, формальна верифікація може формально довести, що смарт-контракт задовольняє вимоги для нескінченного діапазону виконань, _не запускаючи_ контракт узагалі. Це вимагає створення формальної специфікації, яка точно описує коректну поведінку контракту, і розробки формальної (математичної) моделі системи контракту. Потім ми можемо слідувати формальній процедурі доведення, щоб перевірити узгодженість між моделлю контракту та його специфікацією.

З формальною верифікацією питання перевірки того, чи задовольняє бізнес-логіка контракту вимогам, є математичним твердженням, яке можна довести або спростувати. Формально доводячи твердження, ми можемо перевірити нескінченну кількість тестових випадків за скінченну кількість кроків. Таким чином, формальна верифікація має кращі перспективи для доведення того, що контракт є функціонально коректним відносно специфікації.

#### Ідеальні цілі для верифікації {#ideal-verification-targets}

Ціль верифікації описує систему, яку потрібно формально верифікувати. Формальна верифікація найкраще використовується у «вбудованих системах» (невеликих, простих частинах програмного забезпечення, які є частиною більшої системи). Вони також ідеально підходять для спеціалізованих доменів, які мають небагато правил, оскільки це полегшує модифікацію інструментів для перевірки властивостей, специфічних для домену.

Смарт-контракти — принаймні певною мірою — відповідають обом вимогам. Наприклад, невеликий розмір контрактів Ethereum робить їх придатними для формальної верифікації. Так само EVM дотримується простих правил, що полегшує визначення та перевірку семантичних властивостей для програм, що працюють в EVM.

### Швидший цикл розробки {#faster-development-cycle}

Методи формальної верифікації, такі як перевірка моделей та символьне виконання, загалом ефективніші, ніж звичайний аналіз коду смарт-контрактів (що виконується під час тестування або аудиту). Це тому, що формальна верифікація покладається на символьні значення для перевірки тверджень («що, якщо користувач спробує вивести _n_ ефіру?») на відміну від тестування, яке використовує конкретні значення («що, якщо користувач спробує вивести 5 ефірів?»).

Символьні вхідні змінні можуть охоплювати кілька класів конкретних значень, тому підходи формальної верифікації обіцяють більше покриття коду за коротший проміжок часу. При ефективному використанні формальна верифікація може прискорити цикл розробки для розробників.

Формальна верифікація також покращує процес створення децентралізованих додатків (dapps), зменшуючи кількість дорогих помилок у проєктуванні. Оновлення контрактів (де це можливо) для виправлення вразливостей вимагає значного переписування кодових баз і більше зусиль, витрачених на розробку. Формальна верифікація може виявити багато помилок у реалізаціях контрактів, які можуть прослизнути повз тестувальників і аудиторів, і надає достатньо можливостей для виправлення цих проблем перед розгортанням контракту.

## Недоліки формальної верифікації {#drawbacks-of-formal-verification}

### Вартість ручної праці {#cost-of-manual-labor}

Формальна верифікація, особливо напівавтоматична верифікація, в якій людина керує доказувачем для виведення доказів коректності, вимагає значної ручної праці. Крім того, створення формальної специфікації — це складна діяльність, яка вимагає високого рівня кваліфікації.

Ці фактори (зусилля та кваліфікація) роблять формальну верифікацію більш вимогливою та дорогою порівняно зі звичайними методами оцінки коректності контрактів, такими як тестування та аудит. Тим не менш, оплата повноцінного аудиту верифікації є практичною, враховуючи вартість помилок у реалізаціях смарт-контрактів.

### Хибнонегативні результати {#false-negatives}

Формальна верифікація може лише перевірити, чи відповідає виконання смарт-контракту формальній специфікації. Таким чином, важливо переконатися, що специфікація належним чином описує очікувану поведінку смарт-контракту.

Якщо специфікації написані погано, порушення властивостей, які вказують на вразливі виконання, не можуть бути виявлені аудитом формальної верифікації. У цьому випадку розробник може помилково припустити, що контракт не містить помилок.

### Проблеми з продуктивністю {#performance-issues}

Формальна верифікація стикається з низкою проблем із продуктивністю. Наприклад, проблеми вибуху станів і шляхів, що виникають під час перевірки моделей та символьної перевірки відповідно, можуть вплинути на процедури верифікації. Також інструменти формальної верифікації часто використовують SMT-розв'язувачі та інші розв'язувачі обмежень на своєму базовому рівні, і ці розв'язувачі покладаються на обчислювально інтенсивні процедури.

Також, верифікаторам програм не завжди можливо визначити, чи може властивість (описана як логічна формула) бути задоволена чи ні («[проблема розв'язності](https://en.wikipedia.org/wiki/Decision_problem)»), оскільки програма може ніколи не завершитися. Таким чином, може бути неможливо довести деякі властивості для контракту, навіть якщо він добре специфікований.

## Інструменти формальної верифікації для смарт-контрактів Ethereum {#formal-verification-tools}

### Мови специфікацій для створення формальних специфікацій {#specification-languages}

**Act**: __Act дозволяє специфікувати оновлення сховища, передумови/післяумови та інваріанти контракту. Його набір інструментів також має бекенди для доведення, здатні доводити багато властивостей через Coq, SMT-розв'язувачі або hevm.__

- [GitHub](https://github.com/ethereum/act)
- [Документація](https://github.com/argotorg/act)

**Scribble** — __Scribble перетворює анотації коду мовою специфікацій Scribble на конкретні твердження, які перевіряють специфікацію.__

- [Документація](https://docs.scribble.codes/)

**Dafny** — __Dafny — це готова до верифікації мова програмування, яка покладається на високорівневі анотації для міркування та доведення коректності коду.__

- [GitHub](https://github.com/dafny-lang/dafny)

### Верифікатори програм для перевірки коректності {#program-verifiers}

**Certora Prover** — _Certora Prover — це автоматичний інструмент формальної верифікації для перевірки коректності коду в смарт-контрактах. Специфікації пишуться мовою CVL (Certora Verification Language), а порушення властивостей виявляються за допомогою комбінації статичного аналізу та розв'язання обмежень._

- [Вебсайт](https://www.certora.com/)
- [Документація](https://docs.certora.com/en/latest/index.html)

**Solidity SMTChecker** — __SMTChecker у Solidity — це вбудований засіб перевірки моделей на основі SMT (Satisfiability Modulo Theories) і розв'язання за Горном. Він підтверджує, чи відповідає вихідний код контракту специфікаціям під час компіляції, і статично перевіряє наявність порушень властивостей безпеки.__

- [GitHub](https://github.com/ethereum/solidity)

**solc-verify** — __solc-verify — це розширена версія компілятора Solidity, яка може виконувати автоматичну формальну верифікацію коду Solidity за допомогою анотацій та модульної верифікації програм.__

- [GitHub](https://github.com/SRI-CSL/solidity)

**KEVM** — __KEVM — це формальна семантика віртуальної машини Ethereum (EVM), написана на фреймворку K. KEVM є виконуваною і може доводити певні твердження, пов'язані з властивостями, використовуючи логіку досяжності.__

- [GitHub](https://github.com/runtimeverification/evm-semantics)
- [Документація](https://jellopaper.org/)

### Логічні фреймворки для доведення теорем {#theorem-provers}

**Isabelle** — _Isabelle/HOL — це асистент доведення, який дозволяє виражати математичні формули формальною мовою та надає інструменти для доведення цих формул. Основне застосування — це формалізація математичних доказів і, зокрема, формальна верифікація, що включає доведення коректності комп'ютерного обладнання або програмного забезпечення, а також доведення властивостей комп'ютерних мов і протоколів._

- [GitHub](https://github.com/isabelle-prover)
- [Документація](https://isabelle.in.tum.de/documentation.html)

**Rocq** — _Rocq — це інтерактивний доказувач теорем, який дозволяє визначати програми за допомогою теорем та інтерактивно генерувати докази коректності, що перевіряються машиною._

- [GitHub](https://github.com/rocq-prover/rocq)
- [Документація](https://rocq-prover.org/docs)

### Інструменти на основі символьного виконання для виявлення вразливих патернів у смарт-контрактах {#symbolic-execution-tools}

**Manticore** — __Інструмент для аналізу байт-коду EVM на основі символьного виконання_._

- [GitHub](https://github.com/trailofbits/manticore)
- [Документація](https://github.com/trailofbits/manticore/wiki)

**hevm** — __hevm — це механізм символьного виконання та засіб перевірки еквівалентності для байт-коду EVM.__

- [GitHub](https://github.com/dapphub/dapptools/tree/master/src/hevm)

**Mythril** — _інструмент символьного виконання для виявлення вразливостей у смарт-контрактах Ethereum_

- [GitHub](https://github.com/ConsenSys/mythril-classic)
- [Документація](https://mythril-classic.readthedocs.io/en/develop/)

## Для подальшого читання {#further-reading}

- [Як працює формальна верифікація смарт-контрактів](https://runtimeverification.com/blog/how-formal-verification-of-smart-contracts-works/)
- [Як формальна верифікація може забезпечити бездоганні смарт-контракти](https://media.consensys.net/how-formal-verification-can-ensure-flawless-smart-contracts-cbda8ad99bd1)
- [Огляд проєктів формальної верифікації в екосистемі Ethereum](https://github.com/leonardoalt/ethereum_formal_verification_overview)
- [Наскрізна формальна верифікація депозитного смарт-контракту Ethereum 2.0](https://runtimeverification.com/blog/end-to-end-formal-verification-of-ethereum-2-0-deposit-smart-contract/)
- [Формальна верифікація найпопулярнішого смарт-контракту у світі](https://www.zellic.io/blog/formal-verification-weth)
- [SMTChecker та формальна верифікація](https://docs.soliditylang.org/en/v0.8.15/smtchecker.html)
