---
title: Безпека смартконтракту
description: Огляд рекомендацій щодо створення безпечних смарт-контрактів Ethereum
lang: uk
---

Смарт-контракти є надзвичайно гнучкими і здатні контролювати великі обсяги цінностей і даних, при цьому виконуючи незмінну логіку на основі коду, розгорнутого в блокчейні. Це створило динамічну екосистему бездовірних і децентралізованих застосунків, які надають багато переваг у порівнянні з застарілими системами. Вони також створюють можливості для зловмисників, які прагнуть отримати прибуток шляхом використання вразливостей у смарт-контрактах.

Публічні блокчейни, як-от Ethereum, ще більше ускладнюють проблему забезпечення безпеки смарт-контрактів. Розгорнутий код контракту _зазвичай_ неможливо змінити, щоб виправити недоліки безпеки, а активи, викрадені зі смарт-контрактів, надзвичайно важко відстежити і переважно неможливо повернути через їхню незмінність.

Хоча цифри різняться, за оцінками, загальна сума вартості, вкраденої або втраченої через дефекти безпеки в смарт-контрактах, легко перевищує 1 мільярд доларів. Це включає гучні інциденти, як-от злам [DAO](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/) (вкрадено 3,6 млн ETH, що за сьогоднішніми цінами становить понад 1 млрд доларів), злам [гаманця з мультипідписом Parity](https://www.coindesk.com/markets/2017/07/19/30-million-ether-reported-stolen-due-to-parity-wallet-breach) (30 млн доларів, втрачених через хакерів), та [проблему замороженого гаманця Parity](https://www.theguardian.com/technology/2017/nov/08/cryptocurrency-300m-dollars-stolen-bug-ether) (понад 300 млн доларів в ETH, заблокованих назавжди).

Вищезгадані проблеми вимагають від розробників докладати зусиль для створення безпечних, надійних і стійких смарт-контрактів. Безпека смарт-контрактів — це серйозна справа, і кожен розробник добре зробить, якщо вивчить її. У цьому посібнику розглядаються аспекти безпеки для розробників Ethereum та досліджуються ресурси для підвищення безпеки смарт-контрактів.

## Передумови {#prerequisites}

Перш ніж займатися безпекою, переконайтеся, що ви знайомі з [основами розробки смарт-контрактів](/developers/docs/smart-contracts/).

## Рекомендації щодо створення безпечних смарт-контрактів Ethereum {#smart-contract-security-guidelines}

### 1. Розробка належних засобів контролю доступу {#design-proper-access-controls}

У смарт-контрактах функції, позначені як `public` або `external`, можуть викликатися будь-якими обліковими записами, що належать зовнішнім власникам (EOA), або обліковими записами контрактів. Вказання публічної видимості для функцій є необхідним, якщо ви хочете, щоб інші могли взаємодіяти з вашим контрактом. Проте функції, позначені як `private`, можуть викликатися лише функціями всередині смарт-контракту, а не зовнішніми обліковими записами. Надання кожному учаснику мережі доступу до функцій контракту може спричинити проблеми, особливо якщо це означає, що будь-хто може виконувати конфіденційні операції (наприклад, карбування нових токенів).

Щоб запобігти несанкціонованому використанню функцій смарт-контракту, необхідно впровадити безпечні засоби контролю доступу. Механізми контролю доступу обмежують можливість використання певних функцій у смарт-контракті для затверджених суб’єктів, таких як облікові записи, відповідальні за керування контрактом. Патерн **Ownable** та **контроль на основі ролей** — це два патерни, корисні для реалізації контролю доступу в смарт-контрактах:

#### Патерн Ownable {#ownable-pattern}

У патерні Ownable адреса встановлюється як «власник» контракту під час процесу створення контракту. Захищеним функціям присвоюється модифікатор `OnlyOwner`, який гарантує, що контракт автентифікує особу адреси, що викликає, перед виконанням функції. Виклики захищених функцій з інших адрес, окрім власника контракту, завжди скасовуються, що запобігає небажаному доступу.

#### Контроль доступу на основі ролей {#role-based-access-control}

Реєстрація однієї адреси як `Owner` у смарт-контракті створює ризик централізації та є єдиною точкою відмови. Якщо ключі облікового запису власника скомпрометовані, зловмисники можуть атакувати контракт, що йому належить. Ось чому використання патерну контролю доступу на основі ролей із кількома адміністративними обліковими записами може бути кращим варіантом.

При контролі доступу на основі ролей доступ до конфіденційних функцій розподіляється між набором довірених учасників. Наприклад, один обліковий запис може відповідати за карбування токенів, а інший — за оновлення або призупинення контракту. Така децентралізація контролю доступу усуває єдині точки відмови та зменшує припущення щодо довіри для користувачів.

##### Використання гаманців з мультипідписом

Іншим підходом до реалізації безпечного контролю доступу є використання [облікового запису з мультипідписом](/developers/docs/smart-contracts/#multisig) для керування контрактом. На відміну від звичайного EOA, облікові записи з мультипідписом належать кільком суб’єктам і вимагають підписів від мінімальної кількості облікових записів — скажімо, 3 із 5 — для виконання транзакцій.

Використання мультипідпису для контролю доступу створює додатковий шар безпеки, оскільки дії з цільовим контрактом вимагають згоди кількох сторін. Це особливо корисно, якщо необхідно використовувати патерн Ownable, оскільки це ускладнює зловмиснику або нечесному інсайдеру маніпулювання конфіденційними функціями контракту в зловмисних цілях.

### 2. Використовуйте оператори require(), assert() і revert() для захисту операцій контракту {#use-require-assert-revert}

Як уже згадувалося, будь-хто може викликати публічні функції у вашому смарт-контракті після його розгортання в блокчейні. Оскільки ви не можете заздалегідь знати, як зовнішні облікові записи будуть взаємодіяти з контрактом, ідеально впровадити внутрішні заходи захисту від проблемних операцій перед розгортанням. Ви можете забезпечити правильну поведінку в смарт-контрактах, використовуючи оператори `require()`, `assert()` і `revert()`, щоб викликати винятки та скасовувати зміни стану, якщо виконання не відповідає певним вимогам.

**`require()`**: `require` визначаються на початку функцій і гарантують, що попередньо визначені умови виконані до виконання викликаної функції. Оператор `require` може використовуватися для перевірки введених користувачем даних, перевірки змінних стану або автентифікації особистості облікового запису, що викликає, перш ніж продовжувати роботу з функцією.

**`assert()`**: `assert()` використовується для виявлення внутрішніх помилок і перевірки порушень «інваріантів» у вашому коді. Інваріант — це логічне твердження про стан контракту, яке має залишатися істинним для всіх виконань функцій. Прикладом інваріанту є максимальна загальна пропозиція або баланс контракту токенів. Використання `assert()` гарантує, що ваш контракт ніколи не досягне вразливого стану, а якщо це станеться, усі зміни змінних стану будуть скасовані.

**`revert()`**: `revert()` можна використовувати в операторі if-else, який викликає виняток, якщо необхідна умова не виконується. Наведений нижче приклад контракту використовує `revert()` для захисту виконання функцій:

```
pragma solidity ^0.8.4;

contract VendingMachine {
    address owner;
    error Unauthorized();
    function buy(uint amount) public payable {
        if (amount > msg.value / 2 ether)
            revert("Надано недостатньо Ether.");
        // Виконайте покупку.
    }
    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}
```

### 3. Тестуйте смарт-контракти та перевіряйте правильність коду {#test-smart-contracts-and-verify-code-correctness}

Незмінність коду, що виконується у [віртуальній машині Ethereum](/developers/docs/evm/), означає, що смарт-контракти вимагають вищого рівня оцінки якості на етапі розробки. Ретельне тестування вашого контракту та спостереження за будь-якими неочікуваними результатами значно покращить безпеку та захистить ваших користувачів у довгостроковій перспективі.

Звичайний метод полягає в написанні невеликих модульних тестів з використанням макетних даних, які контракт, як очікується, отримає від користувачів. [Модульне тестування](/developers/docs/smart-contracts/testing/#unit-testing) добре підходить для тестування функціональності певних функцій і перевірки того, що смарт-контракт працює, як очікувалося.

На жаль, модульне тестування є мінімально ефективним для підвищення безпеки смарт-контрактів, якщо воно використовується окремо. Модульний тест може довести, що функція виконується належним чином для макетних даних, але модульні тести настільки ефективні, наскільки ефективні тести, які написані. Це ускладнює виявлення пропущених крайніх випадків і вразливостей, які можуть порушити безпеку вашого смарт-контракту.

Кращий підхід — поєднати модульне тестування з тестуванням на основі властивостей, що виконується за допомогою [статичного та динамічного аналізу](/developers/docs/smart-contracts/testing/#static-dynamic-analysis). Статичний аналіз покладається на представлення низького рівня, такі як [графи потоку керування](https://en.wikipedia.org/wiki/Control-flow_graph) та [абстрактні синтаксичні дерева](https://deepsource.io/glossary/ast/), для аналізу досяжних станів програми та шляхів виконання. Тим часом, методи динамічного аналізу, такі як [фаззінг смарт-контрактів](https://www.cyfrin.io/blog/smart-contract-fuzzing-and-invariants-testing-foundry), виконують код контракту з випадковими вхідними значеннями для виявлення операцій, що порушують властивості безпеки.

[Формальна верифікація](/developers/docs/smart-contracts/formal-verification) — ще один метод перевірки властивостей безпеки в смарт-контрактах. На відміну від звичайного тестування, формальна верифікація може остаточно довести відсутність помилок у смарт-контракті. Це досягається шляхом створення формальної специфікації, яка фіксує бажані властивості безпеки, і доведення того, що формальна модель контрактів відповідає цій специфікації.

### 4. Попросіть про незалежну перевірку вашого коду {#get-independent-code-reviews}

Після тестування вашого контракту, добре попросити інших перевірити вихідний код на наявність будь-яких проблем з безпекою. Тестування не виявить усіх недоліків у смарт-контракті, але отримання незалежної перевірки збільшує ймовірність виявлення вразливостей.

#### Аудити {#audits}

Замовлення аудиту смарт-контракту є одним зі способів проведення незалежної перевірки коду. Аудитори відіграють важливу роль у забезпеченні того, щоб смарт-контракти були безпечними та вільними від дефектів якості та помилок у проєктуванні.

Проте, вам слід уникати розгляду аудитів як панацеї. Аудити смарт-контрактів не виявлять усіх помилок і переважно призначені для надання додаткового раунду перевірок, що може допомогти виявити проблеми, пропущені розробниками під час початкової розробки та тестування. Ви також повинні дотримуватися найкращих практик роботи з аудиторами, таких як належне документування коду та додавання вбудованих коментарів, щоб отримати максимальну користь від аудиту смарт-контракту.

- [Поради та хитрощі щодо аудиту смарт-контрактів](https://twitter.com/tinchoabbate/status/1400170232904400897) - _@tinchoabbate_
- [Отримайте максимум від свого аудиту](https://inference.ag/blog/2023-08-14-tips/) - _Inference_

#### Програми винагород за виявлення помилок (баг-баунті) {#bug-bounties}

Створення програми винагород за виявлення помилок — ще один підхід до впровадження зовнішніх перевірок коду. Винагорода за виявлення помилок (баг-баунті) — це фінансова винагорода, що надається особам (зазвичай «білим» хакерам), які виявляють уразливості в застосунку.

При правильному використанні програми винагород за помилки дають членам хакерської спільноти стимул перевіряти ваш код на наявність критичних недоліків. Реальним прикладом є «помилка нескінченних грошей», яка дозволила б зловмиснику створювати необмежену кількість ефіру на [Optimism](https://www.optimism.io/), протоколі [Шару 2](/layer-2/), що працює на Ethereum. На щастя, «білий» хакер [виявив недолік](https://www.saurik.com/optimism.html) і повідомив команду, [заробивши при цьому велику винагороду](https://cryptoslate.com/critical-bug-in-ethereum-l2-optimism-2m-bounty-paid/).

Корисною стратегією є встановлення розміру виплати за програмою винагород за помилки пропорційно до суми коштів, що перебувають під загрозою. Цей підхід, описаний як «[програма масштабування винагород за помилки](https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7)», надає фінансові стимули для осіб, щоб вони відповідально розкривали вразливості, а не використовували їх.

### 5. Дотримуйтесь найкращих практик під час розробки смарт-контрактів {#follow-smart-contract-development-best-practices}

Існування аудитів і програм винагород за помилки не звільняє вас від відповідальності писати високоякісний код. Хороша безпека смарт-контрактів починається з дотримання належних процесів проєктування та розробки:

- Зберігайте весь код у системі контролю версій, такій як git

- Робіть усі зміни в коді через pull-запити

- Переконайтеся, що pull-запити мають принаймні одного незалежного рецензента — якщо ви працюєте над проєктом самостійно, розгляньте можливість знайти інших розробників і обмінюватися перевірками коду

- Використовуйте [середовище розробки](/developers/docs/frameworks/) для тестування, компіляції та розгортання смарт-контрактів

- Проганяйте свій код через базові інструменти аналізу коду, такі як [Cyfrin Aderyn](https://github.com/Cyfrin/aderyn), Mythril і Slither. В ідеалі, ви повинні робити це перед кожним злиттям pull-запиту та порівнювати відмінності у вихідних даних

- Переконайтеся, що ваш код компілюється без помилок, і компілятор Solidity не видає попереджень

- Належним чином документуйте свій код (використовуючи [NatSpec](https://solidity.readthedocs.io/en/develop/natspec-format.html)) і описуйте деталі архітектури контракту легкою для розуміння мовою. Це полегшить іншим аудит і перевірку вашого коду.

### 6. Впроваджуйте надійні плани аварійного відновлення {#implement-disaster-recovery-plans}

Розробка безпечних засобів контролю доступу, впровадження модифікаторів функцій та інші пропозиції можуть покращити безпеку смарт-контрактів, але вони не можуть виключити можливість зловмисних експлойтів. Створення безпечних смарт-контрактів вимагає «підготовки до невдач» і наявності резервного плану для ефективного реагування на атаки. Належний план аварійного відновлення включатиме деякі або всі з наступних компонентів:

#### Оновлення контрактів {#contract-upgrades}

Хоча смарт-контракти Ethereum за замовчуванням є незмінними, можна досягти певного ступеня змінюваності, використовуючи патерни оновлення. Оновлення контрактів необхідне у випадках, коли критичний недолік робить ваш старий контракт непридатним для використання, і розгортання нової логіки є найбільш доцільним варіантом.

Механізми оновлення контрактів працюють по-різному, але «проксі-патерн» є одним із найпопулярніших підходів до оновлення смарт-контрактів. [Проксі-патерни](https://www.cyfrin.io/blog/upgradeable-proxy-smart-contract-pattern) розділяють стан і логіку застосунку між _двома_ контрактами. Перший контракт (називається «проксі-контракт») зберігає змінні стану (наприклад, баланси користувачів), а другий контракт (називається «логічний контракт») містить код для виконання функцій контракту.

Облікові записи взаємодіють з проксі-контрактом, який перенаправляє всі виклики функцій до логічного контракту за допомогою низькорівневого виклику [`delegatecall()`](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries). На відміну від звичайного виклику повідомлення, `delegatecall()` гарантує, що код, який виконується за адресою логічного контракту, виконується в контексті контракту, що викликає. Це означає, що логічний контракт завжди буде записувати дані в сховище проксі (замість власного сховища), і початкові значення `msg.sender` та `msg.value` зберігаються.

Делегування викликів логічному контракту вимагає зберігання його адреси в сховищі проксі-контракту. Отже, оновлення логіки контракту — це лише питання розгортання іншого логічного контракту та зберігання нової адреси в проксі-контракті. Оскільки наступні виклики до проксі-контракту автоматично спрямовуються до нового логічного контракту, ви «оновили» б контракт, фактично не змінюючи код.

[Детальніше про оновлення контрактів](/developers/docs/smart-contracts/upgrading/).

#### Аварійні зупинки {#emergency-stops}

Як уже згадувалося, ретельний аудит і тестування не можуть виявити всі помилки в смарт-контракті. Якщо після розгортання у вашому коді з'являється вразливість, виправити її неможливо, оскільки ви не можете змінити код, що працює за адресою контракту. Крім того, механізми оновлення (наприклад, проксі-патерни) можуть вимагати часу для впровадження (вони часто вимагають схвалення від різних сторін), що лише дає зловмисникам більше часу, щоб завдати більшої шкоди.

Крайній варіант — це реалізувати функцію «аварійної зупинки», яка блокує виклики вразливих функцій у контракті. Аварійні зупинки зазвичай складаються з таких компонентів:

1. Глобальна булева змінна, яка вказує, чи перебуває смарт-контракт у зупиненому стані. Ця змінна встановлюється у значення `false` під час налаштування контракту, але повертається до значення `true` після його зупинки.

2. Функції, які посилаються на булеву змінну під час свого виконання. Такі функції доступні, коли смарт-контракт не зупинено, і стають недоступними, коли спрацьовує функція аварійної зупинки.

3. Суб’єкт, що має доступ до функції аварійної зупинки, яка встановлює булеву змінну в значення `true`. Щоб запобігти зловмисним діям, виклики цієї функції можна обмежити довіреною адресою (наприклад, власником контракту).

Щойно контракт активує аварійну зупинку, певні функції не можна буде викликати. Це досягається шляхом обгортання вибраних функцій у модифікатор, який посилається на глобальну змінну. Нижче наведено [приклад](https://github.com/fravoll/solidity-patterns/blob/master/EmergencyStop/EmergencyStop.sol), що описує реалізацію цього патерна в контрактах:

```solidity
// Цей код не пройшов професійний аудит і не гарантує безпеку або правильність. Використовуйте на свій страх і ризик.

contract EmergencyStop {

    bool isStopped = false;

    modifier stoppedInEmergency {
        require(!isStopped);
        _;
    }

    modifier onlyWhenStopped {
        require(isStopped);
        _;
    }

    modifier onlyAuthorized {
        // Перевірка авторизації msg.sender тут
        _;
    }

    function stopContract() public onlyAuthorized {
        isStopped = true;
    }

    function resumeContract() public onlyAuthorized {
        isStopped = false;
    }

    function deposit() public payable stoppedInEmergency {
        // Логіка депозиту тут
    }

    function emergencyWithdraw() public onlyWhenStopped {
        // Аварійне зняття коштів тут
    }
}
```

Цей приклад показує основні риси аварійних зупинок:

- `isStopped` — це булева змінна, яка на початку має значення `false`, а коли контракт переходить в аварійний режим, — `true`.

- Модифікатори функцій `onlyWhenStopped` і `stoppedInEmergency` перевіряють змінну `isStopped`. `stoppedInEmergency` використовується для контролю функцій, які мають бути недоступними, коли контракт є вразливим (наприклад, `deposit()`). Виклики цих функцій буде просто скасовано.

`onlyWhenStopped` використовується для функцій, які можна викликати під час надзвичайної ситуації (наприклад, `emergencyWithdraw()`). Такі функції можуть допомогти вирішити ситуацію, тому їх виключають зі списку «обмежених функцій».

Використання функціональності аварійної зупинки забезпечує ефективний тимчасовий захід для боротьби із серйозними вразливостями у вашому смарт-контракті. Однак це підвищує потребу користувачів довіряти розробникам, що вони не активують її з корисливих міркувань. Для цього можливими рішеннями є децентралізація контролю над аварійною зупинкою шляхом підпорядкування її механізму голосування onchain, timelock або схвалення з гаманця з мультипідписом (multisig).

#### Моніторинг подій {#event-monitoring}

[Події](https://docs.soliditylang.org/en/v0.8.15/contracts.html#events) дозволяють відстежувати виклики функцій смарт-контракту та контролювати зміни змінних стану. В ідеалі запрограмувати свій смарт-контракт так, щоб він генерував подію щоразу, коли якась сторона виконує критично важливу для безпеки дію (наприклад, виведення коштів).

Реєстрація подій та їх моніторинг offchain дає уявлення про операції контракту та допомагає швидше виявляти зловмисні дії. Це означає, що ваша команда може швидше реагувати на зломи та вживати заходів для пом'якшення наслідків для користувачів, як-от призупинення функцій або виконання оновлення.

Ви також можете вибрати готовий інструмент моніторингу, який автоматично надсилає сповіщення, коли хтось взаємодіє з вашими контрактами. Ці інструменти дозволять вам створювати власні сповіщення на основі різних тригерів, таких як обсяг транзакцій, частота викликів функцій або залучені конкретні функції. Наприклад, ви можете запрограмувати сповіщення, яке надходитиме, коли сума, виведена в одній транзакції, перевищує певний поріг.

### 7. Проєктуйте безпечні системи управління {#design-secure-governance-systems}

Ви можете захотіти децентралізувати свій застосунок, передавши контроль над основними смарт-контрактами членам спільноти. У цьому випадку система смарт-контрактів включатиме модуль управління — механізм, який дозволяє членам спільноти схвалювати адміністративні дії через ончейн-систему управління. Наприклад, пропозиція оновити проксі-контракт до нової реалізації може бути винесена на голосування власників токенів.

Децентралізоване управління може бути корисним, особливо тому, що воно узгоджує інтереси розробників і кінцевих користувачів. Тим не менш, механізми управління смарт-контрактами можуть створювати нові ризики, якщо вони реалізовані неправильно. Імовірний сценарій — якщо зловмисник отримує величезну силу голосу (вимірюється кількістю утримуваних токенів), взявши [швидку позику](/defi/#flash-loans), і просуває зловмисну пропозицію.

Одним із способів запобігання проблемам, пов’язаним з ончейн-управлінням, є [використання тимчасового блокування](https://blog.openzeppelin.com/protect-your-users-with-smart-contract-timelocks/). Тимчасове блокування не дозволяє смарт-контракту виконувати певні дії, доки не мине певний проміжок часу. Інші стратегії включають присвоєння «ваги голосу» кожному токену на основі того, як довго він був заблокований, або вимірювання сили голосу адреси в історичний період (наприклад, 2-3 блоки в минулому), а не в поточному блоці. Обидва методи зменшують можливість швидкого накопичення сили голосу для впливу на результати ончейн-голосувань.

Більше про [проєктування безпечних систем управління](https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/), [різні механізми голосування в DAO](https://hackernoon.com/governance-is-the-holy-grail-for-daos) та [поширені вектори атак на DAO з використанням DeFi](https://dacian.me/dao-governance-defi-attacks) за наведеними посиланнями.

### 8. Зведіть складність коду до мінімуму {#reduce-code-complexity}

Традиційні розробники програмного забезпечення знайомі з принципом KISS («keep it simple, stupid» — «роби це простіше, дурню»), який радить уникати введення непотрібної складності в дизайн програмного забезпечення. Це випливає з давнього уявлення про те, що «складні системи дають збій у складний спосіб» і є більш схильними до дорогих помилок.

Збереження простоти має особливе значення при написанні смарт-контрактів, враховуючи, що смарт-контракти потенційно контролюють великі обсяги вартості. Порада для досягнення простоти при написанні смарт-контрактів — це повторне використання існуючих бібліотек, таких як [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/), де це можливо. Оскільки ці бібліотеки були ретельно перевірені та протестовані розробниками, їх використання зменшує шанси на введення помилок шляхом написання нової функціональності з нуля.

Інша поширена порада — писати невеликі функції та зберігати контракти модульними, розділяючи бізнес-логіку на кілька контрактів. Написання простішого коду не тільки зменшує поверхню атаки в смарт-контракті, але й полегшує міркування про правильність загальної системи та раннє виявлення можливих помилок проєктування.

### 9. Захист від поширених уразливостей смарт-контрактів {#mitigate-common-smart-contract-vulnerabilities}

#### Повторний вхід (Reentrancy) {#reentrancy}

EVM не допускає паралелізму, що означає, що два контракти, залучені до виклику повідомлення, не можуть виконуватися одночасно. Зовнішній виклик призупиняє виконання та пам’ять контракту, що викликає, доки виклик не повернеться, після чого виконання продовжується в звичайному режимі. Цей процес можна формально описати як передачу [потоку керування](https://www.computerhope.com/jargon/c/contflow.htm) іншому контракту.

Хоча здебільшого це нешкідливо, передача потоку керування недовіреним контрактам може спричинити проблеми, такі як повторний вхід. Атака повторного входу відбувається, коли зловмисний контракт викликає вразливий контракт до того, як завершиться початковий виклик функції. Цей тип атаки найкраще пояснити на прикладі.

Розглянемо простий смарт-контракт («Victim»), який дозволяє будь-кому вносити та знімати ефір:

```solidity
// Цей контракт вразливий. Не використовуйте в робочому середовищі

contract Victim {
    mapping (address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

Цей контракт надає функцію `withdraw()` для того, щоб користувачі могли знімати ETH, раніше внесені в контракт. Під час обробки зняття коштів контракт виконує такі операції:

1. Перевіряє баланс ETH користувача
2. Надсилає кошти на адресу, що викликає
3. Скидає їхній баланс до 0, запобігаючи додатковим зняттям коштів користувачем

Функція `withdraw()` у контракті `Victim` дотримується патерну «перевірки-взаємодії-ефекти». Він _перевіряє_, чи виконані умови, необхідні для виконання (тобто користувач має позитивний баланс ETH), і виконує _взаємодію_, надсилаючи ETH на адресу викликача, перш ніж застосовувати _ефекти_ транзакції (тобто зменшувати баланс користувача).

Якщо `withdraw()` викликається з облікового запису, що належить зовнішньому власнику (EOA), функція виконується, як очікувалося: `msg.sender.call.value()` надсилає ETH викликачу. Однак, якщо `msg.sender` — це обліковий запис смарт-контракту, що викликає `withdraw()`, надсилання коштів за допомогою `msg.sender.call.value()` також запустить код, що зберігається за цією адресою.

Уявіть, що це код, розгорнутий за адресою контракту:

```solidity
 contract Attacker {
    function beginAttack() external payable {
        Victim(victim_address).deposit.value(1 ether)();
        Victim(victim_address).withdraw();
    }

    function() external payable {
        if (gasleft() > 40000) {
            Victim(victim_address).withdraw();
        }
    }
}
```

Цей контракт призначений для виконання трьох дій:

1. Приймати депозит з іншого облікового запису (ймовірно, EOA зловмисника)
2. Вносити 1 ETH у контракт Victim
3. Знімати 1 ETH, що зберігається в смарт-контракті

Тут немає нічого поганого, за винятком того, що `Attacker` має іншу функцію, яка знову викликає `withdraw()` у `Victim`, якщо залишок газу від вхідного `msg.sender.call.value` перевищує 40 000. Це дає `Attacker` можливість повторно увійти в `Victim` і зняти більше коштів _до_ завершення першого виклику `withdraw`. Цикл виглядає так:

```solidity
- EOA зловмисника викликає `Attacker.beginAttack()` з 1 ETH
- `Attacker.beginAttack()` вносить 1 ETH у `Victim`
- `Attacker` викликає `withdraw()` в `Victim`
- `Victim` перевіряє баланс `Attacker` (1 ETH)
- `Victim` надсилає 1 ETH до `Attacker` (що запускає функцію за замовчуванням)
- `Attacker` знову викликає `Victim.withdraw()` (зверніть увагу, що `Victim` не зменшив баланс `Attacker` після першого зняття коштів)
- `Victim` перевіряє баланс `Attacker` (який все ще становить 1 ETH, оскільки він не застосував наслідки першого виклику)
- `Victim` надсилає 1 ETH до `Attacker` (що запускає функцію за замовчуванням і дозволяє `Attacker` повторно увійти до функції `withdraw`)
- Процес повторюється, доки у `Attacker` не закінчиться газ, після чого `msg.sender.call.value` повертається без запуску додаткових знять коштів
- `Victim` нарешті застосовує результати першої транзакції (і наступних) до свого стану, тому баланс `Attacker` встановлюється на 0
```

Підсумок полягає в тому, що оскільки баланс викликача не встановлюється на 0 до завершення виконання функції, наступні виклики будуть успішними і дозволять викликачу зняти свій баланс кілька разів. Цей вид атаки може бути використаний для викачування коштів зі смарт-контракту, як це сталося під час [зламу DAO у 2016 році](https://www.coindesk.com/learn/understanding-the-dao-attack). Атаки повторного входу все ще є критичною проблемою для смарт-контрактів сьогодні, як показують [публічні списки експлойтів повторного входу](https://github.com/pcaversaccio/reentrancy-attacks).

##### Як запобігти атакам повторного входу

Одним із підходів до боротьби з повторним входом є дотримання [патерну перевірки-ефекти-взаємодії](https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern). Цей патерн впорядковує виконання функцій таким чином, що код, який виконує необхідні перевірки перед продовженням виконання, йде першим, за ним іде код, який маніпулює станом контракту, а код, який взаємодіє з іншими контрактами або EOA, йде останнім.

Патерн перевірки-ефекти-взаємодії використовується в переглянутій версії контракту `Victim`, показаній нижче:

```solidity
contract NoLongerAVictim {
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
    }
}
```

Цей контракт виконує _перевірку_ балансу користувача, застосовує _ефекти_ функції `withdraw()` (скидаючи баланс користувача до 0), і переходить до виконання _взаємодії_ (надсилання ETH на адресу користувача). Це гарантує, що контракт оновлює своє сховище перед зовнішнім викликом, усуваючи умову повторного входу, яка уможливила першу атаку. Контракт `Attacker` все ще може викликати `NoLongerAVictim`, але оскільки `balances[msg.sender]` було встановлено на 0, додаткові зняття коштів спричинять помилку.

Інший варіант — використовувати блокування взаємного виключення (зазвичай описується як «м'ютекс»), яке блокує частину стану контракту до завершення виклику функції. Це реалізується за допомогою логічної змінної, яка встановлюється в `true` перед виконанням функції та повертається до `false` після завершення виклику. Як видно з прикладу нижче, використання м'ютекса захищає функцію від рекурсивних викликів, поки початковий виклик ще обробляється, ефективно зупиняючи повторний вхід.

```solidity
pragma solidity ^0.7.0;

contract MutexPattern {
    bool locked = false;
    mapping(address => uint256) public balances;

    modifier noReentrancy() {
        require(!locked, "Заблоковано від повторного входу.");
        locked = true;
        _;
        locked = false;
    }
    // Ця функція захищена м'ютексом, тому рекурсивні виклики з `msg.sender.call` не можуть знову викликати `withdraw`.
    //  Оператор `return` повертає `true`, але все ще виконує оператор `locked = false` у модифікаторі
    function withdraw(uint _amount) public payable noReentrancy returns(bool) {
        require(balances[msg.sender] >= _amount, "Немає балансу для зняття.");

        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success);

        return true;
    }
}
```

Ви також можете використовувати систему [pull-платежів](https://docs.openzeppelin.com/contracts/5.x/api/security#PullPayment), яка вимагає від користувачів знімати кошти зі смарт-контрактів, замість системи «push-платежів», яка надсилає кошти на облікові записи. Це усуває можливість ненавмисного запуску коду за невідомими адресами (і може також запобігти певним атакам типу «відмова в обслуговуванні»).

#### Цілочисельні недоповнення та переповнення {#integer-underflows-and-overflows}

Цілочисельне переповнення відбувається, коли результати арифметичної операції виходять за межі допустимого діапазону значень, змушуючи його «перекрутитися» до найменшого представленого значення. Наприклад, `uint8` може зберігати значення лише до 2^8-1=255. Арифметичні операції, що призводять до значень, вищих за `255`, переповняться і скинуть `uint` до `0`, подібно до того, як одометр на автомобілі скидається до 0, досягнувши максимального пробігу (999999).

Цілочисельні недоповнення відбуваються з подібних причин: результати арифметичної операції падають нижче допустимого діапазону. Скажімо, ви спробували зменшити `0` у `uint8`, результат просто перекрутився б до максимального представленого значення (`255`).

Як цілочисельні переповнення, так і недоповнення можуть призвести до несподіваних змін змінних стану контракту та призвести до незапланованого виконання. Нижче наведено приклад, що показує, як зловмисник може використати арифметичне переповнення в смарт-контракті для виконання недійсної операції:

```
pragma solidity ^0.7.6;

// Цей контракт призначений для роботи як сховище часу.
// Користувач може вносити кошти в цей контракт, але не може зняти їх принаймні протягом тижня.
// Користувач також може продовжити час очікування понад 1-тижневий період очікування.

/*
1. Розгорніть TimeLock
2. Розгорніть Attack з адресою TimeLock
3. Викличте Attack.attack, відправивши 1 ether. Ви зможете негайно
   зняти свій ефір.

Що сталося?
Атака спричинила переповнення TimeLock.lockTime, і зловмисник зміг зняти кошти
до закінчення 1-тижневого періоду очікування.
*/

contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "Недостатньо коштів");
        require(block.timestamp > lockTime[msg.sender], "Час блокування ще не минув");

        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Не вдалося надіслати Ether");
    }
}

contract Attack {
    TimeLock timeLock;

    constructor(TimeLock _timeLock) {
        timeLock = TimeLock(_timeLock);
    }

    fallback() external payable {}

    function attack() public payable {
        timeLock.deposit{value: msg.value}();
        /*
        якщо t = поточний час блокування, то нам потрібно знайти x, такий що
        x + t = 2**256 = 0
        отже x = -t
        2**256 = type(uint).max + 1
        отже x = type(uint).max + 1 - t
        */
        timeLock.increaseLockTime(
            type(uint).max + 1 - timeLock.lockTime(address(this))
        );
        timeLock.withdraw();
    }
}
```

##### Як запобігти цілочисельним недоповненням і переповненням

Починаючи з версії 0.8.0, компілятор Solidity відхиляє код, який призводить до цілочисельних недоповнень і переповнень. Однак контракти, скомпільовані за допомогою старішої версії компілятора, повинні або виконувати перевірки функцій, що включають арифметичні операції, або використовувати бібліотеку (наприклад, [SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math)), яка перевіряє на недоповнення/переповнення.

#### Маніпуляція оракулами {#oracle-manipulation}

[Оракули](/developers/docs/oracles/) отримують інформацію поза ланцюгом і надсилають її в ланцюг для використання смарт-контрактами. За допомогою оракулів ви можете створювати смарт-контракти, які взаємодіють із системами поза ланцюгом, такими як ринки капіталу, що значно розширює їх застосування.

Але якщо оракул пошкоджений і надсилає неправильну інформацію в ланцюг, смарт-контракти виконуватимуться на основі помилкових вхідних даних, що може спричинити проблеми. Це є основою «проблеми оракула», яка стосується завдання переконатися, що інформація від блокчейн-оракула є точною, актуальною та своєчасною.

Пов'язана проблема безпеки полягає у використанні ончейн-оракула, такого як децентралізована біржа, для отримання спотової ціни на актив. Платформи кредитування в галузі [децентралізованих фінансів (DeFi)](/defi/) часто роблять це для визначення вартості застави користувача, щоб визначити, скільки він може позичити.

Ціни DEX часто є точними, значною мірою завдяки арбітражерам, які відновлюють паритет на ринках. Однак вони відкриті для маніпуляцій, особливо якщо ончейн-оракул розраховує ціни на активи на основі історичних торгових патернів (як це зазвичай буває).

Наприклад, зловмисник може штучно підняти спотову ціну активу, взявши швидку позику безпосередньо перед взаємодією з вашим контрактом кредитування. Запит до DEX щодо ціни активу поверне вищу, ніж зазвичай, вартість (через великий «ордер на купівлю» зловмисника, що спотворює попит на актив), що дозволить їм позичити більше, ніж вони повинні. Такі «атаки зі швидкими позиками» використовувалися для експлуатації залежності від цінових оракулів серед застосунків DeFi, що коштувало протоколам мільйони втрачених коштів.

##### Як запобігти маніпуляціям оракулами

Мінімальною вимогою для [уникнення маніпуляцій оракулами](https://www.cyfrin.io/blog/price-oracle-manipultion-attacks-with-examples) є використання децентралізованої мережі оракулів, яка запитує інформацію з кількох джерел, щоб уникнути єдиних точок відмови. У більшості випадків децентралізовані оракули мають вбудовані криптоекономічні стимули, щоб заохочувати вузли оракулів повідомляти правильну інформацію, що робить їх більш безпечними, ніж централізовані оракули.

Якщо ви плануєте запитувати ончейн-оракул щодо цін на активи, розгляньте можливість використання такого, що реалізує механізм середньозваженої за часом ціни (TWAP). [Оракул TWAP](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) запитує ціну активу в два різні моменти часу (які ви можете змінити) і розраховує спотову ціну на основі отриманого середнього значення. Вибір довших періодів часу захищає ваш протокол від маніпуляцій цінами, оскільки великі ордери, виконані нещодавно, не можуть вплинути на ціни активів.

## Ресурси з безпеки смарт-контрактів для розробників {#smart-contract-security-resources-for-developers}

### Інструменти для аналізу смарт-контрактів і перевірки правильності коду {#code-analysis-tools}

- **[Інструменти та бібліотеки для тестування](/developers/docs/smart-contracts/testing/#testing-tools-and-libraries)** - _Збірка стандартних інструментів і бібліотек для виконання модульних тестів, статичного та динамічного аналізу смарт-контрактів._

- **[Інструменти формальної верифікації](/developers/docs/smart-contracts/formal-verification/#formal-verification-tools)** - _Інструменти для перевірки функціональної правильності в смарт-контрактах і перевірки інваріантів._

- **[Послуги з аудиту смарт-контрактів](/developers/docs/smart-contracts/testing/#smart-contract-auditing-services)** - _Список організацій, що надають послуги з аудиту смарт-контрактів для проєктів розробки Ethereum._

- **[Платформи баг-баунті](/developers/docs/smart-contracts/testing/#bug-bounty-platforms)** - _Платформи для координації програм винагород за помилки та винагороди за відповідальне розкриття критичних уразливостей у смарт-контрактах._

- **[Fork Checker](https://forkchecker.hashex.org/)** - _Безкоштовний онлайн-інструмент для перевірки всієї доступної інформації щодо форкнутого контракту._

- **[ABI Encoder](https://abi.hashex.org/)** - _Безкоштовний онлайн-сервіс для кодування функцій вашого контракту Solidity та аргументів конструктора._

- **[Aderyn](https://github.com/Cyfrin/aderyn)** - _Статичний аналізатор Solidity, що обходить абстрактні синтаксичні дерева (AST) для виявлення підозрілих вразливостей і виведення проблем у легкому для сприйняття форматі markdown._

### Інструменти для моніторингу смарт-контрактів {#smart-contract-monitoring-tools}

- **[Tenderly Real-Time Alerting](https://tenderly.co/monitoring)** - _Інструмент для отримання сповіщень у реальному часі, коли на ваших смарт-контрактах або гаманцях відбуваються незвичайні або несподівані події._

### Інструменти для безпечного адміністрування смарт-контрактів {#smart-contract-administration-tools}

- **[Safe](https://safe.global/)** - _Гаманець на базі смарт-контракту, що працює на Ethereum і вимагає, щоб мінімальна кількість людей схвалила транзакцію, перш ніж вона відбудеться (M з N)._

- **[OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/)** - _Бібліотеки контрактів для реалізації адміністративних функцій, включаючи володіння контрактом, оновлення, контроль доступу, управління, можливість призупинення тощо._

### Послуги з аудиту смарт-контрактів {#smart-contract-auditing-services}

- **[ConsenSys Diligence](https://diligence.consensys.io/)** - _Сервіс аудиту смарт-контрактів, що допомагає проєктам у всій блокчейн-екосистемі переконатися, що їхні протоколи готові до запуску та створені для захисту користувачів._

- **[CertiK](https://www.certik.com/)** - _Фірма з безпеки блокчейну, що є піонером у використанні передових технологій формальної верифікації для смарт-контрактів і блокчейн-мереж._

- **[Trail of Bits](https://www.trailofbits.com/)** - _Компанія з кібербезпеки, яка поєднує дослідження безпеки з мисленням зловмисника для зменшення ризиків і зміцнення коду._

- **[PeckShield](https://peckshield.com/)** - _Компанія з безпеки блокчейну, що пропонує продукти та послуги для безпеки, конфіденційності та зручності використання всієї екосистеми блокчейну._

- **[QuantStamp](https://quantstamp.com/)** - _Сервіс аудиту, що сприяє масовому впровадженню технології блокчейн через послуги з оцінки безпеки та ризиків._

- **[OpenZeppelin](https://www.openzeppelin.com/security-audits)** - _Компанія з безпеки смарт-контрактів, що надає аудити безпеки для розподілених систем._

- **[Runtime Verification](https://runtimeverification.com/)** - _Компанія з безпеки, що спеціалізується на формальному моделюванні та верифікації смарт-контрактів._

- **[Hacken](https://hacken.io)** - _Аудитор кібербезпеки Web3, що пропонує 360-градусний підхід до безпеки блокчейну._

- **[Nethermind](https://www.nethermind.io/smart-contract-audits)** - _Послуги аудиту Solidity та Cairo, що забезпечують цілісність смарт-контрактів та безпеку користувачів на Ethereum та Starknet._

- **[HashEx](https://hashex.org/)** - _HashEx зосереджується на аудиті блокчейну та смарт-контрактів для забезпечення безпеки криптовалют, надаючи такі послуги, як розробка смарт-контрактів, тестування на проникнення, консалтинг у сфері блокчейну._

- **[Code4rena](https://code4rena.com/)** - _Конкурентна платформа для аудитів, яка стимулює експертів з безпеки смарт-контрактів знаходити вразливості та допомагає зробити web3 більш безпечним._

- **[CodeHawks](https://codehawks.com/)** - _Платформа для конкурентних аудитів, що проводить змагання з аудиту смарт-контрактів для дослідників безпеки._

- **[Cyfrin](https://cyfrin.io)** - _Лідер у сфері безпеки Web3, що розвиває криптобезпеку через продукти та послуги з аудиту смарт-контрактів._

- **[ImmuneBytes](https://immunebytes.com/smart-contract-audit/)** - _Фірма з безпеки Web3, що пропонує аудити безпеки для блокчейн-систем за допомогою команди досвідчених аудиторів та найкращих інструментів._

- **[Oxorio](https://oxor.io/)** - _Аудити смарт-контрактів та послуги з безпеки блокчейну з експертизою в EVM, Solidity, ZK, крос-чейн технологіях для криптофірм та проєктів DeFi._

- **[Inference](https://inference.ag/)** - _Компанія з аудиту безпеки, що спеціалізується на аудиті смарт-контрактів для блокчейнів на базі EVM. Завдяки своїм експертним аудиторам вони виявляють потенційні проблеми та пропонують дієві рішення для їх усунення перед розгортанням._

### Платформи баг-баунті {#bug-bounty-platforms}

- **[Immunefi](https://immunefi.com/)** - _Платформа баг-баунті для смарт-контрактів і проєктів DeFi, де дослідники безпеки перевіряють код, розкривають уразливості, отримують винагороду та роблять криптосвіт безпечнішим._

- **[HackerOne](https://www.hackerone.com/)** - _Платформа для координації вразливостей і баг-баунті, що з'єднує бізнеси з пентестерами та дослідниками кібербезпеки._

- **[HackenProof](https://hackenproof.com/)** - _Експертна платформа баг-баунті для криптопроєктів (DeFi, смарт-контракти, гаманці, CEX та інше), де фахівці з безпеки надають послуги тріажу, а дослідники отримують винагороду за релевантні, перевірені звіти про помилки._

- **[Sherlock](https://www.sherlock.xyz/)** - _Андеррайтер у Web3 для безпеки смарт-контрактів, з виплатами для аудиторів, що керуються через смарт-контракти, щоб забезпечити справедливу оплату за відповідні помилки._

- **[CodeHawks](https://www.codehawks.com/)** - _Конкурентна платформа баг-баунті, де аудитори беруть участь у конкурсах та змаганнях з безпеки, а (незабаром) і у власних приватних аудитах._

### Публікації відомих уразливостей та експлойтів смарт-контрактів {#common-smart-contract-vulnerabilities-and-exploits}

- **[ConsenSys: відомі атаки на смарт-контракти](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/)** - _Зрозуміле для початківців пояснення найзначніших уразливостей контрактів, з прикладами коду для більшості випадків._

- **[Реєстр SWC](https://swcregistry.io/)** - _Курований список елементів Common Weakness Enumeration (CWE), які застосовуються до смарт-контрактів Ethereum._

- **[Rekt](https://rekt.news/)** - _Регулярно оновлювана публікація про гучні криптозлами та експлойти, разом із детальними звітами після інцидентів._

### Завдання для вивчення безпеки смарт-контрактів {#challenges-for-learning-smart-contract-security}

- **[Awesome BlockSec CTF](https://github.com/blockthreat/blocksec-ctfs)** - _Курований список воєнних ігор з безпеки блокчейну, завдань та змагань [Capture The Flag](https://www.webopedia.com/definitions/ctf-event/amp/) та описів рішень._

- **[Damn Vulnerable DeFi](https://www.damnvulnerabledefi.xyz/)** - _Воєнна гра для вивчення наступальної безпеки смарт-контрактів DeFi та розвитку навичок полювання на помилки та аудиту безпеки._

- **[Ethernaut](https://ethernaut.openzeppelin.com/)** - _Воєнна гра на базі Web3/Solidity, де кожен рівень — це смарт-контракт, який потрібно «зламати»._

- **[HackenProof x HackTheBox](https://app.hackthebox.com/tracks/HackenProof-Track)** - _Завдання зі зламу смарт-контрактів у стилі фентезійної пригоди. Успішне завершення завдання також дає доступ до приватної програми баг-баунті._

### Найкращі практики для захисту смарт-контрактів {#smart-contract-security-best-practices}

- **[ConsenSys: Найкращі практики безпеки смарт-контрактів Ethereum](https://consensys.github.io/smart-contract-best-practices/)** - _Вичерпний список рекомендацій щодо захисту смарт-контрактів Ethereum._

- **[Nascent: Простий набір інструментів безпеки](https://github.com/nascentxyz/simple-security-toolkit)** - _Збірка практичних посібників та контрольних списків, орієнтованих на безпеку, для розробки смарт-контрактів._

- **[Патерни Solidity](https://fravoll.github.io/solidity-patterns/)** - _Корисна компіляція безпечних патернів та найкращих практик для мови програмування смарт-контрактів Solidity._

- **[Документація Solidity: Аспекти безпеки](https://docs.soliditylang.org/en/v0.8.16/security-considerations.html)** - _Рекомендації щодо написання безпечних смарт-контрактів на Solidity._

- **[Стандарт верифікації безпеки смарт-контрактів](https://github.com/securing/SCSVS)** - _Контрольний список із чотирнадцяти частин, створений для стандартизації безпеки смарт-контрактів для розробників, архітекторів, рецензентів безпеки та постачальників._

- **[Вивчення безпеки та аудиту смарт-контрактів](https://updraft.cyfrin.io/courses/security)** - _Повний курс з безпеки та аудиту смарт-контрактів, створений для розробників смарт-контрактів, які хочуть підвищити свої знання про найкращі практики безпеки та стати дослідниками безпеки._

### Посібники з безпеки смарт-контрактів {#tutorials-on-smart-contract-security}

- [Як писати безпечні смарт-контракти](/developers/tutorials/secure-development-workflow/)

- [Як використовувати Slither для пошуку помилок у смарт-контрактах](/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/)

- [Як використовувати Manticore для пошуку помилок у смарт-контрактах](/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/)

- [Рекомендації з безпеки смарт-контрактів](/developers/tutorials/smart-contract-security-guidelines/)

- [Як безпечно інтегрувати ваш контракт токенів з довільними токенами](/developers/tutorials/token-integration-checklist/)

- [Cyfrin Updraft - Повний курс з безпеки та аудиту смарт-контрактів](https://updraft.cyfrin.io/courses/security)
