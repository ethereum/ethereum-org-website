---
title: "Uniswap-v2 कराराचे अवलोकन"
description: "Uniswap-v2 करार कसा काम करतो? ते त्या प्रकारे का लिहिले आहे?"
author: Ori Pomerantz
tags: [ "सॉलिडिटी" ]
skill: intermediate
published: 2021-05-01
lang: mr
---

## प्रस्तावना {#introduction}

[Uniswap v2](https://app.uniswap.org/whitepaper.pdf) कोणत्याही दोन ERC-20 टोकन्समध्ये विनिमय बाजार तयार करू शकते. या लेखात आपण या प्रोटोकॉलची अंमलबजावणी करणाऱ्या करारांसाठी स्रोत कोड पाहू आणि ते या प्रकारे का लिहिले आहेत हे पाहू.

### Uniswap काय करते? {#what-does-uniswap-do}

मूलतः, वापरकर्त्यांचे दोन प्रकार आहेत: लिक्विडिटी प्रोव्हायडर आणि व्यापारी.

_लिक्विडिटी प्रोव्हायडर_ पूलला दोन टोकन्स प्रदान करतात ज्यांचा विनिमय केला जाऊ शकतो (आपण त्यांना **टोकन0** आणि **टोकन1** म्हणू). त्या बदल्यात, त्यांना तिसरे टोकन मिळते जे पूलच्या आंशिक मालकीचे प्रतिनिधित्व करते, ज्याला _लिक्विडिटी टोकन_ म्हणतात.

_व्यापारी_ पूलमध्ये एका प्रकारचे टोकन पाठवतात आणि दुसरे टोकन (उदाहरणार्थ, **टोकन0** पाठवून **टोकन1** प्राप्त करणे) लिक्विडिटी प्रोव्हायडरद्वारे प्रदान केलेल्या पूलमधून प्राप्त करतात. पूलमध्ये असलेल्या **टोकन0** आणि **टोकन1** च्या सापेक्ष संख्येनुसार विनिमय दर निर्धारित केला जातो. याव्यतिरिक्त, पूल लिक्विडिटी पूलसाठी बक्षीस म्हणून लहान टक्केवारी घेते.

जेव्हा लिक्विडिटी प्रोव्हायडरना त्यांची मालमत्ता परत हवी असते, तेव्हा ते पूल टोकन्स बर्न करू शकतात आणि बक्षिसांमधील त्यांच्या वाट्यासह त्यांचे टोकन्स परत मिळवू शकतात.

[अधिक वर्णनासाठी येथे क्लिक करा](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/swaps/).

### v2 का? v3 का नाही? {#why-v2}

[Uniswap v3](https://app.uniswap.org/whitepaper-v3.pdf) हे एक अपग्रेड आहे जे v2 पेक्षा खूपच गुंतागुंतीचे आहे. आधी v2 शिकणे आणि नंतर v3 कडे जाणे सोपे आहे.

### मुख्य करार विरुद्ध परिघ करार {#contract-types}

Uniswap v2 दोन घटकांमध्ये विभागलेले आहे, एक मुख्य आणि एक परिघ. हे विभाजन मुख्य करारांना, जे मालमत्ता ठेवतात आणि त्यामुळे _सुरक्षित_ असणे आवश्यक आहे, सोपे आणि ऑडिट करण्यास सोपे बनवते. व्यापाऱ्यांसाठी आवश्यक असलेली सर्व अतिरिक्त कार्यक्षमता नंतर परिघ करारांद्वारे प्रदान केली जाऊ शकते.

## डेटा आणि नियंत्रण प्रवाह {#flows}

जेव्हा तुम्ही Uniswap च्या तीन मुख्य क्रिया करता तेव्हा हा डेटा आणि नियंत्रणाचा प्रवाह आहे:

1. वेगवेगळ्या टोकन्समध्ये स्वॅप करा
2. मार्केटमध्ये लिक्विडिटी जोडा आणि पेअर एक्सचेंज ERC-20 लिक्विडिटी टोकन्ससह बक्षीस मिळवा
3. ERC-20 लिक्विडिटी टोकन्स बर्न करा आणि पेअर एक्सचेंज व्यापाऱ्यांना विनिमय करण्याची परवानगी देणारे ERC-20 टोकन्स परत मिळवा

### स्वॅप {#swap-flow}

हा सर्वात सामान्य प्रवाह आहे, जो व्यापाऱ्यांद्वारे वापरला जातो:

#### कॉलर {#caller}

1. स्वॅप करायच्या रकमेसाठी परिघ खात्याला अनुमती द्या.
2. परिघ कराराच्या अनेक स्वॅप फंक्शन्सपैकी एक कॉल करा (कोणते फंक्शन वापरायचे हे ETH सामील आहे की नाही, व्यापारी जमा करायच्या टोकन्सची रक्कम किंवा परत मिळवायच्या टोकन्सची रक्कम निर्दिष्ट करतो का, इत्यादीवर अवलंबून असते).
   प्रत्येक स्वॅप फंक्शन एक `path` स्वीकारतो, जो एक एक्सचेंजेसचा अॅरे आहे ज्यातून जायचे आहे.

#### परिघ करारामध्ये (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02-sol}

3. मार्गावरील प्रत्येक एक्सचेंजवर व्यापार करण्याची आवश्यकता असलेल्या रकमेची ओळख करा.
4. मार्गावर पुनरावृत्ती करते. मार्गावरील प्रत्येक एक्सचेंजसाठी ते इनपुट टोकन पाठवते आणि नंतर एक्सचेंजच्या `swap` फंक्शनला कॉल करते.
   बहुतेक प्रकरणांमध्ये टोकन्ससाठी गंतव्य पत्ता मार्गावरील पुढील पेअर एक्सचेंज असतो. अंतिम एक्सचेंजमध्ये तो व्यापाऱ्याने प्रदान केलेला पत्ता असतो.

#### मुख्य करारामध्ये (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

5. मुख्य कराराची फसवणूक होत नाही आणि स्वॅपनंतर पुरेशी लिक्विडिटी राखू शकते याची पडताळणी करा.
6. ज्ञात रिझर्व्ह्स व्यतिरिक्त आमच्याकडे किती अतिरिक्त टोकन्स आहेत ते पहा. ती रक्कम म्हणजे आम्हाला विनिमय करण्यासाठी मिळालेल्या इनपुट टोकन्सची संख्या.
7. आउटपुट टोकन्स गंतव्यस्थानावर पाठवा.
8. रिझर्व्ह रक्कम अपडेट करण्यासाठी `_update` ला कॉल करा

#### परिघ करारामध्ये परत (UniswapV2Router02.sol) {#back-in-the-periphery-contract-uniswapv2router02-sol}

9. आवश्यक स्वच्छता करा (उदाहरणार्थ, व्यापाऱ्याला पाठवण्यासाठी ETH परत मिळवण्यासाठी WETH टोकन्स बर्न करा)

### लिक्विडिटी जोडा {#add-liquidity-flow}

#### कॉलर {#caller-2}

1. लिक्विडिटी पूलमध्ये जोडल्या जाणाऱ्या रकमेसाठी परिघ खात्याला अनुमती द्या.
2. परिघ कराराच्या `addLiquidity` फंक्शन्सपैकी एक कॉल करा.

#### परिघ करारामध्ये (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-2}

3. आवश्यक असल्यास नवीन पेअर एक्सचेंज तयार करा
4. जर अस्तित्वात असलेला पेअर एक्सचेंज असेल, तर जोडण्यासाठी टोकन्सची रक्कम मोजा. हे दोन्ही टोकन्ससाठी समान मूल्य मानले जाते, म्हणून नवीन टोकन्स आणि अस्तित्वातील टोकन्सचे प्रमाण समान असते.
5. रक्कम स्वीकारार्ह आहे की नाही ते तपासा (कॉलर किमान रक्कम निर्दिष्ट करू शकतात ज्याच्या खाली ते लिक्विडिटी जोडू इच्छित नाहीत)
6. मुख्य कराराला कॉल करा.

#### मुख्य करारामध्ये (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

7. लिक्विडिटी टोकन्स मिंट करा आणि ते कॉलरला पाठवा
8. रिझर्व्ह रक्कम अपडेट करण्यासाठी `_update` ला कॉल करा

### लिक्विडिटी काढा {#remove-liquidity-flow}

#### कॉलर {#caller-3}

1. अंतर्निहित टोकन्सच्या बदल्यात बर्न करण्यासाठी लिक्विडिटी टोकन्सची अनुमती परिघ खात्याला द्या.
2. परिघ कराराच्या `removeLiquidity` फंक्शन्सपैकी एक कॉल करा.

#### परिघ करारामध्ये (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-3}

3. लिक्विडिटी टोकन्स पेअर एक्सचेंजला पाठवा

#### मुख्य करारामध्ये (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-3}

4. बर्न केलेल्या टोकन्सच्या प्रमाणात गंतव्य पत्त्यावर अंतर्निहित टोकन्स पाठवा. उदाहरणार्थ, जर पूलमध्ये 1000 A टोकन्स, 500 B टोकन्स, आणि 90 लिक्विडिटी टोकन्स असतील, आणि आम्हाला बर्न करण्यासाठी 9 टोकन्स मिळाले, तर आम्ही 10% लिक्विडिटी टोकन्स बर्न करत आहोत, म्हणून आम्ही वापरकर्त्याला 100 A टोकन्स आणि 50 B टोकन्स परत पाठवतो.
5. लिक्विडिटी टोकन्स बर्न करा
6. रिझर्व्ह रक्कम अपडेट करण्यासाठी `_update` ला कॉल करा

## मुख्य करार {#core-contracts}

हे सुरक्षित करार आहेत जे लिक्विडिटी ठेवतात.

### UniswapV2Pair.sol {#UniswapV2Pair}

[हा करार](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol) प्रत्यक्ष पूलची अंमलबजावणी करतो जो टोकन्सचा विनिमय करतो. ही मुख्य Uniswap कार्यक्षमता आहे.

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';
```

हे सर्व इंटरफेस आहेत ज्यांबद्दल कराराला माहित असणे आवश्यक आहे, एकतर कारण करार त्यांची अंमलबजावणी करतो (`IUniswapV2Pair` आणि `UniswapV2ERC20`) किंवा कारण तो त्यांची अंमलबजावणी करणाऱ्या करारांना कॉल करतो.

```solidity
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
```

हा करार `UniswapV2ERC20` पासून वारसा घेतो, जो लिक्विडिटी टोकन्ससाठी ERC-20 फंक्शन्स प्रदान करतो.

```solidity
    using SafeMath  for uint;
```

[SafeMath लायब्ररी](https://docs.openzeppelin.com/contracts/2.x/api/math) ओव्हरफ्लो आणि अंडरफ्लो टाळण्यासाठी वापरली जाते. हे महत्त्वाचे आहे कारण अन्यथा आपण अशा परिस्थितीत येऊ शकतो जिथे मूल्य `-1` असले पाहिजे, परंतु त्याऐवजी `2^256-1` असेल.

```solidity
    using UQ112x112 for uint224;
```

पूल करारामध्ये अनेक गणितांसाठी अपूर्णांकांची आवश्यकता असते. तथापि, EVM द्वारे अपूर्णांक समर्थित नाहीत.
Uniswap ने शोधलेला उपाय म्हणजे 224 बिट मूल्यांचा वापर करणे, ज्यामध्ये पूर्णांक भागासाठी 112 बिट्स आणि अपूर्णांकासाठी 112 बिट्स असतात. म्हणून `1.0` हे `2^112` म्हणून दर्शविले जाते, `1.5` हे `2^112 + 2^111` म्हणून दर्शविले जाते, इत्यादी.

या लायब्ररीबद्दल अधिक तपशील [दस्तऐवजात नंतर](#FixedPoint) उपलब्ध आहेत.

#### व्हेरिअबल्स {#pair-vars}

```solidity
    uint public constant MINIMUM_LIQUIDITY = 10**3;
```

शून्याने भागाकार टाळण्यासाठी, लिक्विडिटी टोकन्सची किमान संख्या नेहमी अस्तित्वात असते (परंतु ती शून्य खात्याच्या मालकीची असते). ती संख्या **MINIMUM_LIQUIDITY** आहे, एक हजार.

```solidity
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
```

हा ERC-20 ट्रान्सफर फंक्शनसाठी ABI सिलेक्टर आहे. हे दोन टोकन खात्यांमध्ये ERC-20 टोकन्स हस्तांतरित करण्यासाठी वापरले जाते.

```solidity
    address public factory;
```

हा फॅक्टरी करार आहे ज्याने हा पूल तयार केला. प्रत्येक पूल दोन ERC-20 टोकन्समध्ये एक एक्सचेंज आहे, फॅक्टरी एक केंद्रीय बिंदू आहे जो या सर्व पूलांना जोडतो.

```solidity
    address public token0;
    address public token1;
```

हे त्या दोन प्रकारच्या ERC-20 टोकन्सच्या करारांचे पत्ते आहेत ज्यांचा या पूलमार्फत विनिमय केला जाऊ शकतो.

```solidity
    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
```

प्रत्येक टोकन प्रकारासाठी पूलमध्ये असलेला राखीव साठा. आपण असे गृहीत धरतो की दोन्ही समान मूल्याचे प्रतिनिधित्व करतात, आणि म्हणून प्रत्येक token0 चे मूल्य reserve1/reserve0 token1 इतके आहे.

```solidity
    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves
```

शेवटच्या ब्लॉकसाठी टाइमस्टॅम्प ज्यामध्ये विनिमय झाला होता, जो वेळेनुसार विनिमय दरांचा मागोवा घेण्यासाठी वापरला जातो.

Ethereum करारांचा सर्वात मोठा गॅस खर्च म्हणजे स्टोरेज, जो कराराच्या एका कॉलपासून दुसऱ्या कॉलपर्यंत कायम राहतो. प्रत्येक स्टोरेज सेल 256 बिट्स लांब असतो. म्हणून तीन व्हेरिएबल्स, `reserve0`, `reserve1`, आणि `blockTimestampLast`, अशा प्रकारे वाटप केले जातात की एकाच स्टोरेज मूल्यामध्ये हे तिन्ही समाविष्ट होऊ शकतात (112+112+32=256).

```solidity
    uint public price0CumulativeLast;
    uint public price1CumulativeLast;
```

हे व्हेरिएबल्स प्रत्येक टोकनसाठी (प्रत्येकी दुसऱ्याच्या संदर्भात) एकत्रित खर्च ठेवतात. ते एका विशिष्ट कालावधीसाठी सरासरी विनिमय दर मोजण्यासाठी वापरले जाऊ शकतात.

```solidity
    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
```

पेअर एक्सचेंज token0 आणि token1 मधील विनिमय दराचा निर्णय घेण्याचा मार्ग म्हणजे व्यापारादरम्यान दोन राखीव साठ्यांचा गुणाकार स्थिर ठेवणे. `kLast` हे हे मूल्य आहे. जेव्हा एखादा लिक्विडिटी प्रोव्हायडर टोकन्स जमा करतो किंवा काढतो तेव्हा ते बदलते आणि 0.3% बाजार शुल्कामुळे ते किंचित वाढते.

येथे एक सोपे उदाहरण आहे. लक्षात घ्या की साधेपणासाठी सारणीमध्ये दशांश बिंदूनंतर फक्त तीन अंक आहेत आणि आम्ही 0.3% व्यापार शुल्क दुर्लक्षित करतो त्यामुळे संख्या अचूक नाहीत.

| इव्हेंट                                                                |                  reserve0 |                  reserve1 | reserve0 \* reserve1 | सरासरी विनिमय दर (टोकन1 / टोकन0) |
| ---------------------------------------------------------------------- | ------------------------: | ------------------------: | -------------------: | --------------------------------------------------- |
| प्राथमिक सेटअप                                                         | 1,000.000 | 1,000.000 |            1,000,000 |                                                     |
| व्यापारी A ने 50 token0 साठी 47.619 token1 स्वॅप केले  | 1,050.000 |   952.381 |            1,000,000 | 0.952                               |
| व्यापारी B ने 10 token0 साठी 8.984 token1 स्वॅप केले   | 1,060.000 |   943.396 |            1,000,000 | 0.898                               |
| व्यापारी C ने 40 token0 साठी 34.305 token1 स्वॅप केले  | 1,100.000 |   909.090 |            1,000,000 | 0.858                               |
| व्यापारी D ने 100 token1 साठी 109.01 token0 स्वॅप केले |   990.990 | 1,009.090 |            1,000,000 | 0.917                               |
| व्यापारी E ने 10 token0 साठी 10.079 token1 स्वॅप केले  | 1,000.990 |   999.010 |            1,000,000 | 1.008                               |

व्यापारी जसजसे अधिक token0 प्रदान करतात, तसतसे token1 चे सापेक्ष मूल्य वाढते आणि उलट, पुरवठा आणि मागणीवर आधारित.

#### लॉक {#pair-lock}

```solidity
    uint private unlocked = 1;
```

सुरक्षा भेद्यतांचा एक वर्ग आहे जो [पुनर्प्रवेश गैरवापरा](https://medium.com/coinmonks/ethernaut-lvl-10-re-entrancy-walkthrough-how-to-abuse-execution-ordering-and-reproduce-the-dao-7ec88b912c14) वर आधारित आहे. Uniswap ला अनियंत्रित ERC-20 टोकन हस्तांतरित करणे आवश्यक आहे, याचा अर्थ ERC-20 करारांना कॉल करणे जे त्यांना कॉल करणाऱ्या Uniswap बाजाराचा गैरवापर करण्याचा प्रयत्न करू शकतात.
कराराचा भाग म्हणून `unlocked` व्हेरिएबल असल्यामुळे, आपण फंक्शन्स चालू असताना (एकाच व्यवहारात) त्यांना कॉल करण्यापासून रोखू शकतो.

```solidity
    modifier lock() {
```

हे फंक्शन एक [मॉडिफायर](https://docs.soliditylang.org/en/v0.8.3/contracts.html#function-modifiers) आहे, एक फंक्शन जे सामान्य फंक्शनभोवती गुंडाळते आणि त्याचे वर्तन काही प्रकारे बदलते.

```solidity
        require(unlocked == 1, 'UniswapV2: LOCKED');
        unlocked = 0;
```

जर `unlocked` एकच्या बरोबर असेल, तर ते शून्यावर सेट करा. जर ते आधीच शून्य असेल तर कॉल रिव्हर्ट करा, ते अयशस्वी करा.

```solidity
        _;
```

एका मॉडिफायरमध्ये `_;` हे मूळ फंक्शन कॉल आहे (सर्व पॅरामीटर्ससह). येथे याचा अर्थ असा आहे की फंक्शन कॉल तेव्हाच होतो जेव्हा `unlocked` चे मूल्य एक होते, आणि ते चालू असताना `unlocked` चे मूल्य शून्य असते.

```solidity
        unlocked = 1;
    }
```

मुख्य फंक्शन परत आल्यानंतर, लॉक सोडा.

#### विविध फंक्शन्स {#pair-misc}

```solidity
    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }
```

हे फंक्शन कॉल करणाऱ्यांना एक्सचेंजच्या सध्याच्या स्थितीबद्दल माहिती देते. लक्षात घ्या की सॉलिडिटी फंक्शन्स [एकाधिक मूल्ये परत करू शकतात](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values).

```solidity
    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
```

हे इंटर्नल फंक्शन एक्सचेंजमधून ERC20 टोकन्सची ठराविक रक्कम दुसऱ्या कोणालातरी हस्तांतरित करते. `SELECTOR` हे निर्दिष्ट करते की आपण ज्या फंक्शनला कॉल करत आहोत ते `transfer(address,uint)` आहे (वरील व्याख्या पहा).

टोकन फंक्शनसाठी इंटरफेस इम्पोर्ट करणे टाळण्यासाठी, आम्ही [ABI फंक्शन्स](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions) पैकी एक वापरून "मॅन्युअली" कॉल तयार करतो.

```solidity
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }
```

ERC-20 ट्रान्सफर कॉल अयशस्वी झाल्याची तक्रार करण्याचे दोन मार्ग आहेत:

1. रिव्हर्ट. जर बाह्य कॉन्ट्रॅक्टचा कॉल रिव्हर्ट झाल्यास, तर बुलियन रिटर्न व्हॅल्यू `false` असते
2. सामान्यपणे समाप्त होते परंतु अपयशाची तक्रार करते. त्या बाबतीत रिटर्न व्हॅल्यू बफरची लांबी शून्य नसते, आणि जेव्हा बुलियन व्हॅल्यू म्हणून डीकोड केले जाते, तेव्हा ते `false` असते

यापैकी कोणतीही अट घडल्यास, रिव्हर्ट करा.

#### इव्हेंट्स {#pair-events}

```solidity
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
```

हे दोन इव्हेंट्स तेव्हा उत्सर्जित होतात जेव्हा लिक्विडिटी प्रोव्हायडर एकतर लिक्विडिटी जमा करतो (`Mint`) किंवा काढतो (`Burn`). दोन्ही बाबतीत, जमा केलेल्या किंवा काढलेल्या token0 आणि token1 ची रक्कम इव्हेंटचा भाग आहे, तसेच आम्हाला कॉल करणाऱ्या खात्याची ओळख (`sender`) देखील आहे. विथड्रॉवलच्या बाबतीत, इव्हेंटमध्ये टोकन प्राप्त करणारे लक्ष्य (`to`) देखील समाविष्ट असते, जे प्रेषकासारखे (`sender`) नसू शकते.

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

जेव्हा एखादा व्यापारी एका टोकनसाठी दुसऱ्या टोकनची देवाणघेवाण करतो तेव्हा हा इव्हेंट उत्सर्जित होतो. पुन्हा, प्रेषक आणि गंतव्यस्थान समान नसू शकतात.
प्रत्येक टोकन एकतर एक्सचेंजला पाठवला जाऊ शकतो, किंवा तिथून प्राप्त केला जाऊ शकतो.

```solidity
    event Sync(uint112 reserve0, uint112 reserve1);
```

शेवटी, `Sync` प्रत्येक वेळी टोकन्स जोडले किंवा काढले जातात, कारणाकडे दुर्लक्ष करून, नवीनतम राखीव माहिती (आणि म्हणून विनिमय दर) प्रदान करण्यासाठी उत्सर्जित होतो.

#### सेटअप फंक्शन्स {#pair-setup}

नवीन पेअर एक्सचेंज सेट अप केल्यावर हे फंक्शन्स एकदा कॉल केले जाणे अपेक्षित आहे.

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

कन्स्ट्रक्टर हे सुनिश्चित करतो की आम्ही पेअर तयार करणाऱ्या फॅक्टरीच्या ॲड्रेसचा मागोवा ठेवू. ही माहिती `initialize` साठी आणि फॅक्टरी फीसाठी (असल्यास) आवश्यक आहे.

```solidity
    // डिप्लॉयमेंटच्या वेळी फॅक्टरीद्वारे एकदा कॉल केले जाते
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // पुरेसे तपासणी
        token0 = _token0;
        token1 = _token1;
    }
```

हे फंक्शन फॅक्टरीला (आणि फक्त फॅक्टरीला) दोन ERC-20 टोकन्स निर्दिष्ट करण्याची परवानगी देते ज्यांची हे पेअर देवाणघेवाण करेल.

#### इंटर्नल अपडेट फंक्शन्स {#pair-update-internal}

##### \_update

```solidity
    // रिझर्व्हस् अपडेट करा आणि, प्रति ब्लॉक पहिल्या कॉलवर, किंमत संचयक (price accumulators) अपडेट करा
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

प्रत्येक वेळी टोकन्स जमा केले किंवा काढले जातात तेव्हा हे फंक्शन कॉल केले जाते.

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

जर balance0 किंवा balance1 (uint256) हे uint112(-1) (=2^112-1) पेक्षा जास्त असेल (म्हणजे uint112 मध्ये रूपांतरित केल्यावर ते ओव्हरफ्लो होते आणि 0 वर परत येते) तर ओव्हरफ्लो टाळण्यासाठी \_update पुढे चालू ठेवण्यास नकार द्या. एका सामान्य टोकनसह ज्याला 10^18 युनिट्समध्ये उपविभाजित केले जाऊ शकते, याचा अर्थ प्रत्येक एक्सचेंज प्रत्येक टोकनच्या सुमारे 5.1\*10^15 पर्यंत मर्यादित आहे. आतापर्यंत ही समस्या आलेली नाही.

```solidity
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // ओव्हरफ्लो अपेक्षित आहे
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
```

जर गेलेला वेळ शून्य नसेल, तर याचा अर्थ आम्ही या ब्लॉकवरील पहिले एक्सचेंज व्यवहार आहोत. त्या बाबतीत, आम्हाला कॉस्ट अ‍ॅक्युम्युलेटर (cost accumulators) अपडेट करणे आवश्यक आहे.

```solidity
            // * कधीही ओव्हरफ्लो होत नाही, आणि + ओव्हरफ्लो अपेक्षित आहे
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
```

प्रत्येक कॉस्ट अ‍ॅक्युम्युलेटरला नवीनतम कॉस्ट (दुसऱ्या टोकनचा रिझर्व्ह/या टोकनचा रिझर्व्ह) गुणिले सेकंदात गेलेला वेळ यानुसार अपडेट केले जाते. सरासरी किंमत मिळवण्यासाठी, तुम्ही वेळेच्या दोन बिंदूंमधील एकत्रित किंमत वाचता आणि त्यांच्यातील वेळेच्या फरकाने भागता. उदाहरणार्थ, घटनांचा हा क्रम गृहीत धरा:

| इव्हेंट                                                                     |                  reserve0 |                  reserve1 | टाइमस्टॅम्प | सीमान्त विनिमय दर (reserve1 / reserve0) |                                                       price0CumulativeLast |
| --------------------------------------------------------------------------- | ------------------------: | ------------------------: | ----------- | ---------------------------------------------------------: | -------------------------------------------------------------------------: |
| प्राथमिक सेटअप                                                              | 1,000.000 | 1,000.000 | 5,000       |                                      1.000 |                                                                          0 |
| व्यापारी A 50 token0 जमा करतो आणि 47.619 token1 परत मिळवतो  | 1,050.000 |   952.381 | 5,020       |                                      0.907 |                                                                         20 |
| व्यापारी B 10 token0 जमा करतो आणि 8.984 token1 परत मिळवतो   | 1,060.000 |   943.396 | 5,030       |                                      0.890 |                       20+10\*0.907 = 29.07 |
| व्यापारी C 40 token0 जमा करतो आणि 34.305 token1 परत मिळवतो  | 1,100.000 |   909.090 | 5,100       |                                      0.826 |    29.07+70\*0.890 = 91.37 |
| व्यापारी D 100 token1 जमा करतो आणि 109.01 token0 परत मिळवतो |   990.990 | 1,009.090 | 5,110       |                                      1.018 |    91.37+10\*0.826 = 99.63 |
| व्यापारी E 10 token0 जमा करतो आणि 10.079 token1 परत मिळवतो  | 1,000.990 |   999.010 | 5,150       |                                      0.998 | 99.63+40\*1.1018 = 143.702 |

समजा आपल्याला 5,030 आणि 5,150 टाइमस्टॅम्प दरम्यान **Token0** ची सरासरी किंमत काढायची आहे. `price0Cumulative` च्या मूल्यातील फरक 143.702-29.07=114.632 आहे. ही दोन मिनिटांची (120 सेकंद) सरासरी आहे. म्हणून सरासरी किंमत 114.632/120 = 0.955 आहे.

या किंमतीच्या गणनेमुळेच आपल्याला जुन्या रिझर्व्ह आकारांची माहिती असणे आवश्यक आहे.

```solidity
एका मॉडिफायरमध्ये `_;` मूळ फंक्शन कॉल (सर्व पॅरामीटर्ससह) असतो.
```

येथे याचा अर्थ असा आहे की फंक्शन कॉल तेव्हाच होतो जेव्हा `unlocked` कॉल केल्यावर एक होते आणि ते चालू असताना `unlocked` चे मूल्य शून्य असते.

##### ```

    unlocked = 1;
}
```

```solidity
मुख्य फंक्शन परत आल्यानंतर, लॉक सोडा.
```

विविध फंक्शन्स {#pair-misc}     function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
_reserve0 = reserve0;
_reserve1 = reserve1;
_blockTimestampLast = blockTimestampLast;
}

हे फंक्शन कॉलरला एक्सचेंजच्या सध्याच्या स्थितीबद्दल माहिती देते.

```solidity
लक्षात घ्या की Solidity फंक्शन्स [एकापेक्षा जास्त मूल्ये परत करू शकतात](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values).
```

```
function _safeTransfer(address token, address to, uint value) private {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); हे अंतर्गत फंक्शन एक्सचेंजमधून ERC20 टोकनची रक्कम दुसऱ्या कोणालातरी हस्तांतरित करते.
```

```solidity
`SELECTOR` निर्दिष्ट करते की आपण ज्या फंक्शनला कॉल करत आहोत ते `transfer(address,uint)` आहे (वर व्याख्या पहा).
```

टोकन फंक्शनसाठी इंटरफेस आयात करणे टाळण्यासाठी, आम्ही [ABI फंक्शन्स](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions) पैकी एक वापरून "मॅन्युअली" कॉल तयार करतो.
require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
}

```solidity
ERC-20 ट्रान्सफर कॉल अयशस्वी झाल्याची तक्रार करण्याचे दोन मार्ग आहेत:
```

रिव्हर्ट. जर बाह्य कराराचा कॉल रिव्हर्ट झाला, तर बूलियन रिटर्न व्हॅल्यू `false` असते

```solidity
सामान्यपणे समाप्त होते परंतु अपयशाची तक्रार करते.
```

त्या बाबतीत रिटर्न व्हॅल्यू बफरची लांबी शून्य नसते आणि बूलियन व्हॅल्यू म्हणून डीकोड केल्यावर ते `false` असते यापैकी कोणतीही एक अट घडल्यास, रिव्हर्ट करा.

```solidity
इव्हेंट्स {#pair-events}
```

```
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); जेव्हा लिक्विडिटी प्रोव्हायडर एकतर लिक्विडिटी जमा करतो (`Mint`) किंवा काढतो (`Burn`) तेव्हा हे दोन इव्हेंट उत्सर्जित होतात.
```

```solidity
दोन्ही बाबतीत, जमा किंवा काढलेल्या token0 आणि token1 ची रक्कम इव्हेंटचा भाग असते, तसेच आम्हाला कॉल करणाऱ्या खात्याची ओळख (`sender`).
```

पैसे काढण्याच्या बाबतीत, इव्हेंटमध्ये टोकन प्राप्त करणाऱ्या लक्ष्याचा (`to`) देखील समावेश असतो, जो प्रेषकसारखाच असेल असे नाही.

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

जेव्हा व्यापारी एका टोकनसाठी दुसरा टोकन स्वॅप करतो तेव्हा हा इव्हेंट उत्सर्जित होतो. पुन्हा, प्रेषक आणि गंतव्यस्थान समान असू शकत नाहीत.
प्रत्येक टोकन एकतर एक्सचेंजला पाठवला जाऊ शकतो, किंवा त्यातून प्राप्त केला जाऊ शकतो.

#### ```

event Sync(uint112 reserve0, uint112 reserve1);
```

शेवटी, `Sync` प्रत्येक वेळी टोकन जोडले किंवा काढले जातात, कारणास्तव काहीही असो, नवीनतम राखीव माहिती (आणि म्हणून विनिमय दर) प्रदान करण्यासाठी उत्सर्जित होते. सेटअप फंक्शन्स {#pair-setup}

##### नवीन पेअर एक्सचेंज सेट केल्यावर ही फंक्शन्स एकदा कॉल केली जावीत.

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

कन्स्ट्रक्टर हे सुनिश्चित करतो की आम्ही पेअर तयार करणाऱ्या फॅक्टरीच्या पत्त्याचा मागोवा ठेवू. ही माहिती `initialize` आणि फॅक्टरी शुल्कासाठी (जर असेल तर) आवश्यक आहे     // called once by the factory at time of deployment
function initialize(address _token0, address _token1) external {
require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
token0 = _token0;
token1 = _token1;
}

```solidity
हे फंक्शन फॅक्टरीला (आणि फक्त फॅक्टरीला) दोन ERC-20 टोकन निर्दिष्ट करण्याची परवानगी देते ज्यांचा हा पेअर एक्सचेंज करेल.
```

अंतर्गत अपडेट फंक्शन्स {#pair-update-internal} \_update

```solidity
    // update reserves and, on the first call per block, price accumulators
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

जेव्हाही टोकन्स जमा किंवा काढले जातात तेव्हा हे फंक्शन कॉल केले जाते.

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

जर balance0 किंवा balance1 (uint256) uint112(-1) (=2^112-1) पेक्षा जास्त असेल (म्हणजे ते ओव्हरफ्लो होते आणि uint112 मध्ये रूपांतरित झाल्यावर 0 वर परत येते), तर ओव्हरफ्लो टाळण्यासाठी \_update पुढे चालू ठेवण्यास नकार द्या. सामान्य टोकनसह जे 10^18 युनिट्समध्ये विभागले जाऊ शकते, याचा अर्थ प्रत्येक एक्सचेंज सुमारे 5.1\*10^15 प्रत्येक टोकनपर्यंत मर्यादित आहे.

```solidity
आतापर्यंत ती समस्या नाही.
```

```
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { जर गेलेला वेळ शून्य नसेल, तर याचा अर्थ आम्ही या ब्लॉकवरील पहिला एक्सचेंज व्यवहार आहोत. त्या बाबतीत, आम्हाला खर्च संचयक अद्यतनित करणे आवश्यक आहे.             // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
```

प्रत्येक खर्च संचयक नवीनतम खर्चासह (दुसऱ्या टोकनचा राखीव साठा/या टोकनचा राखीव साठा) सेकंदात गेलेल्या वेळेने गुणून अद्यतनित केला जातो.

सरासरी किंमत मिळविण्यासाठी, आपण दोन वेळेच्या बिंदूंवर एकत्रित किंमत वाचता आणि त्यांच्यातील वेळेच्या फरकाने भागता.
उदाहरणार्थ, घटनांचा हा क्रम गृहीत धरा: एक व्यापारी या वस्तुस्थितीचा वापर करू शकतो की पेअर एक्सचेंजला वाटते की **Token0** अधिक मौल्यवान आहे, त्यातून मूल्य काढण्यासाठी.

| इव्हेंट                                                         | reserve0 | reserve1 | reserve0 \* reserve1 | price0CumulativeLast |
| --------------------------------------------------------------- | -------: | -------: | -------------------: | -------------------: |
| प्राथमिक सेटअप                                                  |        8 |       32 |                5,000 |                   40 |
| व्यापारी 8 **Token0** टोकन्स जमा करतो, 16 **Token1** परत मिळवतो |       16 |       16 |                5,000 |                   32 |

0.907

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
```

व्यापारी B ने 10 token0 जमा केले आणि 8.984 token1 परत मिळवले जर ते तसे करत नाहीत, तर आम्ही त्यांना शिक्षा म्हणून त्यांनी प्रदान केलेल्या कमी मूल्याच्या आधारावर लिक्विडिटी टोकन देतो.

ती सुरुवातीची ठेव असो किंवा नंतरची, आम्ही प्रदान केलेल्या लिक्विडिटी टोकन्सची संख्या `reserve0*reserve1` मधील बदलाच्या वर्गमूळाएवढी असते आणि लिक्विडिटी टोकनचे मूल्य बदलत नाही (जोपर्यंत आम्हाला दोन्ही प्रकारांचे समान मूल्य नसलेली ठेव मिळत नाही, ज्या प्रकरणात "दंड" वितरित केला जातो). 5,030

| इव्हेंट                                                                                                                                                                   |                                                                                                                                                  reserve0 |                                                                                                                                                  reserve1 |                                                                              reserve0 \* reserve1 |                                                                                                                          पूल मूल्य (reserve0 + reserve1) | 5,100 | 0.826 |                                                                                                                                                                                                                                                                                                                                                        29.07+70\*0.890 = 91.37 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------: | ------------------------------------------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ----: | --------------------: | -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| प्राथमिक सेटअप                                                                                                                                                            |                                                                                                                                     8.000 |                                                                                                                                     8.000 |                                                                                                64 |                                                                                                                                                       1.018 |     8 |                     8 |                                                                                                                                                                                                                                                                                                                                                                                                          2.000 |
| प्रत्येक प्रकारातील चार जमा करा                                                                                                                                           |                                                                                                                                                     5,150 |                                                                                                                                                     5,150 |                        99.63+40\*1.1018 = 143.702 |                                                                    समजा आपल्याला 5,030 आणि 5,150 टाइमस्टॅम्प दरम्यान **टोकन0** ची सरासरी किंमत मोजायची आहे. |     4 |                    12 |                                                                                                                                                                                                                                                                                                                                                                                                          2.000 |
| या किंमतीच्या गणनेमुळेच आपल्याला जुन्या राखीव आकारांची माहिती असणे आवश्यक आहे.                                                                            | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` |                                                                   \_mintFee | ```
// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
``` |     2 |                    14 |                                                                                                                                                                                                                                                                                                                                                                                                          2.000 |
| गणना कमी करण्यासाठी (आणि त्यामुळे गॅस खर्च), हे शुल्क प्रत्येक व्यवहाराऐवजी केवळ लिक्विडिटी जोडताना किंवा पूलमधून काढतानाच मोजले जाते. |                                                          ```
    address feeTo = IUniswapV2Factory(factory).feeTo();
    feeOn = feeTo != address(0);
``` | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` | जर ते शून्य असेल तर कोणतेही प्रोटोकॉल शुल्क नाही आणि ते शुल्क मोजण्याची गरज नाही. |                                                                                                                             ```
    uint _kLast = kLast; // gas savings
``` |     0 |                    14 |                                                                                                                                                                                                                                                                                                                                                                            ```
    if (feeOn) {
        if (_kLast != 0) {
``` |
| लिक्विडिटी प्रोव्हायडरला त्यांच्या लिक्विडिटी टोकनच्या मूल्यांकनातून त्यांचा वाटा मिळतो.                                                                  |                                 परंतु प्रोटोकॉल शुल्कासाठी नवीन लिक्विडिटी टोकन्स मिंट करणे आणि `feeTo` पत्त्यावर प्रदान करणे आवश्यक आहे. |                                 परंतु प्रोटोकॉल शुल्कासाठी नवीन लिक्विडिटी टोकन्स मिंट करणे आणि `feeTo` पत्त्यावर प्रदान करणे आवश्यक आहे. | जर ते शून्य असेल तर कोणतेही प्रोटोकॉल शुल्क नाही आणि ते शुल्क मोजण्याची गरज नाही. |                                                                                                        आपण वर्गमूळ फंक्शन [या लेखात नंतर](#Math) पाहू शकता. |     0 |                    14 | आम्हाला माहित आहे की `kLast` ची गणना केल्यापासून आणि वर्तमानापर्यंत कोणतीही लिक्विडिटी जोडली किंवा काढली गेली नाही (कारण आम्ही प्रत्येक वेळी लिक्विडिटी जोडली किंवा काढली जाते तेव्हा ही गणना करतो, ती प्रत्यक्षात बदलण्यापूर्वी), त्यामुळे `reserve0 * reserve1` मधील कोणताही बदल व्यवहार शुल्कातून आला पाहिजे (त्यांच्याशिवाय आम्ही `reserve0 * reserve1` स्थिर ठेवू). |

```solidity
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
```

अतिरिक्त लिक्विडिटी टोकन तयार करण्यासाठी आणि त्यांना `feeTo` ला नियुक्त करण्यासाठी `UniswapV2ERC20._mint` फंक्शन वापरा.

```solidity
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }
```

जर कोणतेही शुल्क नसेल तर `kLast` शून्यावर सेट करा (जर ते आधीच नसेल तर).

##### जेव्हा हा करार लिहिला गेला होता तेव्हा एक [गॅस परतावा वैशिष्ट्य](https://eips.ethereum.org/EIPS/eip-3298) होते जे करारांना Ethereum राज्याचा एकूण आकार कमी करण्यासाठी प्रोत्साहन देत होते, ज्यासाठी त्यांना आवश्यक नसलेले स्टोरेज शून्यावर आणावे लागत होते.

```solidity
हा कोड शक्य असेल तेव्हा तो परतावा मिळवतो.
```

बाह्यरित्या प्रवेश करण्यायोग्य फंक्शन्स {#pair-external}
लक्षात घ्या की कोणताही व्यवहार किंवा करार ही फंक्शन्स _कॉल_ करू शकतो, तरीही ते परिघ करारातून कॉल करण्यासाठी डिझाइन केलेले आहेत.

```solidity
जर तुम्ही त्यांना थेट कॉल केले तर तुम्ही पेअर एक्सचेंजला फसवू शकणार नाही, परंतु चुकीमुळे तुमचे मूल्य कमी होऊ शकते.
```

मिंट     // this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint liquidity) {

```solidity
जेव्हा लिक्विडिटी प्रोव्हायडर पूलमध्ये लिक्विडिटी जोडतो तेव्हा हे फंक्शन कॉल केले जाते.
```

ते बक्षीस म्हणून अतिरिक्त लिक्विडिटी टोकन मिंट करते. हे [परिघ करार](#UniswapV2Router02) मधून कॉल केले पाहिजे जे त्याच व्यवहारात लिक्विडिटी जोडल्यानंतर त्याला कॉल करते (जेणेकरून इतर कोणीही कायदेशीर मालकापूर्वी नवीन लिक्विडिटीचा दावा करणारा व्यवहार सबमिट करू शकणार नाही).

```solidity
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
```

अनेक मूल्ये परत करणाऱ्या Solidity फंक्शनचे परिणाम वाचण्याचा हा मार्ग आहे.

##### आम्ही शेवटची परत केलेली मूल्ये, ब्लॉक टाइमस्टॅम्प, टाकून देतो कारण आम्हाला त्याची गरज नाही.

```solidity
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0.sub(_reserve0);
        uint amount1 = balance1.sub(_reserve1);
```

सध्याची शिल्लक मिळवा आणि प्रत्येक टोकन प्रकारात किती जोडले गेले ते पहा.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
```

गोळा करायचे प्रोटोकॉल शुल्क, जर असेल तर, मोजा आणि त्यानुसार लिक्विडिटी टोकन मिंट करा.
कारण `_mintFee` चे पॅरामीटर्स जुने राखीव मूल्ये आहेत, शुल्क केवळ शुल्कामुळे होणाऱ्या पूल बदलांवर आधारित अचूकपणे मोजले जाते.         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
if (_totalSupply == 0) {
liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
_mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

```solidity
जर ही पहिली ठेव असेल, तर `MINIMUM_LIQUIDITY` टोकन तयार करा आणि त्यांना लॉक करण्यासाठी शून्य पत्त्यावर पाठवा.
```

ते कधीही रिडीम केले जाऊ शकत नाहीत, याचा अर्थ पूल कधीही पूर्णपणे रिकामा होणार नाही (हे आपल्याला काही ठिकाणी शून्याने भागाकार करण्यापासून वाचवते). `MINIMUM_LIQUIDITY` चे मूल्य एक हजार आहे, जे बहुतेक ERC-20 हे 10^-18 व्या टोकनच्या युनिट्समध्ये विभागलेले आहेत हे लक्षात घेता, जसे ETH वेईमध्ये विभागलेले आहे, ते एकाच टोकनच्या मूल्याच्या 10^-15 आहे.

```solidity
जास्त खर्च नाही.
```

पहिल्या ठेवीच्या वेळी आम्हाला दोन टोकनचे सापेक्ष मूल्य माहित नसते, म्हणून आम्ही फक्त रक्कम गुणतो आणि वर्गमूळ घेतो, असे गृहीत धरून की ठेव आम्हाला दोन्ही टोकनमध्ये समान मूल्य प्रदान करते.

```solidity
आपण यावर विश्वास ठेवू शकतो कारण समान मूल्य प्रदान करणे ठेवकर्त्याच्या हिताचे आहे, जेणेकरून आर्बिट्रेजमुळे मूल्य गमावू नये.
```

समजा दोन टोकनचे मूल्य समान आहे, परंतु आमच्या ठेवकर्त्याने **टोकन0** पेक्षा चार पट जास्त **टोकन1** जमा केले. एक व्यापारी या वस्तुस्थितीचा वापर करू शकतो की पेअर एक्सचेंजला वाटते की **टोकन0** अधिक मौल्यवान आहे, त्यातून मूल्य काढण्यासाठी. यामुळे कॉन्ट्रॅक्टला फसवणूक होत नाही हे तपासणे सोपे होते, ही तपासणी कोअर कॉन्ट्रॅक्टमध्येच _व्हावी_ लागते (कारण आम्हाला आमच्या पेरिफेरी कॉन्ट्रॅक्टव्यतिरिक्त इतर घटकांद्वारे कॉल केले जाऊ शकते).

```solidity
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // reserve{0,1}Adjusted साठी स्कोप, स्टॅक खूप खोल त्रुटी टाळतो
            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
```

स्वॅपमधून आपले नुकसान होणार नाही याची खात्री करण्यासाठी ही एक सॅनिटी चेक आहे. अशी कोणतीही परिस्थिती नाही ज्यात स्वॅपमुळे `reserve0*reserve1` कमी व्हावे. पूलचे मूल्य (reserve0 + reserve1)

```solidity
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }
```

`reserve0` आणि `reserve1` अपडेट करा, आणि आवश्यक असल्यास प्राइस अ‍ॅक्युम्युलेटर (price accumulators) आणि टाइमस्टॅम्प अपडेट करा आणि एक इव्हेंट उत्सर्जित करा.

##### सिंक किंवा स्किम

256
कॉन्ट्रॅक्टच्या संमतीशिवाय टोकन काढण्याचा कोणताही मार्ग नाही, परंतु डिपॉझिट ही एक वेगळी बाब आहे. व्यापारी 8 **टोकन0** टोकन्स जमा करतो, 16 **टोकन1** परत मिळवतो

त्या बाबतीत दोन उपाय आहेत:

- `sync`, रिझर्व्हस्ना सध्याच्या बॅलन्सवर अपडेट करा
- `skim`, अतिरिक्त रक्कम काढा. लक्षात घ्या की कोणत्याही खात्याला `skim` कॉल करण्याची परवानगी आहे कारण आम्हाला माहित नाही की टोकन कोणी जमा केले. जसे आपण पाहू शकता, व्यापाऱ्याने अतिरिक्त 8 टोकन कमावले, जे पूलच्या मूल्यात घट झाल्यामुळे येतात, ज्यामुळे त्याच्या मालकीच्या ठेवकर्त्याला दुखापत होते.

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
```

### प्रत्येक त्यानंतरच्या ठेवीसह आम्हाला दोन मालमत्तांमधील विनिमय दर आधीच माहित आहे, आणि आम्ही अपेक्षा करतो की लिक्विडिटी प्रदाता दोन्हीमध्ये समान मूल्य प्रदान करतील.

जर ते तसे करत नाहीत, तर आम्ही त्यांना शिक्षा म्हणून त्यांनी प्रदान केलेल्या कमी मूल्यावर आधारित लिक्विडिटी टोकन देतो.

```solidity
ती प्रारंभिक ठेव असो किंवा त्यानंतरची, आम्ही प्रदान करत असलेल्या लिक्विडिटी टोकनची संख्या `reserve0*reserve1` मधील बदलाच्या वर्गमूळाच्या बरोबरीची असते आणि लिक्विडिटी टोकनचे मूल्य बदलत नाही (जोपर्यंत आम्हाला अशी ठेव मिळत नाही ज्यात दोन्ही प्रकारांची समान मूल्ये नसतात, अशावेळी "दंड" वितरीत केला जातो).
```

येथे समान मूल्याच्या दोन टोकनसह दुसरे उदाहरण आहे, ज्यात तीन चांगल्या ठेवी आणि एक वाईट ठेव आहे (फक्त एका टोकन प्रकाराची ठेव, त्यामुळे ते कोणतेही लिक्विडिटी टोकन तयार करत नाही).
`feeTo` ॲड्रेस प्रोटोकॉल फीसाठी लिक्विडिटी टोकन जमा करतो, आणि `feeToSetter` हा `feeTo` ला वेगळ्या ॲड्रेसवर बदलण्याची परवानगी असलेला ॲड्रेस आहे.

```solidity
    mapping(address => mapping(address => address)) public getPair;
    address[] public allPairs;
```

हे व्हेरिएबल्स पेअर्सचा, म्हणजेच दोन टोकन प्रकारांमधील एक्सचेंजचा मागोवा ठेवतात.

पहिले, `getPair`, हे एक मॅपिंग आहे जे दोन ERC-20 टोकन्सच्या आधारे पेअर एक्सचेंज कॉन्ट्रॅक्ट ओळखते ज्यांची ते देवाणघेवाण करते. पूल मूल्य (reserve0 + reserve1) या ठेवीसाठी तयार केलेले लिक्विडिटी टोकन

एकूण लिक्विडिटी टोकन्स प्रत्येक लिक्विडिटी टोकनचे मूल्य

टीप: मॅपिंगच्या सर्व कीज (keys) वर पुनरावृत्ती (iterate) न करू शकण्याचे कारण म्हणजे कॉन्ट्रॅक्ट डेटा स्टोरेज _महाग_ आहे, म्हणून आपण जितके कमी वापरू तितके चांगले आणि जितके कमी वेळा बदलू तितके चांगले. 8.000 बहुतेक ऍप्लिकेशन्समध्ये तुम्हाला त्याची गरज नसते.

```solidity
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

16.000 यात टोकन्सचे ॲड्रेस, पेअर एक्सचेंजचा ॲड्रेस आणि फॅक्टरीद्वारे व्यवस्थापित केलेल्या एकूण एक्सचेंजची संख्या समाविष्ट आहे.

```solidity
    constructor(address _feeToSetter) public {
        feeToSetter = _feeToSetter;
    }
```

2.000 प्रत्येक प्रकारचे चार जमा करा

```solidity
12.000
```

हे फंक्शन एक्सचेंज पेअर्सची संख्या परत करते.

```solidity
144
```

24.000 लक्षात घ्या की कोणीही हे फंक्शन कॉल करू शकतो. नवीन पेअर एक्सचेंज तयार करण्यासाठी तुम्हाला Uniswap कडून परवानगीची आवश्यकता नाही.

```solidity
        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
```

प्रत्येक प्रकारचे दोन जमा करा
14.000

```solidity
        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // एकच तपासणी पुरेशी आहे
```

196 28.000 जर आधीपासूनच एक्सचेंज अस्तित्वात असेल, तर त्याच पेअरसाठी दुसरे तयार करण्याची गरज नाही.

```solidity
        bytes memory bytecode = type(UniswapV2Pair).creationCode;
```

नवीन कॉन्ट्रॅक्ट तयार करण्यासाठी आम्हाला तो तयार करणारा कोड आवश्यक आहे (कन्स्ट्रक्टर फंक्शन आणि प्रत्यक्ष कॉन्ट्रॅक्टचा EVM बायकोड मेमरीमध्ये लिहिणारा कोड दोन्ही). असमान मूल्य ठेव
18.000 ही आता समस्या नाही, कारण [Solidity आता CREATE2 ला सपोर्ट करते](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2).

```solidity
252
```

32.000

```solidity
        IUniswapV2Pair(pair).initialize(token0, token1);
```

नवीन एक्सचेंजला ते कोणते दोन टोकन एक्सचेंज करते हे सांगण्यासाठी `initialize` फंक्शनला कॉल करा.

```solidity
~2.286
```

आर्बिट्रेजनंतर

```solidity
~15.874
```

हे दोन फंक्शन्स `feeSetter` ला फी प्राप्तकर्त्यावर (असल्यास) नियंत्रण ठेवण्याची आणि `feeSetter` ला नवीन ॲड्रेसवर बदलण्याची परवानगी देतात.

### UniswapV2ERC20.sol {#UniswapV2ERC20}

~31.748 हे [OpenZeppelin ERC-20 कॉन्ट्रॅक्ट](/developers/tutorials/erc20-annotated-code) सारखेच आहे, म्हणून मी फक्त वेगळा असलेला भाग, `permit` फंक्शनॅलिटी समजावून सांगेन.

Ethereum वरील व्यवहारांसाठी इथर (ETH) खर्च होतो, जो खऱ्या पैशाच्या समतुल्य आहे. ~2.267         }
require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
_mint(to, liquidity);
अतिरिक्त लिक्विडिटी टोकन तयार करण्यासाठी आणि त्यांना योग्य खात्यात देण्यासाठी `UniswapV2ERC20._mint` फंक्शन वापरा.
_update(balance0, balance1, _reserve0, _reserve1);
if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
emit Mint(msg.sender, amount0, amount1);
}

```solidity
स्टेट व्हेरिएबल्स (`reserve0`, `reserve1`, आणि आवश्यक असल्यास `kLast`) अद्यतनित करा आणि योग्य इव्हेंट उत्सर्जित करा.
```

बर्न     // this low-level function should be called from a contract which performs important safety checks
function burn(address to) external lock returns (uint amount0, uint amount1) {

```solidity
जेव्हा लिक्विडिटी काढली जाते आणि योग्य लिक्विडिटी टोकन बर्न करणे आवश्यक असते तेव्हा हे फंक्शन कॉल केले जाते.
```

हे [परिघ खात्या](#UniswapV2Router02) मधून देखील कॉल केले पाहिजे.         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
address _token0 = token0;                                // gas savings
address _token1 = token1;                                // gas savings
uint balance0 = IERC20(_token0).balanceOf(address(this));
uint balance1 = IERC20(_token1).balanceOf(address(this));
uint liquidity = balanceOf[address(this)]; परिघ कराराने कॉल करण्यापूर्वी बर्न करण्यासाठी लिक्विडिटी या करारात हस्तांतरित केली. त्यामुळे आम्हाला माहित आहे की किती लिक्विडिटी बर्न करायची आहे आणि आम्ही खात्री करू शकतो की ती बर्न होईल.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
```

लिक्विडिटी प्रोव्हायडरला दोन्ही टोकनचे समान मूल्य मिळते. यामुळे आपण विनिमय दर बदलत नाही.         _burn(address(this), liquidity);
_safeTransfer(_token0, to, amount0);
_safeTransfer(_token1, to, amount1);
balance0 = IERC20(_token0).balanceOf(address(this));
balance1 = IERC20(_token1).balanceOf(address(this));```
    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
```

```solidity
`burn` फंक्शनचा उर्वरित भाग वरील `mint` फंक्शनचा आरसा प्रतिमा आहे.
```

स्वॅप

```solidity
    // this low-level function should be called from a contract which performs important safety checks
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
```

हे फंक्शन [परिघ करार](#UniswapV2Router02) मधून कॉल केले जाणे अपेक्षित आहे.         require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');```
    uint balance0;
    uint balance1;
    { // scope for _token{0,1}, avoids stack too deep errors
```

```solidity
स्थानिक व्हेरिएबल्स एकतर मेमरीमध्ये किंवा, जर ते जास्त नसतील तर, थेट स्टॅकवर संग्रहित केले जाऊ शकतात.
```

जर आपण संख्या मर्यादित करू शकलो तर आपण स्टॅक वापरू ज्यामुळे कमी गॅस वापरला जाईल.

```solidity
अधिक माहितीसाठी [पिवळे कागदपत्र, अधिकृत Ethereum तपशील](https://ethereum.github.io/yellowpaper/paper.pdf), पृष्ठ २६, समीकरण २९८ पहा.
```

```
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens हे हस्तांतरण आशावादी आहे, कारण सर्व अटी पूर्ण झाल्या आहेत याची खात्री करण्यापूर्वी आम्ही हस्तांतरण करतो.
```

Ethereum मध्ये हे ठीक आहे कारण जर कॉलमध्ये नंतर अटी पूर्ण झाल्या नाहीत तर आम्ही त्यातून आणि त्याने तयार केलेल्या कोणत्याही बदलांमधून रिव्हर्ट करतो.

```solidity
            if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
```

मागणी केल्यास प्राप्तकर्त्याला स्वॅपबद्दल माहिती द्या.

```solidity
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
```

सध्याची शिल्लक मिळवा.

## परिघ करार आम्हाला स्वॅपसाठी कॉल करण्यापूर्वी टोकन्स पाठवतो.

यामुळे कराराला त्याची फसवणूक होत नाही हे तपासणे सोपे होते, ही तपासणी _मुख्य करारामध्ये_ होणे आवश्यक आहे (कारण आम्हाला आमच्या परिघ कराराव्यतिरिक्त इतर घटकांकडून कॉल केला जाऊ शकतो).         uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
{ // scope for reserve{0,1}Adjusted, avoids stack too deep errors
uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000\*\*2), 'UniswapV2: K'); स्वॅपमधून आम्हाला नुकसान होत नाही याची खात्री करण्यासाठी ही एक sanity check आहे. कोणत्याही परिस्थितीत स्वॅपने `reserve0*reserve1` कमी करू नये. येथेच आम्ही खात्री करतो की स्वॅपवर 0.3% शुल्क पाठवले जात आहे; K चे मूल्य तपासण्यापूर्वी, आम्ही दोन्ही शिल्लक 1000 ने गुणतो आणि रकमेला 3 ने गुणून वजा करतो, याचा अर्थ 0.3% (3/1000 = 0.003 = 0.3%) शिल्लक मधून वजा केले जात आहे, त्याच्या K मूल्याची सध्याच्या राखीव K मूल्याशी तुलना करण्यापूर्वी.

### ```

    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

`reserve0` आणि `reserve1` अद्यतनित करा, आणि आवश्यक असल्यास किंमत संचयक आणि टाइमस्टॅम्प आणि एक इव्हेंट उत्सर्जित करा. सिंक किंवा स्किम

### पेअर एक्सचेंजला वाटणाऱ्या राखीव साठ्याशी वास्तविक शिल्लक सिंकच्या बाहेर जाणे शक्य आहे.

कराराच्या संमतीशिवाय टोकन काढण्याचा कोणताही मार्ग नाही, परंतु ठेवी वेगळी बाब आहे.
एक खाते `mint` किंवा `swap` कॉल न करता एक्सचेंजला टोकन हस्तांतरित करू शकते.

```solidity
त्या बाबतीत दोन उपाय आहेत:
```

`sync`, राखीव साठा सध्याच्या शिल्लकनुसार अद्यतनित करा `skim`, अतिरिक्त रक्कम काढा. लक्षात घ्या की कोणत्याही खात्याला `skim` कॉल करण्याची परवानगी आहे कारण आम्हाला माहित नाही की टोकन कोणी जमा केले. ही माहिती एका इव्हेंटमध्ये उत्सर्जित केली जाते, परंतु इव्हेंट ब्लॉकचेनमधून प्रवेश करण्यायोग्य नाहीत.     // force balances to match reserves
function skim(address to) external lock {
address _token0 = token0; // gas savings
address _token1 = token1; // gas savings
_safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
_safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
}```
// force reserves to match balances
function sync() external lock {
    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
}
```} UniswapV2Factory.sol {#UniswapV2Factory} [हा करार](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol) पेअर एक्सचेंजेस तयार करतो.

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Factory.sol';
import './UniswapV2Pair.sol';

contract UniswapV2Factory is IUniswapV2Factory {
    address public feeTo;
    address public feeToSetter;
```

प्रोटोकॉल शुल्क लागू करण्यासाठी हे स्टेट व्हेरिएबल्स आवश्यक आहेत ([व्हाइटपेपर](https://app.uniswap.org/whitepaper.pdf), पृष्ठ 5 पहा). `feeTo` पत्ता प्रोटोकॉल शुल्कासाठी लिक्विडिटी टोकन जमा करतो, आणि `feeToSetter` हा `feeTo` वेगळ्या पत्त्यावर बदलण्यास परवानगी असलेला पत्ता आहे.     mapping(address => mapping(address => address)) public getPair;
address[] public allPairs;

```solidity
हे व्हेरिएबल्स पेअर्सचा, दोन टोकन प्रकारांमधील एक्सचेंजेसचा मागोवा ठेवतात.
```

पहिले, `getPair`, एक मॅपिंग आहे जे दोन ERC-20 टोकनच्या आधारावर पेअर एक्सचेंज करार ओळखते.

```solidity
ERC-20 टोकन्स त्यांच्या अंमलबजावणी करणाऱ्या करारांच्या पत्त्यांवरून ओळखले जातात, त्यामुळे की आणि मूल्य सर्व पत्ते आहेत.
```

`tokenA` वरून `tokenB` मध्ये रूपांतरित करणाऱ्या पेअर एक्सचेंजचा पत्ता मिळवण्यासाठी, तुम्ही `getPair[<tokenA address>][<tokenB address>]` (किंवा उलट) वापरता.

```solidity
दुसरे व्हेरिएबल, `allPairs`, एक अॅरे आहे ज्यात या फॅक्टरीद्वारे तयार केलेल्या पेअर एक्सचेंजेसचे सर्व पत्ते समाविष्ट आहेत.
```

Ethereum मध्ये तुम्ही मॅपिंगच्या सामग्रीवर पुनरावृत्ती करू शकत नाही, किंवा सर्व कीची सूची मिळवू शकत नाही, म्हणून हे व्हेरिएबलच या फॅक्टरीद्वारे व्यवस्थापित केलेल्या एक्सचेंजेसची माहिती मिळवण्याचा एकमेव मार्ग आहे. टीप: तुम्ही मॅपिंगच्या सर्व कीवर पुनरावृत्ती करू शकत नाही याचे कारण असे की करार डेटा स्टोरेज _महाग_ आहे, त्यामुळे आपण जितके कमी वापरू तितके चांगले, आणि आपण ते जितके कमी बदलू तितके चांगले.

#### तुम्ही [पुनरावृत्तीला समर्थन देणारे मॅपिंग](https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol) तयार करू शकता, परंतु त्यांना कीच्या सूचीसाठी अतिरिक्त स्टोरेजची आवश्यकता असते.

बहुतेक ॲप्लिकेशन्समध्ये तुम्हाला त्याची गरज नसते.

```solidity
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

जेव्हा नवीन पेअर एक्सचेंज तयार केले जाते तेव्हा हा इव्हेंट उत्सर्जित होतो.

```solidity
यात टोकनचे पत्ते, पेअर एक्सचेंजचा पत्ता आणि फॅक्टरीद्वारे व्यवस्थापित केलेल्या एकूण एक्सचेंजेसची संख्या समाविष्ट आहे.
```

```
constructor(address _feeToSetter) public {
    feeToSetter = _feeToSetter;
}
```

```solidity
कन्स्ट्रक्टर फक्त `feeToSetter` निर्दिष्ट करतो.
```

फॅक्टरीज शुल्काशिवाय सुरू होतात, आणि फक्त `feeSetter` ते बदलू शकतो.     function allPairsLength() external view returns (uint) {
return allPairs.length;
}

```solidity
हे फंक्शन एक्सचेंज पेअर्सची संख्या परत करते.
```

```
function createPair(address tokenA, address tokenB) external returns (address pair) { फॅक्टरीचे मुख्य कार्य म्हणजे दोन ERC-20 टोकनमध्ये पेअर एक्सचेंज तयार करणे. लक्षात घ्या की कोणीही हे फंक्शन कॉल करू शकते.
```

नवीन पेअर एक्सचेंज तयार करण्यासाठी तुम्हाला Uniswap कडून परवानगीची गरज नाही.         require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
(address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);

आम्हाला नवीन एक्सचेंजचा पत्ता निश्चित हवा आहे, जेणेकरून तो ऑफचेन आगाऊ मोजला जाऊ शकेल (हे [लेयर 2 व्यवहारांसाठी](/developers/docs/scaling/) उपयुक्त ठरू शकते).

| पॅरामीटर                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                      मूल्य |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| मोठे लिक्विडिटी पूल लहान पूलांपेक्षा चांगले असतात, कारण त्यांच्या किंमती अधिक स्थिर असतात.                                                                                |                                                                                                                                                                                                        आम्हाला प्रति टोकन जोडीसाठी एकापेक्षा जास्त लिक्विडिटी पूल नको आहे. |
| जर आधीच एक एक्सचेंज असेल, तर त्याच जोडीसाठी दुसरा तयार करण्याची गरज नाही.                                                                                                 |                                                                                                                                                                                                        आम्हाला प्रति टोकन जोडीसाठी एकापेक्षा जास्त लिक्विडिटी पूल नको आहे. |
| नवीन करार तयार करण्यासाठी आम्हाला तो तयार करणारा कोड आवश्यक आहे (कन्स्ट्रक्टर फंक्शन आणि वास्तविक कराराचा EVM बायटकोड मेमरीमध्ये लिहिणारा कोड दोन्ही). | सामान्यतः Solidity मध्ये आपण फक्त `addr = new <name of contract>(<constructor parameters>)` वापरतो आणि कंपायलर आमच्यासाठी सर्व काही हाताळतो, परंतु एक निश्चित करार पत्ता मिळवण्यासाठी आम्हाला [CREATE2 ऑपकोड](https://eips.ethereum.org/EIPS/eip-1014) वापरण्याची गरज आहे. |
| जेव्हा हा कोड लिहिला गेला होता तेव्हा तो ऑपकोड अजूनही Solidity द्वारे समर्थित नव्हता, म्हणून कोड मॅन्युअली मिळवणे आवश्यक होते.                                            |                                                                                                         ही आता समस्या नाही, कारण [Solidity आता CREATE2 ला समर्थन देते](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2). |

```
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    } जेव्हा एखादा ऑपकोड Solidity द्वारे अजून समर्थित नसतो तेव्हा आपण त्याला [इनलाइन असेंब्ली](https://docs.soliditylang.org/en/v0.8.3/assembly.html) वापरून कॉल करू शकतो.
```

```
    IUniswapV2Pair(pair).initialize(token0, token1); नवीन एक्सचेंजला कोणते दोन टोकन एक्सचेंज करायचे आहेत हे सांगण्यासाठी `initialize` फंक्शनला कॉल करा.
```

```solidity
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair; // populate mapping in the reverse direction
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }
```

नवीन जोडीची माहिती स्टेट व्हेरिएबल्समध्ये सेव्ह करा आणि नवीन जोडी एक्सचेंजची माहिती जगाला देण्यासाठी एक इव्हेंट उत्सर्जित करा.

```solidity
    function setFeeTo(address _feeTo) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeTo = _feeTo;
    }

    function setFeeToSetter(address _feeToSetter) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeToSetter = _feeToSetter;
    }
}
```

ही दोन फंक्शन्स `feeSetter` ला शुल्क प्राप्तकर्ता (जर असेल तर) नियंत्रित करण्यास आणि `feeSetter` ला नवीन पत्त्यावर बदलण्यास परवानगी देतात.

```solidity
UniswapV2ERC20.sol {#UniswapV2ERC20}
```

[हा करार](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol) ERC-20 लिक्विडिटी टोकन लागू करतो.

```solidity
हे [OpenZeppelin ERC-20 करार](/developers/tutorials/erc20-annotated-code) सारखेच आहे, म्हणून मी फक्त वेगळा भाग, `permit` कार्यक्षमता स्पष्ट करेन.
```

Ethereum वरील व्यवहारांसाठी इथर (ETH) लागते, जे खऱ्या पैशाच्या समतुल्य आहे. तुमच्याकडे ERC-20 टोकन्स असतील पण ETH नसेल, तर तुम्ही व्यवहार पाठवू शकत नाही, त्यामुळे तुम्ही त्यांच्यासोबत काहीही करू शकत नाही.

```solidity
ही समस्या टाळण्यासाठी एक उपाय म्हणजे [मेटा-ट्रान्झॅक्शन्स](https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/supporting-meta-transactions).
```

टोकनचा मालक एका व्यवहारावर स्वाक्षरी करतो ज्यामुळे दुसऱ्या कोणालातरी ऑफचेन टोकन काढण्याची परवानगी मिळते आणि ते इंटरनेटद्वारे प्राप्तकर्त्याला पाठवतो. प्राप्तकर्ता, ज्याच्याकडे ETH आहे, तो मालकाच्या वतीने परवानगी सादर करतो.

```solidity
    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
```

हा हॅश [व्यवहार प्रकारासाठी ओळखकर्ता](https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash) आहे.

```solidity
आम्ही येथे फक्त या पॅरामीटर्ससह `Permit` ला समर्थन देतो.
```

```
mapping(address => uint) public nonces; प्राप्तकर्त्यासाठी डिजिटल स्वाक्षरी बनावट करणे शक्य नाही. तथापि, समान व्यवहार दोनदा पाठवणे क्षुल्लक आहे (हा [रिप्ले हल्ला](https://wikipedia.org/wiki/Replay_attack) चा एक प्रकार आहे).
```

हे टाळण्यासाठी, आम्ही [नॉन्स](https://wikipedia.org/wiki/Cryptographic_nonce) वापरतो. जर नवीन `Permit` चा नॉन्स शेवटच्या वापरलेल्या नॉन्सपेक्षा एक जास्त नसेल, तर आम्ही ते अवैध मानतो.     constructor() public {
uint chainId;
assembly {
chainId := chainid
} हा [चेन आयडेंटिफायर](https://chainid.network/) मिळवण्यासाठी कोड आहे. हे [Yul](https://docs.soliditylang.org/en/v0.8.4/yul.html) नावाच्या EVM असेंब्ली बोलीचा वापर करते. लक्षात घ्या की Yul च्या सध्याच्या आवृत्तीमध्ये तुम्हाला `chainid()` वापरावे लागेल, `chainid` नाही.

```
    DOMAIN_SEPARATOR = keccak256(
        abi.encode(
            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
            keccak256(bytes(name)),
            keccak256(bytes('1')),
            chainId,
            address(this)
        )
    );
```

EIP-712 साठी [डोमेन विभाजक](https://eips.ethereum.org/EIPS/eip-712#rationale-for-domainseparator) मोजा.     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {

```solidity
हे फंक्शन परवानगी लागू करते.
```

ते पॅरामीटर्स म्हणून संबंधित फील्ड्स आणि [स्वाक्षरीसाठी](https://yos.io/2018/11/16/ethereum-signatures/) तीन स्केलर मूल्ये (v, r, आणि s) प्राप्त करते.         require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');

.         bytes32 digest = keccak256(
abi.encodePacked(
'\x19\x01',
DOMAIN_SEPARATOR,
keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
)
); `abi.encodePacked(...)` हा संदेश आहे जो आम्हाला मिळण्याची अपेक्षा आहे.

```solidity
आम्हाला माहित आहे की नॉन्स काय असावे, म्हणून आम्हाला ते पॅरामीटर म्हणून मिळवण्याची गरज नाही.
```

Ethereum स्वाक्षरी अल्गोरिदमला स्वाक्षरी करण्यासाठी 256 बिट्सची अपेक्षा असते, म्हणून आम्ही `keccak256` हॅश फंक्शन वापरतो.         address recoveredAddress = ecrecover(digest, v, r, s);

```solidity
डायजेस्ट आणि स्वाक्षरीवरून आपण [ecrecover](https://coders-errand.com/ecrecover-signature-verification-ethereum/) वापरून स्वाक्षरी करणारा पत्ता मिळवू शकतो.
```

```
    require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
    _approve(owner, spender, value);
}
```

```solidity
जर सर्व काही ठीक असेल, तर याला [ERC-20 approve](https://eips.ethereum.org/EIPS/eip-20#approve) म्हणून समजा.
```

परिघ करार {#periphery-contracts} परिघ करार Uniswap साठी API (ॲप्लिकेशन प्रोग्राम इंटरफेस) आहेत.

```solidity
ते बाह्य कॉल्ससाठी उपलब्ध आहेत, एकतर इतर करारांमधून किंवा विकेंद्रीकृत ॲप्लिकेशन्समधून.
```

तुम्ही मुख्य करारांना थेट कॉल करू शकता, परंतु ते अधिक गुंतागुंतीचे आहे आणि तुम्ही चूक केल्यास मूल्य गमावू शकता. मुख्य करारांमध्ये फक्त ते फसवले जात नाहीत याची खात्री करण्यासाठी चाचण्या असतात, इतर कोणासाठीही sanity checks नाहीत. ते परिघामध्ये आहेत जेणेकरून आवश्यकतेनुसार ते अद्यतनित केले जाऊ शकतात.

```solidity
UniswapV2Router01.sol {#UniswapV2Router01}
```

[या करारामध्ये](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol) समस्या आहेत, आणि [तो आता वापरला जाऊ नये](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01). सुदैवाने, परिघ करार स्टेटलेस आहेत आणि कोणतीही मालमत्ता ठेवत नाहीत, त्यामुळे त्याला नाकारणे आणि लोकांना त्याऐवजी बदल, `UniswapV2Router02`, वापरण्यास सुचवणे सोपे आहे. UniswapV2Router02.sol {#UniswapV2Router02}

```solidity
बहुतेक प्रकरणांमध्ये तुम्ही [या कराराद्वारे](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol) Uniswap वापराल.
```

तुम्ही ते कसे वापरायचे ते [येथे](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02) पाहू शकता.

#### pragma solidity =0.6.6;import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';&#xA;import '@uniswap/lib/contracts/libraries/TransferHelper.sol';import './interfaces/IUniswapV2Router02.sol';&#xA;import './libraries/UniswapV2Library.sol';&#xA;import './libraries/SafeMath.sol';&#xA;import './interfaces/IERC20.sol';&#xA;import './interfaces/IWETH.sol';

यापैकी बहुतेक आपण यापूर्वी पाहिले आहेत, किंवा ते बरेच स्पष्ट आहेत.

```solidity
एक अपवाद `IWETH.sol` आहे.
```

Uniswap v2 कोणत्याही ERC-20 टोकनच्या जोडीसाठी एक्सचेंजला परवानगी देतो, परंतु इथर (ETH) स्वतः ERC-20 टोकन नाही. ते मानकापूर्वीचे आहे आणि अद्वितीय यंत्रणेद्वारे हस्तांतरित केले जाते.

```solidity
ERC-20 टोकनवर लागू होणाऱ्या करारांमध्ये ETH चा वापर सक्षम करण्यासाठी लोकांनी [रॅप्ड इथर (WETH)](https://weth.tkn.eth.limo/) करार आणला.
```

तुम्ही या कराराला ETH पाठवता, आणि ते तुम्हाला WETH ची समतुल्य रक्कम मिंट करते.

```solidity
किंवा तुम्ही WETH बर्न करू शकता, आणि ETH परत मिळवू शकता.
```

contract UniswapV2Router02 is IUniswapV2Router02 {
using SafeMath for uint;```
address public immutable override factory;
address public immutable override WETH; राउटरला माहित असणे आवश्यक आहे की कोणती फॅक्टरी वापरायची, आणि WETH आवश्यक असलेल्या व्यवहारांसाठी कोणता WETH करार वापरायचा.
```

```solidity
ही मूल्ये [अपरिवर्तनीय](https://docs.soliditylang.org/en/v0.8.3/contracts.html#constant-and-immutable-state-variables) आहेत, म्हणजे ती फक्त कन्स्ट्रक्टरमध्ये सेट केली जाऊ शकतात.
```

यामुळे वापरकर्त्यांना विश्वास मिळतो की कोणीही त्यांना कमी प्रामाणिक करारांकडे निर्देशित करण्यासाठी बदलू शकणार नाही.

```solidity
    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }
```

हा मॉडिफायर खात्री करतो की वेळेनुसार मर्यादित व्यवहार ("वेळेच्या आत Y करा जर तुम्ही करू शकत असाल तर") त्यांच्या वेळेच्या मर्यादेनंतर होत नाहीत.

```solidity
    constructor(address _factory, address _WETH) public {
        factory = _factory;
        WETH = _WETH;
    }
```

कन्स्ट्रक्टर फक्त अपरिवर्तनीय स्टेट व्हेरिएबल्स सेट करतो.

```solidity
    receive() external payable {
        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
    }
```

जेव्हा आम्ही WETH करारातून टोकन परत ETH मध्ये रिडीम करतो तेव्हा हे फंक्शन कॉल केले जाते.

```solidity
फक्त आम्ही वापरत असलेला WETH करारच ते करण्यास अधिकृत आहे.
```

लिक्विडिटी जोडा {#add-liquidity} ही फंक्शन्स पेअर एक्सचेंजमध्ये टोकन जोडतात, ज्यामुळे लिक्विडिटी पूल वाढतो.

```solidity

    // **** ADD LIQUIDITY ****
    function _addLiquidity(
```

अंतिम कार्य स्टोरेज फी आणि मेटा-ट्रान्झॅक्शन्स एकत्र करते.

#### ट्रेड {#trade}

```solidity
    // **** स्वॅप ****
    // प्रारंभिक रक्कम आधीच पहिल्या जोडीला पाठवली गेली असणे आवश्यक आहे
    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {
```

हे कार्य अंतर्गत प्रक्रिया करते जे ट्रेडर्ससाठी उपलब्ध असलेल्या कार्यांसाठी आवश्यक आहे.

```solidity
        for (uint i; i < path.length - 1; i++) {
```

मी हे लिहित असताना [388,160 ERC-20 टोकन्स](https://eth.blockscout.com/tokens) आहेत. प्रत्येक टोकन जोडीसाठी एक पेअर एक्सचेंज असते, तर ते 150 अब्ज पेक्षा जास्त पेअर एक्सचेंज झाले असते. संपूर्ण चेनमध्ये, सध्या, [त्या संख्येच्या केवळ 0.1% खाती आहेत](https://eth.blockscout.com/stats/accountsGrowth). त्याऐवजी, स्वॅप फंक्शन्स पाथच्या संकल्पनेला समर्थन देतात. एक ट्रेडर A ला B साठी, B ला C साठी, आणि C ला D साठी एक्सचेंज करू शकतो, त्यामुळे थेट A-D पेअर एक्सचेंजची गरज नाही.

या बाजारांमधील किमती सिंक्रोनाइझ (समक्रमित) केल्या जातात, कारण जेव्हा त्या सिंकमध्ये नसतात तेव्हा आर्बिट्रेजसाठी संधी निर्माण होते. उदाहरणार्थ, A, B आणि C या तीन टोकन्सची कल्पना करा. प्रत्येक जोडीसाठी एक, असे तीन पेअर एक्सचेंज आहेत.

1. सुरुवातीची परिस्थिती
2. एक ट्रेडर 24.695 A टोकन्स विकतो आणि 25.305 B टोकन्स मिळवतो.
3. ट्रेडर 24.695 B टोकन्स 25.305 C टोकन्ससाठी विकतो, आणि अंदाजे 0.61 B टोकन्स नफा म्हणून ठेवतो.
4. मग ट्रेडर 24.695 C टोकन्स 25.305 A टोकन्ससाठी विकतो, आणि अंदाजे 0.61 C टोकन्स नफा म्हणून ठेवतो. ट्रेडरकडे 0.61 अतिरिक्त A टोकन्स देखील आहेत (ट्रेडरला शेवटी मिळालेले 25.305, वजा 24.695 ची मूळ गुंतवणूक).

| टप्पा | A-B एक्सचेंज                                                                                | B-C एक्सचेंज                                                                                | A-C एक्सचेंज                                                                                |
| ----- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| 1     | A:1000 B:1050 A/B=1.05                      | B:1000 C:1050 B/C=1.05                      | A:1050 C:1000 C/A=1.05                      |
| 2     | A:1024.695 B:1024.695 A/B=1 | B:1000 C:1050 B/C=1.05                      | A:1050 C:1000 C/A=1.05                      |
| 3     | A:1024.695 B:1024.695 A/B=1 | B:1024.695 C:1024.695 B/C=1 | A:1050 C:1000 C/A=1.05                      |
| 4     | A:1024.695 B:1024.695 A/B=1 | B:1024.695 C:1024.695 B/C=1 | A:1024.695 C:1024.695 C/A=1 |

```solidity
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            uint amountOut = amounts[i + 1];
```

आपण सध्या हाताळत असलेली जोडी मिळवा, ती क्रमवारी लावा (जोडीसोबत वापरण्यासाठी) आणि अपेक्षित आउटपुट रक्कम मिळवा.

```solidity
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
```

अपेक्षित आउटपुट रक्कम मिळवा, पेअर एक्सचेंजला अपेक्षित असलेल्या पद्धतीने क्रमवारी लावा.

```solidity
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
```

हे शेवटचे एक्सचेंज आहे का? तसे असल्यास, ट्रेडसाठी मिळालेले टोकन्स गंतव्यस्थानावर पाठवा. तसे नसल्यास, ते पुढील पेअर एक्सचेंजवर पाठवा.

```solidity

            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
                amount0Out, amount1Out, to, new bytes(0)
            );
        }
    }
```

टोकन्स स्वॅप करण्यासाठी प्रत्यक्षात पेअर एक्सचेंजला कॉल करा. आम्हाला एक्सचेंजबद्दल कळवण्यासाठी कॉलबॅकची आवश्यकता नाही, म्हणून आम्ही त्या फील्डमध्ये कोणतेही बाइट्स पाठवत नाही.

```solidity
    function swapExactTokensForTokens(
```

हे कार्य ट्रेडर्सद्वारे थेट एका टोकनला दुसऱ्या टोकनसाठी स्वॅप करण्याकरिता वापरले जाते.

```solidity
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
```

या पॅरामीटरमध्ये ERC-20 कॉन्ट्रॅक्ट्सचे ॲड्रेस आहेत. वर स्पष्ट केल्याप्रमाणे, ही एक ॲरे आहे कारण तुमच्याकडे असलेल्या मालमत्तेपासून तुम्हाला हव्या असलेल्या मालमत्तेपर्यंत पोहोचण्यासाठी तुम्हाला अनेक पेअर एक्सचेंजेसमधून जावे लागू शकते.

सॉलिडिटीमधील फंक्शन पॅरामीटर `memory` किंवा `calldata` मध्ये संग्रहित केले जाऊ शकते. जर कार्य कॉन्ट्रॅक्टसाठी एक प्रवेश बिंदू असेल, वापरकर्त्याकडून थेट (ट्रान्झॅक्शन वापरून) किंवा वेगळ्या कॉन्ट्रॅक्टवरून कॉल केले असेल, तर पॅरामीटरचे मूल्य थेट कॉल डेटामधून घेतले जाऊ शकते. जर कार्य अंतर्गतपणे कॉल केले असेल, जसे वरील `_swap`, तर पॅरामीटर्स `memory` मध्ये संग्रहित करणे आवश्यक आहे. कॉल केलेल्या कॉन्ट्रॅक्टच्या दृष्टिकोनातून `calldata` फक्त वाचनीय आहे.

`uint` किंवा `address` सारख्या स्केलर प्रकारांसह कंपाइलर आमच्यासाठी स्टोरेजची निवड हाताळतो, परंतु ॲरेंसाठी, जे लांब आणि अधिक महाग आहेत, आम्ही वापरल्या जाणाऱ्या स्टोरेजचा प्रकार निर्दिष्ट करतो.

```solidity
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
```

परत येणारी मूल्ये नेहमी मेमरीमध्ये परत केली जातात.

```solidity
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
```

प्रत्येक स्वॅपमध्ये खरेदी करायच्या रकमेची गणना करा. जर परिणाम ट्रेडरने स्वीकारण्यास तयार असलेल्या किमान रकमेपेक्षा कमी असेल, तर ट्रान्झॅक्शनमधून परत या.

```solidity
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

शेवटी, प्रारंभिक ERC-20 टोकन पहिल्या पेअर एक्सचेंजच्या खात्यावर हस्तांतरित करा आणि `_swap` कॉल करा. हे सर्व एकाच ट्रान्झॅक्शनमध्ये घडत आहे, त्यामुळे पेअर एक्सचेंजला माहित आहे की कोणतेही अनपेक्षित टोकन या हस्तांतरणाचा भाग आहेत.

```solidity
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

मागील कार्य, `swapTokensForTokens`, एका ट्रेडरला तो देण्यास तयार असलेल्या इनपुट टोकन्सची नेमकी संख्या आणि त्या बदल्यात तो स्वीकारण्यास तयार असलेल्या आउटपुट टोकन्सची किमान संख्या निर्दिष्ट करण्याची परवानगी देते. हे कार्य उलट स्वॅप करते, हे एका ट्रेडरला त्याला हव्या असलेल्या आउटपुट टोकन्सची संख्या आणि त्यासाठी तो देण्यास तयार असलेल्या इनपुट टोकन्सची कमाल संख्या निर्दिष्ट करू देते.

दोन्ही प्रकरणांमध्ये, ट्रेडरला प्रथम या पेरिफेरी कॉन्ट्रॅक्टला एक भत्ता द्यावा लागतो जेणेकरून ते त्यांना हस्तांतरित करू शकेल.

```solidity
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
    }


    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }



    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }


    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
        // डस्ट eth परत करा, जर असेल तर
        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);
    }
```

हे चार प्रकार ETH आणि टोकन्समध्ये ट्रेड करण्याशी संबंधित आहेत. फरक फक्त एवढाच आहे की आम्ही एकतर ट्रेडरकडून ETH घेतो आणि WETH तयार करण्यासाठी त्याचा वापर करतो, किंवा आम्ही पाथमधील शेवटच्या एक्सचेंजमधून WETH घेतो आणि ते बर्न करतो, आणि ट्रेडरला परिणामी ETH परत पाठवतो.

```solidity
    // **** स्वॅप (फी-ऑन-ट्रान्सफर टोकन्सना समर्थन देणारे) ****
    // प्रारंभिक रक्कम आधीच पहिल्या जोडीला पाठवली गेली असणे आवश्यक आहे
    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {
```

हे ट्रान्सफर किंवा स्टोरेज फी असलेल्या टोकन्सना स्वॅप करण्यासाठीचे अंतर्गत कार्य आहे ([ही समस्या](https://github.com/Uniswap/uniswap-interface/issues/835) सोडवण्यासाठी).

```solidity
        for (uint i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));
            uint amountInput;
            uint amountOutput;
            { // स्टॅक खूप खोल त्रुटी टाळण्यासाठी स्कोप
            (uint reserve0, uint reserve1,) = pair.getReserves();
            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
```

ट्रान्सफर फीमुळे प्रत्येक ट्रान्सफरमधून आम्हाला किती मिळेल हे सांगण्यासाठी आम्ही `getAmountsOut` फंक्शनवर अवलंबून राहू शकत नाही (ज्याप्रमाणे आम्ही मूळ `_swap` कॉल करण्यापूर्वी करतो). त्याऐवजी आम्हाला आधी हस्तांतरण करावे लागेल आणि मग आम्हाला किती टोकन्स परत मिळाले हे पाहावे लागेल.

टीप: सैद्धांतिकदृष्ट्या आपण `_swap` ऐवजी फक्त हे फंक्शन वापरू शकतो, परंतु काही विशिष्ट प्रकरणांमध्ये (उदाहरणार्थ, जर आवश्यक किमान रक्कम पूर्ण करण्यासाठी शेवटी पुरेसे नसल्यामुळे हस्तांतरण परत केले गेले) त्यासाठी जास्त गॅस खर्च येईल. ट्रान्सफर फी टोकन्स खूप दुर्मिळ आहेत, त्यामुळे जरी आपल्याला त्यांना सामावून घेण्याची आवश्यकता असली तरी, सर्व स्वॅप्सना त्यांच्यापैकी किमान एकातून जावे लागेल असे गृहीत धरण्याची गरज नाही.

```solidity
            }
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
            pair.swap(amount0Out, amount1Out, to, new bytes(0));
        }
    }


    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) {
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        payable
        ensure(deadline)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        uint amountIn = msg.value;
        IWETH(WETH).deposit{value: amountIn}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        ensure(deadline)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        _swapSupportingFeeOnTransferTokens(path, address(this));
        uint amountOut = IERC20(WETH).balanceOf(address(this));
        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).withdraw(amountOut);
        TransferHelper.safeTransferETH(to, amountOut);
    }
```

हे सामान्य टोकन्ससाठी वापरले जाणारे तेच प्रकार आहेत, परंतु ते त्याऐवजी `_swapSupportingFeeOnTransferTokens` कॉल करतात.

```solidity
    // **** लायब्ररी फंक्शन्स ****
    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {
        return UniswapV2Library.quote(amountA, reserveA, reserveB);
    }

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountOut)
    {
        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
    }

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountIn)
    {
        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);
    }

    function getAmountsOut(uint amountIn, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsOut(factory, amountIn, path);
    }

    function getAmountsIn(uint amountOut, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsIn(factory, amountOut, path);
    }
}
```

ही फंक्शन्स फक्त प्रॉक्सी आहेत जी [UniswapV2Library फंक्शन्स](#uniswapV2library) ला कॉल करतात.

### UniswapV2Migrator.sol {#UniswapV2Migrator}

हा कॉन्ट्रॅक्ट जुन्या v1 मधून v2 मध्ये एक्सचेंज स्थलांतरित करण्यासाठी वापरला गेला होता. आता ते स्थलांतरित झाले असल्याने, ते आता संबंधित नाही.

## लायब्ररी {#libraries}

[SafeMath लायब्ररी](https://docs.openzeppelin.com/contracts/2.x/api/math) चांगल्या प्रकारे दस्तऐवजीकृत आहे, म्हणून येथे त्याचे दस्तऐवजीकरण करण्याची गरज नाही.

### गणित {#Math}

या लायब्ररीमध्ये काही गणिती फंक्शन्स आहेत ज्यांची सामान्यतः Solidity कोडमध्ये आवश्यकता नसते, म्हणून ते भाषेचा भाग नाहीत.

```solidity
pragma solidity =0.5.16;

// विविध गणिती क्रिया करण्यासाठी एक लायब्ररी

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // बॅबिलोनियन पद्धत (https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
```

वर्गमूळापेक्षा जास्त असलेल्या अंदाजाने x सह प्रारंभ करा (हेच कारण आहे की आम्हाला 1-3 ला विशेष प्रकरणे म्हणून हाताळण्याची आवश्यकता आहे).

```solidity
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
```

एक जवळचा अंदाज मिळवा, मागील अंदाज आणि ज्या संख्येचे वर्गमूळ आपण शोधण्याचा प्रयत्न करत आहोत ती संख्या, मागील अंदाजाने भागून मिळणारी सरासरी. नवीन अंदाज विद्यमान अंदाजापेक्षा कमी होईपर्यंत पुनरावृत्ती करा. अधिक माहितीसाठी, [येथे पहा](https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).

```solidity
            }
        } else if (y != 0) {
            z = 1;
```

आपल्याला शून्याच्या वर्गमूळाची कधीही गरज भासू नये. एक, दोन आणि तीन यांचे वर्गमूळ अंदाजे एक आहे (आपण पूर्णांक वापरतो, म्हणून आपण अपूर्णांकाकडे दुर्लक्ष करतो).

```solidity
        }
    }
}
```

### फिक्स्ड पॉईंट फ्रॅक्शन्स (UQ112x112) {#FixedPoint}

ही लायब्ररी अपूर्णांक हाताळते, जे सामान्यतः Ethereum अंकगणिताचा भाग नाहीत. हे _x_ या संख्येला _x\*2^112_ म्हणून एन्कोड करून करते. हे आपल्याला मूळ बेरीज आणि वजाबाकी ऑपकोड्समध्ये बदल न करता वापरण्याची परवानगी देते.

```solidity
pragma solidity =0.5.16;

// बायनरी फिक्स्ड पॉईंट संख्या हाताळण्यासाठी एक लायब्ररी (https://wikipedia.org/wiki/Q_(number_format))

// श्रेणी: [0, 2**112 - 1]
// रिझोल्यूशन: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;
```

`Q112` हे एक साठी एन्कोडिंग आहे.

```solidity
    // uint112 ला UQ112x112 म्हणून एन्कोड करा
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // कधीही ओव्हरफ्लो होत नाही
    }
```

कारण y हे `uint112` आहे, ते जास्तीत जास्त 2^112-1 असू शकते. ती संख्या अजूनही `UQ112x112` म्हणून एन्कोड केली जाऊ शकते.

```solidity
    // UQ112x112 ला uint112 ने भागा, UQ112x112 परत करा
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}
```

जर आपण दोन `UQ112x112` मूल्यांना भागले, तर परिणाम 2^112 ने गुणला जात नाही. म्हणून त्याऐवजी आपण भाजकासाठी एक पूर्णांक घेतो. गुणाकार करण्यासाठी आम्हाला अशीच युक्ती वापरावी लागली असती, परंतु आम्हाला `UQ112x112` मूल्यांचा गुणाकार करण्याची आवश्यकता नाही.

### UniswapV2Library {#uniswapV2library}

ही लायब्ररी केवळ पेरिफेरी कॉन्ट्रॅक्ट्सद्वारे वापरली जाते.

```solidity
pragma solidity >=0.5.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import "./SafeMath.sol";

library UniswapV2Library {
    using SafeMath for uint;

    // क्रमवारी लावलेले टोकन पत्ते परत करते, या क्रमाने क्रमवारी लावलेल्या जोड्यांमधून परत येणारी मूल्ये हाताळण्यासाठी वापरले जाते
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }
```

दोन टोकन्सना ॲड्रेसनुसार क्रमवारी लावा, म्हणजे आपल्याला त्यांच्यासाठी पेअर एक्सचेंजचा ॲड्रेस मिळू शकेल. हे आवश्यक आहे कारण अन्यथा आमच्याकडे दोन शक्यता असतील, एक A,B पॅरामीटर्ससाठी आणि दुसरी B,A पॅरामीटर्ससाठी, ज्यामुळे एकाऐवजी दोन एक्सचेंज होतील.

```solidity
    // कोणत्याही बाह्य कॉल न करता जोडीसाठी CREATE2 ॲड्रेसची गणना करते
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init कोड हॅश
            ))));
    }
```

हे फंक्शन दोन टोकन्ससाठी पेअर एक्सचेंजच्या ॲड्रेसची गणना करते. हा कॉन्ट्रॅक्ट [CREATE2 ऑपकोड](https://eips.ethereum.org/EIPS/eip-1014) वापरून तयार केला आहे, त्यामुळे जर आम्हाला ते वापरत असलेले पॅरामीटर्स माहित असतील तर आम्ही त्याच अल्गोरिदमचा वापर करून ॲड्रेसची गणना करू शकतो. हे फॅक्टरीला विचारण्यापेक्षा खूपच स्वस्त आहे, आणि

```solidity
    // एका जोडीसाठी राखीव निधी मिळवते आणि क्रमवारी लावते
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
```

हे फंक्शन पेअर एक्सचेंजकडे असलेल्या दोन टोकन्सचा राखीव निधी परत करते. लक्षात घ्या की ते टोकन्स कोणत्याही क्रमाने प्राप्त करू शकते, आणि अंतर्गत वापरासाठी त्यांची क्रमवारी लावते.

```solidity
    // मालमत्तेची काही रक्कम आणि जोडीचा राखीव निधी दिल्यास, दुसऱ्या मालमत्तेची समतुल्य रक्कम परत करते
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }
```

हे फंक्शन तुम्हाला टोकन A च्या बदल्यात मिळणाऱ्या टोकन B ची रक्कम देते, जर त्यात कोणतेही शुल्क सामील नसेल. ही गणना विचारात घेते की हस्तांतरणामुळे विनिमय दर बदलतो.

```solidity
    // मालमत्तेची इनपुट रक्कम आणि जोडीचा राखीव निधी दिल्यास, दुसऱ्या मालमत्तेची कमाल आउटपुट रक्कम परत करते
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
```

वरील `quote` फंक्शन उत्तम काम करते, जर पेअर एक्सचेंज वापरण्यासाठी कोणतेही शुल्क नसेल. तथापि, जर 0.3% एक्सचेंज शुल्क असेल तर तुम्हाला मिळणारी रक्कम कमी असते. हे फंक्शन एक्सचेंज फी नंतरच्या रकमेची गणना करते.

```solidity

        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
```

Solidity मूळतः अपूर्णांक हाताळत नाही, म्हणून आपण फक्त रकमेला 0.997 ने गुणू शकत नाही. त्याऐवजी, आम्ही अंशाला 997 ने आणि भाजकाला 1000 ने गुणतो, ज्यामुळे तोच परिणाम साधला जातो.

```solidity
    // मालमत्तेची आउटपुट रक्कम आणि जोडीचा राखीव निधी दिल्यास, दुसऱ्या मालमत्तेची आवश्यक इनपुट रक्कम परत करते
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }
```

हे फंक्शन अंदाजे तेच काम करते, परंतु ते आउटपुट रक्कम मिळवते आणि इनपुट प्रदान करते.

```solidity

    // कोणत्याही संख्येच्या जोड्यांवर साखळी getAmountOut गणना करते
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // कोणत्याही संख्येच्या जोड्यांवर साखळी getAmountIn गणना करते
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}
```

ही दोन फंक्शन्स मूल्ये ओळखण्याचे काम करतात, जेव्हा अनेक पेअर एक्सचेंजेसमधून जाणे आवश्यक असते.

### ट्रान्सफर हेल्पर {#transfer-helper}

[ही लायब्ररी](https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol) ERC-20 आणि Ethereum ट्रान्सफरभोवती यशस्वी तपासणी जोडते, जेणेकरून रिव्हर्ट आणि `false` मूल्य परत येण्यास एकाच प्रकारे हाताळता येईल.

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.6.0;

// ERC20 टोकन्सशी संवाद साधण्यासाठी आणि ETH पाठवण्यासाठी मदतनीस पद्धती जे सातत्याने खरे/खोटे परत करत नाहीत
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));

```

आपण वेगळ्या कॉन्ट्रॅक्टला दोनपैकी एका प्रकारे कॉल करू शकतो:

- फंक्शन कॉल तयार करण्यासाठी इंटरफेस व्याख्या वापरा
- कॉल तयार करण्यासाठी [ऍप्लिकेशन बायनरी इंटरफेस (ABI)](https://docs.soliditylang.org/en/v0.8.3/abi-spec.html) "मॅन्युअली" वापरा. कोडच्या लेखकाने हेच करण्याचे ठरवले.

```solidity
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }
```

ERC-20 मानकापूर्वी तयार केलेल्या टोकनसह बॅकवर्ड सुसंगततेसाठी, ERC-20 कॉल एकतर रिव्हर्ट होऊन अयशस्वी होऊ शकतो (या प्रकरणात `success` `false` असते) किंवा यशस्वी होऊन `false` मूल्य परत करून (या प्रकरणात आउटपुट डेटा असतो, आणि जर तुम्ही ते बुलियन म्हणून डीकोड केले तर तुम्हाला `false` मिळते).

```solidity


    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }
```

हे फंक्शन [ERC-20 ची ट्रान्सफर कार्यक्षमता](https://eips.ethereum.org/EIPS/eip-20#transfer) लागू करते, जे एका खात्याला दुसऱ्या खात्याने प्रदान केलेला भत्ता खर्च करण्याची परवानगी देते.

```solidity

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }
```

हे फंक्शन [ERC-20 ची transferFrom कार्यक्षमता](https://eips.ethereum.org/EIPS/eip-20#transferfrom) लागू करते, जे एका खात्याला दुसऱ्या खात्याने प्रदान केलेला भत्ता खर्च करण्याची परवानगी देते.

```solidity

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}
```

हे फंक्शन एका खात्यात ईथर हस्तांतरित करते. वेगळ्या कॉन्ट्रॅक्टला केलेला कोणताही कॉल ईथर पाठवण्याचा प्रयत्न करू शकतो. कारण आम्हाला प्रत्यक्षात कोणतेही फंक्शन कॉल करण्याची गरज नाही, आम्ही कॉलसोबत कोणताही डेटा पाठवत नाही.

## निष्कर्ष {#conclusion}

हा सुमारे 50 पानांचा एक लांब लेख आहे. तुम्ही इथपर्यंत पोहोचलात तर, अभिनंदन! आशा आहे की आतापर्यंत तुम्हाला वास्तविक जीवनातील ॲप्लिकेशन लिहिण्यातील विचार (लहान नमुना कार्यक्रमांच्या विपरीत) समजले असतील आणि तुमच्या स्वतःच्या वापराच्या प्रकरणांसाठी कॉन्ट्रॅक्ट लिहिण्यास अधिक सक्षम आहात.

आता जा आणि काहीतरी उपयुक्त लिहा आणि आम्हाला चकित करा.

[माझ्या कामाबद्दल अधिक माहितीसाठी येथे पहा](https://cryptodocguy.pro/).
