---
title: एका Python डेव्हलपरसाठी Ethereum ची ओळख, भाग 1
description: Ethereum डेव्हलपमेंटची ओळख, विशेषतः Python प्रोग्रामिंग भाषेचे ज्ञान असलेल्यांसाठी उपयुक्त
author: Marc Garreau
lang: mr
tags: [ "python", "web3.py" ]
skill: beginner
published: 2020-09-08
source: Snake charmers
sourceUrl: https://snakecharmers.ethereum.org/a-developers-guide-to-ethereum-pt-1/
---

तर, तुम्ही या Ethereum नावाच्या गोष्टीबद्दल ऐकले आहे आणि या गहन जगात प्रवेश करण्यास तयार आहात का? ही पोस्ट ब्लॉकचेनच्या काही मूलभूत गोष्टींवर पटकन प्रकाश टाकेल, त्यानंतर तुम्हाला एका सिम्युलेटेड Ethereum नोडशी संवाद साधायला लावेल – ब्लॉक डेटा वाचणे, खात्यातील शिल्लक तपासणे आणि व्यवहार पाठवणे. या प्रक्रियेत, ॲप्स बनवण्याच्या पारंपरिक पद्धती आणि हे नवीन विकेंद्रित प्रतिमान (paradigm) यांमधील फरक आम्ही अधोरेखित करू.

## (अंदाजित) पूर्वतयारी {#soft-prerequisites}

ही पोस्ट विविध प्रकारच्या डेव्हलपर्ससाठी सोपी आणि सहज समजण्याजोगी असावी अशी आमची इच्छा आहे. [Python टूल्स](/developers/docs/programming-languages/python/) यात सामील असतील, पण ती केवळ कल्पना पोहोचवण्याचे एक माध्यम आहेत - तुम्ही Python डेव्हलपर नसाल तरी काही हरकत नाही. तथापि, तुम्हाला आधीपासून काय माहित आहे याबद्दल मी काही गृहीतके धरणार आहे, जेणेकरून आपण पटकन Ethereum-विशिष्ट भागांकडे जाऊ शकू.

गृहीतके:

- तुम्ही टर्मिनलमध्ये काम करू शकता,
- तुम्ही Python कोडच्या काही ओळी लिहिल्या आहेत,
- Python आवृत्ती 3.6 किंवा त्याहून अधिक तुमच्या मशीनवर इंस्टॉल केलेले आहे ([व्हर्च्युअल एन्व्हायर्नमेंट](https://realpython.com/effective-python-environment/#virtual-environments) वापरण्यास जोरदार प्रोत्साहन दिले जाते), आणि
- तुम्ही `pip`, Python चे पॅकेज इंस्टॉलर वापरले आहे.
  पुन्हा एकदा, यापैकी काहीही असत्य असल्यास, किंवा तुम्ही या लेखातील कोड पुन्हा वापरण्याची योजना करत नसल्यास, तरीही तुम्ही हे सहजपणे समजून घेऊ शकता.

## ब्लॉकचेन्स, थोडक्यात {#blockchains-briefly}

Ethereum चे वर्णन करण्याचे अनेक मार्ग आहेत, पण त्याच्या केंद्रस्थानी एक ब्लॉकचेन आहे. ब्लॉकचेन हे ब्लॉक्सच्या मालिकेपासून बनलेले असतात, चला तर मग तिथूनच सुरुवात करूया. सोप्या भाषेत सांगायचे झाल्यास, Ethereum ब्लॉकचेनवरील प्रत्येक ब्लॉक म्हणजे काही मेटाडेटा आणि व्यवहारांची सूची. JSON फॉरमॅटमध्ये, ते असे काहीतरी दिसते:

```json
{
   "number": 1234567,
   "hash": "0xabc123...",
   "parentHash": "0xdef456...",
   ...,
   "transactions": [...]
}
```

प्रत्येक [ब्लॉक](/developers/docs/blocks/) मध्ये त्याच्या आधीच्या ब्लॉकचा संदर्भ असतो; `parentHash` म्हणजे फक्त मागील ब्लॉकचा हॅश.

<FeaturedText>टीप: Ethereum ठराविक आकाराची मूल्ये (“हॅश”) तयार करण्यासाठी <a href="https://wikipedia.org/wiki/Hash_function">हॅश फंक्शन्स</a>चा नियमित वापर करते. हॅश Ethereum मध्ये महत्त्वाची भूमिका बजावतात, पण सध्यासाठी तुम्ही त्यांना युनिक आयडी म्हणून समजू शकता.</FeaturedText>

![एका ब्लॉकचेनचे चित्र, ज्यात प्रत्येक ब्लॉकच्या आतील डेटा दर्शविला आहे](./blockchain-diagram.png)

_एक ब्लॉकचेन मूलतः एक लिंक्ड लिस्ट आहे; प्रत्येक ब्लॉकला मागील ब्लॉकचा संदर्भ असतो._

ही डेटा स्ट्रक्चर काही नवीन नाही, परंतु नेटवर्कचे संचालन करणारे नियम (म्हणजेच, पीअर-टू-पीअर प्रोटोकॉल) नवीन आहेत. येथे कोणतेही केंद्रीय प्राधिकरण नाही; नेटवर्क टिकवून ठेवण्यासाठी पीअर्सच्या नेटवर्कला एकत्र काम करावे लागते, आणि पुढील ब्लॉकमध्ये कोणते व्यवहार समाविष्ट करायचे हे ठरवण्यासाठी स्पर्धा करावी लागते. म्हणून, जेव्हा तुम्हाला तुमच्या मित्राला काही पैसे पाठवायचे असतील, तेव्हा तुम्हाला तो व्यवहार नेटवर्कवर प्रसारित करावा लागेल, आणि नंतर तो आगामी ब्लॉकमध्ये समाविष्ट होण्याची वाट पाहावी लागेल.

एका वापरकर्त्याकडून दुसऱ्या वापरकर्त्याकडे पैसे खरोखरच पाठवले गेले आहेत हे पडताळून पाहण्याचा ब्लॉकचेनसाठी एकमेव मार्ग म्हणजे त्या ब्लॉकचेनचे मूळ चलन (म्हणजेच, त्या ब्लॉकचेनद्वारे तयार केलेले आणि शासित) वापरणे. Ethereum मध्ये, या चलनास ईथर म्हणतात, आणि Ethereum ब्लॉकचेनमध्ये खात्यातील शिलकीची एकमेव अधिकृत नोंद असते.

## एक नवीन प्रतिमान (paradigm) {#a-new-paradigm}

या नवीन विकेंद्रित टेक स्टॅकने नवीन डेव्हलपर टूल्स तयार केले आहेत. अशी टूल्स अनेक प्रोग्रामिंग भाषांमध्ये अस्तित्वात आहेत, परंतु आपण Python च्या दृष्टिकोनातून पाहणार आहोत. पुन्हा सांगतो: Python तुमची पसंतीची भाषा नसली तरीही, हे समजून घेण्यासाठी जास्त अडचण येऊ नये.

Ethereum शी संवाद साधू इच्छिणारे Python डेव्हलपर बहुधा [Web3.py](https://web3py.readthedocs.io/) चा वापर करतात. Web3.py ही एक लायब्ररी आहे जी तुम्हाला Ethereum नोडशी जोडण्याची आणि त्यातून डेटा पाठवण्याची आणि प्राप्त करण्याची पद्धत खूप सोपी करते.

<FeaturedText>टीप: “Ethereum नोड” आणि “Ethereum क्लायंट” हे शब्द एकमेकांसाठी वापरले जातात. दोन्ही बाबतीत, याचा अर्थ Ethereum नेटवर्कमधील एक सहभागी चालवत असलेले सॉफ्टवेअर असा होतो. हे सॉफ्टवेअर ब्लॉक डेटा वाचू शकते, चेनमध्ये नवीन ब्लॉक जोडल्यावर अपडेट्स मिळवू शकते, नवीन व्यवहार प्रसारित करू शकते आणि बरेच काही. तांत्रिकदृष्ट्या, क्लायंट हे सॉफ्टवेअर आहे, तर नोड हे सॉफ्टवेअर चालवणारा संगणक आहे.</FeaturedText>

[Ethereum क्लायंट](/developers/docs/nodes-and-clients/) [IPC](https://wikipedia.org/wiki/Inter-process_communication), HTTP, किंवा Websockets द्वारे पोहोचण्यायोग्य होण्यासाठी कॉन्फिगर केले जाऊ शकतात, म्हणून Web3.py ला हे कॉन्फिगरेशन प्रतिबिंबित करावे लागेल. Web3.py या कनेक्शन पर्यायांना **प्रोव्हायडर्स** म्हणून संबोधते. Web3.py इंस्टन्सला तुमच्या नोडशी जोडण्यासाठी तुम्हाला तीन प्रोव्हायडर्सपैकी एक निवडावा लागेल.

![तुमचा ॲप्लिकेशन Ethereum नोडशी जोडण्यासाठी web3.py IPC चा कसा वापर करते हे दर्शवणारे एक चित्र](./web3py-and-nodes.png)

_Ethereum नोड आणि Web3.py ला एकाच प्रोटोकॉलद्वारे संवाद साधण्यासाठी कॉन्फिगर करा, उदा., या चित्रात IPC._

एकदा Web3.py योग्यरित्या कॉन्फिगर झाल्यावर, तुम्ही ब्लॉकचेनशी संवाद साधण्यास सुरुवात करू शकता. पुढे काय येणार आहे याची झलक म्हणून येथे Web3.py वापराची काही उदाहरणे आहेत:

```python
# ब्लॉक डेटा वाचा:
w3.eth.get_block('latest')

# एक व्यवहार पाठवा:
w3.eth.send_transaction({'from': ..., 'to': ..., 'value': ...})
```

## इन्स्टॉलेशन {#installation}

या वॉकथ्रूमध्ये, आपण फक्त Python इंटरप्रिटरमध्ये काम करणार आहोत. आपण कोणत्याही डिरेक्टरीज, फाइल्स, क्लासेस किंवा फंक्शन्स तयार करणार नाही.

<FeaturedText>टीप: खालील उदाहरणांमध्ये, `$` ने सुरू होणारे कमांड्स टर्मिनलमध्ये चालवण्यासाठी आहेत. ( `$ ` टाइप करू नका, ते फक्त ओळीची सुरुवात दर्शवते.)</FeaturedText>

सर्वप्रथम, एक्सप्लोर करण्यासाठी वापरकर्ता-स्नेही वातावरणासाठी [IPython](https://ipython.org/) इंस्टॉल करा. IPython टॅब कंप्लिशनसारख्या इतर वैशिष्ट्यांसह, Web3.py मध्ये काय शक्य आहे हे पाहणे खूप सोपे करते.

```bash
pip install ipython
```

Web3.py `web3` या नावाने प्रकाशित केले आहे. ते असे इंस्टॉल करा:

```bash
pip install web3
```

आणखी एक गोष्ट - आपण नंतर एक ब्लॉकचेन सिम्युलेट करणार आहोत, ज्यासाठी आणखी काही डिपेन्डन्सीज आवश्यक आहेत. तुम्ही त्या याप्रमाणे इंस्टॉल करू शकता:

```bash
pip install 'web3[tester]'
```

तुम्ही आता पूर्णपणे तयार आहात!

टीप: `web3[tester]` पॅकेज Python 3.10.xx पर्यंत काम करते.

## एक सँडबॉक्स सुरू करा {#spin-up-a-sandbox}

तुमच्या टर्मिनलमध्ये `ipython` रन करून एक नवीन Python एन्व्हायर्नमेंट उघडा. हे `python` रन करण्यासारखेच आहे, परंतु यात अधिक अतिरिक्त वैशिष्ट्ये आहेत.

```bash
ipython
```

हे तुम्ही चालवत असलेल्या Python आणि IPython च्या आवृत्त्यांविषयी काही माहिती प्रिंट करेल, त्यानंतर तुम्हाला इनपुटची वाट पाहणारा एक प्रॉम्प्ट दिसेल:

```python
In [1]:
```

तुम्ही आता एक इंटरॲक्टिव्ह Python शेल पाहत आहात. मूलतः, हे खेळण्यासाठी एक सँडबॉक्स आहे. जर तुम्ही इथपर्यंत पोहोचला असाल, तर आता Web3.py इम्पोर्ट करण्याची वेळ आली आहे:

```python
In [1]: from web3 import Web3
```

## Web3 मॉड्यूलची ओळख {#introducing-the-web3-module}

Ethereum चे प्रवेशद्वार असण्याव्यतिरिक्त, [Web3](https://web3py.readthedocs.io/en/stable/overview.html#base-api) मॉड्यूल काही सोयीस्कर फंक्शन्स देखील प्रदान करते. चला काही एक्सप्लोर करूया.

एका Ethereum ॲप्लिकेशनमध्ये, तुम्हाला सामान्यतः चलनाची परिमाणे (denominations) रूपांतरित करण्याची आवश्यकता असेल. Web3 मॉड्यूल यासाठीच काही हेल्पर मेथड्स पुरवते: [from_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.from_wei) आणि [to_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.to_wei).

<FeaturedText>
टीप: संगणक दशांश गणित हाताळण्यात कुप्रसिद्ध आहेत. यावर मात करण्यासाठी, डेव्हलपर्स अनेकदा डॉलरची रक्कम सेंटमध्ये साठवतात. उदाहरणार्थ, $5.99 किंमत असलेली वस्तू डेटाबेसमध्ये 599 म्हणून साठवली जाऊ शकते.

<b>ईथर</b>मधील व्यवहार हाताळतानाही असाच पॅटर्न वापरला जातो. तथापि, दोन दशांश स्थळांऐवजी, ईथरला 18 आहेत! ईथरच्या सर्वात लहान परिमाणाला <b>wei</b> म्हणतात, म्हणून व्यवहार पाठवताना तेच मूल्य निर्दिष्ट केले जाते.

1 ईथर = 1000000000000000000 wei

1 wei = 0.000000000000000001 ईथर

</FeaturedText>

काही मूल्ये wei मध्ये आणि wei मधून रूपांतरित करण्याचा प्रयत्न करा. लक्षात घ्या की ईथर आणि wei मध्ये [अनेक परिमाणांसाठी नावे आहेत](https://web3py.readthedocs.io/en/stable/troubleshooting.html#how-do-i-convert-currency-denominations). त्यापैकी एक अधिक प्रसिद्ध नाव म्हणजे **gwei**, कारण व्यवहार शुल्क अनेकदा यात दर्शवले जाते.

```python
In [2]: Web3.to_wei(1, 'ether')
Out[2]: 1000000000000000000

In [3]: Web3.from_wei(500000000, 'gwei')
Out[3]: Decimal('0.5')
```

Web3 मॉड्यूलवरील इतर युटिलिटी मेथड्समध्ये डेटा फॉरमॅट कन्व्हर्टर्स (उदा., [`toHex`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.toHex)), ॲड्रेस हेल्पर्स (उदा., [`isAddress`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.isAddress)), आणि हॅश फंक्शन्स (उदा., [`keccak`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.keccak)) यांचा समावेश आहे. यापैकी बऱ्याच गोष्टी या मालिकेत नंतर समाविष्ट केल्या जातील. सर्व उपलब्ध मेथड्स आणि प्रॉपर्टीज पाहण्यासाठी, `Web3` टाइप करून IPython च्या ऑटो-कम्प्लीटचा वापर करा. आणि पीरियडनंतर टॅब की दोनदा दाबा.

## चेनशी बोला {#talk-to-the-chain}

सोयीस्कर मेथड्स छान आहेत, पण चला आता ब्लॉकचेनकडे वळूया. पुढील पायरी म्हणजे Ethereum नोडशी संवाद साधण्यासाठी Web3.py कॉन्फिगर करणे. येथे आपल्याकडे IPC, HTTP किंवा Websocket प्रोव्हायडर्स वापरण्याचा पर्याय आहे.

आपण या मार्गावर जाणार नाही, परंतु HTTP प्रोव्हायडर वापरून संपूर्ण वर्कफ्लोचे उदाहरण असे काहीतरी दिसेल:

- एक Ethereum नोड डाउनलोड करा, उदा., [Geth](https://geth.ethereum.org/).
- एका टर्मिनल विंडोमध्ये Geth सुरू करा आणि नेटवर्क सिंक होण्याची वाट पाहा. डीफॉल्ट HTTP पोर्ट `8545` आहे, पण ते कॉन्फिगर करता येते.
- `localhost:8545` वर HTTP द्वारे नोडशी कनेक्ट करण्यासाठी Web3.py ला सांगा.
  `w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))`
- नोडशी संवाद साधण्यासाठी `w3` इंस्टन्स वापरा.

हे करण्याची ही एक “वास्तविक” पद्धत असली तरी, सिंक करण्याच्या प्रक्रियेला तास लागतात आणि जर तुम्हाला फक्त एक डेव्हलपमेंट एन्व्हायर्नमेंट हवे असेल तर ते अनावश्यक आहे. Web3.py या उद्देशासाठी चौथा प्रोव्हायडर उपलब्ध करतो, तो म्हणजे **EthereumTesterProvider**. हा टेस्टर प्रोव्हायडर एका सिम्युलेटेड Ethereum नोडला जोडतो, ज्यामध्ये शिथिल परवानग्या आणि खेळण्यासाठी बनावट चलन असते.

![EthereumTesterProvider तुमच्या web3.py ॲप्लिकेशनला सिम्युलेटेड Ethereum नोडशी जोडत असल्याचे दर्शवणारे एक चित्र](./ethereumtesterprovider.png)

_EthereumTesterProvider एका सिम्युलेटेड नोडशी कनेक्ट होतो आणि जलद डेव्हलपमेंट एन्व्हायर्नमेंटसाठी उपयुक्त आहे._

त्या सिम्युलेटेड नोडला [eth-tester](https://github.com/ethereum/eth-tester) म्हणतात आणि आपण तो `pip install web3[tester]` कमांडचा भाग म्हणून इंस्टॉल केला. या टेस्टर प्रोव्हायडरचा वापर करण्यासाठी Web3.py कॉन्फिगर करणे इतके सोपे आहे:

```python
In [4]: w3 = Web3(Web3.EthereumTesterProvider())
```

आता तुम्ही चेन सर्फ करण्यास तयार आहात! असं सहसा कोणी म्हणत नाही. मी हे आताच तयार केले. चला एक छोटीशी सफर करूया.

## छोटीशी सफर {#the-quick-tour}

सर्वात आधी, एक सॅनिटी चेक:

```python
In [5]: w3.is_connected()
Out[5]: True
```

आपण टेस्टर प्रोव्हायडर वापरत असल्यामुळे, ही चाचणी खूप महत्त्वाची नाही, पण जर ती अयशस्वी झाली, तर शक्यता आहे की `w3` व्हेरिएबल इन्स्टँटिएट करताना तुम्ही काहीतरी चुकीचे टाइप केले असेल. तुम्ही आतील कंस समाविष्ट केले आहेत याची खात्री करा, म्हणजे `Web3.EthereumTesterProvider()`.

## सफरीचा थांबा #1: [खाती](/developers/docs/accounts/) {#tour-stop-1-accounts}

सोयीसाठी, टेस्टर प्रोव्हायडरने काही खाती तयार केली आहेत आणि त्यात आधीच चाचणीसाठी ईथर भरलेले आहेत.

प्रथम, त्या खात्यांची यादी पाहूया:

```python
In [6]: w3.eth.accounts
Out[6]: ['0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
 '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
 '0x6813Eb9362372EEF6200f3b1dbC3f819671cBA69', ...]
```

तुम्ही हा कमांड चालवल्यास, तुम्हाला `0x` ने सुरू होणाऱ्या दहा स्ट्रिंगची यादी दिसेल. प्रत्येक एक **पब्लिक ॲड्रेस** आहे आणि काही बाबतीत, तो चेकिंग खात्यावरील खाते क्रमांकासारखा आहे. तुम्हाला ईथर पाठवू इच्छिणाऱ्या व्यक्तीला तुम्ही हा ॲड्रेस द्याल.

सांगितल्याप्रमाणे, टेस्टर प्रोव्हायडरने या प्रत्येक खात्यात काही चाचणी ईथर आधीच भरलेले आहेत. पहिल्या खात्यात किती शिल्लक आहे ते पाहूया:

```python
In [7]: w3.eth.get_balance(w3.eth.accounts[0])
Out[7]: 1000000000000000000000000
```

किती तरी शून्य आहेत! खोट्या बँकेत जाऊन आनंद साजरा करण्यापूर्वी, चलनांच्या परिमाणांबद्दलचा पूर्वीचा धडा आठवा. ईथर मूल्ये सर्वात लहान परिमाण, wei मध्ये दर्शविली जातात. ते ईथरमध्ये रूपांतरित करा:

```python
In [8]: w3.from_wei(1000000000000000000000000, 'ether')
Out[8]: Decimal('1000000')
```

दहा लाख चाचणी ईथर - तरीही वाईट नाही.

## सफरीचा थांबा #2: ब्लॉक डेटा {#tour-stop-2-block-data}

या सिम्युलेटेड ब्लॉकचेनच्या स्थितीवर एक नजर टाकूया:

```python
In [9]: w3.eth.get_block('latest')
Out[9]: AttributeDict({
   'number': 0,
   'hash': HexBytes('0x9469878...'),
   'parentHash': HexBytes('0x0000000...'),
   ...
   'transactions': []
})
```

एका ब्लॉकबद्दल बरीच माहिती परत मिळते, पण येथे फक्त काही गोष्टी नमूद करायच्या आहेत:

- ब्लॉक क्रमांक शून्य आहे - तुम्ही टेस्टर प्रोव्हायडर कितीही वेळापूर्वी कॉन्फिगर केले असले तरीही. वास्तविक Ethereum नेटवर्कच्या विपरीत, जे दर 12 सेकंदांनी एक नवीन ब्लॉक जोडते, हे सिम्युलेशन तुम्ही त्याला काही काम देईपर्यंत थांबेल.
- `transactions` ही एक रिकामी यादी आहे, त्याच कारणासाठी: आपण अद्याप काहीही केलेले नाही. हा पहिला ब्लॉक एक **रिकामा ब्लॉक** आहे, फक्त चेन सुरू करण्यासाठी.
- लक्षात घ्या की `parentHash` फक्त रिकाम्या बाइट्सचा एक समूह आहे. हे सूचित करते की हा चेनमधील पहिला ब्लॉक आहे, ज्याला **जेनेसिस ब्लॉक** असेही म्हणतात.

## सफरीचा थांबा #3: [व्यवहार](/developers/docs/transactions/) {#tour-stop-3-transactions}

आपण ब्लॉक शून्यवर अडकलो आहोत जोपर्यंत प्रलंबित व्यवहार होत नाही, चला तर मग एक व्यवहार करूया. एका खात्यातून दुसऱ्या खात्यात काही चाचणी ईथर पाठवा:

```python
In [10]: tx_hash = w3.eth.send_transaction({
   'from': w3.eth.accounts[0],
   'to': w3.eth.accounts[1],
   'value': w3.to_wei(3, 'ether'),
   'gas': 21000
})
```

हा सहसा तो क्षण असतो जिथे तुम्ही तुमचा व्यवहार नवीन ब्लॉकमध्ये समाविष्ट होण्यासाठी काही सेकंद वाट पाहता. संपूर्ण प्रक्रिया काहीशी अशी आहे:

1. एक व्यवहार सबमिट करा आणि व्यवहार हॅश जपून ठेवा. व्यवहार असलेला ब्लॉक तयार आणि प्रसारित होईपर्यंत, व्यवहार “प्रलंबित” असतो.
   `tx_hash = w3.eth.send_transaction({ … })`
2. व्यवहार ब्लॉकमध्ये समाविष्ट होण्याची वाट पाहा:
   `w3.eth.wait_for_transaction_receipt(tx_hash)`
3. ॲप्लिकेशन लॉजिक सुरू ठेवा. यशस्वी व्यवहार पाहण्यासाठी:
   `w3.eth.get_transaction(tx_hash)`

आमचे सिम्युलेटेड एन्व्हायर्नमेंट व्यवहार तात्काळ एका नवीन ब्लॉकमध्ये जोडेल, त्यामुळे आपण लगेच व्यवहार पाहू शकतो:

```python
In [11]: w3.eth.get_transaction(tx_hash)
Out[11]: AttributeDict({
   'hash': HexBytes('0x15e9fb95dc39...'),
   'blockNumber': 1,
   'transactionIndex': 0,
   'from': '0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
   'to': '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
   'value': 3000000000000000000,
   ...
})
```

तुम्हाला येथे काही ओळखीचे तपशील दिसतील: `from`, `to` आणि `value` फील्ड्स आपल्या `send_transaction` कॉलच्या इनपुटशी जुळले पाहिजेत. दुसरी दिलासादायक गोष्ट म्हणजे हा व्यवहार ब्लॉक क्रमांक 1 मध्ये पहिला व्यवहार (`'transactionIndex': 0`) म्हणून समाविष्ट केला गेला.

या व्यवहाराची यशस्वीता आपण दोन्ही संबंधित खात्यांमधील शिल्लक तपासून सहज पडताळू शकतो. तीन ईथर एका खात्यातून दुसऱ्या खात्यात हस्तांतरित झाले पाहिजेत.

```python
In [12]: w3.eth.get_balance(w3.eth.accounts[0])
Out[12]: 999996999979000000000000

In [13]: w3.eth.get_balance(w3.eth.accounts[1])
Out[13]: 1000003000000000000000000
```

दुसरे बरोबर दिसत आहे! शिल्लक 1,000,000 वरून 1,000,003 ईथर झाली. पण पहिल्या खात्याचे काय झाले? असे दिसते की त्याने तीन ईथरपेक्षा थोडे जास्त गमावले आहेत. अरेरे, जीवनात काहीही विनामूल्य नाही, आणि Ethereum सार्वजनिक नेटवर्क वापरण्यासाठी तुम्हाला तुमच्या पीअर्सना त्यांच्या सहाय्यक भूमिकेसाठी भरपाई देणे आवश्यक आहे. व्यवहार सबमिट करणाऱ्या खात्यातून एक छोटे व्यवहार शुल्क कापले गेले - हे शुल्क म्हणजे गॅसच्या जळलेल्या प्रमाणाला (ETH हस्तांतरणासाठी 21000 गॅस युनिट्स) नेटवर्कच्या क्रियाकलापानुसार बदलणाऱ्या बेस फीने गुणले जाते, अधिक व्यवहाराला ब्लॉकमध्ये समाविष्ट करणाऱ्या व्हॅलिडेटरला जाणारी टीप.

[गॅस](/developers/docs/gas/#post-london) बद्दल अधिक

<FeaturedText>टीप: सार्वजनिक नेटवर्कवर, व्यवहार शुल्क नेटवर्कच्या मागणीनुसार आणि तुम्हाला व्यवहार किती लवकर प्रक्रिया करायचा आहे यावर अवलंबून बदलते. तुम्हाला शुल्क कसे मोजले जाते याच्या तपशिलात स्वारस्य असल्यास, माझी <a href="https://medium.com/ethereum-grid/ethereum-101-how-are-transactions-included-in-a-block-9ae5f491853f">ब्लॉकमध्ये व्यवहार कसे समाविष्ट केले जातात</a> यावरील पूर्वीची पोस्ट पाहा.</FeaturedText>

## आणि श्वास घ्या {#and-breathe}

आपण हे बऱ्याच वेळेपासून करत आहोत, त्यामुळे ब्रेक घेण्यासाठी हे एक चांगले ठिकाण आहे. हे गहन जग पुढेही चालू आहे, आणि आपण या मालिकेच्या दुसऱ्या भागात एक्सप्लोर करणे सुरू ठेवू. येणाऱ्या काही संकल्पना: वास्तविक नोडशी कनेक्ट करणे, स्मार्ट कॉन्ट्रॅक्ट्स आणि टोकन्स. तुमचे काही पुढील प्रश्न आहेत का? मला कळवा! तुमचा अभिप्राय आपण येथून पुढे कुठे जायचे हे ठरवेल. [Twitter](https://twitter.com/wolovim) द्वारे विनंत्यांचे स्वागत आहे.
