---
title: "यलो पेपरचे EVM स्पेसिफिकेशन्स समजून घेणे"
description: "यलो पेपरचा, Ethereum च्या औपचारिक स्पेसिफिकेशन्सचा तो भाग समजून घेणे, जो Ethereum व्हर्च्युअल मशीन (EVM) चे स्पष्टीकरण देतो."
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: mr
published: 2022-05-15
---

[यलो पेपर](https://ethereum.github.io/yellowpaper/paper.pdf) हे Ethereum साठीचे औपचारिक स्पेसिफिकेशन आहे. [EIP प्रक्रियेद्वारे](/eips/) सुधारित केलेले ठिकाण वगळता, त्यात सर्व काही कसे कार्य करते याचे अचूक वर्णन आहे. हे एक गणितीय पेपर म्हणून लिहिले आहे, ज्यामध्ये अशी परिभाषा आहे जी प्रोग्रामरना परिचित वाटणार नाही. या पेपरमध्ये तुम्ही ते कसे वाचावे हे शिकाल, आणि त्याचबरोबर इतर संबंधित गणितीय पेपर्स कसे वाचावेत हे देखील शिकाल.

## कोणता यलो पेपर? {#which-yellow-paper}

Ethereum मधील इतर बहुतेक गोष्टींप्रमाणेच, यलो पेपर देखील कालांतराने विकसित होतो. एका विशिष्ट आवृत्तीचा संदर्भ देता यावा यासाठी, मी [लिहिण्याच्या वेळी असलेली सध्याची आवृत्ती](yellow-paper-berlin.pdf) अपलोड केली आहे. मी वापरत असलेले विभाग, पृष्ठ आणि समीकरण क्रमांक त्याच आवृत्तीचा संदर्भ देतील. हे डॉक्युमेंट वाचताना दुसऱ्या विंडोमध्ये उघडे ठेवणे ही एक चांगली कल्पना आहे.

### EVM का? {#why-the-evm}

मूळ यलो पेपर Ethereum च्या विकासाच्या अगदी सुरुवातीला लिहिला गेला होता. हे मूळ प्रूफ-ऑफ-वर्क-आधारित सहमती यंत्रणेचे वर्णन करते जी मूळतः नेटवर्क सुरक्षित करण्यासाठी वापरली गेली होती. तथापि, Ethereum ने प्रूफ-ऑफ-वर्क बंद केले आणि सप्टेंबर 2022 मध्ये प्रूफ-ऑफ-स्टेक-आधारित सहमती वापरण्यास सुरुवात केली. हे ट्यूटोरियल यलो पेपरच्या त्या भागांवर लक्ष केंद्रित करेल जे Ethereum व्हर्च्युअल मशीनची व्याख्या करतात. प्रूफ-ऑफ-स्टेकमध्ये संक्रमण झाल्यामुळे EVM मध्ये कोणताही बदल झाला नाही (DIFFICULTY ऑपकोडच्या रिटर्न व्हॅल्यू वगळता).

## 9 एक्झिक्युशन मॉडेल {#9-execution-model}

या विभागात (पृ. 12-14) EVM च्या व्याख्येचा बहुतेक भाग समाविष्ट आहे.

_सिस्टम स्टेट_ या शब्दात सिस्टीम चालवण्यासाठी तुम्हाला ज्या सर्व गोष्टींची माहिती असणे आवश्यक आहे त्या सर्वांचा समावेश होतो. एका सामान्य संगणकात, याचा अर्थ मेमरी, रजिस्टर्समधील मजकूर, इत्यादी.

[ट्युरिंग मशीन](https://en.wikipedia.org/wiki/Turing_machine) हे एक संगणकीय मॉडेल आहे. मूलतः, ही संगणकाची एक सोपी आवृत्ती आहे, जी एक सामान्य संगणक करू शकणाऱ्या गणना चालवण्याची समान क्षमता असल्याचे सिद्ध झाले आहे (एक संगणक जे काही मोजू शकतो ते ट्युरिंग मशीन मोजू शकते आणि याउलट). हे मॉडेल काय गणनीय आहे आणि काय नाही याबद्दलचे विविध प्रमेय सिद्ध करणे सोपे करते.

[ट्युरिंग-कम्प्लीट](https://en.wikipedia.org/wiki/Turing_completeness) या शब्दाचा अर्थ एक संगणक आहे जो ट्युरिंग मशीनसारखीच गणना करू शकतो. ट्युरिंग मशीन्स अनंत लूपमध्ये अडकू शकतात, आणि EVM अडकू शकत नाही कारण त्यात गॅस संपेल, त्यामुळे ते फक्त क्वासी-ट्युरिंग-कम्प्लीट आहे.

## 9.1 मूलभूत गोष्टी {#91-basics}

हा विभाग EVM च्या मूलभूत गोष्टी सांगतो आणि इतर संगणकीय मॉडेल्सशी त्याची तुलना कशी केली जाते.

[स्टॅक मशीन](https://en.wikipedia.org/wiki/Stack_machine) हे एक संगणक आहे जे मध्यवर्ती डेटा रजिस्टर्समध्ये नाही, तर [**स्टॅक**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)) मध्ये संग्रहित करते. व्हर्च्युअल मशीनसाठी हे प्राधान्यकृत आर्किटेक्चर आहे कारण ते लागू करणे सोपे आहे, याचा अर्थ असा की बग्स आणि सुरक्षा भेद्यता खूप कमी असण्याची शक्यता असते. स्टॅकमधील मेमरी 256-बिट वर्ड्समध्ये विभागलेली आहे. हे निवडले गेले कारण ते Ethereum च्या मुख्य क्रिप्टोग्राफिक ऑपरेशन्ससाठी सोयीस्कर आहे, जसे की Keccak-256 हॅशिंग आणि एलिप्टिक कर्व्ह कॅल्क्युलेशन्स. स्टॅकचा कमाल आकार 1024 आयटम्स (1024 x 256 बिट्स) आहे. जेव्हा ऑपकोड्स कार्यान्वित केले जातात तेव्हा ते सहसा त्यांचे पॅरामीटर्स स्टॅकमधून मिळवतात. स्टॅकमधील घटकांची पुनर्रचना करण्यासाठी विशेषतः ऑपकोड्स आहेत जसे की `POP` (स्टॅकच्या वरून आयटम काढून टाकते), `DUP_N` (स्टॅकमधील N'व्या आयटमची डुप्लिकेट करते), इत्यादी.

EVM मध्ये **मेमरी** नावाची एक अस्थिर जागा देखील आहे जी एक्झिक्युशन दरम्यान डेटा संग्रहित करण्यासाठी वापरली जाते. ही मेमरी 32-बाइट वर्ड्समध्ये आयोजित केली जाते. सर्व मेमरी लोकेशन्स शून्यावर इनिशिअलाइज केली जातात. जर तुम्ही मेमरीमध्ये एक वर्ड जोडण्यासाठी हा [Yul](https://docs.soliditylang.org/en/latest/yul.html) कोड कार्यान्वित केला, तर तो वर्डमधील रिकामी जागा शून्यांनी पॅड करून 32 बाइट्स मेमरी भरेल, म्हणजे, तो एक वर्ड तयार करतो - लोकेशन्स 0-29 मध्ये शून्य, 30 वर 0x60, आणि 31 वर 0xA7.

```yul
mstore(0, 0x60A7)
```

`mstore` हे EVM द्वारे मेमरीशी संवाद साधण्यासाठी प्रदान केलेल्या तीन ऑपकोड्सपैकी एक आहे - ते मेमरीमध्ये एक वर्ड लोड करते. इतर दोन `mstore8` आहेत जे मेमरीमध्ये एकच बाइट लोड करते, आणि `mload` जे मेमरीतून स्टॅकवर एक वर्ड हलवते.

EVM मध्ये एक वेगळे नॉन-व्होलाटाईल **स्टोरेज** मॉडेल देखील आहे जे सिस्टम स्टेटचा एक भाग म्हणून राखले जाते - ही मेमरी वर्ड अॅरेमध्ये आयोजित केली जाते (स्टॅकमधील वर्ड-अॅड्रेसेबल बाइट अॅरेच्या विपरीत). हे स्टोरेज असे आहे जिथे कॉन्ट्रॅक्ट्स पर्सिस्टंट डेटा ठेवतात - एक कॉन्ट्रॅक्ट फक्त त्याच्या स्वतःच्या स्टोरेजशी संवाद साधू शकतो. स्टोरेज की-व्हॅल्यू मॅपिंगमध्ये आयोजित केले जाते.

यलो पेपरच्या या विभागात याचा उल्लेख नसला तरी, चौथ्या प्रकारची मेमरी आहे हे जाणून घेणे देखील उपयुक्त आहे. **कॉलडेटा** ही बाइट-अॅड्रेसेबल रीड-ओन्ली मेमरी आहे जी व्यवहाराच्या `data` पॅरामीटरसह पास केलेले मूल्य संग्रहित करण्यासाठी वापरली जाते. EVM मध्ये `calldata` व्यवस्थापित करण्यासाठी विशिष्ट ऑपकोड्स आहेत. `calldatasize` डेटाचा आकार परत करते. `calldataload` डेटा स्टॅकमध्ये लोड करते. `calldatacopy` डेटा मेमरीमध्ये कॉपी करते.

मानक [वॉन न्यूमन आर्किटेक्चर](https://en.wikipedia.org/wiki/Von_Neumann_architecture) कोड आणि डेटा एकाच मेमरीमध्ये संग्रहित करते. EVM सुरक्षिततेच्या कारणास्तव या मानकाचे पालन करत नाही - अस्थिर मेमरी शेअर केल्याने प्रोग्राम कोड बदलणे शक्य होते. त्याऐवजी, कोड स्टोरेजमध्ये सेव्ह केला जातो.

अशी फक्त दोन प्रकरणे आहेत ज्यात कोड मेमरीमधून कार्यान्वित केला जातो:

- जेव्हा एखादा कॉन्ट्रॅक्ट दुसरा कॉन्ट्रॅक्ट तयार करतो ([`CREATE`](https://www.evm.codes/#f0) किंवा [`CREATE2`](https://www.evm.codes/#f5) वापरून), कॉन्ट्रॅक्ट कंस्ट्रक्टरसाठीचा कोड मेमरीमधून येतो.
- _कोणत्याही_ कॉन्ट्रॅक्टच्या निर्मितीदरम्यान, कंस्ट्रक्टर कोड चालतो आणि नंतर प्रत्यक्ष कॉन्ट्रॅक्टच्या कोडसह परत येतो, तो देखील मेमरीमधून.

अपवादात्मक एक्झिक्युशन या शब्दाचा अर्थ असा आहे की असा अपवाद ज्यामुळे सध्याच्या कॉन्ट्रॅक्टचे एक्झिक्युशन थांबते.

## 9.2 शुल्काचे अवलोकन {#92-fees-overview}

हा विभाग गॅस शुल्क कसे मोजले जाते हे स्पष्ट करतो. तीन खर्च आहेत:

### ऑपकोड खर्च {#opcode-cost}

विशिष्ट ऑपकोडचा अंतर्भूत खर्च. हे मूल्य मिळविण्यासाठी, परिशिष्ट H (पृ. 28, समीकरण (327) अंतर्गत) मध्ये ऑपकोडचा खर्च गट शोधा आणि समीकरण (324) मध्ये खर्च गट शोधा. हे तुम्हाला एक खर्च फंक्शन देते, जे बहुतेक प्रकरणांमध्ये परिशिष्ट G (पृ. 27) मधील पॅरामीटर्स वापरते.

उदाहरणार्थ, ऑपकोड [`CALLDATACOPY`](https://www.evm.codes/#37) हा _W<sub>copy</sub>_ गटाचा सदस्य आहे. त्या गटासाठी ऑपकोड खर्च _G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_ आहे. परिशिष्ट G पाहता, आपल्याला दिसते की दोन्ही स्थिरांक 3 आहेत, जे आपल्याला _3+3×⌈μ<sub>s</sub>[2]÷32⌉_ देते.

आपल्याला अजूनही _⌈μ<sub>s</sub>[2]÷32⌉_ या अभिव्यक्तीचा अर्थ लावणे आवश्यक आहे. सर्वात बाहेरील भाग, _⌈ \<मूल्य\> ⌉_ हे सीलिंग फंक्शन आहे, एक फंक्शन जे दिलेले मूल्य परत करते जो सर्वात लहान पूर्णांक आहे जो अजूनही मूल्यापेक्षा लहान नाही. उदाहरणार्थ, _⌈2.5⌉ = ⌈3⌉ = 3_. आतील भाग _μ<sub>s</sub>[2]÷32_ आहे. पृष्ठ 3 वरील विभाग 3 (संकेत) पाहता, _μ_ ही मशीन स्टेट आहे. मशीन स्टेटची व्याख्या पृष्ठ 13 वरील विभाग 9.4.1 मध्ये केली आहे. त्या विभागानुसार, मशीन स्टेट पॅरामीटर्सपैकी एक स्टॅकसाठी _s_ आहे. हे सर्व एकत्र ठेवल्यास, असे दिसते की _μ<sub>s</sub>[2]_ हे स्टॅकमधील स्थान #2 आहे. [ऑपकोड](https://www.evm.codes/#37) पाहता, स्टॅकमधील स्थान #2 म्हणजे डेटाचा आकार बाइट्समध्ये. W<sub>copy</sub> गटातील इतर ऑपकोड्स, [`CODECOPY`](https://www.evm.codes/#39) आणि [`RETURNDATACOPY`](https://www.evm.codes/#3e) पाहता, त्यांच्याकडे त्याच ठिकाणी डेटाचा आकार देखील असतो. त्यामुळे _⌈μ<sub>s</sub>[2]÷32⌉_ म्हणजे कॉपी केल्या जात असलेल्या डेटाला संग्रहित करण्यासाठी आवश्यक असलेल्या 32 बाइट शब्दांची संख्या. सर्वकाही एकत्र ठेवल्यास, [`CALLDATACOPY`](https://www.evm.codes/#37) चा अंतर्भूत खर्च 3 गॅस अधिक कॉपी केल्या जाणाऱ्या डेटाच्या प्रति वर्ड 3 आहे.

### चालू खर्च {#running-cost}

आपण कॉल करत असलेल्या कोडला चालवण्याचा खर्च.

- [`CREATE`](https://www.evm.codes/#f0) आणि [`CREATE2`](https://www.evm.codes/#f5) च्या बाबतीत, नवीन कॉन्ट्रॅक्टसाठीचा कंस्ट्रक्टर.
- [`CALL`](https://www.evm.codes/#f1), [`CALLCODE`](https://www.evm.codes/#f2), [`STATICCALL`](https://www.evm.codes/#fa), किंवा [`DELEGATECALL`](https://www.evm.codes/#f4) च्या बाबतीत, आपण ज्या कॉन्ट्रॅक्टला कॉल करतो तो.

### मेमरी विस्तार खर्च {#expanding-memory-cost}

मेमरी विस्तारण्याचा खर्च (आवश्यक असल्यास).

समीकरण 324 मध्ये, हे मूल्य _C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_ असे लिहिले आहे. विभाग 9.4.1 पुन्हा पाहता, आपल्याला दिसते की _μ<sub>i</sub>_ हे मेमरीमधील शब्दांची संख्या आहे. त्यामुळे _μ<sub>i</sub>_ हे ऑपकोडच्या आधी मेमरीमधील शब्दांची संख्या आहे आणि _μ<sub>i</sub>'_ हे ऑपकोडनंतर मेमरीमधील शब्दांची संख्या आहे.

_C<sub>mem</sub>_ हे फंक्शन समीकरण 326 मध्ये परिभाषित केले आहे: _C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_. ⌊x⌋ हे फ्लोअर फंक्शन आहे, एक फंक्शन जे दिलेले मूल्य परत करते जो सर्वात मोठा पूर्णांक आहे जो अजूनही मूल्यापेक्षा मोठा नाही. उदाहरणार्थ, ⌊2.5⌋ = ⌊2⌋ = 2._ जेव्हा _a < √512_, _a<sup>2</sup> < 512_, आणि फ्लोअर फंक्शनचा परिणाम शून्य असतो. त्यामुळे पहिल्या 22 शब्दांसाठी (704 बाइट्स), खर्च आवश्यक असलेल्या मेमरी शब्दांच्या संख्येसह रेषीयपणे वाढतो. त्या बिंदूच्या पलीकडे _⌊a<sup>2</sup> ÷ 512⌋_ धन असतो. जेव्हा आवश्यक असलेली मेमरी पुरेशी जास्त असते तेव्हा गॅस खर्च मेमरीच्या प्रमाणाच्या वर्गाच्या प्रमाणात असतो.

**टीप** की हे घटक फक्त _अंतर्भूत_ गॅस खर्चावर परिणाम करतात - ते फी मार्केट किंवा व्हॅलिडेटर्सना मिळणाऱ्या टिप्सचा विचार करत नाहीत जे अंतिम वापरकर्त्याला किती पैसे द्यावे लागतील हे ठरवतात - हा फक्त EVM वर विशिष्ट ऑपरेशन चालवण्याचा कच्चा खर्च आहे.

[गॅसविषयी अधिक वाचा](/developers/docs/gas/).

## 9.3 एक्झिक्युशन पर्यावरण {#93-execution-env}

एक्झिक्युशन पर्यावरण हे एक टपल, _I_ आहे, ज्यात अशी माहिती समाविष्ट आहे जी ब्लॉकचेन स्टेट किंवा EVM चा भाग नाही.

| पॅरामीटर        | डेटामध्ये प्रवेश करण्यासाठी ऑपकोड                                                                              | डेटामध्ये प्रवेश करण्यासाठी सॉलिडिटी कोड                     |
| --------------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                                         | `address(this)`                                              |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                                          | `tx.origin`                                                  |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                                        | `tx.gasprice`                                                |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35), इत्यादी.                                          | `msg.data`                                                   |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                                          | `msg.sender`                                                 |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                                       | `msg.value`                                                  |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                                        | `address(this).code`                                         |
| _I<sub>H</sub>_ | ब्लॉक हेडर फील्ड्स, जसे की [`NUMBER`](https://www.evm.codes/#43) आणि [`DIFFICULTY`](https://www.evm.codes/#44) | `block.number`, `block.difficulty`, इत्यादी. |
| _I<sub>e</sub>_ | कॉन्ट्रॅक्ट्समधील कॉल्ससाठी कॉल स्टॅकची खोली (कॉन्ट्रॅक्ट निर्मितीसह)                       |                                                              |
| _I<sub>w</sub>_ | EVM ला स्टेट बदलण्याची परवानगी आहे का, की ते स्टॅटिकली चालत आहे                                                |                                                              |

विभाग 9 चा उर्वरित भाग समजून घेण्यासाठी काही इतर पॅरामीटर्स आवश्यक आहेत:

| पॅरामीटर | या विभागात परिभाषित                                             | अर्थ                                                                                                                                                                                                                                                            |
| -------- | --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _σ_      | 2 (पृ. 2, समीकरण 1)          | ब्लॉकचेनची स्टेट                                                                                                                                                                                                                                                |
| _g_      | 9.3 (पृ. 13) | शिल्लक गॅस                                                                                                                                                                                                                                                      |
| _A_      | 6.1 (पृ. 8)  | एकत्रित सबस्टेट (व्यवहार संपल्यावर नियोजित बदल)                                                                                                                                                                                              |
| _o_      | 9.3 (पृ. 13) | आउटपुट - अंतर्गत व्यवहाराच्या बाबतीत परत आलेला परिणाम (जेव्हा एक कॉन्ट्रॅक्ट दुसऱ्याला कॉल करतो) आणि व्ह्यू फंक्शन्सना केलेले कॉल (जेव्हा तुम्ही फक्त माहिती विचारत असता, त्यामुळे व्यवहारासाठी थांबण्याची आवश्यकता नसते) |

## 9.4 एक्झिक्युशनचे अवलोकन {#94-execution-overview}

आता आपल्याकडे सर्व प्राथमिक गोष्टी आहेत, आपण शेवटी EVM कसे कार्य करते यावर काम करण्यास सुरुवात करू शकतो.

समीकरणे 137-142 आपल्याला EVM चालवण्यासाठीच्या प्रारंभिक अटी देतात:

| चिन्ह            | प्रारंभिक मूल्य                                                                  | अर्थ                                                                                                                                                                                                                                                                                                                 |
| ---------------- | -------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | शिल्लक गॅस                                                                                                                                                                                                                                                                                                           |
| _μ<sub>pc</sub>_ | _0_                                                                              | प्रोग्राम काउंटर, कार्यान्वित करण्याच्या पुढील निर्देशाचा अॅड्रेस                                                                                                                                                                                                                                                    |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | मेमरी, सर्व शून्यांवर इनिशिअलाइज केलेली                                                                                                                                                                                                                                                                              |
| _μ<sub>i</sub>_  | _0_                                                                              | वापरलेले सर्वोच्च मेमरी लोकेशन                                                                                                                                                                                                                                                                                       |
| _μ<sub>s</sub>_  | _()_                                                          | स्टॅक, सुरुवातीला रिकामा                                                                                                                                                                                                                                                                                             |
| _μ<sub>o</sub>_  | _∅_                                                                              | आउटपुट, जोपर्यंत आपण रिटर्न डेटासह ([`RETURN`](https://www.evm.codes/#f3) किंवा [`REVERT`](https://www.evm.codes/#fd)) किंवा त्याशिवाय ([`STOP`](https://www.evm.codes/#00) किंवा [`SELFDESTRUCT`](https://www.evm.codes/#ff)) थांबत नाही तोपर्यंत रिकामा सेट. |

समीकरण 143 आपल्याला सांगते की एक्झिक्युशन दरम्यान प्रत्येक वेळी चार संभाव्य अटी आहेत, आणि त्यांचे काय करायचे:

1. `Z(σ,μ,A,I)`. Z हे एक फंक्शन दर्शवते जे एखादे ऑपरेशन अवैध स्टेट संक्रमण तयार करते की नाही हे तपासते ([अपवादात्मक थांबणे](#942-exceptional-halting) पहा). जर त्याचे मूल्य True आले, तर नवीन स्टेट जुन्या स्टेटसारखीच असते (गॅस जळतो वगळता) कारण बदल लागू केलेले नाहीत.
2. जर कार्यान्वित होणारा ऑपकोड [`REVERT`](https://www.evm.codes/#fd) असेल, तर नवीन स्टेट जुन्या स्टेटसारखीच असते, काही गॅस वाया जातो.
3. जर ऑपरेशन्सचा क्रम पूर्ण झाला असेल, जसे की [`RETURN`](https://www.evm.codes/#f3) द्वारे सूचित केले जाते, तर स्टेट नवीन स्टेटमध्ये अपडेट केली जाते.
4. जर आपण 1-3 या अंतिम अटींपैकी एकात नसू, तर चालवणे सुरू ठेवा.

## 9.4.1 मशीन स्टेट {#941-machine-state}

हा विभाग मशीन स्टेट अधिक तपशीलवार स्पष्ट करतो. हे निर्दिष्ट करते की _w_ हा सध्याचा ऑपकोड आहे. जर _μ<sub>pc</sub>_ हे _||I<sub>b</sub>||_ पेक्षा कमी असेल, जे कोडची लांबी आहे, तर तो बाइट (_I<sub>b</sub>[μ<sub>pc</sub>]_) ऑपकोड आहे. अन्यथा, ऑपकोड [`STOP`](https://www.evm.codes/#00) म्हणून परिभाषित केला आहे.

हे एक [स्टॅक मशीन](https://en.wikipedia.org/wiki/Stack_machine) असल्याने, आपल्याला प्रत्येक ऑपकोडद्वारे बाहेर काढलेल्या (_δ_) आणि आत टाकलेल्या (_α_) आयटमच्या संख्येचा मागोवा ठेवणे आवश्यक आहे.

## 9.4.2 अपवादात्मक थांबणे {#942-exceptional-halt}

हा विभाग _Z_ फंक्शन परिभाषित करतो, जो निर्दिष्ट करतो की आपल्याकडे असामान्य समाप्ती केव्हा होते. हे एक [बूलियन](https://en.wikipedia.org/wiki/Boolean_data_type) फंक्शन आहे, म्हणून ते [लॉजिकल ऑर साठी _∨_](https://en.wikipedia.org/wiki/Logical_disjunction) आणि [लॉजिकल अँड साठी _∧_](https://en.wikipedia.org/wiki/Logical_conjunction) वापरते.

यापैकी कोणतीही अट सत्य असल्यास आम्हाला एक अपवादात्मक थांबा मिळतो:

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  जसे आपण विभाग 9.2 मध्ये पाहिले, _C_ हे फंक्शन आहे जे गॅसचा खर्च निर्दिष्ट करते. पुढील ऑपकोडसाठी पुरेसा गॅस शिल्लक नाही.

- **_δ<sub>w</sub>=∅_**
  जर एखाद्या ऑपकोडसाठी बाहेर काढलेल्या आयटमची संख्या अपरिभाषित असेल, तर ऑपकोड स्वतःच अपरिभाषित असतो.

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  स्टॅक अंडरफ्लो, सध्याच्या ऑपकोडसाठी स्टॅकमध्ये पुरेसे आयटम नाहीत.

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  ऑपकोड [`JUMP`](https://www.evm.codes/#56) आहे आणि अॅड्रेस [`JUMPDEST`](https://www.evm.codes/#5b) नाही. जेव्हा गंतव्यस्थान [`JUMPDEST`](https://www.evm.codes/#5b) असेल तेव्हाच जंप _केवळ_ वैध असतात.

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  ऑपकोड [`JUMPI`](https://www.evm.codes/#57) आहे, अट सत्य आहे (शून्य नाही) त्यामुळे जंप व्हायला हवा, आणि अॅड्रेस [`JUMPDEST`](https://www.evm.codes/#5b) नाही. जेव्हा गंतव्यस्थान [`JUMPDEST`](https://www.evm.codes/#5b) असेल तेव्हाच जंप _केवळ_ वैध असतात.

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  ऑपकोड [`RETURNDATACOPY`](https://www.evm.codes/#3e) आहे. या ऑपकोडमध्ये स्टॅक घटक _μ<sub>s</sub>[1]_ रिटर्न डेटा बफरमध्ये वाचण्यासाठीचा ऑफसेट आहे, आणि स्टॅक घटक _μ<sub>s</sub>[2]_ डेटाची लांबी आहे. जेव्हा तुम्ही रिटर्न डेटा बफरच्या शेवटी पलीकडे वाचण्याचा प्रयत्न करता तेव्हा ही अट उद्भवते. लक्षात घ्या की कॉलडेटासाठी किंवा कोडसाठीच अशीच अट नाही. जेव्हा तुम्ही त्या बफर्सच्या शेवटी पलीकडे वाचण्याचा प्रयत्न करता तेव्हा तुम्हाला फक्त शून्य मिळतात.

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  स्टॅक ओव्हरफ्लो. जर ऑपकोड चालवल्याने 1024 पेक्षा जास्त आयटमचा स्टॅक तयार होणार असेल, तर रद्द करा.

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  आपण स्टॅटिकली चालवत आहोत का ([¬ म्हणजे नकार](https://en.wikipedia.org/wiki/Negation) आणि _I<sub>w</sub>_ सत्य आहे जेव्हा आपल्याला ब्लॉकचेन स्टेट बदलण्याची परवानगी असते)? जर असे असेल, आणि आपण स्टेट बदलणारे ऑपरेशन करण्याचा प्रयत्न करत असू, तर ते होऊ शकत नाही.

  _W(w,μ)_ हे फंक्शन नंतर समीकरण 150 मध्ये परिभाषित केले आहे. यापैकी एक अट सत्य असल्यास _W(w,μ)_ सत्य आहे:

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    हे ऑपकोड्स स्टेट बदलतात, एकतर नवीन कॉन्ट्रॅक्ट तयार करून, मूल्य संग्रहित करून किंवा सध्याचा कॉन्ट्रॅक्ट नष्ट करून.

  - **_LOG0≤w ∧ w≤LOG4_**
    जर आपल्याला स्टॅटिकली कॉल केले असेल तर आपण लॉग नोंदी जारी करू शकत नाही.
    लॉग ऑपकोड्स सर्व [`LOG0` (A0)](https://www.evm.codes/#a0) आणि [`LOG4` (A4)](https://www.evm.codes/#a4) दरम्यानच्या श्रेणीत आहेत.
    लॉग ऑपकोडनंतरची संख्या लॉग एंट्रीमध्ये किती विषय आहेत हे निर्दिष्ट करते.

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    तुम्ही स्टॅटिक असताना दुसऱ्या कॉन्ट्रॅक्टला कॉल करू शकता, पण जर तुम्ही तसे केले तर तुम्ही त्याला ETH हस्तांतरित करू शकत नाही.

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  तुमच्याकडे G<sub>callstipend</sub> (परिशिष्ट G मध्ये 2300 म्हणून परिभाषित) पेक्षा जास्त गॅस असल्याशिवाय तुम्ही [`SSTORE`](https://www.evm.codes/#55) चालवू शकत नाही.

## 9.4.3 जंप डेस्टिनेशन वैधता {#943-jump-dest-valid}

येथे आपण [`JUMPDEST`](https://www.evm.codes/#5b) ऑपकोड्स काय आहेत हे औपचारिकपणे परिभाषित करतो. आपण फक्त 0x5B बाइट मूल्य शोधू शकत नाही, कारण ते PUSH च्या आत असू शकते (आणि म्हणून डेटा आणि ऑपकोड नाही).

समीकरण (153) मध्ये आपण एक फंक्शन, _N(i,w)_ परिभाषित करतो. पहिला पॅरामीटर, _i_, ऑपकोडचे स्थान आहे. दुसरा, _w_, ऑपकोड स्वतःच आहे. जर _w∈[PUSH1, PUSH32]_ असेल तर याचा अर्थ ऑपकोड PUSH आहे (चौरस कंस अंत्यबिंदू समाविष्ट असलेली श्रेणी परिभाषित करतात). त्या बाबतीत पुढील ऑपकोड _i+2+(w−PUSH1)_ येथे आहे. [`PUSH1`](https://www.evm.codes/#60) साठी आपल्याला दोन बाइट्सने पुढे जाणे आवश्यक आहे (PUSH स्वतः आणि एक बाइट मूल्य), [`PUSH2`](https://www.evm.codes/#61) साठी आपल्याला तीन बाइट्सने पुढे जाणे आवश्यक आहे कारण ते दोन बाइट मूल्य आहे, इत्यादी. इतर सर्व EVM ऑपकोड्स फक्त एक बाइट लांब आहेत, म्हणून इतर सर्व प्रकरणांमध्ये _N(i,w)=i+1_.

हे फंक्शन समीकरण (152) मध्ये _D<sub>J</sub>(c,i)_ परिभाषित करण्यासाठी वापरले जाते, जे कोड _c_ मध्ये, ऑपकोड स्थान _i_ पासून सुरू होणाऱ्या सर्व वैध जंप गंतव्यस्थानांचा [संच](https://en.wikipedia.org/wiki/Set_\(mathematics\)) आहे. हे फंक्शन पुनरावृत्तीने परिभाषित केले आहे. जर _i≥||c||_ असेल, तर याचा अर्थ असा की आपण कोडच्या शेवटी किंवा नंतर आहोत. आम्हाला आणखी जंप गंतव्यस्थान सापडणार नाहीत, म्हणून फक्त रिकामा संच परत करा.

इतर सर्व प्रकरणांमध्ये आपण पुढील ऑपकोडवर जाऊन आणि त्यापासून सुरू होणारा संच मिळवून उर्वरित कोड पाहतो. _c[i]_ हा सध्याचा ऑपकोड आहे, म्हणून _N(i,c[i])_ हे पुढील ऑपकोडचे स्थान आहे. _D<sub>J</sub>(c,N(i,c[i]))_ म्हणून पुढील ऑपकोडपासून सुरू होणाऱ्या वैध जंप गंतव्यस्थानांचा संच आहे. जर सध्याचा ऑपकोड `JUMPDEST` नसेल, तर फक्त तो संच परत करा. जर ते `JUMPDEST` असेल, तर ते परिणाम संचामध्ये समाविष्ट करा आणि ते परत करा.

## 9.4.4 सामान्य थांबणे {#944-normal-halt}

थांबणारे फंक्शन _H_, तीन प्रकारचे मूल्य परत करू शकते.

- जर आपण हॉल्ट ऑपकोडमध्ये नसू, तर _∅_, रिकामा संच परत करा. परंपरेनुसार, हे मूल्य बूलियन फाल्स म्हणून अर्थ लावले जाते.
- जर आपल्याकडे हॉल्ट ऑपकोड असेल जो आउटपुट तयार करत नाही ([`STOP`](https://www.evm.codes/#00) किंवा [`SELFDESTRUCT`](https://www.evm.codes/#ff)), तर परत मूल्य म्हणून शून्य बाइट्सचा क्रम परत करा. लक्षात घ्या की हे रिकाम्या संचापेक्षा खूप वेगळे आहे. या मूल्याचा अर्थ असा आहे की EVM खरोखर थांबले आहे, फक्त वाचण्यासाठी कोणताही रिटर्न डेटा नाही.
- जर आपल्याकडे हॉल्ट ऑपकोड असेल जो आउटपुट तयार करतो ([`RETURN`](https://www.evm.codes/#f3) किंवा [`REVERT`](https://www.evm.codes/#fd)), तर त्या ऑपकोडद्वारे निर्दिष्ट केलेला बाइट्सचा क्रम परत करा. हा क्रम मेमरीमधून घेतला जातो, स्टॅकच्या शीर्षस्थानी असलेले मूल्य (_μ<sub>s</sub>[0]_) पहिला बाइट आहे, आणि त्यानंतरचे मूल्य (_μ<sub>s</sub>[1]_) लांबी आहे.

## H.2 सूचना संच {#h2-instruction-set}

EVM च्या अंतिम उपविभाग 9.5 वर जाण्यापूर्वी, आपण सूचना स्वतः पाहूया. ते परिशिष्ट H.2 मध्ये परिभाषित केले आहेत जे पृ. 29 पासून सुरू होते. त्या विशिष्ट ऑपकोडसह बदलणारे म्हणून निर्दिष्ट नसलेली कोणतीही गोष्ट तशीच राहण्याची अपेक्षा आहे. बदलणारे व्हेरिएबल्स \<काहीतरी\>′ सह निर्दिष्ट केले जातात.

उदाहरणार्थ, आपण [`ADD`](https://www.evm.codes/#01) ऑपकोड पाहूया.

| मूल्य | स्मरणीय | δ | α | वर्णन                                                                                                                                                                                                                 |
| ----: | ------- | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x01 | ADD     | 2 | 1 | बेरीज ऑपरेशन.                                                                                                                                                                                         |
|       |         |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_ ही आपण स्टॅकमधून काढलेल्या मूल्यांची संख्या आहे. या प्रकरणात दोन, कारण आपण शीर्षस्थानी असलेल्या दोन मूल्यांची बेरीज करत आहोत.

_α_ ही आपण परत ढकललेल्या मूल्यांची संख्या आहे. या प्रकरणात एक, बेरीज.

त्यामुळे नवीन स्टॅक टॉप (_μ′<sub>s</sub>[0]_) जुन्या स्टॅक टॉप (_μ<sub>s</sub>[0]_) आणि त्याखालील जुन्या मूल्याची (_μ<sub>s</sub>[1]_) बेरीज आहे.

सर्व ऑपकोड्सची "डोळे मिटून घेणारी यादी" पाहण्याऐवजी, हा लेख फक्त त्या ऑपकोड्सचे स्पष्टीकरण देतो जे काहीतरी नवीन सादर करतात.

| मूल्य | स्मरणीय   | δ | α | वर्णन                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ----: | --------- | - | - | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x20 | KECCAK256 | 2 | 1 | Keccak-256 हॅशची गणना करा.                                                                                                                                                                                                                                                                                                                                                                                                                           |
|       |           |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] . . . (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|       |           |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                                                     |

हा पहिला ऑपकोड आहे जो मेमरीमध्ये प्रवेश करतो (या प्रकरणात, फक्त वाचन). तथापि, ते मेमरीच्या सध्याच्या मर्यादांच्या पलीकडे विस्तारू शकते, म्हणून आपल्याला _μ<sub>i</sub>_ अपडेट करणे आवश्यक आहे. आपण हे पृष्ठ 29 वरील समीकरण 328 मध्ये परिभाषित केलेल्या _M_ फंक्शनचा वापर करून करतो.

| मूल्य | स्मरणीय | δ | α | वर्णन                                               |
| ----: | ------- | - | - | --------------------------------------------------- |
|  0x31 | BALANCE | 1 | 1 | दिलेल्या खात्याची शिल्लक मिळवा.     |
|       |         |   |   | ... |

ज्या पत्त्याची शिल्लक आपल्याला शोधायची आहे तो _μ<sub>s</sub>[0] mod 2<sup>160</sup>_ आहे. स्टॅकच्या शीर्षस्थानी अॅड्रेस आहे, परंतु अॅड्रेस फक्त 160 बिट्सचे असल्यामुळे, आपण [मॉड्युलो](https://en.wikipedia.org/wiki/Modulo_operation) 2<sup>160</sup> मूल्याची गणना करतो.

जर _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_ असेल, तर याचा अर्थ या अॅड्रेसबद्दल माहिती आहे. त्या बाबतीत, _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_ ही त्या अॅड्रेसची शिल्लक आहे. जर _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_ असेल, तर याचा अर्थ हा अॅड्रेस इनिशिअलाइज केलेला नाही आणि शिल्लक शून्य आहे. तुम्ही पृष्ठ 4 वरील विभाग 4.1 मध्ये खाते माहिती फील्डची यादी पाहू शकता.

दुसरे समीकरण, _A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_, हे वॉर्म स्टोरेज (स्टोरेज ज्यावर नुकताच प्रवेश केला गेला आहे आणि कॅश होण्याची शक्यता आहे) आणि कोल्ड स्टोरेज (स्टोरेज ज्यावर प्रवेश केला गेला नाही आणि पुनर्प्राप्त करण्यासाठी अधिक महाग असलेल्या हळू स्टोरेजमध्ये असण्याची शक्यता आहे) मधील प्रवेश खर्चातील फरकाशी संबंधित आहे. _A<sub>a</sub>_ ही व्यवहाराद्वारे पूर्वी प्रवेश केलेल्या पत्त्यांची सूची आहे, ज्यामुळे प्रवेश करणे स्वस्त असले पाहिजे, जसे की पृष्ठ 8 वरील विभाग 6.1 मध्ये परिभाषित केले आहे. तुम्ही या विषयावर [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929) मध्ये अधिक वाचू शकता.

| मूल्य | स्मरणीय | δ  | α  | वर्णन                                                                                                                                           |
| ----: | ------- | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x8F | DUP16   | 16 | 17 | 16 व्या स्टॅक आयटमची डुप्लिकेट करा.                                                                                             |
|       |         |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

लक्षात घ्या की कोणताही स्टॅक आयटम वापरण्यासाठी, आपल्याला तो पॉप करणे आवश्यक आहे, याचा अर्थ आपल्याला त्याच्यावरील सर्व स्टॅक आयटम देखील पॉप करणे आवश्यक आहे. [`DUP<n>`](https://www.evm.codes/#8f) आणि [`SWAP<n>`](https://www.evm.codes/#9f) च्या बाबतीत, याचा अर्थ सोळा मूल्यांपर्यंत पॉप करणे आणि नंतर पुश करणे आहे.

## 9.5 एक्झिक्युशन सायकल {#95-exec-cycle}

आता आपल्याकडे सर्व भाग आहेत, आपण शेवटी EVM चे एक्झिक्युशन सायकल कसे दस्तऐवजीकरण केले आहे हे समजू शकतो.

समीकरण (155) म्हणते की दिलेली स्टेट:

- _σ_ (जागतिक ब्लॉकचेन स्टेट)
- _μ_ (EVM स्टेट)
- _A_ (सबस्टेट, व्यवहार संपल्यावर होणारे बदल)
- _I_ (एक्झिक्युशन पर्यावरण)

नवीन स्टेट _(σ', μ', A', I')_ आहे.

समीकरणे (156)-(158) स्टॅक आणि ऑपकोडमुळे त्यात होणारा बदल (_μ<sub>s</sub>_) परिभाषित करतात. समीकरण (159) गॅसमधील बदल (_μ<sub>g</sub>_) आहे. समीकरण (160) प्रोग्राम काउंटरमधील बदल (_μ<sub>pc</sub>_) आहे. शेवटी, समीकरणे (161)-(164) निर्दिष्ट करतात की इतर पॅरामीटर्स तसेच राहतात, जोपर्यंत ऑपकोडद्वारे स्पष्टपणे बदलले जात नाही.

याद्वारे EVM पूर्णपणे परिभाषित आहे.

## निष्कर्ष {#conclusion}

गणितीय नोटेशन अचूक आहे आणि त्याने यलो पेपरला Ethereum च्या प्रत्येक तपशीलाचे तपशीलवार वर्णन करण्याची परवानगी दिली आहे. तथापि, त्याचे काही तोटे आहेत:

- हे फक्त मानवांनाच समजू शकते, याचा अर्थ असा की [अनुपालन चाचण्या](https://github.com/ethereum/tests) हाताने लिहाव्या लागतील.
- प्रोग्रामर संगणक कोड समजतात.
  ते गणितीय नोटेशन समजू शकतात किंवा नाही.

कदाचित या कारणांमुळे, नवीन [कन्सेंसस लेयर स्पेक्स](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md) पायथनमध्ये लिहिलेले आहेत. [पायथनमधील एक्झिक्युशन लेयर स्पेक्स](https://ethereum.github.io/execution-specs) आहेत, परंतु ते पूर्ण नाहीत. जोपर्यंत संपूर्ण यलो पेपर पायथन किंवा तत्सम भाषेत भाषांतरित होत नाही, तोपर्यंत यलो पेपर सेवेत राहील, आणि ते वाचण्यास सक्षम असणे उपयुक्त आहे.
