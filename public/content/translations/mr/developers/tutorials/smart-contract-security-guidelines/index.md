---
title: "स्मार्ट कॉन्ट्रॅक्ट सुरक्षा मार्गदर्शक तत्त्वे"
description: "तुमचे डॅप तयार करताना विचारात घेण्यासाठी सुरक्षा मार्गदर्शक तत्त्वांची तपासणी सूची"
author: "Trailofbits"
tags: [ "सॉलिडिटी", "स्मार्ट कॉन्ट्रॅक्ट", "सुरक्षा" ]
skill: intermediate
lang: mr
published: 2020-09-06
source: "सुरक्षित contracts तयार करणे"
sourceUrl: https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/guidelines.md
---

अधिक सुरक्षित स्मार्ट कॉन्ट्रॅक्ट तयार करण्यासाठी या उच्च-स्तरीय शिफारशींचे अनुसरण करा.

## डिझाइन मार्गदर्शक तत्त्वे {#design-guidelines}

कोडची कोणतीही ओळ लिहिण्यापूर्वी कॉन्ट्रॅक्टच्या डिझाइनवर वेळेपूर्वी चर्चा केली पाहिजे.

### दस्तऐवजीकरण आणि विशिष्टता {#documentation-and-specifications}

दस्तऐवजीकरण वेगवेगळ्या स्तरांवर लिहिले जाऊ शकते आणि कॉन्ट्रॅक्ट्सची अंमलबजावणी करताना ते अपडेट केले पाहिजे:

- **सिस्टमचे सोपे इंग्रजी वर्णन**, जे कॉन्ट्रॅक्ट्स काय करतात आणि कोडबेसवरील कोणतीही गृहितके यांचे वर्णन करते.
- **स्कीमा आणि आर्किटेक्चरल डायग्राम**, ज्यात कॉन्ट्रॅक्टमधील परस्परसंवाद आणि सिस्टमचे स्टेट मशीन समाविष्ट आहे. [स्लिदर प्रिंटर्स](https://github.com/crytic/slither/wiki/Printer-documentation) हे स्कीमा तयार करण्यासाठी मदत करू शकतात.
- **संपूर्ण कोड दस्तऐवजीकरण**, सॉलिडिटीसाठी [Natspec फॉरमॅट](https://docs.soliditylang.org/en/develop/natspec-format.html) वापरला जाऊ शकतो.

### ऑनचेन विरुद्ध ऑफचेन गणना {#onchain-vs-offchain-computation}

- **तुम्ही शक्य तितका कोड ऑफचेन ठेवा.** ऑनचेन लेयर लहान ठेवा. ऑफचेन कोडसह डेटावर अशा प्रकारे पूर्व-प्रक्रिया करा की ऑनचेन पडताळणी सोपी होईल. तुम्हाला क्रमबद्ध यादीची आवश्यकता आहे का? यादी ऑफचेन लावा, मग फक्त तिचा क्रम ऑनचेन तपासा.

### अपग्रेडेबिलिटी {#upgradeability}

आम्ही [आमच्या ब्लॉगपोस्टमध्ये](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/) वेगवेगळ्या अपग्रेडेबिलिटी सोल्यूशन्सवर चर्चा केली आहे. कोणताही कोड लिहिण्यापूर्वी अपग्रेडेबिलिटीला सपोर्ट करायचा की नाही, याची हेतुपुरस्सर निवड करा. तुम्ही तुमचा कोड कसा संरचित करता यावर हा निर्णय प्रभाव टाकेल. सर्वसाधारणपणे, आम्ही शिफारस करतो:

- **अपग्रेडेबिलिटीपेक्षा [कॉन्ट्रॅक्ट मायग्रेशनला](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) प्राधान्य द्या.** मायग्रेशन सिस्टम्समध्ये अपग्रेड करण्यायोग्य सिस्टमसारखेच अनेक फायदे आहेत, पण त्यांचे तोटे नाहीत.
- **डेलिगेट कॉल प्रॉक्सी पॅटर्नपेक्षा डेटा सेपरेशन पॅटर्न वापरा.** जर तुमच्या प्रोजेक्टमध्ये स्पष्ट ॲब्स्ट्रॅक्शन सेपरेशन असेल, तर डेटा सेपरेशन वापरून अपग्रेडेबिलिटीसाठी फक्त काही समायोजन आवश्यक असतील. डेलिगेट कॉल प्रॉक्सीसाठी EVM तज्ञतेची आवश्यकता असते आणि ते खूप त्रुटी-प्रवण आहे.
- **डिप्लॉयमेंट करण्यापूर्वी मायग्रेशन/अपग्रेड प्रक्रिया डॉक्युमेंट करा.** जर तुम्हाला कोणत्याही मार्गदर्शक तत्त्वांशिवाय तणावाखाली प्रतिक्रिया द्यावी लागली, तर तुम्ही चुका कराल. अनुसरण्याची प्रक्रिया वेळेपूर्वीच लिहा. त्यात समाविष्ट असावे:
  - नवीन कॉन्ट्रॅक्ट्स सुरू करणारे कॉल्स
  - कीज कुठे साठवल्या आहेत आणि त्या कशा ऍक्सेस करायच्या
  - डिप्लॉयमेंट कशी तपासावी! डिप्लॉयमेंट-नंतरची स्क्रिप्ट विकसित करा आणि तपासा.

## अंमलबजावणीची मार्गदर्शक तत्त्वे {#implementation-guidelines}

**साधेपणासाठी प्रयत्न करा.** नेहमी सर्वात सोपा उपाय वापरा जो तुमच्या उद्देशाला अनुकूल असेल. तुमच्या टीममधील कोणत्याही सदस्याला तुमचा उपाय समजू शकला पाहिजे.

### फंक्शन कंपोझिशन {#function-composition}

तुमच्या कोडबेसचे आर्किटेक्चर असे असावे की ज्यामुळे तुमचा कोड तपासणे सोपे होईल. असे आर्किटेक्चरल पर्याय टाळा जे त्याच्या अचूकतेबद्दल तर्क करण्याची क्षमता कमी करतात.

- **तुमच्या सिस्टमच्या लॉजिकचे विभाजन करा**, एकतर अनेक कॉन्ट्रॅक्ट्सद्वारे किंवा समान फंक्शन्स एकत्र गटबद्ध करून (उदाहरणार्थ, ऑथेंटिकेशन, अंकगणित, ...).
- **स्पष्ट उद्देशाने लहान फंक्शन्स लिहा.** यामुळे पुनरावलोकन सोपे होईल आणि वैयक्तिक घटकांची चाचणी घेता येईल.

### इनहेरिटन्स {#inheritance}

- **इनहेरिटन्स व्यवस्थापनीय ठेवा.** लॉजिकचे विभाजन करण्यासाठी इनहेरिटन्सचा वापर केला पाहिजे, तथापि, तुमच्या प्रोजेक्टने इनहेरिटन्स ट्रीची खोली आणि रुंदी कमी करण्याचे ध्येय ठेवले पाहिजे.
- **कॉन्ट्रॅक्ट्सची हायरार्की तपासण्यासाठी स्लिदरचा [इनहेरिटन्स प्रिंटर](https://github.com/crytic/slither/wiki/Printer-documentation#inheritance-graph) वापरा.** इनहेरिटन्स प्रिंटर तुम्हाला हायरार्कीचा आकार तपासण्यात मदत करेल.

### इव्हेंट्स {#events}

- **सर्व महत्त्वाच्या ऑपरेशन्स लॉग करा.** इव्हेंट्स डेव्हलपमेंट दरम्यान कॉन्ट्रॅक्ट डीबग करण्यास आणि डिप्लॉयमेंटनंतर त्यावर लक्ष ठेवण्यास मदत करतील.

### ज्ञात धोके टाळा {#avoid-known-pitfalls}

- **सर्वात सामान्य सुरक्षा समस्यांबद्दल जागरूक रहा.** सामान्य समस्यांबद्दल जाणून घेण्यासाठी अनेक ऑनलाइन संसाधने आहेत, जसे की [Ethernaut CTF](https://ethernaut.openzeppelin.com/), [कॅप्चर द इथर](https://capturetheether.com/), किंवा [नॉट सो स्मार्ट कॉन्ट्रॅक्ट्स](https://github.com/crytic/not-so-smart-contracts/).
- **[Solidity दस्तऐवजीकरणामधील](https://docs.soliditylang.org/en/latest/) चेतावणी विभागांबद्दल जागरूक रहा.** चेतावणी विभाग तुम्हाला भाषेच्या अस्पष्ट वर्तनाबद्दल माहिती देतील.

### डिपेंडन्सीज {#dependencies}

- **चांगल्या प्रकारे तपासलेल्या लायब्ररी वापरा.** चांगल्या प्रकारे तपासलेल्या लायब्ररीमधून कोड इम्पोर्ट केल्याने तुम्ही सदोष कोड लिहिण्याची शक्यता कमी होईल. जर तुम्हाला ERC20 कॉन्ट्रॅक्ट लिहायचा असेल, तर [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) वापरा.
- **डिपेंडन्सी मॅनेजर वापरा; कोड कॉपी-पेस्ट करणे टाळा.** जर तुम्ही बाह्य स्त्रोतावर अवलंबून असाल, तर तुम्ही ते मूळ स्त्रोतासह अद्ययावत ठेवले पाहिजे.

### चाचणी आणि पडताळणी {#testing-and-verification}

- **संपूर्ण युनिट-टेस्ट्स लिहा.** उच्च-गुणवत्तेचे सॉफ्टवेअर तयार करण्यासाठी एक विस्तृत टेस्ट सूट महत्त्वपूर्ण आहे.
- **[स्लिदर](https://github.com/crytic/slither), [एकिडना](https://github.com/crytic/echidna) आणि [मॅन्टिकोर](https://github.com/trailofbits/manticore) कस्टम चेक्स आणि प्रॉपर्टीज लिहा.** स्वयंचलित टूल्स तुमचा कॉन्ट्रॅक्ट सुरक्षित असल्याची खात्री करण्यास मदत करतील. कार्यक्षम चेक्स आणि प्रॉपर्टीज कसे लिहायचे हे जाणून घेण्यासाठी या मार्गदर्शकाचा उर्वरित भाग तपासा.
- **[crytic.io](https://crytic.io/) वापरा.** क्रिटिक GitHub सह समाकलित होते, खाजगी स्लिदर डिटेक्टरना ऍक्सेस प्रदान करते, आणि एकिडनामधून कस्टम प्रॉपर्टी चेक्स चालवते.

### Solidity {#solidity}

- **0.4 आणि 0.6 पेक्षा सॉलिडिटी 0.5 ला प्राधान्य द्या.** आमच्या मते, सॉलिडिटी 0.5 अधिक सुरक्षित आहे आणि 0.4 पेक्षा त्यात अधिक चांगल्या बिल्ट-इन पद्धती आहेत. सॉलिडिटी 0.6 उत्पादनासाठी खूपच अस्थिर सिद्ध झाले आहे आणि त्याला परिपक्व होण्यासाठी वेळ लागेल.
- **कंपाइल करण्यासाठी स्थिर रिलीझ वापरा; चेतावणी तपासण्यासाठी नवीनतम रिलीझ वापरा.** नवीनतम कंपाइलर आवृत्तीसह तुमच्या कोडमध्ये कोणतीही नोंदवलेली समस्या नाही याची खात्री करा. तथापि, सॉलिडिटीचे रिलीझ चक्र वेगवान आहे आणि त्यात कंपाइलर बग्सचा इतिहास आहे, म्हणून आम्ही डिप्लॉयमेंटसाठी नवीनतम आवृत्तीची शिफारस करत नाही (स्लिदरची [solc आवृत्ती शिफारस](https://github.com/crytic/slither/wiki/Detector-Documentation#recommendation-33) पहा).
- **इनलाइन असेंब्ली वापरू नका.** असेंब्लीसाठी EVM तज्ञतेची आवश्यकता असते. जर तुम्ही यलो पेपरवर _प्रभुत्व_ मिळवले नसेल तर EVM कोड लिहू नका.

## डिप्लॉयमेंट मार्गदर्शक तत्त्वे {#deployment-guidelines}

एकदा कॉन्ट्रॅक्ट विकसित आणि डिप्लॉय झाल्यानंतर:

- **तुमच्या कॉन्ट्रॅक्ट्सवर लक्ष ठेवा.** लॉग्स पहा आणि कॉन्ट्रॅक्ट किंवा वॉलेटशी तडजोड झाल्यास प्रतिक्रिया देण्यासाठी तयार रहा.
- **तुमची संपर्क माहिती [ब्लॉकचेन-सुरक्षा-संपर्क](https://github.com/crytic/blockchain-security-contacts) मध्ये जोडा.** जर एखादी सुरक्षा त्रुटी आढळल्यास ही यादी तृतीय-पक्षांना तुमच्याशी संपर्क साधण्यास मदत करते.
- **विशेषाधिकार असलेल्या वापरकर्त्यांचे वॉलेट्स सुरक्षित करा.** जर तुम्ही हार्डवेअर वॉलेट्समध्ये कीज साठवत असाल तर आमच्या [सर्वोत्तम पद्धतींचे](https://blog.trailofbits.com/2018/11/27/10-rules-for-the-secure-use-of-cryptocurrency-hardware-wallets/) अनुसरण करा.
- **घटनेला प्रतिसाद देण्यासाठी एक योजना तयार ठेवा.** तुमचे स्मार्ट कॉन्ट्रॅक्ट्स धोक्यात येऊ शकतात याचा विचार करा. जरी तुमचे कॉन्ट्रॅक्ट्स बग-मुक्त असले तरी, एक हल्लेखोर कॉन्ट्रॅक्ट मालकाच्या कीजचा ताबा घेऊ शकतो.
