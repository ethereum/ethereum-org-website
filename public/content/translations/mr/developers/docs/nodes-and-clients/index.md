---
title: नोड्स आणि क्लायंट
description: Ethereum नोड्स आणि क्लायंट सॉफ्टवेअरचा आढावा, तसेच नोड कसा सेट करायचा आणि तुम्ही ते का करावे.
lang: mr
sidebarDepth: 2
---

Ethereum हे संगणकांचे (नोड्स म्हणून ओळखले जाणारे) एक वितरित नेटवर्क आहे जे सॉफ्टवेअर चालवते जे ब्लॉक्स आणि व्यवहाराच्या डेटाची पडताळणी करू शकते. तुमच्या संगणकाला Ethereum नोडमध्ये रूपांतरित करण्यासाठी हे सॉफ्टवेअर त्यावर चालवणे आवश्यक आहे. नोड तयार करण्यासाठी सॉफ्टवेअरचे दोन स्वतंत्र भाग ('क्लायंट' म्हणून ओळखले जाणारे) आवश्यक आहेत.

## पूर्वतयारी {#prerequisites}

Ethereum क्लायंटचे तुमचे स्वतःचे इन्स्टन्स चालवण्यापूर्वी आणि अधिक सखोल अभ्यास करण्यापूर्वी तुम्हाला पीअर-टू-पीअर नेटवर्कची संकल्पना आणि [EVM च्या मूलभूत गोष्टी](/developers/docs/evm/) समजल्या पाहिजेत. आमची [Ethereum ची ओळख](/developers/docs/intro-to-ethereum/) पहा.

तुम्ही नोड्सच्या विषयासाठी नवीन असाल, तर आम्ही तुम्हाला शिफारस करतो की तुम्ही प्रथम [Ethereum नोड चालवण्यावर](/run-a-node) आमची वापरकर्ता-अनुकूल ओळख तपासा.

## नोड्स आणि क्लायंट म्हणजे काय? {#what-are-nodes-and-clients}

"नोड" हे Ethereum क्लायंट सॉफ्टवेअरचे कोणतेही उदाहरण आहे जे Ethereum सॉफ्टवेअर चालवणाऱ्या इतर संगणकांशी जोडलेले असते, ज्यामुळे एक नेटवर्क तयार होते. क्लायंट हे Ethereum चे एक अंमलबजावणी आहे जे प्रोटोकॉल नियमांनुसार डेटाची पडताळणी करते आणि नेटवर्क सुरक्षित ठेवते. एका नोडला दोन क्लायंट चालवावे लागतात: एक कन्सेंसस क्लायंट आणि एक एक्झिक्युशन क्लायंट.

- एक्झिक्युशन क्लायंट (ज्याला एक्झिक्युशन इंजिन, EL क्लायंट किंवा पूर्वीचे Eth1 क्लायंट म्हणूनही ओळखले जाते) नेटवर्कमध्ये प्रसारित होणाऱ्या नवीन व्यवहारांवर लक्ष ठेवतो, त्यांना EVM मध्ये कार्यान्वित करतो आणि सर्व सद्य Ethereum डेटाची नवीनतम स्थिती आणि डेटाबेस ठेवतो.
- कन्सेंसस क्लायंट (ज्याला बीकन नोड, CL क्लायंट किंवा पूर्वीचा Eth2 क्लायंट असेही म्हणतात) प्रूफ-ऑफ-स्टेक कन्सेंसस अल्गोरिदमची अंमलबजावणी करतो, ज्यामुळे नेटवर्कला एक्झिक्युशन क्लायंटकडून प्रमाणित केलेल्या डेटाच्या आधारे एकमत साधता येते. एक तिसरे सॉफ्टवेअर देखील आहे, ज्याला 'व्हॅलिडेटर' म्हणून ओळखले जाते, जे कन्सेंसस क्लायंटमध्ये जोडले जाऊ शकते, ज्यामुळे नोडला नेटवर्क सुरक्षित करण्यात सहभागी होता येते.

हे क्लायंट एकत्र काम करून Ethereum चेनच्या हेडचा मागोवा ठेवतात आणि वापरकर्त्यांना Ethereum नेटवर्कशी संवाद साधण्याची परवानगी देतात. एकत्र काम करणाऱ्या सॉफ्टवेअरच्या अनेक भागांच्या या मॉड्युलर डिझाइनला [एनकॅप्स्युलेटेड कॉम्प्लेक्सिटी](https://vitalik.eth.limo/general/2022/02/28/complexity.html) म्हटले जाते. या दृष्टिकोनामुळे [द मर्ज](/roadmap/merge) अखंडपणे कार्यान्वित करणे सोपे झाले, क्लायंट सॉफ्टवेअरची देखभाल आणि विकास सोपा होतो आणि वैयक्तिक क्लायंटचा पुनर्वापर सक्षम होतो, उदाहरणार्थ, [लेयर 2 इकोसिस्टममध्ये](/layer-2/).

![जोडलेले एक्झिक्युशन आणि कन्सेंसस क्लायंट](./eth1eth2client.png)
जोडलेल्या एक्झिक्युशन आणि कन्सेंसस क्लायंटची सरलीकृत आकृती.

### क्लायंट विविधता {#client-diversity}

[एक्झिक्युशन क्लायंट](/developers/docs/nodes-and-clients/#execution-clients) आणि [कन्सेंसस क्लायंट](/developers/docs/nodes-and-clients/#consensus-clients) दोन्ही वेगवेगळ्या संघांनी विकसित केलेल्या विविध प्रोग्रामिंग भाषांमध्ये अस्तित्वात आहेत.

एकाधिक क्लायंट अंमलबजावणीमुळे नेटवर्क एकाच कोडबेसवरील अवलंबित्व कमी करून अधिक मजबूत होऊ शकते. आदर्श ध्येय हे आहे की कोणताही एक क्लायंट नेटवर्कवर वर्चस्व गाजवणार नाही अशी विविधता प्राप्त करणे, ज्यामुळे अपयशाचा संभाव्य एकच बिंदू नाहीसा होईल.
भाषांमधील विविधता एका व्यापक विकासक समुदायाला आमंत्रित करते आणि त्यांना त्यांच्या पसंतीच्या भाषेत एकत्रीकरण तयार करण्याची परवानगी देते.

[क्लायंट विविधतेबद्दल](/developers/docs/nodes-and-clients/client-diversity/) अधिक जाणून घ्या.

या सर्व अंमलबजावणींमध्ये एक गोष्ट समान आहे की त्या सर्व एकाच विनिर्देशाचे पालन करतात. Ethereum नेटवर्क आणि ब्लॉकचेन कसे कार्य करतात हे विनिर्देश ठरवतात. प्रत्येक तांत्रिक तपशील परिभाषित केलेला आहे आणि विनिर्देश खालीलप्रमाणे आढळू शकतात:

- मूळतः, [Ethereum यलो पेपर](https://ethereum.github.io/yellowpaper/paper.pdf)
- [एक्झिक्युशन स्पेसिफिकेशन्स](https://github.com/ethereum/execution-specs/)
- [कन्सेंसस स्पेसिफिकेशन्स](https://github.com/ethereum/consensus-specs)
- [EIPs](https://eips.ethereum.org/) विविध [नेटवर्क अपग्रेड्स](/ethereum-forks/) मध्ये लागू

### नेटवर्कमधील नोड्सचा मागोवा घेणे {#network-overview}

अनेक ट्रॅकर्स Ethereum नेटवर्कमधील नोड्सचा रिअल-टाइम आढावा देतात. लक्षात घ्या की विकेंद्रित नेटवर्कच्या स्वरूपामुळे, हे क्रॉलर्स नेटवर्कचे केवळ मर्यादित दृश्य प्रदान करू शकतात आणि भिन्न परिणाम नोंदवू शकतात.

- Etherscan द्वारे [नोड्सचा नकाशा](https://etherscan.io/nodetracker)
- Bitfly द्वारे [Ethernodes](https://ethernodes.org/)
- Chainsafe द्वारे [Nodewatch](https://www.nodewatch.io/), कन्सेंसस नोड्स क्रॉल करत आहे
- [Monitoreth](https://monitoreth.io/) - MigaLabs द्वारे, एक वितरित नेटवर्क मॉनिटरिंग साधन
- [साप्ताहिक नेटवर्क आरोग्य अहवाल](https://probelab.io) - ProbeLab द्वारे, [Nebula crawler](https://github.com/dennis-tra/nebula) आणि इतर साधनांचा वापर करून

## नोडचे प्रकार {#node-types}

तुम्हाला [तुमचा स्वतःचा नोड चालवायचा असेल](/developers/docs/nodes-and-clients/run-a-node/), तर तुम्हाला हे समजले पाहिजे की नोडचे विविध प्रकार आहेत जे डेटा वेगळ्या प्रकारे वापरतात. खरं तर, क्लायंट तीन वेगवेगळ्या प्रकारचे नोड चालवू शकतात: लाइट, फुल आणि आर्काइव्ह. वेगवेगळ्या सिंक धोरणांचे पर्याय देखील आहेत जे जलद सिंक्रोनाइझेशन वेळ सक्षम करतात. सिंक्रोनाइझेशन म्हणजे Ethereum च्या स्थितीबद्दल सर्वात अद्ययावत माहिती किती लवकर मिळवता येते.

### फुल नोड {#full-node}

फुल नोड्स ब्लॉकचेनची ब्लॉक-दर-ब्लॉक पडताळणी करतात, ज्यात प्रत्येक ब्लॉकसाठी ब्लॉक बॉडी आणि स्टेट डेटा डाउनलोड करणे आणि सत्यापित करणे समाविष्ट आहे. फुल नोडचे वेगवेगळे वर्ग आहेत - काही जेनेसिस ब्लॉकपासून सुरुवात करतात आणि ब्लॉकचेनच्या संपूर्ण इतिहासातील प्रत्येक ब्लॉकची पडताळणी करतात. इतर त्यांची पडताळणी अधिक अलीकडील ब्लॉकपासून सुरू करतात ज्यावर ते वैध असल्याचा विश्वास ठेवतात (उदा., Geth चे 'स्नॅप सिंक'). पडताळणी कोठून सुरू होते याची पर्वा न करता, फुल नोड्स फक्त तुलनेने अलीकडील डेटाची स्थानिक प्रत ठेवतात (साधारणपणे सर्वात अलीकडील 128 ब्लॉक्स), ज्यामुळे डिस्कची जागा वाचवण्यासाठी जुना डेटा हटवता येतो. आवश्यकतेनुसार जुना डेटा पुन्हा तयार केला जाऊ शकतो.

- संपूर्ण ब्लॉकचेन डेटा संग्रहित करतो (जरी हा डेटा वेळोवेळी छाटला जातो, त्यामुळे फुल नोड जेनेसिसपासूनचा सर्व स्टेट डेटा संग्रहित करत नाही)
- ब्लॉक पडताळणीत भाग घेतो, सर्व ब्लॉक्स आणि स्टेट्सची पडताळणी करतो.
- सर्व स्टेट्स एकतर स्थानिक स्टोरेजमधून मिळवता येतात किंवा फुल नोडद्वारे 'स्नॅपशॉट्स'मधून पुन्हा तयार करता येतात.
- नेटवर्कला सेवा देतो आणि विनंतीनुसार डेटा प्रदान करतो.

### आर्काइव्ह नोड {#archive-node}

आर्काइव्ह नोड्स हे फुल नोड्स आहेत जे जेनेसिसपासून प्रत्येक ब्लॉकची पडताळणी करतात आणि डाउनलोड केलेला कोणताही डेटा कधीही हटवत नाहीत.

- फुल नोडमध्ये ठेवलेल्या सर्व गोष्टी संग्रहित करतो आणि ऐतिहासिक स्टेट्सचे आर्काइव्ह तयार करतो. जर तुम्हाला ब्लॉक #4,000,000 वरील खात्यातील शिल्लक यासारख्या गोष्टींची चौकशी करायची असेल किंवा ट्रेसिंग वापरून तुमच्या स्वतःच्या व्यवहारांच्या सेटची पडताळणी न करता फक्त आणि विश्वसनीयरित्या चाचणी करायची असेल तर याची आवश्यकता आहे.
- हा डेटा टेराबाइट्सच्या युनिट्समध्ये असतो, ज्यामुळे आर्काइव्ह नोड्स सामान्य वापरकर्त्यांसाठी कमी आकर्षक ठरतात, परंतु ब्लॉक एक्सप्लोरर्स, वॉलेट विक्रेते आणि चेन अॅनालिटिक्स यांसारख्या सेवांसाठी ते उपयुक्त ठरू शकतात.

आर्काइव्ह व्यतिरिक्त इतर कोणत्याही मोडमध्ये क्लायंट सिंक केल्याने ब्लॉकचेन डेटा छाटला जाईल. याचा अर्थ, सर्व ऐतिहासिक स्टेट्सचे कोणतेही आर्काइव्ह नसते, परंतु फुल नोड गरजेनुसार ते तयार करू शकतो.

[आर्काइव्ह नोड्सबद्दल](/developers/docs/nodes-and-clients/archive-nodes) अधिक जाणून घ्या.

### लाइट नोड {#light-node}

प्रत्येक ब्लॉक डाउनलोड करण्याऐवजी, लाइट नोड्स फक्त ब्लॉक हेडर्स डाउनलोड करतात. या हेडर्समध्ये ब्लॉक्सच्या सामग्रीबद्दल सारांश माहिती असते. लाइट नोडला आवश्यक असलेली इतर कोणतीही माहिती फुल नोडकडून मागवली जाते. लाइट नोड त्यानंतर ब्लॉक हेडर्समधील स्टेट रूट्सच्या आधारावर त्यांना मिळालेल्या डेटाची स्वतंत्रपणे पडताळणी करू शकतो. लाइट नोड्स वापरकर्त्यांना फुल नोड्स चालवण्यासाठी आवश्यक असलेल्या शक्तिशाली हार्डवेअर किंवा उच्च बँडविड्थशिवाय Ethereum नेटवर्कमध्ये सहभागी होण्यास सक्षम करतात. अखेरीस, लाइट नोड्स मोबाईल फोन किंवा एम्बेडेड उपकरणांवर चालवता येतील. लाइट नोड्स कन्सेंससमध्ये सहभागी होत नाहीत (म्हणजे, ते व्हॅलिडेटर असू शकत नाहीत), परंतु ते फुल नोड प्रमाणेच समान कार्यक्षमता आणि सुरक्षा हमीसह Ethereum ब्लॉकचेनमध्ये प्रवेश करू शकतात.

लाइट क्लायंट हे Ethereum साठी सक्रिय विकासाचे क्षेत्र आहे आणि आम्ही लवकरच कन्सेंसस लेयर आणि एक्झिक्युशन लेयरसाठी नवीन लाइट क्लायंट पाहण्याची अपेक्षा करतो.
[गॉसिप नेटवर्क](https://www.ethportal.net/) वरून लाइट क्लायंट डेटा प्रदान करण्याचे संभाव्य मार्ग देखील आहेत. हे फायदेशीर आहे कारण गॉसिप नेटवर्क विनंत्या पूर्ण करण्यासाठी फुल नोड्सची आवश्यकता न ठेवता लाइट नोड्सच्या नेटवर्कला समर्थन देऊ शकते.

Ethereum अद्याप मोठ्या संख्येने लाइट नोड्सना समर्थन देत नाही, परंतु लाइट नोड समर्थन हे एक क्षेत्र आहे जे नजीकच्या भविष्यात वेगाने विकसित होण्याची अपेक्षा आहे. विशेषतः, [Nimbus](https://nimbus.team/), [Helios](https://github.com/a16z/helios), आणि [LodeStar](https://lodestar.chainsafe.io/) सारखे क्लायंट सध्या लाइट नोड्सवर जास्त लक्ष केंद्रित करत आहेत.

## मी Ethereum नोड का चालवावा? {#why-should-i-run-an-ethereum-node}

नोड चालवण्यामुळे तुम्हाला Ethereum थेट, विश्वासहीनपणे आणि खाजगीरित्या वापरता येतो, तसेच नेटवर्कला अधिक मजबूत आणि विकेंद्रित ठेवून त्याला समर्थन देता येते.

### तुमच्यासाठी फायदे {#benefits-to-you}

तुमचा स्वतःचा नोड चालवल्याने तुम्हाला Ethereum खाजगी, स्वयंपूर्ण आणि विश्वासहीन पद्धतीने वापरता येते. तुम्हाला नेटवर्कवर विश्वास ठेवण्याची गरज नाही कारण तुम्ही तुमच्या क्लायंटद्वारे डेटा स्वतःच सत्यापित करू शकता. "विश्वास ठेवू नका, पडताळणी करा" हा एक लोकप्रिय ब्लॉकचेन मंत्र आहे.

- तुमचा नोड सर्व व्यवहार आणि ब्लॉक्सची पडताळणी कन्सेंसस नियमांनुसार स्वतःच करतो. याचा अर्थ असा की तुम्हाला नेटवर्कमधील इतर कोणत्याही नोडवर अवलंबून राहण्याची किंवा त्यांच्यावर पूर्णपणे विश्वास ठेवण्याची आवश्यकता नाही.
- तुम्ही तुमच्या स्वतःच्या नोडसह Ethereum वॉलेट वापरू शकता. तुम्ही dapps अधिक सुरक्षितपणे आणि खाजगीरित्या वापरू शकता कारण तुम्हाला तुमचे पत्ते आणि शिल्लक मध्यस्थांना लीक करण्याची आवश्यकता नाही. सर्व काही तुमच्या स्वतःच्या क्लायंटने तपासले जाऊ शकते. [MetaMask](https://metamask.io), [Frame](https://frame.sh/), आणि [इतर अनेक वॉलेट्स](/wallets/find-wallet/) RPC-इम्पोर्टिंगची सुविधा देतात, ज्यामुळे त्यांना तुमचा नोड वापरता येतो.
- तुम्ही Ethereum मधील डेटावर अवलंबून असलेल्या इतर सेवा चालवू आणि स्वयं-होस्ट करू शकता. उदाहरणार्थ, हे बीकन चेन व्हॅलिडेटर, लेयर 2 सारखे सॉफ्टवेअर, पायाभूत सुविधा, ब्लॉक एक्सप्लोरर, पेमेंट प्रोसेसर इत्यादी असू शकते.
- तुम्ही तुमचे स्वतःचे सानुकूल [RPC एंडपॉइंट](/developers/docs/apis/json-rpc/) प्रदान करू शकता. तुम्ही मोठ्या केंद्रीकृत प्रदात्यांना टाळण्यास मदत करण्यासाठी समुदायाला हे एंडपॉइंट्स सार्वजनिकरित्या देऊ शकता.
- तुम्ही **इंटर-प्रोसेस कम्युनिकेशन्स (IPC)** वापरून तुमच्या नोडशी कनेक्ट होऊ शकता किंवा तुमचा प्रोग्राम प्लगइन म्हणून लोड करण्यासाठी नोड पुन्हा लिहू शकता. हे कमी विलंबता प्रदान करते, जे वेब3 लायब्ररी वापरून बरेच डेटा प्रक्रिया करताना किंवा जेव्हा आपल्याला शक्य तितक्या लवकर आपले व्यवहार पुनर्स्थित करण्याची आवश्यकता असते (उदा. फ्रंटरनिंग) तेव्हा खूप मदत करते.
- तुम्ही नेटवर्क सुरक्षित करण्यासाठी आणि बक्षिसे मिळवण्यासाठी थेट ETH स्टेक करू शकता. प्रारंभ करण्यासाठी [सोलो स्टेकिंग](/staking/solo/) पहा.

![तुमच्या ॲप्लिकेशन आणि नोड्सद्वारे तुम्ही Ethereum मध्ये कसे प्रवेश करता](./nodes.png)

### नेटवर्क फायदे {#network-benefits}

Ethereum च्या आरोग्यासाठी, सुरक्षेसाठी आणि कार्यान्वयन लवचिकतेसाठी नोड्सचा एक वैविध्यपूर्ण संच महत्त्वाचा आहे.

- फुल नोड्स कन्सेंसस नियमांची अंमलबजावणी करतात जेणेकरून त्यांना नियमांचे पालन न करणाऱ्या ब्लॉक्सना स्वीकारण्यासाठी फसवता येणार नाही. हे नेटवर्कमध्ये अतिरिक्त सुरक्षा प्रदान करते कारण जर सर्व नोड्स लाइट नोड्स असते, जे पूर्ण पडताळणी करत नाहीत, तर व्हॅलिडेटर्स नेटवर्कवर हल्ला करू शकले असते.
- [प्रूफ-ऑफ-स्टेक](/developers/docs/consensus-mechanisms/pos/#what-is-pos) च्या क्रिप्टो-इकॉनॉमिक संरक्षणावर मात करणाऱ्या हल्ल्याच्या बाबतीत, प्रामाणिक चेनचे अनुसरण करणे निवडून फुल नोड्सद्वारे सामाजिक पुनर्प्राप्ती केली जाऊ शकते.
- नेटवर्कमधील अधिक नोड्समुळे अधिक वैविध्यपूर्ण आणि मजबूत नेटवर्क तयार होते, जे विकेंद्रीकरणाचे अंतिम ध्येय आहे, जे सेन्सॉरशिप-प्रतिरोधक आणि विश्वासार्ह प्रणाली सक्षम करते.
- फुल नोड्स त्यांच्यावर अवलंबून असलेल्या हलक्या क्लायंटसाठी ब्लॉकचेन डेटामध्ये प्रवेश प्रदान करतात. लाइट नोड्स संपूर्ण ब्लॉकचेन संग्रहित करत नाहीत, त्याऐवजी ते [ब्लॉक हेडर्समधील स्टेट रूट्स](/developers/docs/blocks/#block-anatomy) द्वारे डेटाची पडताळणी करतात. त्यांना आवश्यक असल्यास ते फुल नोड्सकडून अधिक माहितीची विनंती करू शकतात.

तुम्ही व्हॅलिडेटर चालवत नसला तरीही, तुम्ही फुल नोड चालवल्यास संपूर्ण Ethereum नेटवर्कला त्याचा फायदा होतो.

## तुमचा स्वतःचा नोड चालवणे {#running-your-own-node}

तुमचा स्वतःचा Ethereum क्लायंट चालविण्यात स्वारस्य आहे का?

नवशिक्यांसाठी सोप्या परिचयासाठी, अधिक जाणून घेण्यासाठी आमच्या [नोड चालवा](/run-a-node) पृष्ठास भेट द्या.

तुम्ही अधिक तांत्रिक वापरकर्ते असल्यास, [तुमचा स्वतःचा नोड कसा सुरू करायचा](/developers/docs/nodes-and-clients/run-a-node/) याबद्दल अधिक तपशील आणि पर्यायांमध्ये सखोल जा.

## पर्याय {#alternatives}

तुमचा स्वतःचा नोड सेट करण्यासाठी तुम्हाला वेळ आणि संसाधने लागू शकतात परंतु तुम्हाला नेहमीच तुमचे स्वतःचे उदाहरण चालवण्याची गरज नसते. या प्रकरणात, आपण तृतीय-पक्ष API प्रदाता वापरू शकता. या सेवा वापरण्याच्या विहंगावलोकनासाठी, [सेवा म्हणून नोड्स](/developers/docs/nodes-and-clients/nodes-as-a-service/) पहा.

जर कोणी तुमच्या समुदायात सार्वजनिक API सह Ethereum नोड चालवत असेल, तर तुम्ही तुमच्या वॉलेट्सना कस्टम RPC द्वारे समुदाय नोडकडे निर्देशित करू शकता आणि काही यादृच्छिक विश्वासू तृतीय पक्षापेक्षा अधिक गोपनीयता मिळवू शकता.

दुसरीकडे, जर तुम्ही क्लायंट चालवत असाल, तर तुम्ही तो तुमच्या मित्रांना शेअर करू शकता ज्यांना त्याची गरज असेल.

## एक्झिक्युशन क्लायंट {#execution-clients}

Ethereum समुदाय एकाधिक ओपन-सोर्स एक्झिक्युशन क्लायंट्स (पूर्वी 'Eth1 क्लायंट्स' किंवा फक्त 'Ethereum क्लायंट्स' म्हणून ओळखले जाणारे) सांभाळतो, जे वेगवेगळ्या टीम्सनी वेगवेगळ्या प्रोग्रामिंग भाषा वापरून विकसित केले आहेत. हे नेटवर्कला अधिक मजबूत आणि अधिक [विविध](/developers/docs/nodes-and-clients/client-diversity/) बनवते. आदर्श ध्येय हे आहे की अपयशाचा कोणताही एकच बिंदू कमी करण्यासाठी कोणताही क्लायंट वर्चस्व गाजवणार नाही अशी विविधता प्राप्त करणे.

हा तक्ता वेगवेगळ्या क्लायंटचा सारांश देतो. ते सर्व [क्लायंट चाचण्या](https://github.com/ethereum/tests) पास करतात आणि नेटवर्क अपग्रेडसह अद्ययावत राहण्यासाठी सक्रियपणे देखरेख केली जाते.

| क्लायंट                                                                                     | भाषा                     | ऑपरेटिंग सिस्टीम      | नेटवर्क                | सिंक स्ट्रॅटेजीज                                                               | स्टेट प्रूनिंग     |
| ------------------------------------------------------------------------------------------- | ------------------------ | --------------------- | ---------------------- | ------------------------------------------------------------------------------ | ------------------ |
| [Geth](https://geth.ethereum.org/)                                                          | Go                       | Linux, Windows, macOS | मेननेट, सेपोलिया, हूडी | [स्नॅप](#snap-sync), [फुल](#full-sync)                                         | आर्काइव्ह, प्रुन्ड |
| [Nethermind](https://www.nethermind.io/)                                                    | C#, .NET | Linux, Windows, macOS | मेननेट, सेपोलिया, हूडी | [स्नॅप](#snap-sync) (सेवा न देता), फास्ट, [फुल](#full-sync) | आर्काइव्ह, प्रुन्ड |
| [Besu](https://besu.hyperledger.org/en/stable/)                                             | Java                     | Linux, Windows, macOS | मेननेट, सेपोलिया, हूडी | [स्नॅप](#snap-sync), [फास्ट](#fast-sync), [फुल](#full-sync)                    | आर्काइव्ह, प्रुन्ड |
| [Erigon](https://github.com/ledgerwatch/erigon)                                             | Go                       | Linux, Windows, macOS | मेननेट, सेपोलिया, हूडी | [फुल](#full-sync)                                                              | आर्काइव्ह, प्रुन्ड |
| [Reth](https://reth.rs/)                                                                    | Rust                     | Linux, Windows, macOS | मेननेट, सेपोलिया, हूडी | [फुल](#full-sync)                                                              | आर्काइव्ह, प्रुन्ड |
| [EthereumJS](https://github.com/ethereumjs/ethereumjs-monorepo) _(बीटा)_ | TypeScript               | Linux, Windows, macOS | सेपोलिया, हूडी         | [फुल](#full-sync)                                                              | प्रुन्ड            |

समर्थित नेटवर्कवर अधिक माहितीसाठी, [Ethereum नेटवर्क्स](/developers/docs/networks/) वर वाचा.

प्रत्येक क्लायंटचे स्वतःचे अनन्य उपयोग आणि फायदे आहेत, त्यामुळे तुम्ही तुमच्या स्वतःच्या आवडीनुसार एक निवडले पाहिजे. विविधता अंमलबजावणींना वेगवेगळ्या वैशिष्ट्यांवर आणि वापरकर्त्यांच्या प्रेक्षकांवर लक्ष केंद्रित करण्यास अनुमती देते. तुम्ही वैशिष्ट्ये, समर्थन, प्रोग्रामिंग भाषा किंवा परवान्यांवर आधारित क्लायंट निवडू शकता.

### Besu {#besu}

हायपरलेजर Besu हा सार्वजनिक आणि परवानगी असलेल्या नेटवर्क्ससाठी एक एंटरप्राइज-ग्रेड Ethereum क्लायंट आहे. हे ट्रेसिंगपासून GraphQL पर्यंत सर्व Ethereum मेननेट वैशिष्ट्ये चालवते, त्यात विस्तृत देखरेख आहे आणि ConsenSys द्वारे, मुक्त समुदाय चॅनेलमध्ये आणि एंटरप्राइझसाठी व्यावसायिक SLA द्वारे समर्थित आहे. हे Java मध्ये लिहिलेले आहे आणि Apache 2.0 परवानाकृत आहे.

Besu चे विस्तृत [दस्तऐवजीकरण](https://besu.hyperledger.org/en/stable/) तुम्हाला त्याच्या वैशिष्ट्यांबद्दल आणि सेटअपबद्दल सर्व तपशीलांमध्ये मार्गदर्शन करेल.

### Erigon {#erigon}

Erigon, पूर्वी Turbo-Geth म्हणून ओळखले जात असे, Go Ethereum च्या फोर्क म्हणून सुरू झाले जे गती आणि डिस्क-स्पेस कार्यक्षमतेवर केंद्रित होते. Erigon हे Ethereum चे पूर्णपणे पुनर्रचित केलेले अंमलबजावणी आहे, जे सध्या Go मध्ये लिहिलेले आहे परंतु इतर भाषांमध्ये अंमलबजावणी विकासाधीन आहे. Erigon चे ध्येय Ethereum ची जलद, अधिक मॉड्युलर आणि अधिक ऑप्टिमाइझ केलेली अंमलबजावणी प्रदान करणे आहे. हे सुमारे 2TB डिस्क स्पेस वापरून 3 दिवसांपेक्षा कमी वेळेत पूर्ण आर्काइव्ह नोड सिंक करू शकते.

### Go Ethereum {#geth}

Go Ethereum (थोडक्यात Geth) हे Ethereum प्रोटोकॉलच्या मूळ अंमलबजावणींपैकी एक आहे. सध्या, हे सर्वात व्यापक क्लायंट आहे ज्यात वापरकर्ते आणि विकासकांसाठी सर्वात मोठा वापरकर्ता आधार आणि विविध प्रकारची साधने आहेत. हे Go मध्ये लिहिलेले आहे, पूर्णपणे ओपन सोर्स आहे आणि GNU LGPL v3 अंतर्गत परवानाकृत आहे.

Geth बद्दल त्याच्या [दस्तऐवजीकरण](https://geth.ethereum.org/docs/) मध्ये अधिक जाणून घ्या.

### Nethermind {#nethermind}

Nethermind हे C# .NET टेक स्टॅकसह तयार केलेले Ethereum अंमलबजावणी आहे, जे LGPL-3.0 सह परवानाकृत आहे, ARM सह सर्व प्रमुख प्लॅटफॉर्मवर चालते. हे यासह उत्कृष्ट कार्यप्रदर्शन देते:

- एक ऑप्टिमाइझ केलेले व्हर्च्युअल मशीन
- स्टेट ऍक्सेस
- नेटवर्किंग आणि Prometheus/Grafana डॅशबोर्ड, seq एंटरप्राइझ लॉगिंग समर्थन, JSON-RPC ट्रेसिंग, आणि विश्लेषण प्लगइन यांसारख्या समृद्ध वैशिष्ट्ये.

Nethermind कडे [तपशीलवार दस्तऐवजीकरण](https://docs.nethermind.io), मजबूत डेव्हलपर समर्थन, एक ऑनलाइन समुदाय आणि प्रीमियम वापरकर्त्यांसाठी 24/7 समर्थन देखील उपलब्ध आहे.

### Reth {#reth}

Reth (Rust Ethereum चे संक्षिप्त रूप) हे एक Ethereum फुल नोड अंमलबजावणी आहे जे वापरकर्ता-अनुकूल, अत्यंत मॉड्युलर, जलद आणि कार्यक्षम असण्यावर लक्ष केंद्रित करते. Reth मूळतः Paradigm द्वारे तयार केले गेले आणि पुढे नेले गेले आणि ते Apache आणि MIT परवान्यांतर्गत परवानाकृत आहे.

Reth उत्पादनासाठी तयार आहे आणि स्टेकिंग किंवा उच्च-अपटाइम सेवांसारख्या मिशन-क्रिटिकल वातावरणात वापरासाठी योग्य आहे. RPC, MEV, इंडेक्सिंग, सिम्युलेशन आणि P2P क्रियाकलाप यांसारख्या उच्च कार्यक्षमतेची आवश्यकता असलेल्या वापराच्या प्रकरणांमध्ये चांगला परफाॅरमन्स देते.

[Reth बुक](https://reth.rs/) किंवा [Reth GitHub repo](https://github.com/paradigmxyz/reth?tab=readme-ov-file#reth) तपासून अधिक जाणून घ्या.

### विकासात {#execution-in-development}

हे क्लायंट अजूनही विकासाच्या सुरुवातीच्या टप्प्यात आहेत आणि अद्याप उत्पादन वापरासाठी शिफारस केलेले नाहीत.

#### EthereumJS {#ethereumjs}

EthereumJS एक्झिक्युशन क्लायंट (EthereumJS) TypeScript मध्ये लिहिलेला आहे आणि अनेक पॅकेजेसनी बनलेला आहे, ज्यात ब्लॉक, व्यवहार आणि मर्क्ल-पॅट्रिशिया ट्री क्लासेसद्वारे दर्शविलेले मूळ Ethereum आदिम आणि Ethereum व्हर्च्युअल मशीन (EVM) चे अंमलबजावणी, एक ब्लॉकचेन क्लास आणि DevP2P नेटवर्किंग स्टॅकसह मूळ क्लायंट घटक समाविष्ट आहेत.

त्याच्या [दस्तऐवजीकरण](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master) वाचून त्याबद्दल अधिक जाणून घ्या

## कन्सेंसस क्लायंट {#consensus-clients}

[कन्सेंसस अपग्रेड](/roadmap/beacon-chain/) ला समर्थन देण्यासाठी एकाधिक कन्सेंसस क्लायंट (पूर्वी 'Eth2' क्लायंट म्हणून ओळखले जाणारे) आहेत. ते फोर्क-चॉइस अल्गोरिदम, प्रमाणीकरणांवर प्रक्रिया करणे आणि [प्रूफ-ऑफ-स्टेक](/developers/docs/consensus-mechanisms/pos) पुरस्कार आणि दंड व्यवस्थापित करण्यासह सर्व कन्सेंसस-संबंधित तर्कासाठी जबाबदार आहेत.

| क्लायंट                                                       | भाषा       | ऑपरेटिंग सिस्टीम      | नेटवर्क                                                   |
| ------------------------------------------------------------- | ---------- | --------------------- | --------------------------------------------------------- |
| [Lighthouse](https://lighthouse.sigmaprime.io/)               | Rust       | Linux, Windows, macOS | बीकन चेन, हूडी, पिरमाँट, सेपोलिया, आणि बरेच काही          |
| [Lodestar](https://lodestar.chainsafe.io/)                    | TypeScript | Linux, Windows, macOS | बीकन चेन, हूडी, सेपोलिया, आणि बरेच काही                   |
| [Nimbus](https://nimbus.team/)                                | Nim        | Linux, Windows, macOS | बीकन चेन, हूडी, सेपोलिया, आणि बरेच काही                   |
| [Prysm](https://prysm.offchainlabs.com/docs/)                 | Go         | Linux, Windows, macOS | बीकन चेन, ग्नोसिस, हूडी, पिरमाँट, सेपोलिया, आणि बरेच काही |
| [Teku](https://consensys.net/knowledge-base/ethereum-2/teku/) | Java       | Linux, Windows, macOS | बीकन चेन, ग्नोसिस, हूडी, सेपोलिया, आणि बरेच काही          |
| [Grandine](https://docs.grandine.io/)                         | Rust       | Linux, Windows, macOS | बीकन चेन, हूडी, सेपोलिया, आणि बरेच काही                   |

### Lighthouse {#lighthouse}

Lighthouse हे Rust मध्ये Apache-2.0 परवान्याअंतर्गत लिहिलेले एक कन्सेंसस क्लायंट अंमलबजावणी आहे. हे सिग्मा प्राइम द्वारे सांभाळले जाते आणि बीकन चेन जेनेसिसपासून स्थिर आणि उत्पादनासाठी तयार आहे. विविध उपक्रम, स्टेकिंग पूल आणि व्यक्ती त्यावर अवलंबून आहेत. हे डेस्कटॉप पीसीपासून ते अत्याधुनिक स्वयंचलित उपयोजनांपर्यंतच्या विस्तृत वातावरणात सुरक्षित, कार्यक्षम आणि आंतर-कार्यक्षम असण्याचे उद्दिष्ट ठेवते.

दस्तऐवजीकरण [लाइटहाऊस बुक](https://lighthouse-book.sigmaprime.io/) मध्ये आढळू शकते

### Lodestar {#lodestar}

लोडस्टार हे Typescript मध्ये LGPL-3.0 परवान्याअंतर्गत लिहिलेले एक उत्पादन-तयार कन्सेंसस क्लायंट अंमलबजावणी आहे. हे चेनसेफ सिस्टीम्सद्वारे सांभाळले जाते आणि सोलो-स्टेकर्स, डेव्हलपर्स आणि संशोधकांसाठी कन्सेंसस क्लायंटमधील सर्वात नवीन आहे. लोडस्टारमध्ये बीकन नोड आणि व्हॅलिडेटर क्लायंटचा समावेश आहे जे Ethereum प्रोटोकॉलच्या JavaScript अंमलबजावणीद्वारे समर्थित आहेत. लोडस्टारचे उद्दिष्ट लाइट क्लायंटसह Ethereum उपयोगिता सुधारणे, विकसकांच्या मोठ्या गटासाठी सुलभता वाढवणे आणि इकोसिस्टम विविधतेमध्ये अधिक योगदान देणे हे आहे.

अधिक माहिती [लोडस्टार वेबसाइट](https://lodestar.chainsafe.io/) वर आढळू शकते

### Nimbus {#nimbus}

निंबस हे निममध्ये Apache-2.0 परवान्याअंतर्गत लिहिलेले एक कन्सेंसस क्लायंट अंमलबजावणी आहे. हा एक उत्पादन-तयार क्लायंट आहे जो सोलो-स्टेकर्स आणि स्टेकिंग पूलद्वारे वापरला जातो. निंबस संसाधनांच्या कार्यक्षमतेसाठी डिझाइन केलेले आहे, ज्यामुळे ते संसाधन-प्रतिबंधित उपकरणांवर आणि एंटरप्राइझ इन्फ्रास्ट्रक्चरवर समान सहजतेने चालवणे सोपे होते, स्थिरता किंवा बक्षीस कार्यक्षमतेशी तडजोड न करता. हलक्या संसाधनांच्या पदचिन्हाचा अर्थ असा आहे की नेटवर्क तणावाखाली असताना क्लायंटला सुरक्षिततेचा अधिक मार्जिन असतो.

[निंबस डॉक्स](https://nimbus.guide/) मध्ये अधिक जाणून घ्या

### Prysm {#prysm}

Prysm हे GPL-3.0 परवान्याअंतर्गत Go मध्ये लिहिलेले एक पूर्ण-वैशिष्ट्यीकृत, ओपन सोर्स कन्सेंसस क्लायंट आहे. यात एक पर्यायी वेबॲप UI आहे आणि घरातून स्टेक करणाऱ्या आणि संस्थात्मक वापरकर्त्यांसाठी वापरकर्ता अनुभव, दस्तऐवजीकरण आणि कॉन्फिगरिबिलिटीला प्राधान्य देते.

अधिक जाणून घेण्यासाठी [Prysm डॉक्स](https://prysm.offchainlabs.com/docs/) ला भेट द्या.

### Teku {#teku}

Teku हे मूळ बीकन चेन जेनेसिस क्लायंटपैकी एक आहे. नेहमीच्या उद्दिष्टांसोबतच (सुरक्षा, मजबुती, स्थिरता, उपयोगिता, कार्यक्षमता), Teku विशेषतः सर्व विविध कन्सेंसस क्लायंट मानकांचे पूर्णपणे पालन करण्याचे उद्दिष्ट ठेवते.

Teku खूप लवचिक उपयोजन पर्याय देते. बीकन नोड आणि व्हॅलिडेटर क्लायंट एकत्र एकाच प्रक्रियेत चालवले जाऊ शकतात, जे सोलो स्टेकर्ससाठी अत्यंत सोयीचे आहे, किंवा अत्याधुनिक स्टेकिंग ऑपरेशन्ससाठी नोड्स स्वतंत्रपणे चालवले जाऊ शकतात. याव्यतिरिक्त, Teku की सुरक्षा आणि स्लॅशिंग संरक्षणासाठी [Web3Signer](https://github.com/ConsenSys/web3signer/) सह पूर्णपणे आंतर-कार्यक्षम आहे.

Teku Java मध्ये लिहिलेले आहे आणि Apache 2.0 परवानाकृत आहे. हे ConsenSys मधील प्रोटोकॉल टीमद्वारे विकसित केले आहे जे Besu आणि Web3Signer साठी देखील जबाबदार आहे. [Teku डॉक्स](https://docs.teku.consensys.net/en/latest/) मध्ये अधिक जाणून घ्या.

### Grandine {#grandine}

Grandine हे Rust मध्ये GPL-3.0 परवान्याअंतर्गत लिहिलेले एक कन्सेंसस क्लायंट अंमलबजावणी आहे. हे Grandine कोअर टीमद्वारे सांभाळले जाते आणि ते जलद, उच्च-कार्यक्षम आणि हलके आहे. हे रास्पबेरी पाय सारख्या कमी-संसाधन उपकरणांवर चालणाऱ्या सोलो स्टेकर्सपासून ते हजारो व्हॅलिडेटर्स चालवणाऱ्या मोठ्या संस्थात्मक स्टेकर्सपर्यंतच्या विस्तृत स्टेकर्ससाठी योग्य आहे.

दस्तऐवजीकरण [Grandine Book](https://docs.grandine.io/) मध्ये आढळू शकते

## सिंक्रोनाइझेशन मोड {#sync-modes}

नेटवर्कमधील सद्य डेटाचे अनुसरण आणि पडताळणी करण्यासाठी, Ethereum क्लायंटला नवीनतम नेटवर्क स्थितीसह सिंक करणे आवश्यक आहे. हे पीअर्सकडून डेटा डाउनलोड करून, त्यांच्या अखंडतेची क्रिप्टोग्राफिकरित्या पडताळणी करून आणि स्थानिक ब्लॉकचेन डेटाबेस तयार करून केले जाते.

सिंक्रोनाइझेशन मोड्स या प्रक्रियेसाठी विविध ट्रेड-ऑफसह भिन्न दृष्टिकोन दर्शवतात. क्लायंट त्यांच्या सिंक अल्गोरिदमच्या अंमलबजावणीमध्ये देखील भिन्न आहेत. अंमलबजावणीवरील तपशीलांसाठी नेहमी तुमच्या निवडलेल्या क्लायंटच्या अधिकृत दस्तऐवजीकरणाचा संदर्भ घ्या.

### एक्झिक्युशन लेयर सिंक मोड्स {#execution-layer-sync-modes}

एक्झिक्युशन लेयर वेगवेगळ्या वापराच्या प्रकरणांसाठी वेगवेगळ्या मोड्समध्ये चालवले जाऊ शकते, ब्लॉकचेनच्या जागतिक स्थितीची पुन्हा-अंमलबजावणी करण्यापासून ते विश्वसनीय चेकपॉइंटवरून केवळ चेनच्या टोकाशी सिंक करण्यापर्यंत.

#### फुल सिंक {#full-sync}

एक फुल सिंक सर्व ब्लॉक्स (हेडर्स आणि ब्लॉक बॉडीसह) डाउनलोड करतो आणि जेनेसिसपासून प्रत्येक ब्लॉक कार्यान्वित करून ब्लॉकचेनची स्थिती वाढीवपणे पुन्हा तयार करतो.

- प्रत्येक व्यवहाराची पडताळणी करून विश्वास कमी करते आणि सर्वोच्च सुरक्षा देते.
- वाढत्या व्यवहारांच्या संख्येमुळे, सर्व व्यवहारांवर प्रक्रिया करण्यासाठी दिवस ते आठवडे लागू शकतात.

[आर्काइव्ह नोड्स](#archive-node) प्रत्येक ब्लॉकमधील प्रत्येक व्यवहाराद्वारे केलेल्या स्थिती बदलांचा संपूर्ण इतिहास तयार करण्यासाठी (आणि टिकवून ठेवण्यासाठी) पूर्ण सिंक करतात.

#### फास्ट सिंक {#fast-sync}

फुल सिंकप्रमाणे, फास्ट सिंक सर्व ब्लॉक्स (हेडर्स, व्यवहार आणि पावत्यांसह) डाउनलोड करतो. तथापि, ऐतिहासिक व्यवहारांवर पुन्हा प्रक्रिया करण्याऐवजी, फास्ट सिंक अलीकडील हेडपर्यंत पोहोचेपर्यंत पावत्यांवर अवलंबून असतो, त्यानंतर तो पूर्ण नोड प्रदान करण्यासाठी ब्लॉक्स इम्पोर्ट करणे आणि प्रक्रिया करणे सुरू करतो.

- फास्ट सिंक स्ट्रॅटेजी.
- बँडविड्थ वापराच्या बाजूने प्रक्रिया मागणी कमी करते.

#### स्नॅप सिंक {#snap-sync}

स्नॅप सिंक देखील चेनची ब्लॉक-दर-ब्लॉक पडताळणी करतात. तथापि, जेनेसिस ब्लॉकपासून सुरुवात करण्याऐवजी, स्नॅप सिंक अधिक अलीकडील 'विश्वसनीय' चेकपॉइंटपासून सुरू होतो जो खऱ्या ब्लॉकचेनचा भाग असल्याचे ओळखले जाते. नोड ठराविक वयापेक्षा जुना डेटा हटवताना नियतकालिक चेकपॉइंट्स सेव्ह करतो. हे स्नॅपशॉट्स कायमचे संग्रहित करण्याऐवजी आवश्यकतेनुसार स्टेट डेटा पुन्हा तयार करण्यासाठी वापरले जातात.

- सर्वात वेगवान सिंक स्ट्रॅटेजी, सध्या Ethereum मेननेटमध्ये डीफॉल्ट आहे.
- सुरक्षिततेशी तडजोड न करता भरपूर डिस्क वापर आणि नेटवर्क बँडविड्थ वाचवते.

[स्नॅप सिंकवर अधिक](https://github.com/ethereum/devp2p/blob/master/caps/snap.md).

#### लाइट सिंक {#light-sync}

लाइट क्लायंट मोड सर्व ब्लॉक हेडर्स, ब्लॉक डेटा डाउनलोड करतो आणि काहींची यादृच्छिकपणे पडताळणी करतो. केवळ विश्वसनीय चेकपॉइंटवरून चेनच्या टोकापर्यंत सिंक करते.

- विकसक आणि कन्सेंसस यंत्रणेवरील विश्वासावर अवलंबून राहून केवळ नवीनतम स्थिती प्राप्त करते.
- क्लायंट काही मिनिटांत सध्याच्या नेटवर्क स्थितीसह वापरण्यासाठी तयार.

**सूचना** लाइट सिंक अजूनही प्रूफ-ऑफ-स्टेक Ethereum सह कार्य करत नाही - लाइट सिंकच्या नवीन आवृत्त्या लवकरच पाठवल्या पाहिजेत!

[लाइट क्लायंटवर अधिक](/developers/docs/nodes-and-clients/light-clients/)

### कन्सेंसस लेयर सिंक मोड्स {#consensus-layer-sync-modes}

#### ऑप्टिमिस्टिक सिंक {#optimistic-sync}

ऑप्टिमिस्टिक सिंक ही एक विलीनीकरणानंतरची सिंक्रोनाइझेशन स्ट्रॅटेजी आहे जी ऑप्ट-इन आणि बॅकवर्ड्स सुसंगत असण्यासाठी डिझाइन केलेली आहे, ज्यामुळे एक्झिक्युशन नोड्सना स्थापित पद्धतींद्वारे सिंक करता येते. एक्झिक्युशन इंजिन _आशावादीपणे_ बीकन ब्लॉक्स पूर्णपणे सत्यापित न करता आयात करू शकते, नवीनतम हेड शोधू शकते आणि नंतर वरील पद्धतींसह चेन सिंक करणे सुरू करू शकते. त्यानंतर, एक्झिक्युशन क्लायंट पकडल्यानंतर, ते कन्सेंसस क्लायंटला बीकन चेनमधील व्यवहारांच्या वैधतेबद्दल सूचित करेल.

[ऑप्टिमिस्टिक सिंकवर अधिक](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md)

#### चेकपॉइंट सिंक {#checkpoint-sync}

चेकपॉइंट सिंक, ज्याला वीक सब्जेक्टिव्हिटी सिंक असेही म्हणतात, बीकन नोड सिंक करण्यासाठी एक उत्कृष्ट वापरकर्ता अनुभव तयार करतो. हे [कमकुवत व्यक्तिनिष्ठतेच्या](/developers/docs/consensus-mechanisms/pos/weak-subjectivity/) गृहितकांवर आधारित आहे जे जेनेसिसऐवजी अलीकडील कमकुवत व्यक्तिनिष्ठता चेकपॉइंटवरून बीकन चेन सिंक करण्यास सक्षम करते. चेकपॉइंट सिंक [जेनेसिस](/glossary/#genesis-block) पासून सिंक करण्यासारख्याच विश्वासाच्या गृहितकांसह प्रारंभिक सिंक वेळ लक्षणीयरीत्या जलद करतात.

व्यवहारात, याचा अर्थ असा की तुमचा नोड अलीकडील अंतिम स्थिती डाउनलोड करण्यासाठी रिमोट सेवेशी कनेक्ट होतो आणि त्या बिंदूपासून डेटाची पडताळणी करणे सुरू ठेवतो. डेटा प्रदान करणारा तृतीय पक्ष विश्वासार्ह आहे आणि काळजीपूर्वक निवडला पाहिजे.

[चेकपॉइंट सिंक](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice) वर अधिक

## पुढील वाचन {#further-reading}

- [Ethereum 101 - भाग 2 - नोड्स समजून घेणे](https://kauri.io/ethereum-101-part-2-understanding-nodes/48d5098292fd4f11b251d1b1814f0bba/a) _- विल् बार्न्स, 13 फेब्रुवारी 2019_
- [Ethereum फुल नोड्स चालवणे: केवळ प्रेरित लोकांसाठी एक मार्गदर्शक](https://medium.com/@JustinMLeroux/running-ethereum-full-nodes-a-guide-for-the-barely-motivated-a8a13e7a0d31) _- जस्टिन लेरॉक्स, 7 नोव्हेंबर 2019_

## संबंधित विषय {#related-topics}

- [ब्लॉक्स](/developers/docs/blocks/)
- [नेटवर्क्स](/developers/docs/networks/)

## संबंधित ट्युटोरियल्स {#related-tutorials}

- [तुमच्या रास्पबेरी पाय 4 ला फक्त मायक्रोएसडी कार्ड फ्लॅश करून व्हॅलिडेटर नोडमध्ये बदला - इन्स्टॉलेशन मार्गदर्शक](/developers/tutorials/run-node-raspberry-pi/) _- तुमचा रास्पबेरी पाय 4 फ्लॅश करा, इथरनेट केबल लावा, एसएसडी डिस्क कनेक्ट करा आणि रास्पबेरी पाय 4 ला एक्झिक्युशन लेयर (मेननेट) आणि/किंवा कन्सेंसस लेयर (बीकन चेन/व्हॅलिडेटर) चालवणारा पूर्ण Ethereum नोड बनवण्यासाठी डिव्हाइस चालू करा._
