---
title: "शून्य-ज्ञान रोलअप्स"
description: "शून्य-ज्ञान रोलअप्सचा परिचय — Ethereum समुदायाद्वारे वापरले जाणारे स्केलिंग सोल्यूशन."
lang: mr
---

शून्य-ज्ञान रोलअप्स (ZK-rollups) हे लेअर 2 [स्केलिंग सोल्यूशन्स](/developers/docs/scaling/) आहेत जे कम्प्युटेशन आणि स्टेट-स्टोरेज ऑफचेन हलवून Ethereum Mainnet वरील थ्रूपूट वाढवतात. ZK-rollups एका बॅचमध्ये हजारो व्यवहारांवर प्रक्रिया करू शकतात आणि नंतर Mainnet वर फक्त काही किमान सारांश डेटा पोस्ट करतात. हा सारांश डेटा Ethereum स्टेटमध्ये केले जाणारे बदल आणि ते बदल योग्य असल्याचे काही क्रिप्टोग्राफिक पुरावे परिभाषित करतो.

## पूर्वतयारी {#prerequisites}

तुम्ही आमचे [इथेरियम स्केलिंग](/developers/docs/scaling/) आणि [लेअर 2](/layer-2) वरील पेज वाचून समजून घेतलेले असावे.

## शून्य-ज्ञान रोलअप्स काय आहेत? {#what-are-zk-rollups}

**शून्य-ज्ञान रोलअप्स (ZK-rollups)** व्यवहारांना बॅचेसमध्ये बंडल (किंवा 'रोल अप') करतात जे ऑफचेन कार्यान्वित केले जातात. ऑफचेन कम्प्युटेशनमुळे ब्लॉकचेनवर पोस्ट कराव्या लागणाऱ्या डेटाचे प्रमाण कमी होते. ZK-रोलअप ऑपरेटर्स प्रत्येक व्यवहार स्वतंत्रपणे पाठवण्याऐवजी, एका बॅचमधील सर्व व्यवहारांचे प्रतिनिधित्व करण्यासाठी आवश्यक बदलांचा सारांश सबमिट करतात. ते त्यांच्या बदलांची अचूकता सिद्ध करण्यासाठी [वैधता पुरावे](/glossary/#validity-proof) देखील तयार करतात.

ZK-रोलअपची स्टेट Ethereum नेटवर्कवर तैनात केलेल्या स्मार्ट कॉन्ट्रॅक्टद्वारे सांभाळली जाते. ही स्टेट अपडेट करण्यासाठी, ZK-रोलअप नोड्सनी पडताळणीसाठी वैधता पुरावा सादर करणे आवश्यक आहे. नमूद केल्याप्रमाणे, वैधता पुरावा ही एक क्रिप्टोग्राफिक हमी आहे की रोलअपद्वारे प्रस्तावित स्टेट-बदल हा दिलेल्या व्यवहारांच्या बॅचला कार्यान्वित करण्याचाच परिणाम आहे. याचा अर्थ असा की [ऑप्टिमिस्टिक रोलअप्स](/developers/docs/scaling/optimistic-rollups/) प्रमाणे सर्व व्यवहार डेटा ऑनचेन पोस्ट करण्याऐवजी, ZK-रोलअप्सना Ethereum वर व्यवहार अंतिम करण्यासाठी फक्त वैधता पुरावे प्रदान करणे आवश्यक आहे.

ZK-रोलअपमधून Ethereum मध्ये निधी हलवताना कोणताही विलंब होत नाही, कारण ZK-रोलअप कॉन्ट्रॅक्टने वैधता पुराव्याची पडताळणी केल्यावर बाहेर पडण्याचे व्यवहार कार्यान्वित केले जातात. याउलट, ऑप्टिमिस्टिक रोलअपमधून निधी काढण्यास विलंब होतो, जेणेकरून कोणालाही [फ्रॉड प्रूफ](/glossary/#fraud-proof) सह बाहेर पडण्याच्या व्यवहाराला आव्हान देता येईल.

ZK-रोलअप्स Ethereum वर `calldata` म्हणून व्यवहार लिहितात. `calldata` हे असे ठिकाण आहे जिथे स्मार्ट कॉन्ट्रॅक्ट फंक्शन्सच्या बाह्य कॉल्समध्ये समाविष्ट केलेला डेटा संग्रहित केला जातो. `calldata` मधील माहिती ब्लॉकचेनवर प्रकाशित केली जाते, ज्यामुळे कोणालाही रोलअपची स्टेट स्वतंत्रपणे पुनर्रचना करता येते. ZK-रोलअप्स व्यवहार डेटा कमी करण्यासाठी कॉम्प्रेशन तंत्रांचा वापर करतात—उदाहरणार्थ, अकाउंट्स पत्त्याऐवजी निर्देशांकाद्वारे दर्शविले जातात, ज्यामुळे 28 बाइट्स डेटा वाचतो. ऑनचेन डेटा प्रकाशन ही रोलअपसाठी एक महत्त्वपूर्ण खर्च आहे, त्यामुळे डेटा कॉम्प्रेशन वापरकर्त्यांसाठी शुल्क कमी करू शकते.

## ZK-रोलअप Ethereum सोबत कसे संवाद साधतात? {#zk-rollups-and-ethereum}

ZK-रोलअप चेन हा एक ऑफचेन प्रोटोकॉल आहे जो Ethereum ब्लॉकचेनच्या वर काम करतो आणि ऑनचेन Ethereum स्मार्ट कॉन्ट्रॅक्टद्वारे व्यवस्थापित केला जातो. ZK-रोलअप्स Mainnet च्या बाहेर व्यवहार कार्यान्वित करतात, परंतु ठराविक कालावधीने ऑफचेन व्यवहार बॅचेस ऑनचेन रोलअप कॉन्ट्रॅक्टला सादर करतात. हा व्यवहार रेकॉर्ड अपरिवर्तनीय असतो, जसा Ethereum ब्लॉकचेन असतो, आणि तो ZK-रोलअप चेन तयार करतो.

ZK-रोलअपच्या मुख्य रचनेत खालील घटक असतात:

1. **ऑनचेन कॉन्ट्रॅक्ट्स**: नमूद केल्याप्रमाणे, ZK-रोलअप प्रोटोकॉल Ethereum वर चालणाऱ्या स्मार्ट कॉन्ट्रॅक्टद्वारे नियंत्रित केला जातो. यामध्ये मुख्य कॉन्ट्रॅक्टचा समावेश आहे जो रोलअप ब्लॉक्स संग्रहित करतो, डिपॉझिट्सचा मागोवा घेतो आणि स्टेट अपडेट्सचे निरीक्षण करतो. आणखी एक ऑनचेन कॉन्ट्रॅक्ट (व्हेरिफायर कॉन्ट्रॅक्ट) ब्लॉक प्रोड्युसर्सद्वारे सबमिट केलेल्या शून्य-ज्ञान पुराव्यांची पडताळणी करतो. अशाप्रकारे, Ethereum ZK-रोलअपसाठी बेस लेअर किंवा "लेअर 1" म्हणून काम करते.

2. **ऑफचेन व्हर्च्युअल मशीन (VM)**: जरी ZK-रोलअप प्रोटोकॉल Ethereum वर राहत असला तरी, व्यवहार अंमलबजावणी आणि स्टेट स्टोरेज [EVM](/developers/docs/evm/) पेक्षा स्वतंत्र असलेल्या वेगळ्या व्हर्च्युअल मशीनवर घडते. ही ऑफचेन VM ZK-रोलअपवरील व्यवहारांसाठी अंमलबजावणीचे वातावरण आहे आणि ZK-रोलअप प्रोटोकॉलसाठी सेकंडरी लेअर किंवा "लेअर 2" म्हणून काम करते. Ethereum Mainnet वर सत्यापित केलेले वैधता पुरावे ऑफचेन VM मधील स्टेट संक्रमणांची अचूकता हमी देतात.

ZK-रोलअप हे "हायब्रिड स्केलिंग सोल्यूशन्स" आहेत—ऑफचेन प्रोटोकॉल जे स्वतंत्रपणे कार्य करतात परंतु Ethereum कडून सुरक्षा प्राप्त करतात. विशेषतः, Ethereum नेटवर्क ZK-रोलअपवरील स्टेट अपडेट्सची वैधता लागू करते आणि रोलअपच्या स्टेटच्या प्रत्येक अपडेटमागील डेटाची उपलब्धता सुनिश्चित करते. परिणामी, ZK-रोलअप्स हे [साईडचेन्स](/developers/docs/scaling/sidechains/) सारख्या शुद्ध ऑफचेन स्केलिंग सोल्यूशन्सपेक्षा बरेच सुरक्षित आहेत, जे त्यांच्या सुरक्षा गुणधर्मांसाठी जबाबदार असतात, किंवा [व्हॅलिडियम्स](/developers/docs/scaling/validium/), जे Ethereum वर वैधता पुराव्यांसह व्यवहारांची पडताळणी करतात, परंतु व्यवहार डेटा इतरत्र संग्रहित करतात.

ZK-रोलअप खालील गोष्टींसाठी मुख्य Ethereum प्रोटोकॉलवर अवलंबून असतात:

### डेटा उपलब्धता {#data-availability}

ZK-रोलअप ऑफचेन प्रक्रिया केलेल्या प्रत्येक व्यवहारासाठी स्टेट डेटा Ethereum वर प्रकाशित करतात. या डेटाद्वारे, व्यक्ती किंवा व्यवसायांना रोलअपची स्टेट पुनरुत्पादित करणे आणि स्वतःच चेनची वैधता तपासणे शक्य होते. Ethereum हा डेटा नेटवर्कमधील सर्व सहभागींना `calldata` म्हणून उपलब्ध करून देते.

ZK-रोलअपला जास्त व्यवहार डेटा ऑनचेन प्रकाशित करण्याची आवश्यकता नाही कारण वैधता पुरावे आधीच स्टेट संक्रमणांची सत्यता पडताळतात. तरीही, ऑनचेन डेटा संग्रहित करणे महत्त्वाचे आहे कारण ते L2 चेनच्या स्टेटची परवानगीरहित, स्वतंत्र पडताळणी करण्यास अनुमती देते, ज्यामुळे कोणालाही व्यवहारांचे बॅचेस सबमिट करता येतात, आणि दुर्भावनापूर्ण ऑपरेटर्सना चेननला सेन्सॉर करण्यापासून किंवा फ्रीझ करण्यापासून प्रतिबंधित करते.

वापरकर्त्यांना रोलअपसह संवाद साधण्यासाठी ऑनचेन आवश्यक आहे. स्टेट डेटामध्ये प्रवेशाशिवाय वापरकर्ते त्यांच्या खात्यातील शिल्लक तपासू शकत नाहीत किंवा स्टेट माहितीवर अवलंबून असलेले व्यवहार (उदा. पैसे काढणे) सुरू करू शकत नाहीत.

### व्यवहाराची अंतिम निश्चिती {#transaction-finality}

Ethereum ZK-रोलअप्ससाठी सेटलमेंट लेअर म्हणून काम करते: L2 व्यवहार तेव्हाच अंतिम होतात जेव्हा L1 कॉन्ट्रॅक्ट वैधता पुरावा स्वीकारतो. यामुळे दुर्भावनापूर्ण ऑपरेटर्सकडून चेनमध्ये गडबड होण्याचा (उदा. रोलअप निधी चोरणे) धोका नाहीसा होतो कारण प्रत्येक व्यवहाराला Mainnet वर मंजूर करणे आवश्यक असते. तसेच, Ethereum हमी देते की एकदा L1 वर अंतिम झाल्यावर वापरकर्त्याच्या क्रिया उलटवल्या जाऊ शकत नाहीत.

### सेन्सॉरशिप प्रतिरोध {#censorship-resistance}

बहुतेक ZK-रोलअप्स व्यवहार कार्यान्वित करण्यासाठी, बॅच तयार करण्यासाठी आणि L1 वर ब्लॉक्स सबमिट करण्यासाठी "सुपरनोड" (ऑपरेटर) वापरतात. यामुळे कार्यक्षमता सुनिश्चित होत असली तरी, सेन्सॉरशिपचा धोका वाढतो: दुर्भावनापूर्ण ZK-रोलअप ऑपरेटर्स वापरकर्त्यांच्या व्यवहारांना बॅचेसमध्ये समाविष्ट करण्यास नकार देऊन त्यांना सेन्सॉर करू शकतात.

सुरक्षितता उपाय म्हणून, ZK-रोलअप वापरकर्त्यांना थेट Mainnet वरील रोलअप कॉन्ट्रॅक्टमध्ये व्यवहार सबमिट करण्याची परवानगी देतात जर त्यांना वाटत असेल की ऑपरेटर त्यांना सेन्सॉर करत आहे. यामुळे वापरकर्त्यांना ऑपरेटरच्या परवानगीवर अवलंबून न राहता ZK-रोलअपमधून Ethereum वर बाहेर पडण्यास भाग पाडता येते.

## ZK-रोलअप कसे कार्य करतात? {#how-do-zk-rollups-work}

### व्यवहार {#transactions}

ZK-रोलअपमधील वापरकर्ते व्यवहारांवर स्वाक्षरी करतात आणि प्रक्रियेसाठी आणि पुढील बॅचमध्ये समावेशासाठी L2 ऑपरेटर्सकडे सबमिट करतात. काही प्रकरणांमध्ये, ऑपरेटर एक केंद्रीकृत संस्था असते, ज्याला सिक्वेन्सर म्हणतात, जो व्यवहार कार्यान्वित करतो, त्यांना बॅचमध्ये एकत्र करतो आणि L1 वर सबमिट करतो. या प्रणालीतील सिक्वेन्सर ही एकमेव संस्था आहे जिला L2 ब्लॉक्स तयार करण्याची आणि ZK-रोलअप कॉन्ट्रॅक्टमध्ये रोलअप व्यवहार जोडण्याची परवानगी आहे.

इतर ZK-रोलअप्स [प्रूफ-ऑफ-स्टेक](/developers/docs/consensus-mechanisms/pos/) व्हॅलिडेटर सेट वापरून ऑपरेटरची भूमिका फिरवत ठेवू शकतात. संभाव्य ऑपरेटर रोलअप कॉन्ट्रॅक्टमध्ये निधी जमा करतात, प्रत्येक स्टेकचा आकार पुढील रोलअप बॅच तयार करण्यासाठी निवडल्या जाण्याच्या स्टेकरच्या संधीवर प्रभाव टाकतो. जर ऑपरेटरने दुर्भावनापूर्णपणे काम केले तर त्याचा स्टेक कापला जाऊ शकतो, ज्यामुळे त्यांना वैध ब्लॉक्स पोस्ट करण्यास प्रोत्साहन मिळते.

#### ZK-रोलअप्स Ethereum वर व्यवहार डेटा कसा प्रकाशित करतात {#how-zk-rollups-publish-transaction-data-on-ethereum}

स्पष्ट केल्याप्रमाणे, व्यवहार डेटा Ethereum वर `calldata` म्हणून प्रकाशित केला जातो. `calldata` स्मार्ट कॉन्ट्रॅक्टमधील डेटा एरिया आहे जो फंक्शनला वितर्क पास करण्यासाठी वापरला जातो आणि [मेमरी](/developers/docs/smart-contracts/anatomy/#memory) प्रमाणेच कार्य करतो. जरी `calldata` Ethereum च्या स्टेटचा भाग म्हणून संग्रहित नसला तरी, तो Ethereum चेनच्या [इतिहास लॉग](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html?highlight=memory#logs) चा भाग म्हणून ऑनचेन टिकतो. `calldata` Ethereum च्या स्टेटवर परिणाम करत नाही, ज्यामुळे तो ऑनचेन डेटा संग्रहित करण्याचा एक स्वस्त मार्ग बनतो.

`calldata` कीवर्ड बहुतेकदा व्यवहाराद्वारे कॉल केलेल्या स्मार्ट कॉन्ट्रॅक्ट पद्धतीची ओळख करून देतो आणि बाइट्सच्या अनियंत्रित क्रमाने पद्धतीसाठी इनपुट धारण करतो. ZK-रोलअप संकुचित व्यवहार डेटा ऑनचेन प्रकाशित करण्यासाठी `calldata` वापरतात; रोलअप ऑपरेटर फक्त रोलअप कॉन्ट्रॅक्टमध्ये आवश्यक फंक्शन कॉल करून नवीन बॅच जोडतो आणि संकुचित डेटा फंक्शन वितर्क म्हणून पास करतो. हे वापरकर्त्यांसाठी खर्च कमी करण्यास मदत करते कारण रोलअप शुल्काचा मोठा भाग ऑनचेन व्यवहार डेटा संग्रहित करण्यासाठी जातो.

### स्टेट कमिटमेंट्स {#state-commitments}

ZK-रोलअपची स्टेट, ज्यात L2 अकाउंट्स आणि बॅलन्स समाविष्ट आहेत, [मर्कल ट्री](/whitepaper/#merkle-trees) म्हणून दर्शविली जाते. मर्कल ट्रीच्या मूळ (मर्कल रूट) चा क्रिप्टोग्राफिक हॅश ऑनचेन कॉन्ट्रॅक्टमध्ये संग्रहित केला जातो, ज्यामुळे रोलअप प्रोटोकॉलला ZK-रोलअपच्या स्टेटमधील बदलांचा मागोवा घेता येतो.

नवीन व्यवहारांच्या संचाच्या अंमलबजावणीनंतर रोलअप नवीन स्थितीत जातो. स्टेट ट्रान्झिशन सुरू करणाऱ्या ऑपरेटरला नवीन स्टेट रूटची गणना करणे आणि ते ऑनचेन कॉन्ट्रॅक्टला सादर करणे आवश्यक आहे. जर बॅचशी संबंधित वैधता पुरावा व्हेरिफायर कॉन्ट्रॅक्टद्वारे प्रमाणित केला गेला, तर नवीन मर्कल रूट ZK-रोलअपचा कॅनॉनिकल स्टेट रूट बनतो.

स्टेट रूट्सची गणना करण्याव्यतिरिक्त, ZK-रोलअप ऑपरेटर बॅच रूट देखील तयार करतो - बॅचमधील सर्व व्यवहारांचा समावेश असलेल्या मर्कल ट्रीचा रूट. जेव्हा नवीन बॅच सबमिट केली जाते, तेव्हा रोलअप कॉन्ट्रॅक्ट बॅच रूट संग्रहित करतो, ज्यामुळे वापरकर्त्यांना व्यवहार (उदा. पैसे काढण्याची विनंती) बॅचमध्ये समाविष्ट असल्याचे सिद्ध करता येते. वापरकर्त्यांना व्यवहाराचे तपशील, बॅच रूट आणि समावेशाचा मार्ग दर्शवणारा [मर्कल प्रूफ](/developers/tutorials/merkle-proofs-for-offline-data-integrity/) द्यावा लागेल.

### वैधता पुरावे {#validity-proofs}

ZK-रोलअप ऑपरेटर L1 कॉन्ट्रॅक्टला सादर करणारा नवीन स्टेट रूट रोलअपच्या स्टेटमधील अपडेट्सचा परिणाम आहे. समजा ॲलिसने बॉबला 10 टोकन पाठवले, तर ऑपरेटर फक्त ॲलिसची शिल्लक 10 ने कमी करतो आणि बॉबची शिल्लक 10 ने वाढवतो. त्यानंतर ऑपरेटर अपडेट केलेल्या खात्याच्या डेटाचा हॅश करतो, रोलअपची मर्कल ट्री पुन्हा तयार करतो आणि नवीन मर्कल रूट ऑनचेन कॉन्ट्रॅक्टला सादर करतो.

परंतु रोलअप कॉन्ट्रॅक्ट प्रस्तावित स्टेट कमिटमेंट आपोआप स्वीकारणार नाही जोपर्यंत ऑपरेटर हे सिद्ध करत नाही की नवीन मर्कल रूट रोलअपच्या स्टेटमधील योग्य अपडेट्समधून आला आहे. ZK-रोलअप ऑपरेटर वैधता पुरावा तयार करून हे करतो, जो बॅचमधील व्यवहारांची अचूकता सत्यापित करणारी एक संक्षिप्त क्रिप्टोग्राफिक कमिटमेंट आहे.

वैधता पुरावे पक्षांना विधान स्वतः उघड न करता विधानाची अचूकता सिद्ध करण्याची परवानगी देतात—म्हणून, त्यांना शून्य-ज्ञान पुरावे देखील म्हटले जाते. ZK-रोलअप्स Ethereum वर व्यवहार पुन्हा कार्यान्वित न करता ऑफचेन स्टेट संक्रमणांची अचूकता पुष्टी करण्यासाठी वैधता पुरावे वापरतात. हे पुरावे [ZK-SNARK](https://arxiv.org/abs/2202.06877) (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) किंवा [ZK-STARK](https://eprint.iacr.org/2018/046) (Zero-Knowledge Scalable Transparent Argument of Knowledge) स्वरूपात येऊ शकतात.

SNARKs आणि STARKs दोन्ही ZK-रोलअपमध्ये ऑफचेन गणनेच्या अखंडतेची साक्ष देण्यास मदत करतात, जरी प्रत्येक पुरावा प्रकारात विशिष्ट वैशिष्ट्ये आहेत.

**ZK-SNARKs**

ZK-SNARK प्रोटोकॉल कार्य करण्यासाठी, एक कॉमन रेफरन्स स्ट्रिंग (CRS) तयार करणे आवश्यक आहे: CRS वैधता पुरावे सिद्ध करण्यासाठी आणि सत्यापित करण्यासाठी सार्वजनिक पॅरामीटर्स प्रदान करते. सिद्धता प्रणालीची सुरक्षा CRS सेटअपवर अवलंबून असते; जर सार्वजनिक पॅरामीटर्स तयार करण्यासाठी वापरलेली माहिती दुर्भावनापूर्ण घटकांच्या ताब्यात आली तर ते खोटे वैधता पुरावे तयार करू शकतात.

काही ZK-रोलअप्स ही समस्या सोडवण्यासाठी ZK-SNARK सर्किटसाठी सार्वजनिक पॅरामीटर्स तयार करण्यासाठी विश्वासू व्यक्तींचा समावेश असलेल्या [मल्टी-पार्टी कॉम्प्युटेशन सेरेमनी (MPC)](https://zkproof.org/2021/06/30/setup-ceremonies/amp/) वापरण्याचा प्रयत्न करतात. प्रत्येक पक्ष CRS तयार करण्यासाठी काही यादृच्छिकता ("विषारी कचरा" म्हटले जाते) योगदान देतो, जे त्यांनी त्वरित नष्ट केले पाहिजे.

विश्वसनीय सेटअप्स वापरले जातात कारण ते CRS सेटअपची सुरक्षा वाढवतात. जोपर्यंत एक प्रामाणिक सहभागी आपले इनपुट नष्ट करतो, तोपर्यंत ZK-SNARK प्रणालीची सुरक्षा हमी दिली जाते. तरीही, या दृष्टिकोनासाठी सहभागींवर विश्वास ठेवणे आवश्यक आहे की ते त्यांची नमुना यादृच्छिकता हटवतील आणि प्रणालीच्या सुरक्षा हमींना कमी करणार नाहीत.

विश्वासाच्या गृहितकांना बाजूला ठेवून, ZK-SNARKs त्यांच्या लहान पुरावा आकारांसाठी आणि स्थिर-वेळ पडताळणीसाठी लोकप्रिय आहेत. L1 वर पुरावा पडताळणी ही ZK-रोलअप चालवण्याचा मोठा खर्च असल्याने, L2s ZK-SNARKs वापरून पुरावे तयार करतात जे Mainnet वर जलद आणि स्वस्तात सत्यापित केले जाऊ शकतात.

**ZK-STARKs**

ZK-SNARKs प्रमाणेच, ZK-STARKs इनपुट उघड न करता ऑफचेन गणनेची वैधता सिद्ध करतात. तथापि, ZK-STARKs त्यांच्या स्केलेबिलिटी आणि पारदर्शकतेमुळे ZK-SNARKs वर सुधारणा मानले जातात.

ZK-STARKs 'पारदर्शक' आहेत, कारण ते कॉमन रेफरन्स स्ट्रिंग (CRS) च्या विश्वसनीय सेटअपशिवाय काम करू शकतात. त्याऐवजी, ZK-STARKs पुरावे तयार करण्यासाठी आणि सत्यापित करण्यासाठी पॅरामीटर्स सेट करण्यासाठी सार्वजनिकरित्या सत्यापित करण्यायोग्य यादृच्छिकतेवर अवलंबून असतात.

ZK-STARKs अधिक स्केलेबिलिटी देखील प्रदान करतात कारण वैधता पुरावे सिद्ध करण्यासाठी आणि सत्यापित करण्यासाठी लागणारा वेळ अंतर्निहित गणनेच्या जटिलतेच्या संबंधात _क्वासीलिनियरली_ वाढतो. ZK-SNARKs सह, सिद्ध करणे आणि पडताळणीचा वेळ अंतर्निहित गणनेच्या आकाराच्या संबंधात _रेखीयपणे_ वाढतो. याचा अर्थ असा की जेव्हा मोठ्या डेटासेटचा समावेश असतो तेव्हा ZK-STARKs ला ZK-SNARKs पेक्षा सिद्ध करण्यासाठी आणि सत्यापित करण्यासाठी कमी वेळ लागतो, ज्यामुळे ते उच्च-व्हॉल्यूम ॲप्लिकेशन्ससाठी उपयुक्त ठरतात.

ZK-STARKs क्वांटम संगणकांविरुद्ध देखील सुरक्षित आहेत, तर ZK-SNARKs मध्ये वापरलेली इलिप्टिक कर्व क्रिप्टोग्राफी (ECC) क्वांटम संगणकीय हल्ल्यांना बळी पडण्याची शक्यता आहे असे मानले जाते. ZK-STARKs चा तोटा हा आहे की ते मोठ्या आकाराचे पुरावे तयार करतात, जे Ethereum वर सत्यापित करण्यासाठी अधिक महाग आहेत.

#### ZK-रोलअपमध्ये वैधता पुरावे कसे कार्य करतात? {#validity-proofs-in-zk-rollups}

##### पुरावा निर्मिती

व्यवहार स्वीकारण्यापूर्वी, ऑपरेटर नेहमीच्या तपासण्या करेल. यामध्ये याची पुष्टी करणे समाविष्ट आहे की:

- प्रेषक आणि प्राप्तकर्ता खाती स्टेट ट्रीचा भाग आहेत.
- प्रेषकाकडे व्यवहार प्रक्रिया करण्यासाठी पुरेसा निधी आहे.
- व्यवहार योग्य आहे आणि रोलअपवरील प्रेषकाच्या सार्वजनिक कीशी जुळतो.
- प्रेषकाचा नॉन्स योग्य आहे, इत्यादी.

एकदा ZK-रोलअप नोडकडे पुरेसे व्यवहार झाल्यावर, तो त्यांना एका बॅचमध्ये एकत्रित करतो आणि एक संक्षिप्त ZK-पुरावा संकलित करण्यासाठी सिद्ध करणाऱ्या सर्किटसाठी इनपुट संकलित करतो. यात समाविष्ट आहे:

- बॅचमधील सर्व व्यवहारांचा समावेश असलेला एक मर्कल ट्री रूट.
- बॅचमध्ये समावेश सिद्ध करण्यासाठी व्यवहारांसाठी मर्कल पुरावे.
- व्यवहारांमधील प्रत्येक प्रेषक-प्राप्तकर्ता जोडीसाठी मर्कल पुरावे हे सिद्ध करण्यासाठी की ती खाती रोलअपच्या स्टेट ट्रीचा भाग आहेत.
- प्रत्येक व्यवहारासाठी स्टेट अपडेट लागू केल्यानंतर स्टेट रूट अपडेट करून प्राप्त झालेल्या इंटरमीडिएट स्टेट रूट्सचा एक संच (म्हणजे, प्रेषक खाती कमी करणे आणि प्राप्तकर्ता खाती वाढवणे).

सिद्ध करणारे सर्किट प्रत्येक व्यवहारावर "लूपिंग" करून आणि व्यवहार प्रक्रिया करण्यापूर्वी ऑपरेटरने पूर्ण केलेल्या त्याच तपासण्या करून वैधता पुरावा मोजते. प्रथम, ते प्रदान केलेल्या मर्कल पुराव्याचा वापर करून प्रेषकाचे खाते विद्यमान स्टेट रूटचा भाग असल्याची पडताळणी करते. नंतर ते प्रेषकाची शिल्लक कमी करते, त्याचा नॉन्स वाढवते, अद्ययावत खात्याच्या डेटाचा हॅश करते आणि नवीन मर्कल रूट तयार करण्यासाठी मर्कल पुराव्यासोबत जोडते.

हा मर्कल रूट ZK-रोलअपच्या स्टेटमधील एकमेव बदल दर्शवतो: प्रेषकाची शिल्लक आणि नॉन्समध्ये बदल. हे शक्य आहे कारण खात्याचे अस्तित्व सिद्ध करण्यासाठी वापरलेला मर्कल पुरावा नवीन स्टेट रूट मिळवण्यासाठी वापरला जातो.

सिद्ध करणारे सर्किट प्राप्तकर्त्याच्या खात्यावर समान प्रक्रिया करते. ते तपासते की प्राप्तकर्त्याचे खाते इंटरमीडिएट स्टेट रूट अंतर्गत अस्तित्वात आहे की नाही (मर्कल पुराव्याचा वापर करून), त्यांची शिल्लक वाढवते, खात्याच्या डेटाचा पुन्हा हॅश करते आणि नवीन स्टेट रूट तयार करण्यासाठी मर्कल पुराव्यासोबत जोडते.

ही प्रक्रिया प्रत्येक व्यवहारासाठी पुनरावृत्ती होते; प्रत्येक "लूप" प्रेषकाचे खाते अद्यतनित करून एक नवीन स्टेट रूट तयार करतो आणि त्यानंतर प्राप्तकर्त्याचे खाते अद्यतनित करून एक नवीन रूट तयार करतो. स्पष्ट केल्याप्रमाणे, स्टेट रूटमधील प्रत्येक अपडेट रोलअपच्या स्टेट ट्रीचा एक भाग बदलण्याचे प्रतिनिधित्व करतो.

ZK-सिद्ध करणारे सर्किट संपूर्ण व्यवहार बॅचवर पुनरावृत्ती करते, शेवटचा व्यवहार कार्यान्वित झाल्यानंतर अंतिम स्टेट रूटमध्ये परिणाम करणाऱ्या अद्यतनांच्या क्रमाची पडताळणी करते. शेवटचा गणना केलेला मर्कल रूट ZK-रोलअपचा सर्वात नवीन कॅनॉनिकल स्टेट रूट बनतो.

##### पुरावा पडताळणी

सिद्ध करणारे सर्किट स्टेट अपडेट्सची अचूकता सत्यापित केल्यानंतर, L2 ऑपरेटर गणना केलेला वैधता पुरावा L1 वरील व्हेरिफायर कॉन्ट्रॅक्टला सादर करतो. कॉन्ट्रॅक्टचे व्हेरिफिकेशन सर्किट पुराव्याच्या वैधतेची पडताळणी करते आणि पुराव्याचा भाग असलेल्या सार्वजनिक इनपुटची देखील तपासणी करते:

- **प्री-स्टेट रूट**: ZK-रोलअपचा जुना स्टेट रूट (म्हणजे, बॅच केलेले व्यवहार कार्यान्वित होण्यापूर्वी), L2 चेनची शेवटची ज्ञात वैध स्टेट दर्शवतो.

- **पोस्ट-स्टेट रूट**: ZK-रोलअपचा नवीन स्टेट रूट (म्हणजे, बॅच केलेल्या व्यवहारांच्या अंमलबजावणीनंतर), L2 चेनची सर्वात नवीन स्टेट दर्शवतो. पोस्ट-स्टेट रूट हा सिद्ध करणाऱ्या सर्किटमध्ये स्टेट अपडेट लागू केल्यानंतर मिळवलेला अंतिम रूट आहे.

- **बॅच रूट**: बॅचचा मर्कल रूट, जो बॅचमधील व्यवहारांना _मर्कलाईझ_ करून आणि ट्रीच्या रूटचा हॅश करून मिळवला जातो.

- **व्यवहार इनपुट**: सबमिट केलेल्या बॅचचा भाग म्हणून कार्यान्वित केलेल्या व्यवहारांशी संबंधित डेटा.

जर पुरावा सर्किटला समाधान देत असेल (म्हणजे, तो वैध असेल), तर याचा अर्थ असा की वैध व्यवहारांचा एक क्रम अस्तित्वात आहे जो रोलअपला मागील स्टेटमधून (प्री-स्टेट रूटद्वारे क्रिप्टोग्राफिकली फिंगरप्रिंट केलेले) नवीन स्टेटमध्ये (पोस्ट-स्टेट रूटद्वारे क्रिप्टोग्राफिकली फिंगरप्रिंट केलेले) संक्रमण करतो. जर प्री-स्टेट रूट रोलअप कॉन्ट्रॅक्टमध्ये संग्रहित रूटशी जुळत असेल आणि पुरावा वैध असेल, तर रोलअप कॉन्ट्रॅक्ट पुराव्यातून पोस्ट-स्टेट रूट घेतो आणि रोलअपची बदललेली स्टेट दर्शवण्यासाठी त्याचे स्टेट ट्री अपडेट करतो.

### एंट्रीज आणि एग्झिट्स {#entries-and-exits}

वापरकर्ते L1 चेनवर तैनात केलेल्या रोलअपच्या कॉन्ट्रॅक्टमध्ये टोकन जमा करून ZK-रोलअपमध्ये प्रवेश करतात. हा व्यवहार रांगेत ठेवला जातो कारण फक्त ऑपरेटरच रोलअप कॉन्ट्रॅक्टमध्ये व्यवहार सबमिट करू शकतात.

जर प्रलंबित डिपॉझिट रांग भरू लागली, तर ZK-रोलअप ऑपरेटर डिपॉझिट व्यवहार घेईल आणि त्यांना रोलअप कॉन्ट्रॅक्टमध्ये सबमिट करेल. एकदा वापरकर्त्याचे निधी रोलअपमध्ये आल्यावर, ते प्रक्रियेसाठी ऑपरेटरला व्यवहार पाठवून व्यवहार सुरू करू शकतात. वापरकर्ते त्यांच्या खात्याच्या डेटाचा हॅश करून, हॅश रोलअप कॉन्ट्रॅक्टला पाठवून, आणि वर्तमान स्टेट रूटविरुद्ध पडताळणी करण्यासाठी मर्कल पुरावा प्रदान करून रोलअपवरील शिल्लक सत्यापित करू शकतात.

ZK-रोलअपमधून L1 मध्ये पैसे काढणे सोपे आहे. वापरकर्ता रोलअपवरील आपली मालमत्ता जाळण्यासाठी एका निर्दिष्ट खात्यात पाठवून बाहेर पडण्याचा व्यवहार सुरू करतो. जर ऑपरेटरने व्यवहार पुढील बॅचमध्ये समाविष्ट केला, तर वापरकर्ता ऑनचेन कॉन्ट्रॅक्टला पैसे काढण्याची विनंती सबमिट करू शकतो. या पैसे काढण्याच्या विनंतीमध्ये खालील गोष्टींचा समावेश असेल:

- वापरकर्त्याच्या व्यवहाराचा बर्न खात्यात एका व्यवहार बॅचमध्ये समावेश असल्याचे सिद्ध करणारा मर्कल पुरावा

- व्यवहार डेटा

- बॅच रूट

- जमा केलेला निधी प्राप्त करण्यासाठी L1 पत्ता

रोलअप कॉन्ट्रॅक्ट व्यवहार डेटाचा हॅश करतो, बॅच रूट अस्तित्वात आहे की नाही हे तपासतो, आणि व्यवहार हॅश बॅच रूटचा भाग आहे की नाही हे तपासण्यासाठी मर्कल पुराव्याचा वापर करतो. त्यानंतर, कॉन्ट्रॅक्ट बाहेर पडण्याचा व्यवहार कार्यान्वित करतो आणि L1 वरील वापरकर्त्याच्या निवडलेल्या पत्त्यावर निधी पाठवतो.

## ZK-रोलअप्स आणि EVM सुसंगतता {#zk-rollups-and-evm-compatibility}

ऑप्टिमिस्टिक रोलअप्सच्या विपरीत, ZK-रोलअप्स [Ethereum Virtual Machine (EVM)](/developers/docs/evm/) शी सहज सुसंगत नाहीत. सर्किट्समध्ये सामान्य-उद्देशीय EVM गणना सिद्ध करणे सोप्या गणना सिद्ध करण्यापेक्षा (जसे की पूर्वी वर्णन केलेले टोकन हस्तांतरण) अधिक कठीण आणि संसाधन-केंद्रित आहे.

तथापि, [शून्य-ज्ञान तंत्रज्ञानातील प्रगती](https://hackmd.io/@yezhang/S1_KMMbGt#Why-possible-now) शून्य-ज्ञान पुराव्यांमध्ये EVM गणना गुंडाळण्यात नवीन रस निर्माण करत आहे. हे प्रयत्न एक शून्य-ज्ञान EVM (zkEVM) अंमलबजावणी तयार करण्याच्या दिशेने आहेत जे प्रोग्रामच्या अंमलबजावणीची अचूकता कार्यक्षमतेने सत्यापित करू शकेल. एक zkEVM सर्किट्समध्ये सिद्ध/पडताळणीसाठी विद्यमान EVM ऑपकोड्स पुन्हा तयार करते, ज्यामुळे स्मार्ट कॉन्ट्रॅक्ट्स कार्यान्वित करणे शक्य होते.

EVM प्रमाणे, काही इनपुटवर गणना केल्यानंतर zkEVM स्टेट्स दरम्यान संक्रमण करते. फरक हा आहे की zkEVM प्रोग्रामच्या अंमलबजावणीतील प्रत्येक चरणाची अचूकता सत्यापित करण्यासाठी शून्य-ज्ञान पुरावे देखील तयार करते. वैधता पुरावे VM च्या स्टेटला (मेमरी, स्टॅक, स्टोरेज) स्पर्श करणाऱ्या ऑपरेशन्सची अचूकता आणि गणना स्वतःच (म्हणजे, ऑपरेशनने योग्य ऑपकोड्स कॉल केले आणि ते योग्यरित्या कार्यान्वित केले का?) सत्यापित करू शकतात.

EVM-सुसंगत ZK-रोलअप्सची ओळख विकसकांना शून्य-ज्ञान पुराव्यांच्या स्केलेबिलिटी आणि सुरक्षा हमींचा लाभ घेण्यास मदत करेल अशी अपेक्षा आहे. सर्वात महत्त्वाचे म्हणजे, मूळ Ethereum पायाभूत सुविधांसोबत सुसंगतता म्हणजे विकासक परिचित (आणि लढाई-चाचणी) साधने आणि भाषा वापरून ZK-अनुकूल dapps तयार करू शकतात.

## ZK-रोलअप शुल्क कसे कार्य करते? {#how-do-zk-rollup-fees-work}

ZK-रोलअपवरील व्यवहारांसाठी वापरकर्ते किती पैसे देतात हे Ethereum Mainnet प्रमाणेच गॅस शुल्कावर अवलंबून असते. तथापि, L2 वर गॅस शुल्क वेगळ्या पद्धतीने कार्य करते आणि खालील खर्चांवर प्रभावित होते:

1. **स्टेट राइट**: Ethereum च्या स्टेटवर लिहिण्यासाठी (म्हणजे, Ethereum ब्लॉकचेनवर व्यवहार सबमिट करणे) एक निश्चित खर्च आहे. ZK-रोलअप व्यवहार बॅच करून आणि निश्चित खर्च अनेक वापरकर्त्यांमध्ये विभागून हा खर्च कमी करतात.

2. **डेटा प्रकाशन**: ZK-रोलअप प्रत्येक व्यवहारासाठी स्टेट डेटा Ethereum वर `calldata` म्हणून प्रकाशित करतात. `calldata` चे खर्च सध्या [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) द्वारे नियंत्रित केले जातात, जे `calldata` च्या शून्य-नसलेल्या बाइट्ससाठी 16 गॅस आणि शून्य बाइट्ससाठी 4 गॅसचा खर्च निर्धारित करते. प्रत्येक व्यवहारावर दिला जाणारा खर्च त्यावर अवलंबून असतो की त्यासाठी किती `calldata` ऑनचेन पोस्ट करणे आवश्यक आहे.

3. **L2 ऑपरेटर शुल्क**: हे रोलअप ऑपरेटरला व्यवहार प्रक्रिया करताना झालेल्या संगणकीय खर्चाची भरपाई म्हणून दिले जाणारे रक्कम आहे, जसे Ethereum Mainnet वरील [व्यवहार "प्राधान्य शुल्क (टिप्स)"](/developers/docs/gas/#how-are-gas-fees-calculated) प्रमाणे.

4. **पुरावा निर्मिती आणि पडताळणी**: ZK-रोलअप ऑपरेटर्सना व्यवहार बॅचेससाठी वैधता पुरावे तयार करणे आवश्यक आहे, जे संसाधन-केंद्रित आहे. Mainnet वर शून्य-ज्ञान पुरावे सत्यापित करण्यासाठी देखील गॅस खर्च होतो (~ 500,000 गॅस).

व्यवहार बॅच करण्याव्यतिरिक्त, ZK-रोलअप व्यवहार डेटा संकुचित करून वापरकर्त्यांसाठी शुल्क कमी करतात. तुम्ही Ethereum ZK-रोलअप वापरण्यासाठी किती खर्च येतो याचा [रिअल-टाइम आढावा पाहू शकता](https://l2fees.info/).

## ZK-रोलअप Ethereum कसे मोजतात? {#scaling-ethereum-with-zk-rollups}

### व्यवहार डेटा कॉम्प्रेशन {#transaction-data-compression}

ZK-रोलअप्स Ethereum च्या बेस लेअरवरील थ्रूपूट वाढवतात, कम्प्युटेशन ऑफचेन घेऊन, पण स्केलिंगसाठी खरी चालना व्यवहार डेटा कॉम्प्रेशनमधून येते. Ethereum चा [ब्लॉक आकार](/developers/docs/blocks/#block-size) प्रत्येक ब्लॉकमध्ये किती डेटा असू शकतो आणि त्याद्वारे, प्रति ब्लॉक प्रक्रिया केलेल्या व्यवहारांची संख्या मर्यादित करतो. व्यवहार-संबंधित डेटा संकुचित करून, ZK-रोलअप प्रति ब्लॉक प्रक्रिया केलेल्या व्यवहारांची संख्या लक्षणीयरीत्या वाढवतात.

ZK-रोलअप ऑप्टिमिस्टिक रोलअपपेक्षा व्यवहार डेटा अधिक चांगल्या प्रकारे संकुचित करू शकतात कारण त्यांना प्रत्येक व्यवहाराची वैधता तपासण्यासाठी आवश्यक असलेला सर्व डेटा पोस्ट करावा लागत नाही. त्यांना फक्त रोलअपवरील खाती आणि शिल्लक यांची नवीनतम स्टेट पुन्हा तयार करण्यासाठी आवश्यक असलेला किमान डेटा पोस्ट करावा लागतो.

### रिकर्सिव्ह प्रूफ्स {#recursive-proofs}

शून्य-ज्ञान पुराव्यांचा एक फायदा म्हणजे पुरावे इतर पुराव्यांची पडताळणी करू शकतात. उदाहरणार्थ, एक ZK-SNARK इतर ZK-SNARKs ची पडताळणी करू शकतो. अशा "पुरावा-च्या-पुराव्यांना" रिकर्सिव्ह पुरावे म्हणतात आणि ते ZK-रोलअपवरील थ्रूपूट नाटकीयरित्या वाढवतात.

सध्या, वैधता पुरावे ब्लॉक-दर-ब्लॉक आधारावर तयार केले जातात आणि पडताळणीसाठी L1 कॉन्ट्रॅक्टला सादर केले जातात. तथापि, सिंगल ब्लॉक पुरावे सत्यापित करणे ZK-रोलअप्स साध्य करू शकणाऱ्या थ्रूपूटला मर्यादित करते कारण ऑपरेटर जेव्हा पुरावा सादर करतो तेव्हा फक्त एकच ब्लॉक अंतिम केला जाऊ शकतो.

रिकर्सिव्ह पुरावे, तथापि, एकाच वैधता पुराव्याने अनेक ब्लॉक्स अंतिम करणे शक्य करतात. हे शक्य आहे कारण सिद्ध करणारे सर्किट अनेक ब्लॉक पुरावे रिकर्सिव्हपणे एकत्र करते जोपर्यंत एक अंतिम पुरावा तयार होत नाही. L2 ऑपरेटर हा रिकर्सिव्ह पुरावा सादर करतो, आणि जर कॉन्ट्रॅक्टने तो स्वीकारला, तर सर्व संबंधित ब्लॉक्स त्वरित अंतिम होतील. रिकर्सिव्ह पुराव्यांसह, ठराविक अंतराने Ethereum वर अंतिम केल्या जाऊ शकणाऱ्या ZK-रोलअप व्यवहारांची संख्या वाढते.

### ZK-रोलअप्सचे फायदे आणि तोटे {#zk-rollups-pros-and-cons}

| फायदे                                                                                                                                                                                                                                | बाधक                                                                                                                                                                                                                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| वैधता पुरावे ऑफचेन व्यवहारांची अचूकता सुनिश्चित करतात आणि ऑपरेटर्सना अवैध स्टेट संक्रमण कार्यान्वित करण्यापासून प्रतिबंधित करतात.                                                                                    | वैधता पुरावे मोजण्यासाठी आणि सत्यापित करण्यासाठी लागणारा खर्च मोठा आहे आणि त्यामुळे रोलअप वापरकर्त्यांसाठी शुल्क वाढू शकते.                                                                                     |
| जलद व्यवहार अंतिमत्वाची ऑफर देते कारण L1 वर वैधता पुरावे सत्यापित झाल्यावर स्टेट अपडेट्स मंजूर केले जातात.                                                                                                           | शून्य-ज्ञान तंत्रज्ञानाच्या जटिलतेमुळे EVM-सुसंगत ZK-रोलअप तयार करणे कठीण आहे.                                                                                                                                  |
| सुरक्षेसाठी विश्वासहीन क्रिप्टोग्राफिक यंत्रणांवर अवलंबून असते, [ऑप्टिमिस्टिक रोलअप्स](/developers/docs/scaling/optimistic-rollups/#optimistic-pros-and-cons) प्रमाणे प्रोत्साहनित कलाकारांच्या प्रामाणिकपणावर नाही. | वैधता पुरावे तयार करण्यासाठी विशेष हार्डवेअरची आवश्यकता असते, ज्यामुळे काही पक्षांद्वारे चेनवर केंद्रीकृत नियंत्रण वाढू शकते.                                                                                   |
| ऑफचेन स्टेट पुनर्प्राप्त करण्यासाठी आवश्यक डेटा L1 वर संग्रहित करते, ज्यामुळे सुरक्षा, सेन्सॉरशिप-प्रतिरोध आणि विकेंद्रीकरण सुनिश्चित होते.                                                                          | केंद्रीकृत ऑपरेटर (सिक्वेन्सर) व्यवहारांच्या क्रमावर प्रभाव टाकू शकतात.                                                                                                                      |
| वापरकर्त्यांना अधिक भांडवली कार्यक्षमतेचा फायदा होतो आणि ते L2 मधून विलंब न करता निधी काढू शकतात.                                                                                                                    | हार्डवेअर आवश्यकता सहभागींची संख्या कमी करू शकतात जे चेनला प्रगती करण्यास भाग पाडू शकतात, ज्यामुळे दुर्भावनापूर्ण ऑपरेटर्सकडून रोलअपची स्टेट फ्रीझ होण्याचा आणि वापरकर्त्यांना सेन्सॉर करण्याचा धोका वाढतो.     |
| लाइव्हनेस गृहितकांवर अवलंबून नाही आणि वापरकर्त्यांना त्यांचे निधी संरक्षित करण्यासाठी चेनची वैधता तपासण्याची आवश्यकता नाही.                                                                                          | काही सिद्धता प्रणालींना (उदा., ZK-SNARK) एका विश्वसनीय सेटअपची आवश्यकता असते, जे चुकीच्या पद्धतीने हाताळल्यास, संभाव्यतः ZK-रोलअपच्या सुरक्षा मॉडेलला धोका निर्माण करू शकते. |
| चांगले डेटा कॉम्प्रेशन Ethereum वर `calldata` प्रकाशित करण्याचा खर्च कमी करण्यास आणि वापरकर्त्यांसाठी रोलअप शुल्क कमी करण्यास मदत करू शकते.                                                                          |                                                                                                                                                                                                                                 |

### ZK-रोलअपचे एक दृश्यात्मक स्पष्टीकरण {#zk-video}

Finematics ला ZK-रोलअप समजावून सांगताना पहा:

<YouTube id="7pWxCklcNsU" start="406" />

## zkEVM वर कोण काम करत आहे? {#zkevm-projects}

zkEVMs वर काम करणाऱ्या प्रकल्पांमध्ये हे समाविष्ट आहे:

- **[zkEVM](https://github.com/privacy-scaling-explorations/zkevm-specs)** - _zkEVM हा Ethereum फाउंडेशनद्वारे निधीबद्ध केलेला एक प्रकल्प आहे, जो EVM-सुसंगत ZK-रोलअप आणि Ethereum ब्लॉक्ससाठी वैधता पुरावे तयार करण्याची यंत्रणा विकसित करतो._

- **[Polygon zkEVM](https://polygon.technology/solutions/polygon-zkevm)** - _हा Ethereum mainnet वरील एक विकेंद्रित ZK Rollup आहे जो शून्य-ज्ञान Ethereum Virtual Machine (zkEVM) वर काम करतो, जो शून्य-ज्ञान-पुरावा प्रमाणीकरणासह स्मार्ट कॉन्ट्रॅक्ट्ससह Ethereum व्यवहारांना पारदर्शकपणे कार्यान्वित करतो._

- **[Scroll](https://scroll.io/blog/zkEVM)** - _Scroll ही एक तंत्रज्ञान-चालित कंपनी आहे जी Ethereum साठी एक मूळ zkEVM लेअर 2 सोल्यूशन तयार करण्यावर काम करत आहे._

- **[Taiko](https://taiko.xyz)** - _Taiko एक विकेंद्रित, Ethereum-समकक्ष ZK-रोलअप आहे (एक [Type 1 ZK-EVM](https://vitalik.eth.limo/general/2022/08/04/zkevm.html))._

- **[ZKsync](https://docs.zksync.io/)** - _ZKsync Era हा Matter Labs द्वारे तयार केलेला EVM-सुसंगत ZK Rollup आहे, जो त्याच्या स्वतःच्या zkEVM द्वारे चालतो._

- **[Starknet](https://starkware.co/starknet/)** - _StarkNet हे StarkWare द्वारे तयार केलेले EVM-सुसंगत लेअर 2 स्केलिंग सोल्यूशन आहे._

- **[Morph](https://www.morphl2.io/)** - _Morph हे एक हायब्रिड रोलअप स्केलिंग सोल्यूशन आहे जे लेअर 2 स्टेट आव्हान समस्येचे निराकरण करण्यासाठी zk-proof चा वापर करते._

- **[Linea](https://linea.build)** - _Linea हे Consensys द्वारे तयार केलेले Ethereum-समकक्ष zkEVM लेअर 2 आहे, जे Ethereum इकोसिस्टमशी पूर्णपणे सुसंगत आहे._

## ZK-रोलअप्सवर अधिक वाचन {#further-reading-on-zk-rollups}

- [शून्य-ज्ञान रोलअप्स काय आहेत?](https://coinmarketcap.com/alexandria/glossary/zero-knowledge-rollups)
- [शून्य-ज्ञान रोलअप्स काय आहेत?](https://alchemy.com/blog/zero-knowledge-rollups)
- [इथेरियम रोलअप्ससाठी व्यावहारिक मार्गदर्शक](https://web.archive.org/web/20241108192208/https://research.2077.xyz/the-practical-guide-to-ethereum-rollups)
- [STARKs विरुद्ध SNARKs](https://consensys.net/blog/blockchain-explained/zero-knowledge-proofs-starks-vs-snarks/)
- [zkEVM काय आहे?](https://www.alchemy.com/overviews/zkevm)
- [ZK-EVM प्रकार: Ethereum-समकक्ष, EVM-समकक्ष, प्रकार 1, प्रकार 4, आणि इतर गुप्त बझवर्ड्स](https://taiko.mirror.xyz/j6KgY8zbGTlTnHRFGW6ZLVPuT0IV0_KmgowgStpA0K4)
- [zkEVM चा परिचय](https://hackmd.io/@yezhang/S1_KMMbGt)
- [ZK-EVM L2s काय आहेत?](https://linea.mirror.xyz/qD18IaQ4BROn_Y40EBMTUTdJHYghUtdECscSWyMvm8M)
- [अप्रतिम-zkEVM संसाधने](https://github.com/LuozhuZhang/awesome-zkevm)
- [ZK-SNARKS पडद्याआड](https://vitalik.eth.limo/general/2017/02/01/zk_snarks.html)
- [SNARKs कसे शक्य आहेत?](https://vitalik.eth.limo/general/2021/01/26/snarks.html)
