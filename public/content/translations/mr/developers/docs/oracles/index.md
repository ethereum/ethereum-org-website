---
title: "ओरॅकल्स"
description: "ओरॅकल्स इथेरियम स्मार्ट कॉन्ट्रॅक्ट्सना वास्तविक जगातील डेटामध्ये प्रवेश देतात, ज्यामुळे वापरकर्त्यांसाठी अधिक वापर-प्रकरणे आणि अधिक मूल्य अनलॉक होते."
lang: mr
---

ओरॅकल्स हे असे ऍप्लिकेशन्स आहेत जे डेटा फीड्स तयार करतात जे स्मार्ट कॉन्ट्रॅक्ट्ससाठी ब्लॉकचेनला ऑफचेन डेटा स्रोत उपलब्ध करून देतात. हे आवश्यक आहे कारण इथेरियम-आधारित स्मार्ट कॉन्ट्रॅक्ट्स, डीफॉल्टनुसार, ब्लॉकचेन नेटवर्कच्या बाहेर संग्रहित माहितीमध्ये प्रवेश करू शकत नाहीत.

स्मार्ट कॉन्ट्रॅक्ट्सना ऑफचेन डेटा वापरून कार्यान्वित करण्याची क्षमता देणे विकेंद्रित ऍप्लिकेशन्सची उपयोगिता आणि मूल्य वाढवते. उदाहरणार्थ, ऑनचेन प्रेडिक्शन मार्केट्स निकालांबद्दल माहिती देण्यासाठी ओरॅकल्सवर अवलंबून असतात, ज्याचा वापर ते वापरकर्त्याच्या अंदाजांची पडताळणी करण्यासाठी करतात. समजा ॲलिसने पुढील यू.एस. कोण होईल यावर 20 ETH ची पैज लावली. अध्यक्ष. त्या प्रकरणात, प्रेडिक्शन-मार्केट डॅपला निवडणुकीच्या निकालांची पुष्टी करण्यासाठी आणि ॲलिस पेमेंटसाठी पात्र आहे की नाही हे ठरवण्यासाठी एका ओरॅकलची आवश्यकता आहे.

## पूर्वतयारी {#prerequisites}

हे पान असे गृहीत धरते की वाचक इथेरियमच्या मूलभूत तत्त्वांशी परिचित आहे, ज्यात [नोड्स](/developers/docs/nodes-and-clients/), [सहमती यंत्रणा](/developers/docs/consensus-mechanisms/), आणि [EVM](/developers/docs/evm/) यांचा समावेश आहे. तुम्हाला [स्मार्ट कॉन्ट्रॅक्ट्स](/developers/docs/smart-contracts/) आणि [स्मार्ट कॉन्ट्रॅक्टची रचना](/developers/docs/smart-contracts/anatomy/), विशेषतः [इव्हेंट्स](/glossary/#events) यांची चांगली समज असणे आवश्यक आहे.

## ब्लॉकचेन ओरॅकल म्हणजे काय? {#what-is-a-blockchain-oracle}

ओरॅकल्स हे असे ऍप्लिकेशन्स आहेत जे ब्लॉकचेनवर चालू असलेल्या स्मार्ट कॉन्ट्रॅक्ट्सना बाह्य माहिती (म्हणजे ऑफचेन संग्रहित माहिती) मिळवतात, सत्यापित करतात आणि प्रसारित करतात. ऑफचेन डेटा 'पुल' करण्याव्यतिरिक्त आणि इथेरियमवर प्रसारित करण्याव्यतिरिक्त, ओरॅकल्स ब्लॉकचेनमधून बाह्य प्रणालींमध्ये माहिती 'पुश' देखील करू शकतात, उदा., वापरकर्त्याने इथेरियम व्यवहाराद्वारे शुल्क पाठवल्यावर स्मार्ट लॉक अनलॉक करणे.

ओरॅकलशिवाय, स्मार्ट कॉन्ट्रॅक्ट पूर्णपणे ऑनचेन डेटापुरते मर्यादित राहील.

ओरॅकल्स डेटाच्या स्रोतावर (एक किंवा अनेक स्रोत), विश्वास मॉडेल्सवर (केंद्रीकृत किंवा विकेंद्रित), आणि सिस्टम आर्किटेक्चरवर (इमिडिएट-रीड, पब्लिश-सबस्क्राइब, आणि रिक्वेस्ट-रिस्पॉन्स) आधारित वेगळे असतात. ते ऑनचेन कॉन्ट्रॅक्ट्सद्वारे वापरासाठी बाह्य डेटा पुनर्प्राप्त करतात (इनपुट ओरॅकल्स), ब्लॉकचेनमधून ऑफचेन ऍप्लिकेशन्सना माहिती पाठवतात (आउटपुट ओरॅकल्स), किंवा ऑफचेन संगणकीय कार्ये करतात (संगणकीय ओरॅकल्स) यावर आधारित आपण ओरॅकल्समध्ये फरक करू शकतो.

## स्मार्ट कॉन्ट्रॅक्ट्सना ओरॅकल्सची गरज का आहे? {#why-do-smart-contracts-need-oracles}

बरेच डेव्हलपर्स स्मार्ट कॉन्ट्रॅक्ट्सना ब्लॉकचेनवरील विशिष्ट ॲड्रेसवर चालणारा कोड म्हणून पाहतात. तथापि, [स्मार्ट कॉन्ट्रॅक्ट्सचा अधिक सामान्य दृष्टिकोन](/smart-contracts/) असा आहे की ते स्व-अंमलबजावणी करणारे सॉफ्टवेअर प्रोग्राम आहेत जे एकदा विशिष्ट अटी पूर्ण झाल्यावर पक्षांमधील करारांची अंमलबजावणी करण्यास सक्षम असतात - म्हणूनच 'स्मार्ट कॉन्ट्रॅक्ट्स' ही संज्ञा आहे.

परंतु इथेरियम निर्धारक असल्यामुळे, लोकांमध्ये करारांची अंमलबजावणी करण्यासाठी स्मार्ट कॉन्ट्रॅक्ट्स वापरणे सोपे नाही. [निर्धारक प्रणाली](https://en.wikipedia.org/wiki/Deterministic_algorithm) अशी आहे जी प्रारंभिक स्थिती आणि विशिष्ट इनपुट दिल्यास नेहमी समान परिणाम देते, याचा अर्थ इनपुटमधून आउटपुटची गणना करण्याच्या प्रक्रियेत कोणतीही यादृच्छिकता किंवा भिन्नता नसते.

निर्धारक अंमलबजावणी साध्य करण्यासाठी, ब्लॉकचेन _केवळ_ ब्लॉकचेनवरच संग्रहित डेटा वापरून साध्या बायनरी (खरे/खोटे) प्रश्नांवर सहमतीपर्यंत पोहोचण्यासाठी नोड्सना मर्यादित करतात. अशा प्रश्नांची उदाहरणे:

- “खाते मालकाने (सार्वजनिक की द्वारे ओळखले जाते) या व्यवहारावर जोडलेल्या खाजगी की सह स्वाक्षरी केली होती का?”
- “या खात्यात व्यवहार कव्हर करण्यासाठी पुरेसा निधी आहे का?”
- “या स्मार्ट कॉन्ट्रॅक्टच्या संदर्भात हा व्यवहार वैध आहे का?”, इत्यादी.

जर ब्लॉकचेनला बाह्य स्रोतांकडून (म्हणजे, वास्तविक जगातून) माहिती मिळाली, तर निर्धारकता साध्य करणे अशक्य होईल, ज्यामुळे नोड्सना ब्लॉकचेनच्या स्थितीतील बदलांच्या वैधतेवर सहमत होण्यापासून प्रतिबंधित केले जाईल. उदाहरणार्थ, एक स्मार्ट कॉन्ट्रॅक्ट घ्या जो पारंपारिक किंमत API मधून मिळवलेल्या सध्याच्या ETH-USD विनिमय दरावर आधारित व्यवहार कार्यान्वित करतो. हा आकडा वारंवार बदलण्याची शक्यता आहे (API नापसंत किंवा हॅक होऊ शकते याचा उल्लेख नाही), याचा अर्थ समान कॉन्ट्रॅक्ट कोड कार्यान्वित करणारे नोड्स वेगवेगळ्या निष्कर्षांवर पोहोचतील.

इथेरियमसारख्या सार्वजनिक ब्लॉकचेनसाठी, जिथे जगभरातील हजारो नोड्स व्यवहार प्रक्रिया करत आहेत, निर्धारकता अत्यंत महत्त्वाची आहे. सत्याचा स्रोत म्हणून काम करणारी कोणतीही केंद्रीय संस्था नसल्यामुळे, समान व्यवहार लागू केल्यानंतर समान स्थितीवर पोहोचण्यासाठी नोड्सना यंत्रणेची आवश्यकता आहे. अशी केस जिथे नोड A स्मार्ट कॉन्ट्रॅक्टचा कोड कार्यान्वित करतो आणि परिणाम म्हणून '3' मिळवतो, तर नोड B समान व्यवहार चालवल्यानंतर '7' मिळवतो, यामुळे सहमती तुटेल आणि विकेंद्रित संगणन प्लॅटफॉर्म म्हणून इथेरियमचे मूल्य नष्ट होईल.

हे परिदृश्य बाह्य स्रोतांकडून माहिती खेचण्यासाठी ब्लॉकचेन डिझाइन करण्यामधील समस्या देखील अधोरेखित करते. तथापि, ओरॅकल्स ऑफचेन स्रोतांकडून माहिती घेऊन आणि स्मार्ट कॉन्ट्रॅक्ट्स वापरण्यासाठी ती ब्लॉकचेनवर संग्रहित करून ही समस्या सोडवतात. ऑनचेन संग्रहित माहिती अपरिवर्तनीय आणि सार्वजनिकरित्या उपलब्ध असल्यामुळे, इथेरियम नोड्स सहमती न तोडता स्थितीतील बदल संगणित करण्यासाठी ओरॅकलद्वारे आयात केलेला ऑफचेन डेटा सुरक्षितपणे वापरू शकतात.

हे करण्यासाठी, एक ओरॅकल सामान्यतः ऑनचेन चालणाऱ्या स्मार्ट कॉन्ट्रॅक्ट आणि काही ऑफचेन घटकांपासून बनलेला असतो. ऑनचेन कॉन्ट्रॅक्ट इतर स्मार्ट कॉन्ट्रॅक्ट्सकडून डेटासाठी विनंत्या प्राप्त करतो, ज्या तो ऑफचेन घटकाकडे (ज्याला ओरॅकल नोड म्हणतात) पाठवतो. हा ओरॅकल नोड डेटा स्रोतांना क्वेरी करू शकतो - उदाहरणार्थ, ऍप्लिकेशन प्रोग्रामिंग इंटरफेस (APIs) वापरून - आणि विनंती केलेला डेटा स्मार्ट कॉन्ट्रॅक्टच्या स्टोरेजमध्ये संग्रहित करण्यासाठी व्यवहार पाठवू शकतो.

मूलतः, एक ब्लॉकचेन ओरॅकल ब्लॉकचेन आणि बाह्य पर्यावरण यांच्यातील माहितीतील अंतर भरून काढतो, ज्यामुळे “हायब्रीड स्मार्ट कॉन्ट्रॅक्ट्स” तयार होतात. हायब्रीड स्मार्ट कॉन्ट्रॅक्ट हा एक असा कॉन्ट्रॅक्ट आहे जो ऑनचेन कॉन्ट्रॅक्ट कोड आणि ऑफचेन पायाभूत सुविधांच्या संयोजनावर आधारित कार्य करतो. विकेंद्रित प्रेडिक्शन मार्केट्स हे हायब्रीड स्मार्ट कॉन्ट्रॅक्ट्सचे उत्कृष्ट उदाहरण आहे. इतर उदाहरणांमध्ये पीक विमा स्मार्ट कॉन्ट्रॅक्ट्सचा समावेश असू शकतो जे ओरॅकल्सचा एक संच विशिष्ट हवामान घटना घडल्या आहेत हे ठरवल्यावर पेमेंट करतात.

## ओरॅकल समस्या काय आहे? {#the-oracle-problem}

ओरॅकल्स एक महत्त्वाची समस्या सोडवतात, परंतु काही गुंतागुंत देखील निर्माण करतात, उदा.,:

- आपण हे कसे सत्यापित करू शकतो की इंजेक्ट केलेली माहिती योग्य स्रोतातून काढली गेली आहे किंवा तिच्यात फेरफार झालेली नाही?

- हा डेटा नेहमी उपलब्ध आहे आणि नियमितपणे अपडेट केला जातो याची आपण खात्री कशी करू शकतो?

तथाकथित “ओरॅकल समस्या” स्मार्ट कॉन्ट्रॅक्ट्सना इनपुट पाठवण्यासाठी ब्लॉकचेन ओरॅकल्स वापरण्याशी संबंधित समस्या दर्शवते. स्मार्ट कॉन्ट्रॅक्ट योग्यरित्या कार्यान्वित होण्यासाठी ओरॅकलमधील डेटा अचूक असणे आवश्यक आहे. शिवाय, अचूक माहिती पुरवण्यासाठी ओरॅकल ऑपरेटर्सवर ‘विश्वास’ ठेवणे हे स्मार्ट कॉन्ट्रॅक्ट्सच्या 'विश्वासहीन' पैलूला कमी करते.

वेगवेगळे ओरॅकल्स ओरॅकल समस्येवर वेगवेगळे उपाय देतात, ज्याचा आपण नंतर शोध घेऊ. ओरॅकल्सचे सामान्यतः ते खालील आव्हाने किती चांगल्या प्रकारे हाताळू शकतात यावर मूल्यांकन केले जाते:

1. **अचूकता**: ओरॅकलने अवैध ऑफचेन डेटावर आधारित स्मार्ट कॉन्ट्रॅक्ट्सना स्थितीतील बदल सुरू करण्यास कारणीभूत ठरू नये. एका ओरॅकलने डेटाची _सत्यता_ आणि _अखंडता_ याची हमी दिली पाहिजे. सत्यता म्हणजे डेटा योग्य स्रोताकडून मिळवला गेला आहे, तर अखंडता म्हणजे ऑनचेन पाठवण्यापूर्वी डेटा अखंड राहिला (म्हणजे, बदलला गेला नाही).

2. **उपलब्धता**: ओरॅकलने स्मार्ट कॉन्ट्रॅक्ट्सना कृती कार्यान्वित करण्यापासून आणि स्थितीतील बदल सुरू करण्यापासून विलंब किंवा प्रतिबंध करू नये. याचा अर्थ असा की ओरॅकलमधील डेटा व्यत्ययाशिवाय _विनंतीनुसार उपलब्ध_ असणे आवश्यक आहे.

3. **प्रोत्साहन सुसंगतता**: ओरॅकलने ऑफचेन डेटा प्रदात्यांना स्मार्ट कॉन्ट्रॅक्ट्समध्ये अचूक माहिती सबमिट करण्यासाठी प्रोत्साहन दिले पाहिजे. प्रोत्साहन सुसंगततेमध्ये _श्रेय देण्याची क्षमता_ आणि _उत्तरदायित्व_ यांचा समावेश आहे. श्रेय देण्याची क्षमता बाह्य माहितीचा एक तुकडा त्याच्या प्रदात्याशी जोडण्याची परवानगी देते, तर उत्तरदायित्व डेटा प्रदात्यांना ते देत असलेल्या माहितीशी बांधते, जेणेकरून प्रदान केलेल्या माहितीच्या गुणवत्तेवर आधारित त्यांना पुरस्कृत किंवा दंडित केले जाऊ शकते.

## ब्लॉकचेन ओरॅकल सेवा कशी कार्य करते? {#how-does-a-blockchain-oracle-service-work}

### वापरकर्ते {#users}

वापरकर्ते अशा संस्था आहेत (म्हणजे, स्मार्ट कॉन्ट्रॅक्ट्स) ज्यांना विशिष्ट क्रिया पूर्ण करण्यासाठी ब्लॉकचेनच्या बाहेरील माहितीची आवश्यकता असते. ओरॅकल सेवेचा मूलभूत कार्यप्रवाह वापरकर्त्याने ओरॅकल कॉन्ट्रॅक्टला डेटा विनंती पाठवण्यापासून सुरू होतो. डेटा विनंत्या सहसा खालीलपैकी काही किंवा सर्व प्रश्नांची उत्तरे देतील:

1. विनंती केलेल्या माहितीसाठी ऑफचेन नोड्स कोणत्या स्रोतांचा सल्ला घेऊ शकतात?

2. रिपोर्टर्स डेटा स्रोतांकडून माहितीवर प्रक्रिया कशी करतात आणि उपयुक्त डेटा पॉइंट्स कसे काढतात?

3. डेटा पुनर्प्राप्त करण्यासाठी किती ओरॅकल नोड्स सहभागी होऊ शकतात?

4. ओरॅकल अहवालांमधील विसंगती कशा व्यवस्थापित केल्या पाहिजेत?

5. सबमिशन फिल्टर करण्यासाठी आणि अहवालांना एकाच मूल्यात एकत्रित करण्यासाठी कोणती पद्धत लागू केली पाहिजे?

### ओरॅकल कॉन्ट्रॅक्ट {#oracle-contract}

ओरॅकल कॉन्ट्रॅक्ट हा ओरॅकल सेवेसाठी ऑनचेन घटक आहे. हे इतर कॉन्ट्रॅक्ट्सकडून डेटा विनंत्या ऐकते, ओरॅकल नोड्सना डेटा क्वेरी रिले करते आणि क्लायंट कॉन्ट्रॅक्ट्सना परत आलेला डेटा प्रसारित करते. हा कॉन्ट्रॅक्ट विनंती करणाऱ्या कॉन्ट्रॅक्टला पाठवण्यासाठी एकत्रित मूल्य तयार करण्यासाठी परत आलेल्या डेटा पॉइंट्सवर काही गणना देखील करू शकतो.

ओरॅकल कॉन्ट्रॅक्ट काही फंक्शन्स उघड करतो जे क्लायंट कॉन्ट्रॅक्ट्स डेटा विनंती करताना कॉल करतात. नवीन क्वेरी मिळाल्यावर, स्मार्ट कॉन्ट्रॅक्ट डेटा विनंतीच्या तपशीलांसह एक [लॉग इव्हेंट](/developers/docs/smart-contracts/anatomy/#events-and-logs) उत्सर्जित करेल. हे लॉगला सबस्क्राइब केलेल्या ऑफचेन नोड्सना सूचित करते (सहसा JSON-RPC `eth_subscribe` कमांडसारखे काहीतरी वापरून), जे लॉग इव्हेंटमध्ये परिभाषित केलेला डेटा पुनर्प्राप्त करण्यासाठी पुढे जातात.

खाली पेड्रो कोस्टा द्वारे एक [उदाहरण ओरॅकल कॉन्ट्रॅक्ट](https://medium.com/@pedrodc/implementing-a-blockchain-oracle-on-ethereum-cedc7e26b49e) आहे. ही एक सोपी ओरॅकल सेवा आहे जी इतर स्मार्ट कॉन्ट्रॅक्ट्सच्या विनंतीनुसार ऑफचेन APIs ला क्वेरी करू शकते आणि विनंती केलेली माहिती ब्लॉकचेनवर संग्रहित करू शकते:

```solidity
pragma solidity >=0.4.21 <0.6.0;

contract Oracle {
  Request[] requests; //कॉन्ट्रॅक्टला केलेल्या विनंत्यांची यादी
  uint currentId = 0; //वाढणारी विनंती आयडी
  uint minQuorum = 2; //अंतिम निकाल घोषित करण्यापूर्वी प्राप्त करण्यासाठी किमान प्रतिसादांची संख्या
  uint totalOracleCount = 3; // हार्डकोड केलेली ओरॅकल संख्या

  // एक सामान्य एपीआय विनंती परिभाषित करते
  struct Request {
    uint id;                            //विनंती आयडी
    string urlToQuery;                  //API url
    string attributeToFetch;            //प्रतिसादामध्ये पुनर्प्राप्त करण्यासाठी json ॲट्रिब्यूट (की)
    string agreedValue;                 //की पासून मूल्य
    mapping(uint => string) answers;     //ओरॅकल्सनी दिलेली उत्तरे
    mapping(address => uint) quorum;    //ओरॅकल्स जे उत्तराला क्वेरी करतील (1=ओरॅकलने मत दिलेले नाही, 2=ओरॅकलने मत दिलेले आहे)
  }

  //ब्लॉकचेनच्या बाहेर ओरॅकलला चालना देणारी इव्हेंट
  event NewRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch
  );

  //अंतिम निकालावर एकमत झाल्यावर चालना दिली जाते
  event UpdatedRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch,
    string agreedValue
  );

  function createRequest (
    string memory _urlToQuery,
    string memory _attributeToFetch
  )
  public
  {
    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, ""));
    Request storage r = requests[length-1];

    // हार्डकोड केलेला ओरॅकल्स ॲड्रेस
    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;
    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;
    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;

    //ब्लॉकचेनच्या बाहेर ओरॅकलद्वारे शोधण्यासाठी एक इव्हेंट लॉन्च करा
    emit NewRequest (
      currentId,
      _urlToQuery,
      _attributeToFetch
    );

    //विनंती आयडी वाढवा
    currentId++;
  }

  //ओरॅकलद्वारे त्याचे उत्तर नोंदवण्यासाठी कॉल केले जाते
  function updateRequest (
    uint _id,
    string memory _valueRetrieved
  ) public {

    Request storage currRequest = requests[_id];

    //विश्वसनीय ओरॅकल्सच्या यादीत ओरॅकल आहे की नाही ते तपासा
    //आणि ओरॅकलने अद्याप मत दिले नसल्यास
    if(currRequest.quorum[address(msg.sender)] == 1){

      //या ॲड्रेसने मत दिले आहे असे चिन्हांकित करणे
      currRequest.quorum[msg.sender] = 2;

      //उत्तरांच्या "ॲरे" मधून पुनरावृत्ती करा जोपर्यंत एखादी जागा मोकळी होत नाही आणि पुनर्प्राप्त केलेले मूल्य जतन करा
      uint tmpI = 0;
      bool found = false;
      while(!found) {
        //पहिली रिकामी स्लॉट शोधा
        if(bytes(currRequest.answers[tmpI]).length == 0){
          found = true;
          currRequest.answers[tmpI] = _valueRetrieved;
        }
        tmpI++;
      }

      uint currentQuorum = 0;

      //ओरॅकल यादीतून पुनरावृत्ती करा आणि पुरेसे ओरॅकल्स (किमान कोरम) आहेत की नाही ते तपासा
      //सध्याच्या उत्तरासारखेच मत दिले आहे
      for(uint i = 0; i < totalOracleCount; i++){
        bytes memory a = bytes(currRequest.answers[i]);
        bytes memory b = bytes(_valueRetrieved);

        if(keccak256(a) == keccak256(b)){
          currentQuorum++;
          if(currentQuorum >= minQuorum){
            currRequest.agreedValue = _valueRetrieved;
            emit UpdatedRequest (
              currRequest.id,
              currRequest.urlToQuery,
              currRequest.attributeToFetch,
              currRequest.agreedValue
            );
          }
        }
      }
    }
  }
}
```

### ओरॅकल नोड्स {#oracle-nodes}

ओरॅकल नोड हा ओरॅकल सेवेचा ऑफचेन घटक आहे. हे तृतीय-पक्ष सर्व्हरवर होस्ट केलेल्या APIs सारख्या बाह्य स्रोतांकडून माहिती काढते आणि स्मार्ट कॉन्ट्रॅक्ट्सद्वारे वापरासाठी ऑनचेन ठेवते. ओरॅकल नोड्स ऑनचेन ओरॅकल कॉन्ट्रॅक्टमधील इव्हेंट्स ऐकतात आणि लॉगमध्ये वर्णन केलेले कार्य पूर्ण करण्यासाठी पुढे जातात.

ओरॅकल नोड्ससाठी एक सामान्य कार्य म्हणजे API सेवेला [HTTP GET](https://www.w3schools.com/tags/ref_httpmethods.asp) विनंती पाठवणे, संबंधित डेटा काढण्यासाठी प्रतिसादाचे विश्लेषण करणे, ब्लॉकचेन-वाचनीय आउटपुटमध्ये स्वरूपन करणे आणि ओरॅकल कॉन्ट्रॅक्टला व्यवहारात समाविष्ट करून ऑनचेन पाठवणे. ओरॅकल नोडला “सत्यता पुराव्यांचा” वापर करून सबमिट केलेल्या माहितीच्या वैधतेची आणि अखंडतेची पुष्टी करणे देखील आवश्यक असू शकते, ज्याचा आपण नंतर शोध घेऊ.

संगणकीय ओरॅकल्स गॅस खर्च आणि ब्लॉक आकाराच्या मर्यादा लक्षात घेता, ऑनचेन कार्यान्वित करणे अव्यवहार्य असलेल्या संगणकीय कार्यांसाठी ऑफचेन नोड्सवर देखील अवलंबून असतात. उदाहरणार्थ, ओरॅकल नोडला सत्यापित करता येण्याजोगा यादृच्छिक आकडा तयार करण्याचे काम दिले जाऊ शकते (उदा., ब्लॉकचेन-आधारित गेम्ससाठी).

## ओरॅकल डिझाइन पॅटर्न्स {#oracle-design-patterns}

ओरॅकल्स विविध प्रकारांमध्ये येतात, ज्यात _इमिडिएट-रीड_, _पब्लिश-सबस्क्राइब_, आणि _रिक्वेस्ट-रिस्पॉन्स_ यांचा समावेश आहे, ज्यात नंतरचे दोन इथेरियम स्मार्ट कॉन्ट्रॅक्ट्समध्ये सर्वाधिक लोकप्रिय आहेत. येथे आपण पब्लिश-सबस्क्राइब आणि रिक्वेस्ट-रिस्पॉन्स मॉडेल्सचे थोडक्यात वर्णन करतो.

### पब्लिश-सबस्क्राइब ओरॅकल्स {#publish-subscribe-oracles}

या प्रकारचा ओरॅकल एक “डेटा फीड” उघड करतो जो इतर कॉन्ट्रॅक्ट्स माहितीसाठी नियमितपणे वाचू शकतात. या प्रकरणातील डेटा वारंवार बदलण्याची अपेक्षा आहे, म्हणून क्लायंट कॉन्ट्रॅक्ट्सनी ओरॅकलच्या स्टोरेजमधील डेटामधील अपडेट्ससाठी ऐकले पाहिजे. एक उदाहरण म्हणजे एक ओरॅकल जो वापरकर्त्यांना नवीनतम ETH-USD किंमत माहिती प्रदान करतो.

### रिक्वेस्ट-रिस्पॉन्स ओरॅकल्स {#request-response-oracles}

एक रिक्वेस्ट-रिस्पॉन्स सेटअप क्लायंट कॉन्ट्रॅक्टला पब्लिश-सबस्क्राइब ओरॅकलद्वारे प्रदान केलेल्या व्यतिरिक्त अनियंत्रित डेटाची विनंती करण्याची परवानगी देतो. रिक्वेस्ट-रिस्पॉन्स ओरॅकल्स आदर्श आहेत जेव्हा डेटासेट स्मार्ट कॉन्ट्रॅक्टच्या स्टोरेजमध्ये संग्रहित करण्यासाठी खूप मोठा असतो, आणि/किंवा वापरकर्त्यांना कोणत्याही वेळी डेटाचा फक्त एक छोटासा भाग आवश्यक असेल.

पब्लिश-सबस्क्राइब मॉडेल्सपेक्षा अधिक जटिल असले तरी, रिक्वेस्ट-रिस्पॉन्स ओरॅकल्स मूलतः तेच आहेत ज्याचे आपण मागील विभागात वर्णन केले आहे. ओरॅकलमध्ये एक ऑनचेन घटक असेल जो डेटा विनंती प्राप्त करतो आणि प्रक्रियेसाठी ऑफचेन नोडला पाठवतो.

डेटा क्वेरी सुरू करणाऱ्या वापरकर्त्यांनी ऑफचेन स्रोताकडून माहिती पुनर्प्राप्त करण्याची किंमत भरली पाहिजे. विनंतीमध्ये निर्दिष्ट केलेल्या कॉलबॅक फंक्शनद्वारे प्रतिसाद परत करण्यासाठी ओरॅकल कॉन्ट्रॅक्टद्वारे झालेल्या गॅस खर्चाची भरपाई करण्यासाठी क्लायंट कॉन्ट्रॅक्टने निधी देखील प्रदान करणे आवश्यक आहे.

## केंद्रीकृत विरुद्ध विकेंद्रित ओरॅकल्स {#types-of-oracles}

### केंद्रीकृत ओरॅकल्स {#centralized-oracles}

एक केंद्रीकृत ओरॅकल एकाच संस्थेद्वारे नियंत्रित केला जातो जो ऑफचेन माहिती एकत्रित करण्यासाठी आणि विनंतीनुसार ओरॅकल कॉन्ट्रॅक्टचा डेटा अपडेट करण्यासाठी जबाबदार असतो. केंद्रीकृत ओरॅकल्स कार्यक्षम आहेत कारण ते सत्याच्या एकाच स्रोतावर अवलंबून असतात. जेव्हा मालकीचे डेटासेट थेट मालकाद्वारे व्यापकपणे स्वीकारलेल्या स्वाक्षरीसह प्रकाशित केले जातात तेव्हा ते अधिक चांगले कार्य करू शकतात. तथापि, त्याचे काही तोटे देखील आहेत:

#### कमी अचूकतेची हमी {#low-correctness-guarantees}

केंद्रीकृत ओरॅकल्ससह, प्रदान केलेली माहिती योग्य आहे की नाही याची पुष्टी करण्याचा कोणताही मार्ग नाही. अगदी "प्रतिष्ठित" प्रदाते देखील चुकीचे वागू शकतात किंवा हॅक होऊ शकतात. जर ओरॅकल भ्रष्ट झाला, तर स्मार्ट कॉन्ट्रॅक्ट्स चुकीच्या डेटाच्या आधारावर कार्यान्वित होतील.

#### खराब उपलब्धता {#poor-availability}

केंद्रीकृत ओरॅकल्स इतर स्मार्ट कॉन्ट्रॅक्ट्सना ऑफचेन डेटा नेहमी उपलब्ध करून देतील याची हमी नाही. जर प्रदात्याने सेवा बंद करण्याचा निर्णय घेतला किंवा हॅकरने ओरॅकलच्या ऑफचेन घटकावर नियंत्रण मिळवले, तर तुमच्या स्मार्ट कॉन्ट्रॅक्टला डिनायल ऑफ सर्व्हिस (DoS) हल्ल्याचा धोका आहे.

#### खराब प्रोत्साहन सुसंगतता {#poor-incentive-compatibility}

केंद्रीकृत ओरॅकल्समध्ये अनेकदा डेटा प्रदात्याला अचूक/अपरिवर्तित माहिती पाठवण्यासाठी खराब डिझाइन केलेले किंवा अस्तित्वात नसलेले प्रोत्साहन असते. अचूकतेसाठी ओरॅकलला पैसे देणे प्रामाणिकपणाची हमी देत नाही. स्मार्ट कॉन्ट्रॅक्ट्सद्वारे नियंत्रित मूल्याच्या प्रमाणात ही समस्या अधिक मोठी होते.

### विकेंद्रित ओरॅकल्स {#decentralized-oracles}

विकेंद्रित ओरॅकल्स केंद्रीकृत ओरॅकल्सच्या मर्यादांवर मात करण्यासाठी डिझाइन केलेले आहेत, ज्यामुळे अपयशाचे एकच बिंदू दूर होतात. विकेंद्रित ओरॅकल सेवेमध्ये पीअर-टू-पीअर नेटवर्कमधील अनेक सहभागींचा समावेश असतो जे स्मार्ट कॉन्ट्रॅक्टला पाठवण्यापूर्वी ऑफचेन डेटावर एकमत तयार करतात.

एक विकेंद्रित ओरॅकल (आदर्शपणे) परवानगीशिवाय, विश्वासहीन आणि केंद्रीय पक्षाच्या प्रशासनापासून मुक्त असावा; प्रत्यक्षात, ओरॅकल्समधील विकेंद्रीकरण एका स्पेक्ट्रमवर आहे. अर्ध-विकेंद्रित ओरॅकल नेटवर्क आहेत जिथे कोणीही सहभागी होऊ शकतो, परंतु एक “मालक” असतो जो ऐतिहासिक कामगिरीच्या आधारावर नोड्सना मंजूर करतो आणि काढून टाकतो. पूर्णपणे विकेंद्रित ओरॅकल नेटवर्क देखील अस्तित्वात आहेत: हे सहसा स्वतंत्र ब्लॉकचेन म्हणून चालतात आणि नोड्सचे समन्वय साधण्यासाठी आणि गैरवर्तनासाठी शिक्षा देण्यासाठी परिभाषित सहमती यंत्रणा असतात.

विकेंद्रित ओरॅकल्स वापरण्याचे खालील फायदे आहेत:

### उच्च अचूकतेची हमी {#high-correctness-guarantees}

विकेंद्रित ओरॅकल्स वेगवेगळ्या दृष्टिकोनांचा वापर करून डेटाची अचूकता प्राप्त करण्याचा प्रयत्न करतात. यामध्ये परत केलेल्या माहितीची सत्यता आणि अखंडता सिद्ध करणारे पुरावे वापरणे आणि ऑफचेन डेटाच्या वैधतेवर एकत्रितपणे सहमत होण्यासाठी अनेक संस्थांची आवश्यकता असते.

#### सत्यतेचे पुरावे {#authenticity-proofs}

सत्यतेचे पुरावे हे क्रिप्टोग्राफिक यंत्रणा आहेत जे बाह्य स्रोतांकडून पुनर्प्राप्त केलेल्या माहितीची स्वतंत्र पडताळणी करण्यास सक्षम करतात. हे पुरावे माहितीच्या स्रोताची पडताळणी करू शकतात आणि पुनर्प्राप्तीनंतर डेटामधील संभाव्य बदलांचा शोध घेऊ शकतात.

सत्यतेच्या पुराव्यांची उदाहरणे:

**ट्रान्सपोर्ट लेयर सिक्युरिटी (TLS) पुरावे**: ओरॅकल नोड्स अनेकदा ट्रान्सपोर्ट लेयर सिक्युरिटी (TLS) प्रोटोकॉलवर आधारित सुरक्षित HTTP कनेक्शन वापरून बाह्य स्रोतांकडून डेटा पुनर्प्राप्त करतात. काही विकेंद्रित ओरॅकल्स TLS सत्रांची पडताळणी करण्यासाठी सत्यता पुराव्यांचा वापर करतात (म्हणजे, नोड आणि विशिष्ट सर्व्हर दरम्यान माहितीच्या देवाणघेवाणीची पुष्टी करणे) आणि सत्रातील सामग्री बदललेली नाही याची पुष्टी करतात.

**ट्रस्टेड एक्झिक्यूशन एन्व्हायर्नमेंट (TEE) अटेस्टेशन्स**: एक [ट्रस्टेड एक्झिक्यूशन एन्व्हायर्नमेंट](https://en.wikipedia.org/wiki/Trusted_execution_environment) (TEE) हे एक सँडबॉक्स केलेले संगणकीय वातावरण आहे जे त्याच्या होस्ट सिस्टमच्या कार्यान्वयन प्रक्रियेपासून वेगळे आहे. TEEs हे सुनिश्चित करतात की संगणन वातावरणात संग्रहित/वापरलेला कोणताही ऍप्लिकेशन कोड किंवा डेटा अखंडता, गोपनीयता आणि अपरिवर्तनीयता टिकवून ठेवतो. वापरकर्ते ट्रस्टेड एक्झिक्यूशन एन्व्हायर्नमेंटमध्ये ऍप्लिकेशन इन्स्टन्स चालू आहे हे सिद्ध करण्यासाठी एक अटेस्टेशन देखील तयार करू शकतात.

विकेंद्रित ओरॅकल्सच्या विशिष्ट वर्गांना ओरॅकल नोड ऑपरेटर्सना TEE अटेस्टेशन्स प्रदान करणे आवश्यक असते. हे वापरकर्त्याला पुष्टी देते की नोड ऑपरेटर ट्रस्टेड एक्झिक्यूशन एन्व्हायर्नमेंटमध्ये ओरॅकल क्लायंटचा इन्स्टन्स चालवत आहे. TEEs बाह्य प्रक्रियांच्या ऍप्लिकेशनच्या कोड आणि डेटामध्ये बदल करण्यापासून किंवा वाचण्यापासून प्रतिबंध करतात, त्यामुळे, ते अटेस्टेशन्स सिद्ध करतात की ओरॅकल नोडने माहिती अखंड आणि गोपनीय ठेवली आहे.

#### माहितीची सहमती-आधारित पडताळणी {#consensus-based-validation-of-information}

केंद्रीकृत ओरॅकल्स स्मार्ट कॉन्ट्रॅक्ट्सना डेटा प्रदान करताना सत्याच्या एकाच स्रोतावर अवलंबून असतात, ज्यामुळे चुकीची माहिती प्रकाशित होण्याची शक्यता निर्माण होते. विकेंद्रित ओरॅकल्स ऑफचेन माहितीची क्वेरी करण्यासाठी अनेक ओरॅकल नोड्सवर अवलंबून राहून ही समस्या सोडवतात. अनेक स्रोतांकडून डेटाची तुलना करून, विकेंद्रित ओरॅकल्स ऑनचेन कॉन्ट्रॅक्ट्सना अवैध माहिती पाठवण्याचा धोका कमी करतात.

तथापि, विकेंद्रित ओरॅकल्सना अनेक ऑफचेन स्रोतांकडून पुनर्प्राप्त केलेल्या माहितीमधील विसंगती हाताळावी लागते. माहितीमधील फरक कमी करण्यासाठी आणि ओरॅकल कॉन्ट्रॅक्टला पाठवलेला डेटा ओरॅकल नोड्सच्या सामूहिक मताचे प्रतिबिंब आहे हे सुनिश्चित करण्यासाठी, विकेंद्रित ओरॅकल्स खालील यंत्रणा वापरतात:

##### डेटाच्या अचूकतेवर मतदान/स्टेकिंग करणे

काही विकेंद्रित ओरॅकल नेटवर्क्स सहभागींना डेटा क्वेरींच्या उत्तरांच्या अचूकतेवर मतदान किंवा स्टेक करणे आवश्यक करतात (उदा., "2020 ची यूएस निवडणूक कोणी जिंकली?"). नेटवर्कच्या मूळ टोकनचा वापर करून. एकत्रीकरण प्रोटोकॉल नंतर मते आणि स्टेक्स एकत्रित करतो आणि बहुमताने समर्थित उत्तर वैध म्हणून घेतो.

ज्या नोड्सची उत्तरे बहुमताच्या उत्तरापेक्षा वेगळी असतात त्यांना त्यांचे टोकन अधिक अचूक मूल्ये प्रदान करणाऱ्या इतरांना वितरित करून दंडित केले जाते. डेटा प्रदान करण्यापूर्वी नोड्सना बॉण्ड प्रदान करण्यास भाग पाडणे प्रामाणिक प्रतिसादांना प्रोत्साहन देते कारण ते तर्कसंगत आर्थिक अभिनेते मानले जातात जे परतावा जास्तीत जास्त करण्याच्या हेतूने असतात.

स्टेकिंग/मतदान विकेंद्रित ओरॅकल्सना [सिबिल हल्ल्यांपासून](/glossary/#sybil-attack) देखील संरक्षण देते जिथे दुर्भावनापूर्ण अभिनेते सहमती प्रणालीला खेळण्यासाठी अनेक ओळखी तयार करतात. तथापि, स्टेकिंग “फ्रीलोडिंग” (ओरॅकल नोड्स इतरांकडून माहिती कॉपी करणे) आणि “आळशी पडताळणी” (ओरॅकल नोड्स स्वतः माहितीची पडताळणी न करता बहुमताचे अनुसरण करणे) प्रतिबंधित करू शकत नाही.

##### शेलिंग पॉइंट यंत्रणा

[शेलिंग पॉइंट](https://en.wikipedia.org/wiki/Focal_point_\(game_theory\)) ही एक गेम-थिअरी संकल्पना आहे जी गृहीत धरते की अनेक संस्था कोणत्याही संवादाच्या अनुपस्थितीत समस्येवर नेहमीच एका सामान्य समाधानाकडे वळतील. शेलिंग-पॉइंट यंत्रणा अनेकदा विकेंद्रित ओरॅकल नेटवर्क्समध्ये वापरल्या जातात जेणेकरून नोड्सना डेटा विनंत्यांच्या उत्तरांवर सहमती साधता येईल.

यासाठी एक प्रारंभिक कल्पना [शेलिंगकॉइन](https://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/) होती, जो एक प्रस्तावित डेटा फीड आहे जिथे सहभागी "स्केलर" प्रश्नांची उत्तरे (ज्या प्रश्नांची उत्तरे परिमाणाने वर्णन केली जातात, उदा., "ETH ची किंमत काय आहे?") एका ठेवीसह सबमिट करतात. 25 व्या आणि 75 व्या [पर्सेंटाइल](https://en.wikipedia.org/wiki/Percentile) दरम्यान मूल्ये प्रदान करणाऱ्या वापरकर्त्यांना पुरस्कृत केले जाते, तर ज्यांची मूल्ये मध्यक मूल्यापासून मोठ्या प्रमाणात विचलित होतात त्यांना दंडित केले जाते.

जरी शेलिंगकॉइन आज अस्तित्वात नसले तरी, अनेक विकेंद्रित ओरॅकल्स — विशेषतः [मेकर प्रोटोकॉलचे ओरॅकल्स](https://docs.makerdao.com/smart-contract-modules/oracle-module) — ओरॅकल डेटाची अचूकता सुधारण्यासाठी शेलिंग-पॉइंट यंत्रणेचा वापर करतात. प्रत्येक मेकर ओरॅकलमध्ये नोड्सच्या (“रिलेअर्स” आणि “फीड्स”) ऑफचेन P2P नेटवर्कचा समावेश असतो जे संपार्श्विक मालमत्तेसाठी बाजारातील किमती सबमिट करतात आणि एक ऑनचेन “मीडियनाइझर” कॉन्ट्रॅक्ट जो सर्व प्रदान केलेल्या मूल्यांचा मध्यक मोजतो. एकदा निर्दिष्ट विलंब कालावधी संपला की, हे मध्यक मूल्य संबंधित मालमत्तेसाठी नवीन संदर्भ किंमत बनते.

शेलिंग पॉइंट यंत्रणा वापरणाऱ्या ओरॅकल्सच्या इतर उदाहरणांमध्ये [चेनलिंक ऑफचेन रिपोर्टिंग](https://docs.chain.link/architecture-overview/off-chain-reporting) आणि [विटनेट](https://witnet.io/) यांचा समावेश आहे. दोन्ही प्रणालींमध्ये, पीअर-टू-पीअर नेटवर्कमधील ओरॅकल नोड्सच्या प्रतिसादांना एकाच एकत्रित मूल्यात, जसे की मध्य किंवा मध्यक, एकत्रित केले जाते. नोड्सना त्यांचे प्रतिसाद एकत्रित मूल्याशी किती प्रमाणात जुळतात किंवा त्यापासून विचलित होतात यानुसार पुरस्कृत किंवा दंडित केले जाते.

शेलिंग पॉइंट यंत्रणा आकर्षक आहेत कारण त्या ऑनचेन फूटप्रिंट कमी करतात (फक्त एक व्यवहार पाठवण्याची आवश्यकता आहे) आणि विकेंद्रीकरणाची हमी देतात. नंतरचे शक्य आहे कारण नोड्सनी सबमिट केलेल्या प्रतिसादांच्या यादीवर स्वाक्षरी करणे आवश्यक आहे, त्याआधी ते अल्गोरिदममध्ये दिले जाते जे मध्य/मध्यक मूल्य तयार करते.

### उपलब्धता {#availability}

विकेंद्रित ओरॅकल सेवा स्मार्ट कॉन्ट्रॅक्ट्सना ऑफचेन डेटाची उच्च उपलब्धता सुनिश्चित करतात. हे ऑफचेन माहितीच्या स्रोताचे आणि माहिती ऑनचेन हस्तांतरित करण्यासाठी जबाबदार असलेल्या नोड्सचे विकेंद्रीकरण करून साध्य केले जाते.

हे दोष-सहिष्णुता सुनिश्चित करते कारण ओरॅकल कॉन्ट्रॅक्ट इतर कॉन्ट्रॅक्ट्सकडून क्वेरी कार्यान्वित करण्यासाठी अनेक नोड्सवर (जे अनेक डेटा स्रोतांवर देखील अवलंबून असतात) अवलंबून राहू शकतो. स्रोतावर आणि नोड-ऑपरेटर स्तरावर विकेंद्रीकरण महत्त्वपूर्ण आहे—एकाच स्रोतावरून पुनर्प्राप्त केलेली माहिती देणारे ओरॅकल नोड्सचे नेटवर्क केंद्रीकृत ओरॅकलसारख्याच समस्येत सापडेल.

स्टेक-आधारित ओरॅकल्ससाठी नोड ऑपरेटर्सना स्लॅश करणे देखील शक्य आहे जे डेटा विनंत्यांना त्वरीत प्रतिसाद देण्यात अयशस्वी ठरतात. हे ओरॅकल नोड्सना दोष-सहिष्णु पायाभूत सुविधांमध्ये गुंतवणूक करण्यास आणि वेळेवर डेटा प्रदान करण्यास लक्षणीयरीत्या प्रोत्साहन देते.

### चांगली प्रोत्साहन सुसंगतता {#good-incentive-compatibility}

विकेंद्रित ओरॅकल्स ओरॅकल नोड्समधील [बायझंटाइन](https://en.wikipedia.org/wiki/Byzantine_fault) वर्तन रोखण्यासाठी विविध प्रोत्साहन डिझाइन लागू करतात. विशेषतः, ते _श्रेय देण्याची क्षमता_ आणि _उत्तरदायित्व_ साध्य करतात:

1. विकेंद्रित ओरॅकल नोड्सना डेटा विनंत्यांच्या प्रतिसादात ते प्रदान करत असलेल्या डेटावर स्वाक्षरी करणे आवश्यक असते. ही माहिती ओरॅकल नोड्सच्या ऐतिहासिक कामगिरीचे मूल्यांकन करण्यास मदत करते, जेणेकरून वापरकर्ते डेटा विनंत्या करताना अविश्वसनीय ओरॅकल नोड्स फिल्टर करू शकतात. एक उदाहरण विटनेटची [ॲल्गोरिथमिक रिप्युटेशन सिस्टीम](https://docs.witnet.io/intro/about/architecture#algorithmic-reputation-system) आहे.

2. विकेंद्रित ओरॅकल्स—जसे आधी स्पष्ट केले आहे—नोड्सना ते सबमिट करत असलेल्या डेटाच्या सत्यावरील त्यांच्या आत्मविश्वासावर स्टेक ठेवण्याची आवश्यकता असू शकते. जर दावा खरा ठरला, तर हा स्टेक प्रामाणिक सेवेसाठी पुरस्कारांसह परत केला जाऊ शकतो. परंतु माहिती चुकीची असल्यास ते स्लॅश देखील केले जाऊ शकते, ज्यामुळे काही प्रमाणात उत्तरदायित्व मिळते.

## स्मार्ट कॉन्ट्रॅक्ट्समध्ये ओरॅकल्सचे ऍप्लिकेशन्स {#applications-of-oracles-in-smart-contracts}

इथेरियममध्ये ओरॅकल्ससाठी खालील सामान्य वापर-प्रकरणे आहेत:

### आर्थिक डेटा पुनर्प्राप्त करणे {#retrieving-financial-data}

[विकेंद्रित वित्त](/defi/) (DeFi) ऍप्लिकेशन्स पीअर-टू-पीअर कर्ज देणे, घेणे आणि मालमत्तेचा व्यापार करण्याची परवानगी देतात. यासाठी अनेकदा विविध आर्थिक माहिती मिळवणे आवश्यक असते, ज्यात विनिमय दर डेटा (क्रिप्टोकरन्सीचे फियाट मूल्य मोजण्यासाठी किंवा टोकन किमतींची तुलना करण्यासाठी) आणि भांडवली बाजार डेटा (सोनं किंवा यूएस डॉलरसारख्या टोकनाइज्ड मालमत्तेचे मूल्य मोजण्यासाठी) यांचा समावेश आहे.

एक DeFi कर्ज प्रोटोकॉल, उदाहरणार्थ, संपार्श्विक म्हणून जमा केलेल्या मालमत्तेच्या (उदा., ETH) सध्याच्या बाजारातील किमतींची क्वेरी करणे आवश्यक आहे. हे कॉन्ट्रॅक्टला संपार्श्विक मालमत्तेचे मूल्य निर्धारित करण्यास आणि प्रणालीतून किती कर्ज घेऊ शकते हे ठरविण्यास अनुमती देते.

DeFi मधील लोकप्रिय “प्राइस ओरॅकल्स” (जसे त्यांना अनेकदा म्हटले जाते) मध्ये चेनलिंक प्राइस फीड्स, कंपाऊंड प्रोटोकॉलचे [ओपन प्राइस फीड](https://compound.finance/docs/prices), युनिस्वॅपचे [टाइम-वेटेड ॲव्हरेज प्राइसेस (TWAPs)](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles), आणि [मेकर ओरॅकल्स](https://docs.makerdao.com/smart-contract-modules/oracle-module) यांचा समावेश आहे.

बिल्डर्सनी त्यांच्या प्रोजेक्टमध्ये या प्राइस ओरॅकल्सना समाकलित करण्यापूर्वी त्यांच्यासोबत येणाऱ्या caveats (सावधगिरी) समजून घ्याव्यात. हा [लेख](https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles) उल्लेख केलेल्या कोणत्याही प्राइस ओरॅकल्सचा वापर करण्याची योजना आखताना काय विचार करावा याचे तपशीलवार विश्लेषण प्रदान करतो.

खाली एक उदाहरण आहे की तुम्ही तुमच्या स्मार्ट कॉन्ट्रॅक्टमध्ये चेनलिंक प्राइस फीड वापरून नवीनतम ETH किंमत कशी पुनर्प्राप्त करू शकता:

```solidity
pragma solidity ^0.6.7;

import "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;

    /**
     * नेटवर्क: Kovan
     * ॲग्रीगेटर: ETH/USD
     * ॲड्रेस: 0x9326BFA02ADD2366b30bacB125260Af641031331
     */
    constructor() public {
        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
    }

    /**
     * नवीनतम किंमत परत करते
     */
    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```

### पडताळणीयोग्य यादृच्छिकता निर्माण करणे {#generating-verifiable-randomness}

काही ब्लॉकचेन ऍप्लिकेशन्स, जसे की ब्लॉकचेन-आधारित गेम्स किंवा लॉटरी योजना, प्रभावीपणे कार्य करण्यासाठी उच्च पातळीची अप्रत्याशितता आणि यादृच्छिकता आवश्यक असते. तथापि, ब्लॉकचेनची निर्धारक अंमलबजावणी यादृच्छिकता काढून टाकते.

मूळ दृष्टिकोन `blockhash` सारख्या स्यूडोरँडम क्रिप्टोग्राफिक फंक्शन्सचा वापर करणे होता, परंतु हे [मायनर्सद्वारे हाताळले जाऊ शकते](https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So%20while%20the%20miners%20can,to%20one%20of%20the%20players.) प्रूफ-ऑफ-वर्क अल्गोरिदम सोडवणे. तसेच, इथेरियमचे [प्रूफ-ऑफ-स्टेकवर स्विच करणे](/roadmap/merge/) म्हणजे डेव्हलपर्स आता ऑनचेन यादृच्छिकतेसाठी `blockhash` वर अवलंबून राहू शकत नाहीत. बीकन चेनची [RANDAO यंत्रणा](https://eth2book.info/altair/part2/building_blocks/randomness) त्याऐवजी यादृच्छिकतेचा पर्यायी स्रोत प्रदान करते.

ऑफचेन यादृच्छिक मूल्य तयार करणे आणि ते ऑनचेन पाठवणे शक्य आहे, परंतु असे केल्याने वापरकर्त्यांवर उच्च विश्वासाची आवश्यकता लादली जाते. त्यांना विश्वास ठेवावा लागतो की मूल्य खरोखरच अप्रत्याशित यंत्रणेद्वारे तयार केले गेले आहे आणि ते संक्रमणामध्ये बदलले नाही.

ऑफचेन गणनेसाठी डिझाइन केलेले ओरॅकल्स ही समस्या सोडवतात, ते ऑफचेन सुरक्षितपणे यादृच्छिक परिणाम तयार करतात जे ते प्रक्रियेच्या अप्रत्याशिततेची पुष्टी करणाऱ्या क्रिप्टोग्राफिक पुराव्यांसह ऑनचेन प्रसारित करतात. एक उदाहरण म्हणजे [चेनलिंक VRF](https://docs.chain.link/docs/chainlink-vrf/) (व्हेरिफायेबल रँडम फंक्शन), जो एक सिद्धपणे निष्पक्ष आणि छेडछाड-प्रतिरोधक यादृच्छिक संख्या जनरेटर (RNG) आहे जो अप्रत्याशित परिणामांवर अवलंबून असलेल्या ऍप्लिकेशन्ससाठी विश्वसनीय स्मार्ट कॉन्ट्रॅक्ट्स तयार करण्यासाठी उपयुक्त आहे.

### घटनांसाठी परिणाम मिळवणे {#getting-outcomes-for-events}

ओरॅकल्ससह, वास्तविक-जगातील घटनांना प्रतिसाद देणारे स्मार्ट कॉन्ट्रॅक्ट्स तयार करणे सोपे आहे. ओरॅकल सेवा कॉन्ट्रॅक्ट्सना ऑफचेन घटकांद्वारे बाह्य APIs शी कनेक्ट करण्याची आणि त्या डेटा स्रोतांमधून माहिती वापरण्याची परवानगी देऊन हे शक्य करतात. उदाहरणार्थ, पूर्वी उल्लेख केलेला प्रेडिक्शन डॅप एका ओरॅकलला एका विश्वसनीय ऑफचेन स्रोताकडून (उदा., असोसिएटेड प्रेस) निवडणुकीचे निकाल परत करण्याची विनंती करू शकतो.

वास्तविक-जगातील परिणामांवर आधारित डेटा पुनर्प्राप्त करण्यासाठी ओरॅकल्सचा वापर इतर नवीन वापर-प्रकरणांना सक्षम करतो; उदाहरणार्थ, एका विकेंद्रित विमा उत्पादनाला प्रभावीपणे कार्य करण्यासाठी हवामान, आपत्ती इत्यादींबद्दल अचूक माहितीची आवश्यकता असते.

### स्मार्ट कॉन्ट्रॅक्ट्स स्वयंचलित करणे {#automating-smart-contracts}

स्मार्ट कॉन्ट्रॅक्ट्स आपोआप चालत नाहीत; त्याऐवजी, बाह्यतः मालकीचे खाते (EOA), किंवा दुसरे कॉन्ट्रॅक्ट खाते, कॉन्ट्रॅक्टचा कोड कार्यान्वित करण्यासाठी योग्य फंक्शन्स चालवणे आवश्यक आहे. बहुतेक प्रकरणांमध्ये, कॉन्ट्रॅक्टची बरीचशी फंक्शन्स सार्वजनिक असतात आणि EOAs आणि इतर कॉन्ट्रॅक्ट्सद्वारे बोलावली जाऊ शकतात.

परंतु कॉन्ट्रॅक्टमध्ये _खाजगी फंक्शन्स_ देखील आहेत जी इतरांसाठी प्रवेशयोग्य नाहीत;, परंतु जी डॅपच्या एकूण कार्यक्षमतेसाठी महत्त्वपूर्ण आहेत. उदाहरणांमध्ये `mintERC721Token()` फंक्शन जे नियमितपणे वापरकर्त्यांसाठी नवीन NFTs मिंट करते, प्रेडिक्शन मार्केटमध्ये पेमेंट देण्यासाठी एक फंक्शन, किंवा DEX मध्ये स्टेक केलेले टोकन्स अनलॉक करण्यासाठी एक फंक्शन यांचा समावेश आहे.

ऍप्लिकेशन सुरळीतपणे चालू ठेवण्यासाठी डेव्हलपर्सना अशा फंक्शन्सना ठराविक अंतराने चालवणे आवश्यक असेल. तथापि, यामुळे डेव्हलपर्ससाठी क्षुल्लक कामांमध्ये अधिक तास वाया जाऊ शकतात, म्हणूनच स्मार्ट कॉन्ट्रॅक्ट्सची अंमलबजावणी स्वयंचलित करणे आकर्षक आहे.

काही विकेंद्रित ओरॅकल नेटवर्क ऑटोमेशन सेवा देतात, जे ऑफचेन ओरॅकल नोड्सना वापरकर्त्याद्वारे परिभाषित केलेल्या पॅरामीटर्सनुसार स्मार्ट कॉन्ट्रॅक्ट फंक्शन्स चालविण्याची परवानगी देतात. यासाठी सामान्यतः लक्ष्य कॉन्ट्रॅक्टला ओरॅकल सेवेसह “नोंदणी” करणे, ओरॅकल ऑपरेटरला पैसे देण्यासाठी निधी प्रदान करणे आणि कॉन्ट्रॅक्टला चालवण्यासाठीच्या अटी किंवा वेळा निर्दिष्ट करणे आवश्यक असते.

चेनलिंकचा [कीपर नेटवर्क](https://chain.link/keepers) स्मार्ट कॉन्ट्रॅक्ट्सना कमीत कमी विश्वासावर आणि विकेंद्रित पद्धतीने नियमित देखभालीची कामे आउटसोर्स करण्याचे पर्याय प्रदान करते. तुमचा कॉन्ट्रॅक्ट कीपर-सुसंगत बनवण्यासाठी आणि अपकीप सेवेचा वापर करण्यासाठी अधिकृत [कीपरची माहिती](https://docs.chain.link/docs/chainlink-keepers/introduction/) वाचा.

## ब्लॉकचेन ओरॅकल्स कसे वापरावे {#use-blockchain-oracles}

तुमच्या इथेरियम डॅपमध्ये तुम्ही समाकलित करू शकणारे अनेक ओरॅकल ऍप्लिकेशन्स आहेत:

**[Chainlink](https://chain.link/)** - _चेनलिंक विकेंद्रित ओरॅकल नेटवर्क्स कोणत्याही ब्लॉकचेनवर प्रगत स्मार्ट कॉन्ट्रॅक्ट्सना समर्थन देण्यासाठी छेडछाड-प्रतिरोधक इनपुट, आउटपुट आणि गणना प्रदान करतात._

**[RedStone Oracles](https://redstone.finance/)** - _रेडस्टोन हे एक विकेंद्रित मॉड्युलर ओरॅकल आहे जे गॅस-ऑप्टिमाइझ्ड डेटा फीड्स प्रदान करते. हे लिक्विड स्टेकिंग टोकन्स (LSTs), लिक्विड रीस्टेकिंग टोकन्स (LRTs), आणि बिटकॉइन स्टेकिंग डेरिव्हेटिव्ह्जसारख्या उदयोन्मुख मालमत्तेसाठी किंमत फीड्स प्रदान करण्यात माहिर आहे._

**[Chronicle](https://chroniclelabs.org/)** - _क्रॉनिकल खऱ्या अर्थाने स्केलेबल, किफायतशीर, विकेंद्रित आणि पडताळणीयोग्य ओरॅकल्स विकसित करून ऑनचेन डेटा हस्तांतरित करण्याच्या सध्याच्या मर्यादांवर मात करते._

**[Witnet](https://witnet.io/)** - _विटनेट हे एक परवानगीशिवाय, विकेंद्रित आणि सेन्सॉरशिप-प्रतिरोधक ओरॅकल आहे जे स्मार्ट कॉन्ट्रॅक्ट्सना मजबूत क्रिप्टो-इकॉनॉमिक हमीसह वास्तविक जगातील घटनांवर प्रतिक्रिया देण्यास मदत करते._

**[UMA Oracle](https://uma.xyz)** - _UMA चे आशावादी ओरॅकल स्मार्ट कॉन्ट्रॅक्ट्सना विमा, आर्थिक डेरिव्हेटिव्ह्ज आणि प्रेडिक्शन मार्केट्ससह विविध ऍप्लिकेशन्ससाठी कोणत्याही प्रकारचा डेटा त्वरीत प्राप्त करण्याची परवानगी देते._

**[Tellor](https://tellor.io/)** - _टेलोर हा तुमच्या स्मार्ट कॉन्ट्रॅक्टसाठी एक पारदर्शक आणि परवानगीशिवाय ओरॅकल प्रोटोकॉल आहे, ज्यामुळे त्याला गरज असेल तेव्हा कोणताही डेटा सहजपणे मिळू शकतो._

**[Band Protocol](https://bandprotocol.com/)** - _बँड प्रोटोकॉल हा एक क्रॉस-चेन डेटा ओरॅकल प्लॅटफॉर्म आहे जो वास्तविक-जगातील डेटा आणि APIs ला स्मार्ट कॉन्ट्रॅक्ट्समध्ये एकत्रित करतो आणि जोडतो._

**[Pyth Network](https://pyth.network/)** - _Pyth नेटवर्क हे एक प्रथम-पक्षीय आर्थिक ओरॅकल नेटवर्क आहे जे छेडछाड-प्रतिरोधक, विकेंद्रित आणि स्व-शाश्वत वातावरणात ऑनचेन सतत वास्तविक-जगातील डेटा प्रकाशित करण्यासाठी डिझाइन केलेले आहे._

**[API3 DAO](https://www.api3.org/)** - _API3 DAO प्रथम-पक्षीय ओरॅकल सोल्यूशन्स देत आहे जे स्मार्ट कॉन्ट्रॅक्ट्ससाठी विकेंद्रित सोल्यूशनमध्ये अधिक स्रोत पारदर्शकता, सुरक्षा आणि स्केलेबिलिटी देतात._

**[Supra](https://supra.com/)** - क्रॉस-चेन सोल्यूशन्सचे एक अनुलंब एकात्मिक टूलकिट जे सर्व ब्लॉकचेन, सार्वजनिक (L1s आणि L2s) किंवा खाजगी (उद्यम), एकमेकांशी जोडते, विकेंद्रित ओरॅकल किंमत फीड्स प्रदान करते जे ऑनचेन आणि ऑफचेन वापरासाठी वापरले जाऊ शकतात.

**[Gas Network](https://gas.network/)** - ब्लॉकचेनवर रिअल-टाइम गॅस किंमत डेटा प्रदान करणारा एक वितरित ओरॅकल प्लॅटफॉर्म. अग्रगण्य गॅस किंमत डेटा प्रदात्यांकडून डेटा ऑनचेन आणून, Gas Network इंटरऑपरेबिलिटीला चालना देण्यास मदत करत आहे. Gas Network इथेरियम मेननेट आणि अनेक अग्रगण्य L2 सह 35 पेक्षा जास्त चेन्ससाठी डेटाला समर्थन देते.

## पुढील वाचन {#further-reading}

**लेख**

- [ब्लॉकचेन ओरॅकल म्हणजे काय?](https://chain.link/education/blockchain-oracles) — _चेनलिंक_
- [ब्लॉकचेन ओरॅकल म्हणजे काय?](https://medium.com/better-programming/what-is-a-blockchain-oracle-f5ccab8dbd72) — _पॅट्रिक कॉलिन्स_
- [विकेंद्रित ओरॅकल्स: एक सर्वसमावेशक आढावा](https://medium.com/fabric-ventures/decentralised-oracles-a-comprehensive-overview-d3168b9a8841) — _ज्युलियन थेवेनार्ड_
- [इथेरियमवर ब्लॉकचेन ओरॅकल लागू करणे](https://medium.com/@pedrodc/implementing-a-blockchain-oracle-on-ethereum-cedc7e26b49e) – _पेड्रो कोस्टा_
- [स्मार्ट कॉन्ट्रॅक्ट्स API कॉल्स का करू शकत नाहीत?](https://ethereum.stackexchange.com/questions/301/why-cant-contracts-make-api-calls) — _स्टॅकएक्सचेंज_
- [तर तुम्हाला प्राइस ओरॅकल वापरायचे आहे](https://samczsun.com/so-you-want-to-use-a-price-oracle/) — _samczsun_

**व्हिडिओ**

- [ओरॅकल्स आणि ब्लॉकचेन उपयोगितेचा विस्तार](https://youtu.be/BVUZpWa8vpw) — _रिअल व्हिजन फायनान्स_

**शिकवण्या**

- [Solidityमध्ये इथेरियमची सध्याची किंमत कशी मिळवायची](https://blog.chain.link/fetch-current-crypto-price-data-solidity/) — _चेनलिंक_
- [ओरॅकल डेटा वापरणे](https://docs.chroniclelabs.org/Developers/tutorials/Remix) — _क्रॉनिकल_

**उदाहरणार्थ प्रकल्प**

- [Solidityमध्ये इथेरियमसाठी पूर्ण चेनलिंक स्टार्टर प्रोजेक्ट](https://github.com/hackbg/chainlink-fullstack) — _HackBG_
