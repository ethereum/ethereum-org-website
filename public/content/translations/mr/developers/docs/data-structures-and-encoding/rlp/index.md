---
title: रिकर्सिव्ह-लेंग्थ प्रीफिक्स (RLP) सिरियलायझेशन
description: Ethereum च्या एक्सिक्युशन लेअरमधील rlp एन्कोडिंगची व्याख्या.
lang: mr
sidebarDepth: 2
---

रिकर्सिव्ह लेंग्थ प्रीफिक्स (RLP) सिरियलायझेशनचा वापर Ethereum च्या एक्सिक्युशन क्लायंट्समध्ये मोठ्या प्रमाणावर केला जातो. RLP नोड्समधील डेटाच्या हस्तांतरणाला स्पेस-एफिशिएंट फॉरमॅटमध्ये प्रमाणित करते. RLP चा उद्देश बायनरी डेटाच्या अनियंत्रितपणे नेस्टेड अॅरेंना एन्कोड करणे आहे आणि RLP ही Ethereum च्या एक्सिक्युशन लेअरमधील ऑब्जेक्ट्स सिरियलाइज करण्यासाठी वापरली जाणारी प्राथमिक एन्कोडिंग पद्धत आहे. RLP चा मुख्य उद्देश स्ट्रक्चर एन्कोड करणे आहे; धन पूर्णांक वगळता, RLP विशिष्ट डेटा प्रकारांचे (उदा., स्ट्रिंग, फ्लोट्स) एन्कोडिंग हायर-ऑर्डर प्रोटोकॉलकडे सोपवते. धन पूर्णांक बिग-एंडियन बायनरी स्वरूपात कोणत्याही लीडिंग शून्येशिवाय दर्शविले पाहिजेत (त्यामुळे पूर्णांक मूल्य शून्य हे रिक्त बाइट अॅरेच्या समतुल्य होते). लीडिंग शून्य असलेले डिसेरियलाइज्ड धन पूर्णांक RLP वापरणाऱ्या कोणत्याही हायर-ऑर्डर प्रोटोकॉलद्वारे अवैध मानले पाहिजेत.

अधिक माहिती [Ethereum यलो पेपर (परिशिष्ट B)](https://ethereum.github.io/yellowpaper/paper.pdf#page=19) मध्ये.

डिक्शनरी एन्कोड करण्यासाठी RLP वापरण्याकरिता, दोन सुचवलेले कॅनोनिकल फॉर्म आहेत:

- लेक्सिकोग्राफिक क्रमाने की सह `[[k1,v1],[k2,v2]...]` वापरा
- Ethereum प्रमाणे हायर-लेव्हल पॅट्रिशिया ट्री एन्कोडिंग वापरा

## व्याख्या {#definition}

RLP एन्कोडिंग फंक्शन एक आयटम इनपुट म्हणून घेते. आयटमची व्याख्या खालीलप्रमाणे आहे:

- एक स्ट्रिंग (म्हणजेच, बाइट अॅरे) एक आयटम आहे
- आयटम्सची एक यादी हा एक आयटम आहे
- एक धन पूर्णांक एक आयटम आहे

उदाहरणार्थ, खालील सर्व आयटम आहेत:

- एक रिकामी स्ट्रिंग;
- "cat" हा शब्द असलेली स्ट्रिंग;
- कितीही स्ट्रिंग असलेली यादी;
- आणि `["cat", ["puppy", "cow"], "horse", [[]], "pig", [""], "sheep"]` सारखी अधिक जटिल डेटा स्ट्रक्चर्स.
- `100` ही संख्या

लक्षात घ्या की या पानाच्या उर्वरित संदर्भात, 'स्ट्रिंग' याचा अर्थ "बायनरी डेटाचे विशिष्ट संख्येचे बाइट्स" आहे; कोणतेही विशेष एन्कोडिंग वापरले जात नाहीत आणि स्ट्रिंगच्या सामग्रीबद्दल कोणतेही ज्ञान सूचित केले जात नाही (नॉन-मिनिमल धन पूर्णांकांविरुद्धच्या नियमानुसार आवश्यक असल्याशिवाय).

RLP एन्कोडिंग खालीलप्रमाणे परिभाषित केले आहे:

- धन पूर्णांकासाठी, त्याला सर्वात लहान बाइट अॅरेमध्ये रूपांतरित केले जाते ज्याचे बिग-एंडियन इंटरप्रिटेशन तो पूर्णांक आहे, आणि नंतर खालील नियमांनुसार स्ट्रिंग म्हणून एन्कोड केले जाते.
- एका बाइटसाठी ज्याचे मूल्य `[0x00, 0x7f]` (दशांश `[0, 127]`) या रेंजमध्ये आहे, तो बाइट स्वतःच त्याचे RLP एन्कोडिंग आहे.
- अन्यथा, जर एखादी स्ट्रिंग 0-55 बाइट्स लांब असेल, तर RLP एन्कोडिंगमध्ये **0x80** (दशांश 128) मूल्याचा एक बाइट अधिक स्ट्रिंगची लांबी आणि त्यानंतर स्ट्रिंग असते. पहिल्या बाइटची रेंज `[0x80, 0xb7]` (दशांश `[128, 183]`) आहे.
- जर एखादी स्ट्रिंग 55 बाइट्सपेक्षा लांब असेल, तर RLP एन्कोडिंगमध्ये **0xb7** (दशांश 183) अधिक स्ट्रिंगच्या लांबीच्या बायनरी स्वरूपाची बाइट्समधील लांबी, हे मूल्य असलेला एक बाइट असतो. त्यानंतर स्ट्रिंगची लांबी आणि मग स्ट्रिंग असते. उदाहरणार्थ, 1024 बाइट लांबीच्या स्ट्रिंगला `\xb9\x04\x00` (दशांश `185, 4, 0`) आणि त्यानंतर स्ट्रिंग असे एन्कोड केले जाईल. येथे, पहिला बाइट `0xb9` (183 + 2 = 185) आहे, त्यानंतर 2 बाइट्स `0x0400` (दशांश 1024) येतात जे प्रत्यक्ष स्ट्रिंगची लांबी दर्शवतात. पहिल्या बाइटची रेंज `[0xb8, 0xbf]` (दशांश `[184, 191]`) आहे.
- जर एखादी स्ट्रिंग 2^64 बाइट्स लांब किंवा त्याहून अधिक लांब असेल, तर ती एन्कोड केली जाऊ शकत नाही.
- जर एखाद्या यादीचा एकूण पेलोड (म्हणजेच, RLP एन्कोड केलेल्या तिच्या सर्व आयटमची एकत्रित लांबी) 0-55 बाइट्स लांब असेल, तर RLP एन्कोडिंगमध्ये **0xc0** अधिक पेलोडची लांबी हे मूल्य असलेला एक बाइट असतो, आणि त्यानंतर आयटमच्या RLP एन्कोडिंगचे एकत्रीकरण असते. पहिल्या बाइटची रेंज `[0xc0, 0xf7]` (दशांश `[192, 247]`) आहे.
- जर यादीचा एकूण पेलोड 55 बाइट्सपेक्षा जास्त असेल, तर RLP एन्कोडिंगमध्ये **0xf7** अधिक पेलोडच्या लांबीच्या बायनरी स्वरूपाची बाइट्समधील लांबी हे मूल्य असलेला एक बाइट असतो, त्यानंतर पेलोडची लांबी, आणि त्यानंतर आयटमच्या RLP एन्कोडिंगचे एकत्रीकरण असते. पहिल्या बाइटची रेंज `[0xf8, 0xff]` (दशांश `[248, 255]`) आहे.

कोडमध्ये, हे असे आहे:

```python
def rlp_encode(input):
    if isinstance(input,str):
        if len(input) == 1 and ord(input) < 0x80:
            return input
        return encode_length(len(input), 0x80) + input
    elif isinstance(input, list):
        output = ''
        for item in input:
            output += rlp_encode(item)
        return encode_length(len(output), 0xc0) + output

def encode_length(L, offset):
    if L < 56:
         return chr(L + offset)
    elif L < 256**8:
         BL = to_binary(L)
         return chr(len(BL) + offset + 55) + BL
    raise Exception("input too long")

def to_binary(x):
    if x == 0:
        return ''
    return to_binary(int(x / 256)) + chr(x % 256)
```

## उदाहरणे {#examples}

- "dog" ही स्ट्रिंग = [ 0x83, 'd', 'o', 'g' ]
- [ "cat", "dog" ] ही यादी = `[ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]`
- रिकामी स्ट्रिंग ('null') = `[ 0x80 ]`
- रिकामी यादी = `[ 0xc0 ]`
- पूर्णांक 0 = `[ 0x80 ]`
- बाइट '\\x00' = `[ 0x00 ]`
- बाइट '\\x0f' = `[ 0x0f ]`
- बाइट्स '\\x04\\x00' = `[ 0x82, 0x04, 0x00 ]`
- तीनचे [संच सैद्धांतिक प्रतिनिधित्व](http://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers), `[ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]`
- "Lorem ipsum dolor sit amet, consectetur adipisicing elit" ही स्ट्रिंग = `[ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ...` , 'e', 'l', 'i', 't' ]\`

## RLP डीकोडिंग {#rlp-decoding}

RLP एन्कोडिंगच्या नियमांनुसार आणि प्रक्रियेनुसार, RLP डीकोडचे इनपुट बायनरी डेटाचा अॅरे म्हणून मानले जाते. RLP डीकोडिंग प्रक्रिया खालीलप्रमाणे आहे:

1. इनपुट डेटाच्या पहिल्या बाइटनुसार (म्हणजे, प्रीफिक्स) डेटा प्रकार, प्रत्यक्ष डेटाची लांबी आणि ऑफसेट डीकोड करणे;

2. डेटाच्या प्रकार आणि ऑफसेटनुसार डेटा डीकोड करणे, धन पूर्णांकांसाठी किमान एन्कोडिंग नियमाचा आदर राखून;

3. उर्वरित इनपुट डीकोड करणे सुरू ठेवणे;

त्यापैकी, डेटा प्रकार आणि ऑफसेट डीकोड करण्याचे नियम खालीलप्रमाणे आहेत:

1. जर पहिल्या बाइटची (म्हणजे, प्रीफिक्स) रेंज [0x00, 0x7f] असेल, तर डेटा एक स्ट्रिंग आहे आणि स्ट्रिंग हा तो पहिला बाइटच असतो;

2. जर पहिल्या बाइटची रेंज [0x80, 0xb7] असेल, तर डेटा एक स्ट्रिंग आहे, आणि ज्याची लांबी पहिल्या बाइट वजा 0x80 इतकी आहे अशी स्ट्रिंग पहिल्या बाइटनंतर येते;

3. जर पहिल्या बाइटची रेंज [0xb8, 0xbf] असेल, तर डेटा एक स्ट्रिंग आहे, आणि ज्याची बाइट्समधील लांबी पहिल्या बाइट वजा 0xb7 इतकी आहे अशी स्ट्रिंगची लांबी पहिल्या बाइटनंतर येते, आणि स्ट्रिंग त्या लांबीनंतर येते;

4. जर पहिल्या बाइटची रेंज [0xc0, 0xf7] असेल, तर डेटा एक यादी आहे, आणि ज्या यादीचा एकूण पेलोड पहिल्या बाइट वजा 0xc0 इतका आहे, तिच्या सर्व आयटमच्या RLP एन्कोडिंगचे एकत्रीकरण पहिल्या बाइटनंतर येते;

5. जर पहिल्या बाइटची रेंज [0xf8, 0xff] असेल, तर डेटा एक यादी आहे, आणि ज्याची लांबी पहिल्या बाइट वजा 0xf7 इतकी आहे असा यादीचा एकूण पेलोड पहिल्या बाइटनंतर येतो, आणि यादीच्या सर्व आयटमच्या RLP एन्कोडिंगचे एकत्रीकरण यादीच्या एकूण पेलोडनंतर येते;

कोडमध्ये, हे असे आहे:

```python
def rlp_decode(input):
    if len(input) == 0:
        return
    output = ''
    (offset, dataLen, type) = decode_length(input)
    if type is str:
        output = instantiate_str(substr(input, offset, dataLen))
    elif type is list:
        output = instantiate_list(substr(input, offset, dataLen))
    output += rlp_decode(substr(input, offset + dataLen))
    return output

def decode_length(input):
    length = len(input)
    if length == 0:
        raise Exception("input is null")
    prefix = ord(input[0])
    if prefix <= 0x7f:
        return (0, 1, str)
    elif prefix <= 0xb7 and length > prefix - 0x80:
        strLen = prefix - 0x80
        return (1, strLen, str)
    elif prefix <= 0xbf and length > prefix - 0xb7 and length > prefix - 0xb7 + to_integer(substr(input, 1, prefix - 0xb7)):
        lenOfStrLen = prefix - 0xb7
        strLen = to_integer(substr(input, 1, lenOfStrLen))
        return (1 + lenOfStrLen, strLen, str)
    elif prefix <= 0xf7 and length > prefix - 0xc0:
        listLen = prefix - 0xc0;
        return (1, listLen, list)
    elif prefix <= 0xff and length > prefix - 0xf7 and length > prefix - 0xf7 + to_integer(substr(input, 1, prefix - 0xf7)):
        lenOfListLen = prefix - 0xf7
        listLen = to_integer(substr(input, 1, lenOfListLen))
        return (1 + lenOfListLen, listLen, list)
    raise Exception("input does not conform to RLP encoding form")

def to_integer(b):
    length = len(b)
    if length == 0:
        raise Exception("input is null")
    elif length == 1:
        return ord(b[0])
    return ord(substr(b, -1)) + to_integer(substr(b, 0, -1)) * 256
```

## पुढील वाचन {#further-reading}

- [Ethereum मधील RLP](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)
- [Ethereum अंडर द हूड: RLP](https://medium.com/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58)
- Coglio, A. (2020). ACL2 मधील Ethereum चा रिकर्सिव्ह लेंग्थ प्रीफिक्स. arXiv preprint arXiv:2009.13769.](https://arxiv.org/abs/2009.13769)

## संबंधित विषय {#related-topics}

- [पॅट्रिशिया मर्केल ट्राय](/developers/docs/data-structures-and-encoding/patricia-merkle-trie)
