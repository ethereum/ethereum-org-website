---
title: "मर्केल पॅट्रिशिया ट्राई"
description: "मर्केल पॅट्रिशिया ट्राईची ओळख."
lang: mr
sidebarDepth: 2
---

इथेरियमची स्टेट (सर्व अकाउंट्स, बॅलन्स आणि स्मार्ट कॉन्ट्रॅक्ट्सची एकूणता), डेटा स्ट्रक्चरच्या एका विशेष आवृत्तीमध्ये एन्कोड केली जाते, जी संगणक विज्ञानात सामान्यतः मर्केल ट्री म्हणून ओळखली जाते. ही रचना क्रिप्टोग्राफीमधील अनेक ॲप्लिकेशन्ससाठी उपयुक्त आहे कारण ती ट्रीमध्ये गुंतलेल्या डेटाच्या सर्व वैयक्तिक भागांमध्ये एक सत्यापित करण्यायोग्य संबंध तयार करते, ज्यामुळे एकच **रूट** व्हॅल्यू तयार होते ज्याचा वापर डेटाबद्दल गोष्टी सिद्ध करण्यासाठी केला जाऊ शकतो.

इथेरियमची डेटा स्ट्रक्चर एक 'मॉडिफाइड मर्केल-पॅट्रिशिया ट्राई' आहे, ज्याला हे नाव दिले गेले आहे कारण ते PATRICIA (प्रॅक्टिकल अल्गोरिदम टू रिट्रीव्ह इन्फॉर्मेशन कोडेड इन अल्फान्यूमेरिक) चे काही वैशिष्ट्ये घेते आणि कारण ते इथेरियम स्टेट तयार करणाऱ्या आयटम्सच्या कार्यक्षम डेटा रि**ट्राई**व्हलसाठी डिझाइन केलेले आहे.

मर्केल-पॅट्रिशिया ट्राई ही निश्चित (deterministic) आणि क्रिप्टोग्राफिकदृष्ट्या सत्यापित करण्यायोग्य आहे: स्टेट रूट तयार करण्याचा एकमेव मार्ग म्हणजे स्टेटच्या प्रत्येक वैयक्तिक भागातून त्याची गणना करणे आणि दोन सारख्याच स्टेट्सची रूट हॅश आणि त्यापर्यंत पोहोचलेल्या हॅशेसची तुलना करून सहजपणे सिद्ध करता येते (_एक मर्केल प्रूफ_). याउलट, एकाच रूट हॅशसह दोन भिन्न स्टेट्स तयार करण्याचा कोणताही मार्ग नाही आणि भिन्न मूल्यांसह स्टेटमध्ये बदल करण्याचा कोणताही प्रयत्न केल्यास भिन्न स्टेट रूट हॅश मिळेल. सैद्धांतिकदृष्ट्या, ही रचना इन्सर्ट, लुकअप आणि डिलीटसाठी `O(log(n))` कार्यक्षमतेचे 'होली ग्रेल' प्रदान करते.

नजीकच्या भविष्यात, इथेरियम [Verkle Tree](/roadmap/verkle-trees) रचनेमध्ये स्थलांतरित करण्याची योजना आखत आहे, ज्यामुळे भविष्यातील प्रोटोकॉल सुधारणांसाठी अनेक नवीन शक्यता उघडल्या जातील.

## पूर्वतयारी {#prerequisites}

हे पृष्ठ अधिक चांगल्या प्रकारे समजून घेण्यासाठी, [हॅशेस](https://en.wikipedia.org/wiki/Hash_function), [मर्केल ट्रीज](https://en.wikipedia.org/wiki/Merkle_tree), [ट्राईज](https://en.wikipedia.org/wiki/Trie) आणि [सीरियलायझेशन](https://en.wikipedia.org/wiki/Serialization) यांचे मूलभूत ज्ञान असणे उपयुक्त ठरेल. हा लेख मूलभूत [रॅडिक्स ट्री](https://en.wikipedia.org/wiki/Radix_tree) च्या वर्णनाने सुरू होतो, नंतर हळूहळू इथेरियमच्या अधिक ऑप्टिमाइझ केलेल्या डेटा स्ट्रक्चरसाठी आवश्यक बदल सादर करतो.

## मूलभूत रॅडिक्स ट्राईज {#basic-radix-tries}

मूलभूत रॅडिक्स ट्राईमध्ये, प्रत्येक नोड खालीलप्रमाणे दिसतो:

```
    [i_0, i_1 ... i_n, value]
```

जिथे `i_0 ...  i_n` वर्णमालेची चिन्हे दर्शवतात (बहुतेकदा बायनरी किंवा हेक्स), `व्हॅल्यू` नोडमधील टर्मिनल व्हॅल्यू आहे, आणि `i_0, i_1 ... ` मधील व्हॅल्यूज i_n`स्लॉट एकतर`NULL`किंवा इतर नोड्सचे पॉइंटर्स (आमच्या बाबतीत, हॅश) असतात. हे एक मूलभूत`(की, व्हॅल्यू)` स्टोअर तयार करते.

समजा तुम्हाला की-व्हॅल्यू जोड्यांच्या सेटवर ऑर्डर कायम ठेवण्यासाठी रॅडिक्स ट्री डेटा स्ट्रक्चर वापरायचे आहे. ट्राईमध्ये सध्या `dog` की शी मॅप केलेली व्हॅल्यू शोधण्यासाठी, तुम्ही प्रथम `dog` ला वर्णमालेच्या अक्षरांमध्ये रूपांतरित कराल ( `64 6f 67` देऊन), आणि नंतर तुम्हाला व्हॅल्यू मिळेपर्यंत त्या मार्गावरून ट्राईमध्ये खाली जाल. म्हणजे, तुम्ही ट्राईचा रूट नोड शोधण्यासाठी फ्लॅट की/व्हॅल्यू DB मध्ये रूट हॅश शोधून सुरुवात करता. ते इतर नोड्सना पॉइंट करणाऱ्या कीजच्या ॲरे म्हणून दर्शविले जाते. तुम्ही इंडेक्स `6` वरील व्हॅल्यूचा की म्हणून वापर कराल आणि एका लेव्हल खालील नोड मिळवण्यासाठी फ्लॅट की/व्हॅल्यू DB मध्ये शोधाल. नंतर पुढील व्हॅल्यू शोधण्यासाठी इंडेक्स `4` निवडा, नंतर इंडेक्स `6` निवडा, आणि असेच, जोपर्यंत तुम्ही मार्ग: `रूट -> 6 -> 4 -> 6 -> 15 -> 6 -> 7` फॉलो करत नाही, तोपर्यंत तुम्ही नोडची व्हॅल्यू शोधून निकाल परत कराल.

'ट्राई' मध्ये काहीतरी शोधणे आणि अंतर्निहित फ्लॅट की/व्हॅल्यू 'DB' मध्ये शोधणे यात फरक आहे. ते दोघेही की/व्हॅल्यू व्यवस्था परिभाषित करतात, परंतु अंतर्निहित DB की चा पारंपरिक 1-स्टेप लुकअप करू शकतो. ट्राईमध्ये की शोधण्यासाठी वर वर्णन केलेल्या अंतिम व्हॅल्यूपर्यंत पोहोचण्यासाठी अनेक अंतर्निहित DB लुकअप्सची आवश्यकता असते. अस्पष्टता दूर करण्यासाठी आपण नंतरच्याला `पाथ` म्हणूया.

रॅडिक्स ट्राईजसाठी अपडेट आणि डिलीट ऑपरेशन्स खालीलप्रमाणे परिभाषित केल्या जाऊ शकतात:

```python
    def update(node_hash, path, value):
        curnode = db.get(node_hash) if node_hash else [NULL] * 17
        newnode = curnode.copy()
        if path == "":
            newnode[-1] = value
        else:
            newindex = update(curnode[path[0]], path[1:], value)
            newnode[path[0]] = newindex
        db.put(hash(newnode), newnode)
        return hash(newnode)

    def delete(node_hash, path):
        if node_hash is NULL:
            return NULL
        else:
            curnode = db.get(node_hash)
            newnode = curnode.copy()
            if path == "":
                newnode[-1] = NULL
            else:
                newindex = delete(curnode[path[0]], path[1:])
                newnode[path[0]] = newindex

            if all(x is NULL for x in newnode):
                return NULL
            else:
                db.put(hash(newnode), newnode)
                return hash(newnode)
```

एक "मर्केल" रॅडिक्स ट्री निश्चितपणे-उत्पादित क्रिप्टोग्राफिक हॅश डायजेस्ट वापरून नोड्स लिंक करून तयार केली जाते. हे कंटेंट-ॲड्रेसिंग (की/व्हॅल्यू DB मध्ये `की == keccak256(rlp(व्हॅल्यू))`) संग्रहित डेटाची क्रिप्टोग्राफिक अखंडतेची हमी देते. जर दिलेल्या ट्राईचा रूट हॅश सार्वजनिकरित्या ज्ञात असेल, तर अंतर्निहित लीफ डेटामध्ये प्रवेश असलेला कोणीही विशिष्ट व्हॅल्यूला ट्री रूटशी जोडणाऱ्या प्रत्येक नोडचे हॅश प्रदान करून, ट्राईमध्ये विशिष्ट मार्गावर विशिष्ट व्हॅल्यू समाविष्ट असल्याचा पुरावा तयार करू शकतो.

आक्रमणकर्त्यासाठी अस्तित्वात नसलेल्या `(पाथ, व्हॅल्यू)` जोडीचा पुरावा देणे अशक्य आहे कारण रूट हॅश शेवटी त्याच्या खालील सर्व हॅशवर आधारित असतो. कोणत्याही अंतर्निहित बदलामुळे रूट हॅश बदलेल. आपण हॅशला डेटाच्या संरचनात्मक माहितीचे संकुचित प्रतिनिधित्व म्हणून विचार करू शकता, जे हॅशिंग फंक्शनच्या प्री-इमेज संरक्षणाद्वारे सुरक्षित केलेले आहे.

आपण रॅडिक्स ट्रीच्या अणु एककाला (उदा., एकच हेक्स कॅरॅक्टर किंवा 4 बिट बायनरी संख्या) "निबल" म्हणू. वर वर्णन केल्याप्रमाणे, एका वेळी एक निबल मार्गक्रमण करताना, नोड्स जास्तीत जास्त 16 चिल्ड्रेनचा संदर्भ घेऊ शकतात परंतु त्यात `व्हॅल्यू` घटक समाविष्ट असतो. म्हणून, आम्ही त्यांना 17 लांबीच्या ॲरे म्हणून दर्शवितो. आम्ही या 17-घटक ॲरेला "ब्रांच नोड्स" म्हणतो.

## मर्केल पॅट्रिशिया ट्राई {#merkle-patricia-trees}

रॅडिक्स ट्राईजची एक मोठी मर्यादा आहे: त्या अकार्यक्षम आहेत. जर तुम्हाला एक `(पाथ, व्हॅल्यू)` बाइंडिंग साठवायचे असेल जिथे पाथ, इथेरियमप्रमाणे, 64 कॅरॅक्टर लांब आहे (`bytes32` मधील निबल्सची संख्या), तर आम्हाला प्रत्येक कॅरॅक्टरसाठी एक लेव्हल साठवण्यासाठी एक किलोबाइटपेक्षा जास्त अतिरिक्त जागेची आवश्यकता असेल, आणि प्रत्येक लुकअप किंवा डिलीटसाठी पूर्ण 64 स्टेप्स लागतील. खालीलप्रमाणे सादर केलेली पॅट्रिशिया ट्राई ही समस्या सोडवते.

### ऑप्टिमायझेशन {#optimization}

मर्केल पॅट्रिशिया ट्राईमधील नोड खालीलपैकी एक असतो:

1. `NULL` (रिकाम्या स्ट्रिंगने दर्शविलेले)
2. `ब्रांच` एक 17-आयटम नोड `[ v0 ... v15, vt ]`
3. `लीफ` एक 2-आयटम नोड `[ एन्कोडेडपाथ, व्हॅल्यू ]`
4. `एक्सटेन्शन` एक 2-आयटम नोड `[ एन्कोडेडपाथ, की ]`

64 कॅरॅक्टर पाथसह, ट्राईच्या पहिल्या काही लेयर्समधून गेल्यानंतर, तुम्ही अशा नोडवर पोहोचणारच आहात जिथे किमान काही मार्गासाठी कोणताही भिन्न मार्ग अस्तित्वात नाही. मार्गावर 15 पर्यंत विरळ `NULL` नोड्स तयार करणे टाळण्यासाठी, आम्ही `[ एन्कोडेडपाथ, की ]` स्वरूपाचा एक `एक्सटेन्शन` नोड सेट करून उतरण लहान करतो, जिथे `एन्कोडेडपाथ` मध्ये पुढे जाण्यासाठी "आंशिक मार्ग" असतो (खाली वर्णन केलेल्या कॉम्पॅक्ट एन्कोडिंगचा वापर करून), आणि `की` पुढील DB लुकअपसाठी असते.

`लीफ` नोडसाठी, जे `एन्कोडेडपाथ`च्या पहिल्या निबलमधील ध्वजाद्वारे चिन्हांकित केले जाऊ शकते, पाथमध्ये मागील सर्व नोडच्या पाथच्या तुकड्यांचे एन्कोडिंग असते आणि आम्ही थेट `व्हॅल्यू` शोधू शकतो.

तथापि, वरील ऑप्टिमायझेशनमुळे संदिग्धता निर्माण होते.

निबल्समध्ये पाथक्रमण करताना, आपल्याला विषम संख्येने निबल्सचा सामना करावा लागू शकतो, परंतु सर्व डेटा `बाइट्स` स्वरूपात संग्रहित असल्यामुळे. उदाहरणार्थ, निबल `1` आणि निबल्स `01` मध्ये फरक करणे शक्य नाही (दोन्ही `<01>` म्हणून संग्रहित करणे आवश्यक आहे). विषम लांबी निर्दिष्ट करण्यासाठी, आंशिक मार्गाच्या आधी एक ध्वज लावला जातो.

### स्पेसिफिकेशन: पर्यायी टर्मिनेटरसह हेक्स सीक्वेन्सचे कॉम्पॅक्ट एन्कोडिंग {#specification}

वर वर्णन केल्याप्रमाणे _विषम विरुद्ध सम उर्वरित आंशिक मार्गाची लांबी_ आणि _लीफ विरुद्ध एक्सटेन्शन नोड_ या दोन्हींचे ध्वजांकन कोणत्याही 2-आयटम नोडच्या आंशिक मार्गाच्या पहिल्या निबलमध्ये असते. त्यांचे परिणाम खालीलप्रमाणे आहेत:

| हेक्स कॅरॅक्टर | बिट्स | नोड प्रकार आंशिक                     | पाथची लांबी |
| -------------- | ----- | ------------------------------------ | ----------- |
| 0              | 0000  | एक्सटेन्शन                           | सम          |
| 1              | 0001  | एक्सटेन्शन                           | विषम        |
| 2              | 0010  | टर्मिनेटिंग (लीफ) | सम          |
| 3              | 0011  | टर्मिनेटिंग (लीफ) | विषम        |

सम उर्वरित पाथ लांबीसाठी (`0` किंवा `2`), नेहमीच आणखी एक `0` "पॅडिंग" निबल येईल.

```python
    def compact_encode(hexarray):
        term = 1 if hexarray[-1] == 16 else 0
        if term:
            hexarray = hexarray[:-1]
        oddlen = len(hexarray) % 2
        flags = 2 * term + oddlen
        if oddlen:
            hexarray = [flags] + hexarray
        else:
            hexarray = [flags] + [0] + hexarray
        # hexarray now has an even length whose first nibble is the flags.
        o = ""
        for i in range(0, len(hexarray), 2):
            o += chr(16 * hexarray[i] + hexarray[i + 1])
        return o
```

उदाहरणे:

```python
    > [1, 2, 3, 4, 5, ...]
    '11 23 45'
    > [0, 1, 2, 3, 4, 5, ...]
    '00 01 23 45'
    > [0, f, 1, c, b, 8, 10]
    '20 0f 1c b8'
    > [f, 1, c, b, 8, 10]
    '3f 1c b8'
```

मर्केल पॅट्रिशिया ट्राईमध्ये नोड मिळवण्यासाठी विस्तारित कोड येथे आहे:

```python
    def get_helper(node_hash, path):
        if path == []:
            return node_hash
        if node_hash == "":
            return ""
        curnode = rlp.decode(node_hash if len(node_hash) < 32 else db.get(node_hash))
        if len(curnode) == 2:
            (k2, v2) = curnode
            k2 = compact_decode(k2)
            if k2 == path[: len(k2)]:
                return get(v2, path[len(k2) :])
            else:
                return ""
        elif len(curnode) == 17:
            return get_helper(curnode[path[0]], path[1:])

    def get(node_hash, path):
        path2 = []
        for i in range(len(path)):
            path2.push(int(ord(path[i]) / 16))
            path2.push(ord(path[i]) % 16)
        path2.push(16)
        return get_helper(node_hash, path2)
```

### उदाहरण ट्राई {#example-trie}

समजा आपल्याला चार पाथ/व्हॅल्यू जोड्या असलेली ट्राई हवी आहे: `('do', 'verb')`, `('dog', 'puppy')`, `('doge', 'coins')`, `('horse', 'stallion')`.

प्रथम, आपण पाथ आणि व्हॅल्यू दोन्ही `बाइट्स` मध्ये रूपांतरित करतो. खाली, _पाथ_ साठी वास्तविक बाइट रिप्रेझेंटेशन्स `<>` ने दर्शविले आहेत, तरीही _व्हॅल्यू_ सोप्या समजुतीसाठी `''` ने दर्शविलेल्या स्ट्रिंग म्हणून दाखवल्या आहेत (त्या देखील वास्तविकपणे `बाइट्स` असतील):

```
    <64 6f> : 'क्रियापद'
    <64 6f 67> : 'पिल्लू'
    <64 6f 67 65> : 'नाणी'
    <68 6f 72 73 65> : 'घोडा'
```

आता, आपण अंतर्निहित DB मध्ये खालील की/व्हॅल्यू जोड्यांसह अशी ट्राई तयार करू:

```
    rootHash: [ <16>, hashA ]
    hashA:    [ <>, <>, <>, <>, hashB, <>, <>, <>, [ <20 6f 72 73 65>, 'घोडा' ], <>, <>, <>, <>, <>, <>, <>, <> ]
    hashB:    [ <00 6f>, hashC ]
    hashC:    [ <>, <>, <>, <>, <>, <>, hashD, <>, <>, <>, <>, <>, <>, <>, <>, <>, 'क्रियापद' ]
    hashD:    [ <17>, [ <>, <>, <>, <>, <>, <>, [ <35>, 'नाणी' ], <>, <>, <>, <>, <>, <>, <>, <>, <>, 'पिल्लू' ] ]
```

जेव्हा एका नोडचा दुसऱ्या नोडमध्ये संदर्भ दिला जातो, तेव्हा `keccak256(rlp.encode(node))` समाविष्ट केले जाते, जर `len(rlp.encode(node)) >= 32` असेल तर, अन्यथा `node` समाविष्ट केले जाते जिथे `rlp.encode` हे [RLP](/developers/docs/data-structures-and-encoding/rlp) एन्कोडिंग फंक्शन आहे.

लक्षात घ्या की ट्राई अपडेट करताना, जर नव्याने तयार केलेला नोड 32 किंवा त्यापेक्षा जास्त लांबीचा असेल तर, की/व्हॅल्यू जोडी `(keccak256(x), x)` एका पर्सिस्टंट लुकअप टेबलमध्ये साठवणे आवश्यक आहे. तथापि, जर नोड त्यापेक्षा लहान असेल, तर काहीही साठवण्याची गरज नाही, कारण f(x) = x हे फंक्शन उलट करता येण्याजोगे आहे.

## इथेरियममधील ट्राईज {#tries-in-ethereum}

इथेरियमच्या एक्झिक्युशन लेअरमधील सर्व मर्केल ट्राईज मर्केल पॅट्रिशिया ट्राई वापरतात.

ब्लॉक हेडरमधून यापैकी 3 ट्राईजचे 3 रूट्स असतात.

1. स्टेटरूट
2. ट्रान्झॅक्शन्सरूट
3. रीसीट्सरूट

### स्टेट ट्राई {#state-trie}

एक जागतिक स्टेट ट्राई आहे, आणि जेव्हा एखादा क्लायंट ब्लॉकवर प्रक्रिया करतो तेव्हा ती प्रत्येक वेळी अपडेट केली जाते. त्यात, एक `पाथ` नेहमी असतो: `keccak256(ethereumAddress)` आणि एक `व्हॅल्यू` नेहमी असते: `rlp(ethereumAccount)`. अधिक विशेषतः, एक इथेरियम `अकाउंट` `[nonce,balance,storageRoot,codeHash]` या 4 आयटमचा ॲरे आहे. या टप्प्यावर, हे लक्षात घेण्यासारखे आहे की हा `storageRoot` दुसऱ्या पॅट्रिशिया ट्राईचा रूट आहे:

### स्टोरेज ट्राई {#storage-trie}

स्टोरेज ट्राई हे असे ठिकाण आहे जिथे _सर्व_ कॉन्ट्रॅक्ट डेटा राहतो. प्रत्येक अकाउंटसाठी स्वतंत्र स्टोरेज ट्राई असते. विशिष्ट ॲड्रेसवर विशिष्ट स्टोरेज पोझिशनवरील व्हॅल्यूज मिळवण्यासाठी स्टोरेज ॲड्रेस, स्टोरेजमध्ये संग्रहित डेटाची पूर्णांक पोझिशन आणि ब्लॉक आयडी आवश्यक आहेत. त्यानंतर JSON-RPC API मध्ये परिभाषित `eth_getStorageAt` ला आर्गुमेंट्स म्हणून पास केले जाऊ शकते, उदा., ॲड्रेस `0x295a70b2de5e3953354a6a8344e616ed314d7251` साठी स्टोरेज स्लॉट 0 मधील डेटा मिळवण्यासाठी:

```bash
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x0", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x00000000000000000000000000000000000000000000000000000000000004d2"}

```

स्टोरेजमधील इतर घटक मिळवणे थोडे अधिक गुंतागुंतीचे आहे कारण स्टोरेज ट्राईमधील पोझिशनची प्रथम गणना करणे आवश्यक आहे. पोझिशनची गणना ॲड्रेस आणि स्टोरेज पोझिशनच्या `keccak256` हॅश म्हणून केली जाते, दोन्ही 32 बाइट्सच्या लांबीपर्यंत शून्यांसह डावीकडे पॅड केलेले असतात. उदाहरणार्थ, ॲड्रेस `0x391694e7e0b0cce554cb130d723a9d27458f9298` साठी स्टोरेज स्लॉट 1 मधील डेटाची पोझिशन आहे:

```python
keccak256(decodeHex("000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298" + "0000000000000000000000000000000000000000000000000000000000000001"))
```

Geth कन्सोलमध्ये, याची गणना खालीलप्रमाणे केली जाऊ शकते:

```
> var key = "000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298" + "0000000000000000000000000000000000000000000000000000000000000001"
undefined
> web3.sha3(key, {"encoding": "hex"})
"0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9"
```

म्हणून `पाथ` `keccak256(<6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9>)` आहे. हे आता पूर्वीप्रमाणेच स्टोरेज ट्राईमधून डेटा मिळवण्यासाठी वापरले जाऊ शकते:

```bash
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000162e"}
```

टीप: जर ते कॉन्ट्रॅक्ट अकाउंट नसेल तर इथेरियम अकाउंटसाठी `storageRoot` डिफॉल्टनुसार रिकामा असतो.

### ट्रान्झॅक्शन ट्राई {#transaction-trie}

प्रत्येक ब्लॉकसाठी एक वेगळी ट्रान्झॅक्शन ट्राई असते, जी पुन्हा `(की, व्हॅल्यू)` जोड्या साठवते. येथे एक पाथ आहे: `rlp(transactionIndex)` जो एका व्हॅल्यूशी संबंधित की दर्शवितो, जी याद्वारे निर्धारित केली जाते:

```python
if legacyTx:
  value = rlp(tx)
else:
  value = TxType | encode(tx)
```

याबद्दल अधिक माहिती [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718) डॉक्युमेंटेशनमध्ये आढळू शकते.

### रीसीट्स ट्राई {#receipts-trie}

प्रत्येक ब्लॉकची स्वतःची रीसीट्स ट्राई असते. येथे एक `पाथ` आहे: `rlp(transactionIndex)`. `transactionIndex` हा ज्या ब्लॉक मध्ये त्याचा समावेश आहे त्यातील त्याचा इंडेक्स आहे. रीसीट्स ट्राई कधीही अपडेट केली जात नाही. ट्रान्झॅक्शन ट्राई प्रमाणेच, सध्याच्या आणि लेगसी रीसीट्स आहेत. रीसीट्स ट्राईमध्ये विशिष्ट रीसीट क्वेरी करण्यासाठी, त्याच्या ब्लॉकमधील ट्रान्झॅक्शनचा इंडेक्स, रीसीट पेलोड आणि ट्रान्झॅक्शन प्रकार आवश्यक आहे. परत आलेली रीसीट `Receipt` प्रकाराची असू शकते जी `TransactionType` आणि `ReceiptPayload` चे एकत्रीकरण म्हणून परिभाषित केली आहे किंवा ती `LegacyReceipt` प्रकाराची असू शकते जी `rlp([status, cumulativeGasUsed, logsBloom, logs])` म्हणून परिभाषित केली आहे.

याबद्दल अधिक माहिती [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718) डॉक्युमेंटेशनमध्ये आढळू शकते.

## अधिक वाचन {#further-reading}

- [सुधारित मर्केल पॅट्रिशिया ट्राई — इथेरियम स्टेट कसे सेव्ह करते](https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd)
- [इथेरियममधील मर्कलिंग](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)
- [इथेरियम ट्राई समजून घेणे](https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/)
