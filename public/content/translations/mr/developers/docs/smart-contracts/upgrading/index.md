---
title: "स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करणे"
description: "इथेरियम स्मार्ट कॉन्ट्रॅक्टसाठी अपग्रेड पॅटर्नचा आढावा"
lang: mr
---

इथेरियमवरील स्मार्ट कॉन्ट्रॅक्ट हे स्व-कार्यकारी प्रोग्राम आहेत जे इथेरियम व्हर्च्युअल मशीन (EVM) मध्ये चालतात. हे प्रोग्राम डिझाइननुसार अपरिवर्तनीय आहेत, जे एकदा कॉन्ट्रॅक्ट तैनात झाल्यावर व्यवसायाच्या तर्कामध्ये कोणतेही बदल करण्यास प्रतिबंध करते.

स्मार्ट कॉन्ट्रॅक्ट्सच्या विश्वासहीनता, विकेंद्रीकरण आणि सुरक्षिततेसाठी अपरिवर्तनीयता आवश्यक असली तरी, काही विशिष्ट प्रकरणांमध्ये तो एक तोटा असू शकतो. उदाहरणार्थ, अपरिवर्तनीय कोडमुळे डेव्हलपर्सना असुरक्षित कॉन्ट्रॅक्ट्स दुरुस्त करणे अशक्य होऊ शकते.

तथापि, स्मार्ट कॉन्ट्रॅक्ट सुधारण्यावरील वाढलेल्या संशोधनामुळे अनेक अपग्रेड पॅटर्नची ओळख झाली आहे. हे अपग्रेड पॅटर्न डेव्हलपर्सना वेगवेगळ्या कॉन्ट्रॅक्टमध्ये व्यवसायाचे तर्क ठेवून स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्यास सक्षम करतात (अपरिवर्तनीयता जपताना).

## पूर्वतयारी {#prerequisites}

तुम्हाला [स्मार्ट कॉन्ट्रॅक्ट](/developers/docs/smart-contracts/), [स्मार्ट कॉन्ट्रॅक्ट रचना](/developers/docs/smart-contracts/anatomy/), आणि [इथेरियम व्हर्च्युअल मशीन (EVM)](/developers/docs/evm/) यांची चांगली समज असायला हवी. हे मार्गदर्शक असेही गृहीत धरते की वाचकांना स्मार्ट कॉन्ट्रॅक्ट प्रोग्रामिंगची माहिती आहे.

## स्मार्ट कॉन्ट्रॅक्ट अपग्रेड म्हणजे काय? {#what-is-a-smart-contract-upgrade}

स्मार्ट कॉन्ट्रॅक्ट अपग्रेडमध्ये कॉन्ट्रॅक्टची स्थिती जतन करताना स्मार्ट कॉन्ट्रॅक्टच्या व्यवसायाच्या तर्कामध्ये बदल करणे समाविष्ट असते. हे स्पष्ट करणे महत्त्वाचे आहे की, विशेषतः स्मार्ट कॉन्ट्रॅक्टच्या संदर्भात, अपग्रेडिबिलिटी आणि म्युटेबिलिटी या एकच नाहीत.

तुम्ही इथेरियम नेटवर्कवरील पत्त्यावर तैनात केलेला प्रोग्राम अजूनही बदलू शकत नाही. परंतु वापरकर्ते स्मार्ट कॉन्ट्रॅक्टशी संवाद साधताना कार्यान्वित होणारा कोड तुम्ही बदलू शकता.

हे खालील पद्धतींद्वारे केले जाऊ शकते:

1. स्मार्ट कॉन्ट्रॅक्टच्या अनेक आवृत्त्या तयार करणे आणि जुन्या कॉन्ट्रॅक्टमधून नवीन कॉन्ट्रॅक्ट इंस्टन्सवर स्थिती (म्हणजे डेटा) स्थलांतरित करणे.

2. व्यवसाय तर्क आणि स्थिती साठवण्यासाठी स्वतंत्र कॉन्ट्रॅक्ट तयार करणे.

3. अपरिवर्तनीय प्रॉक्सी कॉन्ट्रॅक्टमधून बदलण्यायोग्य तर्क कॉन्ट्रॅक्टकडे फंक्शन कॉल सोपवण्यासाठी प्रॉक्सी पॅटर्न वापरणे.

4. विशिष्ट फंक्शन्स कार्यान्वित करण्यासाठी लवचिक सॅटेलाइट कॉन्ट्रॅक्ट्सशी इंटरफेस करणारा आणि त्यावर अवलंबून असणारा एक अपरिवर्तनीय मुख्य कॉन्ट्रॅक्ट तयार करणे.

5. प्रॉक्सी कॉन्ट्रॅक्टमधून लॉजिक कॉन्ट्रॅक्ट्सकडे फंक्शन कॉल सोपवण्यासाठी डायमंड पॅटर्न वापरणे.

### अपग्रेड यंत्रणा #1: कॉन्ट्रॅक्ट स्थलांतर {#contract-migration}

कॉन्ट्रॅक्ट स्थलांतर हे आवृत्तीकरणावर आधारित आहे—म्हणजेच, एकाच सॉफ्टवेअरच्या अद्वितीय स्थिती तयार करणे आणि व्यवस्थापित करण्याची कल्पना. कॉन्ट्रॅक्ट स्थलांतरामध्ये अस्तित्वात असलेल्या स्मार्ट कॉन्ट्रॅक्टचा नवीन इन्स्टन्स तैनात करणे आणि नवीन कॉन्ट्रॅक्टमध्ये स्टोरेज आणि शिल्लक हस्तांतरित करणे यांचा समावेश असतो.

नव्याने तैनात केलेल्या कॉन्ट्रॅक्टमध्ये रिकामा स्टोरेज असेल, ज्यामुळे तुम्हाला जुन्या कॉन्ट्रॅक्टमधून डेटा परत मिळवता येईल आणि तो नवीन अंमलबजावणीमध्ये लिहिता येईल. त्यानंतर, तुम्हाला जुन्या कॉन्ट्रॅक्टशी संवाद साधलेल्या सर्व कॉन्ट्रॅक्टना नवीन पत्ता दर्शवण्यासाठी अपडेट करावे लागेल.

कॉन्ट्रॅक्ट स्थलांतरातील शेवटची पायरी म्हणजे वापरकर्त्यांना नवीन कॉन्ट्रॅक्ट वापरण्यासाठी प्रवृत्त करणे. नवीन कॉन्ट्रॅक्ट आवृत्ती वापरकर्त्याची शिल्लक आणि पत्ते कायम ठेवेल, ज्यामुळे अपरिवर्तनीयता जपली जाते. जर तो टोकन-आधारित कॉन्ट्रॅक्ट असेल, तर तुम्हाला जुना कॉन्ट्रॅक्ट रद्द करून नवीन कॉन्ट्रॅक्ट वापरण्यासाठी एक्सचेंजेसशी संपर्क साधावा लागेल.

वापरकर्त्यांच्या संवादात व्यत्यय न आणता स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्यासाठी कॉन्ट्रॅक्ट स्थलांतर ही एक तुलनेने सोपी आणि सुरक्षित उपाययोजना आहे. तथापि, वापरकर्ता स्टोरेज आणि शिल्लक नवीन कॉन्ट्रॅक्टमध्ये मॅन्युअली स्थलांतरित करणे वेळखाऊ आहे आणि त्यात जास्त गॅस खर्च येऊ शकतो.

[कॉन्ट्रॅक्ट स्थलांतरावर अधिक.](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/)

### अपग्रेड यंत्रणा #2: डेटा विभाजन {#data-separation}

स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्याची दुसरी पद्धत म्हणजे व्यवसाय तर्क आणि डेटा स्टोरेज स्वतंत्र कॉन्ट्रॅक्टमध्ये वेगळे करणे. याचा अर्थ वापरकर्ते लॉजिक कॉन्ट्रॅक्टशी संवाद साधतात, तर डेटा स्टोरेज कॉन्ट्रॅक्टमध्ये संग्रहित केला जातो.

लॉजिक कॉन्ट्रॅक्टमध्ये तो कोड असतो जो वापरकर्ते ऍप्लिकेशनशी संवाद साधताना कार्यान्वित होतो. त्यात स्टोरेज कॉन्ट्रॅक्टचा पत्ता देखील असतो आणि डेटा मिळवण्यासाठी आणि सेट करण्यासाठी त्याच्याशी संवाद साधतो.

दरम्यान, स्टोरेज कॉन्ट्रॅक्टमध्ये स्मार्ट कॉन्ट्रॅक्टशी संबंधित स्थिती असते, जसे की वापरकर्त्याची शिल्लक आणि पत्ते. लक्षात घ्या की स्टोरेज कॉन्ट्रॅक्ट लॉजिक कॉन्ट्रॅक्टच्या मालकीचा असतो आणि तैनात करताना नंतरच्या पत्त्यासह कॉन्फिगर केलेला असतो. हे अनधिकृत कॉन्ट्रॅक्टना स्टोरेज कॉन्ट्रॅक्टला कॉल करण्यापासून किंवा त्याचा डेटा अपडेट करण्यापासून प्रतिबंधित करते.

डीफॉल्टनुसार, स्टोरेज कॉन्ट्रॅक्ट अपरिवर्तनीय असतो—परंतु तुम्ही ज्या लॉजिक कॉन्ट्रॅक्टकडे ते निर्देश करते त्याला नवीन अंमलबजावणीसह बदलू शकता. यामुळे EVM मध्ये चालणारा कोड बदलेल, आणि स्टोरेज व शिल्लक अबाधित राहील.

ही अपग्रेड पद्धत वापरण्यासाठी स्टोरेज कॉन्ट्रॅक्टमधील लॉजिक कॉन्ट्रॅक्टचा पत्ता अपडेट करणे आवश्यक आहे. तुम्ही नवीन लॉजिक कॉन्ट्रॅक्टला स्टोरेज कॉन्ट्रॅक्टच्या पत्त्यासह कॉन्फिगर करणे आवश्यक आहे, ज्याची कारणे पूर्वी स्पष्ट केली आहेत.

कॉन्ट्रॅक्ट स्थलांतराच्या तुलनेत डेटा विभाजन पॅटर्न अंमलात आणणे अधिक सोपे आहे. तथापि, तुम्हाला अनेक कॉन्ट्रॅक्ट्स व्यवस्थापित करावे लागतील आणि स्मार्ट कॉन्ट्रॅक्ट्सना दुर्भावनापूर्ण अपग्रेड्सपासून वाचवण्यासाठी गुंतागुंतीच्या अधिकृतता योजना लागू कराव्या लागतील.

### अपग्रेड यंत्रणा #3: प्रॉक्सी पॅटर्न {#proxy-patterns}

प्रॉक्सी पॅटर्न देखील व्यवसाय तर्क आणि डेटा स्वतंत्र कॉन्ट्रॅक्टमध्ये ठेवण्यासाठी डेटा विभाजनाचा वापर करतो. तथापि, प्रॉक्सी पॅटर्नमध्ये, स्टोरेज कॉन्ट्रॅक्ट (ज्याला प्रॉक्सी म्हणतात) कोड अंमलबजावणी दरम्यान लॉजिक कॉन्ट्रॅक्टला कॉल करतो. ही डेटा विभाजन पद्धतीच्या उलट आहे, जिथे लॉजिक कॉन्ट्रॅक्ट स्टोरेज कॉन्ट्रॅक्टला कॉल करतो.

प्रॉक्सी पॅटर्नमध्ये हे घडते:

1. वापरकर्ते प्रॉक्सी कॉन्ट्रॅक्टशी संवाद साधतात, जो डेटा संग्रहित करतो, परंतु व्यवसायाचा तर्क ठेवत नाही.

2. प्रॉक्सी कॉन्ट्रॅक्ट लॉजिक कॉन्ट्रॅक्टचा पत्ता संग्रहित करतो आणि `delegatecall` फंक्शन वापरून सर्व फंक्शन कॉल लॉजिक कॉन्ट्रॅक्टकडे (ज्यात व्यवसायाचा तर्क असतो) सोपवतो.

3. कॉल लॉजिक कॉन्ट्रॅक्टकडे फॉरवर्ड केल्यानंतर, लॉजिक कॉन्ट्रॅक्टमधून परत आलेला डेटा पुनर्प्राप्त केला जातो आणि वापरकर्त्याला परत केला जातो.

प्रॉक्सी पॅटर्न वापरण्यासाठी **delegatecall** फंक्शनची समज असणे आवश्यक आहे. मूलतः, `delegatecall` एक ऑपकोड आहे जो एका कॉन्ट्रॅक्टला दुसऱ्या कॉन्ट्रॅक्टला कॉल करण्याची परवानगी देतो, तर प्रत्यक्ष कोडची अंमलबजावणी कॉलिंग कॉन्ट्रॅक्टच्या संदर्भात होते. प्रॉक्सी पॅटर्नमध्ये `delegatecall` वापरण्याचा एक परिणाम म्हणजे प्रॉक्सी कॉन्ट्रॅक्ट त्याच्या स्टोरेजमध्ये वाचतो आणि लिहितो आणि लॉजिक कॉन्ट्रॅक्टमध्ये साठवलेला तर्क कार्यान्वित करतो, जसे की तो अंतर्गत फंक्शनला कॉल करत आहे.

[Solidity माहिती](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries) वरून:

> _मेसेज कॉलचा एक विशेष प्रकार आहे, ज्याला **delegatecall** म्हणतात, जो मेसेज कॉलसारखाच आहे, याशिवाय की लक्ष्य पत्त्यावरील कोड कॉलिंग कॉन्ट्रॅक्टच्या संदर्भात (म्हणजे, पत्त्यावर) कार्यान्वित होतो आणि `msg.sender` व `msg.value` त्यांची मूल्ये बदलत नाहीत._ _याचा अर्थ असा की एक कॉन्ट्रॅक्ट रनटाइमवेळी वेगळ्या पत्त्यावरून कोड डायनॅमिकली लोड करू शकतो. स्टोरेज, वर्तमान पत्ता आणि शिल्लक अजूनही कॉलिंग कॉन्ट्रॅक्टचा संदर्भ घेतात, फक्त कोड कॉल केलेल्या पत्त्यावरून घेतला जातो._

प्रॉक्सी कॉन्ट्रॅक्टला `delegatecall` कसे चालवायचे हे माहित असते, जेव्हा एखादा वापरकर्ता फंक्शनला कॉल करतो, कारण त्यात `fallback` फंक्शन तयार केलेले असते. Solidity प्रोग्रामिंगमध्ये, [फॉलबॅक फंक्शन](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function) तेव्हा कार्यान्वित होते जेव्हा फंक्शन कॉल कॉन्ट्रॅक्टमध्ये निर्दिष्ट केलेल्या फंक्शन्सशी जुळत नाही.

प्रॉक्सी पॅटर्न कार्यरत करण्यासाठी एक कस्टम फॉलबॅक फंक्शन लिहिणे आवश्यक आहे, जे हे निर्दिष्ट करते की प्रॉक्सी कॉन्ट्रॅक्टने समर्थन न करणाऱ्या फंक्शन कॉल्सना कसे हाताळावे. या प्रकरणात, प्रॉक्सीचे फॉलबॅक फंक्शन delegatecall सुरू करण्यासाठी आणि वापरकर्त्याची विनंती सध्याच्या लॉजिक कॉन्ट्रॅक्ट अंमलबजावणीकडे पुन्हा मार्गस्थ करण्यासाठी प्रोग्राम केलेले असते.

प्रॉक्सी कॉन्ट्रॅक्ट डीफॉल्टनुसार अपरिवर्तनीय असतो, परंतु अपडेटेड व्यवसाय तर्कासह नवीन लॉजिक कॉन्ट्रॅक्ट तयार केले जाऊ शकतात. त्यानंतर अपग्रेड करणे म्हणजे प्रॉक्सी कॉन्ट्रॅक्टमध्ये संदर्भित लॉजिक कॉन्ट्रॅक्टचा पत्ता बदलणे.

प्रॉक्सी कॉन्ट्रॅक्टला नवीन लॉजिक कॉन्ट्रॅक्टकडे निर्देशित करून, वापरकर्ते प्रॉक्सी कॉन्ट्रॅक्ट फंक्शनला कॉल करतात तेव्हा कार्यान्वित होणारा कोड बदलतो. यामुळे आम्हाला वापरकर्त्यांना नवीन कॉन्ट्रॅक्टशी संवाद साधण्यास न सांगता कॉन्ट्रॅक्टचा तर्क अपग्रेड करता येतो.

प्रॉक्सी पॅटर्न स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्याची एक लोकप्रिय पद्धत आहे कारण ते कॉन्ट्रॅक्ट स्थलांतराशी संबंधित अडचणी दूर करतात. तथापि, प्रॉक्सी पॅटर्न वापरण्यास अधिक गुंतागुंतीचे आहेत आणि जर ते अयोग्यरित्या वापरले गेले तर, [फंक्शन सिलेक्टर क्लॅश](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357) सारखे गंभीर दोष निर्माण करू शकतात.

[प्रॉक्सी पॅटर्नवर अधिक](https://blog.openzeppelin.com/proxy-patterns/).

### अपग्रेड यंत्रणा #4: स्ट्रॅटेजी पॅटर्न {#strategy-pattern}

हे तंत्र [स्ट्रॅटेजी पॅटर्न](https://en.wikipedia.org/wiki/Strategy_pattern) पासून प्रभावित आहे, जे विशिष्ट वैशिष्ट्ये लागू करण्यासाठी इतर प्रोग्राम्सशी इंटरफेस करणारे सॉफ्टवेअर प्रोग्राम तयार करण्यास प्रोत्साहित करते. इथेरियम डेव्हलपमेंटमध्ये स्ट्रॅटेजी पॅटर्न लागू करणे म्हणजे इतर कॉन्ट्रॅक्ट्समधून फंक्शन्स कॉल करणारा स्मार्ट कॉन्ट्रॅक्ट तयार करणे.

या प्रकरणात मुख्य कॉन्ट्रॅक्टमध्ये मुख्य व्यवसाय तर्क असतो, परंतु तो विशिष्ट फंक्शन्स कार्यान्वित करण्यासाठी इतर स्मार्ट कॉन्ट्रॅक्ट्स ("सॅटेलाइट कॉन्ट्रॅक्ट्स") शी इंटरफेस करतो. हा मुख्य कॉन्ट्रॅक्ट प्रत्येक सॅटेलाइट कॉन्ट्रॅक्टचा पत्ता देखील संग्रहित करतो आणि सॅटेलाइट कॉन्ट्रॅक्टच्या वेगवेगळ्या अंमलबजावणींमध्ये स्विच करू शकतो.

तुम्ही एक नवीन सॅटेलाइट कॉन्ट्रॅक्ट तयार करू शकता आणि मुख्य कॉन्ट्रॅक्टला नवीन पत्त्यासह कॉन्फिगर करू शकता. यामुळे तुम्हाला स्मार्ट कॉन्ट्रॅक्टसाठी _स्ट्रॅटेजी_ (म्हणजे, नवीन तर्क लागू करणे) बदलता येते.

आधी चर्चा केलेल्या प्रॉक्सी पॅटर्नसारखे असले तरी, स्ट्रॅटेजी पॅटर्न वेगळा आहे कारण मुख्य कॉन्ट्रॅक्ट, ज्याच्याशी वापरकर्ते संवाद साधतात, त्यात व्यवसायाचा तर्क असतो. हा पॅटर्न वापरल्याने तुम्हाला मुख्य पायाभूत सुविधांवर परिणाम न करता स्मार्ट कॉन्ट्रॅक्टमध्ये मर्यादित बदल करण्याची संधी मिळते.

मुख्य तोटा असा आहे की हा पॅटर्न मुख्यतः किरकोळ अपग्रेड्ससाठी उपयुक्त आहे. तसेच, जर मुख्य कॉन्ट्रॅक्टमध्ये तडजोड झाली (उदा. हॅकद्वारे), तर तुम्ही ही अपग्रेड पद्धत वापरू शकत नाही.

### अपग्रेड यंत्रणा #5: डायमंड पॅटर्न {#diamond-pattern}

डायमंड पॅटर्नला प्रॉक्सी पॅटर्नमधील सुधारणा मानले जाऊ शकते. डायमंड पॅटर्न प्रॉक्सी पॅटर्नपेक्षा वेगळे आहेत कारण डायमंड प्रॉक्सी कॉन्ट्रॅक्ट एकापेक्षा जास्त लॉजिक कॉन्ट्रॅक्टकडे फंक्शन कॉल सोपवू शकतो.

डायमंड पॅटर्नमधील लॉजिक कॉन्ट्रॅक्ट्स _फेसिट्स_ म्हणून ओळखले जातात. डायमंड पॅटर्न कार्यरत करण्यासाठी, तुम्हाला प्रॉक्सी कॉन्ट्रॅक्टमध्ये एक मॅपिंग तयार करावे लागेल जे [फंक्शन सिलेक्टर्स](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector) वेगवेगळ्या फेसिट पत्त्यांवर मॅप करेल.

जेव्हा वापरकर्ता फंक्शन कॉल करतो, तेव्हा प्रॉक्सी कॉन्ट्रॅक्ट ते फंक्शन कार्यान्वित करण्यासाठी जबाबदार फेसिट शोधण्यासाठी मॅपिंग तपासतो. मग ते `delegatecall` (फॉलबॅक फंक्शन वापरून) चालवते आणि कॉल योग्य लॉजिक कॉन्ट्रॅक्टकडे पुनर्निर्देशित करते.

डायमंड अपग्रेड पॅटर्नमध्ये पारंपरिक प्रॉक्सी अपग्रेड पॅटर्नपेक्षा काही फायदे आहेत:

1. हे तुम्हाला संपूर्ण कोड न बदलता कॉन्ट्रॅक्टचा एक छोटासा भाग अपग्रेड करण्याची परवानगी देते. अपग्रेडसाठी प्रॉक्सी पॅटर्न वापरताना, किरकोळ अपग्रेडसाठी सुद्धा, संपूर्णपणे नवीन लॉजिक कॉन्ट्रॅक्ट तयार करणे आवश्यक आहे.

2. सर्व स्मार्ट कॉन्ट्रॅक्ट्सना (प्रॉक्सी पॅटर्नमध्ये वापरलेल्या लॉजिक कॉन्ट्रॅक्ट्ससह) 24KB आकाराची मर्यादा असते, जी एक मर्यादा असू शकते - विशेषतः अधिक फंक्शन्स आवश्यक असलेल्या गुंतागुंतीच्या कॉन्ट्रॅक्ट्ससाठी. डायमंड पॅटर्न अनेक लॉजिक कॉन्ट्रॅक्ट्समध्ये फंक्शन्स विभाजित करून ही समस्या सोडवणे सोपे करते.

3. प्रॉक्सी पॅटर्न ऍक्सेस नियंत्रणासाठी कॅच-ऑल दृष्टीकोन स्वीकारतात. अपग्रेड फंक्शन्समध्ये ऍक्सेस असलेली संस्था _संपूर्ण_ कॉन्ट्रॅक्ट बदलू शकते. परंतु डायमंड पॅटर्न एक मॉड्यूलर परवानगी दृष्टीकोन सक्षम करतो, जिथे तुम्ही संस्थांना स्मार्ट कॉन्ट्रॅक्टमधील विशिष्ट फंक्शन्स अपग्रेड करण्यापुरते मर्यादित करू शकता.

[डायमंड पॅटर्नवर अधिक](https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard?s=w).

## स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्याचे फायदे आणि तोटे {#pros-and-cons-of-upgrading-smart-contracts}

| फायदे                                                                                                                                           | बाधक                                                                                                                                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| स्मार्ट कॉन्ट्रॅक्ट अपग्रेडमुळे तैनातीनंतरच्या टप्प्यात शोधलेल्या असुरक्षितता दुरुस्त करणे सोपे होते.                           | स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करणे हे कोड अपरिवर्तनीयतेच्या कल्पनेला नाकारते, ज्याचे विकेंद्रीकरण आणि सुरक्षिततेवर परिणाम होतात.                |
| डेव्हलपर्स विकेंद्रित ऍप्लिकेशन्समध्ये नवीन वैशिष्ट्ये जोडण्यासाठी लॉजिक अपग्रेड्स वापरू शकतात.                                 | वापरकर्त्यांनी डेव्हलपर्सवर विश्वास ठेवला पाहिजे की ते स्मार्ट कॉन्ट्रॅक्टमध्ये अनियंत्रितपणे बदल करणार नाहीत.                                |
| स्मार्ट कॉन्ट्रॅक्ट अपग्रेड्स अंतिम वापरकर्त्यांसाठी सुरक्षितता सुधारू शकतात कारण बग्स लवकर दुरुस्त केले जाऊ शकतात.             | स्मार्ट कॉन्ट्रॅक्टमध्ये अपग्रेड कार्यक्षमता प्रोग्रामिंग केल्याने गुंतागुंतीचा आणखी एक स्तर वाढतो आणि गंभीर दोषांची शक्यता वाढते.            |
| कॉन्ट्रॅक्ट अपग्रेड डेव्हलपर्सना वेगवेगळ्या वैशिष्ट्यांसह प्रयोग करण्यासाठी आणि कालांतराने dapps सुधारण्यासाठी अधिक संधी देतात. | स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्याची संधी डेव्हलपर्सना विकासाच्या टप्प्यात योग्य काळजी न घेता प्रकल्प लवकर सुरू करण्यास प्रोत्साहित करू शकते. |
|                                                                                                                                                 | स्मार्ट कॉन्ट्रॅक्टमधील असुरक्षित ऍक्सेस नियंत्रण किंवा केंद्रीकरणामुळे दुर्भावनापूर्ण व्यक्तींना अनधिकृत अपग्रेड करणे सोपे होऊ शकते.         |

## स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्यासाठी विचार करण्याच्या गोष्टी {#considerations-for-upgrading-smart-contracts}

1. अनधिकृत स्मार्ट कॉन्ट्रॅक्ट अपग्रेड्सना प्रतिबंध करण्यासाठी सुरक्षित ऍक्सेस नियंत्रण/अधिकृतता यंत्रणा वापरा, विशेषतः प्रॉक्सी पॅटर्न, स्ट्रॅटेजी पॅटर्न किंवा डेटा विभाजन वापरत असल्यास. एक उदाहरण म्हणजे अपग्रेड फंक्शनमध्ये प्रवेश मर्यादित करणे, जेणेकरून केवळ कॉन्ट्रॅक्टचा मालकच ते कॉल करू शकेल.

2. स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करणे ही एक गुंतागुंतीची क्रिया आहे आणि असुरक्षितता टाळण्यासाठी उच्च पातळीवरील काळजी घेणे आवश्यक आहे.

3. अपग्रेड लागू करण्याची प्रक्रिया विकेंद्रित करून विश्वासाची गृहितके कमी करा. संभाव्य धोरणांमध्ये अपग्रेड नियंत्रित करण्यासाठी [मल्टी-सिग वॉलेट कॉन्ट्रॅक्ट](/developers/docs/smart-contracts/#multisig) वापरणे, किंवा अपग्रेड मंजूर करण्यासाठी [DAO चे सदस्य](/dao/) यांना मतदान करणे आवश्यक करणे यांचा समावेश आहे.

4. कॉन्ट्रॅक्ट अपग्रेड करण्यामध्ये समाविष्ट असलेल्या खर्चाबद्दल जागरूक रहा. उदाहरणार्थ, कॉन्ट्रॅक्ट स्थलांतरादरम्यान जुन्या कॉन्ट्रॅक्टमधून नवीन कॉन्ट्रॅक्टमध्ये स्थिती (उदा. वापरकर्त्याची शिल्लक) कॉपी करण्यासाठी एकापेक्षा जास्त व्यवहारांची आवश्यकता असू शकते, म्हणजे अधिक गॅस शुल्क.

5. वापरकर्त्यांचे संरक्षण करण्यासाठी **टाइमलॉक** लागू करण्याचा विचार करा. टाइमलॉक म्हणजे सिस्टममधील बदलांवर लागू होणारा विलंब. अपग्रेड नियंत्रित करण्यासाठी टाइमलॉक मल्टी-सिग गव्हर्नन्स प्रणालीसह एकत्र केले जाऊ शकतात: जर प्रस्तावित कृती आवश्यक मान्यता मर्यादेपर्यंत पोहोचली, तर ती पूर्वनिर्धारित विलंब कालावधी संपेपर्यंत कार्यान्वित होत नाही.

जर वापरकर्ते प्रस्तावित बदलाशी (उदा. लॉजिक अपग्रेड किंवा नवीन शुल्क योजना) असहमत असतील तर टाइमलॉक त्यांना सिस्टममधून बाहेर पडण्यासाठी थोडा वेळ देतात. टाइमलॉकशिवाय, वापरकर्त्यांना डेव्हलपर्सवर विश्वास ठेवावा लागतो की ते पूर्वसूचना न देता स्मार्ट कॉन्ट्रॅक्टमध्ये अनियंत्रित बदल करणार नाहीत. येथे तोटा असा आहे की टाइमलॉक असुरक्षितता त्वरीत पॅच करण्याची क्षमता प्रतिबंधित करतात.

## संसाधने {#resources}

**OpenZeppelin अपग्रेड्स प्लगइन - _अपग्रेड करण्यायोग्य स्मार्ट कॉन्ट्रॅक्ट्स तैनात आणि सुरक्षित करण्यासाठी साधनांचा संच._**

- [GitHub](https://github.com/OpenZeppelin/openzeppelin-upgrades)
- [माहिती](https://docs.openzeppelin.com/upgrades)

## ट्यूटोरियल्स {#tutorials}

- [तुमचे स्मार्ट कॉन्ट्रॅक्ट्स अपग्रेड करणे | YouTube ट्युटोरियल](https://www.youtube.com/watch?v=bdXJmWajZRY) पॅट्रिक कॉलिन्स द्वारे
- [इथेरियम स्मार्ट कॉन्ट्रॅक्ट मायग्रेशन ट्युटोरियल](https://medium.com/coinmonks/ethereum-smart-contract-migration-13f6f12539bd) ऑस्टिन ग्रिफिथ द्वारे
- [स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्यासाठी UUPS प्रॉक्सी पॅटर्न वापरणे](https://blog.logrocket.com/author/praneshas/) प्रणेश ए. एस. द्वारे
- [Web3 ट्युटोरियल: OpenZeppelin वापरून अपग्रेड करण्यायोग्य स्मार्ट कॉन्ट्रॅक्ट (प्रॉक्सी) लिहा](https://dev.to/yakult/tutorial-write-upgradeable-smart-contract-proxy-contract-with-openzeppelin-1916) फॅंगजुन.ईथ द्वारे

## पुढील वाचन {#further-reading}

- [स्मार्ट कॉन्ट्रॅक्ट अपग्रेडची स्थिती](https://blog.openzeppelin.com/the-state-of-smart-contract-upgrades/) सँटियागो पॅलाडिनो द्वारे
- [सॉलिडिटी स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करण्याचे अनेक मार्ग](https://cryptomarketpool.com/multiple-ways-to-upgrade-a-solidity-smart-contract/) - क्रिप्टो मार्केट पूल ब्लॉग
- [शिका: स्मार्ट कॉन्ट्रॅक्ट अपग्रेड करणे](https://docs.openzeppelin.com/learn/upgrading-smart-contracts) - OpenZeppelin Docs
- [सॉलिडिटी कॉन्ट्रॅक्ट्सच्या अपग्रेडिबिलिटीसाठी प्रॉक्सी पॅटर्न: पारदर्शक विरुद्ध UUPS प्रॉक्सी](https://mirror.xyz/0xB38709B8198d147cc9Ff9C133838a044d78B064B/M7oTptQkBGXxox-tk9VJjL66E1V8BUF0GF79MMK4YG0) नवीन साहू द्वारे
- [डायमंड अपग्रेड्स कसे काम करतात](https://dev.to/mudgen/how-diamond-upgrades-work-417j) निक मज द्वारे
