---
title: 零知识卷叠
description: 零知识卷叠简介 — 以太坊社区使用的一种扩容解决方案。
lang: zh
---

零知识卷叠（ZK 卷叠）是二层网络[扩容解决方案](/developers/docs/scaling/)，通过将计算和状态存储转移到链下进行提高了以太坊主网吞吐量。 零知识卷叠可以处理一个批次中的数千笔交易，但仅将一部分最少量的摘要数据发布到主网。 这些摘要数据确定了应对以太坊状态进行的变化以及一些证明这些变化正确性的加密证明。

## 前提条件 {#prerequisites}

你应该已经阅读并理解关于[以太坊扩容](/developers/docs/scaling/)和[二层网络](/layer-2)的页面。

## 什么是零知识卷叠？ {#what-are-zk-rollups}

**零知识卷叠（ZK 卷叠）**将在链下执行的交易打包（或“卷叠”）成批。 链下计算减少了必须发布到区块链的数据量。 零知识卷叠运营商提交用于表示批次中所有交易的变化摘要，而不是单独发送每笔交易。 他们还生成[有效性证明](/glossary/#validity-proof)来证明状态变化的正确性。

零知识卷叠的状态由部署在以太坊网络上的智能合约维护。 为了更新这个状态，零知识卷叠节点必须提交一个有效性证明进行验证。 如前所述，有效性证明是一种加密保证，即卷叠提出的状态变化确实是执行给定批次交易的结果。 这意味着零知识卷叠只需提供有效性证明即可在以太坊上最终确定交易，而不是像[乐观卷叠](/developers/docs/scaling/optimistic-rollups/)那样将所有交易数据发布到链上。

将资金从零知识卷叠转移到以太坊时不会出现延迟，因为一旦零知识卷叠合约验证了有效性证明后，就会执行退出交易。 相反，从乐观卷叠中提取资金会产生延迟，让任何人都可以使用[欺诈证明](/glossary/#fraud-proof)来挑战退出交易。

零知识卷叠将交易作为 `calldata` 写入以太坊。 对智能合约函数进行的外部调用中包含的数据就存储在 `calldata` 中。 `calldata` 中的信息发布在区块链上，让任何人都可以独立重建该卷叠的状态。 零知识卷叠使用压缩技术减少交易数据 — 例如，帐户用索引而不是地址表示，这样可以节省 28 字节的数据。 链上数据发布占据卷叠的大部分成本，因此数据压缩可以降低用户的费用。

## 零知识卷叠如何与以太坊交互？ {#zk-rollups-and-ethereum}

零知识卷叠链是一种在以太坊区块链上运行并由链上以太坊智能合约管理的链下协议。 零知识卷叠在主网之外执行交易，但会定期将链下交易批次提交到链上卷叠合约。 与以太坊区块链非常相像，这种交易记录是不可更改的并形成了零知识卷叠链。

零知识卷叠的核心架构由以下组件构成：

1. **链上合约**：如前所述，零知识卷叠协议由运行在以太坊上的智能合约控制。 其中包括存储卷叠区块、跟踪存款并监控状态更新的主合约。 另一个上链上合约（验证者合约），它验证区块生产者提交的零知识证明。 因此，以太坊充当零知识卷叠的基础层或“一层网络”。

2. **链下虚拟机 (VM)**：虽然零知识卷叠协议存在于以太坊上，但交易执行和状态存储却在独立于[以太坊虚拟机](/developers/docs/evm/)的单独虚拟机中进行。 这种链下虚拟机是零知识卷叠上交易的执行环境，并作为零知识卷叠协议的第二层或“二层网络”。 在以太坊主网上验证的有效性证明保证链下虚拟机中状态转换的正确性。

零知识卷叠是“混合扩容解决方案” — 独立运行但从以太坊获得安全性的链下协议。 具体来说，以太坊网络强制执行零知识卷叠上状态更新的有效性，并保证每次更新卷叠状态时后台数据的可用性。 因此，零知识卷叠比纯链下扩容解决方案安全得多，例如负责其安全属性的[侧链](/developers/docs/scaling/sidechains/)，或 [Validium](/developers/docs/scaling/validium/)，它也使用有效性证明在以太坊上验证交易但将交易数据存储在别处。

零知识卷叠依赖以太坊主协议获得：

### 数据可用性 {#data-availability}

零知识卷叠将链下处理的每笔交易的状态数据发布到以太坊。 通过这些数据，个人或企业就可以复制卷叠的状态并自行验证链。 以太坊将这些数据作为 `calldata` 提供给网络的所有参与者。

零知识卷叠不需要在链上发布过多交易数据，因为有效性证明已经验证了状态转换的真实性。 尽管如此，在链上存储数据仍然很重要，因为这样便可以无需许可对二层网络链的状态进行独立验证，从而让任何人可以提交批量交易并阻止恶意运营商审查或冻结链。

用户需要在链上与卷叠交互。 如果无法访问状态数据，用户将无法查询帐户余额或发起依赖状态信息的交易（例如提款）。

### 交易确定性 {#transaction-finality}

以太坊充当零知识卷叠的结算层：只有当一层网络合约接受有效性证明时，二层网络交易才会最终确定。 这就化解了恶意运营商破坏链的风险（例如，窃取卷叠资金），因为每笔交易都必须在主网上得到批准。 此外，以太坊保证一旦在一层网络上最终确定后，用户操作就不能被逆转。

### 抗审查 {#censorship-resistance}

大多数零知识卷叠使用“超级节点”（运营商）来执行交易、生产批次并将区块提交到一层网络。 尽管这样做保证了效率，但也增加了审查风险：恶意零知识卷叠运营商可以通过拒绝将用户的交易添加到批次中来审查用户。

作为一项安全措施，零知识卷叠允许用户在认为自己受到运营商审查时直接向主网上的卷叠合约提交交易。 这允许用户强制从零知识卷叠退出到以太坊，而无需依赖运营商的许可。

## 零知识卷叠如何运作？ {#how-do-zk-rollups-work}

### 交易 {#transactions}

零知识卷叠中的用户签署交易，提交给二层网络运营商进行处理并添加到下一批次中。 在某些情况下，运营商是一个中心化实体（即排序者），它执行交易，将交易聚合成批次，然后提交到一层网络。 该系统中的排序者是唯一获得允许可生成二层网络区块并将卷叠交易添加到零知识卷叠合约的实体。

其他零知识卷叠可以通过一组[权益证明](/developers/docs/consensus-mechanisms/pos/)验证者轮换运营商角色。 潜在的运营商将资金存入卷叠合约，每份质押的额度会影响质押者被选中生产下一批次卷叠的机会。 如果运营商实施恶意行为，他们的质押会被罚没，这会激励他们发布有效的区块。

#### 零知识卷叠如何在以太坊上发布交易数据 {#how-zk-rollups-publish-transaction-data-on-ethereum}

如前所述，交易数据作为 `calldata` 发布到以太坊上。 `calldata` 是智能合约中的数据区，用于将参数传递给函数，其行为类似于[内存](/developers/docs/smart-contracts/anatomy/#memory)。 虽然 `calldata` 不存储到以太坊状态中，但它作为以太坊链[历史日志](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html?highlight=memory#logs)的一部分一直存在于链上。 `calldata` 不会影响以太坊的状态，使其成为一种在链上存储数据的实惠方式。

`calldata` 关键字通常标识交易调用的智能合约方法，并以任意字节序列的形式保存该方法的输入。 零知识卷叠使用 `calldata` 将压缩的交易数据发布到链上；卷叠运营商只需通过调用卷叠合约中所需的函数来添加一个新批次，并将压缩数据作为函数参数传递。 这有助于降低用户的成本，因为大部分卷叠费用用于在链上存储交易数据。

### 状态承诺 {#state-commitments}

零知识卷叠的状态包括二层网络帐户和余额，用[默克尔树](/whitepaper/#merkle-trees)表示。 默克尔树根（默克尔根）的加密哈希存储在链上合约中，让卷叠协议可以跟踪零知识卷叠状态的变化。

在执行一组新交易后，卷叠交易转换到新状态。 发起状态转换的运营商需要计算一个新的状态根并提交到链上合约。 如果与批次相关的有效性证明通过验证者合约的身份验证，则新默克尔根将成为零知识卷叠的规范状态根。

除了计算状态根之外，零知识卷叠运营商还创建了一个批处理根 — 包含批处理中所有交易的默克尔树的根。 当提交新批次时，卷叠合约存储批次根，允许用户证明交易（例如，提款请求）包含在批次中。 用户必须提供交易详情、批次根和显示包含路径的 [Merkle 证明](/developers/tutorials/merkle-proofs-for-offline-data-integrity/)。

### 有效性证明 {#validity-proofs}

零知识卷叠运营商提交到一层网络合约的新状态根是卷叠状态更新的结果。 假设 Alice 向 Bob 发送了 10 个代币，运营商只需将 Alice 的余额减少 10 并将 Bob 的余额增加 10。 然后运营商对更新后的帐户数据进行哈希处理，重建卷叠的默克尔树，并将新默克尔根提交到链上合约。

但是，在运营商证明新默克尔根是由卷叠状态的正确更新产生之前，卷叠合约不会自动接受提出的状态承诺。 零知识卷叠运营商通过生成有效性证明来做到这一点，有效性证明是一种简单的加密承诺，用于验证批量交易的正确性。

有效性证明允许参与方在不透露陈述本身的情况下证明陈述的正确性 — 因此，它们又称为零知识证明。 零知识卷叠使用有效性证明确认链下状态转换的正确性，而无需在以太坊上重新执行交易。 这些证明可以有 [ZK-SNARK](https://arxiv.org/abs/2202.06877)（零知识简洁非交互式知识论证）或 [ZK-STARK](https://eprint.iacr.org/2018/046)（零知识可扩容透明知识论证）两种形式。

SNARK 和 STARK 都有助于证明零知识卷叠中链下计算的完整性，尽管每种证明类型都有不同的特征。

**零知识简洁非交互式知识论证 (ZK-SNARK)**

为了让 ZK-SNARK 协议起作用，必须创建公共参考字符串 (CRS)，公共参考字符串提供公共参数来证明和验证有效性证明。 证明系统的安全性取决于公共参考字符串设置；如果用于创建公共参数的信息落入恶意行为者手中，他们可能会生成虚假的有效性证明。

一些零知识卷叠尝试通过采用[多方计算仪式 (MPC)](https://zkproof.org/2021/06/30/setup-ceremonies/amp/) 解决这一问题，即让受信任个人为 ZK-SNARK 线路生成公共参数。 每一方都提供一些随机性（称为“有毒废物”）来构建公共参考字符串，而且必须立即将其销毁。

使用受信任的设置，因为它们提高了公共参考字符串设置的安全性。 只要诚实参与者销毁其输入，ZK-SNARK 系统的安全性就得到了保证。 这种方法仍然需要信任相关人员删除他们抽样的随机性，并且不会破坏系统的安全保障。

撇开信任假设不谈，ZK-SNARK 因其更小的证明大小和恒定时间验证而广受欢迎。 由于运行零知识卷叠的较大一部分成本用于一层网络上的证明验证，因此二层网络使用 ZK-SNARK 生成可在主网上快速、经济实惠地验证的证明。

**零知识可扩容透明知识论证 (ZK-STARK)**

与 ZK-SNARK 一样，ZK-STARK 证明链下计算的有效性而不会透露输入。 然而，ZK-STARK 被认为是对 ZK-SNARK 的改进，因为前者具有可扩展性和透明性。

ZK-STARK 是“透明的”，因为无需受信任的公共参考字符串 (CRS) 设置，它们就可以工作。 然而，ZK-STARK 依靠可公开验证的随机性来设置用于生成和验证证明的参数。

ZK-STARK 还提供了更强的可扩展性，因为证明和验证有效性证明所需的时间相对于底层计算的复杂性呈_准线性_增加。 对于 ZK-SNARK，证明和验证时间相对于底层计算的规模呈_线性_增加。 这意味着在涉及大型数据集时，ZK-STARK 比 ZK-SNARK 的证明和验证时间更少，这使得前者适用于大批量应用。

ZK-STARK 对于量子计算机也是安全的，而 ZK-SNARK 中使用的椭圆曲线密码学 (ECC) 被广泛认为容易受到量子计算攻击。 ZK-STARK 的缺点是它们产生的证明尺寸更大，在以太坊上验证的成本更高。

#### 有效性证明如何在零知识卷叠中运作？ {#validity-proofs-in-zk-rollups}

##### 证明生成

在接受交易之前，运营商将进行常规检查。 包括确认：

- 发送者和接收者帐户是状态树的一部分。
- 发送者有足够的资金处理交易。
- 交易是正确的并与卷叠中发送者的公钥匹配。
- 发送者的随机数是正确的，等等。

在零知识卷叠节点有足够的交易后，该节点将这些交易聚合成一个批次并为证明线路编译输入，从而编译成简单的零知识证明。 其中包括：

- 一个包含批次中所有交易的默克尔树根。
- 用于证明交易包含在批次中的默克尔交易证明。
- 交易中每个发送者-接收者对的默克尔证明，用于证明这些帐户是卷叠状态树的一部分。
- 一组中间状态根，通过在应用每笔交易的状态更新（即减少发送方帐户并增加接收方帐户）之后更新状态根获得。

证明线路通过“遍历”每笔交易并执行和运营商执行的相同检查来计算有效性证明，之后再处理交易。 首先，它使用提供的默克尔证明来验证发送者的帐户是现有状态根的一部分。 然后它减少发送者的余额，增加他们的随机数，对更新的帐户数据进行哈希处理，并将其与默克尔证明结合以生成一个新的默克尔根。

这个默克尔根反映出零知识卷叠状态的唯一变化：发送者余额和随机数的变化。 这是可能出现的，因为用来证明帐户存在的默克尔证明用于产生新的状态根。

证明线路对接收者帐户执行相同过程。 它（使用默克尔证明）检查接收者帐户是否存在于中间状态根下，增加他们的余额，对帐户数据重新进行哈希处理，并将其与默克尔证明结合以生成新的状态根。

该过程对每笔交易重复；每次“循环”均会通过更新发送者帐户创建一个新的状态根，并通过更新接收者帐户随后创建一个新状态根。 如前所述，状态根的每次更新都代表卷叠状态树变化的一部分。

零知识证明线路迭代整个交易批次，并在执行最后一个交易后验证导致最终状态根的更新顺序。 最后计算的默克尔根成为零知识卷叠的最新规范状态根。

##### 证明验证

在证明线路验证状态更新的正确性后，二层网络运营商将计算出的有效性证明提交给一层网络上的验证者合约。 合约的验证线路验证证明的有效性，并检查证明中包含的公共输入：

- **前状态根**：零知识卷叠的旧状态根（在执行交易批次之前），表示二层网络链的前一个已知有效状态。

- **后状态根**：零知识卷叠的新状态根（执行交易批次之后），表示二层网络链的最新状态。 后状态根是在证明线路中应用状态更新后产生的最终根。

- **批处理根**：批次的默克尔根，通过_默克尔化_批次中的交易并对树根进行哈希处理得到。

- **交易输入**：与在已提交批次中执行的交易相关的数据。

如果证明符合线路条件（即证明是有效的），则意味着存在一系列有效交易，这些交易将卷叠从先前状态（由前状态根提供加密指纹）转换到新状态（由后状态根提供加密指纹）。 如果前状态根与存储在卷叠合约中的根匹配，并且证明是有效的，则卷叠合约从证明中获取后状态根并更新其状态树以反映卷叠的状态变化。

### 进入和退出 {#entries-and-exits}

用户通过向部署在一层网络链上的卷叠合约中存入代币来进入零知识卷叠。 此交易已排队，因为只有运营商才能将交易提交到卷叠合约。

如果待处理的存款队列开始填满，零知识卷叠运营商将接受存款交易并将其提交到卷叠合约。 一旦用户的资金存入卷叠后，他们就可以通过将交易发送给运营商进行处理来开始交易。 用户可以验证他们在卷叠上的余额，方法是对其帐户进行哈希处理，将哈希值发送到卷叠合约，并提供对照当前状态根进行验证的默克尔证明。

从零知识卷叠撤回到一层网络很简单。 用户通过将其卷叠上的资产发送到指定帐户进行销毁来发起退出交易。 如果运营商将该交易添加到下一批次中，用户可以向链上合约提交提款请求。 该提款请求将包括以下内容：

- 默克尔证明，证明用户的交易添加到交易批次中的销毁帐户

- 交易数据

- 批处理根

- 一层网络地址，用于接收存入资金

卷叠合约对交易数据进行哈希处理，检查批处理根是否存在，并使用默克尔证明检查交易哈希是否是批处理根的一部分。 之后，合约执行退出交易并将资金发送到用户选择的一层网络上的地址。

## 零知识卷叠和以太坊虚拟机的兼容性 {#zk-rollups-and-evm-compatibility}

与乐观卷叠不同，零知识卷叠不直接与[以太坊虚拟机 (EVM)](/developers/docs/evm/) 兼容。 在线路中证明通用以太坊虚拟机计算比证明简单计算（如前面描述的代币转账），更加困难且更加耗费资源。

然而，[零知识技术的进步](https://hackmd.io/@yezhang/S1_KMMbGt#Why-possible-now)重新点燃了将以太坊虚拟机计算封装在零知识证明中的兴趣。 这些努力旨在创建一个零知识以太坊虚拟机 (zkEVM) 实现，它可以高效验证程序执行的正确性。 零知识以太坊虚拟机重新创建在线路中进行证明/验证的现有以太坊虚拟机操作码，从而允许执行智能合约。

与以太坊虚拟机一样，零知识以太坊虚拟机在对某些输入执行计算之后在状态之间转换。 差别在于零知识以太坊虚拟机还创建了零知识证明，验证程序执行中每一步的正确性。 有效性证明可以验证影响虚拟机状态（内存、堆栈、存储）和计算本身的操作的正确性（即，操作是否调用了正确的操作码并正确执行它们？）。

与以太坊虚拟机兼容的零知识卷叠的引入，有望帮助开发者利用零知识证明的可扩展性和安全保障。 更重要的是，与原生以太坊基础设施的兼容性意味着，开发者可以使用熟悉（且经过实战考验）的工具和语言构建零知识友好的去中心化应用程序。

## 零知识卷叠的费用如何运作？ {#how-do-zk-rollup-fees-work}

用户为零知识卷叠上的交易支付多少费用取决于燃料费用，就像在以太坊主网上一样。 但是，燃料费用在二层网络上的运作方式不同，并受以下费用影响：

1. **状态写入**：写入以太坊状态（即在以太坊区块链上提交交易）有固定费用。 零知识卷叠通过批量处理交易并将固定费用分摊给多名用户来降低该费用。

2. **数据发布**：零知识卷叠将每笔交易的状态数据作为 `calldata` 发布到以太坊。 `calldata` 费用目前由 [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) 监管，它规定对于 `calldata` 的非零字节和零字节费用分别为 16 单位和 4 单位燃料。 每笔交易支付的费用受需要在链上为其发布多少 `calldata` 的影响。

3. **二层网络运营商费用**：这是支付给卷叠运营商的金额，用于补偿处理交易产生的计算费用，很像以太坊上的矿工费用一样。

4. **证明生成和验证**：零知识卷叠运营商必须为交易批次生成有效性证明，该操作耗费大量资源。 在主网上验证零知识证明也需要花费燃料（约 500,000 单位燃料）。

除了批量处理交易之外，零知识卷叠通过压缩交易数据降低用户的费用。 你可以[查看实时概览](https://l2fees.info/)，了解使用以太坊零知识卷叠的费用。

## 零知识卷叠如何扩展以太坊？ {#scaling-ethereum-with-zk-rollups}

### 交易数据压缩 {#transaction-data-compression}

零知识卷叠通过在链下计算来提升以太坊基础层的吞吐量，但真正提升扩容的是压缩交易数据。 以太坊的[区块大小](/developers/docs/blocks/#block-size)限制了每个区块可以保存的数据，进而限制了每个区块处理的交易数量。 通过压缩交易相关数据，零知识卷叠显著增加了每个区块处理的交易数量。

零知识卷叠能够比乐观卷叠更好地压缩交易数据，因为它们不必发布验证每笔交易所需的所有数据。 它们只需要发布在卷叠上重建帐户和余额的最新状态所需的最少量数据。

### 递归证明 {#recursive-proofs}

零知识证明的一个优点是证明可以验证其他证明。 例如，单个 ZK-SNARK 可以验证其他 ZK-SNARK。 这种“证明的证明”被称为递归证明，它们显著提高了零知识卷叠的吞吐量。

目前，有效性证明是逐块生成的，并提交给一层网络合约进行验证。 然而，验证单个区块证明限制了零知识卷叠可以实现的吞吐量，因为当运营商提交证明时只能最终确定一个区块。

然而，递归证明可以用一个有效性证明最终确定多个区块。 这是因为证明线路以递归方式聚合多个区块证明，直到创建一个最终证明。 二层网络运营商提交该递归证明，如果合约接受它，所有相关区块将立即最终确定。 使用递归证明，可以在以太坊上每隔一段时间最终确定的零知识卷叠交易的数量会增加。

### 零知识卷叠的优缺点 {#zk-rollups-pros-and-cons}

| 优点                                                                                                              | 缺点                                                  |
| --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- |
| 有效性证明确保链下交易的正确性，并阻止运营商执行无效的状态转换。                                                                                | 与计算和验证有效性证明相关的成本很高，并且可能会增加卷叠用户的费用。                  |
| 一旦在一层网络上验证了有效性证明，在批准状态更新后，交易的最终确定更快。                                                                            | 由于零知识技术的复杂性，构建与以太坊虚拟机兼容的零知识卷叠很困难。                   |
| 依靠去信任加密机制来保证安全性，而不是像[乐观卷叠](/developers/docs/scaling/optimistic-rollups/#optimistic-pros-and-cons)那样依靠受激励参与者的诚信。 | 生成有效性证明需要专用硬件，这可能会鼓励一些参与方对链进行集中控制。                  |
| 将恢复链下状态所需的数据存储在一层网络上，从而保证安全性、抗审查性和去中心化。                                                                         | 中心化运营商（排序者）可以影响交易的顺序。                               |
| 用户可以从更高的资本效率中受益，并且可以毫无拖延地从二层网络中提取资金。                                                                            | 硬件要求可能会减少能够强制推进链状态的参与者数量，从而增加恶意运营商冻结卷叠状态和审查用户的风险。   |
| 不依赖于可用性假设，用户不必验证链来保护他们的资金。                                                                                      | 一些证明系统（例如 ZK-SNARK）需要受信任的设置，如果处理不当，可能会危及零知识卷叠的安全模型。 |
| 更好的数据压缩有助于降低在以太坊上发布 `calldata` 的成本，并最大限度地减少用户的卷叠费用。                                                             |                                                     |

### 零知识卷叠的直观解释 {#zk-video}

观看 Finematics 解说零知识卷叠：

<YouTube id="7pWxCklcNsU" start="406" />

### 使用零知识卷叠 {#use-zk-rollups}

零知识卷叠有多种实现方式，你可以将其整合到自己的去中心化应用程序中：

<RollupProductDevDoc rollupType="zk" />

## 零知识以太坊虚拟机上有哪些项目？ {#zkevm-projects}

零知识以太坊虚拟机上运行的项目包括：

- **[Applied ZKP](https://github.com/privacy-scaling-explorations/zkevm-specs)** - _Applied ZKP 是由以太坊基金会资助的项目，旨在开发与以太坊虚拟机兼容的零知识卷叠以及为以太坊区块生成有效性证明的机制。_

- **[Polygon zkEVM](https://polygon.technology/solutions/polygon-zkevm)** - _是以太坊主网上的去中心化零知识卷叠，它在零知识以太坊虚拟机 (zkEVM) 上运行，以透明的方式执行以太坊交易，包括智能合约与零知识证明验证。_

- **[Scroll](https://scroll.io/blog/zkEVM)** - _Scroll 是 一家致力于为以太坊构建原生零知识以太坊虚拟机二层解决方案的技术驱动型公司。_

- **[Taiko](https://taiko.xyz)** - _Taiko 是一个去中心化、类似以太坊的零知识卷叠（一种[第一类零知识以太坊虚拟机](https://vitalik.eth.limo/general/2022/08/04/zkevm.html)）。_

- **[ZKSync](https://docs.zksync.io/zkevm/)** - _ZkSync Era 是与以太坊虚拟机兼容的零知识卷叠，由 Matter Labs 构建并由它自己的零知识以太坊虚拟机提供支持。_

- **[Starknet](https://starkware.co/starknet/)** - _StarkNet 是以太坊虚拟机兼容的二层网络扩容解决方案，由 StarkWare 构建。_

## 进一步阅读零知识卷叠的相关内容 {#further-reading-on-zk-rollups}

- [什么是零知识卷叠？](https://coinmarketcap.com/alexandria/glossary/zero-knowledge-rollups)
- [什么是零知识卷叠？](https://alchemy.com/blog/zero-knowledge-rollups)
- [STARK（可扩容透明知识论证）和 SNARK（简洁非交互式知识论证）](https://consensys.net/blog/blockchain-explained/zero-knowledge-proofs-starks-vs-snarks/)
- [什么是 zkEVM（零知识以太坊虚拟机）？](https://www.alchemy.com/overviews/zkevm)
- [zkEVM（零知识以太坊虚拟机）简介](https://hackmd.io/@yezhang/S1_KMMbGt)
- [超赞的 zkEVM（零知识以太坊虚拟机）资源](https://github.com/LuozhuZhang/awesome-zkevm)
- [ZK-SNARK（零知识简洁非交互式知识论证）底层技术](https://vitalik.eth.limo/general/2017/02/01/zk_snarks.html)
- [SNARK（简洁非交互式知识论证），怎么可能？](https://vitalik.eth.limo/general/2021/01/26/snarks.html)
