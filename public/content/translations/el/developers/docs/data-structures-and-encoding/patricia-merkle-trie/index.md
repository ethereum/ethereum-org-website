---
title: Merkle Patricia Trie
description: Εισαγωγή στο Merkle Patricia Trie.
lang: el
sidebarDepth: 2
---

Η κατάσταση του Ethereum (το σύνολο όλων των λογαριασμών, υπολοίπων και έξυπνων συμβολαίων) κωδικοποιείται σε μια ειδική έκδοση της δομής δεδομένων που είναι γνωστή γενικά στην επιστήμη υπολογιστών ως Merkle Tree. Αυτή η δομή είναι χρήσιμη για πολλές εφαρμογές στην κρυπτογραφία επειδή δημιουργεί μια αποδεδειγμένη σχέση μεταξύ όλων των μεμονωμένων κομματιών δεδομένων που περιπλέκονται στο δέντρο, με αποτέλεσμα μια ενιαία τιμή **ρίζας** που μπορεί να χρησιμοποιηθεί για να αποδειχθούν πράγματα για τα δεδομένα.

Η δομή δεδομένων του Ethereum είναι ένα 'τροποποιημένο Merkle-Patricia Trie', που ονομάζεται έτσι επειδή δανείζεται ορισμένα χαρακτηριστικά από το PATRICIA (ο πρακτικός αλγόριθμος για την ανάκτηση πληροφοριών κωδικοποιημένων αλφαριθμητικά) και επειδή έχει σχεδιαστεί για αποτελεσματική ανάκτηση δεδομένων **trie** που αποτελούν την κατάσταση Ethereum.

A Merkle-Patricia trie is deterministic and cryptographically verifiable: The only way to generate a state root is by computing it from each individual piece of the state, and two states that are identical can be easily proven so by comparing the root hash and the hashes that led to it (_a Merkle proof_). Αντίθετα, δεν υπάρχει τρόπος να δημιουργηθούν δύο διαφορετικές καταστάσεις με το ίδιο hash ρίζας, και οποιαδήποτε προσπάθεια τροποποίησης της κατάστασης με διαφορετικές τιμές θα οδηγήσει σε διαφορετικό hash ρίζας κατάστασης. Θεωρητικά, αυτή η δομή παρέχει το 'ιερό δισκοπότηρο' της απόδοσης `O(log(n))` για εισαγωγές, αναζητήσεις και διαγραφές.

Στο κοντινό μέλλον, το Ethereum σχεδιάζει να μεταφερθεί σε μια δομή [Verkle Tree](/roadmap/verkle-trees), η οποία θα ανοίξει πολλές νέες δυνατότητες για μελλοντικές βελτιώσεις του πρωτοκόλλου.

## Προαπαιτούμενα {#prerequisites}

Για να κατανοήσετε καλύτερα αυτή τη σελίδα, θα ήταν χρήσιμο να έχετε βασικές γνώσεις σχετικά με τα [hash](https://en.wikipedia.org/wiki/Hash_function), τα [δέντρα Merkle](https://en.wikipedia.org/wiki/Merkle_tree), τα [tries](https://en.wikipedia.org/wiki/Trie) και τη [σειριοποίηση](https://en.wikipedia.org/wiki/Serialization). Αυτό το άρθρο ξεκινά με μια περιγραφή ενός βασικού [δέντρου radix](https://en.wikipedia.org/wiki/Radix_tree), και στη συνέχεια εισάγει σταδιακά τις τροποποιήσεις που απαιτούνται για την πιο βελτιστοποιημένη δομή δεδομένων του Ethereum.

## Βασικά δέντρα radix {#basic-radix-tries}

Σε ένα βασικό δέντρο radix, κάθε κόμβος φαίνεται ως εξής:

```
    [i_0, i_1 ... i_n, value]
```

Όπου `i_0 ... i_n` αντιπροσωπεύουν τα σύμβολα του αλφαβήτου (συχνά δυαδικά ή δεκαεξαδικά), η `τιμή` είναι η τελική τιμή στον κόμβο και οι τιμές στις θέσεις `i_0, i_1 ... i_n` είναι είτε `NULL` είτε δείκτες (στην περίπτωσή μας, hashes) άλλων κόμβων. Αυτό σχηματίζει ένα βασικό αποθηκευτικό χώρο `(κλειδί, τιμή)`.

Ας υποθέσουμε ότι θέλετε να χρησιμοποιήσετε μια δομή δεδομένων δέντρου radix για την επιμονή μιας σειράς ζευγών κλειδιού-τιμής. Για να βρείτε την τιμή που αντιστοιχίζεται αυτήν τη στιγμή στο κλειδί `dog` στο trie, θα μετατρέπατε πρώτα το `dog` σε γράμματα του αλφαβήτου (δίδοντας `64 6f 67)` και στη συνέχεια θα κατεβαίνατε το trie ακολουθώντας αυτό το μονοπάτι μέχρι να βρείτε την τιμή. Αυτό σημαίνει ότι ξεκινάτε αναζητώντας τον hash της ρίζας σε μια επίπεδη βάση δεδομένων κλειδιού/τιμής για να βρείτε τον κόμβο ρίζας του trie. Αντιπροσωπεύεται ως ένας πίνακας κλειδιών που δείχνουν σε άλλους κόμβους. Θα χρησιμοποιούσατε την τιμή στο δείκτη `6` ως κλειδί και θα την αναζητούσατε στην επίπεδη βάση δεδομένων κλειδιού/τιμής για να πάρετε τον κόμβο ένα επίπεδο κάτω. Στη συνέχεια επιλέγετε το δείκτη `4` για να αναζητήσετε την επόμενη τιμή, στη συνέχεια επιλέγετε το δείκτη `6`, και ούτω καθεξής, μέχρι, αφού ακολουθήσετε το μονοπάτι: `root -> 6 -> 4 -> 6 -> 15 -> 6 -> 7`, θα αναζητούσατε την τιμή του κόμβου και θα επιστρέφατε το αποτέλεσμα.

Υπάρχει μια διαφορά μεταξύ της αναζήτησης κάτι στο 'trie' και της υποκείμενης επίπεδης βάσης δεδομένων κλειδιού/τιμής 'DB'. Και τα δύο ορίζουν διατάξεις κλειδιού/τιμής, αλλά η υποκείμενη DB μπορεί να κάνει μια παραδοσιακή αναζήτηση ενός βήματος ενός κλειδιού. Η αναζήτηση ενός κλειδιού στο trie απαιτεί πολλές υποκείμενες αναζητήσεις DB για να φτάσει στην τελική τιμή που περιγράφεται παραπάνω. Ας αναφερθούμε στο τελευταίο ως ένα `μονοπάτι` για να εξαλείψουμε την ασάφεια.

Οι λειτουργίες ενημέρωσης και διαγραφής για τα δέντρα radix μπορούν να οριστούν ως εξής:

```
    def update(node_hash, path, value):
        curnode = db.get(node_hash) if node_hash else [ NULL ] * 17
        newnode = curnode.copy()
        if path == '':
            newnode[-1] = value
        else:
            newindex = update(curnode[path[0]], path[1:], value)
            newnode[path[0]] = newindex
        db.put(hash(newnode), newnode)
        return hash(newnode)

    def delete(node_hash, path):
        if node_hash is NULL:
            return NULL
        else:
            curnode = db.get(node_hash)
            newnode = curnode.copy()
            if path == '':
                newnode[-1] = NULL
            else:
                newindex = delete(curnode[path[0]], path[1:])
                newnode[path[0]] = newindex

            if all(x is NULL for x in newnode):
                return NULL
            else:
                db.put(hash(newnode), newnode)
                return hash(newnode)
```

Ένα δέντρο Radix Merkle κατασκευάζεται συνδέοντας κόμβους χρησιμοποιώντας κρυπτογραφικά hash digests που παράγονται καθοριστικά. Αυτή η αντιστοίχιση περιεχομένου (στο κλειδί/τιμή DB `key == keccak256(rlp(value))`) παρέχει μια κρυπτογραφική εγγύηση ακεραιότητας των αποθηκευμένων δεδομένων. Εάν το hash ρίζας ενός δεδομένου trie είναι δημόσια γνωστό, τότε ο καθένας που έχει πρόσβαση στα υποκείμενα δεδομένα φύλλων μπορεί να κατασκευάσει μια απόδειξη ότι το trie περιλαμβάνει μια δεδομένη τιμή σε μια συγκεκριμένη διαδρομή παρέχοντας τα hash κάθε κόμβου που συνδέει μια συγκεκριμένη τιμή με τη ρίζα του δέντρου.

Είναι αδύνατο για έναν επιτιθέμενο να παράσχει μια απόδειξη ενός ζεύγους `(διαδρομή, τιμή)` που δεν υπάρχει, καθώς το hash ρίζας βασίζεται τελικά σε όλα τα hash κάτω από αυτό. Οποιαδήποτε υποκείμενη τροποποίηση θα άλλαζε το hash ρίζας. Μπορείτε να σκεφτείτε το hash ως μια συμπιεσμένη αναπαράσταση δομικών πληροφοριών σχετικά με τα δεδομένα, ασφαλισμένη από την προστασία προ-εικόνας της συνάρτησης hashing.

Θα αναφερόμαστε σε μια ατομική μονάδα ενός δέντρου radix (π.χ. ένας μόνο εξαδικός χαρακτήρας ή 4 δυαδικός αριθμός) ως "nibble". Κατά την παρακολούθηση μιας διαδρομής ένα nibble κάθε φορά, όπως περιγράφεται παραπάνω, οι κόμβοι μπορούν μέγιστα να αναφέρονται σε 16 παιδιά αλλά να περιλαμβάνουν ένα στοιχείο `τιμής`. Κατά συνέπεια, τους αντιπροσωπεύουμε ως έναν πίνακα μήκους 17. Αποκαλούμε αυτούς τους πίνακες 17 στοιχείων "κόμβοι κλάδου".

## Merkle Patricia Trie {#merkle-patricia-trees}

Οι radix tries έχουν ένα σημαντικό περιορισμό: είναι αναποτελεσματικές. Εάν θέλετε να αποθηκεύσετε μία δέσμη `(path, value)` όπου το path, όπως στο Ethereum, έχει μήκος 64 χαρακτήρες (τον αριθμό των nibbles σε `bytes32`), θα χρειαστούμε πάνω από ένα kilobyte επιπλέον χώρου για να αποθηκεύσουμε ένα επίπεδο ανά χαρακτήρα, και κάθε αναζήτηση ή διαγραφή θα χρειαστεί τα πλήρη 64 βήματα. Το Patricia trie που εισάγεται στη συνέχεια επιλύει αυτό το πρόβλημα.

### Βελτιστοποίηση {#optimization}

Ένας κόμβος σε μια Merkle Patricia trie είναι ένα από τα εξής:

1.  `NULL` (αντιπροσωπεύεται ως κενή συμβολοσειρά)
2.  `branch` Ένας κόμβος 17 στοιχείων `[ v0 ... v15, vt ]`
3.  `leaf` Ένας κόμβος 2 στοιχείων `[ encodedPath, value ]`
4.  `extension` Ένας κόμβος 2 στοιχείων `[ encodedPath, key ]`

Με διαδρομές 64 χαρακτήρων είναι αναπόφευκτο ότι μετά την διέλευση των πρώτων λίγων επιπέδων της trie, θα φτάσετε σε έναν κόμβο όπου δεν υπάρχει αποκλίνουσα διαδρομή για τουλάχιστον μέρος του δρόμου προς τα κάτω. Για να αποφύγουμε τη δημιουργία έως και 15 κενών κόμβων `NULL` κατά μήκος της διαδρομής, συντομεύουμε την κάθοδο δημιουργώντας έναν κόμβο `extension` της μορφής `[ encodedPath, key ]`, όπου το `encodedPath` περιέχει τη "μερική διαδρομή" για να παραλείψουμε μπροστά (χρησιμοποιώντας μια συμπαγή κωδικοποίηση που περιγράφεται παρακάτω) και το `key` είναι για την επόμενη αναζήτηση DB.

Για έναν κόμβο `leaf`, ο οποίος μπορεί να επισημανθεί με μια σημαία στο πρώτο nibble του `encodedPath`, η διαδρομή κωδικοποιεί τα τμήματα διαδρομής όλων των προηγούμενων κόμβων και μπορούμε να αναζητήσουμε την `value` απευθείας.

Αυτή η παραπάνω βελτιστοποίηση, ωστόσο, εισάγει ασάφεια.

Κατά τη διέλευση διαδρομών σε nibbles, μπορεί να καταλήξουμε σε έναν περιττό αριθμό nibbles για διέλευση, αλλά επειδή όλα τα δεδομένα αποθηκεύονται σε μορφή `byte`. Δεν είναι δυνατό να διαφοροποιηθεί μεταξύ, για παράδειγμα, του nibble `1` και των nibbles `01` (και τα δύο πρέπει να αποθηκευτούν ως `<01>`). Για να καθοριστεί το περιττό μήκος, η μερική διαδρομή τροποποιείται με μια σημαία.

### Προδιαγραφή: Συμπαγής κωδικοποίηση εξαγωνικής ακολουθίας με προαιρετικό τερματιστή {#specification}

Η σηματοδότηση τόσο _της περιττής όσο και της άρτιας υπόλοιπης μερικής διαδρομής μήκους_ και του _κόμβου φύλλου ως κόμβου επέκτασης_ όπως περιγράφεται παραπάνω βρίσκεται στο πρώτο nibble της μερικής διαδρομής οποιουδήποτε κόμβου 2 στοιχείων. Αυτό έχει ως αποτέλεσμα τα εξής:

    hex char    bits    |    node type partial     path length
    ----------------------------------------------------------
       0        0000    |       extension              even
       1        0001    |       extension              odd
       2        0010    |   terminating (leaf)         even
       3        0011    |   terminating (leaf)         odd

Για άρτιο υπόλοιπο μήκος διαδρομής (`0` ή `2`), ένα άλλο nibble "padding" `0` θα ακολουθεί πάντα.

```
    def compact_encode(hexarray):
        term = 1 if hexarray[-1] == 16 else 0
        if term: hexarray = hexarray[:-1]
        oddlen = len(hexarray) % 2
        flags = 2 * term + oddlen
        if oddlen:
            hexarray = [flags] + hexarray
        else:
            hexarray = [flags] + [0] + hexarray
        // hexarray now has an even length whose first nibble is the flags.
        o = ''
        for i in range(0,len(hexarray),2):
            o += chr(16 * hexarray[i] + hexarray[i+1])
        return o
```

Παραδείγματα:

```
    > [ 1, 2, 3, 4, 5, ...]
    '11 23 45'
    > [ 0, 1, 2, 3, 4, 5, ...]
    '00 01 23 45'
    > [ 0, f, 1, c, b, 8, 10]
    '20 0f 1c b8'
    > [ f, 1, c, b, 8, 10]
    '3f 1c b8'
```

Ακολουθεί ο επεκταμένος κώδικας για την απόκτηση ενός κόμβου στο δέντρο Merkle Patricia:

```
    def get_helper(node_hash,path):
        if path == []: return node_hash
        if node_hash == '': return ''
        curnode = rlp.decode(node_hash if len(node_hash) < 32 else db.get(node_hash))
        if len(curnode) == 2:
            (k2, v2) = curnode
            k2 = compact_decode(k2)
            if k2 == path[:len(k2)]:
                return get(v2, path[len(k2):])
            else:
                return ''
        elif len(curnode) == 17:
            return get_helper(curnode[path[0]],path[1:])

    def get(node_hash,path):
        path2 = []
        for i in range(len(path)):
            path2.push(int(ord(path[i]) / 16))
            path2.push(ord(path[i]) % 16)
        path2.push(16)
        return get_helper(node_hash,path2)
```

### Παράδειγμα «Trie» {#example-trie}

Ας υποθέσουμε ότι θέλουμε ένα trie που περιέχει τέσσερα ζεύγη διαδρομή/τιμή `('do', 'verb')`, `('dog', 'puppy')`, `('doge', 'coins')`, `('horse', 'stallion')`.

Πρώτα, μετατρέπουμε τόσο τις διαδρομές όσο και τις τιμές σε `byte`. Παρακάτω, οι πραγματικές αναπαραστάσεις byte για τις _διαδρομές_ υποδεικνύονται με `<>`, αν και οι _τιμές_ εμφανίζονται ακόμα ως συμβολοσειρές, που υποδεικνύονται με `'`', για ευκολότερη κατανόηση (θα ήταν επίσης πραγματικά `byte`):

```
    <64 6f> : 'verb'
    <64 6f 67> : 'puppy'
    <64 6f 67 65> : 'coins'
    <68 6f 72 73 65> : 'stallion'
```

Τώρα, κατασκευάζουμε ένα τέτοιο trie με τα ακόλουθα ζεύγη κλειδί/τιμή στην υποκείμενη βάση δεδομένων:

```
    rootHash: [ <16>, hashA ]
    hashA:    [ <>, <>, <>, <>, hashB, <>, <>, <>, [ <20 6f 72 73 65>, 'stallion' ], <>, <>, <>, <>, <>, <>, <>, <> ]
    hashB:    [ <00 6f>, hashC ]
    hashC:    [ <>, <>, <>, <>, <>, <>, hashD, <>, <>, <>, <>, <>, <>, <>, <>, <>, 'verb' ]
    hashD:    [ <17>, [ <>, <>, <>, <>, <>, <>, [ <35>, 'coins' ], <>, <>, <>, <>, <>, <>, <>, <>, <>, 'puppy' ] ]
```

Όταν ένας κόμβος αναφέρεται μέσα σε έναν άλλο κόμβο, αυτό που περιλαμβάνεται είναι `H(rlp.encode(node))`, όπου `H(x) = keccak256(x) if len(x) >= 32 αλλιώς `x και `rlp.encode` είναι η συνάρτηση κωδικοποίησης [RLP](/developers/docs/data-structures-and-encoding/rlp).

Σημειώστε ότι κατά την ενημέρωση ενός trie, πρέπει να αποθηκεύσετε το ζεύγος κλειδί/τιμή `(keccak256(x), x)` σε έναν μόνιμο πίνακα αναζήτησης _εάν_ ο νεοδημιουργημένος κόμβος έχει μήκος >= 32. Ωστόσο, εάν ο κόμβος είναι μικρότερος από αυτό, δεν χρειάζεται να αποθηκεύσετε τίποτα, καθώς η συνάρτηση f(x) = x είναι αναστρέψιμη.

## Τα Tries στο Ethereum {#tries-in-ethereum}

Όλα τα merkle tries στο επίπεδο εκτέλεσης του Ethereum χρησιμοποιούν ένα Merkle Patricia Trie.

Από μια κεφαλίδα μπλοκ υπάρχουν 3 ρίζες από 3 από αυτά τα tries.

1.  stateRoot
2.  transactionsRoot
3.  receiptsRoot

### Κατάσταση Trie {#state-trie}

Υπάρχει ένα παγκόσμιο trie κατάστασης και ενημερώνεται κάθε φορά που ένας πελάτης επεξεργάζεται ένα μπλοκ. Σε αυτό, μια `path` είναι πάντα: `keccak256(ethereumAddress)` και μια `τιμή` είναι πάντα: `rlp(ethereumAccount)`. Πιο συγκεκριμένα, ένας `account` ethereum είναι ένας πίνακας 4 στοιχείων από `[nonce,balance,storageRoot,codeHash]`. Σε αυτό το σημείο, αξίζει να σημειωθεί ότι αυτό το `storageRoot` είναι η ρίζα ενός άλλου trie πατρίσια:

### Αποθηκευτικός χώρος «Trie» {#storage-trie}

Το storage trie είναι όπου υπάρχουν _όλα_ τα δεδομένα συμβολαίου. Υπάρχει ένα ξεχωριστό storage trie για κάθε λογαριασμό. Για να ανακτήσετε τιμές σε συγκεκριμένες θέσεις αποθήκευσης σε μια δεδομένη διεύθυνση, απαιτούνται η διεύθυνση αποθήκευσης, η ακέραια θέση των αποθηκευμένων δεδομένων στην αποθήκευση και το αναγνωριστικό μπλοκ. Αυτά μπορούν στη συνέχεια να περαστούν ως ορίσματα στο `eth_getStorageAt` που ορίζεται στο API JSON-RPC, π.χ. για να ανακτήσετε τα δεδομένα στην υποδοχή αποθήκευσης 0 για τη διεύθυνση `0x295a70b2de5e3953354a6a8344e616ed314d7251`:

```
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x0", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x00000000000000000000000000000000000000000000000000000000000004d2"}

```

Η ανάκτηση άλλων στοιχείων στην αποθήκευση είναι λίγο πιο περίπλοκη επειδή πρέπει πρώτα να υπολογιστεί η θέση στο storage trie. Η θέση υπολογίζεται ως το hash `keccak256` της διεύθυνσης και της θέσης αποθήκευσης, και τα δύο αριστερά γεμισμένα με μηδενικά σε μήκος 32 byte. Για παράδειγμα, η θέση για τα δεδομένα στην υποδοχή αποθήκευσης 1 για τη διεύθυνση `0x391694e7e0b0cce554cb130d723a9d27458f9298` είναι:

```
keccak256(decodeHex("000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298" + "0000000000000000000000000000000000000000000000000000000000000001"))
```

Σε μια κονσόλα Geth, αυτό μπορεί να υπολογιστεί ως εξής:

```
> var key = "000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298" + "0000000000000000000000000000000000000000000000000000000000000001"
undefined
> web3.sha3(key, {"encoding": "hex"})
"0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9"
```

Η `path` είναι επομένως `keccak256(<6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9>)`. Αυτό μπορεί τώρα να χρησιμοποιηθεί για να ανακτήσει τα δεδομένα από το trie αποθήκευσης όπως πριν:

```
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000162e"}
```

Σημείωση: Το `storageRoot` για έναν λογαριασμό Ethereum είναι κενό από προεπιλογή εάν δεν είναι λογαριασμός συμβολαίου.

### Συναλλαγές Trie {#transaction-trie}

Υπάρχει ένα ξεχωριστό trie συναλλαγών για κάθε μπλοκ, αποθηκεύοντας και πάλι ζεύγη `(key, value)`. Μια διαδρομή εδώ είναι: `rlp(transactionIndex)` που αντιπροσωπεύει το κλειδί που αντιστοιχεί σε μια τιμή που καθορίζεται από:

```
if legacyTx:
  value = rlp(tx)
else:
  value = TxType | encode(tx)
```

Περισσότερες πληροφορίες σχετικά με αυτό μπορούν να βρεθούν στην τεκμηρίωση [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718).

### Αποδείξεις Trie {#receipts-trie}

Κάθε μπλοκ έχει το δικό του trie αποδείξεων. Ένα `path` εδώ είναι: `rlp(transactionIndex)`. Το `transactionIndex` είναι ο δείκτης του μέσα στο μπλοκ όπου συμπεριλήφθηκε. Το trie αποδείξεων δεν ενημερώνεται ποτέ. Παρόμοια με το trie συναλλαγών, υπάρχουν τρέχουσες και παλιές αποδείξεις. Για να ερωτηθεί μια συγκεκριμένη απόδειξη στο trie αποδείξεων, απαιτείται ο δείκτης της συναλλαγής στο μπλοκ της, το φορτίο απόδειξης και ο τύπος συναλλαγής. Η επιστρεφόμενη απόδειξη μπορεί να είναι τύπου `Receipt` που ορίζεται ως η συνένωση του `TransactionType` και του `ReceiptPayload` ή μπορεί να είναι τύπου `LegacyReceipt` που ορίζεται ως `rlp([status, cumulativeGasUsed, logsBloom, logs])`.

Περισσότερες πληροφορίες σχετικά με αυτό μπορούν να βρεθούν στην τεκμηρίωση [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718).

## Περισσότερες πληροφορίες {#further-reading}

- [Τροποποιημένο δέντρο Merkle Patricia — Πώς το Ethereum αποθηκεύει μια κατάσταση](https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd)
- [Merkling στο Ethereum](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)
- [Κατανόηση του trie Ethereum](https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/)
