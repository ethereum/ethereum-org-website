---
title: येलो पेपर के EVM विनिर्देशों को समझना
description: येलो पेपर (इथेरियम के लिए औपचारिक विनिर्देश) के उस हिस्से को समझना, जो एथेरियम वर्चुअल मशीन (EVM) की व्याख्या करता है।
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: hi
published: 2022-05-15
---

[येलो पेपर](https://ethereum.github.io/yellowpaper/paper.pdf) इथेरियम के लिए औपचारिक विनिर्देश है। [EIP प्रक्रिया](/eips/) द्वारा संशोधित किए गए स्थानों को छोड़कर, इसमें हर चीज़ के काम करने के तरीके का सटीक विवरण है। यह एक गणितीय पेपर के रूप में लिखा गया है, जिसमें ऐसी शब्दावली शामिल है जिससे प्रोग्रामर परिचित नहीं हो सकते हैं। इस पेपर में आप सीखेंगे कि इसे कैसे पढ़ा जाए, और विस्तार से, अन्य संबंधित गणितीय पेपर भी।

## कौनसा येलो पेपर? {#which-yellow-paper}

इथेरियम में लगभग हर दूसरी चीज की तरह, येलो पेपर भी समय के साथ विकसित होता है। एक विशिष्ट संस्करण का संदर्भ देने में सक्षम होने के लिए, मैंने [लिखने के समय का वर्तमान संस्करण](yellow-paper-berlin.pdf) अपलोड किया है। मेरे द्वारा उपयोग किए जाने वाले अनुभाग, पृष्ठ और समीकरण संख्याएं उसी संस्करण का संदर्भ देंगी। इस दस्तावेज़ को पढ़ते समय इसे एक अलग विंडो में खुला रखना एक अच्छा विचार है।

### EVM क्यों? {#why-the-evm}

मूल येलो पेपर इथेरियम के विकास की शुरुआत में ही लिखा गया था। यह मूल प्रूफ-ऑफ-वर्क आधारित सहमति तंत्र का वर्णन करता है जिसका उपयोग मूल रूप से नेटवर्क को सुरक्षित करने के लिए किया गया था। हालाँकि, इथेरियम ने सितंबर 2022 में प्रूफ-ऑफ-वर्क को बंद कर दिया और प्रूफ-ऑफ-स्टेक आधारित सहमति का उपयोग करना शुरू कर दिया। यह ट्यूटोरियल येलो पेपर के उन हिस्सों पर ध्यान केंद्रित करेगा जो एथेरियम वर्चुअल मशीन को परिभाषित करते हैं। प्रूफ-ऑफ-स्टेक में संक्रमण से EVM अपरिवर्तित रहा (DIFFICULTY ऑपकोड के वापसी मान को छोड़कर)।

## 9 निष्पादन मॉडल {#9-execution-model}

इस अनुभाग (पृ. 12-14) में EVM की अधिकांश परिभाषा शामिल है।

_सिस्टम स्टेट_ शब्द में सिस्टम को चलाने के लिए आपको जो कुछ भी जानने की जरूरत है, वह सब शामिल है। एक सामान्य कंप्यूटर में, इसका मतलब है मेमोरी, रजिस्टर की सामग्री, आदि।

एक [ट्यूरिंग मशीन](https://en.wikipedia.org/wiki/Turing_machine) एक कम्प्यूटेशनल मॉडल है। मूल रूप से, यह कंप्यूटर का एक सरलीकृत संस्करण है, जिसमें एक सामान्य कंप्यूटर के समान गणना करने की क्षमता साबित हुई है (एक कंप्यूटर जो कुछ भी गणना कर सकता है, एक ट्यूरिंग मशीन भी गणना कर सकती है और इसके विपरीत)। यह मॉडल विभिन्न प्रमेयों को साबित करना आसान बनाता है कि क्या गणना योग्य है और क्या नहीं।

[ट्यूरिंग-कंप्लीट](https://en.wikipedia.org/wiki/Turing_completeness) शब्द का अर्थ एक ऐसा कंप्यूटर है जो ट्यूरिंग मशीन के समान गणना चला सकता है। ट्यूरिंग मशीनें अनंत लूप में जा सकती हैं, और EVM नहीं जा सकती क्योंकि उसकी गैस खत्म हो जाएगी, इसलिए यह केवल अर्ध-ट्यूरिंग-पूर्ण है।

## 9.1 मूल बातें {#91-basics}

यह अनुभाग EVM की मूल बातें बताता है और यह अन्य कम्प्यूटेशनल मॉडलों से कैसे तुलना करता है।

एक [स्टैक मशीन](https://en.wikipedia.org/wiki/Stack_machine) एक ऐसा कंप्यूटर है जो मध्यवर्ती डेटा को रजिस्टरों में संग्रहीत नहीं करता है, बल्कि एक [**स्टैक**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)) में करता है। यह वर्चुअल मशीनों के लिए पसंदीदा आर्किटेक्चर है क्योंकि इसे लागू करना आसान है, जिसका अर्थ है कि बग और सुरक्षा कमजोरियों की संभावना बहुत कम है। स्टैक में मेमोरी 256-बिट शब्दों में विभाजित है। इसे इसलिए चुना गया क्योंकि यह इथेरियम के मुख्य क्रिप्टोग्राफ़िक संचालन जैसे Keccak-256 हैशिंग और इलिप्टिक कर्व गणना के लिए सुविधाजनक है। स्टैक का अधिकतम आकार 1024 आइटम (1024 x 256 बिट्स) है। जब ऑपकोड निष्पादित होते हैं, तो वे आमतौर पर अपने पैरामीटर स्टैक से प्राप्त कर रहे होते हैं। स्टैक में तत्वों को पुनर्गठित करने के लिए विशेष रूप से ऑपकोड हैं जैसे `POP` (स्टैक के शीर्ष से आइटम हटाता है), `DUP_N` (स्टैक में Nवें आइटम को डुप्लिकेट करता है), आदि।

EVM में **मेमोरी** नामक एक अस्थिर स्थान भी है जिसका उपयोग निष्पादन के दौरान डेटा संग्रहीत करने के लिए किया जाता है। यह मेमोरी 32-बाइट शब्दों में व्यवस्थित है। सभी मेमोरी स्थान शून्य से आरंभ किए जाते हैं। यदि आप मेमोरी में एक शब्द जोड़ने के लिए इस [Yul](https://docs.soliditylang.org/en/latest/yul.html) कोड को निष्पादित करते हैं, तो यह शब्द में खाली स्थान को शून्य से भरकर 32 बाइट्स मेमोरी भर देगा, यानी, यह एक शब्द बनाता है - स्थानों 0-29 में शून्य के साथ, 30 में 0x60, और 31 में 0xA7 के साथ।

```yul
mstore(0, 0x60A7)
```

`mstore` EVM द्वारा मेमोरी के साथ इंटरैक्ट करने के लिए प्रदान किए गए तीन ऑपकोड में से एक है - यह मेमोरी में एक शब्द लोड करता है। अन्य दो `mstore8` हैं जो मेमोरी में एक बाइट लोड करता है, और `mload` जो मेमोरी से स्टैक में एक शब्द ले जाता है।

EVM में एक अलग गैर-अस्थिर **स्टोरेज** मॉडल भी है जिसे सिस्टम स्टेट के हिस्से के रूप में बनाए रखा जाता है - यह मेमोरी शब्द सरणियों में व्यवस्थित है (स्टैक में शब्द-पता योग्य बाइट सरणियों के विपरीत)। यह स्टोरेज वह जगह है जहां अनुबंध लगातार डेटा रखते हैं - एक अनुबंध केवल अपने स्वयं के स्टोरेज के साथ इंटरैक्ट कर सकता है। स्टोरेज कुंजी-मूल्य मैपिंग में व्यवस्थित है।

यद्यपि येलो पेपर के इस खंड में इसका उल्लेख नहीं है, यह जानना भी उपयोगी है कि चौथी प्रकार की मेमोरी है। **Calldata** बाइट-पता योग्य रीड-ओनली मेमोरी है जिसका उपयोग लेनदेन के `data` पैरामीटर के साथ पारित मान को संग्रहीत करने के लिए किया जाता है। EVM के पास `calldata` के प्रबंधन के लिए विशिष्ट ऑपकोड हैं। `calldatasize` डेटा का आकार लौटाता है। `calldataload` डेटा को स्टैक में लोड करता है। `calldatacopy` डेटा को मेमोरी में कॉपी करता है।

मानक [वॉन न्यूमैन आर्किटेक्चर](https://en.wikipedia.org/wiki/Von_Neumann_architecture) कोड और डेटा को एक ही मेमोरी में संग्रहीत करता है। EVM सुरक्षा कारणों से इस मानक का पालन नहीं करता है - अस्थिर मेमोरी साझा करने से प्रोग्राम कोड बदलना संभव हो जाता है। इसके बजाय, कोड को स्टोरेज में सहेजा जाता है।

केवल दो मामले हैं जिनमें कोड मेमोरी से निष्पादित किया जाता है:

- जब कोई अनुबंध दूसरा अनुबंध बनाता है ([`CREATE`](https://www.evm.codes/#f0) या [`CREATE2`](https://www.evm.codes/#f5) का उपयोग करके), तो अनुबंध कंस्ट्रक्टर के लिए कोड मेमोरी से आता है।
- _किसी भी_ अनुबंध के निर्माण के दौरान, कंस्ट्रक्टर कोड चलता है और फिर वास्तविक अनुबंध के कोड के साथ लौटता है, जो मेमोरी से भी आता है।

असाधारण निष्पादन शब्द का अर्थ एक ऐसा अपवाद है जो वर्तमान अनुबंध के निष्पादन को रोक देता है।

## 9.2 शुल्क अवलोकन {#92-fees-overview}

यह अनुभाग बताता है कि गैस शुल्क की गणना कैसे की जाती है। तीन लागतें हैं:

### ऑपकोड लागत {#opcode-cost}

विशिष्ट ऑपकोड की अंतर्निहित लागत। इस मान को प्राप्त करने के लिए, परिशिष्ट H (पृ. 28, समीकरण (327) के तहत) में ऑपकोड का लागत समूह खोजें, और समीकरण (324) में लागत समूह खोजें। यह आपको एक लागत फ़ंक्शन देता है, जो अधिकांश मामलों में परिशिष्ट G (पृ. 27) से पैरामीटर का उपयोग करता है।

उदाहरण के लिए, ऑपकोड [`CALLDATACOPY`](https://www.evm.codes/#37) समूह _W<sub>copy</sub>_ का सदस्य है। उस समूह के लिए ऑपकोड लागत _G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_ है। परिशिष्ट G को देखने पर, हम देखते हैं कि दोनों स्थिरांक 3 हैं, जो हमें _3+3×⌈μ<sub>s</sub>[2]÷32⌉_ देता है।

हमें अभी भी व्यंजक _⌈μ<sub>s</sub>[2]÷32⌉_ को समझने की आवश्यकता है। सबसे बाहरी भाग, _⌈ \<value\> ⌉_ सीलिंग फ़ंक्शन है, एक फ़ंक्शन जो एक मान दिए जाने पर सबसे छोटा पूर्णांक लौटाता है जो अभी भी मान से छोटा नहीं है। उदाहरण के लिए, _⌈2.5⌉ = ⌈3⌉ = 3_। आंतरिक भाग _μ<sub>s</sub>[2]÷32_ है। पृ. 3 पर अनुभाग 3 (कन्वेंशन) को देखने पर, _μ_ मशीन स्टेट है। मशीन स्टेट को पृ. 13 पर अनुभाग 9.4.1 में परिभाषित किया गया है। उस अनुभाग के अनुसार, मशीन स्टेट पैरामीटर में से एक स्टैक के लिए _s_ है। इन सब को एक साथ रखने पर, ऐसा लगता है कि _μ<sub>s</sub>[2]_ स्टैक में स्थान #2 है। [ऑपकोड](https://www.evm.codes/#37) को देखने पर, स्टैक में स्थान #2 बाइट्स में डेटा का आकार है। समूह W<sub>copy</sub> में अन्य ऑपकोड, [`CODECOPY`](https://www.evm.codes/#39) और [`RETURNDATACOPY`](https://www.evm.codes/#3e) को देखने पर, उनके पास भी उसी स्थान पर डेटा का आकार होता है। तो _⌈μ<sub>s</sub>[2]÷32⌉_ कॉपी किए जा रहे डेटा को संग्रहीत करने के लिए आवश्यक 32 बाइट शब्दों की संख्या है। सब कुछ एक साथ रखने पर, [`CALLDATACOPY`](https://www.evm.codes/#37) की अंतर्निहित लागत 3 गैस और कॉपी किए जा रहे डेटा के प्रति शब्द 3 है।

### चलने की लागत {#running-cost}

हम जिस कोड को कॉल कर रहे हैं उसे चलाने की लागत।

- [`CREATE`](https://www.evm.codes/#f0) और [`CREATE2`](https://www.evm.codes/#f5) के मामले में, नए अनुबंध के लिए कंस्ट्रक्टर।
- [`CALL`](https://www.evm.codes/#f1), [`CALLCODE`](https://www.evm.codes/#f2), [`STATICCALL`](https://www.evm.codes/#fa), या [`DELEGATECALL`](https://www.evm.codes/#f4) के मामले में, वह अनुबंध जिसे हम कॉल करते हैं।

### मेमोरी विस्तार लागत {#expanding-memory-cost}

मेमोरी का विस्तार करने की लागत (यदि आवश्यक हो)।

समीकरण 324 में, यह मान _C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_ के रूप में लिखा गया है। अनुभाग 9.4.1 को फिर से देखने पर, हम देखते हैं कि _μ<sub>i</sub>_ मेमोरी में शब्दों की संख्या है। तो _μ<sub>i</sub>_ ऑपकोड से पहले मेमोरी में शब्दों की संख्या है और _μ<sub>i</sub>'_ ऑपकोड के बाद मेमोरी में शब्दों की संख्या है।

फ़ंक्शन _C<sub>mem</sub>_ को समीकरण 326 में परिभाषित किया गया है: _C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_। _⌊x⌋_ फ़्लोर फ़ंक्शन है, एक फ़ंक्शन जो एक मान दिए जाने पर सबसे बड़ा पूर्णांक लौटाता है जो अभी भी मान से बड़ा नहीं है। उदाहरण के लिए, _⌊2.5⌋ = ⌊2⌋ = 2._ जब _a < √512_, _a<sup>2</sup> < 512_, और फ़्लोर फ़ंक्शन का परिणाम शून्य होता है। तो पहले 22 शब्दों (704 बाइट्स) के लिए, लागत आवश्यक मेमोरी शब्दों की संख्या के साथ रैखिक रूप से बढ़ती है। उस बिंदु से परे _⌊a<sup>2</sup> ÷ 512⌋_ धनात्मक है। जब आवश्यक मेमोरी पर्याप्त रूप से अधिक होती है, तो गैस लागत मेमोरी की मात्रा के वर्ग के समानुपाती होती है।

**ध्यान दें** कि ये कारक केवल _अंतर्निहित_ गैस लागत को प्रभावित करते हैं - यह शुल्क बाजार या सत्यापनकर्ताओं को दिए जाने वाले सुझावों को ध्यान में नहीं रखता है जो यह निर्धारित करते हैं कि एक अंतिम उपयोगकर्ता को कितना भुगतान करना आवश्यक है - यह सिर्फ EVM पर किसी विशेष ऑपरेशन को चलाने की कच्ची लागत है।

[गैस के बारे में और पढ़ें](/developers/docs/gas/)।

## 9.3 निष्पादन वातावरण {#93-execution-env}

निष्पादन वातावरण एक टपल, _I_ है, जिसमें ऐसी जानकारी शामिल है जो ब्लॉकचेन स्टेट या EVM का हिस्सा नहीं है।

| पैरामीटर        | डेटा तक पहुंचने के लिए ऑपकोड                                                                               | डेटा तक पहुंचने के लिए सॉलिडिटी कोड      |
| --------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                                     | `address(this)`                          |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                                      | `tx.origin`                              |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                                    | `tx.gasprice`                            |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35), आदि।                                                          | `msg.data`                               |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                                      | `msg.sender`                             |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                                   | `msg.value`                              |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                                    | `address(this).code`                     |
| _I<sub>H</sub>_ | ब्लॉक हेडर फ़ील्ड, जैसे [`NUMBER`](https://www.evm.codes/#43) और [`DIFFICULTY`](https://www.evm.codes/#44) | `block.number`, `block.difficulty`, आदि। |
| _I<sub>e</sub>_ | अनुबंधों के बीच कॉल के लिए कॉल स्टैक की गहराई (अनुबंध निर्माण सहित)                     |                                          |
| _I<sub>w</sub>_ | क्या EVM को स्टेट बदलने की अनुमति है, या यह स्थिर रूप से चल रहा है                                         |                                          |

अनुभाग 9 के बाकी हिस्सों को समझने के लिए कुछ अन्य पैरामीटर आवश्यक हैं:

| पैरामीटर | अनुभाग में परिभाषित                                             | अर्थ                                                                                                                                                                                                                                                           |
| -------- | --------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _σ_      | 2 (पृ. 2, समीकरण 1)          | ब्लॉकचेन की स्टेट                                                                                                                                                                                                                                              |
| _g_      | 9.3 (पृ. 13) | शेष गैस                                                                                                                                                                                                                                                        |
| _A_      | 6.1 (पृ. 8)  | उपार्जित सबस्टेट (लेनदेन समाप्त होने पर निर्धारित परिवर्तन)                                                                                                                                                                                 |
| _o_      | 9.3 (पृ. 13) | आउटपुट - आंतरिक लेनदेन (जब एक अनुबंध दूसरे को कॉल करता है) और फ़ंक्शंस देखने के लिए कॉल (जब आप सिर्फ जानकारी मांग रहे होते हैं, तो लेनदेन की प्रतीक्षा करने की कोई आवश्यकता नहीं होती है) के मामले में लौटाया गया परिणाम |

## 9.4 निष्पादन अवलोकन {#94-execution-overview}

अब जब हमारे पास सभी प्रारंभिक बातें हैं, तो हम अंततः इस पर काम करना शुरू कर सकते हैं कि EVM कैसे काम करता है।

समीकरण 137-142 हमें EVM चलाने के लिए प्रारंभिक शर्तें देते हैं:

| प्रतीक           | प्रारंभिक मान                                                                    | अर्थ                                                                                                                                                                                                                                                                                                        |
| ---------------- | -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | शेष गैस                                                                                                                                                                                                                                                                                                     |
| _μ<sub>pc</sub>_ | _0_                                                                              | प्रोग्राम काउंटर, निष्पादित किए जाने वाले अगले निर्देश का पता                                                                                                                                                                                                                                               |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | मेमोरी, सभी शून्यों से आरम्भ की गई                                                                                                                                                                                                                                                                          |
| _μ<sub>i</sub>_  | _0_                                                                              | उपयोग किया गया उच्चतम मेमोरी स्थान                                                                                                                                                                                                                                                                          |
| _μ<sub>s</sub>_  | _()_                                                          | स्टैक, शुरू में खाली                                                                                                                                                                                                                                                                                        |
| _μ<sub>o</sub>_  | _∅_                                                                              | आउटपुट, तब तक खाली सेट रहता है जब तक कि हम या तो रिटर्न डेटा ([`RETURN`](https://www.evm.codes/#f3) या [`REVERT`](https://www.evm.codes/#fd)) के साथ या उसके बिना ([`STOP`](https://www.evm.codes/#00) या [`SELFDESTRUCT`](https://www.evm.codes/#ff)) रुक नहीं जाते। |

समीकरण 143 हमें बताता है कि निष्पादन के दौरान समय के प्रत्येक बिंदु पर चार संभावित स्थितियाँ होती हैं, और उनके साथ क्या करना है:

1. `Z(σ,μ,A,I)`। Z एक ऐसे फ़ंक्शन का प्रतिनिधित्व करता है जो यह परीक्षण करता है कि क्या कोई ऑपरेशन एक अमान्य स्टेट संक्रमण बनाता है ([असाधारण रोक](#942-exceptional-halting) देखें)। यदि यह True का मूल्यांकन करता है, तो नई स्टेट पुरानी स्टेट के समान है (सिवाय इसके कि गैस जल जाती है) क्योंकि परिवर्तन लागू नहीं किए गए हैं।
2. यदि निष्पादित किया जा रहा ऑपकोड [`REVERT`](https://www.evm.codes/#fd) है, तो नई स्टेट पुरानी स्टेट के समान है, कुछ गैस खो जाती है।
3. यदि संचालन का क्रम समाप्त हो गया है, जैसा कि [`RETURN`](https://www.evm.codes/#f3) द्वारा दर्शाया गया है, तो स्टेट को नई स्टेट में अपडेट किया जाता है।
4. यदि हम अंतिम स्थितियों 1-3 में से किसी एक पर नहीं हैं, तो चलना जारी रखें।

## 9.4.1 मशीन स्टेट {#941-machine-state}

यह अनुभाग मशीन स्टेट को अधिक विस्तार से बताता है। यह निर्दिष्ट करता है कि _w_ वर्तमान ऑपकोड है। यदि _μ<sub>pc</sub>_ कोड की लंबाई _||I<sub>b</sub>||_ से कम है, तो वह बाइट (_I<sub>b</sub>[μ<sub>pc</sub>]_) ऑपकोड है। अन्यथा, ऑपकोड को [`STOP`](https://www.evm.codes/#00) के रूप में परिभाषित किया गया है।

चूंकि यह एक [स्टैक मशीन](https://en.wikipedia.org/wiki/Stack_machine) है, हमें प्रत्येक ऑपकोड द्वारा पॉप आउट किए गए (_δ_) और पुश इन किए गए (_α_) आइटमों की संख्या का ट्रैक रखने की आवश्यकता है।

## 9.4.2 असाधारण रोक {#942-exceptional-halt}

यह अनुभाग _Z_ फ़ंक्शन को परिभाषित करता है, जो यह निर्दिष्ट करता है कि हमारे पास कब एक असामान्य समाप्ति होती है। यह एक [बूलियन](https://en.wikipedia.org/wiki/Boolean_data_type) फ़ंक्शन है, इसलिए यह [लॉजिकल ऑर के लिए _∨_](https://en.wikipedia.org/wiki/Logical_disjunction) और [लॉजिकल एंड के लिए _∧_](https://en.wikipedia.org/wiki/Logical_conjunction) का उपयोग करता है।

यदि इनमें से कोई भी शर्त सही है तो हमारे पास एक असाधारण रोक है:

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  जैसा कि हमने अनुभाग 9.2 में देखा, _C_ वह फ़ंक्शन है जो गैस लागत को निर्दिष्ट करता है। अगले ऑपकोड को कवर करने के लिए पर्याप्त गैस नहीं बची है।

- **_δ<sub>w</sub>=∅_**
  यदि किसी ऑपकोड के लिए पॉप किए गए आइटमों की संख्या अपरिभाषित है, तो ऑपकोड स्वयं अपरिभाषित है।

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  स्टैक अंडरफ्लो, वर्तमान ऑपकोड के लिए स्टैक में पर्याप्त आइटम नहीं हैं।

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  ऑपकोड [`JUMP`](https://www.evm.codes/#56) है और पता [`JUMPDEST`](https://www.evm.codes/#5b) नहीं है। जंप _केवल_ तभी मान्य होते हैं जब गंतव्य एक [`JUMPDEST`](https://www.evm.codes/#5b) हो।

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  ऑपकोड [`JUMPI`](https://www.evm.codes/#57) है, शर्त सही है (गैर-शून्य) इसलिए जंप होना चाहिए, और पता [`JUMPDEST`](https://www.evm.codes/#5b) नहीं है। जंप _केवल_ तभी मान्य होते हैं जब गंतव्य एक [`JUMPDEST`](https://www.evm.codes/#5b) हो।

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  ऑपकोड [`RETURNDATACOPY`](https://www.evm.codes/#3e) है। इस ऑपकोड में स्टैक तत्व _μ<sub>s</sub>[1]_ वापसी डेटा बफ़र में पढ़ने के लिए ऑफ़सेट है, और स्टैक तत्व _μ<sub>s</sub>[2]_ डेटा की लंबाई है। यह स्थिति तब होती है जब आप वापसी डेटा बफ़र के अंत से आगे पढ़ने का प्रयास करते हैं। ध्यान दें कि कैलडेटा या स्वयं कोड के लिए कोई समान शर्त नहीं है। जब आप उन बफ़र्स के अंत से आगे पढ़ने का प्रयास करते हैं तो आपको केवल शून्य मिलते हैं।

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  स्टैक ओवरफ्लो। यदि ऑपकोड चलाने से 1024 से अधिक आइटमों का स्टैक परिणामित होता है, तो निरस्त करें।

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  क्या हम स्थिर रूप से चल रहे हैं ([¬ निषेध है](https://en.wikipedia.org/wiki/Negation) और _I<sub>w</sub>_ सत्य है जब हमें ब्लॉकचेन स्टेट बदलने की अनुमति है)? यदि ऐसा है, और हम एक स्टेट बदलने वाले ऑपरेशन की कोशिश कर रहे हैं, तो यह नहीं हो सकता है।

  फ़ंक्शन _W(w,μ)_ को बाद में समीकरण 150 में परिभाषित किया गया है। _W(w,μ)_ सत्य है यदि इनमें से कोई एक शर्त सत्य है:

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    ये ऑपकोड स्टेट बदलते हैं, या तो एक नया अनुबंध बनाकर, एक मान संग्रहीत करके, या वर्तमान अनुबंध को नष्ट करके।

  - **_LOG0≤w ∧ w≤LOG4_**
    यदि हमें स्थिर रूप से बुलाया जाता है तो हम लॉग प्रविष्टियाँ उत्सर्जित नहीं कर सकते हैं।
    लॉग ऑपकोड सभी [`LOG0` (A0)](https://www.evm.codes/#a0) और [`LOG4` (A4)](https://www.evm.codes/#a4) के बीच की सीमा में हैं।
    लॉग ऑपकोड के बाद की संख्या निर्दिष्ट करती है कि लॉग प्रविष्टि में कितने विषय हैं।

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    जब आप स्थिर हों तो आप किसी अन्य अनुबंध को कॉल कर सकते हैं, लेकिन यदि आप ऐसा करते हैं तो आप उसमें ETH स्थानांतरित नहीं कर सकते।

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  आप [`SSTORE`](https://www.evm.codes/#55) नहीं चला सकते जब तक कि आपके पास G<sub>callstipend</sub> (परिशिष्ट G में 2300 के रूप में परिभाषित) से अधिक गैस न हो।

## 9.4.3 जंप गंतव्य वैधता {#943-jump-dest-valid}

यहां हम औपचारिक रूप से परिभाषित करते हैं कि [`JUMPDEST`](https://www.evm.codes/#5b) ऑपकोड क्या हैं। हम केवल बाइट मान 0x5B की तलाश नहीं कर सकते, क्योंकि यह PUSH के अंदर हो सकता है (और इसलिए डेटा है न कि ऑपकोड)।

समीकरण (153) में हम एक फ़ंक्शन, _N(i,w)_ को परिभाषित करते हैं। पहला पैरामीटर, _i_, ऑपकोड का स्थान है। दूसरा, _w_, स्वयं ऑपकोड है। यदि _w∈[PUSH1, PUSH32]_ है तो इसका मतलब है कि ऑपकोड एक PUSH है (वर्ग कोष्ठक एक सीमा को परिभाषित करते हैं जिसमें समापन बिंदु शामिल हैं)। उस स्थिति में अगला ऑपकोड _i+2+(w−PUSH1)_ पर है। [`PUSH1`](https://www.evm.codes/#60) के लिए हमें दो बाइट्स (PUSH स्वयं और एक बाइट मान) से आगे बढ़ना होगा, [`PUSH2`](https://www.evm.codes/#61) के लिए हमें तीन बाइट्स से आगे बढ़ना होगा क्योंकि यह दो बाइट का मान है, आदि। अन्य सभी EVM ऑपकोड केवल एक बाइट लंबे होते हैं, इसलिए अन्य सभी मामलों में _N(i,w)=i+1_ होता है।

इस फ़ंक्शन का उपयोग समीकरण (152) में _D<sub>J</sub>(c,i)_ को परिभाषित करने के लिए किया जाता है, जो कोड _c_ में सभी मान्य जंप गंतव्यों का [सेट](https://en.wikipedia.org/wiki/Set_\(mathematics\)) है, जो ऑपकोड स्थान _i_ से शुरू होता है। यह फ़ंक्शन पुनरावर्ती रूप से परिभाषित किया गया है। यदि _i≥||c||_, तो इसका मतलब है कि हम कोड के अंत में या उसके बाद हैं। हम और अधिक जंप गंतव्य नहीं खोजने जा रहे हैं, इसलिए बस खाली सेट लौटाएं।

अन्य सभी मामलों में हम अगले ऑपकोड पर जाकर और उससे शुरू होने वाले सेट को प्राप्त करके बाकी कोड को देखते हैं। _c[i]_ वर्तमान ऑपकोड है, इसलिए _N(i,c[i])_ अगले ऑपकोड का स्थान है। इसलिए _D<sub>J</sub>(c,N(i,c[i]))_ मान्य जंप गंतव्यों का सेट है जो अगले ऑपकोड से शुरू होता है। यदि वर्तमान ऑपकोड `JUMPDEST` नहीं है, तो बस उस सेट को लौटाएं। यदि यह `JUMPDEST` है, तो इसे परिणाम सेट में शामिल करें और उसे लौटाएं।

## 9.4.4 सामान्य रोक {#944-normal-halt}

हॉल्टिंग फ़ंक्शन _H_, तीन प्रकार के मान लौटा सकता है।

- यदि हम हॉल्ट ऑपकोड में नहीं हैं, तो _∅_ लौटाएं, जो खाली सेट है। परंपरा के अनुसार, इस मान की व्याख्या बूलियन फाल्स के रूप में की जाती है।
- यदि हमारे पास एक हॉल्ट ऑपकोड है जो आउटपुट नहीं देता है ([`STOP`](https://www.evm.codes/#00) या [`SELFDESTRUCT`](https://www.evm.codes/#ff)), तो वापसी मान के रूप में शून्य आकार के बाइट्स का एक क्रम लौटाएं। ध्यान दें कि यह खाली सेट से बहुत अलग है। इस मान का मतलब है कि EVM वास्तव में रुक गया, बस पढ़ने के लिए कोई वापसी डेटा नहीं है।
- यदि हमारे पास एक हॉल्ट ऑपकोड है जो आउटपुट उत्पन्न करता है ([`RETURN`](https://www.evm.codes/#f3) या [`REVERT`](https://www.evm.codes/#fd)), तो उस ऑपकोड द्वारा निर्दिष्ट बाइट्स का क्रम लौटाएं। यह क्रम मेमोरी से लिया जाता है, स्टैक के शीर्ष पर मान (_μ<sub>s</sub>[0]_) पहला बाइट है, और उसके बाद का मान (_μ<sub>s</sub>[1]_) लंबाई है।

## H.2 निर्देश सेट {#h2-instruction-set}

EVM के अंतिम उपखंड, 9.5 पर जाने से पहले, आइए स्वयं निर्देशों को देखें। वे परिशिष्ट H.2 में परिभाषित हैं जो पृ. 29 से शुरू होता है। कुछ भी जो उस विशिष्ट ऑपकोड के साथ बदलने के रूप में निर्दिष्ट नहीं है, उसके समान रहने की उम्मीद है। जो चर बदलते हैं, उन्हें \<something\>′ के रूप में निर्दिष्ट किया जाता है।

उदाहरण के लिए, आइए [`ADD`](https://www.evm.codes/#01) ऑपकोड को देखें।

| मूल्य | मेमोनिक | δ | α | वर्णन                                                                                                                                                                                                                 |
| ----: | ------- | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x01 | ADD     | 2 | 1 | जोड़ने की प्रक्रिया।                                                                                                                                                                                                  |
|       |         |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_ उन मानों की संख्या है जिन्हें हम स्टैक से पॉप करते हैं। इस मामले में दो, क्योंकि हम शीर्ष दो मानों को जोड़ रहे हैं।

_α_ उन मानों की संख्या है जिन्हें हम वापस पुश करते हैं। इस मामले में एक, योग।

तो नया स्टैक टॉप (_μ′<sub>s</sub>[0]_) पुराने स्टैक टॉप (_μ<sub>s</sub>[0]_) और उसके नीचे के पुराने मान (_μ<sub>s</sub>[1]_) का योग है।

सभी ऑपकोड को एक "आँखें चौंधिया देने वाली सूची" के साथ देखने के बजाय, यह लेख केवल उन ऑपकोडों की व्याख्या करता है जो कुछ नया पेश करते हैं।

| मूल्य | मेमोनिक   | δ | α | वर्णन                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ----: | --------- | - | - | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x20 | KECCAK256 | 2 | 1 | Keccak-256 हैश की गणना करें।                                                                                                                                                                                                                                                                                                                                                                                                                          |
|       |           |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] .. । । (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|       |           |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                                      |

यह पहला ऑपकोड है जो मेमोरी तक पहुँचता है (इस मामले में, केवल पढ़ने के लिए)। हालाँकि, यह मेमोरी की वर्तमान सीमाओं से आगे बढ़ सकता है, इसलिए हमें _μ<sub>i</sub>_ को अपडेट करने की आवश्यकता है। हम यह पृ. 29 पर समीकरण 328 में परिभाषित _M_ फ़ंक्शन का उपयोग करके करते हैं।

| मूल्य | मेमोनिक | δ | α | वर्णन                                               |
| ----: | ------- | - | - | --------------------------------------------------- |
|  0x31 | BALANCE | 1 | 1 | दिए गए खाते का बैलेंस प्राप्त करें।                 |
|       |         |   |   | ... |

जिस पते का बैलेंस हमें खोजना है, वह _μ<sub>s</sub>[0] mod 2<sup>160</sup>_ है। स्टैक का शीर्ष पता है, लेकिन क्योंकि पते केवल 160 बिट के होते हैं, हम मान [मॉड्यूलो](https://en.wikipedia.org/wiki/Modulo_operation) 2<sup>160</sup> की गणना करते हैं।

यदि _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_, तो इसका मतलब है कि इस पते के बारे में जानकारी है। उस स्थिति में, _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_ उस पते का बैलेंस है। यदि _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_, तो इसका मतलब है कि यह पता अनइनिशियलाइज़्ड है और बैलेंस शून्य है। आप खाता जानकारी फ़ील्ड की सूची पृ. 4 पर अनुभाग 4.1 में देख सकते हैं।

दूसरा समीकरण, _A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_, वार्म स्टोरेज (स्टोरेज जिसे हाल ही में एक्सेस किया गया है और कैश्ड होने की संभावना है) और कोल्ड स्टोरेज (स्टोरेज जिसे एक्सेस नहीं किया गया है और धीमे स्टोरेज में होने की संभावना है जिसे पुनर्प्राप्त करना अधिक महंगा है) तक पहुंच के बीच लागत में अंतर से संबंधित है। _A<sub>a</sub>_ लेनदेन द्वारा पहले एक्सेस किए गए पतों की सूची है, जिसे इसलिए एक्सेस करना सस्ता होना चाहिए, जैसा कि पृ. 8 पर अनुभाग 6.1 में परिभाषित किया गया है। आप इस विषय के बारे में [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929) में और पढ़ सकते हैं।

| मूल्य | मेमोनिक | δ  | α  | वर्णन                                                                                                                                           |
| ----: | ------- | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x8F | DUP16   | 16 | 17 | 16वें स्टैक आइटम को डुप्लिकेट करें।                                                                                                             |
|       |         |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

ध्यान दें कि किसी भी स्टैक आइटम का उपयोग करने के लिए, हमें इसे पॉप करने की आवश्यकता है, जिसका अर्थ है कि हमें इसके ऊपर के सभी स्टैक आइटम को भी पॉप करने की आवश्यकता है। [`DUP<n>`](https://www.evm.codes/#8f) और [`SWAP<n>`](https://www.evm.codes/#9f) के मामले में, इसका मतलब है कि सोलह मानों तक पॉप और फिर पुश करना होगा।

## 9.5 निष्पादन चक्र {#95-exec-cycle}

अब जब हमारे पास सभी भाग हैं, तो हम अंततः समझ सकते हैं कि EVM के निष्पादन चक्र को कैसे प्रलेखित किया जाता है।

समीकरण (155) कहता है कि दी गई स्टेट:

- _σ_ (वैश्विक ब्लॉकचेन स्टेट)
- _μ_ (EVM स्टेट)
- _A_ (सबस्टेट, लेनदेन समाप्त होने पर होने वाले परिवर्तन)
- _I_ (निष्पादन वातावरण)

नई स्टेट _(σ', μ', A', I')_ है।

समीकरण (156)-(158) स्टैक और उसमें एक ऑपकोड (_μ<sub>s</sub>_) के कारण होने वाले परिवर्तन को परिभाषित करते हैं। समीकरण (159) गैस (_μ<sub>g</sub>_) में परिवर्तन है। समीकरण (160) प्रोग्राम काउंटर (_μ<sub>pc</sub>_) में परिवर्तन है। अंत में, समीकरण (161)-(164) निर्दिष्ट करते हैं कि अन्य पैरामीटर समान रहते हैं, जब तक कि ऑपकोड द्वारा स्पष्ट रूप से नहीं बदला जाता है।

इसके साथ EVM पूरी तरह से परिभाषित है।

## निष्कर्ष {#conclusion}

गणितीय संकेतन सटीक है और इसने येलो पेपर को इथेरियम के हर विवरण को निर्दिष्ट करने की अनुमति दी है। हालाँकि, इसकी कुछ कमियाँ हैं:

- इसे केवल मनुष्यों द्वारा समझा जा सकता है, जिसका अर्थ है कि [अनुपालन परीक्षण](https://github.com/ethereum/tests) मैन्युअल रूप से लिखे जाने चाहिए।
- प्रोग्रामर कंप्यूटर कोड समझते हैं।
  वे गणितीय संकेतन को समझ भी सकते हैं और नहीं भी।

शायद इन्हीं कारणों से, नए [कन्सेंसस लेयर स्पेक्स](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md) Python में लिखे गए हैं। [Python में एक्ज़ीक्यूशन लेयर स्पेक्स](https://ethereum.github.io/execution-specs) हैं, लेकिन वे पूर्ण नहीं हैं। जब तक और जब तक पूरे येलो पेपर का Python या इसी तरह की भाषा में अनुवाद नहीं किया जाता, तब तक येलो पेपर सेवा में रहेगा, और इसे पढ़ने में सक्षम होना सहायक है।
