---
title: सेफ्टी रेल्स के साथ ERC-20
description: लोगों को मूर्खतापूर्ण गलतियों से बचने में कैसे मदद करें
author: ओरी पोमेरेन्ट्ज़
lang: hi
tags: [ "erc-20" ]
skill: beginner
published: 2022-08-15
---

## परिचय {#introduction}

एथेरियम के बारे में एक बड़ी बात यह है कि कोई भी केंद्रीय प्राधिकरण नहीं है जो आपके लेनदेन को संशोधित या पूर्ववत कर सकता है। एथेरियम के साथ एक बड़ी समस्या यह है कि यूज़र की गलतियों या अवैध लेनदेन को पूर्ववत करने की शक्ति वाला कोई केंद्रीय प्राधिकरण नहीं है। इस लेख में आप उन कुछ सामान्य गलतियों के बारे में जानेंगे जो यूज़र [ERC-20](/developers/docs/standards/tokens/erc-20/) टोकन के साथ करते हैं, साथ ही यह भी जानेंगे कि ERC-20 अनुबंध कैसे बनाएं जो यूज़र को उन गलतियों से बचने में मदद करते हैं, या जो एक केंद्रीय प्राधिकरण को कुछ शक्ति देते हैं (उदाहरण के लिए खातों को फ्रीज करने के लिए)।

ध्यान दें कि जब हम [OpenZeppelin ERC-20 टोकन अनुबंध](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) का उपयोग करेंगे, तो यह लेख इसे बहुत विस्तार से नहीं समझाता है। आप यह जानकारी [यहां](/developers/tutorials/erc20-annotated-code) पा सकते हैं।

यदि आप पूरा सोर्स कोड देखना चाहते हैं:

1. [Remix IDE](https://remix.ethereum.org/) खोलें।
2. क्लोन github आइकन (![clone github icon](icon-clone.png)) पर क्लिक करें।
3. Github रिपॉजिटरी `https://github.com/qbzzt/20220815-erc20-safety-rails` को क्लोन करें।
4. **contracts > erc20-safety-rails.sol** खोलें।

## एक ERC-20 अनुबंध बनाना {#creating-an-erc-20-contract}

इससे पहले कि हम सेफ्टी रेल कार्यक्षमता जोड़ सकें, हमें एक ERC-20 अनुबंध की आवश्यकता है। इस लेख में हम [the OpenZeppelin Contracts Wizard](https://docs.openzeppelin.com/contracts/5.x/wizard) का उपयोग करेंगे। इसे दूसरे ब्राउज़र में खोलें और इन निर्देशों का पालन करें:

1. **ERC20** चुनें।

2. ये सेटिंग्स दर्ज करें:

   | पैरामीटर       | मूल्य            |
   | -------------- | ---------------- |
   | नाम            | SafetyRailsToken |
   | प्रतीक         | SAFE             |
   | प्रीमिंट       | 1000             |
   | विशेषताएँ      | कोई नहीं         |
   | एक्सेस कंट्रोल | Ownable          |
   | अपग्रेडेबिलिटी | कोई नहीं         |

3. ऊपर स्क्रॉल करें और **Remix में खोलें** (Remix के लिए) पर क्लिक करें या एक अलग वातावरण का उपयोग करने के लिए **डाउनलोड** करें। मैं यह मान लूंगा कि आप Remix का उपयोग कर रहे हैं, यदि आप कुछ और उपयोग करते हैं तो बस उपयुक्त परिवर्तन करें।

4. अब हमारे पास एक पूरी तरह से कार्यात्मक ERC-20 अनुबंध है। आयातित कोड देखने के लिए आप `.deps` > `npm` का विस्तार कर सकते हैं।

5. यह देखने के लिए अनुबंध को संकलित करें, डिप्लॉय करें और उसके साथ प्रयोग करें कि यह एक ERC-20 अनुबंध के रूप में कार्य करता है। अगर आपको Remix का उपयोग करना सीखना है, तो [इस ट्यूटोरियल का उपयोग करें](https://remix.ethereum.org/?#activate=udapp,solidity,LearnEth)।

## आम गलतियाँ {#common-mistakes}

### गलतियाँ {#the-mistakes}

यूज़र कभी-कभी गलत पते पर टोकन भेज देते हैं। हालांकि हम यह जानने के लिए उनके मन को नहीं पढ़ सकते कि वे क्या करना चाहते थे, दो प्रकार की त्रुटियां हैं जो बहुत होती हैं और जिनका पता लगाना आसान है:

1. टोकन को अनुबंध के अपने पते पर भेजना। उदाहरण के लिए, [Optimism का OP टोकन](https://optimism.mirror.xyz/qvd0WfuLKnePm1Gxb9dpGchPf5uDz5NSMEFdgirDS4c) दो महीने से भी कम समय में [120,000 से अधिक](https://optimism.blockscout.com/address/0x4200000000000000000000000000000000000042) OP टोकन जमा करने में कामयाब रहा। यह एक महत्वपूर्ण मात्रा में धन का प्रतिनिधित्व करता है जिसे संभवतः लोगों ने खो दिया है।

2. टोकन को एक खाली पते पर भेजना, जो [बाहरी स्वामित्व वाले खाते](/developers/docs/accounts/#externally-owned-accounts-and-key-pairs) या [स्मार्ट अनुबंध](/developers/docs/smart-contracts) से मेल नहीं खाता है। हालांकि मेरे पास इस बारे में आंकड़े नहीं हैं कि ऐसा कितनी बार होता है, [एक घटना में 20,000,000 टोकन की लागत आ सकती थी](https://gov.optimism.io/t/message-to-optimism-community-from-wintermute/2595)।

### स्थानांतरण को रोकना {#preventing-transfers}

OpenZeppelin ERC-20 अनुबंध में [एक हुक, `_beforeTokenTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L364-L368) शामिल है, जिसे टोकन स्थानांतरित होने से पहले कॉल किया जाता है। डिफ़ॉल्ट रूप से यह हुक कुछ भी नहीं करता है, लेकिन हम इस पर अपनी खुद की कार्यक्षमता लटका सकते हैं, जैसे कि जांच जो कोई समस्या होने पर रिवर्ट हो जाती है।

हुक का उपयोग करने के लिए, कंस्ट्रक्टर के बाद इस फ़ंक्शन को जोड़ें:

```solidity
    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal virtual
        override(ERC20)
    {
        super._beforeTokenTransfer(from, to, amount);
    }
```

यदि आप Solidity से बहुत परिचित नहीं हैं तो इस फ़ंक्शन के कुछ हिस्से नए हो सकते हैं:

```solidity
        internal virtual
```

`virtual` कीवर्ड का मतलब है कि जैसे हमने `ERC20` से कार्यक्षमता विरासत में ली है और इस फ़ंक्शन को ओवरराइड किया है, वैसे ही अन्य अनुबंध हमसे विरासत में ले सकते हैं और इस फ़ंक्शन को ओवरराइड कर सकते हैं।

```solidity
        override(ERC20)
```

हमें स्पष्ट रूप से निर्दिष्ट करना होगा कि हम `_beforeTokenTransfer` की ERC20 टोकन परिभाषा को [ओवरराइड](https://docs.soliditylang.org/en/v0.8.15/contracts.html#function-overriding) कर रहे हैं। सामान्य तौर पर, सुरक्षा के दृष्टिकोण से, स्पष्ट परिभाषाएँ अंतर्निहित परिभाषाओं की तुलना में बहुत बेहतर होती हैं - आप यह नहीं भूल सकते कि आपने कुछ किया है यदि यह आपके ठीक सामने है। यही कारण है कि हमें यह निर्दिष्ट करने की आवश्यकता है कि हम किस सुपरक्लास के `_beforeTokenTransfer` को ओवरराइड कर रहे हैं।

```solidity
        super._beforeTokenTransfer(from, to, amount);
```

यह लाइन उस अनुबंध या अनुबंधों के `_beforeTokenTransfer` फ़ंक्शन को कॉल करती है जिससे हमने इसे विरासत में लिया है। इस मामले में, वह केवल `ERC20` है, `Ownable` में यह हुक नहीं है। भले ही वर्तमान में `ERC20._beforeTokenTransfer` कुछ भी नहीं करता है, हम इसे भविष्य में कार्यक्षमता जोड़े जाने की स्थिति में कॉल करते हैं (और फिर हम अनुबंध को फिर से डिप्लॉय करने का निर्णय लेते हैं, क्योंकि डिप्लॉयमेंट के बाद अनुबंध नहीं बदलते हैं)।

### आवश्यकताओं को कोडिंग करना {#coding-the-requirements}

हम इन आवश्यकताओं को फ़ंक्शन में जोड़ना चाहते हैं:

- `to` पता `address(this)` के बराबर नहीं हो सकता है, जो कि स्वयं ERC-20 अनुबंध का पता है।
- `to` पता खाली नहीं हो सकता, यह या तो होना चाहिए:
  - एक बाहरी स्वामित्व वाला खाता (EOA)। हम सीधे यह नहीं जांच सकते कि कोई पता EOA है या नहीं, लेकिन हम किसी पते का ETH बैलेंस देख सकते हैं। EOA में लगभग हमेशा एक बैलेंस होता है, भले ही उनका अब उपयोग नहीं किया जाता हो - उन्हें आखिरी wei तक साफ़ करना मुश्किल है।
  - एक स्मार्ट अनुबंध। यह परीक्षण करना कि कोई पता स्मार्ट अनुबंध है या नहीं, थोड़ा कठिन है। एक ऑपकोड है जो बाहरी कोड की लंबाई की जांच करता है, जिसे [`EXTCODESIZE`](https://www.evm.codes/#3b) कहा जाता है, लेकिन यह सीधे Solidity में उपलब्ध नहीं है। इसके लिए हमें [Yul](https://docs.soliditylang.org/en/v0.8.15/yul.html) का उपयोग करना होगा, जो कि EVM असेंबली है। Solidity से अन्य मान हैं जिनका हम उपयोग कर सकते हैं ([`<address>.code` और `<address>.codehash`](https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#members-of-address-types)), लेकिन उनकी लागत अधिक है।

आइए नए कोड को लाइन दर लाइन देखें:

```solidity
        require(to != address(this), "अनुबंध पते पर टोकन नहीं भेज सकते");
```

यह पहली आवश्यकता है, जांचें कि `to` और `this(address)` एक ही चीज़ नहीं हैं।

```solidity
        bool isToContract;
        assembly {
           isToContract := gt(extcodesize(to), 0)
        }
```

इस तरह हम जांचते हैं कि कोई पता एक अनुबंध है या नहीं। हम सीधे Yul से आउटपुट प्राप्त नहीं कर सकते हैं, इसलिए इसके बजाय हम परिणाम रखने के लिए एक चर परिभाषित करते हैं (इस मामले में `isToContract`)। Yul के काम करने का तरीका यह है कि प्रत्येक ऑपकोड को एक फ़ंक्शन माना जाता है। तो पहले हम अनुबंध का आकार प्राप्त करने के लिए [`EXTCODESIZE`](https://www.evm.codes/#3b) को कॉल करते हैं, और फिर यह जांचने के लिए [`GT`](https://www.evm.codes/#11) का उपयोग करते हैं कि यह शून्य नहीं है (हम अहस्ताक्षरित पूर्णांकों के साथ काम कर रहे हैं, इसलिए निश्चित रूप से यह नकारात्मक नहीं हो सकता है)। फिर हम परिणाम को `isToContract` में लिखते हैं।

```solidity
        require(to.balance != 0 || isToContract, "खाली पते पर टोकन नहीं भेज सकते");
```

और अंत में, हमारे पास खाली पतों के लिए वास्तविक जांच है।

## प्रशासनिक पहुंच {#admin-access}

कभी-कभी एक प्रशासक होना उपयोगी होता है जो गलतियों को पूर्ववत कर सकता है। दुरुपयोग की संभावना को कम करने के लिए, यह प्रशासक एक [मल्टीसिग](https://blog.logrocket.com/security-choices-multi-signature-wallets/) हो सकता है ताकि कई लोगों को एक कार्रवाई पर सहमत होना पड़े। इस लेख में हमारे पास दो प्रशासनिक सुविधाएँ होंगी:

1. खातों को फ्रीज और अनफ्रीज करना। यह उपयोगी हो सकता है, उदाहरण के लिए, जब कोई खाता हैक हो सकता है।
2. संपत्ति की सफाई।

   कभी-कभी धोखेबाज वैधता हासिल करने के लिए वास्तविक टोकन के अनुबंध में धोखाधड़ी वाले टोकन भेजते हैं। उदाहरण के लिए, [यहां देखें](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe?tab=holders)। वैध ERC-20 अनुबंध [0x4200....0042](https://optimism.blockscout.com/token/0x4200000000000000000000000000000000000042) है। घोटाला जो यह होने का नाटक करता है वह [0x234....bbe](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe) है।

   यह भी संभव है कि लोग गलती से हमारे अनुबंध में वैध ERC-20 टोकन भेज दें, जो उन्हें बाहर निकालने का एक तरीका चाहने का एक और कारण है।

OpenZeppelin प्रशासनिक पहुंच को सक्षम करने के लिए दो तंत्र प्रदान करता है:

- [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/access-control#ownership-and-ownable) अनुबंधों का एक ही मालिक होता है। जिन फ़ंक्शंस में `onlyOwner` [संशोधक](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm) होता है, उन्हें केवल उस स्वामी द्वारा ही कॉल किया जा सकता है। मालिक किसी और को स्वामित्व हस्तांतरित कर सकते हैं या इसे पूरी तरह से त्याग सकते हैं। अन्य सभी खातों के अधिकार आमतौर पर समान होते हैं।
- [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/access-control#role-based-access-control) अनुबंधों में [भूमिका आधारित अभिगम नियंत्रण (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control) होता है।

सरलता के लिए, इस लेख में हम `Ownable` का उपयोग करते हैं।

### अनुबंधों को फ्रीज और अनफ्रीज करना {#freezing-and-thawing-contracts}

अनुबंधों को फ्रीज और अनफ्रीज करने के लिए कई बदलावों की आवश्यकता होती है:

- [बूलियन](https://en.wikipedia.org/wiki/Boolean_data_type) के लिए पतों से एक [मैपिंग](https://www.tutorialspoint.com/solidity/solidity_mappings.htm) यह ट्रैक करने के लिए कि कौन से पते फ्रीज हैं। सभी मान शुरू में शून्य होते हैं, जिसे बूलियन मानों के लिए गलत माना जाता है। यह वही है जो हम चाहते हैं क्योंकि डिफ़ॉल्ट रूप से खाते फ्रीज नहीं होते हैं।

  ```solidity
      mapping(address => bool) public frozenAccounts;
  ```

- [इवेंट्स](https://www.tutorialspoint.com/solidity/solidity_events.htm) किसी भी इच्छुक व्यक्ति को सूचित करने के लिए जब कोई खाता फ्रीज या अनफ्रीज किया जाता है। तकनीकी रूप से इन कार्यों के लिए इवेंट्स की आवश्यकता नहीं होती है, लेकिन यह ऑफ-चेन कोड को इन इवेंट्स को सुनने और यह जानने में मदद करता है कि क्या हो रहा है। जब कुछ ऐसा होता है जो किसी और के लिए प्रासंगिक हो सकता है तो स्मार्ट अनुबंध के लिए उन्हें उत्सर्जित करना अच्छा शिष्टाचार माना जाता है।

  इवेंट्स को अनुक्रमित किया जाता है ताकि यह खोजना संभव हो सके कि किसी खाते को कितनी बार फ्रीज या अनफ्रीज किया गया है।

  ```solidity
    // जब खाते फ्रीज या अनफ्रीज हो जाते हैं
    event AccountFrozen(address indexed _addr);
    event AccountThawed(address indexed _addr);
  ```

- खातों को फ्रीज और अनफ्रीज करने के लिए फ़ंक्शंस। ये दो फ़ंक्शन लगभग समान हैं, इसलिए हम केवल फ्रीज फ़ंक्शन पर जाएंगे।

  ```solidity
      function freezeAccount(address addr)
        public
        onlyOwner
  ```

  [`public`](https://www.tutorialspoint.com/solidity/solidity_contracts.htm) के रूप में चिह्नित फ़ंक्शंस को अन्य स्मार्ट अनुबंधों से या सीधे एक लेनदेन द्वारा कॉल किया जा सकता है।

  ```solidity
    {
        require(!frozenAccounts[addr], "खाता पहले से ही फ्रीज है");
        frozenAccounts[addr] = true;
        emit AccountFrozen(addr);
    }  // freezeAccount
  ```

  यदि खाता पहले से ही फ्रीज है, तो रिवर्ट करें। अन्यथा, इसे फ्रीज करें और एक इवेंट `emit` करें।

- फ्रीज खाते से पैसे को स्थानांतरित होने से रोकने के लिए `_beforeTokenTransfer` बदलें। ध्यान दें कि फ्रीज खाते में अभी भी पैसा स्थानांतरित किया जा सकता है।

  ```solidity
       require(!frozenAccounts[from], "खाता फ्रीज है");
  ```

### संपत्ति की सफाई {#asset-cleanup}

इस अनुबंध द्वारा रखे गए ERC-20 टोकन को जारी करने के लिए हमें उस टोकन अनुबंध पर एक फ़ंक्शन को कॉल करने की आवश्यकता है, जिससे वे संबंधित हैं, या तो [`transfer`](https://eips.ethereum.org/EIPS/eip-20#transfer) या [`approve`](https://eips.ethereum.org/EIPS/eip-20#approve)। इस मामले में भत्ते पर गैस बर्बाद करने का कोई मतलब नहीं है, हम सीधे स्थानांतरण भी कर सकते हैं।

```solidity
    function cleanupERC20(
        address erc20,
        address dest
    )
        public
        onlyOwner
    {
        IERC20 token = IERC20(erc20);
```

जब हम पता प्राप्त करते हैं तो यह एक अनुबंध के लिए एक ऑब्जेक्ट बनाने के लिए सिंटैक्स है। हम ऐसा इसलिए कर सकते हैं क्योंकि हमारे पास सोर्स कोड के हिस्से के रूप में ERC20 टोकन के लिए परिभाषा है (लाइन 4 देखें), और उस फ़ाइल में [IERC20 के लिए परिभाषा](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) शामिल है, जो एक OpenZeppelin ERC-20 अनुबंध के लिए इंटरफ़ेस है।

```solidity
        uint balance = token.balanceOf(address(this));
        token.transfer(dest, balance);
    }
```

यह एक सफाई फ़ंक्शन है, इसलिए संभवतः हम कोई टोकन नहीं छोड़ना चाहते हैं। यूज़र से मैन्युअल रूप से बैलेंस प्राप्त करने के बजाय, हम प्रक्रिया को स्वचालित भी कर सकते हैं।

## निष्कर्ष {#conclusion}

यह एक आदर्श समाधान नहीं है - "यूज़र ने गलती की" समस्या का कोई आदर्श समाधान नहीं है। हालांकि, इस तरह की जांच का उपयोग करने से कम से कम कुछ गलतियों को रोका जा सकता है। खातों को फ्रीज करने की क्षमता, जबकि खतरनाक है, हैकर को चोरी किए गए धन से वंचित करके कुछ हैक के नुकसान को सीमित करने के लिए इस्तेमाल किया जा सकता है।

[मेरे और काम के लिए यहाँ देखें](https://cryptodocguy.pro/)।
