---
title: स्मार्ट अनुबंध सुरक्षा दिशानिर्देश
description: अपना डैप बनाते समय ध्यान रखने योग्य सुरक्षा दिशानिर्देशों की एक चेकलिस्ट
author: "Trailofbits"
tags: [ "सोलिडीटी", "स्मार्ट अनुबंध", "सुरक्षा" ]
skill: intermediate
lang: hi
published: 2020-09-06
source: सुरक्षित अनुबंध बनाना
sourceUrl: https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/guidelines.md
---

अधिक सुरक्षित स्मार्ट अनुबंध बनाने के लिए इन उच्च-स्तरीय सिफारिशों का पालन करें।

## डिज़ाइन दिशानिर्देश {#design-guidelines}

कोड की कोई भी पंक्ति लिखने से पहले, अनुबंध के डिज़ाइन पर समय से पहले चर्चा की जानी चाहिए।

### प्रलेखन और विनिर्देश {#documentation-and-specifications}

प्रलेखन विभिन्न स्तरों पर लिखा जा सकता है, और अनुबंधों को लागू करते समय अपडेट किया जाना चाहिए:

- **सिस्टम का एक सरल अंग्रेजी विवरण**, यह बताते हुए कि अनुबंध क्या करते हैं और कोडबेस पर कोई भी धारणा।
- **स्कीमा और आर्किटेक्चरल आरेख**, जिसमें अनुबंध इंटरैक्शन और सिस्टम की स्टेट मशीन शामिल हैं। [Slither प्रिंटर](https://github.com/crytic/slither/wiki/Printer-documentation) इन स्कीमा को बनाने में मदद कर सकते हैं।
- **संपूर्ण कोड प्रलेखन**, सॉलिडिटी के लिए [Natspec प्रारूप](https://docs.soliditylang.org/en/develop/natspec-format.html) का उपयोग किया जा सकता है।

### ऑन-चेन बनाम ऑफ-चेन गणना {#onchain-vs-offchain-computation}

- **जितना हो सके उतना कोड ऑफ-चेन रखें।** ऑन-चेन परत को छोटा रखें। ऑफ-चेन कोड के साथ डेटा को इस तरह से प्री-प्रोसेस करें कि ऑन-चेन सत्यापन सरल हो। क्या आपको एक क्रमित सूची की आवश्यकता है? सूची को ऑफ-चेन सॉर्ट करें, फिर केवल ऑन-चेन इसके क्रम की जांच करें।

### अपग्रेडेबिलिटी {#upgradeability}

हमने [हमारे ब्लॉगपोस्ट](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/) में विभिन्न अपग्रेडेबिलिटी समाधानों पर चर्चा की। कोई भी कोड लिखने से पहले अपग्रेडेबिलिटी का समर्थन करना है या नहीं, यह सोच-समझकर चुनें। यह निर्णय प्रभावित करेगा कि आप अपने कोड की संरचना कैसे करते हैं। सामान्य तौर पर, हम अनुशंसा करते हैं:

- **अपग्रेडेबिलिटी पर [अनुबंध माइग्रेशन](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) को प्राथमिकता देना।** माइग्रेशन सिस्टम में अपग्रेड करने योग्य सिस्टम के समान कई फायदे हैं, बिना उनकी कमियों के।
- **delegatecallproxy वाले पैटर्न पर डेटा पृथक्करण पैटर्न का उपयोग करना।** यदि आपके प्रोजेक्ट में एक स्पष्ट एब्स्ट्रैक्शन पृथक्करण है, तो डेटा पृथक्करण का उपयोग करके अपग्रेडेबिलिटी के लिए केवल कुछ समायोजन की आवश्यकता होगी। delegatecallproxy के लिए EVM विशेषज्ञता की आवश्यकता होती है और इसमें त्रुटियों की बहुत अधिक संभावना होती है।
- **परिनियोजन से पहले माइग्रेशन/अपग्रेड प्रक्रिया का दस्तावेजीकरण करें।** यदि आपको बिना किसी दिशानिर्देश के तनाव में प्रतिक्रिया देनी पड़ती है, तो आप गलतियाँ करेंगे। पालन की जाने वाली प्रक्रिया को पहले से लिख लें। इसमें शामिल होना चाहिए:
  - वे कॉल जो नए अनुबंधों को आरंभ करते हैं
  - कुंजियाँ कहाँ संग्रहीत हैं और उन तक कैसे पहुँचें
  - परिनियोजन की जाँच कैसे करें! एक पोस्ट-डिप्लॉयमेंट स्क्रिप्ट विकसित और परीक्षण करें।

## कार्यान्वयन दिशानिर्देश {#implementation-guidelines}

**सरलता के लिए प्रयास करें।** हमेशा उस सरलतम समाधान का उपयोग करें जो आपके उद्देश्य के लिए उपयुक्त हो। आपकी टीम का कोई भी सदस्य आपके समाधान को समझने में सक्षम होना चाहिए।

### फ़ंक्शन संरचना {#function-composition}

आपके कोडबेस की वास्तुकला को आपके कोड की समीक्षा करना आसान बनाना चाहिए। ऐसी वास्तुशिल्प पसंदों से बचें जो इसकी शुद्धता के बारे में तर्क करने की क्षमता को कम करती हैं।

- **अपने सिस्टम के तर्क को विभाजित करें**, या तो कई अनुबंधों के माध्यम से या समान कार्यों को एक साथ समूहित करके (उदाहरण के लिए, प्रमाणीकरण, अंकगणित, ...)।
- **एक स्पष्ट उद्देश्य के साथ छोटे फ़ंक्शन लिखें।** यह आसान समीक्षा की सुविधा प्रदान करेगा और व्यक्तिगत घटकों के परीक्षण की अनुमति देगा।

### इन्हेरिटेंस {#inheritance}

- **इन्हेरिटेंस को प्रबंधनीय रखें।** तर्क को विभाजित करने के लिए इन्हेरिटेंस का उपयोग किया जाना चाहिए, हालांकि, आपके प्रोजेक्ट का लक्ष्य इन्हेरिटेंस ट्री की गहराई और चौड़ाई को कम करना होना चाहिए।
- **अनुबंधों के पदानुक्रम की जांच के लिए Slither के [इन्हेरिटेंस प्रिंटर](https://github.com/crytic/slither/wiki/Printer-documentation#inheritance-graph) का उपयोग करें।** इन्हेरिटेंस प्रिंटर आपको पदानुक्रम के आकार की समीक्षा करने में मदद करेगा।

### घटनाएँ {#events}

- **सभी महत्वपूर्ण परिचालनों को लॉग करें।** इवेंट्स विकास के दौरान अनुबंध को डीबग करने में मदद करेंगे, और परिनियोजन के बाद इसकी निगरानी करेंगे।

### ज्ञात नुकसानों से बचें {#avoid-known-pitfalls}

- **सबसे आम सुरक्षा मुद्दों से अवगत रहें।** सामान्य मुद्दों के बारे में जानने के लिए कई ऑनलाइन संसाधन हैं, जैसे [Ethernaut CTF](https://ethernaut.openzeppelin.com/), [Capture the Ether](https://capturetheether.com/), या [Not so smart contracts](https://github.com/crytic/not-so-smart-contracts/)।
- **[सॉलिडिटी प्रलेखन](https://docs.soliditylang.org/en/latest/) में चेतावनियों के अनुभागों से अवगत रहें।** चेतावनी अनुभाग आपको भाषा के गैर-स्पष्ट व्यवहार के बारे में सूचित करेंगे।

### निर्भरताएँ {#dependencies}

- **अच्छी तरह से परीक्षण की गई लाइब्रेरी का उपयोग करें।** अच्छी तरह से परीक्षण की गई लाइब्रेरी से कोड आयात करना आपके द्वारा बग्गी कोड लिखने की संभावना को कम कर देगा। यदि आप एक ERC20 अनुबंध लिखना चाहते हैं, तो [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) का उपयोग करें।
- **एक निर्भरता प्रबंधक का उपयोग करें; कोड कॉपी-पेस्ट करने से बचें।** यदि आप किसी बाहरी स्रोत पर भरोसा करते हैं, तो आपको इसे मूल स्रोत के साथ अद्यतन रखना होगा।

### परीक्षण और सत्यापन {#testing-and-verification}

- **संपूर्ण यूनिट-टेस्ट लिखें।** उच्च-गुणवत्ता वाले सॉफ़्टवेयर बनाने के लिए एक व्यापक परीक्षण सूट महत्वपूर्ण है।
- **[Slither](https://github.com/crytic/slither), [Echidna](https://github.com/crytic/echidna) और [Manticore](https://github.com/trailofbits/manticore) कस्टम जांच और गुण लिखें।** स्वचालित उपकरण यह सुनिश्चित करने में मदद करेंगे कि आपका अनुबंध सुरक्षित है। कुशल जांच और गुण कैसे लिखें, यह जानने के लिए इस गाइड के बाकी हिस्सों की समीक्षा करें।
- **[crytic.io](https://crytic.io/) का उपयोग करें।** Crytic GitHub के साथ एकीकृत होता है, निजी Slither डिटेक्टरों तक पहुंच प्रदान करता है, और Echidna से कस्टम प्रॉपर्टी जांच चलाता है।

### Solidity {#solidity}

- **सॉलिडिटी 0.4 और 0.6 पर सॉलिडिटी 0.5 को प्राथमिकता दें।** हमारी राय में, सॉलिडिटी 0.5, 0.4 की तुलना में अधिक सुरक्षित है और इसमें बेहतर अंतर्निहित प्रथाएं हैं। सॉलिडिटी 0.6 उत्पादन के लिए बहुत अस्थिर साबित हुआ है और इसे परिपक्व होने के लिए समय चाहिए।
- **संकलन के लिए एक स्थिर रिलीज का उपयोग करें; चेतावनियों की जांच के लिए नवीनतम रिलीज का उपयोग करें।** जांचें कि आपके कोड में नवीनतम कंपाइलर संस्करण के साथ कोई रिपोर्ट की गई समस्या नहीं है। हालांकि, सॉलिडिटी का एक तेज़ रिलीज़ चक्र है और इसमें कंपाइलर बग का इतिहास है, इसलिए हम परिनियोजन के लिए नवीनतम संस्करण की अनुशंसा नहीं करते हैं (Slither की [solc संस्करण अनुशंसा](https://github.com/crytic/slither/wiki/Detector-Documentation#recommendation-33) देखें)।
- **इनलाइन असेंबली का उपयोग न करें।** असेंबली के लिए EVM विशेषज्ञता की आवश्यकता होती है। यदि आपने येलो पेपर में _महारत हासिल_ नहीं की है तो EVM कोड न लिखें।

## परिनियोजन दिशानिर्देश {#deployment-guidelines}

एक बार जब अनुबंध विकसित और परिनियोजित हो जाता है:

- **अपने अनुबंधों की निगरानी करें।** लॉग देखें, और अनुबंध या वॉलेट से छेड़छाड़ की स्थिति में प्रतिक्रिया करने के लिए तैयार रहें।
- **अपनी संपर्क जानकारी [blockchain-security-contacts](https://github.com/crytic/blockchain-security-contacts) में जोड़ें।** यह सूची तीसरे पक्षों को आपसे संपर्क करने में मदद करती है यदि किसी सुरक्षा दोष का पता चलता है।
- **विशेषाधिकार प्राप्त यूज़र्स के वॉलेट सुरक्षित करें।** यदि आप हार्डवेयर वॉलेट में कुंजियाँ संग्रहीत करते हैं तो हमारी [सर्वोत्तम प्रथाओं](https://blog.trailofbits.com/2018/11/27/10-rules-for-the-secure-use-of-cryptocurrency-hardware-wallets/) का पालन करें।
- **घटना प्रतिक्रिया योजना रखें।** इस पर विचार करें कि आपके स्मार्ट अनुबंधों से छेड़छाड़ की जा सकती है। भले ही आपके अनुबंध बग से मुक्त हों, एक हमलावर अनुबंध के मालिक की कुंजियों पर नियंत्रण कर सकता है।
