---
title: "रिकर्सिव-लेंथ प्रीफ़िक्स (RLP) सीरियलाइज़ेशन"
description: "Ethereum की निष्पादन परत में rlp एन्कोडिंग की एक परिभाषा।"
lang: hi
sidebarDepth: 2
---

रिकर्सिव लेंथ प्रीफ़िक्स (RLP) सीरियलाइज़ेशन का Ethereum के निष्पादन क्लाइंट में बड़े पैमाने पर उपयोग किया जाता है। RLP नोड्स के बीच डेटा के हस्तांतरण को स्पेस-एफ़िशिएंट फ़ॉर्मैट में मानकीकृत करता है। RLP का उद्देश्य बाइनरी डेटा के मनमाने ढंग से नेस्टेड ऐरे को एन्कोड करना है, और RLP, Ethereum की निष्पादन परत में ऑब्जेक्ट को सीरियलाइज़ करने के लिए उपयोग की जाने वाली प्राथमिक एन्कोडिंग विधि है। RLP का मुख्य उद्देश्य संरचना को एन्कोड करना है; धनात्मक पूर्णांकों के अपवाद के साथ, RLP विशिष्ट डेटा प्रकारों (जैसे, स्ट्रिंग्स, फ़्लोट्स) को एन्कोड करने का काम हायर-ऑर्डर प्रोटोकॉल को सौंपता है। धनात्मक पूर्णांकों को बिना किसी लीडिंग ज़ीरो के बिग-एंडियन बाइनरी फ़ॉर्म में दर्शाया जाना चाहिए (इस प्रकार पूर्णांक मान शून्य को खाली बाइट ऐरे के बराबर बनाता है)। लीडिंग ज़ीरो वाले डीसीरियलाइज़्ड धनात्मक पूर्णांकों को RLP का उपयोग करने वाले किसी भी हायर-ऑर्डर प्रोटोकॉल द्वारा अमान्य माना जाना चाहिए।

[एथेरियम येलो पेपर (परिशिष्ट B)](https://ethereum.github.io/yellowpaper/paper.pdf#page=19) में अधिक जानकारी।

किसी डिक्शनरी को एन्कोड करने के लिए RLP का उपयोग करने के लिए, दो सुझाए गए कैनोनिकल फ़ॉर्म हैं:

- लेक्सिकोग्राफ़िक क्रम में कीज़ के साथ `[[k1,v1],[k2,v2]...]` का उपयोग करें
- हायर-लेवल पेट्रीसिया ट्री एन्कोडिंग का उपयोग करें जैसा कि Ethereum करता है

## परिभाषा {#definition}

RLP एन्कोडिंग फ़ंक्शन एक आइटम लेता है। एक आइटम को इस प्रकार परिभाषित किया गया है:

- एक स्ट्रिंग (यानी, बाइट ऐरे) एक आइटम है
- आइटम की एक सूची एक आइटम है
- एक धनात्मक पूर्णांक एक आइटम है

उदाहरण के लिए, निम्नलिखित सभी आइटम हैं:

- एक खाली स्ट्रिंग;
- "cat" शब्द वाली स्ट्रिंग;
- किसी भी संख्या में स्ट्रिंग वाली सूची;
- और `["cat", ["puppy", "cow"], "horse", [[]], "pig", [""], "sheep"]` जैसी अधिक जटिल डेटा संरचनाएँ।
- संख्या `100`

ध्यान दें कि इस पृष्ठ के बाकी हिस्सों के संदर्भ में, 'स्ट्रिंग' का अर्थ है "बाइनरी डेटा के बाइट्स की एक निश्चित संख्या"; किसी विशेष एन्कोडिंग का उपयोग नहीं किया जाता है, और स्ट्रिंग्स की सामग्री के बारे में कोई जानकारी निहित नहीं है (नॉन-मिनिमल धनात्मक पूर्णांकों के विरुद्ध नियम के अनुसार आवश्यक को छोड़कर)।

RLP एन्कोडिंग को इस प्रकार परिभाषित किया गया है:

- एक धनात्मक पूर्णांक के लिए, इसे सबसे छोटे बाइट ऐरे में बदल दिया जाता है, जिसकी बिग-एंडियन व्याख्या पूर्णांक है, और फिर नीचे दिए गए नियमों के अनुसार स्ट्रिंग के रूप में एन्कोड किया जाता है।
- एक एकल बाइट के लिए जिसका मान `[0x00, 0x7f]` (दशमलव `[0, 127]`) रेंज में है, वह बाइट स्वयं का RLP एन्कोडिंग है।
- अन्यथा, यदि कोई स्ट्रिंग 0-55 बाइट लंबी है, तो RLP एन्कोडिंग में **0x80** (दशमलव 128) मान वाला एक एकल बाइट, उसके बाद स्ट्रिंग की लंबाई और फिर स्ट्रिंग शामिल होती है। इस प्रकार पहले बाइट की रेंज `[0x80, 0xb7]` (दशमलव `[128, 183]`) है।
- यदि कोई स्ट्रिंग 55 बाइट से अधिक लंबी है, तो RLP एन्कोडिंग में **0xb7** (दशमलव 183) मान वाला एक एकल बाइट, उसके बाद बाइनरी फ़ॉर्म में स्ट्रिंग की लंबाई के बाइट्स में लंबाई, उसके बाद स्ट्रिंग की लंबाई, और फिर स्ट्रिंग शामिल होती है। उदाहरण के लिए, एक 1024 बाइट लंबी स्ट्रिंग को `\xb9\x04\x00` (दशमलव `185, 4, 0`) के रूप में एन्कोड किया जाएगा, जिसके बाद स्ट्रिंग होगी। यहाँ, पहले बाइट के रूप में `0xb9` (183 + 2 = 185) है, जिसके बाद 2 बाइट `0x0400` (दशमलव 1024) हैं जो वास्तविक स्ट्रिंग की लंबाई को दर्शाते हैं। इस प्रकार पहले बाइट की रेंज `[0xb8, 0xbf]` (दशमलव `[184, 191]`) है।
- यदि कोई स्ट्रिंग 2^64 बाइट लंबी या उससे अधिक लंबी है, तो इसे एन्कोड नहीं किया जा सकता है।
- यदि किसी सूची का कुल पेलोड (यानी, RLP एन्कोड किए जा रहे उसके सभी आइटमों की संयुक्त लंबाई) 0-55 बाइट लंबा है, तो RLP एन्कोडिंग में **0xc0** मान वाला एक एकल बाइट, उसके बाद पेलोड की लंबाई और फिर आइटमों के RLP एन्कोडिंग का संयोजन शामिल होता है। इस प्रकार पहले बाइट की रेंज `[0xc0, 0xf7]` (दशमलव `[192, 247]`) है।
- यदि किसी सूची का कुल पेलोड 55 बाइट से अधिक लंबा है, तो RLP एन्कोडिंग में **0xf7** मान वाला एक एकल बाइट, उसके बाद बाइनरी फ़ॉर्म में पेलोड की लंबाई के बाइट्स में लंबाई, उसके बाद पेलोड की लंबाई, और फिर आइटमों के RLP एन्कोडिंग का संयोजन शामिल होता है। इस प्रकार पहले बाइट की रेंज `[0xf8, 0xff]` (दशमलव `[248, 255]`) है।

कोड में, यह है:

```python
def rlp_encode(input):
    if isinstance(input,str):
        if len(input) == 1 and ord(input) < 0x80:
            return input
        return encode_length(len(input), 0x80) + input
    elif isinstance(input, list):
        output = ''
        for item in input:
            output += rlp_encode(item)
        return encode_length(len(output), 0xc0) + output

def encode_length(L, offset):
    if L < 56:
         return chr(L + offset)
    elif L < 256**8:
         BL = to_binary(L)
         return chr(len(BL) + offset + 55) + BL
    raise Exception("इनपुट बहुत लंबा है")

def to_binary(x):
    if x == 0:
        return ''
    return to_binary(int(x / 256)) + chr(x % 256)
```

## उदाहरण {#examples}

- स्ट्रिंग "dog" = [ 0x83, 'd', 'o', 'g' ]
- सूची [ "cat", "dog" ] = `[ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]`
- खाली स्ट्रिंग ('null') = `[ 0x80 ]`
- खाली सूची = `[ 0xc0 ]`
- पूर्णांक 0 = `[ 0x80 ]`
- बाइट '\\x00' = `[ 0x00 ]`
- बाइट '\\x0f' = `[ 0x0f ]`
- बाइट्स '\\x04\\x00' = `[ 0x82, 0x04, 0x00 ]`
- तीन का [सेट थिओरेटिकल निरूपण](http://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers), `[ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]`
- स्ट्रिंग "Lorem ipsum dolor sit amet, consectetur adipisicing elit" = `[ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ...` , 'e', 'l', 'i', 't' ]`

## RLP डिकोडिंग {#rlp-decoding}

RLP एन्कोडिंग के नियमों और प्रक्रिया के अनुसार, RLP डिकोड के इनपुट को बाइनरी डेटा के ऐरे के रूप में माना जाता है। RLP डिकोडिंग प्रक्रिया इस प्रकार है:

1. इनपुट डेटा के पहले बाइट (यानी, प्रीफ़िक्स) के अनुसार डेटा प्रकार, वास्तविक डेटा की लंबाई और ऑफ़सेट को डिकोड करना;

2. डेटा के प्रकार और ऑफ़सेट के अनुसार, धनात्मक पूर्णांकों के लिए न्यूनतम एन्कोडिंग नियम का सम्मान करते हुए, डेटा को तदनुसार डिकोड करें;

3. बाकी इनपुट को डिकोड करना जारी रखें;

उनमें से, डेटा प्रकारों और ऑफ़सेट को डिकोड करने के नियम इस प्रकार हैं:

1. डेटा एक स्ट्रिंग है यदि पहले बाइट (यानी, प्रीफ़िक्स) की रेंज [0x00, 0x7f] है, और स्ट्रिंग ठीक पहला बाइट ही है;

2. डेटा एक स्ट्रिंग है यदि पहले बाइट की रेंज [0x80, 0xb7] है, और वह स्ट्रिंग जिसकी लंबाई पहले बाइट माइनस 0x80 के बराबर है, पहले बाइट के बाद आती है;

3. डेटा एक स्ट्रिंग है यदि पहले बाइट की रेंज [0xb8, 0xbf] है, और स्ट्रिंग की लंबाई जिसकी बाइट्स में लंबाई पहले बाइट माइनस 0xb7 के बराबर है, पहले बाइट के बाद आती है, और स्ट्रिंग, स्ट्रिंग की लंबाई के बाद आती है;

4. डेटा एक सूची है यदि पहले बाइट की रेंज [0xc0, 0xf7] है, और सूची के सभी आइटमों के RLP एन्कोडिंग का संयोजन जिसका कुल पेलोड पहले बाइट माइनस 0xc0 के बराबर है, पहले बाइट के बाद आता है;

5. डेटा एक सूची है यदि पहले बाइट की रेंज [0xf8, 0xff] है, और सूची का कुल पेलोड जिसकी लंबाई पहले बाइट माइनस 0xf7 के बराबर है, पहले बाइट के बाद आता है, और सूची के सभी आइटमों के RLP एन्कोडिंग का संयोजन सूची के कुल पेलोड के बाद आता है;

कोड में, यह है:

```python
def rlp_decode(input):
    if len(input) == 0:
        return
    output = ''
    (offset, dataLen, type) = decode_length(input)
    if type is str:
        output = instantiate_str(substr(input, offset, dataLen))
    elif type is list:
        output = instantiate_list(substr(input, offset, dataLen))
    output += rlp_decode(substr(input, offset + dataLen))
    return output

def decode_length(input):
    length = len(input)
    if length == 0:
        raise Exception("इनपुट शून्य है")
    prefix = ord(input[0])
    if prefix <= 0x7f:
        return (0, 1, str)
    elif prefix <= 0xb7 and length > prefix - 0x80:
        strLen = prefix - 0x80
        return (1, strLen, str)
    elif prefix <= 0xbf and length > prefix - 0xb7 and length > prefix - 0xb7 + to_integer(substr(input, 1, prefix - 0xb7)):
        lenOfStrLen = prefix - 0xb7
        strLen = to_integer(substr(input, 1, lenOfStrLen))
        return (1 + lenOfStrLen, strLen, str)
    elif prefix <= 0xf7 and length > prefix - 0xc0:
        listLen = prefix - 0xc0;
        return (1, listLen, list)
    elif prefix <= 0xff and length > prefix - 0xf7 and length > prefix - 0xf7 + to_integer(substr(input, 1, prefix - 0xf7)):
        lenOfListLen = prefix - 0xf7
        listLen = to_integer(substr(input, 1, lenOfListLen))
        return (1 + lenOfListLen, listLen, list)
    raise Exception("इनपुट RLP एन्कोडिंग फ़ॉर्म के अनुरूप नहीं है")

def to_integer(b):
    length = len(b)
    if length == 0:
        raise Exception("इनपुट शून्य है")
    elif length == 1:
        return ord(b[0])
    return ord(substr(b, -1)) + to_integer(substr(b, 0, -1)) * 256
```

## आगे की रीडिंग {#further-reading}

- [Ethereum में RLP](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)
- [Ethereum की आंतरिक कार्यप्रणाली: RLP](https://medium.com/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58)
- [Coglio, A. (2020). ACL2 में Ethereum का रिकर्सिव लेंथ प्रीफ़िक्स। arXiv preprint arXiv:2009.13769.](https://arxiv.org/abs/2009.13769)

## संबंधित विषय {#related-topics}

- [पेट्रीसिया मर्कल ट्राई](/developers/docs/data-structures-and-encoding/patricia-merkle-trie)
