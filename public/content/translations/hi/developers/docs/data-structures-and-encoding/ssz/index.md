---
title: "सिंपल सीरियलाइज़"
description: "एथेरियम के SSZ फॉर्मेट की व्याख्या।"
lang: hi
sidebarDepth: 2
---

**सिंपल सीरियलाइज़ (SSZ)** बीकन चेन पर उपयोग की जाने वाली सीरियलाइज़ेशन विधि है। यह पीयर डिस्कवरी प्रोटोकॉल को छोड़कर, सहमति परत पर हर जगह निष्पादन परत पर उपयोग किए जाने वाले RLP सीरियलाइज़ेशन की जगह लेता है। RLP सीरियलाइज़ेशन के बारे में और जानने के लिए, [रिकर्सिव-लेंथ प्रीफिक्स (RLP)](/developers/docs/data-structures-and-encoding/rlp/) देखें। SSZ को नियतात्मक होने और कुशलतापूर्वक मर्कलाइज़ करने के लिए डिज़ाइन किया गया है। SSZ को दो घटकों वाला माना जा सकता है: एक सीरियलाइज़ेशन स्कीम और एक मर्कलाइज़ेशन स्कीम जिसे सीरियलाइज़्ड डेटा संरचना के साथ कुशलता से काम करने के लिए डिज़ाइन किया गया है।

## SSZ कैसे काम करता है? {#how-does-ssz-work}

### सीरियलाइज़ेशन {#serialization}

SSZ एक सीरियलाइज़ेशन स्कीम है जो स्व-वर्णन नहीं है - बल्कि यह एक स्कीमा पर निर्भर करती है जिसे पहले से जानना आवश्यक है। SSZ सीरियलाइज़ेशन का लक्ष्य मनमानी जटिलता की वस्तुओं को बाइट्स के स्ट्रिंग्स के रूप में प्रस्तुत करना है। यह "बुनियादी प्रकारों" के लिए एक बहुत ही सरल प्रक्रिया है। तत्व को बस हेक्साडेसिमल बाइट्स में बदल दिया जाता है। बुनियादी प्रकारों में शामिल हैं:

- अहस्ताक्षरित पूर्णांक
- बूलियन

जटिल "समग्र" प्रकारों के लिए, सीरियलाइज़ेशन अधिक जटिल है क्योंकि समग्र प्रकार में कई तत्व होते हैं जिनके प्रकार या आकार अलग-अलग हो सकते हैं, या दोनों। जहां इन सभी वस्तुओं की लंबाई निश्चित होती है (यानी, तत्वों का आकार उनके वास्तविक मूल्यों के बावजूद हमेशा स्थिर रहेगा) सीरियलाइज़ेशन बस समग्र प्रकार के प्रत्येक तत्व का लिटिल-एंडियन बाइटस्ट्रिंग्स में रूपांतरण है। इन बाइटस्ट्रिंग्स को एक साथ जोड़ा जाता है। सीरियलाइज़्ड ऑब्जेक्ट में निश्चित-लंबाई वाले तत्वों का बाइटलिस्ट प्रतिनिधित्व उसी क्रम में होता है जैसे वे डी-सीरियलाइज़्ड ऑब्जेक्ट में दिखाई देते हैं।

परिवर्तनीय लंबाई वाले प्रकारों के लिए, वास्तविक डेटा को सीरियलाइज़्ड ऑब्जेक्ट में उस तत्व की स्थिति में एक "ऑफसेट" मान से बदल दिया जाता है। वास्तविक डेटा को सीरियलाइज़्ड ऑब्जेक्ट के अंत में एक हीप में जोड़ा जाता है। ऑफसेट मान हीप में वास्तविक डेटा की शुरुआत के लिए इंडेक्स है, जो प्रासंगिक बाइट्स के लिए एक पॉइंटर के रूप में कार्य करता है।

नीचे दिया गया उदाहरण दिखाता है कि निश्चित और परिवर्तनीय-लंबाई वाले दोनों तत्वों वाले कंटेनर के लिए ऑफसेटिंग कैसे काम करती है:

```Rust

    struct Dummy {

        number1: u64,
        number2: u64,
        vector: Vec<u8>,
        number3: u64
    }

    dummy = Dummy{

        number1: 37,
        number2: 55,
        vector: vec![1,2,3,4],
        number3: 22,
    }

    serialized = ssz.serialize(dummy)

```

`serialized` की निम्नलिखित संरचना होगी (यहाँ केवल 4 बिट्स तक पैडेड है, वास्तविकता में 32 बिट्स तक पैडेड है, और स्पष्टता के लिए `int` प्रतिनिधित्व रखा गया है):

```
[37, 0, 0, 0, 55, 0, 0, 0, 16, 0, 0, 0, 22, 0, 0, 0, 1, 2, 3, 4]
------------  -----------  -----------  -----------  ----------
      |             |            |           |            |
   number1       number2    vector के लिए  number3    vector का मान
                              ऑफ़सेट
```

स्पष्टता के लिए पंक्तियों में विभाजित:

```
[
  37, 0, 0, 0,  # `number1` का लिटिल-एंडियन एन्कोडिंग।
  55, 0, 0, 0,  # `number2` का लिटिल-एंडियन एन्कोडिंग।
  16, 0, 0, 0,  # "ऑफ़सेट" जो इंगित करता है कि `vector` का मान कहाँ से शुरू होता है (लिटिल-एंडियन 16)।
  22, 0, 0, 0,  # `number3` का लिटिल-एंडियन एन्कोडिंग।
  1, 2, 3, 4,   # `vector` में वास्तविक मान।
]
```

यह अभी भी एक सरलीकरण है - ऊपर की योजना में पूर्णांक और शून्य वास्तव में बाइटलिस्ट के रूप में संग्रहीत किए जाएंगे, इस तरह:

```
[
  10100101000000000000000000000000  # `number1` का लिटिल-एंडियन एन्कोडिंग
  10110111000000000000000000000000  # `number2` का लिटिल-एंडियन एन्कोडिंग।
  10010000000000000000000000000000  # "ऑफ़सेट" जो इंगित करता है कि `vector` का मान कहाँ से शुरू होता है (लिटिल-एंडियन 16)।
  10010110000000000000000000000000  # `number3` का लिटिल-एंडियन एन्कोडिंग।
  10000001100000101000001110000100   # `bytes` फ़ील्ड का वास्तविक मान।
]
```

तो परिवर्तनीय-लंबाई वाले प्रकारों के लिए वास्तविक मान सीरियलाइज़्ड ऑब्जेक्ट के अंत में एक हीप में संग्रहीत किए जाते हैं, उनके ऑफ़सेट फ़ील्ड की क्रमित सूची में उनकी सही स्थिति में संग्रहीत होते हैं।

कुछ विशेष मामले भी हैं जिनके लिए विशिष्ट उपचार की आवश्यकता होती है, जैसे कि `BitList` प्रकार जिसमें सीरियलाइज़ेशन के दौरान एक लंबाई कैप जोड़ने और डी-सीरियलाइज़ेशन के दौरान हटाने की आवश्यकता होती है। पूरा विवरण [SSZ स्पेक](https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md) में उपलब्ध है।

### डी-सीरियलाइज़ेशन {#deserialization}

इस ऑब्जेक्ट को डी-सीरियलाइज़ करने के लिए <b>स्कीमा</b> की आवश्यकता होती है। स्कीमा सीरियलाइज़्ड डेटा के सटीक लेआउट को परिभाषित करता है ताकि प्रत्येक विशिष्ट तत्व को बाइट्स के ब्लॉब से किसी सार्थक ऑब्जेक्ट में डी-सीरियलाइज़ किया जा सके, जिसमें तत्वों का सही प्रकार, मान, आकार और स्थिति हो। यह स्कीमा ही है जो डी-सीरियलाइज़र को बताता है कि कौन से मान वास्तविक मान हैं और कौन से ऑफ़सेट हैं। जब किसी ऑब्जेक्ट को सीरियलाइज़ किया जाता है तो सभी फ़ील्ड नाम गायब हो जाते हैं, लेकिन स्कीमा के अनुसार डी-सीरियलाइज़ेशन पर पुनः स्थापित हो जाते हैं।

इस पर एक इंटरैक्टिव व्याख्या के लिए [ssz.dev](https://www.ssz.dev/overview) देखें।

## मर्कलाइज़ेशन {#merkleization}

इस SSZ सीरियलाइज़्ड ऑब्जेक्ट को फिर मर्कलाइज़्ड किया जा सकता है - यानी उसी डेटा के मर्कल-ट्री प्रतिनिधित्व में बदल दिया जाता है। सबसे पहले, सीरियलाइज़्ड ऑब्जेक्ट में 32-बाइट चंक्स की संख्या निर्धारित की जाती है। ये ट्री के "लीव्स" हैं। लीव्स की कुल संख्या 2 की घात होनी चाहिए ताकि लीव्स को एक साथ हैश करने पर अंततः एक एकल हैश-ट्री-रूट उत्पन्न हो। यदि ऐसा स्वाभाविक रूप से नहीं होता है, तो शून्य के 32 बाइट्स वाले अतिरिक्त लीव्स जोड़े जाते हैं। आरेखीय रूप से:

```
        हैश ट्री रूट
            /     \
           /       \
          /         \
         /           \
   लीव्स का हैश      लीव्स का हैश
     1 और 2         3 और 4
      /   \            /  \
     /     \          /    \
    /       \        /      \
 leaf1     leaf2  leaf3     leaf4
```

ऐसे मामले भी हैं जहां ट्री के लीव्स स्वाभाविक रूप से उस तरह से समान रूप से वितरित नहीं होते हैं जैसे वे उपरोक्त उदाहरण में होते हैं। उदाहरण के लिए, लीफ 4 कई तत्वों वाला एक कंटेनर हो सकता है जिसके लिए मर्कल ट्री में अतिरिक्त "गहराई" जोड़ने की आवश्यकता होती है, जिससे एक असमान ट्री बनता है।

इन ट्री तत्वों को लीफ X, नोड X आदि के रूप में संदर्भित करने के बजाय, हम उन्हें सामान्यीकृत सूचकांक दे सकते हैं, जिसकी शुरुआत रूट = 1 से होती है और प्रत्येक स्तर पर बाएं से दाएं गिनती होती है। यह ऊपर बताया गया सामान्यीकृत सूचकांक है। सीरियलाइज़्ड सूची में प्रत्येक तत्व का एक सामान्यीकृत सूचकांक `2**depth + idx` के बराबर होता है, जहां idx सीरियलाइज़्ड ऑब्जेक्ट में इसकी शून्य-अनुक्रमित स्थिति है और गहराई मर्कल ट्री में स्तरों की संख्या है, जिसे तत्वों (लीव्स) की संख्या के आधार-दो लघुगणक के रूप में निर्धारित किया जा सकता है।

## सामान्यीकृत सूचकांक {#generalized-indices}

एक सामान्यीकृत सूचकांक एक पूर्णांक है जो एक बाइनरी मर्कल ट्री में एक नोड का प्रतिनिधित्व करता है जहां प्रत्येक नोड में एक सामान्यीकृत सूचकांक `2 ** depth + पंक्ति में सूचकांक` होता है।

```
        1           --गहराई = 0  2**0 + 0 = 1
    2       3       --गहराई = 1  2**1 + 0 = 2, 2**1+1 = 3
  4   5   6   7     --गहराई = 2  2**2 + 0 = 4, 2**2 + 1 = 5...

```

यह प्रतिनिधित्व मर्कल ट्री में डेटा के प्रत्येक टुकड़े के लिए एक नोड सूचकांक देता है।

## मल्टीप्रूफ़्स {#multiproofs}

एक विशिष्ट तत्व का प्रतिनिधित्व करने वाले सामान्यीकृत सूचकांकों की सूची प्रदान करने से हमें इसे हैश-ट्री-रूट के विरुद्ध सत्यापित करने की अनुमति मिलती है। यह रूट वास्तविकता का हमारा स्वीकृत संस्करण है। हमें प्रदान किया गया कोई भी डेटा उस वास्तविकता के विरुद्ध सत्यापित किया जा सकता है, इसे मर्कल ट्री में सही जगह पर डालकर (इसके सामान्यीकृत सूचकांक द्वारा निर्धारित) और यह देखकर कि रूट स्थिर रहता है। स्पेक [यहाँ](https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs) में ऐसे फ़ंक्शन हैं जो यह दिखाते हैं कि सामान्यीकृत सूचकांकों के एक विशेष सेट की सामग्री को सत्यापित करने के लिए आवश्यक नोड्स के न्यूनतम सेट की गणना कैसे करें।

उदाहरण के लिए, नीचे दिए गए ट्री में इंडेक्स 9 में डेटा को सत्यापित करने के लिए, हमें इंडेक्स 8, 9, 5, 3, 1 पर डेटा के हैश की आवश्यकता है।
(8,9) का हैश, हैश (4) के बराबर होना चाहिए, जो 5 के साथ हैश होकर 2 उत्पन्न करता है, जो 3 के साथ हैश होकर ट्री रूट 1 उत्पन्न करता है। यदि 9 के लिए गलत डेटा प्रदान किया गया होता, तो रूट बदल जाता - हम इसका पता लगा लेते और शाखा को सत्यापित करने में विफल रहते।

```
* = प्रूफ़ उत्पन्न करने के लिए आवश्यक डेटा

                    1*
          2                      3*
    4          5*          6          7
8*     9*   10    11   12    13    14    15

```

## आगे की रीडिंग {#further-reading}

- [एथेरियम को अपग्रेड करना: SSZ](https://eth2book.info/altair/part2/building_blocks/ssz)
- [एथेरियम को अपग्रेड करना: मर्कलाइज़ेशन](https://eth2book.info/altair/part2/building_blocks/merkleization)
- [SSZ कार्यान्वयन](https://github.com/ethereum/consensus-specs/issues/2138)
- [SSZ कैलकुलेटर](https://simpleserialize.com/)
- [SSZ.dev](https://www.ssz.dev/)
