---
title: नेटवर्किंग परत
description: एथेरियम की नेटवर्किंग परत का परिचय।
lang: hi
sidebarDepth: 2
---

एथेरियम एक पीयर-टू-पीयर नेटवर्क है जिसमें हजारों नोड्स होते हैं, जिन्हें मानकीकृत प्रोटोकॉल का उपयोग करके एक-दूसरे के साथ संवाद करना सक्षम होना चाहिए। "नेटवर्किंग लेयर" वह प्रोटोकॉल्स का सेट है जो उन नोड्स को एक-दूसरे को ढूंढने और जानकारी का आदान-प्रदान करने की अनुमति देता है। यह सूचना का "गॉसिपिंग" (एक-से-कई संचार) नेटवर्क पर करना और विशिष्ट नोड्स के बीच अनुरोधों और प्रतिक्रियाओं का आदान-प्रदान करना (एक-से-एक संचार) शामिल है। प्रत्येक नोड को सुनिश्चित करने के लिए विशेष नेटवर्किंग नियमों का पालन करना चाहिए कि वे सही जानकारी भेज और प्राप्त कर रहे हैं।

क्लाइंट सॉफ्टवेयर के दो भाग होते हैं (निष्पादन क्लाइंट और सर्वसम्मति क्लाइंट) जिनमें से प्रत्येक का अपना अलग नेटवर्किंग स्टैक होता है। अन्य एथेरियम नोड्स के साथ संवाद करने के साथ-साथ, निष्पादन और आम सहमति वाले ग्राहकों को एक-दूसरे के साथ संवाद करना पड़ता है। यह पृष्ठ उन प्रोटोकॉल्स का परिचयात्मक विवरण प्रदान करता है जो इस संचार को सक्षम बनाते हैं।

निष्पादन ग्राहक लेनदेन को निष्पादन लेयर पीयर-टू-पीयर नेटवर्क पर गॉसिप करते हैं। इसके लिए प्रमाणित पीयर्स के बीच एन्क्रिप्टेड संचार की आवश्यकता होती है। जब एक वैलिडेटर को ब्लॉक प्रस्तावित करने के लिए चुना जाता है, तो नोड के स्थानीय लेनदेन पूल से लेनदेन एक स्थानीय RPC कनेक्शन के माध्यम से सहमति क्लाइंट को पास किए जाएंगे, जो बीकन ब्लॉक में पैकेज किए जाएंगे। सहमति ग्राहक तब बीकन ब्लॉक को अपने p2p नेटवर्क पर गॉसिप करेंगे। इसके लिए दो अलग-अलग p2p नेटवर्क की आवश्यकता होती है: एक जो लेनदेन गॉसिप के लिए निष्पादन ग्राहक को जोड़ता है और एक जो ब्लॉक गॉसिप के लिए सहमति ग्राहक को जोड़ता है।

## पूर्वापेक्षाएं {#prerequisites}

इस पृष्ठ को समझने के लिए एथेरियम [नोड्स और क्लाइंट्स](/developers/docs/nodes-and-clients/) की कुछ जानकारी सहायक होगी।

## निष्पादन परत {#execution-layer}

निष्पादन परत के नेटवर्किंग प्रोटोकॉल दो स्टैक्स में विभाजित होते हैं:

- डिस्कवरी स्टैकः UDP के शीर्ष पर बनाया गया है और एक नए नोड को साथियों को जोड़ने के लिए खोजने की अनुमति देता है

- DevP2P स्टैक: TCP के ऊपर बैठता है और नोड्स को सूचना का आदान-प्रदान करने में सक्षम बनाता है

दोनों स्टैक्स समानांतर रूप से काम करते हैं। डिस्कवरी स्टैक नेटवर्क में नए नेटवर्क प्रतिभागियों को फ़ीड करता है, और DevP2P स्टैक उनकी बातचीत को सक्षम बनाता है।

### डिस्कवरी {#discovery}

डिस्कवरी नेटवर्क में अन्य नोड्स को खोजने की प्रक्रिया है। यह बूटनोड्स के एक छोटे सेट का उपयोग करके बूटस्ट्रैप किया जाता है (नोड्स जिनके पते क्लाइंट में [हार्डकोडेड](https://github.com/ethereum/go-ethereum/blob/master/params/bootnodes.go) होते हैं ताकि उन्हें तुरंत पाया जा सके और क्लाइंट को पीयर्स से जोड़ा जा सके)। ये बूटनोड केवल साथियों के एक समूह के लिए एक नए नोड को पेश करने के लिए मौजूद हैं-यह उनका एकमात्र उद्देश्य है, वे श्रृंखला को सिंक करने जैसे सामान्य क्लाइंट कार्यों में भाग नहीं लेते हैं, और उनका उपयोग केवल पहली बार क्लाइंट को घुमाने के लिए किया जाता है।

नोड-बूटनोड इंटरैक्शन के लिए उपयोग किया जाने वाला प्रोटोकॉल [Kademlia](https://medium.com/coinmonks/a-brief-overview-of-kademlia-and-its-use-in-various-decentralized-platforms-da08a7f72b8f) का एक संशोधित रूप है जो नोड्स की सूचियों को साझा करने के लिए एक [डिस्ट्रिब्यूटेड हैश टेबल](https://en.wikipedia.org/wiki/Distributed_hash_table) का उपयोग करता है। प्रत्येक नोड के पास इस तालिका का एक संस्करण होता है जिसमें इसके सबसे करीबी साथियों से कनेक्ट होने के लिए आवश्यक जानकारी होती है। यह 'निकटता' भौगोलिक नहीं है - दूरी नोड के ID की समानता से परिभाषित की जाती है। प्रत्येक नोड की तालिका को एक सुरक्षा सुविधा के रूप में नियमित रूप से ताज़ा किया जाता है। उदाहरण के लिए, [Discv5](https://github.com/ethereum/devp2p/tree/master/discv5) में, खोज प्रोटोकॉल नोड्स 'ads' भी भेज सकते हैं जो उन सबप्रोटोकॉल को प्रदर्शित करते हैं जिनका क्लाइंट समर्थन करता है, जिससे पीयर्स उन प्रोटोकॉल के बारे में बातचीत कर सकते हैं जिनका वे दोनों संचार के लिए उपयोग कर सकते हैं।

खोज PING-PONG के खेल के साथ शुरू होती है। एक सफल PING-PONG नए नोड को बूटनोड से "बांधता" है। वह प्रारंभिक संदेश जो किसी बूटनोड को नेटवर्क में प्रवेश करने वाले नए नोड के अस्तित्व के बारे में सचेत करता है, एक `PING` है। इस `PING` में नए नोड, बूटनोड और एक एक्सपायरी टाइम-स्टैम्प के बारे में हैश की गई जानकारी शामिल है। बूटनोड `PING` प्राप्त करता है और `PING` हैश युक्त एक `PONG` लौटाता है। यदि `PING` और `PONG` हैश मेल खाते हैं तो नए नोड और बूटनोड के बीच कनेक्शन सत्यापित हो जाता है और उन्हें "बॉन्डेड" कहा जाता है।

एक बार बॉन्डेड हो जाने पर, नया नोड बूटनोड को `FIND-NEIGHBOURS` अनुरोध भेज सकता है। बूटनोड द्वारा लौटाया गया डेटा उन साथियों की एक सूची शामिल करता है जिनसे नया नोड कनेक्ट कर सकता है। यदि नोड्स बॉन्डेड नहीं हैं, तो `FIND-NEIGHBOURS` अनुरोध विफल हो जाएगा, इसलिए नया नोड नेटवर्क में प्रवेश नहीं कर पाएगा।

एक बार जब नया नोड बूटनोड से पड़ोसियों की सूची प्राप्त कर लेता है, तो वह उनमें से प्रत्येक के साथ PING-PONG आदान-प्रदान शुरू करता है। सफल PING-PONG नए नोड को उसके पड़ोसियों के साथ बांधते हैं, जिससे संदेश आदान-प्रदान सक्षम हो जाता है।

```
क्लाइंट शुरू करें --> बूटनोड से कनेक्ट करें --> बूटनोड से बॉन्ड करें --> पड़ोसियों को ढूंढें --> पड़ोसियों से बॉन्ड करें
```

निष्पादन क्लाइंट वर्तमान में [Discv4](https://github.com/ethereum/devp2p/blob/master/discv4.md) डिस्कवरी प्रोटोकॉल का उपयोग कर रहे हैं और [Discv5](https://github.com/ethereum/devp2p/tree/master/discv5) प्रोटोकॉल पर माइग्रेट करने का एक सक्रिय प्रयास चल रहा है।

#### ENR: एथेरियम नोड रिकॉर्ड्स {#enr}

[एथेरियम नोड रिकॉर्ड (ENR)](/developers/docs/networking-layer/network-addresses/) एक ऑब्जेक्ट है जिसमें तीन बुनियादी तत्व होते हैं: एक हस्ताक्षर (किसी सहमत पहचान योजना के अनुसार रिकॉर्ड सामग्री का हैश), एक अनुक्रम संख्या जो रिकॉर्ड में परिवर्तनों को ट्रैक करती है, और key:value जोड़ों की एक मनमानी सूची। यह एक फ्यूचर-प्रूफ प्रारूप है जो नए पीयर्स के बीच पहचान की जानकारी के आसान आदान-प्रदान की अनुमति देता है और एथेरियम नोड्स के लिए पसंदीदा [नेटवर्क पता](/developers/docs/networking-layer/network-addresses) प्रारूप है।

#### खोज UDP पर क्यों बनाई गई है? {#why-udp}

UDP किसी भी त्रुटि की जाँच, असफल पैकेटों को फिर से भेजने, या गतिशील रूप से कनेक्शन खोलने और बंद करने का समर्थन नहीं करता है-इसके बजाय यह केवल एक लक्ष्य पर जानकारी की एक निरंतर धारा को फायर करता है, भले ही वह सफलतापूर्वक प्राप्त हो। यह न्यूनतम कार्यक्षमता भी न्यूनतम ओवरहेड में अनुवादित होती है, जिससे इस प्रकार का कनेक्शन बहुत तेज हो जाता है। खोज के लिए, जहां एक नोड बस अपनी उपस्थिति को ज्ञात कराना चाहता है ताकि फिर एक पीयर के साथ एक औपचारिक कनेक्शन स्थापित किया जा सके, UDP पर्याप्त है। हालांकि, नेटवर्किंग स्टैक के बाकी हिस्सों के लिए, UDP उद्देश्य के लिए उपयुक्त नहीं है। नोड्स के बीच सूचना का आदान-प्रदान काफी जटिल होता है और इसलिए एक ऐसा प्रोटोकॉल आवश्यक होता है जो पुनः भेजने, त्रुटि जाँच आदि का समर्थन कर सके। TCP से जुड़ा अतिरिक्त ओवरहेड अतिरिक्त कार्यक्षमता के लायक है। इसलिए, P2P स्टैक का अधिकांश भाग TCP पर संचालित होता है।

### DevP2P {#devp2p}

DevP2P स्वयं प्रोटोकॉल का एक पूरा स्टैक है जिसे एथेरियम पीयर-टू-पीयर नेटवर्क स्थापित करने और बनाए रखने के लिए लागू करता है। नए नोड्स के नेटवर्क में प्रवेश करने के बाद, उनकी बातचीत [DevP2P](https://github.com/ethereum/devp2p) स्टैक में प्रोटोकॉल द्वारा नियंत्रित होती है। ये सभी TCP के ऊपर बैठते हैं और इनमें RLPx ट्रांसपोर्ट प्रोटोकॉल, वायर प्रोटोकॉल और कई उप-प्रोटोकॉल शामिल हैं। [RLPx](https://github.com/ethereum/devp2p/blob/master/rlpx.md) वह प्रोटोकॉल है जो नोड्स के बीच सत्रों को आरंभ करने, प्रमाणित करने और बनाए रखने को नियंत्रित करता है। RLPx संदेशों को RLP (रिकर्सिव लेंथ प्रीफिक्स) का उपयोग करके एनकोड करता है जो नोड्स के बीच भेजने के लिए डेटा को एक न्यूनतम संरचना में एनकोड करने का एक बहुत ही स्थान-कुशल तरीका है।

दो नोड्स के बीच एक RLPx सत्र एक प्रारंभिक क्रिप्टोग्राफिक हैंडशेक के साथ शुरू होता है। इसमें नोड एक auth संदेश भेजता है जिसे फिर पीयर द्वारा सत्यापित किया जाता है। सफल सत्यापन पर, पीयर आरंभकर्ता नोड को वापस करने के लिए एक auth-स्वीकृति संदेश उत्पन्न करता है। यह एक कुंजी-विनिमय प्रक्रिया है जो नोड्स को निजी तौर पर और सुरक्षित रूप से संवाद करने में सक्षम बनाती है। एक सफल क्रिप्टोग्राफिक हैंडशेक तब दोनों नोड्स को एक दूसरे को "वायर पर" एक "हैलो" संदेश भेजने के लिए ट्रिगर करता है। वायर प्रोटोकॉल हैलो संदेशों के सफल आदान-प्रदान द्वारा आरंभ किया जाता है।

हैलो संदेशों में शामिल हैं:

- प्रोटोकॉल संस्करण
- क्लाइंट ID
- पोर्ट
- नोड ID
- समर्थित उप-प्रोटोकॉल की सूची

यह सफल बातचीत के लिए आवश्यक जानकारी है क्योंकि यह परिभाषित करता है कि दोनों नोड्स के बीच कौन सी क्षमताएँ साझा की जाती हैं और संचार को कॉन्फ़िगर करता है। उप-प्रोटोकॉल वार्ता की एक प्रक्रिया है जहाँ प्रत्येक नोड द्वारा समर्थित उप-प्रोटोकॉल की सूचियों की तुलना की जाती है और जो दोनों नोड्स के लिए सामान्य हैं, उनका उपयोग सत्र में किया जा सकता है।

हैलो संदेशों के साथ, वायर प्रोटोकॉल एक "डिस्कनेक्ट" संदेश भी भेज सकता है जो एक सहकर्मी को चेतावनी देता है कि कनेक्शन बंद हो जाएगा। वायर प्रोटोकॉल में PING और PONG संदेश भी शामिल हैं जो एक सत्र को खुला रखने के लिए समय-समय पर भेजे जाते हैं। RLPx और वायर प्रोटोकॉल एक्सचेंज इसलिए नोड्स के बीच संचार की नींव स्थापित करते हैं, जो एक विशिष्ट उप-प्रोटोकॉल के अनुसार उपयोगी जानकारी के आदान-प्रदान के लिए मचान प्रदान करते हैं।

### सब-प्रोटोकॉल {#sub-protocols}

#### वायर प्रोटोकॉल {#wire-protocol}

एक बार पीयर्स कनेक्ट हो जाते हैं, और एक RLPx सत्र शुरू हो जाता है, तब वायर प्रोटोकॉल यह परिभाषित करता है कि पीयर्स कैसे संवाद करते हैं। प्रारंभ में, वायर प्रोटोकॉल ने तीन मुख्य कार्यों को परिभाषित किया था: चेन सिंक्रोनाइजेशन, ब्लॉक प्रसार और लेनदेन विनिमय। हालांकि, जब एथेरियम प्रूफ-ऑफ-स्टेक पर स्विच हुआ, तब ब्लॉक प्रसार और चेन सिंक्रोनाइजेशन सहमति परत का हिस्सा बन गए। लेनदेन विनिमय अभी भी निष्पादन क्लाइंट्स के अधिकार क्षेत्र में है। लेनदेन विनिमय का अर्थ है नोड्स के बीच लंबित लेनदेन का आदान-प्रदान करना ताकि ब्लॉक बिल्डर्स अगले ब्लॉक में शामिल करने के लिए उनमें से कुछ का चयन कर सकें। इन कार्यों के बारे में विस्तृत जानकारी [यहां](https://github.com/ethereum/devp2p/blob/master/caps/eth.md) उपलब्ध है। जो क्लाइंट्स इन सब-प्रोटोकॉल का समर्थन करते हैं, वे उन्हें [JSON-RPC](/developers/docs/apis/json-rpc/) के माध्यम से एक्सपोज़ करते हैं।

#### les (लाइट एथेरियम सबप्रोटोकॉल) {#les}

यह लाइट क्लाइंट्स को सिंक करने के लिए एक न्यूनतम प्रोटोकॉल है। परंपरागत रूप से इस प्रोटोकॉल का उपयोग शायद ही कभी किया जाता था क्योंकि पूर्ण नोड्स को बिना किसी प्रोत्साहन के लाइट क्लाइंट्स को डेटा सेवा प्रदान करने की आवश्यकता होती है। निष्पादन क्लाइंट्स का डिफ़ॉल्ट व्यवहार les पर लाइट क्लाइंट डेटा सेवा न करना है। अधिक जानकारी les [स्पेक](https://github.com/ethereum/devp2p/blob/master/caps/les.md) में उपलब्ध है।

#### Snap {#snap}

[स्नैप प्रोटोकॉल](https://github.com/ethereum/devp2p/blob/master/caps/snap.md#ethereum-snapshot-protocol-snap) एक वैकल्पिक एक्सटेंशन है जो पीयर्स को हाल की स्टेट्स के स्नैपशॉट का आदान-प्रदान करने की अनुमति देता है, जिससे पीयर्स को मध्यवर्ती मर्कल ट्राई नोड्स को डाउनलोड किए बिना खाता और स्टोरेज डेटा को सत्यापित करने की अनुमति मिलती है।

#### Wit (विटनेस प्रोटोकॉल) {#wit}

[विटनेस प्रोटोकॉल](https://github.com/ethereum/devp2p/blob/master/caps/wit.md#ethereum-witness-protocol-wit) एक वैकल्पिक एक्सटेंशन है जो पीयर्स के बीच स्टेट विटनेस के आदान-प्रदान को सक्षम करता है, जो क्लाइंट्स को चेन के टिप तक सिंक करने में मदद करता है।

#### Whisper {#whisper}

व्हिस्पर एक प्रोटोकॉल था जिसका उद्देश्य ब्लॉकचेन पर कोई जानकारी लिखे बिना पीयर्स के बीच सुरक्षित मैसेजिंग प्रदान करना था। यह DevP2P वायर प्रोटोकॉल का हिस्सा था लेकिन अब पदावनत हो चुका है। समान उद्देश्यों वाली अन्य [संबंधित परियोजनाएं](https://wakunetwork.com/) मौजूद हैं।

## सहमति परत {#consensus-layer}

सहमति क्लाइंट्स एक अलग पीयर-टू-पीयर नेटवर्क में भाग लेते हैं जिसकी एक अलग विशिष्टता है। सहमति क्लाइंट्स को ब्लॉक गॉसिप में भाग लेने की आवश्यकता होती है ताकि वे पीयर्स से नए ब्लॉक प्राप्त कर सकें और जब उनकी बारी ब्लॉक प्रस्तावक होने की हो तो उन्हें प्रसारित कर सकें। निष्पादन परत के समान, इसके लिए पहले एक खोज प्रोटोकॉल की आवश्यकता होती है ताकि एक नोड पीयर्स को खोज सके और ब्लॉक्स, अटेस्टेशन आदि के आदान-प्रदान के लिए सुरक्षित सत्र स्थापित कर सके।

### डिस्कवरी {#consensus-discovery}

निष्पादन क्लाइंट्स के समान, सहमति क्लाइंट्स पीयर्स को खोजने के लिए UDP पर [discv5](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#the-discovery-domain-discv5) का उपयोग करते हैं। सहमति परत का discv5 कार्यान्वयन निष्पादन क्लाइंट्स से केवल इस मायने में भिन्न है कि इसमें discv5 को एक [libP2P](https://libp2p.io/) स्टैक से जोड़ने वाला एक एडॉप्टर शामिल है, जो DevP2P को पदावनत करता है। निष्पादन परत के RLPx सत्रों को libP2P के नॉइज सुरक्षित चैनल हैंडशेक के पक्ष में पदावनत कर दिया गया है।

### ENRs {#consensus-enr}

सहमति नोड्स के लिए ENR में नोड की सार्वजनिक कुंजी, IP पता, UDP और TCP पोर्ट और दो सहमति-विशिष्ट फ़ील्ड शामिल हैं: अटेस्टेशन सबनेट बिटफ़ील्ड और `eth2` कुंजी। पूर्वोक्त विशिष्ट अटेस्टेशन गॉसिप उप-नेटवर्क में भाग लेने वाले पीयर्स को खोजना नोड्स के लिए आसान बनाता है। `eth2` कुंजी में यह जानकारी होती है कि नोड किस एथेरियम फोर्क संस्करण का उपयोग कर रहा है, यह सुनिश्चित करते हुए कि पीयर्स सही एथेरियम से कनेक्ट हो रहे हैं।

### libP2P {#libp2p}

libP2P स्टैक खोज के बाद सभी संचार का समर्थन करता है। क्लाइंट्स अपने ENR में परिभाषित के अनुसार IPv4 और/या IPv6 पर डायल और सुन सकते हैं। libP2P परत पर प्रोटोकॉल को गॉसिप और req/resp डोमेन में उप-विभाजित किया जा सकता है।

### Gossip {#gossip}

गॉसिप डोमेन में वह सभी जानकारी शामिल होती है जिसे नेटवर्क में तेजी से फैलना होता है। इसमें बीकन ब्लॉक्स, प्रूफ, अटेस्टेशन, एक्जिट और स्लैशिंग शामिल हैं। यह libP2P gossipsub v1 का उपयोग करके संचारित किया जाता है और प्रत्येक नोड पर स्थानीय रूप से संग्रहीत विभिन्न मेटाडेटा पर निर्भर करता है, जिसमें प्राप्त करने और संचारित करने के लिए गॉसिप पेलोड का अधिकतम आकार शामिल है। गॉसिप डोमेन के बारे में विस्तृत जानकारी [यहां](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#the-gossip-domain-gossipsub) उपलब्ध है।

### रिक्वेस्ट-रिस्पॉन्स {#request-response}

अनुरोध-प्रतिक्रिया डोमेन में वे प्रोटोकॉल शामिल हैं जिनके लिए क्लाइंट्स अपने पीयर्स से विशिष्ट जानकारी का अनुरोध करते हैं। उदाहरणों में कुछ निश्चित रूट हैश या स्लॉट्स की एक श्रेणी के भीतर विशिष्ट बीकन ब्लॉक्स का अनुरोध करना शामिल है। प्रतिक्रियाएं हमेशा स्नैपी-संपीड़ित SSZ एन्कोडेड बाइट्स के रूप में लौटाई जाती हैं।

## सहमति क्लाइंट RLP की तुलना में SSZ को क्यों प्राथमिकता देता है? {#ssz-vs-rlp}

SSZ का अर्थ है सरल सीरियलाइजेशन। यह निश्चित ऑफसेट का उपयोग करता है जो संपूर्ण संरचना को डीकोड किए बिना एन्कोडेड संदेश के व्यक्तिगत भागों को आसानी से डीकोड करना संभव बनाता है, जो सहमति क्लाइंट के लिए बहुत उपयोगी है क्योंकि यह एन्कोडेड संदेशों से विशिष्ट जानकारी के टुकड़ों को कुशलतापूर्वक प्राप्त कर सकता है। यह विशेष रूप से मर्कल प्रोटोकॉल के साथ एकीकृत होने के लिए डिज़ाइन किया गया है, जिससे मर्कलाइजेशन के लिए संबंधित दक्षता लाभ होता है। चूंकि सहमति परत में सभी हैश मर्कल रूट्स हैं, इसलिए यह एक महत्वपूर्ण सुधार में जोड़ता है। SSZ मूल्यों के अद्वितीय प्रतिनिधित्व की भी गारंटी देता है।

## निष्पादन और सहमति क्लाइंट्स को कनेक्ट करना {#connecting-clients}

सहमति और निष्पादन क्लाइंट दोनों समानांतर रूप से चलते हैं। उन्हें कनेक्ट करने की आवश्यकता होती है ताकि सहमति क्लाइंट निष्पादन क्लाइंट को निर्देश प्रदान कर सके, और निष्पादन क्लाइंट बीकन ब्लॉक्स में शामिल करने के लिए सहमति क्लाइंट को लेनदेन के बंडल पास कर सके। दोनों क्लाइंट्स के बीच संचार एक स्थानीय RPC कनेक्शन का उपयोग करके प्राप्त किया जा सकता है। ['इंजन-API'](https://github.com/ethereum/execution-apis/blob/main/src/engine/common.md) के रूप में जाना जाने वाला एक API दो क्लाइंट्स के बीच भेजे गए निर्देशों को परिभाषित करता है। चूंकि दोनों क्लाइंट एक ही नेटवर्क पहचान के पीछे बैठते हैं, वे एक ENR (एथेरियम नोड रिकॉर्ड) साझा करते हैं जिसमें प्रत्येक क्लाइंट के लिए एक अलग कुंजी होती है (eth1 कुंजी और eth2 कुंजी)।

नियंत्रण प्रवाह का एक सारांश नीचे दिखाया गया है, जिसमें प्रासंगिक नेटवर्किंग स्टैक कोष्ठक में है।

### जब सहमति क्लाइंट ब्लॉक प्रोड्यूसर नहीं है: {#when-consensus-client-is-not-block-producer}

- सहमति क्लाइंट ब्लॉक गॉसिप प्रोटोकॉल के माध्यम से एक ब्लॉक प्राप्त करता है (सहमति p2p)
- सहमति क्लाइंट ब्लॉक का पूर्व-सत्यापन करता है, यानी यह सुनिश्चित करता है कि यह सही मेटाडेटा के साथ एक वैध प्रेषक से आया है
- ब्लॉक में लेनदेन को निष्पादन परत को निष्पादन पेलोड के रूप में भेजा जाता है (स्थानीय RPC कनेक्शन)
- निष्पादन परत लेनदेन को निष्पादित करती है और ब्लॉक हेडर में स्टेट को मान्य करती है (यानी, हैश मिलान की जांच करती है)
- निष्पादन परत सत्यापन डेटा को सहमति परत को वापस भेजती है, ब्लॉक अब मान्य माना जाता है (स्थानीय RPC कनेक्शन)
- सहमति परत ब्लॉक को अपने ब्लॉकचेन के सिर पर जोड़ती है और इसकी पुष्टि करती है, नेटवर्क पर पुष्टि का प्रसारण करती है (सहमति p2p)

### जब सहमति क्लाइंट ब्लॉक प्रोड्यूसर है: {#when-consensus-client-is-block-producer}

- सहमति क्लाइंट को सूचना मिलती है कि यह अगला ब्लॉक उत्पादक है (सहमति p2p)
- सहमति परत निष्पादन क्लाइंट में `create block` विधि को कॉल करती है (स्थानीय RPC)
- निष्पादन परत लेनदेन मेमपूल तक पहुंचती है जो लेनदेन गॉसिप प्रोटोकॉल द्वारा भरा गया है (निष्पादन p2p)
- निष्पादन क्लाइंट लेनदेन को एक ब्लॉक में बंडल करता है, लेनदेन को निष्पादित करता है और एक ब्लॉक हैश उत्पन्न करता है
- सहमति क्लाइंट निष्पादन क्लाइंट से लेनदेन और ब्लॉक हैश प्राप्त करता है और उन्हें बीकन ब्लॉक में जोड़ता है (स्थानीय RPC)
- सहमति क्लाइंट ब्लॉक गॉसिप प्रोटोकॉल के माध्यम से ब्लॉक का प्रसारण करता है (सहमति p2p)
- अन्य क्लाइंट ब्लॉक गॉसिप प्रोटोकॉल के माध्यम से प्रस्तावित ब्लॉक प्राप्त करते हैं और ऊपर वर्णित अनुसार मान्य करते हैं (सहमति p2p)

एक बार जब ब्लॉक की पर्याप्त वैलिडेटर्स द्वारा पुष्टि कर दी जाती है तो इसे चेन के सिर पर जोड़ दिया जाता है, न्यायोचित किया जाता है और अंततः अंतिम रूप दिया जाता है।

![](cons_client_net_layer.png)\n![](exe_client_net_layer.png)

[ethresear.ch](https://ethresear.ch/t/eth1-eth2-client-relationship/7248) से सहमति और निष्पादन क्लाइंट्स के लिए नेटवर्क परत का योजनाबद्ध चित्र

## अतिरिक्त पठन {#further-reading}

[DevP2P](https://github.com/ethereum/devp2p)\n[LibP2p](https://github.com/libp2p/specs)\n[सहमति परत नेटवर्क स्पेक्स](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#enr-structure)\n[kademlia से discv5](https://vac.dev/kademlia-to-discv5)\n[kademlia पेपर](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)\n[एथेरियम p2p का परिचय](https://p2p.paris/en/talks/intro-ethereum-networking/)\n[eth1/eth2 संबंध](http://ethresear.ch/t/eth1-eth2-client-relationship/7248)\n[मर्ज और eth2 क्लाइंट विवरण वीडियो](https://www.youtube.com/watch?v=zNIrIninMgg)
