---
title: नोड्स और क्लाइंट
description: एथेरियम नोड्स और क्लाइंट सॉफ़्टवेयर का अवलोकन, साथ ही नोड कैसे सेट करें और आपको यह क्यों करना चाहिए।
lang: hi
sidebarDepth: 2
---

एथेरियम कंप्यूटर का एक वितरित नेटवर्क है (जिसे नोड्स के रूप में जाना जाता है) जो सॉफ़्टवेयर चला रहा है जो ब्लॉक और लेनदेन संबंधी डेटा को सत्यापित कर सकता है। सॉफ़्टवेयर को एथेरियम नोड में बदलने के लिए आपके कंप्यूटर पर चलाया जाना चाहिए। नोड बनाने के लिए आवश्यक सॉफ़्टवेयर के दो अलग-अलग टुकड़े ('क्लाइंट' के रूप में जाना जाता है) होते हैं।

## पूर्वापेक्षाएं {#prerequisites}

आपको अपने एथेरियम क्लाइंट का उदाहरण चलाने और गहराई से जानने से पहले पीयर-टू-पीयर नेटवर्क की अवधारणा और [EVM की मूल बातें](/developers/docs/evm/) समझनी चाहिए। हमारे [एथेरियम के परिचय](/developers/docs/intro-to-ethereum/) पर एक नज़र डालें।

अगर आप नोड्स के विषय में नए हैं, तो हम आपको पहले [एथेरियम नोड चलाने](/run-a-node) पर हमारे उपयोगकर्ता-अनुकूल परिचय को देखने की सलाह देते हैं।

## नोड्स और क्लाइंट क्या हैं? {#what-are-nodes-and-clients}

एक "नोड" एथेरियम क्लाइंट सॉफ़्टवेयर का कोई उदाहरण है जो अन्य कंप्यूटरों से जुड़ा होता है जो एथेरियम सॉफ़्टवेयर भी चलाते हैं, एक नेटवर्क बनाते हैं। एक क्लाइंट एथेरियम का एक कार्यान्वयन है जो प्रोटोकॉल नियमों के खिलाफ डेटा की पुष्टि करता है और नेटवर्क को सुरक्षित रखता है। एक नोड को दो क्लाइंट चलाने होते हैं: एक सर्वसम्मति क्लाइंट और एक निष्पादन क्लाइंट।

- निष्पादन क्लाइंट (जिसे निष्पादन इंजन, EL क्लाइंट या पूर्व में Eth1 क्लाइंट के रूप में भी जाना जाता है) नेटवर्क में प्रसारित नए लेनदेन को सुनता है, उन्हें EVM में निष्पादित करता है और एथेरियम संबंधी सभी मौजूदा डेटा की नई स्थिति और डेटाबेस रखता है।
- सहमति क्लाइंट (जिसे बीकन नोड, CL क्लाइंट या पूर्व में Eth2 क्लाइंट के रूप में भी जाना जाता है) हिस्सेदारी का सबूत कंसेंसस एल्गोरिथम को लागू करता है, जो नेटवर्क को एक्‍जीक्यूशन क्लाइंट से मान्य डेटा के आधार पर समझौता प्राप्त करने में सक्षम बनाता है। सॉफ़्टवेयर का एक तीसरा हिस्सा भी है, जिसे 'सत्यापनकर्ता' के रूप में जाना जाता है जिसे आम सहमति क्लाइंट में जोड़ा जा सकता है, जिससे नोड नेटवर्क को सुरक्षित करने में भाग ले सकता है।

ये क्लाइंट एथेरियम सीरीज़ के प्रमुख पर नज़र रखने के लिए एक साथ काम करते हैं और यूज़र को एथेरियम नेटवर्क के साथ बातचीत करने की अनुमति देते हैं। एक साथ काम करने वाले सॉफ़्टवेयर के कई हिस्सों के साथ मॉड्यूलर डिज़ाइन को [एनकैप्सुलेटेड जटिलता](https://vitalik.eth.limo/general/2022/02/28/complexity.html) कहा जाता है। इस दृष्टिकोण ने [द मर्ज](/roadmap/merge) को निर्बाध रूप से निष्पादित करना आसान बना दिया, क्लाइंट सॉफ़्टवेयर को बनाए रखना और विकसित करना आसान बनाता है, और व्यक्तिगत क्लाइंट्स के पुन: उपयोग को सक्षम बनाता है, उदाहरण के लिए, [लेयर 2 इकोसिस्टम](/layer-2/) में।

![युग्मित निष्पादन और सहमति क्लाइंट्स](./eth1eth2client.png)
युग्मित निष्पादन और सहमति क्लाइंट का सरलीकृत आरेख।

### क्लाइंट विविधता {#client-diversity}

[निष्पादन क्लाइंट](/developers/docs/nodes-and-clients/#execution-clients) और [सहमति क्लाइंट](/developers/docs/nodes-and-clients/#consensus-clients) दोनों विभिन्न टीमों द्वारा विकसित विभिन्न प्रोग्रामिंग भाषाओं में मौजूद हैं।

एकाधिक क्लाइंट कार्यान्वयन सिंगल कोडबेस पर अपनी निर्भरता को कम करके नेटवर्क को मजबूत बना सकते हैं। आदर्श लक्ष्य किसी भी क्लाइंट को नेटवर्क पर हावी किए बिना विविधता प्राप्त करना है, जिससे विफलता के संभावित एकल बिंदु को समाप्त किया जा सके।
भाषाओं की विविधता एक व्यापक डेवलपर समुदाय को भी आमंत्रित करती है और उन्हें अपनी पसंदीदा भाषा में इंटीग्रेशन तय करने की अनुमति देती है।

[क्लाइंट विविधता](/developers/docs/nodes-and-clients/client-diversity/) के बारे में और जानें।

इन कार्यान्वयनों में क्या समानता है, वे सभी एक ही विनिर्देश का पालन करते हैं। विनिर्देश तय करते हैं कि एथेरियम नेटवर्क और ब्लॉकचेन कैसे कार्य करता है। प्रत्येक तकनीकी विवरण को परिभाषित किया गया है और विनिर्देशों को इस प्रकार पाया जा सकता है:

- मूल रूप से, [एथेरियम येलो पेपर](https://ethereum.github.io/yellowpaper/paper.pdf)
- [निष्पादन विनिर्देश](https://github.com/ethereum/execution-specs/)
- [सहमति विनिर्देश](https://github.com/ethereum/consensus-specs)
- [EIPs](https://eips.ethereum.org/) जो विभिन्न [नेटवर्क अपग्रेड्स](/ethereum-forks/) में लागू किए गए हैं

### नेटवर्क में नोड्स को ट्रैक करना {#network-overview}

एकाधिक ट्रैकर्स एथेरियम नेटवर्क में नोड्स का रियल टाइम ओवरव्यू प्रदान करते हैं। ध्यान दें कि विकेंद्रीकृत नेटवर्क की प्रकृति के कारण, ये क्रॉलर केवल नेटवर्क का एक सीमित दृश्य प्रदान कर सकते हैं और विभिन्न परिणामों की रिपोर्ट कर सकते हैं।

- Etherscan द्वारा [नोड्स का नक्शा](https://etherscan.io/nodetracker)
- Bitfly द्वारा [Ethernodes](https://ethernodes.org/)
- [Nodewatch](https://www.nodewatch.io/) Chainsafe द्वारा, सहमति नोड्स को क्रॉल करना
- [Monitoreth](https://monitoreth.io/) - MigaLabs द्वारा, एक वितरित नेटवर्क निगरानी उपकरण
- [साप्ताहिक नेटवर्क स्वास्थ्य रिपोर्ट](https://probelab.io) - ProbeLab द्वारा, [नेबुला क्रॉलर](https://github.com/dennis-tra/nebula) और अन्य उपकरणों का उपयोग करके

## नोड के प्रकार {#node-types}

अगर आप [अपना खुद का नोड चलाना चाहते हैं](/developers/docs/nodes-and-clients/run-a-node/), तो आपको यह समझना चाहिए कि विभिन्न प्रकार के नोड होते हैं जो डेटा का अलग-अलग तरीके से उपभोग करते हैं। वास्तव में, क्लाइंट तीन अलग-अलग प्रकार के नोड्स चला सकते हैं: लाइट, पूर्ण और आर्काइव। विभिन्न सिंक रणनीतियों के विकल्प भी हैं जो तेजी से सिंक्रनाइज़ेशन समय को सक्षम करते हैं। सिंक्रनाइज़ेशन से मतलब है कि यह एथेरियम की स्थिति पर हाल ही में अपडेट की गई जानकारी कितनी जल्दी प्राप्त कर सकता है।

### फुल नोड {#full-node}

फ़ुल नोड्स ब्लॉकचेन का ब्लॉक-बाय-ब्लॉक सत्यापन करते हैं, जिसमें प्रत्येक ब्लॉक के लिए ब्लॉक बॉडी और स्टेट डेटा को डाउनलोड और सत्यापित करना शामिल है। फ़ुल नोड के विभिन्न वर्ग हैं - कुछ उत्पत्ति ब्लॉक से शुरू होते हैं और ब्लॉकचेन के पूरे इतिहास में हर एक ब्लॉक को सत्यापित करते हैं। अन्य लोग अपना सत्यापन एक हाल के ब्लॉक पर शुरू करते हैं जिसे वे वैध मानते हैं (जैसे, Geth का 'स्नैप सिंक')। भले ही सत्यापन कहीं से भी शुरू हो, फ़ुल नोड्स केवल अपेक्षाकृत हाल के डेटा (आमतौर पर सबसे हाल के 128 ब्लॉक) की एक स्थानीय प्रतिलिपि रखते हैं, जिससे डिस्क स्थान को बचाने के लिए पुराने डेटा को हटाया जा सकता है। जरूरत पड़ने पर पुराने डेटा को पुनः उत्पन्न किया जा सकता है।

- पूर्ण ब्लॉकचेन डेटा संग्रहीत करता है (हालांकि यह समय-समय पर छंटनी की जाती है, इसलिए एक फ़ुल नोड सभी स्टेट डेटा को उत्पत्ति में वापस संग्रहीत नहीं करता है)
- ब्लॉक सत्यापन में भाग लेता है, सभी ब्लॉकों और स्टेट की पुष्टि करता है।
- सभी स्टेट को या तो स्थानीय भंडारण से पुनर्प्राप्त किया जा सकता है या एक फ़ुल नोड द्वारा 'स्नैपशॉट' से पुनः उत्पन्न किया जा सकता है।
- नेटवर्क की सेवा करता है और अनुरोध पर डेटा प्रदान करता है।

### आर्काइव नोड {#archive-node}

आर्काइव नोड्स पूर्ण नोड्स हैं जो उत्पत्ति से प्रत्येक ब्लॉक को सत्यापित करते हैं और कभी भी डाउनलोड किए गए किसी भी डेटा को नहीं हटाते हैं।

- फ़ुल नोड में रखी गई हर चीज को संग्रहीत करता है और ऐतिहासिक स्टेट का एक संग्रह बनाता है। इसकी आवश्यकता तब होती है जब आप ब्लॉक #4,000,000 पर खाते की शेष राशि जैसी किसी चीज़ की क्वेरी करना चाहते हैं, या ट्रेसिंग का उपयोग करके उन्हें सत्यापित किए बिना बस और मज़बूती से अपने स्वयं के लेनदेन सेट का परीक्षण करना चाहते हैं।
- यह डेटा टेराबाइट्स की इकाइयों को दिखाता है, जो औसत उपयोगकर्ताओं के लिए संग्रह नोड्स को कम आकर्षक बनाता है लेकिन ब्लॉक खोजकर्ताओं, वॉलेट विक्रेताओं और चेन एनालिटिक्स जैसी सेवाओं के लिए आसान हो सकता है।

संग्रह के अलावा किसी भी मोड में क्लाइंट को सिंक करने से ब्लॉकचेन डेटा की छंटनी होगी। इसका मतलब है, सभी ऐतिहासिक स्टेट्स का कोई संग्रह नहीं है, लेकिन फ़ुल नोड मांग पर उन्हें बनाने में सक्षम है।

[आर्काइव नोड्स](/developers/docs/nodes-and-clients/archive-nodes) के बारे में और जानें।

### लाइट नोड {#light-node}

प्रत्येक ब्लॉक को डाउनलोड करने के बजाय, लाइट नोड्स केवल ब्लॉक हेडर डाउनलोड करते हैं। इन शीर्षलेखों में ब्लॉकों की सामग्री के बारे में सारांश के तौर पर जानकारी होती है। लाइट नोड की आवश्यकता वाली किसी भी अन्य जानकारी को एक फ़ुल नोड से अनुरोध किया जाता है। लाइट नोड तब स्वतंत्र रूप से ब्लॉक हेडर में स्टेट रूट्स के हिसाब से प्राप्त डेटा को सत्यापित कर सकता है। लाइट नोड्स यूज़र को पूर्ण नोड्स चलाने के लिए आवश्यक शक्तिशाली हार्डवेयर या उच्च बैंडविड्थ के बिना एथेरियम नेटवर्क में भाग लेने में सक्षम बनाते हैं। आखिरकार, मोबाइल फ़ोन या एम्बेडेड डिवाइस पर लाइट नोड्स चल सकते हैं। लाइट नोड्स सहमति में भाग नहीं लेते हैं (यानी, वे वैलिडेटर नहीं हो सकते हैं), लेकिन वे एक फुल नोड के समान कार्यक्षमता और सुरक्षा गारंटी के साथ एथेरियम ब्लॉकचेन तक पहुंच सकते हैं।

लाइट क्लाइंट एथेरियम के लिए सक्रिय विकास का एक क्षेत्र हैं और हम जल्द ही सर्वसम्मति परत और निष्पादन परत के लिए नए लाइट क्लाइंट को देखने की उम्मीद करते हैं।
[गॉसिप नेटवर्क](https://www.ethportal.net/) पर लाइट क्लाइंट डेटा प्रदान करने के संभावित मार्ग भी हैं। यह फायदेमंद है, क्योंकि गपशप नेटवर्क अनुरोधों की सेवा के लिए पूर्ण नोड्स की आवश्यकता के बिना लाइट नोड्स के नेटवर्क का सपोर्ट कर सकता है।

एथेरियम अभी तक लाइट नोड्स की एक बड़ी आबादी का सपोर्ट नहीं करता है, लेकिन लाइट नोड सपोर्ट एक ऐसा क्षेत्र है जो निकट भविष्य में तेजी से विकसित होने की उम्मीद है। विशेष रूप से, [Nimbus](https://nimbus.team/), [Helios](https://github.com/a16z/helios), और [LodeStar](https://lodestar.chainsafe.io/) जैसे क्लाइंट्स वर्तमान में लाइट नोड्स पर बहुत अधिक केंद्रित हैं।

## मुझे एथेरियम नोड क्यों चलाना चाहिए? {#why-should-i-run-an-ethereum-node}

नोड चलाने से आप नेटवर्क को अधिक मजबूत और विकेंद्रीकृत रखते हुए एथेरियम को सपोर्ट करते हुए सीधे, भरोसेमंद और निजी तौर पर एथेरियम का उपयोग कर सकते हैं।

### आपके लिए लाभ {#benefits-to-you}

अपना खुद का नोड चलाना आपको निजी, आत्मनिर्भर और भरोसेमंद तरीके से एथेरियम का उपयोग करने में सक्षम बनाता है। आपको नेटवर्क पर भरोसा करने की आवश्यकता नहीं है, क्योंकि आप अपने क्लाइंट के साथ डेटा को खुद सत्यापित कर सकते हैं। "भरोसा न करें, सत्यापित करें" एक लोकप्रिय ब्लॉकचेन मंत्र है।

- आपका नोड सभी लेनदेन और ब्लॉकों को सर्वसम्मति वाले नियमों के हिसाब से खुद सत्यापित करता है। इसका मतलब है कि आपको नेटवर्क में किसी अन्य नोड्स पर भरोसा करने या उन पर पूरी तरह भरोसा करने की आवश्यकता नहीं है।
- आप अपने खुद के नोड के साथ एथेरियम वॉलेट का उपयोग कर सकते हैं। आप dapps का अधिक सुरक्षित और निजी रूप से उपयोग कर सकते हैं, क्योंकि आपको अपने पते और शेष राशि को बिचौलियों को लीक नहीं करना पड़ेगा। सभी चीज़ों की अपने ग्राहकों के साथ जाँच की जा सकती है। [MetaMask](https://metamask.io), [Frame](https://frame.sh/), और [कई अन्य वॉलेट्स](/wallets/find-wallet/) RPC-इंपोर्टिंग की पेशकश करते हैं, जिससे वे आपके नोड का उपयोग कर सकते हैं।
- आप अन्य सेवाओं को चला सकते हैं और स्वयं-होस्ट कर सकते हैं जो एथेरियम के डेटा पर निर्भर करती हैं। उदाहरण के लिए, यह एक बीकन चेन सत्यापनकर्ता, लेयर 2, इन्फ़्रास्ट्रक्चर, ब्लॉक खोजकर्ता, पेमेंट प्रोसेसर आदि जैसे सॉफ़्टवेयर हो सकते हैं।
- आप अपने स्वयं के कस्टम [RPC एंडपॉइंट्स](/developers/docs/apis/json-rpc/) प्रदान कर सकते हैं। आप इन समापन बिंदुओं को सार्वजनिक रूप से समुदाय को बड़े केंद्रीकृत प्रदाताओं से बचने में मदद करने के लिए भी पेश कर सकते हैं।
- आप **इंटर-प्रोसेस कम्युनिकेशन (IPC)** का उपयोग करके अपने नोड से जुड़ सकते हैं या अपने प्रोग्राम को प्लगइन के रूप में लोड करने के लिए नोड को फिर से लिख सकते हैं। यह कम विलंबता प्रदान करता है, जो बहुत मदद करता है, उदा., वेब3 पुस्तकालयों का उपयोग करके बहुत सारे डेटा को संसाधित करते समय या जब आपको अपने लेनदेन को जितनी जल्दी हो सके बदलने की आवश्यकता होती है (यानी, फ्रंटरनिंग)।
- आप नेटवर्क को सुरक्षित करने और पुरस्कार हासिल करने के लिए ETH को सीधे स्टेक कर सकते हैं। शुरू करने के लिए [सोलो स्टेकिंग](/staking/solo/) देखें।

![आप अपने एप्लिकेशन और नोड्स के माध्यम से एथेरियम तक कैसे पहुंचते हैं](./nodes.png)

### नेटवर्क के लाभ {#network-benefits}

एथेरियम के स्वास्थ्य, सुरक्षा और परिचालन लचीलापन के लिए नोड्स का एक विविध सेट महत्वपूर्ण है।

- फ़ुल नोड्स सहमति नियमों को लागू करते हैं, ताकि उन्हें उन ब्लॉकों को स्वीकार करने में धोखा न दिया जा सके जो उनका पालन नहीं करते। यह नेटवर्क में अतिरिक्त सुरक्षा प्रदान करता है, क्योंकि अगर सभी नोड्स लाइट नोड थे, जो पूर्ण सत्यापन नहीं करते हैं, तो सत्यापनकर्ता नेटवर्क पर हमला कर सकते हैं।
- एक ऐसे हमले के मामले में जो [प्रूफ-ऑफ-स्टेक](/developers/docs/consensus-mechanisms/pos/#what-is-pos) की क्रिप्टो-आर्थिक सुरक्षा को पार कर जाता है, एक सामाजिक रिकवरी फुल नोड्स द्वारा की जा सकती है जो ईमानदार श्रृंखला का पालन करने का विकल्प चुनते हैं।
- नेटवर्क में अधिक नोड्स के परिणामस्वरूप एक अधिक विविध और मजबूत नेटवर्क होता है, जो विकेंद्रीकरण का अंतिम लक्ष्य है, जो सेंसरशिप-प्रतिरोधी और विश्वसनीय सिस्टम को सक्षम बनाता है।
- फ़ुल नोड्स लाइट क्लाइंट के लिए ब्लॉकचेन डेटा तक पहुंच प्रदान करते हैं जो इस पर निर्भर करते हैं। लाइट नोड्स पूरे ब्लॉकचेन को संग्रहीत नहीं करते हैं, इसके बजाय वे [ब्लॉक हेडर में स्टेट रूट्स](/developers/docs/blocks/#block-anatomy) के माध्यम से डेटा सत्यापित करते हैं। अगर उन्हें इसकी आवश्यकता हो, तो वे पूर्ण नोड्स से अधिक जानकारी का अनुरोध कर सकते हैं।

अगर आप एक पूर्ण नोड चलाते हैं, तो पूरे एथेरियम नेटवर्क को इससे लाभ होता है, भले ही आप एक सत्यापनकर्ता न चलाएं।

## अपना खुद का नोड चलाना {#running-your-own-node}

अपना खुद का एथेरियम क्लाइंट चलाने के इच्छुक हैं?

शुरुआती-अनुकूल परिचय के लिए, अधिक जानने के लिए हमारे [रन ए नोड](/run-a-node) पेज पर जाएं।

अगर आप एक तकनीकी उपयोगकर्ता हैं, तो [अपना खुद का नोड कैसे स्पिन अप करें](/developers/docs/nodes-and-clients/run-a-node/) इस बारे में अधिक विवरण और विकल्पों में गोता लगाएँ।

## विकल्प {#alternatives}

अपना खुद का नोड सेट करने से आपका समय और संसाधन खर्च हो सकते हैं, लेकिन आपको हमेशा अपना खुद का उदाहरण चलाने की आवश्यकता नहीं होती। इस मामले में, आप किसी तीसरे पक्ष के API प्रदाता का उपयोग कर सकते हैं। इन सेवाओं का उपयोग करने के अवलोकन के लिए, [नोड्स एज़ ए सर्विस](/developers/docs/nodes-and-clients/nodes-as-a-service/) देखें।

अगर कोई आपके समुदाय में सार्वजनिक API के साथ एथेरियम नोड चलाता है, तो आप कस्टम RPC के माध्यम से अपने वॉलेट को सामुदायिक नोड पर इंगित कर सकते हैं और कुछ यादृच्छिक विश्वसनीय तीसरे पक्ष की तुलना में अधिक गोपनीयता प्राप्त कर सकते हैं।

दूसरी ओर, अगर आप कोई क्लाइंट चलाते हैं, तो आप इसे अपने उन दोस्तों के साथ साझा कर सकते हैं जिन्हें इसकी आवश्यकता हो सकती है।

## निष्पादन क्लाइंट {#execution-clients}

एथेरियम समुदाय कई ओपन-सोर्स निष्पादन क्लाइंट (पहले 'Eth1 क्लाइंट', या सिर्फ 'एथेरियम क्लाइंट' के रूप में जाना जाता था) को बनाए रखता है, जिसे विभिन्न प्रोग्रामिंग भाषाओं का उपयोग करके विभिन्न टीमों द्वारा विकसित किया गया है। यह नेटवर्क को मजबूत और अधिक [विविध](/developers/docs/nodes-and-clients/client-diversity/) बनाता है। आदर्श लक्ष्य विफलता के किसी भी बिंदु को कम करने के लिए किसी भी ग्राहक पर हावी हुए बिना विविधता प्राप्त करना है।

यह टेबल विभिन्न क्लाइंट को सारांशित करती है। वे सभी [क्लाइंट परीक्षण](https://github.com/ethereum/tests) पास करते हैं और नेटवर्क अपग्रेड के साथ अपडेट रहने के लिए सक्रिय रूप से बनाए रखे जाते हैं।

| क्लाइंट                                                                                     | भाषा                     | ऑपरेटिंग सिस्टम       | नेटवर्क                | सिंक करने की रणनीतियाँ                                                             | स्टेट की छंटाई |
| ------------------------------------------------------------------------------------------- | ------------------------ | --------------------- | ---------------------- | ---------------------------------------------------------------------------------- | -------------- |
| [Geth](https://geth.ethereum.org/)                                                          | Go                       | Linux, Windows, macOS | मेननेट, सेपोलिया, हुडी | [स्नैप](#snap-sync), [फुल](#full-sync)                                             | आर्काइव, छंटाई |
| [Nethermind](https://www.nethermind.io/)                                                    | C#, .NET | Linux, Windows, macOS | मेननेट, सेपोलिया, हुडी | [स्नैप](#snap-sync) (बिना सर्विंग के), फास्ट, [फुल](#full-sync) | आर्काइव, छंटाई |
| [Besu](https://besu.hyperledger.org/en/stable/)                                             | Java                     | Linux, Windows, macOS | मेननेट, सेपोलिया, हुडी | [स्नैप](#snap-sync), [फास्ट](#fast-sync), [फुल](#full-sync)                        | आर्काइव, छंटाई |
| [Erigon](https://github.com/ledgerwatch/erigon)                                             | Go                       | Linux, Windows, macOS | मेननेट, सेपोलिया, हुडी | [फुल](#full-sync)                                                                  | आर्काइव, छंटाई |
| [Reth](https://reth.rs/)                                                                    | Rust                     | Linux, Windows, macOS | मेननेट, सेपोलिया, हुडी | [फुल](#full-sync)                                                                  | आर्काइव, छंटाई |
| [EthereumJS](https://github.com/ethereumjs/ethereumjs-monorepo) _(बीटा)_ | TypeScript               | Linux, Windows, macOS | सेपोलिया, हुडी         | [फुल](#full-sync)                                                                  | छंटाई की गई    |

समर्थित नेटवर्क के बारे में अधिक जानने के लिए, [एथेरियम नेटवर्क](/developers/docs/networks/) पर पढ़ें।

हर क्लाइंट के पास खास उपयोग के मामले और फायदे होते हैं, इसलिए आपको अपनी प्राथमिकताओं के आधार पर एक चुनना चाहिए। विविधता कार्यान्वयन को विभिन्न विशेषताओं और यूज़र दर्शकों पर केंद्रित करने की अनुमति देती है। आप सुविधाओं, सपोर्ट, प्रोग्रामिंग भाषा या लाइसेंस के आधार पर क्लाइंट चुनना चाह सकते हैं।

### Besu {#besu}

Hyperledger Besu सार्वजनिक और अनुमति प्राप्त नेटवर्क के लिए एक एंटरप्राइज़-ग्रेड एथेरियम क्लाइंट है। यह ट्रेसिंग से लेकर GraphQL तक सभी एथेरियम मेननेट सुविधाओं को चलाता है, इसकी व्यापक निगरानी है और यह खुले सामुदायिक चैनलों और एंटरप्राइज़ के लिए वाणिज्यिक SLA दोनों के माध्यम से ConsenSys द्वारा सपोर्ट करता है। यह Java में लिखा गया है और Apache 2.0 लाइसेंस प्राप्त है।

Besu का विस्तृत [प्रलेखन](https://besu.hyperledger.org/en/stable/) आपको इसकी विशेषताओं और सेटअप के सभी विवरणों के माध्यम से मार्गदर्शन करेगा।

### Erigon {#erigon}

Erigon, जिसे पहले टर्बो-गेथ के नाम से जाना जाता था, गो एथेरियम के फ़ोर्क के रूप में गति और डिस्क-स्पेस दक्षता की ओर उन्मुख था। Erigon एथेरियम का पूरी तरह से फिर से वास्तुशिल्प कार्यान्वयन है, जो वर्तमान में गो में लिखा गया है लेकिन विकास के तहत अन्य भाषाओं में कार्यान्वयन के साथ है। Erigon का लक्ष्य एथेरियम का तेज़, अधिक मॉड्यूलर और अधिक अनुकूलित कार्यान्वयन प्रदान करना है। यह 3 दिनों से कम समय में लगभग 2TB डिस्क स्थान का उपयोग करके एक फ़ुल आर्काइव नोड सिंक कर सकता है।

### Go Ethereum {#geth}

गो एथेरियम (संक्षेप में Geth) एथेरियम प्रोटोकॉल के मूल कार्यान्वयन में से एक है। वर्तमान में, यह यूज़र और डिवलपर्स के लिए सबसे बड़े यूज़र आधार और विभिन्न प्रकार के टूलींग के साथ सबसे व्यापक क्लाइंट है। यह गो में लिखा गया है, पूरी तरह से खुला स्रोत और GNU LGPL v3 के तहत लाइसेंस प्राप्त है।

Geth के बारे में इसके [प्रलेखन](https://geth.ethereum.org/docs/) में और जानें।

### Nethermind {#nethermind}

Nethermind एक एथेरियम कार्यान्वयन है जिसे C# .NET टेक स्टैक के साथ बनाया गया है, जिसे LGPL-3.0 के साथ लाइसेंस प्राप्त है, जो ARM सहित सभी प्रमुख प्लेटफ़ार्मों पर चल रहा है। यह इसके साथ शानदार परफ़ॉर्मेंस प्रदान करता है:

- एक कस्टमाइज़ की गई वर्चुअल मशीन
- स्टेट एक्सेस
- नेटवर्किंग और समृद्ध विशेषताएं जैसे Prometheus/Grafana डैशबोर्ड, seq एंटरप्राइज़ लॉगिंग सपोर्ट, JSON-RPC ट्रेसिंग और एनालिटिक्स प्लगइन्स।

Nethermind के पास [विस्तृत प्रलेखन](https://docs.nethermind.io), मजबूत देव समर्थन, एक ऑनलाइन समुदाय और प्रीमियम उपयोगकर्ताओं के लिए 24/7 सहायता उपलब्ध है।

### Reth {#reth}

Reth (Rust एथेरियम के लिए छोटा) एक एथेरियम फ़ुल नोड कार्यान्वयन है जो यूज़र के अनुकूल, बहुत ज़्यादा मॉड्यूलर, तेज और कुशल होने पर केंद्रित है। Reth मूल रूप से Paradigm द्वारा बनाया और आगे बढ़ाया गया था, और Apache और MIT लाइसेंस के तहत लाइसेंस प्राप्त है।

Reth उत्पादन के लिए तैयार है, और मिशन-महत्वपूर्ण वातावरण जैसे स्टेकिंग या हाई-अपटाइम सेवाओं में उपयोग के लिए सही है। उपयोग के मामलों में अच्छी परफ़ॉर्मेंस देता है जहां RPC, MEV, इंडेक्सिंग, सिमुलेशन और P2P गतिविधियों जैसे महान मार्जिन के साथ बेहतरीन परफ़ॉर्मेंस की आवश्यकता होती है।

[Reth बुक](https://reth.rs/), या [Reth GitHub रिपो](https://github.com/paradigmxyz/reth?tab=readme-ov-file#reth) को देखकर और जानें।

### विकास में {#execution-in-development}

ये क्लाइंट अब भी विकास के पहले चरणों में हैं और अभी तक उत्पादन उपयोग के लिए नहीं सुझाए गए हैं।

#### EthereumJS {#ethereumjs}

EthereumJS निष्पादन क्लाइंट (EthereumJS) TypeScript में लिखा गया है और कई पैकेजों से बना है, जिसमें ब्लॉक, ट्रांज़ैक्शन और मर्कल-पेट्रीसिया ट्राई वर्गों द्वारा दर्शाए गए कोर एथेरियम प्राइमेटिव और एथेरियम वर्चुअल मशीन (EVM), एक ब्लॉकचेन क्लास और DevP2P नेटवर्किंग स्टैक के कार्यान्वयन सहित कोर क्लाइंट घटक शामिल हैं।

इसके [प्रलेखन](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master) को पढ़कर इसके बारे में और जानें

## सहमति क्लाइंट {#consensus-clients}

[सहमति अपग्रेड](/roadmap/beacon-chain/) का समर्थन करने के लिए कई सहमति क्लाइंट (जिन्हें पहले 'Eth2' क्लाइंट के रूप में जाना जाता था) हैं। वे फोर्क-चॉइस एल्गोरिथ्म, साक्ष्यांकनों को संसाधित करने और [प्रूफ-ऑफ-स्टेक](/developers/docs/consensus-mechanisms/pos) पुरस्कारों और दंडों के प्रबंधन सहित सभी सहमति-संबंधी तर्क के लिए जिम्मेदार हैं।

| क्लाइंट                                                       | भाषा       | ऑपरेटिंग सिस्टम       | नेटवर्क                                              |
| ------------------------------------------------------------- | ---------- | --------------------- | ---------------------------------------------------- |
| [Lighthouse](https://lighthouse.sigmaprime.io/)               | Rust       | Linux, Windows, macOS | बीकन चेन, हुडी, पिर्मोंट, सेपोलिया, और अधिक          |
| [Lodestar](https://lodestar.chainsafe.io/)                    | TypeScript | Linux, Windows, macOS | बीकन चेन, हुडी, सेपोलिया, और अधिक                    |
| [Nimbus](https://nimbus.team/)                                | Nim        | Linux, Windows, macOS | बीकन चेन, हुडी, सेपोलिया, और अधिक                    |
| [Prysm](https://prysm.offchainlabs.com/docs/)                 | Go         | Linux, Windows, macOS | बीकन चेन, ग्नोसिस, हुडी, पिर्मोंट, सेपोलिया, और अधिक |
| [Teku](https://consensys.net/knowledge-base/ethereum-2/teku/) | Java       | Linux, Windows, macOS | बीकन चेन, ग्नोसिस, हुडी, सेपोलिया, और अधिक           |
| [Grandine](https://docs.grandine.io/)                         | Rust       | Linux, Windows, macOS | बीकन चेन, हुडी, सेपोलिया, और अधिक                    |

### Lighthouse {#lighthouse}

लाइटहाउस Apache-2.0 लाइसेंस के तहत Rust में लिखा गया एक सर्वसम्मति ग्राहक कार्यान्वयन है। यह सिग्मा प्राइम द्वारा बनाए रखा गया है और बीकन चेन उत्पत्ति के बाद से स्थिर और उत्पादन के लिए तैयार है। यह विभिन्न एंटरप्राइज़, स्टेकिंग पूल और व्यक्तियों द्वारा भरोसा किया जाता है। इसका उद्देश्य डेस्कटॉप PC से परिष्कृत स्वचालित डिप्लॉयमेंट तक, वातावरण की एक विस्तृत सीरीजत़ में सुरक्षित, प्रदर्शनकारी और इंटरऑपरेबल होना है।

प्रलेखन [लाइटहाउस बुक](https://lighthouse-book.sigmaprime.io/) में पाया जा सकता है

### Lodestar {#lodestar}

Lodestar LGPL-3.0 लाइसेंस के तहत TypeScript में लिखा गया एक उत्पादन-तैयार सर्वसम्मति ग्राहक कार्यान्वयन है। यह ChainSafe सिस्टम्स द्वारा बनाए रखा जाता है और एकल-स्टेकर्स, डिवलपर्स और शोधकर्ताओं के लिए आम सहमति ग्राहकों में सबसे नया है। Lodestar में एक बीकन नोड और सत्यापनकर्ता क्लाइंट होता है जो एथेरियम प्रोटोकॉल के JavaScript कार्यान्वयन द्वारा संचालित होता है। Lodestar का उद्देश्य लाइट क्लाइंट के साथ एथेरियम उपयोगिता में सुधार करना, डिवलपर्स के एक बड़े समूह तक पहुंच का विस्तार करना और ईकोसिस्टम की विविधता में और योगदान करना है।

अधिक जानकारी [Lodestar वेबसाइट](https://lodestar.chainsafe.io/) पर मिल सकती है

### Nimbus {#nimbus}

Nimbus, Apache-2.0 लाइसेंस के तहत Nim में लिखा गया एक सर्वसम्मति ग्राहक कार्यान्वयन है। यह एकल-स्टेकर्स और स्टेकिंग पूल द्वारा उपयोग में उत्पादन के लिए तैयार एक क्लाइंट है। Nimbus को संसाधन दक्षता के लिए डिज़ाइन किया गया है, जिससे स्थिरता या इनाम प्रदर्शन से समझौता किए बिना, संसाधन-प्रतिबंधित उपकरणों और एंटरप्राइज़ संबंधी बुनियादी ढांचे पर समान आसानी से चलना आसान हो जाता है। एक लाइट संसाधन पदचिह्न का मतलब है कि नेटवर्क तनाव में होने पर क्लाइंट के पास सुरक्षा का अधिक मार्जिन होता है।

[निंबस डॉक्स](https://nimbus.guide/) में और जानें

### Prysm {#prysm}

प्रिज़्म GPL-3.0 लाइसेंस के तहत गो में लिखा गया एक पूर्ण विशेषताओं वाला, ओपन सोर्स सर्वसम्मति वाला क्लाइंट है। इसमें एक वैकल्पिक वेबपैप UI है और यह स्टेक-एट-होम और संस्थागत उपयोगकर्ताओं दोनों के लिए यूज़र अनुभव, प्रलेखन और विन्यास को प्राथमिकता देता है।

अधिक जानने के लिए [Prysm डॉक्स](https://prysm.offchainlabs.com/docs/) पर जाएं।

### Teku {#teku}

Teku मूल बीकन चेन उत्पत्ति वाले क्लाइंट में से एक है। सामान्य लक्ष्यों (सुरक्षा, मजबूती, स्थिरता, प्रयोज्यता, प्रदर्शन) के साथ, Teku का उद्देश्य विशेष रूप से सभी विभिन्न सर्वसम्मति वाले ग्राहक संबंधी मानकों का पूरी तरह से पालन करना है।

Teku बहुत लचीले परिनियोजन विकल्प प्रदान करता है। बीकन नोड और सत्यापनकर्ता क्लाइंट को एक ही प्रक्रिया के रूप में एक साथ चलाया जा सकता है, जो सिंगल स्टेकर्स के लिए बेहद सुविधाजनक है, या परिष्कृत स्टेकिंग संचालन के लिए नोड्स को अलग से चलाया जा सकता है। इसके अलावा, Teku साइनिंग कुंजी सुरक्षा और स्लैशिंग सुरक्षा के लिए [Web3Signer](https://github.com/ConsenSys/web3signer/) के साथ पूरी तरह से इंटरऑपरेबल है।

Teku, Java में लिखा गया है और Apache 2.0 लाइसेंस प्राप्त है। इसे ConsenSys में प्रोटोकॉल टीम द्वारा विकसित किया गया है जो Besu और Web3Signer के लिए भी ज़िम्मेदार है। [Teku डॉक्स](https://docs.teku.consensys.net/en/latest/) में और जानें।

### Grandine {#grandine}

ग्रैंडाइन एक सर्वसम्मति वाले क्लाइंट से संबंधित कार्यान्वयन है, जिसे GPL-3.0 लाइसेंस के तहत Rust में लिखा गया है। इसका रखरखाव ग्रैंडाइन कोर टीम द्वारा किया जाता है और यह तेज़, बेहतर परफ़ॉर्मेंस वाला और हल्का है। यह रास्पबेरी पाई जैसे कम संसाधन वाले उपकरणों पर चलने वाले सिंगल स्टेकरों से लेकर हज़ारों सत्यापनकर्ताओं को चलाने वाले बड़े संस्थागत स्टेकर्स तक, विभिन्न प्रकार के स्टेकर्स के लिए उपयुक्त है।

प्रलेखन [Grandine बुक](https://docs.grandine.io/) में पाया जा सकता है

## सिंक्रनाइज़ेशन मोड {#sync-modes}

नेटवर्क में वर्तमान डेटा का पालन करने और सत्यापित करने के लिए, एथेरियम क्लाइंट को नेटवर्क की नई स्टेट के साथ सिंक करने की आवश्यकता है। यह साथियों से डेटा डाउनलोड करके, क्रिप्टोग्राफ़िक रूप से उनकी इंटीग्रिटी की पुष्टि करके और स्थानीय ब्लॉकचेन डेटाबेस का निर्माण करके किया जाता है।

सिंक्रनाइज़ेशन मोड विभिन्न ट्रेड-ऑफ़ के साथ इस प्रक्रिया के विभिन्न दृष्टिकोणों को दर्शाते हैं। क्लाइंट सिंक एल्गोरिदम के कार्यान्वयन में भी भिन्न होते हैं। कार्यान्वयन पर बारीकियों के लिए हमेशा अपने चुने हुए ग्राहक के आधिकारिक प्रलेखन देखें।

### निष्पादन परत सिंक मोड {#execution-layer-sync-modes}

निष्पादन परत को अलग-अलग उपयोग के मामलों के हिसाब से अलग-अलग मोड में चलाया जा सकता है, ब्लॉकचेन की वैश्विक स्थिति को फिर से निष्पादित करने से लेकर केवल एक विश्वसनीय चेकपॉइंट से सीरीज़ की नोक के साथ समन्वयित करने तक।

#### फुल सिंक {#full-sync}

एक फ़ुल सिंक सभी ब्लॉकों (हेडर और ब्लॉक निकायों सहित) को डाउनलोड करता है और उत्पत्ति से हर ब्लॉक को निष्पादित करके ब्लॉकचेन की स्टेट को आगे बढ़ाते हुए फिर से जेनरेट करता है।

- विश्वास को कम करता है और प्रत्येक लेनदेन को सत्यापित करके उच्चतम सुरक्षा प्रदान करता है।
- लेन-देन की बढ़ती संख्या के साथ, सभी लेनदेन को प्रोसेस करने में दिनों से लेकर हफ़्तों तक का समय लग सकता है।

[आर्काइव नोड्स](#archive-node) हर ब्लॉक में हर लेनदेन द्वारा किए गए राज्य परिवर्तनों का एक पूरा इतिहास बनाने (और बनाए रखने) के लिए एक फुल सिंक करते हैं।

#### फास्ट सिंक {#fast-sync}

एक फ़ुल सिंक की तरह, एक तेज़ सिंक सभी ब्लॉक (हेडर, लेनदेन और रसीदों सहित) को डाउनलोड करता है। हालांकि, ऐतिहासिक लेनदेन को फिर से प्रोसेस करने के बजाय, एक तेज़ सिंक रसीदों पर निर्भर करता है जब तक कि यह हाल के सिर तक नहीं पहुंच जाता, जब यह एक फ़ुल नोड प्रदान करने के लिए आयात और प्रसंस्करण ब्लॉक पर स्विच करता है।

- फ़ास्ट सिंक रणनीति।
- बैंडविड्थ उपयोग के पक्ष में प्रसंस्करण मांग को कम करता है।

#### स्नैप सिंक {#snap-sync}

स्नैप सिंक सीरीज़ एक-एक करके हर ब्लॉक को भी सत्यापित करता है। हालांकि, उत्पत्ति ब्लॉक से शुरू होने के बजाय, एक स्नैप सिंक हाल ही में 'विश्वसनीय' चेकपॉइंट पर शुरू होता है जिसे सच्चे ब्लॉकचेन का हिस्सा माना जाता है। नोड एक निश्चित आयु से अधिक पुराने डेटा को हटाते समय आवधिक चौकियों को बचाता है। इन स्नैपशॉट का उपयोग स्टेट डेटा को हमेशा के लिए संग्रहीत करने के बजाय, इसे ज़रूरत के हिसाब से फिर से उत्पन्न करने के लिए किया जाता है।

- सबसे तेज़ सिंक रणनीति, वर्तमान में एथेरियम मेननेट में डिफ़ॉल्ट।
- सुरक्षा का त्याग किए बिना बहुत सारे डिस्क उपयोग और नेटवर्क बैंडविड्थ बचाता है।

[स्नैप सिंक पर और अधिक](https://github.com/ethereum/devp2p/blob/master/caps/snap.md)।

#### लाइट सिंक {#light-sync}

लाइट क्लाइंट मोड सभी ब्लॉक हेडर डाउनलोड करता है, डेटा ब्लॉक करता है, और कुछ बेतरतीब ढंग से सत्यापित करता है। केवल विश्वसनीय चेकपॉइंट से सीरीज़ की नोक को सिंक करता है।

- डिवलपर्स और सर्वसम्मति तंत्र में विश्वास पर भरोसा करते हुए केवल नई स्टेट प्राप्त करता है।
- क्लाइंट कुछ ही मिनटों में वर्तमान नेटवर्क स्टेट के साथ उपयोग करने के लिए तैयार है।

**ध्यान दें** लाइट सिंक अभी तक प्रूफ-ऑफ-स्टेक एथेरियम के साथ काम नहीं करता है - लाइट सिंक के नए संस्करण जल्द ही आने चाहिए!

[लाइट क्लाइंट्स के बारे में और जानें](/developers/docs/nodes-and-clients/light-clients/)

### सहमति परत सिंक मोड {#consensus-layer-sync-modes}

#### ऑप्टिमिस्टिक सिंक {#optimistic-sync}

आशावादी सिंक एक पोस्ट-मर्ज सिंक्रनाइज़ेशन रणनीति है जिसे ऑप्ट-इन और पीछे की ओर संगत होने के लिए डिज़ाइन किया गया है, जिससे निष्पादन नोड्स तय तरीकों के माध्यम से सिंक हो सकते हैं। निष्पादन इंजन उन्हें पूरी तरह से सत्यापित किए बिना _आशावादी रूप से_ बीकन ब्लॉकों को आयात कर सकता है, नवीनतम हेड ढूंढ सकता है, और फिर उपरोक्त तरीकों से श्रृंखला को सिंक करना शुरू कर सकता है। फिर, निष्पादन ग्राहक का पता चलने के बाद, यह बीकन सीरीज़ में लेनदेन की वैधता के आम सहमति वाले ग्राहक को सूचित करेगा।

[ऑप्टिमिस्टिक सिंक पर और अधिक](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md)

#### चेकपॉइंट सिंक {#checkpoint-sync}

एक चेकपॉइंट सिंक, जिसे कमजोर सब्जेक्टिविटी सिंक के रूप में भी जाना जाता है, बीकन नोड को सिंक करने के लिए एक बेहतर उपयोगकर्ता अनुभव देता है। यह [कमजोर व्यक्तिपरकता](/developers/docs/consensus-mechanisms/pos/weak-subjectivity/) की धारणाओं पर आधारित है जो जेनेसिस के बजाय हाल के कमजोर व्यक्तिपरकता चेकपॉइंट से बीकन चेन को सिंक करने में सक्षम बनाता है। चेकपॉइंट सिंक, [जेनेसिस](/glossary/#genesis-block) से सिंक करने जैसी समान विश्वास धारणाओं के साथ प्रारंभिक सिंक समय को काफी तेज बनाते हैं।

व्यवहार में, इसका मतलब है कि आपका नोड हाल ही में अंतिम रूप दिए गए स्टेट को डाउनलोड करने के लिए एक दूरस्थ सेवा से जुड़ता है और उस बिंदु से डेटा की पुष्टि करना जारी रखता है। डेटा प्रदान करने वाला तीसरा-पक्ष विश्वसनीय है और इसे सावधानी से चुना जाना चाहिए।

[चेकपॉइंट सिंक](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice) पर और अधिक

## आगे की रीडिंग {#further-reading}

- [एथेरियम 101 - भाग 2 - नोड्स को समझना](https://kauri.io/ethereum-101-part-2-understanding-nodes/48d5098292fd4f11b251d1b1814f0bba/a) _– विल बार्न्स, 13 फरवरी 2019_
- [एथेरियम फुल नोड्स चलाना: मुश्किल से प्रेरित लोगों के लिए एक गाइड](https://medium.com/@JustinMLeroux/running-ethereum-full-nodes-a-guide-for-the-barely-motivated-a8a13e7a0d31) _– जस्टिन लेरॉक्स, 7 नवंबर 2019_

## संबंधित विषय {#related-topics}

- [ब्लॉक](/developers/docs/blocks/)
- [नेटवर्क](/developers/docs/networks/)

## संबंधित ट्यूटोरियल {#related-tutorials}

- [अपने रास्पबेरी पाई 4 को केवल माइक्रोएसडी कार्ड फ्लैश करके एक वैलिडेटर नोड में बदलें – इंस्टॉलेशन गाइड](/developers/tutorials/run-node-raspberry-pi/) _– अपने रास्पबेरी पाई 4 को फ्लैश करें, एक ईथरनेट केबल प्लग करें, एसएसडी डिस्क कनेक्ट करें और रास्पबेरी पाई 4 को निष्पादन परत (मेननेट) और/या सहमति परत (बीकन चेन/वैलिडेटर) चलाने वाले एक पूर्ण एथेरियम नोड में बदलने के लिए डिवाइस को पावर अप करें।_
