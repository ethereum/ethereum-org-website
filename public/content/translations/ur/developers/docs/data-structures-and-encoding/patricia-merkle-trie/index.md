---
title: "مرکل پیٹریشیا ٹرائی"
description: "مرکل پیٹریشیا ٹرائی کا تعارف۔"
lang: ur-in
sidebarDepth: 2
---

ایتھیریم کی اسٹیٹ (تمام اکاؤنٹس، بیلنس، اور اسمارٹ کنٹریکٹس کا مجموعہ)، کو ڈیٹا اسٹرکچر کے ایک خاص ورژن میں انکوڈ کیا جاتا ہے جسے عام طور پر کمپیوٹر سائنس میں مرکل ٹری کہا جاتا ہے۔ یہ اسٹرکچر کرپٹوگرافی میں بہت سی ایپلی کیشنز کے لیے مفید ہے کیونکہ یہ ٹری میں الجھے ہوئے ڈیٹا کے تمام انفرادی ٹکڑوں کے درمیان ایک قابلِ تصدیق تعلق پیدا کرتا ہے، جس کے نتیجے میں ایک واحد **روٹ** ویلیو حاصل ہوتی ہے جسے ڈیٹا کے بارے میں چیزوں کو ثابت کرنے کے لیے استعمال کیا جا سکتا ہے۔

ایتھیریم کا ڈیٹا اسٹرکچر ایک 'موڈیفائیڈ مرکل-پیٹریشیا ٹرائی' ہے، جسے یہ نام اس لیے دیا گیا ہے کیونکہ یہ PATRICIA (پریکٹیکل الگورتھم ٹو ریٹریو انفارمیشن کوڈڈ ان ایلفانیومرک) کی کچھ خصوصیات مستعار لیتا ہے، اور کیونکہ اسے ایتھیریم اسٹیٹ پر مشتمل آئٹمز کی موثر ڈیٹا ری**ٹری**ول کے لیے ڈیزائن کیا گیا ہے۔

ایک مرکل-پیٹریشیا ٹرائی ڈیٹرمنسٹک اور کرپٹوگرافک طور پر قابلِ تصدیق ہے: اسٹیٹ روٹ بنانے کا واحد طریقہ اسے اسٹیٹ کے ہر انفرادی ٹکڑے سے کمپیوٹ کرنا ہے، اور دو اسٹیٹس جو ایک جیسی ہیں، ان کو روٹ ہیش اور ان ہیشز کا موازنہ کر کے آسانی سے ثابت کیا جا سکتا ہے جنہوں نے اسے بنایا (_ایک مرکل پروف_)۔ اس کے برعکس، ایک ہی روٹ ہیش کے ساتھ دو مختلف اسٹیٹس بنانے کا کوئی طریقہ نہیں ہے، اور مختلف ویلیوز کے ساتھ اسٹیٹ میں ترمیم کرنے کی کوئی بھی کوشش ایک مختلف اسٹیٹ روٹ ہیش کا باعث بنے گی۔ نظریاتی طور پر، یہ اسٹرکچر انسرٹس، لک اپس اور ڈیلیٹس کے لیے `O(log(n))` کی کارکردگی کا 'ہولی گریل' فراہم کرتا ہے۔

مستقبل قریب میں، ایتھیریم ایک [ورکل ٹری](/roadmap/verkle-trees) اسٹرکچر میں منتقل ہونے کا ارادہ رکھتا ہے، جو مستقبل میں پروٹوکول میں بہتری کے لیے بہت سے نئے امکانات کھولے گا۔

## شرائط {#prerequisites}

اس صفحے کو بہتر طور پر سمجھنے کے لیے، [ہیشز](https://en.wikipedia.org/wiki/Hash_function)، [مرکل ٹریز](https://en.wikipedia.org/wiki/Merkle_tree)، [ٹرائیز](https://en.wikipedia.org/wiki/Trie) اور [سیریلائزیشن](https://en.wikipedia.org/wiki/Serialization) کا بنیادی علم ہونا مددگار ثابت ہوگا۔ یہ مضمون ایک بنیادی [ریڈکس ٹری](https://en.wikipedia.org/wiki/Radix_tree) کی تفصیل سے شروع ہوتا ہے، پھر آہستہ آہستہ ایتھیریم کے زیادہ آپٹمائزڈ ڈیٹا اسٹرکچر کے لیے ضروری ترمیمات کا تعارف کراتا ہے۔

## بنیادی ریڈکس ٹرائیز {#basic-radix-tries}

ایک بنیادی ریڈکس ٹرائی میں، ہر نوڈ اس طرح نظر آتا ہے:

```
    [i_0, i_1 ... i_n, value]
```

جہاں `i_0 ...` `i_n` حروف تہجی کی علامتوں (اکثر بائنری یا ہیکس) کی نمائندگی کرتے ہیں، `value` نوڈ پر ٹرمینل ویلیو ہے، اور `i_0، i_1 ...` میں موجود ویلیوز `i_n` سلاٹس یا تو `NULL` ہیں یا دوسرے نوڈس کے پوائنٹرز (ہمارے معاملے میں، ہیشز) ہیں۔ یہ ایک بنیادی `(key, value)` اسٹور بناتا ہے۔

فرض کریں کہ آپ کلیدی ویلیو پیئرز کے ایک سیٹ پر ایک آرڈر کو برقرار رکھنے کے لیے ریڈکس ٹری ڈیٹا اسٹرکچر کا استعمال کرنا چاہتے ہیں۔ ٹرائی میں کلید `dog` سے فی الحال میپ شدہ ویلیو تلاش کرنے کے لیے، آپ پہلے `dog` کو حروف تہجی کے حروف میں تبدیل کریں گے (جو `64 6f 67` دے گا)، اور پھر اس راستے پر چلتے ہوئے ٹرائی میں نیچے جائیں گے جب تک کہ آپ کو ویلیو نہ مل جائے۔ یعنی، آپ ٹرائی کے روٹ نوڈ کو تلاش کرنے کے لیے ایک فلیٹ کی/ویلیو DB میں روٹ ہیش کو دیکھ کر شروع کرتے ہیں۔ اسے دوسرے نوڈس کی طرف اشارہ کرنے والی کلیدوں کی ایک صف کے طور پر ظاہر کیا جاتا ہے۔ آپ انڈیکس `6` پر موجود ویلیو کو ایک کلید کے طور پر استعمال کریں گے اور اسے فلیٹ کی/ویلیو DB میں دیکھیں گے تاکہ ایک لیول نیچے نوڈ حاصل کیا جا سکے۔ پھر اگلی ویلیو دیکھنے کے لیے انڈیکس `4` چنیں، پھر انڈیکس `6`، اور اسی طرح، جب تک کہ آپ اس راستے پر نہ چلیں: `root -> 6 -> 4 -> 6 -> 15 -> 6 -> 7`، آپ نوڈ کی ویلیو دیکھیں گے اور نتیجہ واپس کر دیں گے۔

'ٹرائی' اور بنیادی فلیٹ کی/ویلیو 'DB' میں کسی چیز کو تلاش کرنے میں فرق ہے۔ یہ دونوں کی/ویلیو انتظامات کی وضاحت کرتے ہیں، لیکن بنیادی DB ایک کلید کا روایتی 1 قدمی لک اپ کر سکتا ہے۔ ٹرائی میں ایک کلید کو تلاش کرنے کے لیے اوپر بیان کردہ حتمی ویلیو تک پہنچنے کے لیے متعدد بنیادی DB لک اپس کی ضرورت ہوتی ہے۔ آئیے ابہام کو ختم کرنے کے لیے بعد والے کو `path` کے طور پر حوالہ دیں۔

ریڈکس ٹرائیز کے لیے اپ ڈیٹ اور ڈیلیٹ آپریشنز کی وضاحت اس طرح کی جا سکتی ہے:

```python
    def update(node_hash, path, value):
        curnode = db.get(node_hash) if node_hash else [NULL] * 17
        newnode = curnode.copy()
        if path == "":
            newnode[-1] = value
        else:
            newindex = update(curnode[path[0]], path[1:], value)
            newnode[path[0]] = newindex
        db.put(hash(newnode), newnode)
        return hash(newnode)

    def delete(node_hash, path):
        if node_hash is NULL:
            return NULL
        else:
            curnode = db.get(node_hash)
            newnode = curnode.copy()
            if path == "":
                newnode[-1] = NULL
            else:
                newindex = delete(curnode[path[0]], path[1:])
                newnode[path[0]] = newindex

            if all(x is NULL for x in newnode):
                return NULL
            else:
                db.put(hash(newnode), newnode)
                return hash(newnode)
```

ایک "مرکل" ریڈکس ٹری ڈیٹرمنسٹک طور پر تیار کردہ کرپٹوگرافک ہیش ڈائجسٹ کا استعمال کرتے ہوئے نوڈس کو جوڑ کر بنایا جاتا ہے۔ یہ مواد-ایڈریسنگ (کی/ویلیو DB `key == keccak256(rlp(value))` میں) ذخیرہ شدہ ڈیٹا کی کرپٹوگرافک سالمیت کی گارنٹی فراہم کرتا ہے۔ اگر کسی دیے گئے ٹرائی کا روٹ ہیش عوامی طور پر معلوم ہے، تو کوئی بھی شخص جس کے پاس بنیادی لیف ڈیٹا تک رسائی ہو، وہ اس بات کا ثبوت بنا سکتا ہے کہ ٹرائی میں ایک مخصوص راستے پر ایک دی گئی ویلیو شامل ہے، جس کے لیے وہ ہر نوڈ کے ہیشز فراہم کرے گا جو ایک مخصوص ویلیو کو ٹری روٹ سے جوڑتا ہے۔

ایک حملہ آور کے لیے `(path, value)` جوڑے کا ثبوت فراہم کرنا ناممکن ہے جو موجود نہیں ہے کیونکہ روٹ ہیش بالآخر اس کے نیچے کے تمام ہیشز پر مبنی ہے۔ کوئی بھی بنیادی ترمیم روٹ ہیش کو بدل دے گی۔ آپ ہیش کو ڈیٹا کے بارے میں ساختی معلومات کی ایک کمپریسڈ نمائندگی کے طور پر سوچ سکتے ہیں، جو ہیشنگ فنکشن کے پری-امیج تحفظ کے ذریعے محفوظ ہے۔

ہم ریڈکس ٹری کی ایک اٹامک اکائی (مثلاً، ایک واحد ہیکس کریکٹر، یا 4 بٹ بائنری نمبر) کو "نبل" کہیں گے۔ جیسا کہ اوپر بیان کیا گیا ہے، ایک وقت میں ایک نبل کے راستے پر چلتے ہوئے، نوڈس زیادہ سے زیادہ 16 بچوں کا حوالہ دے سکتے ہیں لیکن ایک `value` عنصر شامل کرتے ہیں۔ لہذا، ہم انہیں 17 کی لمبائی والی ایک صف کے طور پر ظاہر کرتے ہیں۔ ہم ان 17-عناصر والی صفوں کو "برانچ نوڈس" کہتے ہیں۔

## مرکل پیٹریشیا ٹرائی {#merkle-patricia-trees}

ریڈکس ٹرائیز کی ایک بڑی حد ہے: وہ غیر موثر ہیں۔ اگر آپ ایک `(path, value)` بائنڈنگ کو ذخیرہ کرنا چاہتے ہیں جہاں پاتھ، جیسا کہ ایتھیریم میں ہے، 64 حروف لمبا ہے (`bytes32` میں نبلز کی تعداد)، تو ہمیں فی کریکٹر ایک لیول کو ذخیرہ کرنے کے لیے ایک کلو بائٹ سے زیادہ اضافی جگہ کی ضرورت ہوگی، اور ہر لک اپ یا ڈیلیٹ میں پورے 64 مراحل لگیں گے۔ درج ذیل میں متعارف کرایا گیا پیٹریشیا ٹرائی اس مسئلے کو حل کرتا ہے۔

### آپٹمائزیشن {#optimization}

مرکل پیٹریشیا ٹرائی میں ایک نوڈ درج ذیل میں سے ایک ہے:

1. `NULL` (خالی اسٹرنگ کے طور پر ظاہر کیا جاتا ہے)
2. `branch` ایک 17 آئٹم والا نوڈ `[ v0 ...` v15, vt ]`
3. `leaf` ایک 2 آئٹم والا نوڈ `[ encodedPath, value ]`
4. `extension` ایک 2 آئٹم والا نوڈ `[ encodedPath, key ]`

64 کریکٹر پاتھس کے ساتھ یہ ناگزیر ہے کہ ٹرائی کی پہلی چند لیئرز کو عبور کرنے کے بعد، آپ ایک ایسے نوڈ پر پہنچ جائیں گے جہاں نیچے کے راستے کے کم از کم ایک حصے کے لیے کوئی مختلف راستہ موجود نہیں ہے۔ راستے میں 15 تک اسپارس `NULL` نوڈز بنانے سے بچنے کے لیے، ہم `[ encodedPath, key ]` کی شکل کا ایک `extension` نوڈ قائم کر کے نزول کو شارٹ کٹ کرتے ہیں، جہاں `encodedPath` آگے بڑھنے کے لیے "جزوی راستہ" پر مشتمل ہے (نیچے بیان کردہ ایک کمپیکٹ انکوڈنگ کا استعمال کرتے ہوئے)، اور `key` اگلے DB لک اپ کے لیے ہے۔

`leaf` نوڈ کے لیے، جسے `encodedPath` کے پہلے نبل میں ایک فلیگ کے ذریعے نشان زد کیا جا سکتا ہے، پاتھ تمام پچھلے نوڈ کے پاتھ کے ٹکڑوں کو انکوڈ کرتا ہے اور ہم براہ راست `value` کو دیکھ سکتے ہیں۔

تاہم، یہ مذکورہ بالا آپٹمائزیشن ابہام پیدا کرتی ہے۔

نبلز میں راستوں کو عبور کرتے وقت، ہمارے پاس عبور کرنے کے لیے نبلز کی ایک طاق تعداد ہو سکتی ہے، لیکن چونکہ تمام ڈیٹا `bytes` فارمیٹ میں ذخیرہ ہوتا ہے۔ مثال کے طور پر، نبل `1`، اور نبلز `01` کے درمیان فرق کرنا ممکن نہیں ہے (دونوں کو `<01>` کے طور پر ذخیرہ کیا جانا چاہیے)۔ طاق لمبائی کی وضاحت کرنے کے لیے، جزوی راستے کو ایک فلیگ کے ساتھ سابقہ لگایا جاتا ہے۔

### تفصیلات: اختیاری ٹرمینیٹر کے ساتھ ہیکس ترتیب کی کمپیکٹ انکوڈنگ {#specification}

جیسا کہ اوپر بیان کیا گیا ہے، _طاق بمقابلہ جفت بقیہ جزوی پاتھ کی لمبائی_ اور _لیف بمقابلہ ایکسٹینشن نوڈ_ دونوں کی فلیگنگ کسی بھی 2-آئٹم نوڈ کے جزوی پاتھ کے پہلے نبل میں ہوتی ہے۔ ان کے نتیجے میں درج ذیل ہوتا ہے:

| ہیکس کریکٹر | بٹس  | نوڈ کی قسم جزوی                    | پاتھ کی لمبائی |
| ----------- | ---- | ---------------------------------- | -------------- |
| 0           | 0000 | ایکسٹینشن                          | جفت            |
| 1           | 0001 | ایکسٹینشن                          | طاق            |
| 2           | 0010 | ٹرمینیٹنگ (لیف) | جفت            |
| 3           | 0011 | ٹرمینیٹنگ (لیف) | طاق            |

جفت بقیہ پاتھ کی لمبائی (`0` یا `2`) کے لیے، ایک اور `0` "پیڈنگ" نبل ہمیشہ پیچھے آئے گا۔

```python
    def compact_encode(hexarray):
        term = 1 if hexarray[-1] == 16 else 0
        if term:
            hexarray = hexarray[:-1]
        oddlen = len(hexarray) % 2
        flags = 2 * term + oddlen
        if oddlen:
            hexarray = [flags] + hexarray
        else:
            hexarray = [flags] + [0] + hexarray
        # hexarray کی اب ایک جفت لمبائی ہے جس کا پہلا نبل فلیگز ہے۔
        o = ""
        for i in range(0, len(hexarray), 2):
            o += chr(16 * hexarray[i] + hexarray[i + 1])
        return o
```

مثالیں:

```python
    > [1, 2, 3, 4, 5, ...]
    '11 23 45'
    > [0, 1, 2, 3, 4, 5, ...]
    '00 01 23 45'
    > [0, f, 1, c, b, 8, 10]
    '20 0f 1c b8'
    > [f, 1, c, b, 8, 10]
    '3f 1c b8'
```

مرکل پیٹریشیا ٹرائی میں ایک نوڈ حاصل کرنے کے لیے یہاں توسیع شدہ کوڈ ہے:

```python
    def get_helper(node_hash, path):
        if path == []:
            return node_hash
        if node_hash == "":
            return ""
        curnode = rlp.decode(node_hash if len(node_hash) < 32 else db.get(node_hash))
        if len(curnode) == 2:
            (k2, v2) = curnode
            k2 = compact_decode(k2)
            if k2 == path[: len(k2)]:
                return get(v2, path[len(k2) :])
            else:
                return ""
        elif len(curnode) == 17:
            return get_helper(curnode[path[0]], path[1:])

    def get(node_hash, path):
        path2 = []
        for i in range(len(path)):
            path2.push(int(ord(path[i]) / 16))
            path2.push(ord(path[i]) % 16)
        path2.push(16)
        return get_helper(node_hash, path2)
```

### مثالی ٹرائی {#example-trie}

فرض کریں کہ ہم ایک ایسی ٹرائی چاہتے ہیں جس میں چار پاتھ/ویلیو جوڑے ہوں `('do', 'verb')`, `('dog', 'puppy')`, `('doge', 'coins')`, `('horse', 'stallion')`۔

سب سے پہلے، ہم پاتھس اور ویلیوز دونوں کو `bytes` میں تبدیل کرتے ہیں۔ نیچے، _پاتھس_ کے لیے اصل بائٹ کی نمائندگی `<>` سے کی گئی ہے، حالانکہ _ویلیوز_ کو اب بھی اسٹرنگز کے طور پر دکھایا گیا ہے، جسے `''` سے ظاہر کیا گیا ہے، تاکہ سمجھنے میں آسانی ہو (وہ بھی، دراصل `bytes` ہوں گے):

```
    <64 6f> : 'verb'
    <64 6f 67> : 'puppy'
    <64 6f 67 65> : 'coins'
    <68 6f 72 73 65> : 'stallion'
```

اب، ہم بنیادی DB میں درج ذیل کی/ویلیو جوڑوں کے ساتھ ایسی ٹرائی بناتے ہیں:

```
    rootHash: [ <16>, hashA ]
    hashA:    [ <>, <>, <>, <>, hashB, <>, <>, <>, [ <20 6f 72 73 65>, 'stallion' ], <>, <>, <>, <>, <>, <>, <>, <> ]
    hashB:    [ <00 6f>, hashC ]
    hashC:    [ <>, <>, <>, <>, <>, <>, hashD, <>, <>, <>, <>, <>, <>, <>, <>, <>, 'verb' ]
    hashD:    [ <17>, [ <>, <>, <>, <>, <>, <>, [ <35>, 'coins' ], <>, <>, <>, <>, <>, <>, <>, <>, <>, 'puppy' ] ]
```

جب ایک نوڈ کا حوالہ دوسرے نوڈ کے اندر دیا جاتا ہے، تو جو چیز شامل کی جاتی ہے وہ `keccak256(rlp.encode(node))` ہے، اگر `len(rlp.encode(node)) >= 32` ورنہ `node` جہاں `rlp.encode` [RLP](/developers/docs/data-structures-and-encoding/rlp) انکوڈنگ فنکشن ہے۔

نوٹ کریں کہ ٹرائی کو اپ ڈیٹ کرتے وقت، کسی کو کی/ویلیو جوڑا `(keccak256(x), x)` کو ایک مستقل لک اپ ٹیبل میں ذخیرہ کرنے کی ضرورت ہے _اگر_ نئے بنائے گئے نوڈ کی لمبائی >= 32 ہے۔ تاہم، اگر نوڈ اس سے چھوٹا ہے، تو کسی کو کچھ بھی ذخیرہ کرنے کی ضرورت نہیں ہے، کیونکہ فنکشن f(x) = x قابلِ واپسی ہے۔

## ایتھیریم میں ٹرائیز {#tries-in-ethereum}

ایتھیریم کی ایگزیکیوشن لیئر میں تمام مرکل ٹرائیز ایک مرکل پیٹریشیا ٹرائی کا استعمال کرتی ہیں۔

ایک بلاک ہیڈر سے ان 3 ٹرائیز کے 3 روٹس ہوتے ہیں۔

1. stateRoot
2. transactionsRoot
3. receiptsRoot

### اسٹیٹ ٹرائی {#state-trie}

ایک عالمی اسٹیٹ ٹرائی ہے، اور جب بھی کوئی کلائنٹ کسی بلاک پر کارروائی کرتا ہے تو اسے اپ ڈیٹ کیا جاتا ہے۔ اس میں، ایک `path` ہمیشہ ہوتا ہے: `keccak256(ethereumAddress)` اور ایک `value` ہمیشہ ہوتی ہے: `rlp(ethereumAccount)`۔ مزید خاص طور پر ایک ایتھیریم `account` ایک 4 آئٹم کی صف ہے `[nonce,balance,storageRoot,codeHash]`۔ اس مقام پر، یہ بات قابل غور ہے کہ یہ `storageRoot` ایک اور پیٹریشیا ٹرائی کا روٹ ہے:

### اسٹوریج ٹرائی {#storage-trie}

اسٹوریج ٹرائی وہ جگہ ہے جہاں _تمام_ کنٹریکٹ ڈیٹا رہتا ہے۔ ہر اکاؤنٹ کے لیے ایک الگ اسٹوریج ٹرائی ہوتی ہے۔ کسی دیے گئے ایڈریس پر مخصوص اسٹوریج پوزیشنز پر ویلیوز کو بازیافت کرنے کے لیے اسٹوریج ایڈریس، اسٹوریج میں ذخیرہ شدہ ڈیٹا کی انٹیجر پوزیشن، اور بلاک آئی ڈی کی ضرورت ہوتی ہے۔ اس کے بعد انہیں JSON-RPC API میں بیان کردہ `eth_getStorageAt` میں آرگیومنٹس کے طور پر پاس کیا جا سکتا ہے، مثلاً، ایڈریس `0x295a70b2de5e3953354a6a8344e616ed314d7251` کے لیے اسٹوریج سلاٹ 0 میں ڈیٹا بازیافت کرنے کے لیے:

```bash
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x0", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x00000000000000000000000000000000000000000000000000000000000004d2"}

```

اسٹوریج میں دیگر عناصر کو بازیافت کرنا قدرے زیادہ پیچیدہ ہے کیونکہ اسٹوریج ٹرائی میں پوزیشن کا پہلے حساب لگانا ضروری ہے۔ پوزیشن کا حساب ایڈریس اور اسٹوریج پوزیشن کے `keccak256` ہیش کے طور پر کیا جاتا ہے، دونوں کو 32 بائٹس کی لمبائی تک صفر کے ساتھ بائیں طرف پیڈ کیا جاتا ہے۔ مثال کے طور پر، ایڈریس `0x391694e7e0b0cce554cb130d723a9d27458f9298` کے لیے اسٹوریج سلاٹ 1 میں ڈیٹا کی پوزیشن یہ ہے:

```python
keccak256(decodeHex("000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298" + "0000000000000000000000000000000000000000000000000000000000000001"))
```

Geth کنسول میں، اس کا حساب اس طرح کیا جا سکتا ہے:

```
> var key = "000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298" + "0000000000000000000000000000000000000000000000000000000000000001"
undefined
> web3.sha3(key, {"encoding": "hex"})
"0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9"
```

`path` اس لیے `keccak256(<6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9>)` ہے۔ اب اسے پہلے کی طرح اسٹوریج ٹرائی سے ڈیٹا بازیافت کرنے کے لیے استعمال کیا جا سکتا ہے:

```bash
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000162e"}
```

نوٹ: ایتھیریم اکاؤنٹ کے لیے `storageRoot` پہلے سے خالی ہوتا ہے اگر یہ کوئی کنٹریکٹ اکاؤنٹ نہ ہو۔

### ٹرانزیکشنز ٹرائی {#transaction-trie}

ہر بلاک کے لیے ایک الگ ٹرانزیکشنز ٹرائی ہوتی ہے، جو دوبارہ `(key, value)` جوڑوں کو ذخیرہ کرتی ہے۔ یہاں ایک پاتھ ہے: `rlp(transactionIndex)` جو اس کلید کی نمائندگی کرتا ہے جو اس کے ذریعے طے شدہ ویلیو کے مساوی ہے:

```python
if legacyTx:
  value = rlp(tx)
else:
  value = TxType | encode(tx)
```

اس بارے میں مزید معلومات [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718) ڈاکومنٹیشن میں مل سکتی ہیں۔

### رسیدوں کی ٹرائی {#receipts-trie}

ہر بلاک کی اپنی رسیدوں کی ٹرائی ہوتی ہے۔ یہاں ایک `path` ہے: `rlp(transactionIndex)`۔ `transactionIndex` اس بلاک کے اندر اس کا انڈیکس ہے جس میں اسے شامل کیا گیا تھا۔ رسیدوں کی ٹرائی کو کبھی اپ ڈیٹ نہیں کیا جاتا۔ ٹرانزیکشنز ٹرائی کی طرح، موجودہ اور لیگیسی رسیدیں ہیں۔ رسیدوں کی ٹرائی میں ایک مخصوص رسید کو استفسار کرنے کے لیے، اس کے بلاک میں ٹرانزیکشن کا انڈیکس، رسید کا پے لوڈ اور ٹرانزیکشن کی قسم درکار ہے۔ واپس کی گئی رسید `Receipt` قسم کی ہو سکتی ہے جس کی تعریف `TransactionType` اور `ReceiptPayload` کے جوڑ کے طور پر کی گئی ہے یا یہ `LegacyReceipt` قسم کی ہو سکتی ہے جس کی تعریف `rlp([status, cumulativeGasUsed, logsBloom, logs])` کے طور پر کی گئی ہے۔

اس بارے میں مزید معلومات [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718) ڈاکومنٹیشن میں مل سکتی ہیں۔

## مزید مطالعہ {#further-reading}

- [موڈیفائیڈ مرکل پیٹریشیا ٹرائی — ایتھیریم اسٹیٹ کو کیسے بچاتا ہے](https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd)
- [ایتھیریم میں مرکلنگ](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)
- [ایتھیریم ٹرائی کو سمجھنا](https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/)
