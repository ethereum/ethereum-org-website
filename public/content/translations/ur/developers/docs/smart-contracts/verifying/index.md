---
title: اسمارٹ کنٹریکٹس کی تصدیق کرنا
description: ایتھیریم اسمارٹ کنٹریکٹس کے لیے سورس کوڈ کی توثیق کا ایک جائزہ
lang: ur-in
---

[اسمارٹ کنٹریکٹس](/developers/docs/smart-contracts/) کو 'بھروسے سے پاک' (trustless) ہونے کے لیے ڈیزائن کیا گیا ہے، جس کا مطلب ہے کہ صارفین کو کسی کنٹریکٹ کے ساتھ تعامل کرنے سے پہلے تیسرے فریقوں (مثلاً، ڈیولپرز اور کمپنیوں) پر بھروسہ کرنے کی ضرورت نہیں ہونی چاہیے۔ بھروسے سے پاک ہونے کی شرط کے طور پر، صارفین اور دیگر ڈیولپرز کو اسمارٹ کنٹریکٹ کے سورس کوڈ کی تصدیق کرنے کے قابل ہونا چاہیے۔ سورس کوڈ کی توثیق صارفین اور ڈیولپرز کو یقین دلاتی ہے کہ شائع شدہ کنٹریکٹ کوڈ وہی کوڈ ہے جو ایتھیریم بلاک چین پر کنٹریکٹ ایڈریس پر چل رہا ہے۔

"سورس کوڈ کی توثیق" اور "[رسمی توثیق](/developers/docs/smart-contracts/formal-verification/)" کے درمیان فرق کرنا ضروری ہے۔ سورس کوڈ کی توثیق، جس کی تفصیل ذیل میں بیان کی جائے گی، اس بات کی توثیق کرنے سے مراد ہے کہ ایک اعلیٰ سطحی زبان (مثلاً، Solidity) میں اسمارٹ کنٹریکٹ کا دیا گیا سورس کوڈ اسی بائٹ کوڈ میں کمپائل ہوتا ہے جسے کنٹریکٹ ایڈریس پر عمل میں لایا جانا ہے۔ تاہم، رسمی توثیق ایک اسمارٹ کنٹریکٹ کی درستگی کی توثیق کو بیان کرتی ہے، یعنی کنٹریکٹ توقع کے مطابق برتاؤ کرتا ہے۔ اگرچہ سیاق و سباق پر منحصر ہے، کنٹریکٹ کی توثیق سے مراد عام طور پر سورس کوڈ کی توثیق ہے۔

## سورس کوڈ کی توثیق کیا ہے؟ {#what-is-source-code-verification}

[ایتھیریم ورچوئل مشین (EVM)](/developers/docs/evm/) میں اسمارٹ کنٹریکٹ کو تعینات کرنے سے پہلے، ڈیولپرز کنٹریکٹ کے سورس کوڈ — [Solidity](/developers/docs/smart-contracts/languages/) یا کسی دوسری اعلیٰ سطحی پروگرامنگ زبان میں لکھی گئی ہدایات — کو بائٹ کوڈ میں [کمپائل](/developers/docs/smart-contracts/compiling/) کرتے ہیں۔ چونکہ EVM اعلیٰ سطحی ہدایات کی تشریح نہیں کر سکتا، اس لیے EVM میں کنٹریکٹ کی منطق کو نافذ کرنے کے لیے سورس کوڈ کو بائٹ کوڈ (یعنی، نچلی سطح کی، مشین کی ہدایات) میں کمپائل کرنا ضروری ہے۔

سورس کوڈ کی توثیق ایک اسمارٹ کنٹریکٹ کے سورس کوڈ اور کنٹریکٹ کی تخلیق کے دوران استعمال ہونے والے کمپائل شدہ بائٹ کوڈ کا موازنہ کرنا ہے تاکہ کسی بھی فرق کا پتہ لگایا جا سکے۔ اسمارٹ کنٹریکٹس کی تصدیق کرنا اس لیے اہم ہے کیونکہ مشتہر کردہ کنٹریکٹ کوڈ اس سے مختلف ہو سکتا ہے جو بلاک چین پر چلتا ہے۔

اسمارٹ کنٹریکٹ کی توثیق مشین کوڈ پڑھے بغیر، اس اعلیٰ سطحی زبان کے ذریعے جس میں یہ لکھا گیا ہے، یہ جانچنے کے قابل بناتی ہے کہ ایک کنٹریکٹ کیا کرتا ہے۔ فنکشنز، ویلیوز، اور عام طور پر متغیر کے نام اور تبصرے اصل سورس کوڈ کے ساتھ وہی رہتے ہیں جسے کمپائل اور تعینات کیا جاتا ہے۔ یہ کوڈ کو پڑھنا بہت آسان بنا دیتا ہے۔ سورس کی توثیق کوڈ کی دستاویزات کے لیے بھی سہولت فراہم کرتی ہے، تاکہ اختتامی صارفین جان سکیں کہ ایک اسمارٹ کنٹریکٹ کیا کرنے کے لیے ڈیزائن کیا گیا ہے۔

### مکمل توثیق کیا ہے؟ {#full-verification}

سورس کوڈ کے کچھ حصے ایسے ہیں جو کمپائل شدہ بائٹ کوڈ کو متاثر نہیں کرتے ہیں جیسے تبصرے یا متغیر کے نام۔ اس کا مطلب ہے کہ مختلف متغیر ناموں اور مختلف تبصروں والے دو سورس کوڈز دونوں ایک ہی کنٹریکٹ کی تصدیق کر سکیں گے۔ اس کے ساتھ، ایک بدنیتی پر مبنی اداکار سورس کوڈ کے اندر دھوکہ دہی والے تبصرے شامل کر سکتا ہے یا گمراہ کن متغیر نام دے سکتا ہے اور اصل سورس کوڈ سے مختلف سورس کوڈ کے ساتھ کنٹریکٹ کی تصدیق کروا سکتا ہے۔

اس سے بچنا ممکن ہے بائٹ کوڈ میں اضافی ڈیٹا کو شامل کر کے تاکہ سورس کوڈ کی درستگی کے لیے _کرپٹوگرافک گارنٹی_ کے طور پر کام کرے، اور تالیف کی معلومات کے _فنگر پرنٹ_ کے طور پر۔ ضروری معلومات [Solidity کے کنٹریکٹ میٹا ڈیٹا](https://docs.soliditylang.org/en/v0.8.15/metadata.html) میں پائی جاتی ہیں، اور اس فائل کا ہیش ایک کنٹریکٹ کے بائٹ کوڈ میں شامل کیا جاتا ہے۔ آپ اسے [میٹا ڈیٹا پلے گراؤنڈ](https://playground.sourcify.dev) میں عمل میں دیکھ سکتے ہیں

میٹا ڈیٹا فائل میں کنٹریکٹ کی تالیف کے بارے میں معلومات ہوتی ہیں بشمول سورس فائلیں اور ان کے ہیشز۔ مطلب، اگر کوئی بھی تالیف کی ترتیبات یا یہاں تک کہ سورس فائلوں میں سے کسی ایک میں ایک بائٹ بھی تبدیل ہوتا ہے، تو میٹا ڈیٹا فائل تبدیل ہو جاتی ہے۔ نتیجتاً میٹا ڈیٹا فائل کا ہیش، جو بائٹ کوڈ میں شامل کیا جاتا ہے، بھی تبدیل ہو جاتا ہے۔ اس کا مطلب یہ ہے کہ اگر کسی کنٹریکٹ کا بائٹ کوڈ + اضافی میٹا ڈیٹا ہیش دیے گئے سورس کوڈ اور کمپائلیشن سیٹنگز سے میل کھاتا ہے، تو ہم اس بات کا یقین کر سکتے ہیں کہ یہ بالکل وہی سورس کوڈ ہے جو اصل کمپائلیشن میں استعمال ہوا تھا، یہاں تک کہ ایک بائٹ بھی مختلف نہیں ہے۔

اس قسم کی توثیق جو میٹا ڈیٹا ہیش کا فائدہ اٹھاتی ہے اسے **"[مکمل توثیق](https://docs.sourcify.dev/docs/full-vs-partial-match/)"** کہا جاتا ہے (جسے "کامل توثیق" بھی کہتے ہیں)۔ اگر میٹا ڈیٹا ہیشز مماثل نہ ہوں یا تصدیق میں ان پر غور نہ کیا جائے تو یہ ایک "جزوی مماثلت" ہوگی، جو فی الحال کنٹریکٹس کی تصدیق کا زیادہ عام طریقہ ہے۔ مکمل توثیق کے بغیر [بدنیتی پر مبنی کوڈ داخل کرنا](https://samczsun.com/hiding-in-plain-sight/) ممکن ہے جو تصدیق شدہ سورس کوڈ میں ظاہر نہیں ہوگا۔ زیادہ تر ڈیولپرز مکمل توثیق سے واقف نہیں ہیں اور اپنی تالیف کی میٹا ڈیٹا فائل نہیں رکھتے ہیں، اس لیے اب تک کنٹریکٹس کی تصدیق کے لیے جزوی توثیق ہی اصل طریقہ رہا ہے۔

## سورس کوڈ کی توثیق کیوں اہم ہے؟ {#importance-of-source-code-verification}

### بھروسے سے پاک ہونا {#trustlessness}

بھروسے سے پاک ہونا بلاشبہ اسمارٹ کنٹریکٹس اور [غیر مرکزی ایپلی کیشنز (dapps)](/developers/docs/dapps/) کے لیے سب سے بڑی بنیاد ہے۔ اسمارٹ کنٹریکٹس "ناقابل تغیر" ہیں اور ان میں تبدیلی نہیں کی جا سکتی؛ ایک کنٹریکٹ صرف اس کاروباری منطق کو نافذ کرے گا جو تعیناتی کے وقت کوڈ میں بیان کی گئی ہے۔ اس کا مطلب ہے کہ ڈیولپرز اور ادارے Ethereum پر تعینات کرنے کے بعد کسی کنٹریکٹ کے کوڈ میں چھیڑ چھاڑ نہیں کر سکتے۔

ایک اسمارٹ کنٹریکٹ کے بھروسے سے پاک ہونے کے لیے، کنٹریکٹ کا کوڈ آزادانہ توثیق کے لیے دستیاب ہونا چاہیے۔ جبکہ ہر اسمارٹ کنٹریکٹ کے لیے کمپائل شدہ بائٹ کوڈ بلاک چین پر عوامی طور پر دستیاب ہے، نچلی سطح کی زبان کو سمجھنا مشکل ہے—ڈیولپرز اور صارفین دونوں کے لیے۔

پروجیکٹس اپنے کنٹریکٹس کا سورس کوڈ شائع کر کے بھروسے کے مفروضوں کو کم کرتے ہیں۔ لیکن یہ ایک اور مسئلے کا باعث بنتا ہے: اس بات کی تصدیق کرنا مشکل ہے کہ شائع شدہ سورس کوڈ کنٹریکٹ بائٹ کوڈ سے میل کھاتا ہے۔ اس منظر نامے میں، بھروسے سے پاک ہونے کی قدر ختم ہو جاتی ہے کیونکہ صارفین کو ڈیولپرز پر بھروسہ کرنا پڑتا ہے کہ وہ اسے بلاک چین پر تعینات کرنے سے پہلے کنٹریکٹ کی کاروباری منطق (یعنی، بائٹ کوڈ کو تبدیل کر کے) کو تبدیل نہیں کریں گے۔

سورس کوڈ کی توثیق کے ٹولز اس بات کی ضمانت فراہم کرتے ہیں کہ اسمارٹ کنٹریکٹ کی سورس کوڈ فائلیں اسمبلی کوڈ سے میل کھاتی ہیں۔ نتیجہ ایک بھروسے سے پاک ماحولیاتی نظام ہے، جہاں صارفین تیسرے فریقوں پر آنکھیں بند کر کے بھروسہ نہیں کرتے اور اس کے بجائے کنٹریکٹ میں فنڈز جمع کرنے سے پہلے کوڈ کی تصدیق کرتے ہیں۔

### صارف کی حفاظت {#user-safety}

اسمارٹ کنٹریکٹس کے ساتھ، عام طور پر بہت سا پیسہ داؤ پر لگا ہوتا ہے۔ یہ اسمارٹ کنٹریکٹ کو استعمال کرنے سے پہلے اعلیٰ حفاظتی ضمانتوں اور اس کی منطق کی توثیق کا مطالبہ کرتا ہے۔ مسئلہ یہ ہے کہ بے ایمان ڈیولپرز ایک اسمارٹ کنٹریکٹ میں بدنیتی پر مبنی کوڈ داخل کر کے صارفین کو دھوکہ دے سکتے ہیں۔ توثیق کے بغیر، بدنیتی پر مبنی اسمارٹ کنٹریکٹس میں [بیک ڈورز](https://www.trustnodes.com/2018/11/10/concerns-rise-over-backdoored-smart-contracts)، متنازعہ رسائی کنٹرول میکانزم، قابل استحصال کمزوریاں، اور دیگر چیزیں ہو سکتی ہیں جو صارف کی حفاظت کو خطرے میں ڈالتی ہیں جن کا پتہ نہیں چل پاتا۔

ایک اسمارٹ کنٹریکٹ کی سورس کوڈ فائلوں کو شائع کرنے سے دلچسپی رکھنے والوں، جیسے آڈیٹرز، کے لیے ممکنہ حملے کے ویکٹرز کے لیے کنٹریکٹ کا جائزہ لینا آسان ہو جاتا ہے۔ ایک سے زیادہ فریقوں کے آزادانہ طور پر ایک اسمارٹ کنٹریکٹ کی تصدیق کرنے سے، صارفین کو اس کی حفاظت کی مضبوط ضمانتیں ملتی ہیں۔

## ایتھیریم اسمارٹ کنٹریکٹس کے لیے سورس کوڈ کی تصدیق کیسے کریں {#source-code-verification-for-ethereum-smart-contracts}

[ایتھیریم پر اسمارٹ کنٹریکٹ کو تعینات کرنے](/developers/docs/smart-contracts/deploying/) کے لیے ایک خصوصی ایڈریس پر ڈیٹا پے لوڈ (کمپائل شدہ بائٹ کوڈ) کے ساتھ ایک ٹرانزیکشن بھیجنے کی ضرورت ہوتی ہے۔ ڈیٹا پے لوڈ سورس کوڈ کو کمپائل کرنے سے پیدا ہوتا ہے، نیز کنٹریکٹ انسٹنس کے [کنسٹرکٹر آرگیومنٹس](https://docs.soliditylang.org/en/v0.8.14/contracts.html#constructor) جو ٹرانزیکشن میں ڈیٹا پے لوڈ میں شامل کیے جاتے ہیں۔ کمپائلیشن قطعی ہے، یعنی یہ ہمیشہ ایک ہی آؤٹ پٹ (یعنی کنٹریکٹ بائٹ کوڈ) پیدا کرتا ہے اگر وہی سورس فائلیں، اور کمپائلیشن سیٹنگز (مثلاً، کمپائلر ورژن، آپٹمائزر) استعمال کی جائیں۔

![ایک ڈایاگرام جو اسمارٹ کنٹریکٹ سورس کوڈ کی توثیق کو دکھا رہا ہے](./source-code-verification.png)

ایک اسمارٹ کنٹریکٹ کی تصدیق میں بنیادی طور پر درج ذیل اقدامات شامل ہیں:

1. سورس فائلوں اور کمپائلیشن سیٹنگز کو ایک کمپائلر میں ان پٹ کریں۔

2. کمپائلر کنٹریکٹ کا بائٹ کوڈ آؤٹ پٹ کرتا ہے۔

3. دیے گئے ایڈریس پر تعینات کردہ کنٹریکٹ کا بائٹ کوڈ حاصل کریں۔

4. تعینات کردہ بائٹ کوڈ کا دوبارہ کمپائل شدہ بائٹ کوڈ سے موازنہ کریں۔ اگر کوڈز میل کھاتے ہیں، تو کنٹریکٹ دیے گئے سورس کوڈ اور کمپائلیشن سیٹنگز کے ساتھ تصدیق شدہ ہو جاتا ہے۔

5. مزید برآں، اگر بائٹ کوڈ کے آخر میں موجود میٹا ڈیٹا ہیشز میچ ہوتے ہیں، تو یہ ایک مکمل میچ ہوگا۔

نوٹ کریں کہ یہ توثیق کی ایک سادہ سی تفصیل ہے اور اس میں بہت سے استثناء ہیں جو اس کے ساتھ کام نہیں کریں گے جیسے [ناقابل تغیر متغیرات](https://docs.sourcify.dev/docs/immutables/) کا ہونا۔

## سورس کوڈ کی توثیق کے ٹولز {#source-code-verification-tools}

کنٹریکٹس کی تصدیق کا روایتی عمل پیچیدہ ہو سکتا ہے۔ اسی لیے ہمارے پاس Ethereum پر تعینات اسمارٹ کنٹریکٹس کے لیے سورس کوڈ کی تصدیق کے لیے ٹولز ہیں۔ یہ ٹولز سورس کوڈ کی توثیق کے بڑے حصوں کو خودکار بناتے ہیں اور صارفین کے فائدے کے لیے تصدیق شدہ کنٹریکٹس کو بھی کیوریٹ کرتے ہیں۔

### Etherscan {#etherscan}

اگرچہ زیادہ تر [ایتھیریم بلاک چین ایکسپلورر](/developers/docs/data-and-analytics/block-explorers/) کے طور پر جانا جاتا ہے، Etherscan اسمارٹ کنٹریکٹ ڈیولپرز اور صارفین کے لیے ایک [سورس کوڈ کی توثیق کی خدمت](https://etherscan.io/verifyContract) بھی پیش کرتا ہے۔

Etherscan آپ کو اصل ڈیٹا پے لوڈ (سورس کوڈ، لائبریری ایڈریس، کمپائلر سیٹنگز، کنٹریکٹ ایڈریس، وغیرہ) سے کنٹریکٹ بائٹ کوڈ کو دوبارہ کمپائل کرنے کی اجازت دیتا ہے۔ اگر دوبارہ کمپائل شدہ بائٹ کوڈ آن چین کنٹریکٹ کے بائٹ کوڈ (اور کنسٹرکٹر پیرامیٹرز) سے وابستہ ہے، تو [کنٹریکٹ کی تصدیق ہو جاتی ہے](https://info.etherscan.com/types-of-contract-verification/)۔

ایک بار تصدیق ہو جانے کے بعد، آپ کے کنٹریکٹ کے سورس کوڈ کو "تصدیق شدہ" کا لیبل ملتا ہے اور اسے دوسروں کے آڈٹ کے لیے Etherscan پر شائع کیا جاتا ہے۔ اسے [تصدیق شدہ کنٹریکٹس](https://etherscan.io/contractsVerified/) سیکشن میں بھی شامل کیا جاتا ہے— جو تصدیق شدہ سورس کوڈ والے اسمارٹ کنٹریکٹس کا ایک ذخیرہ ہے۔

Etherscan کنٹریکٹس کی تصدیق کے لیے سب سے زیادہ استعمال ہونے والا ٹول ہے۔ تاہم، Etherscan کی کنٹریکٹ کی توثیق میں ایک خامی ہے: یہ آن چین بائٹ کوڈ اور دوبارہ کمپائل شدہ بائٹ کوڈ کے **میٹا ڈیٹا ہیش** کا موازنہ کرنے میں ناکام رہتا ہے۔ لہذا Etherscan میں میچز جزوی میچز ہوتے ہیں۔

[Etherscan پر کنٹریکٹس کی تصدیق کے بارے میں مزید](https://medium.com/etherscan-blog/verifying-contracts-on-etherscan-f995ab772327)۔

### Blockscout {#blockscout}

[Blockscout](https://blockscout.com/) ایک اوپن سورس بلاک چین ایکسپلورر ہے جو اسمارٹ کنٹریکٹ ڈیولپرز اور صارفین کے لیے ایک [کنٹریکٹ کی توثیق کی خدمت](https://eth.blockscout.com/contract-verification) بھی فراہم کرتا ہے۔ ایک اوپن سورس متبادل کے طور پر، Blockscout اس بات میں شفافیت پیش کرتا ہے کہ توثیق کیسے کی جاتی ہے اور کمیونٹی کے تعاون کو توثیق کے عمل کو بہتر بنانے کے قابل بناتا ہے۔

دیگر توثیقی خدمات کی طرح، Blockscout آپ کو بائٹ کوڈ کو دوبارہ کمپائل کرکے اور اس کا تعینات کردہ کنٹریکٹ سے موازنہ کرکے اپنے کنٹریکٹ کے سورس کوڈ کی تصدیق کرنے کی اجازت دیتا ہے۔ ایک بار تصدیق ہو جانے کے بعد، آپ کے کنٹریکٹ کو توثیقی حیثیت ملتی ہے اور سورس کوڈ آڈیٹنگ اور تعامل کے لیے عوامی طور پر دستیاب ہو جاتا ہے۔ آسان براؤزنگ اور دریافت کے لیے تصدیق شدہ کنٹریکٹس کو Blockscout کے [تصدیق شدہ کنٹریکٹس کے ذخیرے](https://eth.blockscout.com/verified-contracts) میں بھی درج کیا جاتا ہے۔

### Sourcify {#sourcify}

[Sourcify](https://sourcify.dev/#/verifier) کنٹریکٹس کی تصدیق کا ایک اور ٹول ہے جو اوپن سورس اور غیر مرکزی ہے۔ یہ ایک بلاک ایکسپلورر نہیں ہے اور صرف [مختلف EVM پر مبنی نیٹ ورکس](https://docs.sourcify.dev/docs/chains) پر کنٹریکٹس کی تصدیق کرتا ہے۔ یہ دوسرے ٹولز کے لیے اس پر تعمیر کرنے کے لیے ایک عوامی انفراسٹرکچر کے طور پر کام کرتا ہے، اور اس کا مقصد میٹا ڈیٹا فائل میں پائے جانے والے [ABI](/developers/docs/smart-contracts/compiling/#web-applications) اور [NatSpec](https://docs.soliditylang.org/en/v0.8.15/natspec-format.html) تبصروں کا استعمال کرکے زیادہ انسانی-دوستانہ کنٹریکٹ تعاملات کو فعال کرنا ہے۔

Etherscan کے برعکس، Sourcify میٹا ڈیٹا ہیش کے ساتھ مکمل میچز کی حمایت کرتا ہے۔ تصدیق شدہ کنٹریکٹس کو اس کے [عوامی ذخیرے](https://docs.sourcify.dev/docs/repository/) میں HTTP اور [IPFS](https://docs.ipfs.io/concepts/what-is-ipfs/#what-is-ipfs) پر پیش کیا جاتا ہے، جو ایک غیر مرکزی، [مواد-ایڈریسڈ](https://docs.storacha.network/concepts/content-addressing/) اسٹوریج ہے۔ یہ IPFS پر کسی کنٹریکٹ کی میٹا ڈیٹا فائل حاصل کرنے کی اجازت دیتا ہے کیونکہ اضافی میٹا ڈیٹا ہیش ایک IPFS ہیش ہے۔

مزید برآں، کوئی IPFS پر سورس کوڈ فائلیں بھی حاصل کر سکتا ہے، کیونکہ ان فائلوں کے IPFS ہیشز بھی میٹا ڈیٹا میں پائے جاتے ہیں۔ ایک کنٹریکٹ کی تصدیق اس کی API یا [UI](https://sourcify.dev/#/verifier) پر میٹا ڈیٹا فائل اور سورس فائلیں فراہم کر کے، یا پلگ انز کا استعمال کر کے کی جا سکتی ہے۔ Sourcify مانیٹرنگ ٹول نئے بلاکس پر کنٹریکٹ کی تخلیقات کو بھی سنتا ہے اور اگر ان کی میٹا ڈیٹا اور سورس فائلیں IPFS پر شائع ہوتی ہیں تو کنٹریکٹس کی تصدیق کرنے کی کوشش کرتا ہے۔

[Sourcify پر کنٹریکٹس کی تصدیق کے بارے میں مزید](https://soliditylang.org/blog/2020/06/25/sourcify-faq/)۔

### Tenderly {#tenderly}

[Tenderly پلیٹ فارم](https://tenderly.co/) Web3 ڈیولپرز کو اسمارٹ کنٹریکٹس بنانے، جانچنے، مانیٹر کرنے، اور چلانے کے قابل بناتا ہے۔ ڈیبگنگ ٹولز کو مشاہداتی صلاحیت اور انفراسٹرکچر بلڈنگ بلاکس کے ساتھ ملا کر، Tenderly ڈیولپرز کو اسمارٹ کنٹریکٹ ڈیولپمنٹ کو تیز کرنے میں مدد کرتا ہے۔ Tenderly کی خصوصیات کو مکمل طور پر فعال کرنے کے لیے، ڈیولپرز کو کئی طریقوں کا استعمال کرتے ہوئے [سورس کوڈ کی توثیق کرنی ہوگی](https://docs.tenderly.co/monitoring/contract-verification)۔

ایک کنٹریکٹ کی تصدیق نجی طور پر یا عوامی طور پر کرنا ممکن ہے۔ اگر نجی طور پر تصدیق کی گئی ہے، تو اسمارٹ کنٹریکٹ صرف آپ کو (اور آپ کے پروجیکٹ کے دیگر ممبران) کو نظر آئے گا۔ ایک کنٹریکٹ کی عوامی طور پر تصدیق کرنے سے یہ Tenderly پلیٹ فارم استعمال کرنے والے ہر شخص کو نظر آتا ہے۔

آپ اپنے کنٹریکٹس کی تصدیق [ڈیش بورڈ](https://docs.tenderly.co/contract-verification)، [Tenderly Hardhat پلگ ان](https://docs.tenderly.co/contract-verification/hardhat)، یا [CLI](https://docs.tenderly.co/monitoring/smart-contract-verification/verifying-contracts-using-cli) کا استعمال کرتے ہوئے کر سکتے ہیں۔

ڈیش بورڈ کے ذریعے کنٹریکٹس کی تصدیق کرتے وقت، آپ کو Solidity کمپائلر سے تیار کردہ سورس فائل یا میٹا ڈیٹا فائل، ایڈریس/نیٹ ورک، اور کمپائلر سیٹنگز کو امپورٹ کرنے کی ضرورت ہے۔

Tenderly Hardhat پلگ ان کا استعمال کم محنت کے ساتھ توثیق کے عمل پر زیادہ کنٹرول کی اجازت دیتا ہے، جو آپ کو خودکار (بغیر کوڈ) اور دستی (کوڈ پر مبنی) توثیق کے درمیان انتخاب کرنے کے قابل بناتا ہے۔

## مزید پڑھیں {#further-reading}

- [کنٹریکٹ سورس کوڈ کی تصدیق کرنا](https://programtheblockchain.com/posts/2018/01/16/verifying-contract-source-code/)
