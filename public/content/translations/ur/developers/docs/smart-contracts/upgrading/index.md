---
title: اسمارٹ کانٹریکٹس کو اپ گریڈ کرنا
description: Ethereum اسمارٹ کانٹریکٹس کے لیے اپ گریڈ پیٹرنز کا ایک جائزہ
lang: ur-in
---

Ethereum پر اسمارٹ کانٹریکٹس خود کار طریقے سے عمل درآمد کرنے والے پروگرام ہیں جو Ethereum ورچوئل مشین (EVM) میں چلتے ہیں۔ یہ پروگرامز ڈیزائن کے لحاظ سے ناقابل تغیر ہیں، جو ایک بار کانٹریکٹ کے تعینات ہونے کے بعد کاروباری منطق میں کسی بھی اپ ڈیٹ کو روکتا ہے۔

اگرچہ اسمارٹ کانٹریکٹس کی بے اعتمادی، غیر مرکزیت، اور سیکورٹی کے لیے ناقابل تغیر ہونا ضروری ہے، لیکن یہ بعض صورتوں میں ایک خامی ہو سکتی ہے۔ مثال کے طور پر، ناقابل تغیر کوڈ ڈیولپرز کے لیے کمزور کانٹریکٹس کو ٹھیک کرنا ناممکن بنا سکتا ہے۔

تاہم، اسمارٹ کانٹریکٹس کو بہتر بنانے کی تحقیق میں اضافے نے کئی اپ گریڈ پیٹرنز کو متعارف کرایا ہے۔ یہ اپ گریڈ پیٹرنز ڈیولپرز کو مختلف کانٹریکٹس میں کاروباری منطق رکھ کر اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے (ناقابل تغیر کو برقرار رکھتے ہوئے) کے قابل بناتے ہیں۔

## شرائط {#prerequisites}

آپ کو [اسمارٹ کانٹریکٹس](/developers/docs/smart-contracts/)، [اسمارٹ کانٹریکٹ کی اناٹومی](/developers/docs/smart-contracts/anatomy/)، اور [ایتھریم ورچوئل مشین (EVM)](/developers/docs/evm/) کی اچھی سمجھ ہونی چاہیے۔ یہ گائیڈ یہ بھی فرض کرتا ہے کہ قارئین کو اسمارٹ کانٹریکٹس کی پروگرامنگ پر گرفت حاصل ہے۔

## اسمارٹ کانٹریکٹ اپ گریڈ کیا ہے؟ {#what-is-a-smart-contract-upgrade}

ایک اسمارٹ کانٹریکٹ اپ گریڈ میں کانٹریکٹ کی حالت کو محفوظ رکھتے ہوئے اسمارٹ کانٹریکٹ کی کاروباری منطق کو تبدیل کرنا شامل ہے۔ یہ واضح کرنا ضروری ہے کہ اپ گریڈ کی اہلیت اور تغیر پذیری ایک جیسی نہیں ہیں، خاص طور پر اسمارٹ کانٹریکٹس کے تناظر میں۔

آپ اب بھی Ethereum نیٹ ورک پر کسی ایڈریس پر تعینات کردہ پروگرام کو تبدیل نہیں کر سکتے ہیں۔ لیکن آپ اس کوڈ کو تبدیل کر سکتے ہیں جو اس وقت عمل میں آتا ہے جب صارفین ایک اسمارٹ کانٹریکٹ کے ساتھ تعامل کرتے ہیں۔

یہ مندرجہ ذیل طریقوں سے کیا جا سکتا ہے:

1. ایک اسمارٹ کانٹریکٹ کے متعدد ورژنز بنانا اور پرانے کانٹریکٹ سے کانٹریکٹ کی ایک نئی مثال میں حالت (یعنی، ڈیٹا) کو منتقل کرنا۔

2. کاروباری منطق اور حالت کو ذخیرہ کرنے کے لیے علیحدہ کانٹریکٹس بنانا۔

3. ایک ناقابل تغیر پراکسی کانٹریکٹ سے ایک قابل ترمیم منطقی کانٹریکٹ تک فنکشن کالز کو تفویض کرنے کے لیے پراکسی پیٹرنز کا استعمال کرنا۔

4. ایک ناقابل تغیر مرکزی کانٹریکٹ بنانا جو مخصوص فنکشنز کو انجام دینے کے لیے لچکدار سیٹلائٹ کانٹریکٹس کے ساتھ انٹرفیس کرتا ہے اور ان پر انحصار کرتا ہے۔

5. پراکسی کانٹریکٹ سے منطقی کانٹریکٹس تک فنکشن کالز کو تفویض کرنے کے لیے ڈائمنڈ پیٹرن کا استعمال کرنا۔

### اپ گریڈ میکانزم #1: کانٹریکٹ کی منتقلی {#contract-migration}

کانٹریکٹ کی منتقلی ورژننگ پر مبنی ہے — یعنی ایک ہی سافٹ ویئر کی منفرد حالتوں کو بنانے اور ان کا انتظام کرنے کا خیال۔ کانٹریکٹ کی منتقلی میں ایک موجودہ اسمارٹ کانٹریکٹ کی نئی مثال کو تعینات کرنا اور نئے کانٹریکٹ میں اسٹوریج اور بیلنس منتقل کرنا شامل ہے۔

نئے تعینات کردہ کانٹریکٹ میں ایک خالی اسٹوریج ہوگا، جو آپ کو پرانے کانٹریکٹ سے ڈیٹا بازیافت کرنے اور اسے نئے نفاذ میں لکھنے کی اجازت دیتا ہے۔ اس کے بعد، آپ کو ان تمام کانٹریکٹس کو اپ ڈیٹ کرنے کی ضرورت ہوگی جنہوں نے پرانے کانٹریکٹ کے ساتھ تعامل کیا تھا تاکہ وہ نئے ایڈریس کی عکاسی کریں۔

کانٹریکٹ کی منتقلی کا آخری مرحلہ صارفین کو نئے کانٹریکٹ کا استعمال شروع کرنے کے لیے قائل کرنا ہے۔ نیا کانٹریکٹ ورژن صارف کے بیلنس اور ایڈریسز کو برقرار رکھے گا، جو ناقابل تغیر کو محفوظ رکھتا ہے۔ اگر یہ ٹوکن پر مبنی کانٹریکٹ ہے، تو آپ کو پرانے کانٹریکٹ کو مسترد کرنے اور نئے کانٹریکٹ کو استعمال کرنے کے لیے ایکسچینجز سے بھی رابطہ کرنا ہوگا۔

صارف کے تعاملات میں خلل ڈالے بغیر اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے کے لیے کانٹریکٹ کی منتقلی ایک نسبتاً سیدھا اور محفوظ اقدام ہے۔ تاہم، نئے کانٹریکٹ میں صارف کے اسٹوریج اور بیلنس کو دستی طور پر منتقل کرنا وقت طلب ہے اور اس میں گیس کی زیادہ لاگت آ سکتی ہے۔

[کانٹریکٹ کی منتقلی کے بارے میں مزید۔](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/)

### اپ گریڈ میکانزم #2: ڈیٹا کی علیحدگی {#data-separation}

اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے کا ایک اور طریقہ کاروباری منطق اور ڈیٹا اسٹوریج کو علیحدہ کانٹریکٹس میں تقسیم کرنا ہے۔ اس کا مطلب ہے کہ صارفین منطقی کانٹریکٹ کے ساتھ تعامل کرتے ہیں، جبکہ ڈیٹا اسٹوریج کانٹریکٹ میں ذخیرہ کیا جاتا ہے۔

منطقی کانٹریکٹ میں وہ کوڈ ہوتا ہے جو اس وقت عمل میں آتا ہے جب صارفین ایپلیکیشن کے ساتھ تعامل کرتے ہیں۔ یہ اسٹوریج کانٹریکٹ کا ایڈریس بھی رکھتا ہے اور ڈیٹا حاصل کرنے اور سیٹ کرنے کے لیے اس کے ساتھ تعامل کرتا ہے۔

دریں اثنا، اسٹوریج کانٹریکٹ اسمارٹ کانٹریکٹ سے وابستہ حالت کو برقرار رکھتا ہے، جیسے کہ صارف کے بیلنس اور ایڈریسز۔ نوٹ کریں کہ اسٹوریج کانٹریکٹ منطقی کانٹریکٹ کی ملکیت ہے اور تعیناتی کے وقت مؤخر الذکر کے ایڈریس کے ساتھ کنفیگر کیا جاتا ہے۔ یہ غیر مجاز کانٹریکٹس کو اسٹوریج کانٹریکٹ کو کال کرنے یا اس کے ڈیٹا کو اپ ڈیٹ کرنے سے روکتا ہے۔

پہلے سے طے شدہ طور پر، اسٹوریج کانٹریکٹ ناقابل تغیر ہے—لیکن آپ اس منطقی کانٹریکٹ کو جس کی طرف یہ اشارہ کرتا ہے، ایک نئے نفاذ کے ساتھ بدل سکتے ہیں۔ یہ EVM میں چلنے والے کوڈ کو تبدیل کر دے گا، جبکہ اسٹوریج اور بیلنس کو برقرار رکھا جائے گا۔

اس اپ گریڈ کے طریقہ کار کو استعمال کرنے کے لیے اسٹوریج کانٹریکٹ میں منطقی کانٹریکٹ کے ایڈریس کو اپ ڈیٹ کرنا ضروری ہے۔ پہلے بیان کردہ وجوہات کی بنا پر آپ کو نئے منطقی کانٹریکٹ کو اسٹوریج کانٹریکٹ کے ایڈریس کے ساتھ بھی کنفیگر کرنا ہوگا۔

کانٹریکٹ کی منتقلی کے مقابلے میں ڈیٹا کی علیحدگی کا پیٹرن بلاشبہ نافذ کرنا آسان ہے۔ تاہم، آپ کو متعدد کانٹریکٹس کا انتظام کرنا ہوگا اور اسمارٹ کانٹریکٹس کو بدنیتی پر مبنی اپ گریڈ سے بچانے کے لیے پیچیدہ اجازت کی اسکیمیں نافذ کرنی ہوں گی۔

### اپ گریڈ میکانزم #3: پراکسی پیٹرنز {#proxy-patterns}

پراکسی پیٹرن کاروباری منطق اور ڈیٹا کو علیحدہ کانٹریکٹس میں رکھنے کے لیے ڈیٹا کی علیحدگی کا بھی استعمال کرتا ہے۔ تاہم، ایک پراکسی پیٹرن میں، اسٹوریج کانٹریکٹ (جسے پراکسی کہا جاتا ہے) کوڈ کے نفاذ کے دوران منطقی کانٹریکٹ کو کال کرتا ہے۔ یہ ڈیٹا کی علیحدگی کے طریقہ کار کا الٹ ہے، جہاں منطقی کانٹریکٹ اسٹوریج کانٹریکٹ کو کال کرتا ہے۔

پراکسی پیٹرن میں یہ ہوتا ہے:

1. صارفین پراکسی کانٹریکٹ کے ساتھ تعامل کرتے ہیں، جو ڈیٹا ذخیرہ کرتا ہے، لیکن کاروباری منطق نہیں رکھتا۔

2. پراکسی کانٹریکٹ منطقی کانٹریکٹ کا ایڈریس ذخیرہ کرتا ہے اور `delegatecall` فنکشن کا استعمال کرتے ہوئے تمام فنکشن کالز کو منطقی کانٹریکٹ (جو کاروباری منطق رکھتا ہے) کو تفویض کرتا ہے۔

3. کال کو منطقی کانٹریکٹ میں بھیجے جانے کے بعد، منطقی کانٹریکٹ سے واپس آنے والا ڈیٹا بازیافت کیا جاتا ہے اور صارف کو واپس کر دیا جاتا ہے۔

پراکسی پیٹرنز کا استعمال کرنے کے لیے **delegatecall** فنکشن کو سمجھنا ضروری ہے۔ بنیادی طور پر، `delegatecall` ایک اوپ کوڈ ہے جو ایک کانٹریکٹ کو دوسرے کانٹریکٹ کو کال کرنے کی اجازت دیتا ہے، جبکہ اصل کوڈ کا نفاذ کال کرنے والے کانٹریکٹ کے سیاق و سباق میں ہوتا ہے۔ پراکسی پیٹرنز میں `delegatecall` استعمال کرنے کا ایک مضمر یہ ہے کہ پراکسی کانٹریکٹ اپنے اسٹوریج میں پڑھتا اور لکھتا ہے اور منطقی کانٹریکٹ میں ذخیرہ شدہ منطق کو اس طرح انجام دیتا ہے جیسے کسی اندرونی فنکشن کو کال کر رہا ہو۔

[Solidity دستاویزات](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries) سے:

> _میسج کال کی ایک خاص قسم موجود ہے، جسے **delegatecall** کہا جاتا ہے جو میسج کال کی طرح ہی ہے سوائے اس کے کہ ٹارگٹ ایڈریس پر موجود کوڈ کال کرنے والے کانٹریکٹ کے سیاق و سباق (یعنی، ایڈریس پر) میں عمل میں آتا ہے اور `msg.sender` اور `msg.value` اپنی قدریں تبدیل نہیں کرتے۔_ _اس کا مطلب یہ ہے کہ ایک کانٹریکٹ رن ٹائم پر ایک مختلف ایڈریس سے کوڈ کو متحرک طور پر لوڈ کر سکتا ہے۔_ اسٹوریج، موجودہ ایڈریس اور بیلنس اب بھی کال کرنے والے کانٹریکٹ کا حوالہ دیتے ہیں، صرف کوڈ کال کیے گئے ایڈریس سے لیا جاتا ہے۔_

پراکسی کانٹریکٹ کو معلوم ہوتا ہے کہ جب بھی کوئی صارف کسی فنکشن کو کال کرتا ہے تو `delegatecall` کو طلب کرنا ہے کیونکہ اس میں ایک `fallback` فنکشن بنایا گیا ہے۔ Solidity پروگرامنگ میں [فال بیک فنکشن](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function) اس وقت عمل میں آتا ہے جب کوئی فنکشن کال کسی کانٹریکٹ میں بیان کردہ فنکشنز سے میل نہیں کھاتی۔

پراکسی پیٹرن کو کام کرنے کے لیے ایک حسب ضرورت فال بیک فنکشن لکھنا ضروری ہے جو یہ بتاتا ہے کہ پراکسی کانٹریکٹ ان فنکشن کالز کو کیسے ہینڈل کرے گا جن کی وہ حمایت نہیں کرتا۔ اس معاملے میں پراکسی کا فال بیک فنکشن ڈیلیگیٹ کال شروع کرنے اور صارف کی درخواست کو موجودہ منطقی کانٹریکٹ کے نفاذ کی طرف ری روٹ کرنے کے لیے پروگرام کیا گیا ہے۔

پراکسی کانٹریکٹ پہلے سے طے شدہ طور پر ناقابل تغیر ہے، لیکن اپ ڈیٹ شدہ کاروباری منطق کے ساتھ نئے منطقی کانٹریکٹ بنائے جا سکتے ہیں۔ اپ گریڈ کرنا پھر پراکسی کانٹریکٹ میں حوالہ کردہ منطقی کانٹریکٹ کا ایڈریس تبدیل کرنے کا معاملہ ہے۔

پراکسی کانٹریکٹ کو ایک نئے منطقی کانٹریکٹ کی طرف اشارہ کرکے، جب صارفین پراکسی کانٹریکٹ فنکشن کو کال کرتے ہیں تو عمل میں آنے والا کوڈ تبدیل ہو جاتا ہے۔ یہ ہمیں صارفین سے نئے کانٹریکٹ کے ساتھ تعامل کرنے کے لیے کہے بغیر کسی کانٹریکٹ کی منطق کو اپ گریڈ کرنے کی اجازت دیتا ہے۔

پراکسی پیٹرنز اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے کا ایک مقبول طریقہ ہیں کیونکہ وہ کانٹریکٹ کی منتقلی سے وابستہ مشکلات کو ختم کرتے ہیں۔ تاہم، پراکسی پیٹرنز کا استعمال زیادہ پیچیدہ ہے اور اگر غلط طریقے سے استعمال کیا جائے تو یہ سنگین خامیاں پیدا کر سکتا ہے، جیسے کہ [فنکشن سلیکٹر کے تصادم](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357)۔

[پراکسی پیٹرنز کے بارے میں مزید](https://blog.openzeppelin.com/proxy-patterns/)۔

### اپ گریڈ میکانزم #4: اسٹریٹیجی پیٹرن {#strategy-pattern}

یہ تکنیک [اسٹریٹیجی پیٹرن](https://en.wikipedia.org/wiki/Strategy_pattern) سے متاثر ہے، جو ایسے سافٹ ویئر پروگرام بنانے کی ترغیب دیتی ہے جو مخصوص خصوصیات کو نافذ کرنے کے لیے دوسرے پروگراموں کے ساتھ انٹرفیس کرتے ہیں۔ Ethereum کی ڈیولپمنٹ پر اسٹریٹیجی پیٹرن کا اطلاق کرنے کا مطلب ایک ایسا اسمارٹ کانٹریکٹ بنانا ہوگا جو دوسرے کانٹریکٹس سے فنکشنز کو کال کرتا ہے۔

اس معاملے میں مرکزی کانٹریکٹ بنیادی کاروباری منطق پر مشتمل ہے، لیکن کچھ مخصوص فنکشنز کو انجام دینے کے لیے دوسرے اسمارٹ کانٹریکٹس ("سیٹلائٹ کانٹریکٹس") کے ساتھ انٹرفیس کرتا ہے۔ یہ مرکزی کانٹریکٹ ہر سیٹلائٹ کانٹریکٹ کا ایڈریس بھی ذخیرہ کرتا ہے اور سیٹلائٹ کانٹریکٹ کے مختلف نفاذ کے درمیان سوئچ کر سکتا ہے۔

آپ ایک نیا سیٹلائٹ کانٹریکٹ بنا سکتے ہیں اور مرکزی کانٹریکٹ کو نئے ایڈریس کے ساتھ کنفیگر کر سکتے ہیں۔ یہ آپ کو ایک اسمارٹ کانٹریکٹ کے لیے _اسٹریٹیجیز_ (یعنی، نئی منطق کو نافذ کرنا) کو تبدیل کرنے کی اجازت دیتا ہے۔

اگرچہ پہلے زیر بحث پراکسی پیٹرن کی طرح ہے، اسٹریٹیجی پیٹرن مختلف ہے کیونکہ مرکزی کانٹریکٹ، جس کے ساتھ صارفین تعامل کرتے ہیں، کاروباری منطق رکھتا ہے۔ اس پیٹرن کا استعمال آپ کو بنیادی ڈھانچے کو متاثر کیے بغیر ایک اسمارٹ کانٹریکٹ میں محدود تبدیلیاں متعارف کرانے کا موقع فراہم کرتا ہے۔

سب سے بڑی خامی یہ ہے کہ یہ پیٹرن زیادہ تر معمولی اپ گریڈز کو نافذ کرنے کے لیے مفید ہے۔ اس کے علاوہ، اگر مرکزی کانٹریکٹ سے سمجھوتہ کیا جاتا ہے (مثلاً، ہیک کے ذریعے)، تو آپ اس اپ گریڈ کے طریقہ کار کو استعمال نہیں کر سکتے۔

### اپ گریڈ میکانزم #5: ڈائمنڈ پیٹرن {#diamond-pattern}

ڈائمنڈ پیٹرن کو پراکسی پیٹرن میں ایک بہتری سمجھا جا سکتا ہے۔ ڈائمنڈ پیٹرنز پراکسی پیٹرنز سے مختلف ہیں کیونکہ ڈائمنڈ پراکسی کانٹریکٹ ایک سے زیادہ منطقی کانٹریکٹس کو فنکشن کالز تفویض کر سکتا ہے۔

ڈائمنڈ پیٹرن میں منطقی کانٹریکٹس کو _فیسیٹس_ کے نام سے جانا جاتا ہے۔ ڈائمنڈ پیٹرن کو کام کرنے کے لیے، آپ کو پراکسی کانٹریکٹ میں ایک میپنگ بنانا ہوگی جو [فنکشن سلیکٹرز](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector) کو مختلف فیسیٹ ایڈریسز سے میپ کرتی ہے۔

جب کوئی صارف فنکشن کال کرتا ہے، تو پراکسی کانٹریکٹ اس فنکشن کو انجام دینے کے لیے ذمہ دار فیسیٹ کو تلاش کرنے کے لیے میپنگ کو چیک کرتا ہے۔ پھر یہ `delegatecall` کو طلب کرتا ہے (فال بیک فنکشن کا استعمال کرتے ہوئے) اور کال کو مناسب منطقی کانٹریکٹ کی طرف ری ڈائریکٹ کرتا ہے۔

ڈائمنڈ اپ گریڈ پیٹرن کے روایتی پراکسی اپ گریڈ پیٹرنز کے مقابلے میں کچھ فوائد ہیں:

1. یہ آپ کو تمام کوڈ کو تبدیل کیے بغیر کانٹریکٹ کے ایک چھوٹے سے حصے کو اپ گریڈ کرنے کی اجازت دیتا ہے۔ اپ گریڈ کے لیے پراکسی پیٹرن کا استعمال کرنے کے لیے ایک بالکل نیا منطقی کانٹریکٹ بنانے کی ضرورت ہوتی ہے، یہاں تک کہ معمولی اپ گریڈ کے لیے بھی۔

2. تمام اسمارٹ کانٹریکٹس (بشمول پراکسی پیٹرنز میں استعمال ہونے والے منطقی کانٹریکٹس) کی 24KB سائز کی حد ہوتی ہے، جو ایک حد ہوسکتی ہے — خاص طور پر پیچیدہ کانٹریکٹس کے لیے جن کے لیے زیادہ فنکشنز کی ضرورت ہوتی ہے۔ ڈائمنڈ پیٹرن فنکشنز کو متعدد منطقی کانٹریکٹس میں تقسیم کرکے اس مسئلے کو حل کرنا آسان بناتا ہے۔

3. پراکسی پیٹرنز رسائی کے کنٹرول کے لیے ایک جامع نقطہ نظر اپناتے ہیں۔ ایک ادارہ جس کے پاس اپ گریڈ فنکشنز تک رسائی ہے وہ _پورے_ کانٹریکٹ کو تبدیل کر سکتا ہے۔ لیکن ڈائمنڈ پیٹرن ایک ماڈیولر اجازتوں کا نقطہ نظر فراہم کرتا ہے، جہاں آپ اداروں کو اسمارٹ کانٹریکٹ کے اندر کچھ مخصوص فنکشنز کو اپ گریڈ کرنے تک محدود کر سکتے ہیں۔

[ڈائمنڈ پیٹرن کے بارے میں مزید](https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard?s=w)۔

## اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے کے فائدے اور نقصانات {#pros-and-cons-of-upgrading-smart-contracts}

| فوائد                                                                                                                               | نقصانات                                                                                                                                               |
| ----------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| ایک اسمارٹ کانٹریکٹ اپ گریڈ تعیناتی کے بعد کے مرحلے میں دریافت ہونے والی کمزوریوں کو ٹھیک کرنا آسان بنا سکتا ہے۔                    | اسمارٹ کانٹریکٹس کو اپ گریڈ کرنا کوڈ کی ناقابل تغیر ہونے کے خیال کی نفی کرتا ہے، جس کے غیر مرکزیت اور سیکورٹی پر اثرات مرتب ہوتے ہیں۔                 |
| ڈیولپرز غیر مرکزی ایپلیکیشنز میں نئی خصوصیات شامل کرنے کے لیے منطقی اپ گریڈ کا استعمال کر سکتے ہیں۔                                 | صارفین کو ڈیولپرز پر بھروسہ کرنا چاہیے کہ وہ اسمارٹ کانٹریکٹس میں من مانی طور پر ترمیم نہ کریں۔                                                       |
| اسمارٹ کانٹریکٹ اپ گریڈ آخری صارفین کے لیے حفاظت کو بہتر بنا سکتے ہیں کیونکہ کیڑوں کو جلدی ٹھیک کیا جا سکتا ہے۔                     | اسمارٹ کانٹریکٹس میں اپ گریڈ کی فعالیت کو پروگرامنگ کرنا پیچیدگی کی ایک اور پرت کا اضافہ کرتا ہے اور سنگین خامیوں کے امکان کو بڑھاتا ہے۔              |
| کانٹریکٹ اپ گریڈ ڈیولپرز کو وقت کے ساتھ مختلف خصوصیات کے ساتھ تجربہ کرنے اور ڈیپس کو بہتر بنانے کے لیے زیادہ گنجائش فراہم کرتے ہیں۔ | اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے کا موقع ڈیولپرز کو ڈیولپمنٹ کے مرحلے کے دوران مناسب مستعدی کے بغیر منصوبوں کو تیزی سے شروع کرنے کی ترغیب دے سکتا ہے۔ |
|                                                                                                                                     | اسمارٹ کانٹریکٹس میں غیر محفوظ رسائی کنٹرول یا مرکزیت بدنیتی پر مبنی اداکاروں کے لیے غیر مجاز اپ گریڈ کرنا آسان بنا سکتی ہے۔                          |

## اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے کے لیے غور و فکر {#considerations-for-upgrading-smart-contracts}

1. غیر مجاز اسمارٹ کانٹریکٹ اپ گریڈ کو روکنے کے لیے محفوظ رسائی کنٹرول/ اجازت کے میکانزم کا استعمال کریں، خاص طور پر اگر پراکسی پیٹرن، اسٹریٹیجی پیٹرن، یا ڈیٹا کی علیحدگی کا استعمال کر رہے ہوں۔ ایک مثال یہ ہے کہ اپ گریڈ فنکشن تک رسائی کو محدود کیا جائے، تاکہ صرف کانٹریکٹ کا مالک ہی اسے کال کر سکے۔

2. اسمارٹ کانٹریکٹس کو اپ گریڈ کرنا ایک پیچیدہ سرگرمی ہے اور کمزوریوں کے تعارف کو روکنے کے لیے اعلی سطح کی مستعدی کی ضرورت ہوتی ہے۔

3. اپ گریڈ کو نافذ کرنے کے عمل کو غیر مرکزی بنا کر اعتماد کے مفروضوں کو کم کریں۔ ممکنہ حکمت عملیوں میں اپ گریڈ کو کنٹرول کرنے کے لیے [ملٹی سگ والیٹ کانٹریکٹ](/developers/docs/smart-contracts/#multisig) کا استعمال، یا [DAO کے اراکین](/dao/) سے اپ گریڈ کی منظوری پر ووٹ ڈالنے کا مطالبہ کرنا شامل ہے۔

4. کانٹریکٹس کو اپ گریڈ کرنے میں شامل اخراجات سے آگاہ رہیں۔ مثال کے طور پر، کانٹریکٹ کی منتقلی کے دوران پرانے کانٹریکٹ سے نئے کانٹریکٹ میں حالت (مثلاً، صارف کے بیلنس) کو کاپی کرنے کے لیے ایک سے زیادہ ٹرانزیکشنز کی ضرورت پڑ سکتی ہے، جس کا مطلب ہے زیادہ گیس فیس۔

5. صارفین کی حفاظت کے لیے **ٹائم لاکس** کو نافذ کرنے پر غور کریں۔ ٹائم لاک سے مراد کسی سسٹم میں تبدیلیوں پر نافذ کردہ تاخیر ہے۔ اپ گریڈ کو کنٹرول کرنے کے لیے ٹائم لاکس کو ملٹی سگ گورننس سسٹم کے ساتھ ملایا جا سکتا ہے: اگر کوئی مجوزہ کارروائی مطلوبہ منظوری کی حد تک پہنچ جاتی ہے، تو یہ پہلے سے طے شدہ تاخیر کی مدت ختم ہونے تک عمل میں نہیں آتی۔

ٹائم لاکس صارفین کو کچھ وقت دیتے ہیں کہ اگر وہ کسی مجوزہ تبدیلی (مثلاً، منطقی اپ گریڈ یا نئی فیس اسکیمیں) سے متفق نہ ہوں تو سسٹم سے باہر نکل جائیں۔ ٹائم لاکس کے بغیر، صارفین کو ڈیولپرز پر بھروسہ کرنے کی ضرورت ہوتی ہے کہ وہ پیشگی اطلاع کے بغیر اسمارٹ کانٹریکٹ میں من مانی تبدیلیاں نہ کریں۔ یہاں خامی یہ ہے کہ ٹائم لاکس کمزوریوں کو جلدی سے ٹھیک کرنے کی صلاحیت کو محدود کرتے ہیں۔

## وسائل {#resources}

**OpenZeppelin Upgrades Plugins - _قابل اپ گریڈ اسمارٹ کانٹریکٹس کو تعینات کرنے اور محفوظ کرنے کے لیے ٹولز کا ایک مجموعہ۔_**

- [GitHub](https://github.com/OpenZeppelin/openzeppelin-upgrades)
- [دستاویزات](https://docs.openzeppelin.com/upgrades)

## ٹیوٹوریلز {#tutorials}

- [اپنے اسمارٹ کانٹریکٹس کو اپ گریڈ کرنا | YouTube ٹیوٹوریل](https://www.youtube.com/watch?v=bdXJmWajZRY) بذریعہ Patrick Collins
- [Ethereum اسمارٹ کانٹریکٹ مائیگریشن ٹیوٹوریل](https://medium.com/coinmonks/ethereum-smart-contract-migration-13f6f12539bd) بذریعہ Austin Griffith
- [اسمارٹ کانٹریکٹس کو اپ گریڈ کرنے کے لیے UUPS پراکسی پیٹرن کا استعمال](https://blog.logrocket.com/author/praneshas/) بذریعہ Pranesh A.S
- [Web3 ٹیوٹوریل: OpenZeppelin کا استعمال کرتے ہوئے اپ گریڈ کے قابل اسمارٹ کانٹریکٹ (پراکسی) لکھیں](https://dev.to/yakult/tutorial-write-upgradeable-smart-contract-proxy-contract-with-openzeppelin-1916) بذریعہ fangjun.eth

## مزید پڑھیں {#further-reading}

- [اسمارٹ کانٹریکٹ اپ گریڈز کی حالت](https://blog.openzeppelin.com/the-state-of-smart-contract-upgrades/) بذریعہ Santiago Palladino
- [Solidity اسمارٹ کانٹریکٹ کو اپ گریڈ کرنے کے متعدد طریقے](https://cryptomarketpool.com/multiple-ways-to-upgrade-a-solidity-smart-contract/) - Crypto Market Pool بلاگ
- [سیکھیں: اسمارٹ کانٹریکٹس کو اپ گریڈ کرنا](https://docs.openzeppelin.com/learn/upgrading-smart-contracts) - OpenZeppelin Docs
- [سولیڈیٹی کانٹریکٹس کی اپ گریڈ ایبلٹی کے لیے پراکسی پیٹرنز: ٹرانسپیرنٹ بمقابلہ UUPS پراکسیز](https://mirror.xyz/0xB38709B8198d147cc9Ff9C133838a044d78B064B/M7oTptQkBGXxox-tk9VJjL66E1V8BUF0GF79MMK4YG0) از نوین ساہو
- [ڈائمنڈ اپ گریڈ کیسے کام کرتے ہیں](https://dev.to/mudgen/how-diamond-upgrades-work-417j) از نک میج
