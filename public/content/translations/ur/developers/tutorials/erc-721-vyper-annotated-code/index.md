---
title: "Vyper ERC-721 کنٹریکٹ واک تھرو"
description: "Ryuya Nakamura کا ERC-721 کنٹریکٹ اور یہ کیسے کام کرتا ہے"
author: Ori Pomerantz
lang: ur-in
tags: [ "vyper", "erc-721", "python" ]
skill: beginner
published: 2021-04-01
---

## تعارف {#introduction}

[ERC-721](/developers/docs/standards/tokens/erc-721/) معیار نان فنجیبل ٹوکن (NFT) کی ملکیت رکھنے کے لیے استعمال کیا جاتا ہے۔
[ERC-20](/developers/docs/standards/tokens/erc-20/) ٹوکن ایک کموڈیٹی کی طرح برتاؤ کرتے ہیں، کیونکہ انفرادی ٹوکن کے درمیان کوئی فرق نہیں ہے۔
اس کے برعکس، ERC-721 ٹوکن ایسے اثاثوں کے لیے ڈیزائن کیے گئے ہیں جو ملتے جلتے تو ہیں لیکن ایک جیسے نہیں، جیسے کہ مختلف [بلی کے کارٹونز](https://www.cryptokitties.co/) یا رئیل اسٹیٹ کے مختلف ٹکڑوں کے ٹائٹلز۔

اس مضمون میں ہم [Ryuya Nakamura کے ERC-721 کنٹریکٹ](https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC721.vy) کا تجزیہ کریں گے۔
یہ کنٹریکٹ [Vyper](https://vyper.readthedocs.io/en/latest/index.html) میں لکھا گیا ہے، جو ایک پائتھن جیسی کنٹریکٹ زبان ہے جسے Solidity کے مقابلے میں غیر محفوظ کوڈ لکھنا زیادہ مشکل بنانے کے لیے ڈیزائن کیا گیا ہے۔

## کنٹریکٹ {#contract}

```python
# @dev ERC-721 نان فنجیبل ٹوکن معیار کا نفاذ۔
# @author Ryuya Nakamura (@nrryuya)
# یہاں سے ترمیم شدہ: https://github.com/vyperlang/vyper/blob/de74722bf2d8718cca46902be165f9fe0e3641dd/examples/tokens/ERC721.vy
```

Vyper میں، جیسا کہ Python میں ہے، کمنٹس ایک ہیش (`#`) سے شروع ہوتے ہیں اور لائن کے آخر تک جاری رہتے ہیں۔ وہ کمنٹس جن میں `@<keyword>` شامل ہوتا ہے [NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) کے ذریعے انسان کے پڑھنے کے قابل دستاویزات تیار کرنے کے لیے استعمال ہوتے ہیں۔

```python
from vyper.interfaces import ERC721

implements: ERC721
```

ERC-721 انٹرفیس Vyper زبان میں پہلے سے موجود ہے۔
[آپ کوڈ کی تعریف یہاں دیکھ سکتے ہیں](https://github.com/vyperlang/vyper/blob/master/vyper/builtin_interfaces/ERC721.py)۔
انٹرفیس کی تعریف Vyper کے بجائے Python میں لکھی گئی ہے، کیونکہ انٹرفیس نہ صرف بلاک چین کے اندر استعمال ہوتے ہیں، بلکہ کسی بیرونی کلائنٹ سے بلاک چین کو ٹرانزیکشن بھیجتے وقت بھی استعمال ہوتے ہیں، جو Python میں لکھا ہو سکتا ہے۔

پہلی لائن انٹرفیس کو امپورٹ کرتی ہے، اور دوسری لائن یہ بتاتی ہے کہ ہم اسے یہاں نافذ کر رہے ہیں۔

### ERC721Receiver انٹرفیس {#receiver-interface}

```python
# safeTransferFrom() کے ذریعے کال کیے جانے والے کنٹریکٹ کے لیے انٹرفیس
interface ERC721Receiver:
    def onERC721Received(
```

ERC-721 دو قسم کی منتقلی کو سپورٹ کرتا ہے:

- `transferFrom`، جو بھیجنے والے کو کسی بھی منزل کے پتے کی وضاحت کرنے دیتا ہے اور منتقلی کی ذمہ داری بھیجنے والے پر ڈالتا ہے۔ اس کا مطلب ہے کہ آپ کسی غلط پتے پر منتقل کر سکتے ہیں، ایسی صورت میں NFT ہمیشہ کے لیے ضائع ہو جاتا ہے۔
- `safeTransferFrom`، جو یہ چیک کرتا ہے کہ منزل کا پتہ کنٹریکٹ ہے یا نہیں۔ اگر ایسا ہے تو، ERC-721 کنٹریکٹ وصول کرنے والے کنٹریکٹ سے پوچھتا ہے کہ کیا وہ NFT وصول کرنا چاہتا ہے۔

`safeTransferFrom` کی درخواستوں کا جواب دینے کے لیے ایک وصول کرنے والے کنٹریکٹ کو `ERC721Receiver` نافذ کرنا ہوتا ہے۔

```python
            _operator: address,
            _from: address,
```

`_from` پتہ ٹوکن کا موجودہ مالک ہے۔ `_operator` پتہ وہ ہے جس نے منتقلی کی درخواست کی ہے (یہ دونوں ایک جیسے نہیں ہو سکتے، الاؤنسز کی وجہ سے)۔

```python
            _tokenId: uint256,
```

ERC-721 ٹوکن IDs 256 بٹس کی ہوتی ہیں۔ عام طور پر وہ ٹوکن کی نمائندگی کرنے والی کسی بھی چیز کی تفصیل کو ہیش کرکے بنائے جاتے ہیں۔

```python
            _data: Bytes[1024]
```

درخواست میں 1024 بائٹس تک کا صارف کا ڈیٹا ہو سکتا ہے۔

```python
        ) -> bytes32: view
```

ایسے معاملات کو روکنے کے لیے جن میں کوئی کنٹریکٹ غلطی سے منتقلی قبول کر لیتا ہے، واپسی کی قیمت بولین نہیں ہوتی، بلکہ ایک مخصوص قیمت کے ساتھ 256 بٹس ہوتی ہے۔

یہ فنکشن ایک `view` ہے، جس کا مطلب ہے کہ یہ بلاک چین کی حالت کو پڑھ سکتا ہے، لیکن اسے تبدیل نہیں کر سکتا۔

### ایونٹس {#events}

[Events](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e) بلاک چین کے باہر صارفین اور سرورز کو واقعات سے آگاہ کرنے کے لیے جاری کیے جاتے ہیں۔ نوٹ کریں کہ ایونٹس کا مواد بلاک چین پر موجود کنٹریکٹس کے لیے دستیاب نہیں ہوتا ہے۔

```python
# @dev کسی بھی میکانزم کے ذریعے کسی بھی NFT کی ملکیت تبدیل ہونے پر جاری ہوتا ہے۔ یہ ایونٹ اس وقت جاری ہوتا ہے جب NFTs بنائے جاتے ہیں
#      (`from` == 0) اور تباہ کیے جاتے ہیں (`to` == 0)۔ استثناء: کنٹریکٹ کی تخلیق کے دوران، کسی بھی
#      تعداد میں NFTs ٹرانسفر جاری کیے بغیر بنائے اور تفویض کیے جا سکتے ہیں۔ کسی بھی
#      منتقلی کے وقت، اس NFT کے لیے منظور شدہ پتہ (اگر کوئی ہو) کو none پر ری سیٹ کر دیا جاتا ہے۔
# @param _from NFT کا بھیجنے والا (اگر پتہ صفر ہے تو یہ ٹوکن کی تخلیق کی نشاندہی کرتا ہے)۔
# @param _to NFT کا وصول کنندہ (اگر پتہ صفر ہے تو یہ ٹوکن کی تباہی کی نشاندہی کرتا ہے)۔
# @param _tokenId وہ NFT جو منتقل کیا گیا۔
event Transfer:
    sender: indexed(address)
    receiver: indexed(address)
    tokenId: indexed(uint256)
```

یہ ERC-20 ٹرانسفر ایونٹ کی طرح ہے، سوائے اس کے کہ ہم رقم کے بجائے `tokenId` کی اطلاع دیتے ہیں۔
صفر پتے کا کوئی مالک نہیں ہے، لہذا روایت کے مطابق ہم اسے ٹوکنز کی تخلیق اور تباہی کی اطلاع دینے کے لیے استعمال کرتے ہیں۔

```python
# @dev یہ اس وقت جاری ہوتا ہے جب کسی NFT کے لیے منظور شدہ پتہ تبدیل کیا جاتا ہے یا اس کی دوبارہ تصدیق کی جاتی ہے۔ صفر
#      پتہ اس بات کی نشاندہی کرتا ہے کہ کوئی منظور شدہ پتہ نہیں ہے۔ جب ٹرانسفر ایونٹ جاری ہوتا ہے، تو یہ بھی
#      اشارہ کرتا ہے کہ اس NFT کے لیے منظور شدہ پتہ (اگر کوئی ہو) کو none پر ری سیٹ کر دیا گیا ہے۔
# @param _owner NFT کا مالک۔
# @param _approved وہ پتہ جسے ہم منظور کر رہے ہیں۔
# @param _tokenId وہ NFT جسے ہم منظور کر رہے ہیں۔
event Approval:
    owner: indexed(address)
    approved: indexed(address)
    tokenId: indexed(uint256)
```

ایک ERC-721 کی منظوری ایک ERC-20 الاؤنس کی طرح ہے۔ ایک مخصوص پتے کو ایک مخصوص ٹوکن منتقل کرنے کی اجازت ہے۔ یہ کنٹریکٹس کو اس وقت جواب دینے کے لیے ایک میکانزم فراہم کرتا ہے جب وہ کوئی ٹوکن قبول کرتے ہیں۔ کنٹریکٹس ایونٹس کو نہیں سن سکتے، لہذا اگر آپ صرف ٹوکن ان کو منتقل کر دیتے ہیں تو وہ اس کے بارے میں "جانتے" نہیں ہیں۔ اس طرح مالک پہلے ایک منظوری جمع کرتا ہے اور پھر کنٹریکٹ کو ایک درخواست بھیجتا ہے: "میں نے آپ کو ٹوکن X منتقل کرنے کی منظوری دی ہے، براہ کرم کریں..."۔

یہ ERC-721 معیار کو ERC-20 معیار کی طرح بنانے کے لیے ایک ڈیزائن کا انتخاب ہے۔ چونکہ ERC-721 ٹوکنز فنجیبل نہیں ہیں، ایک کنٹریکٹ ٹوکن کی ملکیت کو دیکھ کر یہ بھی شناخت کر سکتا ہے کہ اسے ایک مخصوص ٹوکن ملا ہے۔

```python
# @dev یہ اس وقت جاری ہوتا ہے جب کسی مالک کے لیے آپریٹر کو فعال یا غیر فعال کیا جاتا ہے۔ آپریٹر مالک کے
#      تمام NFTs کا انتظام کر سکتا ہے۔
# @param _owner NFT کا مالک۔
# @param _operator وہ پتہ جس پر ہم آپریٹر کے حقوق سیٹ کر رہے ہیں۔
# @param _approved آپریٹر کے حقوق کی حیثیت (اگر آپریٹر کے حقوق دیے گئے ہیں تو true اور اگر
# منسوخ کیے گئے ہیں تو false)۔
event ApprovalForAll:
    owner: indexed(address)
    operator: indexed(address)
    approved: bool
```

کبھی کبھی ایک _آپریٹر_ کا ہونا مفید ہوتا ہے جو کسی مخصوص قسم کے اکاؤنٹ کے تمام ٹوکنز کا انتظام کر سکے (وہ جو ایک مخصوص کنٹریکٹ کے ذریعے منظم ہوتے ہیں)، جو کہ پاور آف اٹارنی کی طرح ہے۔ مثال کے طور پر، میں ایسی طاقت ایک ایسے کنٹریکٹ کو دینا چاہ سکتا ہوں جو یہ چیک کرے کہ کیا میں نے چھ ماہ سے اس سے رابطہ نہیں کیا ہے، اور اگر ایسا ہے تو میرے اثاثے میرے وارثوں میں تقسیم کر دے (اگر ان میں سے کوئی اس کا مطالبہ کرتا ہے، تو کنٹریکٹس ٹرانزیکشن کے ذریعے کال کیے بغیر کچھ نہیں کر سکتے)۔ ERC-20 میں ہم وراثت کے کنٹریکٹ کو ایک بڑا الاؤنس دے سکتے ہیں، لیکن یہ ERC-721 کے لیے کام نہیں کرتا کیونکہ ٹوکنز فنجیبل نہیں ہیں۔ یہ اس کے مساوی ہے۔

`approved` کی قیمت ہمیں بتاتی ہے کہ آیا ایونٹ منظوری کے لیے ہے، یا منظوری کی واپسی کے لیے۔

### اسٹیٹ متغیرات {#state-vars}

ان متغیرات میں ٹوکنز کی موجودہ حالت ہوتی ہے: کون سے دستیاب ہیں اور ان کا مالک کون ہے۔ ان میں سے زیادہ تر `HashMap` آبجیکٹس ہیں، [یک سمتی میپنگز جو دو اقسام کے درمیان موجود ہیں](https://vyper.readthedocs.io/en/latest/types.html#mappings)۔

```python
# @dev NFT ID سے اس پتے تک میپنگ جو اس کا مالک ہے۔
idToOwner: HashMap[uint256, address]

# @dev NFT ID سے منظور شدہ پتے تک میپنگ۔
idToApprovals: HashMap[uint256, address]
```

Ethereum میں صارف اور کنٹریکٹ کی شناخت 160 بٹ کے پتوں سے ظاہر ہوتی ہے۔ یہ دو متغیرات ٹوکن آئی ڈیز سے ان کے مالکان اور ان لوگوں تک میپ کرتے ہیں جنہیں انہیں منتقل کرنے کی منظوری دی گئی ہے (ہر ایک کے لیے زیادہ سے زیادہ ایک)۔ Ethereum میں، غیر شروع شدہ ڈیٹا ہمیشہ صفر ہوتا ہے، لہذا اگر کوئی مالک یا منظور شدہ ٹرانسفرر نہیں ہے تو اس ٹوکن کی قیمت صفر ہے۔

```python
# @dev مالک کے پتے سے اس کے ٹوکنز کی گنتی تک میپنگ۔
ownerToNFTokenCount: HashMap[address, uint256]
```

یہ متغیر ہر مالک کے ٹوکنز کی گنتی رکھتا ہے۔ مالکان سے ٹوکنز تک کوئی میپنگ نہیں ہے، لہذا کسی مخصوص مالک کے ٹوکنز کی شناخت کا واحد طریقہ بلاک چین کی ایونٹ ہسٹری میں پیچھے دیکھنا اور مناسب `ٹرانسفر` ایونٹس کو دیکھنا ہے۔ ہم اس متغیر کا استعمال یہ جاننے کے لیے کر سکتے ہیں کہ جب ہمارے پاس تمام NFTs ہوں اور ہمیں وقت میں مزید پیچھے دیکھنے کی ضرورت نہ ہو۔

نوٹ کریں کہ یہ الگورتھم صرف یوزر انٹرفیس اور بیرونی سرورز کے لیے کام کرتا ہے۔ بلاک چین پر چلنے والا کوڈ ماضی کے ایونٹس کو نہیں پڑھ سکتا۔

```python
# @dev مالک کے پتے سے آپریٹر کے پتوں کی میپنگ تک میپنگ۔
ownerToOperators: HashMap[address, HashMap[address, bool]]
```

ایک اکاؤنٹ میں ایک سے زیادہ آپریٹر ہو سکتے ہیں۔ ایک سادہ `HashMap` ان پر نظر رکھنے کے لیے ناکافی ہے، کیونکہ ہر کلید ایک واحد قدر کی طرف لے جاتی ہے۔ اس کے بجائے، آپ قدر کے طور پر `HashMap[address, bool]` استعمال کر سکتے ہیں۔ پہلے سے طے شدہ طور پر ہر پتے کی قدر `False` ہے، جس کا مطلب ہے کہ یہ آپریٹر نہیں ہے۔ آپ ضرورت کے مطابق قدروں کو `True` پر سیٹ کر سکتے ہیں۔

```python
# @dev منٹر کا پتہ، جو ٹوکن منٹ کر سکتا ہے
minter: address
```

نئے ٹوکن کسی نہ کسی طرح بنائے جانے چاہئیں۔ اس کنٹریکٹ میں ایک واحد ادارہ ہے جسے ایسا کرنے کی اجازت ہے، یعنی `minter`۔ یہ مثال کے طور پر ایک گیم کے لیے کافی ہونے کا امکان ہے۔ دیگر مقاصد کے لیے، زیادہ پیچیدہ کاروباری منطق بنانے کی ضرورت پڑ سکتی ہے۔

```python
# @dev انٹرفیس آئی ڈی سے bool تک میپنگ اس بارے میں کہ آیا یہ سپورٹڈ ہے یا نہیں
supportedInterfaces: HashMap[bytes32, bool]

# @dev ERC165 کا ERC165 انٹرفیس آئی ڈی
ERC165_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000001ffc9a7

# @dev ERC721 کا ERC165 انٹرفیس آئی ڈی
ERC721_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000080ac58cd
```

[ERC-165](https://eips.ethereum.org/EIPS/eip-165) ایک کنٹریکٹ کے لیے ایک میکانزم کی وضاحت کرتا ہے تاکہ یہ ظاہر کیا جا سکے کہ ایپلیکیشنز اس کے ساتھ کیسے بات چیت کر سکتی ہیں، اور یہ کن ERCs کے مطابق ہے۔ اس صورت میں، کنٹریکٹ ERC-165 اور ERC-721 کے مطابق ہے۔

### فنکشنز {#functions}

یہ وہ فنکشنز ہیں جو دراصل ERC-721 کو نافذ کرتے ہیں۔

#### کنسٹرکٹر {#constructor}

```python
@external
def __init__():
```

Vyper میں، جیسا کہ Python میں ہے، کنسٹرکٹر فنکشن کو `__init__` کہا جاتا ہے۔

```python
    """
    @dev کنٹریکٹ کنسٹرکٹر۔
    """
```

Python میں، اور Vyper میں، آپ ایک ملٹی لائن اسٹرنگ کی وضاحت کرکے بھی ایک کمنٹ بنا سکتے ہیں (جو `"""` سے شروع اور ختم ہوتا ہے)، اور اسے کسی بھی طرح سے استعمال نہیں کرتے ہیں۔ ان کمنٹس میں [NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) بھی شامل ہو سکتا ہے۔

```python
    self.supportedInterfaces[ERC165_INTERFACE_ID] = True
    self.supportedInterfaces[ERC721_INTERFACE_ID] = True
    self.minter = msg.sender
```

اسٹیٹ متغیرات تک رسائی کے لیے آپ `self.<variable name>` استعمال کرتے ہیں۔` (دوبارہ، جیسا کہ پائتھن میں ہے)۔

#### فنکشنز دیکھیں {#views}

یہ وہ فنکشنز ہیں جو بلاک چین کی حالت میں ترمیم نہیں کرتے ہیں، اور اس لیے اگر انہیں بیرونی طور پر کال کیا جائے تو مفت میں عمل میں لایا جا سکتا ہے۔ اگر ویو فنکشنز کو کسی کنٹریکٹ کے ذریعے کال کیا جاتا ہے تو انہیں اب بھی ہر نوڈ پر عمل میں لانا پڑتا ہے اور اس لیے گیس کی لاگت آتی ہے۔

```python
@view
@external
```

فنکشن کی تعریف سے پہلے یہ کلیدی الفاظ جو ایٹ سائن (`@`) سے شروع ہوتے ہیں، _ڈیکوریشنز_ کہلاتے ہیں۔ وہ ان حالات کی وضاحت کرتے ہیں جن میں ایک فنکشن کو کال کیا جا سکتا ہے۔

- `@view` اس بات کی وضاحت کرتا ہے کہ یہ فنکشن ایک ویو ہے۔
- `@external` اس بات کی وضاحت کرتا ہے کہ اس مخصوص فنکشن کو ٹرانزیکشنز اور دیگر کنٹریکٹس کے ذریعے کال کیا جا سکتا ہے۔

```python
def supportsInterface(_interfaceID: bytes32) -> bool:
```

Python کے برعکس، Vyper ایک [اسٹیٹک ٹائپڈ زبان](https://wikipedia.org/wiki/Type_system#Static_type_checking) ہے۔
آپ [ڈیٹا ٹائپ](https://vyper.readthedocs.io/en/latest/types.html) کی شناخت کیے بغیر کسی متغیر، یا فنکشن پیرامیٹر کا اعلان نہیں کر سکتے۔ اس صورت میں ان پٹ پیرامیٹر `bytes32` ہے، ایک 256 بٹ کی قدر ([ایتھیریم ورچوئل مشین](/developers/docs/evm/) کا مقامی لفظ سائز 256 بٹس ہے)۔ آؤٹ پٹ ایک بولین قدر ہے۔ روایت کے مطابق، فنکشن پیرامیٹرز کے نام انڈر اسکور (`_`) سے شروع ہوتے ہیں۔

```python
    """
    @dev انٹرفیس کی شناخت ERC-165 میں بیان کی گئی ہے۔
    @param _interfaceID انٹرفیس کا آئی ڈی
    """
    return self.supportedInterfaces[_interfaceID]
```

`self.supportedInterfaces` HashMap سے قدر واپس کریں، جو کنسٹرکٹر (`__init__`) میں سیٹ کی گئی ہے۔

```python
### فنکشنز دیکھیں ###

```

یہ وہ ویو فنکشنز ہیں جو ٹوکنز کے بارے میں معلومات صارفین اور دیگر کنٹریکٹس کو دستیاب کراتے ہیں۔

```python
@view
@external
def balanceOf(_owner: address) -> uint256:
    """
    @dev `_owner` کے زیر ملکیت NFTs کی تعداد واپس کرتا ہے۔
         اگر `_owner` صفر کا پتہ ہے تو تھرو کرتا ہے۔ صفر پتے کو تفویض کردہ NFTs کو غلط سمجھا جاتا ہے۔
    @param _owner وہ پتہ جس کے لیے بیلنس کی دریافت کرنی ہے۔
    """
    assert _owner != ZERO_ADDRESS
```

یہ لائن [asserts](https://vyper.readthedocs.io/en/latest/statements.html#assert) کرتی ہے کہ `_owner` صفر نہیں ہے۔ اگر ایسا ہے تو، ایک خرابی ہے اور آپریشن کو واپس کر دیا جاتا ہے۔

```python
    return self.ownerToNFTokenCount[_owner]

@view
@external
def ownerOf(_tokenId: uint256) -> address:
    """
    @dev NFT کے مالک کا پتہ واپس کرتا ہے۔
         اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے۔
    @param _tokenId ایک NFT کے لیے شناخت کنندہ۔
    """
    owner: address = self.idToOwner[_tokenId]
    # اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے
    assert owner != ZERO_ADDRESS
    return owner
```

ایتھیریم ورچوئل مشین (evm) میں کوئی بھی اسٹوریج جس میں کوئی قدر ذخیرہ نہیں کی گئی ہے وہ صفر ہوتا ہے۔
اگر `_tokenId` پر کوئی ٹوکن نہیں ہے تو `self.idToOwner[_tokenId]` کی قدر صفر ہے۔ اس صورت میں فنکشن واپس ہوجاتا ہے۔

```python
@view
@external
def getApproved(_tokenId: uint256) -> address:
    """
    @dev ایک واحد NFT کے لیے منظور شدہ پتہ حاصل کریں۔
         اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے۔
    @param _tokenId اس NFT کا آئی ڈی جس کی منظوری کی دریافت کرنی ہے۔
    """
    # اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے
    assert self.idToOwner[_tokenId] != ZERO_ADDRESS
    return self.idToApprovals[_tokenId]
```

نوٹ کریں کہ `getApproved` صفر واپس _کر سکتا_ ہے۔ اگر ٹوکن درست ہے تو یہ `self.idToApprovals[_tokenId]` واپس کرتا ہے۔
اگر کوئی منظور کنندہ نہیں ہے تو وہ قدر صفر ہے۔

```python
@view
@external
def isApprovedForAll(_owner: address, _operator: address) -> bool:
    """
    @dev چیک کرتا ہے کہ آیا `_operator` `_owner` کے لیے ایک منظور شدہ آپریٹر ہے۔
    @param _owner وہ پتہ جو NFTs کا مالک ہے۔
    @param _operator وہ پتہ جو مالک کی جانب سے کام کرتا ہے۔
    """
    return (self.ownerToOperators[_owner])[_operator]
```

یہ فنکشن چیک کرتا ہے کہ آیا `_operator` کو اس کنٹریکٹ میں `_owner` کے تمام ٹوکنز کا انتظام کرنے کی اجازت ہے۔
چونکہ متعدد آپریٹرز ہو سکتے ہیں، یہ ایک دو سطحی HashMap ہے۔

#### ٹرانسفر ہیلپر فنکشنز {#transfer-helpers}

یہ فنکشنز ان آپریشنز کو نافذ کرتے ہیں جو ٹوکنز کی منتقلی یا انتظام کا حصہ ہیں۔

```python

### ٹرانسفر فنکشن ہیلپرز ###

@view
@internal
```

یہ ڈیکوریشن، `@internal`، کا مطلب ہے کہ فنکشن صرف اسی کنٹریکٹ کے اندر دیگر فنکشنز سے قابل رسائی ہے۔ روایت کے مطابق، ان فنکشنز کے نام بھی انڈر اسکور (`_`) سے شروع ہوتے ہیں۔

```python
def _isApprovedOrOwner(_spender: address, _tokenId: uint256) -> bool:
    """
    @dev واپس کرتا ہے کہ آیا دیا گیا خرچ کنندہ ایک دیا گیا ٹوکن آئی ڈی منتقل کر سکتا ہے
    @param spender خرچ کنندہ کا پتہ جس کی دریافت کرنی ہے
    @param tokenId منتقل کیے جانے والے ٹوکن کا uint256 آئی ڈی
    @return bool کہ آیا msg.sender دیے گئے ٹوکن آئی ڈی کے لیے منظور شدہ ہے،
        مالک کا آپریٹر ہے، یا ٹوکن کا مالک ہے
    """
    owner: address = self.idToOwner[_tokenId]
    spenderIsOwner: bool = owner == _spender
    spenderIsApproved: bool = _spender == self.idToApprovals[_tokenId]
    spenderIsApprovedForAll: bool = (self.ownerToOperators[owner])[_spender]
    return (spenderIsOwner or spenderIsApproved) or spenderIsApprovedForAll
```

کسی پتے کو ٹوکن منتقل کرنے کی اجازت دینے کے تین طریقے ہیں:

1. پتہ ٹوکن کا مالک ہے
2. اس پتے کو وہ ٹوکن خرچ کرنے کی منظوری دی گئی ہے
3. پتہ ٹوکن کے مالک کے لیے آپریٹر ہے

اوپر والا فنکشن ایک ویو ہو سکتا ہے کیونکہ یہ حالت کو تبدیل نہیں کرتا ہے۔ آپریٹنگ اخراجات کو کم کرنے کے لیے، کوئی بھی فنکشن جو ایک ویو ہو _سکتا_ ہے وہ ایک ویو _ہونا_ چاہیے۔

```python
@internal
def _addTokenTo(_to: address, _tokenId: uint256):
    """
    @dev ایک دیے گئے پتے پر ایک NFT شامل کریں
         اگر `_tokenId` کسی کی ملکیت میں ہے تو تھرو کرتا ہے۔
    """
    # اگر `_tokenId` کسی کی ملکیت میں ہے تو تھرو کرتا ہے
    assert self.idToOwner[_tokenId] == ZERO_ADDRESS
    # مالک کو تبدیل کریں
    self.idToOwner[_tokenId] = _to
    # گنتی ٹریکنگ کو تبدیل کریں
    self.ownerToNFTokenCount[_to] += 1


@internal
def _removeTokenFrom(_from: address, _tokenId: uint256):
    """
    @dev ایک دیے گئے پتے سے ایک NFT ہٹائیں
         اگر `_from` موجودہ مالک نہیں ہے تو تھرو کرتا ہے۔
    """
    # اگر `_from` موجودہ مالک نہیں ہے تو تھرو کرتا ہے
    assert self.idToOwner[_tokenId] == _from
    # مالک کو تبدیل کریں
    self.idToOwner[_tokenId] = ZERO_ADDRESS
    # گنتی ٹریکنگ کو تبدیل کریں
    self.ownerToNFTokenCount[_from] -= 1
```

جب منتقلی میں کوئی مسئلہ ہوتا ہے تو ہم کال کو واپس کر دیتے ہیں۔

```python
@internal
def _clearApproval(_owner: address, _tokenId: uint256):
    """
    @dev دیے گئے پتے کی منظوری صاف کریں
         اگر `_owner` موجودہ مالک نہیں ہے تو تھرو کرتا ہے۔
    """
    # اگر `_owner` موجودہ مالک نہیں ہے تو تھرو کرتا ہے
    assert self.idToOwner[_tokenId] == _owner
    if self.idToApprovals[_tokenId] != ZERO_ADDRESS:
        # منظوریوں کو ری سیٹ کریں
        self.idToApprovals[_tokenId] = ZERO_ADDRESS
```

صرف ضرورت پڑنے پر ہی قدر کو تبدیل کریں۔ اسٹیٹ متغیرات اسٹوریج میں رہتے ہیں۔ اسٹوریج میں لکھنا EVM (ایتھیریم ورچوئل مشین) کے سب سے مہنگے آپریشنز میں سے ایک ہے ([گیس](/developers/docs/gas/) کے لحاظ سے)۔ لہذا، اسے کم سے کم کرنا ایک اچھا خیال ہے، یہاں تک کہ موجودہ قدر کو لکھنے کی بھی زیادہ لاگت آتی ہے۔

```python
@internal
def _transferFrom(_from: address, _to: address, _tokenId: uint256, _sender: address):
    """
    @dev ایک NFT کی منتقلی پر عمل کریں۔
         جب تک `msg.sender` موجودہ مالک، ایک مجاز آپریٹر، یا اس NFT کے لیے منظور شدہ
         پتہ نہ ہو، تھرو کرتا ہے۔ (نوٹ: `msg.sender` کو نجی فنکشن میں اجازت نہیں ہے لہذا `_sender` پاس کریں۔)
         اگر `_to` صفر کا پتہ ہے تو تھرو کرتا ہے۔
         اگر `_from` موجودہ مالک نہیں ہے تو تھرو کرتا ہے۔
         اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے۔
    """
```

ہمارے پاس یہ اندرونی فنکشن ہے کیونکہ ٹوکن منتقل کرنے کے دو طریقے ہیں (باقاعدہ اور محفوظ)، لیکن ہم چاہتے ہیں کہ کوڈ میں صرف ایک ہی جگہ ہو جہاں ہم اسے کرتے ہیں تاکہ آڈیٹنگ آسان ہو۔

```python
    # ضروریات چیک کریں
    assert self._isApprovedOrOwner(_sender, _tokenId)
    # اگر `_to` صفر کا پتہ ہے تو تھرو کرتا ہے
    assert _to != ZERO_ADDRESS
    # منظوری صاف کریں۔ اگر `_from` موجودہ مالک نہیں ہے تو تھرو کرتا ہے
    self._clearApproval(_from, _tokenId)
    # NFT ہٹائیں۔ اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے
    self._removeTokenFrom(_from, _tokenId)
    # NFT شامل کریں
    self._addTokenTo(_to, _tokenId)
    # منتقلی کو لاگ کریں
    log Transfer(_from, _to, _tokenId)
```

Vyper میں ایک ایونٹ جاری کرنے کے لیے آپ ایک `log` اسٹیٹمنٹ استعمال کرتے ہیں ([مزید تفصیلات کے لیے یہاں دیکھیں](https://vyper.readthedocs.io/en/latest/event-logging.html#event-logging))۔

#### منتقلی کے فنکشنز {#transfer-funs}

```python

### منتقلی کے فنکشنز ###

@external
def transferFrom(_from: address, _to: address, _tokenId: uint256):
    """
    @dev جب تک `msg.sender` موجودہ مالک، ایک مجاز آپریٹر، یا اس NFT کے لیے منظور شدہ
         پتہ نہ ہو، تھرو کرتا ہے۔
         اگر `_from` موجودہ مالک نہیں ہے تو تھرو کرتا ہے۔
         اگر `_to` صفر کا پتہ ہے تو تھرو کرتا ہے۔
         اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے۔
    @notice کالر اس بات کی تصدیق کرنے کا ذمہ دار ہے کہ `_to` NFTs وصول کرنے کے قابل ہے ورنہ
            وہ مستقل طور پر ضائع ہو سکتے ہیں۔
    @param _from NFT کا موجودہ مالک۔
    @param _to نیا مالک۔
    @param _tokenId منتقل کرنے کے لیے NFT۔
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

یہ فنکشن آپ کو کسی بھی پتے پر منتقل کرنے دیتا ہے۔ جب تک کہ پتہ صارف کا نہ ہو، یا کوئی ایسا کنٹریکٹ جو ٹوکن منتقل کرنا جانتا ہو، کوئی بھی ٹوکن جو آپ منتقل کرتے ہیں وہ اس پتے میں پھنس جائے گا اور بیکار ہو جائے گا۔

```python
@external
def safeTransferFrom(
        _from: address,
        _to: address,
        _tokenId: uint256,
        _data: Bytes[1024]=b""
    ):
    """
    @dev ایک NFT کی ملکیت ایک پتے سے دوسرے پتے پر منتقل کرتا ہے۔
         جب تک `msg.sender` موجودہ مالک، ایک مجاز آپریٹر، یا اس
         NFT کے لیے منظور شدہ پتہ نہ ہو، تھرو کرتا ہے۔
         اگر `_from` موجودہ مالک نہیں ہے تو تھرو کرتا ہے۔
         اگر `_to` صفر کا پتہ ہے تو تھرو کرتا ہے۔
         اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے۔
         اگر `_to` ایک سمارٹ کنٹریکٹ ہے، تو یہ `_to` پر `onERC721Received` کو کال کرتا ہے اور اگر
         واپسی کی قدر `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` نہ ہو تو تھرو کرتا ہے۔
         نوٹ: bytes4 کو پیڈنگ کے ساتھ bytes32 سے ظاہر کیا جاتا ہے
    @param _from NFT کا موجودہ مالک۔
    @param _to نیا مالک۔
    @param _tokenId منتقل کرنے کے لیے NFT۔
    @param _data اضافی ڈیٹا بغیر کسی مخصوص فارمیٹ کے، `_to` کو کال میں بھیجا گیا۔
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

پہلے منتقلی کرنا ٹھیک ہے کیونکہ اگر کوئی مسئلہ ہوتا ہے تو ہم ویسے بھی واپس کر دیں گے، لہذا کال میں کیا گیا سب کچھ منسوخ ہو جائے گا۔

```python
    if _to.is_contract: # چیک کریں کہ آیا `_to` ایک کنٹریکٹ ایڈریس ہے
```

پہلے یہ دیکھنے کے لیے چیک کریں کہ آیا پتہ ایک کنٹریکٹ ہے (اگر اس میں کوڈ ہے)۔ اگر نہیں، تو فرض کریں کہ یہ صارف کا پتہ ہے اور صارف ٹوکن کا استعمال یا اسے منتقل کر سکے گا۔ لیکن اسے آپ کو تحفظ کے جھوٹے احساس میں مبتلا نہ ہونے دیں۔ آپ `safeTransferFrom` کے ساتھ بھی ٹوکن کھو سکتے ہیں، اگر آپ انہیں ایک ایسے پتے پر منتقل کرتے ہیں جس کی نجی کلید کسی کو معلوم نہیں ہے۔

```python
        returnValue: bytes32 = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data)
```

ٹارگٹ کنٹریکٹ کو کال کریں تاکہ یہ دیکھا جا سکے کہ کیا وہ ERC-721 ٹوکن وصول کر سکتا ہے۔

```python
        # اگر منتقلی کی منزل ایک کنٹریکٹ ہے جو 'onERC721Received' کو نافذ نہیں کرتا ہے تو تھرو کرتا ہے
        assert returnValue == method_id("onERC721Received(address,address,uint256,bytes)", output_type=bytes32)
```

اگر منزل ایک کنٹریکٹ ہے، لیکن ایک ایسا جو ERC-721 ٹوکن قبول نہیں کرتا (یا جس نے اس مخصوص منتقلی کو قبول نہ کرنے کا فیصلہ کیا ہے)، تو واپس کریں۔

```python
@external
def approve(_approved: address, _tokenId: uint256):
    """
    @dev ایک NFT کے لیے منظور شدہ پتہ سیٹ کریں یا اس کی دوبارہ تصدیق کریں۔ صفر پتہ اس بات کی نشاندہی کرتا ہے کہ کوئی منظور شدہ پتہ نہیں ہے۔
         جب تک `msg.sender` موجودہ NFT کا مالک، یا موجودہ مالک کا ایک مجاز آپریٹر نہ ہو، تھرو کرتا ہے۔
         اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے۔ (نوٹ: یہ EIP میں نہیں لکھا گیا ہے)
         اگر `_approved` موجودہ مالک ہے تو تھرو کرتا ہے۔ (نوٹ: یہ EIP میں نہیں لکھا گیا ہے)
    @param _approved دیے گئے NFT آئی ڈی کے لیے منظور کیا جانے والا پتہ۔
    @param _tokenId منظور کیے جانے والے ٹوکن کا آئی ڈی۔
    """
    owner: address = self.idToOwner[_tokenId]
    # اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے
    assert owner != ZERO_ADDRESS
    # اگر `_approved` موجودہ مالک ہے تو تھرو کرتا ہے
    assert _approved != owner
```

روایت کے مطابق اگر آپ کوئی منظور کنندہ نہیں رکھنا چاہتے تو آپ صفر پتے کو مقرر کرتے ہیں، خود کو نہیں۔

```python
    # ضروریات چیک کریں
    senderIsOwner: bool = self.idToOwner[_tokenId] == msg.sender
    senderIsApprovedForAll: bool = (self.ownerToOperators[owner])[msg.sender]
    assert (senderIsOwner or senderIsApprovedForAll)
```

منظوری سیٹ کرنے کے لیے آپ یا تو مالک ہو سکتے ہیں، یا مالک کی طرف سے مجاز آپریٹر۔

```python
    # منظوری سیٹ کریں
    self.idToApprovals[_tokenId] = _approved
    log Approval(owner, _approved, _tokenId)


@external
def setApprovalForAll(_operator: address, _approved: bool):
    """
    @dev کسی تیسرے فریق ("آپریٹر") کے لیے `msg.sender` کے تمام اثاثوں کا انتظام کرنے کے لیے منظوری کو فعال یا غیر فعال کرتا ہے۔
         یہ ApprovalForAll ایونٹ بھی جاری کرتا ہے۔
         اگر `_operator` `msg.sender` ہے تو تھرو کرتا ہے۔ (نوٹ: یہ EIP میں نہیں لکھا گیا ہے)
    @notice یہ اس وقت بھی کام کرتا ہے جب بھیجنے والے کے پاس اس وقت کوئی ٹوکن نہ ہو۔
    @param _operator مجاز آپریٹرز کے سیٹ میں شامل کرنے کے لیے پتہ۔
    @param _approved اگر آپریٹرز منظور شدہ ہیں تو True، منظوری منسوخ کرنے کے لیے false۔
    """
    # اگر `_operator` `msg.sender` ہے تو تھرو کرتا ہے
    assert _operator != msg.sender
    self.ownerToOperators[msg.sender][_operator] = _approved
    log ApprovalForAll(msg.sender, _operator, _approved)
```

#### نئے ٹوکن منٹ کریں اور موجودہ کو تباہ کریں {#mint-burn}

وہ اکاؤنٹ جس نے کنٹریکٹ بنایا ہے وہ `minter` ہے، وہ سپر یوزر جسے نئے NFTs منٹ کرنے کا اختیار ہے۔ تاہم، اسے بھی موجودہ ٹوکنز کو جلانے کی اجازت نہیں ہے۔ صرف مالک، یا مالک کی طرف سے مجاز ادارہ، ایسا کر سکتا ہے۔

```python
### منٹ اور برن فنکشنز ###

@external
def mint(_to: address, _tokenId: uint256) -> bool:
```

یہ فنکشن ہمیشہ `True` واپس کرتا ہے، کیونکہ اگر آپریشن ناکام ہوتا ہے تو اسے واپس کر دیا جاتا ہے۔

```python
    """
    @dev ٹوکن منٹ کرنے کا فنکشن
         اگر `msg.sender` منٹر نہیں ہے تو تھرو کرتا ہے۔
         اگر `_to` صفر کا پتہ ہے تو تھرو کرتا ہے۔
         اگر `_tokenId` کسی کی ملکیت میں ہے تو تھرو کرتا ہے۔
    @param _to وہ پتہ جو منٹ کیے گئے ٹوکن وصول کرے گا۔
    @param _tokenId منٹ کیے جانے والے ٹوکن کا آئی ڈی۔
    @return ایک بولین جو اس بات کی نشاندہی کرتا ہے کہ آیا آپریشن کامیاب تھا۔
    """
    # اگر `msg.sender` منٹر نہیں ہے تو تھرو کرتا ہے
    assert msg.sender == self.minter
```

صرف منٹر (وہ اکاؤنٹ جس نے ERC-721 کنٹریکٹ بنایا ہے) نئے ٹوکن منٹ کر سکتا ہے۔ یہ مستقبل میں ایک مسئلہ ہو سکتا ہے اگر ہم منٹر کی شناخت تبدیل کرنا چاہیں۔ ایک پروڈکشن کنٹریکٹ میں آپ شاید ایک ایسا فنکشن چاہیں گے جو منٹر کو منٹر کی مراعات کسی اور کو منتقل کرنے کی اجازت دے۔

```python
    # اگر `_to` صفر کا پتہ ہے تو تھرو کرتا ہے
    assert _to != ZERO_ADDRESS
    # NFT شامل کریں۔ اگر `_tokenId` کسی کی ملکیت میں ہے تو تھرو کرتا ہے
    self._addTokenTo(_to, _tokenId)
    log Transfer(ZERO_ADDRESS, _to, _tokenId)
    return True
```

روایت کے مطابق، نئے ٹوکنز کی منٹنگ صفر پتے سے منتقلی کے طور پر شمار ہوتی ہے۔

```python

@external
def burn(_tokenId: uint256):
    """
    @dev ایک مخصوص ERC721 ٹوکن کو جلاتا ہے۔
         جب تک `msg.sender` موجودہ مالک، ایک مجاز آپریٹر، یا اس NFT کے لیے منظور شدہ
         پتہ نہ ہو، تھرو کرتا ہے۔
         اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے۔
    @param _tokenId جلائے جانے والے ERC721 ٹوکن کا uint256 آئی ڈی۔
    """
    # ضروریات چیک کریں
    assert self._isApprovedOrOwner(msg.sender, _tokenId)
    owner: address = self.idToOwner[_tokenId]
    # اگر `_tokenId` ایک درست NFT نہیں ہے تو تھرو کرتا ہے
    assert owner != ZERO_ADDRESS
    self._clearApproval(owner, _tokenId)
    self._removeTokenFrom(owner, _tokenId)
    log Transfer(owner, ZERO_ADDRESS, _tokenId)
```

جو کوئی بھی ٹوکن منتقل کرنے کی اجازت رکھتا ہے اسے اسے جلانے کی اجازت ہے۔ جبکہ ایک جلانے کا عمل صفر پتے پر منتقلی کے برابر لگتا ہے، صفر پتہ دراصل ٹوکن وصول نہیں کرتا ہے۔ یہ ہمیں ٹوکن کے لیے استعمال ہونے والے تمام اسٹوریج کو آزاد کرنے کی اجازت دیتا ہے، جو ٹرانزیکشن کی گیس لاگت کو کم کر سکتا ہے۔

## اس کنٹریکٹ کا استعمال {#using-contract}

Solidity کے برعکس، Vyper میں وراثت نہیں ہے۔ یہ کوڈ کو واضح اور اس لیے محفوظ بنانے کے لیے ایک دانستہ ڈیزائن کا انتخاب ہے۔ لہذا اپنا خود کا Vyper ERC-721 کنٹریکٹ بنانے کے لیے آپ [اس کنٹریکٹ](https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC721.vy) کو لیتے ہیں اور اپنی مطلوبہ کاروباری منطق کو نافذ کرنے کے لیے اس میں ترمیم کرتے ہیں۔

## نتیجہ {#conclusion}

جائزے کے لیے، اس کنٹریکٹ میں کچھ اہم ترین خیالات یہ ہیں:

- محفوظ منتقلی کے ساتھ ERC-721 ٹوکن وصول کرنے کے لیے، کنٹریکٹس کو `ERC721Receiver` انٹرفیس کو نافذ کرنا ہوتا ہے۔
- یہاں تک کہ اگر آپ محفوظ منتقلی کا استعمال کرتے ہیں، تب بھی ٹوکن پھنس سکتے ہیں اگر آپ انہیں ایک ایسے پتے پر بھیجتے ہیں جس کی نجی کلید معلوم نہیں ہے۔
- جب کسی آپریشن میں کوئی مسئلہ ہو تو صرف ناکامی کی قدر واپس کرنے کے بجائے کال کو `واپس` کرنا ایک اچھا خیال ہے۔
- ERC-721 ٹوکن تب موجود ہوتے ہیں جب ان کا کوئی مالک ہوتا ہے۔
- ایک NFT منتقل کرنے کے لیے مجاز ہونے کے تین طریقے ہیں۔ آپ مالک ہو سکتے ہیں، ایک مخصوص ٹوکن کے لیے منظور شدہ ہو سکتے ہیں، یا مالک کے تمام ٹوکنز کے لیے آپریٹر ہو سکتے ہیں۔
- ماضی کے واقعات صرف بلاک چین کے باہر نظر آتے ہیں۔ بلاک چین کے اندر چلنے والا کوڈ انہیں نہیں دیکھ سکتا۔

اب جائیں اور محفوظ Vyper کنٹریکٹس نافذ کریں۔

[میرے مزید کام کے لیے یہاں دیکھیں](https://cryptodocguy.pro/)۔

