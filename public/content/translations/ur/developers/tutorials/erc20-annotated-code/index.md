---
title: "ERC-20 کنٹریکٹ واک تھرو"
description: OpenZeppelin ERC-20 کنٹریکٹ میں کیا ہے اور یہ وہاں کیوں ہے؟
author: اوری پومیرانٹز
lang: ur-in
tags: [ "solidity", "erc-20" ]
skill: beginner
published: 2021-03-09
---

## تعارف {#introduction}

ایتھیریم کے سب سے عام استعمالات میں سے ایک یہ ہے کہ ایک گروپ ایک قابل تجارت ٹوکن بنائے، ایک طرح سے ان کی اپنی کرنسی۔ یہ ٹوکنز عام طور پر ایک معیار کی پیروی کرتے ہیں،
[ERC-20](/developers/docs/standards/tokens/erc-20/)۔ یہ معیار ایسے ٹولز لکھنا ممکن بناتا ہے، جیسے لیکویڈیٹی پولز اور والیٹس، جو تمام ERC-20
ٹوکنز کے ساتھ کام کرتے ہیں۔ اس مضمون میں ہم
[OpenZeppelin Solidity ERC20 امپلیمینٹیشن](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) کے ساتھ ساتھ
[انٹرفیس ڈیفینیشن](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) کا تجزیہ کریں گے۔

یہ اینوٹیٹیڈ سورس کوڈ ہے۔ اگر آپ ERC-20 کو امپلیمنٹ کرنا چاہتے ہیں،
[یہ ٹیوٹوریل پڑھیں](https://docs.openzeppelin.com/contracts/2.x/erc20-supply)۔

## انٹرفیس {#the-interface}

ERC-20 جیسے معیار کا مقصد بہت سے ٹوکنز امپلیمینٹیشنز کی اجازت دینا ہے جو والیٹس اور ڈی سینٹرلائزڈ ایکسچینجز جیسی ایپلیکیشنز میں انٹرآپریبل ہیں۔ اسے حاصل کرنے کے لیے، ہم ایک
[انٹرفیس](https://www.geeksforgeeks.org/solidity/solidity-basics-of-interface/) بناتے ہیں۔ کوئی بھی کوڈ جسے ٹوکن کنٹریکٹ استعمال کرنے کی ضرورت ہے وہ انٹرفیس میں وہی ڈیفینیشنز استعمال کر سکتا ہے اور اسے استعمال کرنے والے تمام ٹوکن کنٹریکٹس کے ساتھ ہم آہنگ ہو سکتا ہے، چاہے وہ MetaMask جیسا والیٹ ہو، etherscan.io جیسا dapp ہو، یا لیکویڈیٹی پول جیسا کوئی مختلف کنٹریکٹ ہو۔

![ERC-20 انٹرفیس کی مثال](erc20_interface.png)

اگر آپ ایک تجربہ کار پروگرامر ہیں، تو آپ کو شاید [Java](https://www.w3schools.com/java/java_interface.asp) یا یہاں تک کہ [C ہیڈر فائلز](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html) میں بھی اسی طرح کی کنسٹرکٹس دیکھنا یاد ہوگا۔

یہ OpenZeppelin سے [ERC-20 انٹرفیس](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) کی ایک ڈیفینیشن ہے۔ یہ [انسانی پڑھنے کے قابل معیار](https://eips.ethereum.org/EIPS/eip-20) کا Solidity کوڈ میں ترجمہ ہے۔ یقیناً، انٹرفیس خود یہ وضاحت نہیں کرتا ہے کہ _کیسے_ کچھ کرنا ہے۔ اس کی وضاحت نیچے کنٹریکٹ سورس کوڈ میں کی گئی ہے۔

&nbsp;

```solidity
// SPDX-License-Identifier: MIT
```

Solidity فائلوں میں لائسنس شناخت کنندہ شامل ہونا چاہیے۔ [آپ یہاں لائسنسوں کی فہرست دیکھ سکتے ہیں](https://spdx.org/licenses/)۔ اگر آپ کو کسی مختلف لائسنس کی ضرورت ہے تو تبصروں میں اس کی وضاحت کریں۔

&nbsp;

```solidity
pragma solidity >=0.6.0 <0.8.0;
```

Solidity زبان اب بھی تیزی سے ترقی کر رہی ہے، اور نئے ورژنز پرانے کوڈ کے ساتھ ہم آہنگ نہیں ہو سکتے ہیں
([یہاں دیکھیں](https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html))۔ لہذا، یہ ایک اچھا خیال ہے کہ نہ صرف زبان کا کم از کم ورژن، بلکہ ایک زیادہ سے زیادہ ورژن بھی بیان کیا جائے، جس کے ساتھ آپ نے کوڈ کی جانچ کی ہے۔

&nbsp;

```solidity
/**
 * @dev EIP میں بیان کردہ ERC20 معیار کا انٹرفیس۔
 */
```

تبصرے میں `@dev` [NatSpec فارمیٹ](https://docs.soliditylang.org/en/develop/natspec-format.html) کا حصہ ہے، جو سورس کوڈ سے
ڈاکیومینٹیشن تیار کرنے کے لیے استعمال ہوتا ہے۔

&nbsp;

```solidity
interface IERC20 {
```

روایت کے مطابق، انٹرفیس کے نام `I` سے شروع ہوتے ہیں۔

&nbsp;

```solidity
    /**
     * @dev وجود میں موجود ٹوکنز کی مقدار واپس کرتا ہے۔
     */
    function totalSupply() external view returns (uint256);
```

یہ فنکشن `external` ہے، جس کا مطلب ہے [اسے صرف کنٹریکٹ کے باہر سے کال کیا جا سکتا ہے](https://docs.soliditylang.org/en/v0.7.0/cheatsheet.html#index-2)۔
یہ کنٹریکٹ میں ٹوکنز کی کل سپلائی واپس کرتا ہے۔ یہ قدر Ethereum میں سب سے عام قسم، غیر دستخط شدہ 256 بٹس کا استعمال کرتے ہوئے واپس کی جاتی ہے (256 بٹس EVM کا
نیٹیو ورڈ سائز ہے)۔ یہ فنکشن ایک `view` بھی ہے، جس کا مطلب ہے کہ یہ اسٹیٹ کو تبدیل نہیں کرتا ہے، لہذا اسے بلاک چین کے ہر نوڈ پر چلانے کے بجائے ایک ہی نوڈ پر عمل میں لایا جا سکتا ہے۔ اس قسم کا فنکشن ٹرانزیکشن پیدا نہیں کرتا اور اس پر [گیس](/developers/docs/gas/) کی لاگت نہیں آتی۔

**نوٹ:** نظریاتی طور پر یہ ظاہر ہو سکتا ہے کہ کنٹریکٹ کا تخلیق کار اصل قدر سے کم کل سپلائی واپس کر کے دھوکہ دے سکتا ہے، جس سے ہر ٹوکن
اس کی اصل قیمت سے زیادہ قیمتی نظر آتا ہے۔ تاہم، یہ خوف بلاک چین کی حقیقی نوعیت کو نظر انداز کرتا ہے۔ بلاک چین پر ہونے والی ہر چیز کی تصدیق ہر نوڈ سے کی جا سکتی ہے۔ اسے حاصل کرنے کے لیے، ہر کنٹریکٹ کا مشین لینگویج کوڈ اور اسٹوریج ہر نوڈ پر دستیاب ہے۔ جبکہ آپ کو اپنے کنٹریکٹ کے لیے Solidity
کوڈ شائع کرنے کی ضرورت نہیں ہے، کوئی بھی آپ کو سنجیدگی سے نہیں لے گا جب تک کہ آپ سورس کوڈ اور Solidity کا وہ ورژن شائع نہ کریں جس کے ساتھ اسے کمپائل کیا گیا تھا، تاکہ اس کی آپ کے فراہم کردہ مشین لینگویج کوڈ سے تصدیق کی جا سکے۔
مثال کے طور پر، [یہ کنٹریکٹ](https://eth.blockscout.com/address/0xa530F85085C6FE2f866E7FdB716849714a89f4CD?tab=contract) دیکھیں۔

&nbsp;

```solidity
    /**
     * @dev `account` کی ملکیت والے ٹوکنز کی مقدار واپس کرتا ہے۔
     */
    function balanceOf(address account) external view returns (uint256);
```

جیسا کہ نام سے ظاہر ہے، `balanceOf` ایک اکاؤنٹ کا بیلنس واپس کرتا ہے۔ Ethereum اکاؤنٹس کو Solidity میں `address` قسم کا استعمال کرتے ہوئے شناخت کیا جاتا ہے، جس میں 160 بٹس ہوتے ہیں۔
یہ `external` اور `view` بھی ہے۔

&nbsp;

```solidity
    /**
     * @dev کالر کے اکاؤنٹ سے `recipient` کو `amount` ٹوکنز منتقل کرتا ہے۔
     *
     * ایک بولین قدر واپس کرتا ہے جو یہ بتاتا ہے کہ آیا آپریشن کامیاب ہوا۔
     *
     * ایک {Transfer} ایونٹ ایمٹ کرتا ہے۔
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
```

`transfer` فنکشن کالر سے ٹوکنز کو ایک مختلف ایڈریس پر منتقل کرتا ہے۔ اس میں اسٹیٹ کی تبدیلی شامل ہے، لہذا یہ `view` نہیں ہے۔
جب کوئی صارف اس فنکشن کو کال کرتا ہے تو یہ ایک ٹرانزیکشن بناتا ہے اور گیس کی لاگت آتی ہے۔ یہ ایک ایونٹ، `Transfer` بھی ایمٹ کرتا ہے، تاکہ بلاک چین پر ہر کسی کو ایونٹ کے بارے میں مطلع کیا جا سکے۔

فنکشن میں دو مختلف قسم کے کالرز کے لیے دو قسم کے آؤٹ پٹ ہیں:

- صارفین جو فنکشن کو براہ راست صارف انٹرفیس سے کال کرتے ہیں۔ عام طور پر صارف ایک ٹرانزیکشن جمع کرتا ہے اور جواب کا انتظار نہیں کرتا، جس میں غیر معینہ مدت لگ سکتی ہے۔ صارف یہ دیکھ سکتا ہے کہ کیا ہوا ہے
  ٹرانزیکشن کی رسید (جس کی شناخت ٹرانزیکشن ہیش سے ہوتی ہے) یا `Transfer` ایونٹ کو دیکھ کر۔
- دوسرے کنٹریکٹس، جو فنکشن کو مجموعی ٹرانزیکشن کے حصے کے طور پر کال کرتے ہیں۔ ان کنٹریکٹس کو نتیجہ فوری طور پر مل جاتا ہے،
  کیونکہ وہ اسی ٹرانزیکشن میں چلتے ہیں، لہذا وہ فنکشن کی واپسی کی قدر استعمال کر سکتے ہیں۔

اسی قسم کا آؤٹ پٹ دوسرے فنکشنز کے ذریعے بنایا جاتا ہے جو کنٹریکٹ کی اسٹیٹ کو تبدیل کرتے ہیں۔

&nbsp;

الاؤنسز ایک اکاؤنٹ کو کچھ ٹوکنز خرچ کرنے کی اجازت دیتے ہیں جو ایک مختلف مالک سے تعلق رکھتے ہیں۔
یہ مفید ہے، مثال کے طور پر، ان کنٹریکٹس کے لیے جو بیچنے والے کے طور پر کام کرتے ہیں۔ کنٹریکٹس
ایونٹس کی نگرانی نہیں کر سکتے، لہذا اگر کوئی خریدار براہ راست بیچنے والے کنٹریکٹ کو ٹوکنز منتقل کرتا
ہے تو اس کنٹریکٹ کو معلوم نہیں ہوگا کہ اسے ادائیگی کی گئی ہے۔ اس کے بجائے، خریدار بیچنے والے کنٹریکٹ کو ایک مخصوص رقم خرچ کرنے کی اجازت دیتا ہے، اور بیچنے والا اس رقم کو منتقل کرتا ہے۔
یہ ایک فنکشن کے ذریعے کیا جاتا ہے جسے بیچنے والا کنٹریکٹ کال کرتا ہے، تاکہ بیچنے والا کنٹریکٹ
جان سکے کہ آیا یہ کامیاب تھا۔

```solidity
    /**
     * @dev باقی ٹوکنز کی تعداد واپس کرتا ہے جو `spender` کو {transferFrom} کے ذریعے `owner` کی جانب سے خرچ کرنے کی اجازت ہوگی۔ یہ
     * بطور ڈیفالٹ صفر ہے۔
     *
     * یہ قدر اس وقت تبدیل ہوتی ہے جب {approve} یا {transferFrom} کو کال کیا جاتا ہے۔
     */
    function allowance(address owner, address spender) external view returns (uint256);
```

`allowance` فنکشن کسی کو بھی یہ دیکھنے کے لیے استفسار کرنے دیتا ہے کہ ایک
ایڈریس (`owner`) دوسرے ایڈریس (`spender`) کو خرچ کرنے کی کیا الاؤنس دیتا ہے۔

&nbsp;

```solidity
    /**
     * @dev کالر کے ٹوکنز پر `spender` کے الاؤنس کے طور پر `amount` سیٹ کرتا ہے۔
     *
     * ایک بولین قدر واپس کرتا ہے جو یہ بتاتا ہے کہ آیا آپریشن کامیاب ہوا۔
     *
     * اہم: خبردار رہیں کہ اس طریقے سے الاؤنس تبدیل کرنے سے یہ خطرہ لاحق ہوتا ہے
     * کہ کوئی بدقسمت ٹرانزیکشن آرڈرنگ کے ذریعے پرانے اور نئے دونوں الاؤنس استعمال کر سکتا ہے۔ اس ریس
     * کی حالت کو کم کرنے کا ایک ممکنہ حل یہ ہے کہ پہلے خرچ کرنے والے کے الاؤنس کو 0 تک کم کریں اور اس کے بعد
     * مطلوبہ قدر سیٹ کریں:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * ایک {Approval} ایونٹ ایمٹ کرتا ہے۔
     */
    function approve(address spender, uint256 amount) external returns (bool);
```

`approve` فنکشن ایک الاؤنس بناتا ہے۔ اس کے بارے میں پیغام کو ضرور پڑھیں کہ اسے کیسے غلط استعمال کیا جا سکتا ہے۔ Ethereum میں آپ اپنی ٹرانزیکشنز کی ترتیب کو کنٹرول کرتے ہیں،
لیکن آپ اس ترتیب کو کنٹرول نہیں کر سکتے جس میں دوسرے لوگوں کی ٹرانزیکشنز پر عمل درآمد کیا جائے گا،
جب تک کہ آپ اپنی ٹرانزیکشن اس وقت تک جمع نہ کریں جب تک کہ آپ دوسری طرف کی ٹرانزیکشن کو نہ دیکھ لیں۔

&nbsp;

```solidity
    /**
     * @dev الاؤنس میکانزم کا استعمال کرتے ہوئے `sender` سے `recipient` کو `amount` ٹوکنز منتقل کرتا ہے۔
     * `amount` پھر کالر کے الاؤنس سے کاٹا جاتا ہے۔
     *
     * ایک بولین قدر واپس کرتا ہے جو یہ بتاتا ہے کہ آیا آپریشن کامیاب ہوا۔
     *
     * ایک {Transfer} ایونٹ ایمٹ کرتا ہے۔
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```

آخر میں، `transferFrom` خرچ کرنے والے کے ذریعے الاؤنس کو حقیقت میں خرچ کرنے کے لیے استعمال کیا جاتا ہے۔

&nbsp;

```solidity

    /**
     * @dev اس وقت ایمٹ ہوتا ہے جب `value` ٹوکنز ایک اکاؤنٹ (`from`) سے دوسرے (`to`) میں منتقل ہوتے ہیں۔
     *
     * نوٹ کریں کہ `value` صفر ہو سکتا ہے۔
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev اس وقت ایمٹ ہوتا ہے جب {approve} پر کال کے ذریعے ایک `owner` کے لیے `spender` کا الاؤنس سیٹ کیا جاتا ہے۔ `value` نیا الاؤنس ہے۔
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```

یہ ایونٹس اس وقت ایمٹ ہوتے ہیں جب ERC-20 کنٹریکٹ کی اسٹیٹ تبدیل ہوتی ہے۔

## اصل کنٹریکٹ {#the-actual-contract}

یہ اصل کنٹریکٹ ہے جو ERC-20 معیار کو لاگو کرتا ہے،
[یہاں سے لیا گیا ہے](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)۔
اس کا مقصد جیسا ہے ویسا استعمال کرنا نہیں ہے، لیکن آپ اس سے
[انہیریٹ](https://www.tutorialspoint.com/solidity/solidity_inheritance.htm) کر کے اسے کسی قابل استعمال چیز تک بڑھا سکتے ہیں۔

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;
```

&nbsp;

### امپورٹ اسٹیٹمنٹس {#import-statements}

اوپر دی گئی انٹرفیس ڈیفینیشنز کے علاوہ، کنٹریکٹ ڈیفینیشن دو دیگر فائلوں کو امپورٹ کرتی ہے:

```solidity

import "../../GSN/Context.sol";
import "./IERC20.sol";
import "../../math/SafeMath.sol";
```

- `GSN/Context.sol` [OpenGSN](https://www.opengsn.org/) کو استعمال کرنے کے لیے درکار ڈیفینیشنز ہیں، ایک ایسا نظام جو ایتھر کے بغیر صارفین کو
  بلاک چین استعمال کرنے کی اجازت دیتا ہے۔ نوٹ کریں کہ یہ ایک پرانا ورژن ہے، اگر آپ OpenGSN کے ساتھ انٹیگریٹ کرنا چاہتے ہیں تو
  [یہ ٹیوٹوریل استعمال کریں](https://docs.opengsn.org/javascript-client/tutorial.html)۔
- [SafeMath لائبریری](https://ethereumdev.io/using-safe-math-library-to-prevent-from-overflows/)، جو Solidity ورژنز **&lt;0.8.0** کے لیے
  اریتھمیٹک اوور فلو/انڈر فلو کو روکتی ہے۔ Solidity ≥0.8.0 میں، اریتھمیٹک آپریشنز خود بخود
  اوور فلو/انڈر فلو پر ریورٹ ہو جاتے ہیں، جس سے SafeMath غیر ضروری ہو جاتا ہے۔ یہ کنٹریکٹ پرانے کمپائلر ورژنز کے ساتھ بیک ورڈ کمپیٹیبلٹی کے لیے SafeMath کا استعمال کرتا ہے۔

&nbsp;

یہ تبصرہ کنٹریکٹ کے مقصد کی وضاحت کرتا ہے۔

```solidity
/**
 * @dev {IERC20} انٹرفیس کا امپلیمینٹیشن۔
 *
 * یہ امپلیمینٹیشن اس طریقے سے اگنوسٹک ہے جس سے ٹوکنز بنائے جاتے ہیں۔ اس کا مطلب ہے
 * کہ {_mint} کا استعمال کرتے ہوئے ایک ڈیریوڈ کنٹریکٹ میں ایک سپلائی میکانزم شامل کرنا ہوگا۔
 * ایک عام میکانزم کے لیے {ERC20PresetMinterPauser} دیکھیں۔
 *
 * ٹپ: تفصیلی تحریر کے لیے ہماری گائیڈ دیکھیں
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[سپلائی میکانزم کو کیسے
 * لاگو کیا جائے]۔
 *
 * ہم نے عام OpenZeppelin رہنما خطوط پر عمل کیا ہے: فنکشنز ناکامی پر `false` واپس کرنے کے بجائے
 * ریورٹ کرتے ہیں۔ یہ طرز عمل بہرحال روایتی ہے
 * اور ERC20 ایپلیکیشنز کی توقعات سے متصادم نہیں ہے۔
 *
 * مزید برآں، {transferFrom} پر کالز پر ایک {Approval} ایونٹ ایمٹ ہوتا ہے۔
 * یہ ایپلیکیشنز کو صرف مذکورہ ایونٹس کو سن کر تمام اکاؤنٹس کے لیے الاؤنس کو دوبارہ بنانے کی اجازت دیتا ہے۔ EIP کی دیگر امپلیمینٹیشنز
 * ان ایونٹس کو ایمٹ نہیں کر سکتی ہیں، کیونکہ اس کی تفصیلات میں ضرورت نہیں ہے۔
 *
 * آخر میں، غیر معیاری {decreaseAllowance} اور {increaseAllowance}
 * فنکشنز الاؤنس سیٹ کرنے کے ارد گرد معروف مسائل کو کم کرنے کے لیے شامل کیے گئے ہیں۔
 * {IERC20-approve} دیکھیں۔
 */

```

### کنٹریکٹ ڈیفینیشن {#contract-definition}

```solidity
contract ERC20 is Context, IERC20 {
```

یہ لائن انہیریٹنس کی وضاحت کرتی ہے، اس معاملے میں اوپر سے `IERC20` اور OpenGSN کے لیے `Context` سے۔

&nbsp;

```solidity

    using SafeMath for uint256;

```

یہ لائن `SafeMath` لائبریری کو `uint256` قسم سے منسلک کرتی ہے۔ آپ یہ لائبریری
[یہاں](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol) تلاش کر سکتے ہیں۔

### ویری ایبل ڈیفینیشنز {#variable-definitions}

یہ ڈیفینیشنز کنٹریکٹ کے اسٹیٹ ویری ایبلز کی وضاحت کرتی ہیں۔ یہ ویری ایبلز `private` قرار دیے گئے ہیں، لیکن
اس کا صرف یہ مطلب ہے کہ بلاک چین پر موجود دوسرے کنٹریکٹس انہیں پڑھ نہیں سکتے۔ _بلاک چین پر کوئی راز نہیں ہیں_، ہر نوڈ پر موجود سافٹ ویئر میں ہر بلاک پر ہر کنٹریکٹ کی اسٹیٹ ہوتی ہے۔ روایت کے مطابق، اسٹیٹ ویری ایبلز کا نام `_<something>` رکھا جاتا ہے۔

پہلے دو ویری ایبلز [میپنگز](https://www.tutorialspoint.com/solidity/solidity_mappings.htm) ہیں،
یعنی وہ تقریباً [ایسوسی ایٹیو ایرے](https://wikipedia.org/wiki/Associative_array) کی طرح برتاؤ کرتے ہیں،
سوائے اس کے کہ کیز عددی قدریں ہیں۔ اسٹوریج صرف ان اندراجات کے لیے مختص کیا جاتا ہے جن کی قدریں ڈیفالٹ (صفر) سے مختلف ہوتی ہیں۔

```solidity
    mapping (address => uint256) private _balances;
```

پہلی میپنگ، `_balances`، ایڈریسز اور اس ٹوکن کے ان کے متعلقہ بیلنسز ہیں۔ بیلنس تک رسائی کے لیے، یہ نحو استعمال کریں: `_balances[<address>]`۔

&nbsp;

```solidity
    mapping (address => mapping (address => uint256)) private _allowances;
```

یہ ویری ایبل، `_allowances`، پہلے بیان کردہ الاؤنسز کو اسٹور کرتا ہے۔ پہلا انڈیکس ٹوکنز کا مالک ہے، اور دوسرا الاؤنس کے ساتھ کنٹریکٹ ہے۔ ایڈریس A کی رقم تک رسائی حاصل کرنے کے لیے جو وہ ایڈریس B کے اکاؤنٹ سے خرچ کر سکتا ہے، `_allowances[B][A]` استعمال کریں۔

&nbsp;

```solidity
    uint256 private _totalSupply;
```

جیسا کہ نام سے پتہ چلتا ہے، یہ ویری ایبل ٹوکنز کی کل سپلائی کا ٹریک رکھتا ہے۔

&nbsp;

```solidity
    string private _name;
    string private _symbol;
    uint8 private _decimals;
```

یہ تینوں ویری ایبلز پڑھنے کی اہلیت کو بہتر بنانے کے لیے استعمال کیے جاتے ہیں۔ پہلے دو خود وضاحتی ہیں، لیکن `_decimals` نہیں ہے۔

ایک طرف، Ethereum میں فلوٹنگ پوائنٹ یا فریکشنل ویری ایبلز نہیں ہیں۔ دوسری طرف، انسان ٹوکنز کو تقسیم کرنے کے قابل ہونا پسند کرتے ہیں۔ لوگوں کے کرنسی کے لیے سونے پر بسنے کی ایک وجہ یہ تھی کہ جب کوئی گائے کی قیمت کے برابر بطخ خریدنا چاہتا تھا تو چینج کرنا مشکل تھا۔

اس کا حل انٹیجرز کا ٹریک رکھنا ہے، لیکن اصلی ٹوکن کے بجائے ایک فریکشنل ٹوکن کو گننا ہے جو تقریباً بے قیمت ہے۔ ایتھر کے معاملے میں، فریکشنل ٹوکن کو wei کہا جاتا ہے، اور 10^18 wei ایک
ETH کے برابر ہے۔ لکھتے وقت، 10,000,000,000,000 wei تقریباً ایک امریکی یا یورو سینٹ کے برابر ہے۔

ایپلیکیشنز کو یہ جاننے کی ضرورت ہے کہ ٹوکن بیلنس کیسے دکھایا جائے۔ اگر کسی صارف کے پاس 3,141,000,000,000,000,000 wei ہیں، تو کیا یہ
3.14 ETH ہے؟ 31.41 ETH؟ 3,141 ETH؟ ایتھر کے معاملے میں یہ 10^18 wei سے ETH تک بیان کیا گیا ہے، لیکن اپنے
ٹوکن کے لیے آپ ایک مختلف قدر منتخب کر سکتے ہیں۔ اگر ٹوکن کو تقسیم کرنے کا کوئی مطلب نہیں ہے، تو آپ صفر کی `_decimals` قدر استعمال کر سکتے ہیں۔ اگر آپ ETH جیسا ہی معیار استعمال کرنا چاہتے ہیں تو **18** کی قدر استعمال کریں۔

### کنسٹرکٹر {#the-constructor}

```solidity
    /**
     * @dev {name} اور {symbol} کے لیے قدریں سیٹ کرتا ہے، {decimals} کو 18 کی
     * ڈیفالٹ قدر کے ساتھ انیشلائز کرتا ہے۔
     *
     * {decimals} کے لیے ایک مختلف قدر منتخب کرنے کے لیے، {_setupDecimals} استعمال کریں۔
     *
     * یہ تینوں قدریں ناقابل تغیر ہیں: انہیں صرف تعمیر کے دوران ایک بار سیٹ کیا جا سکتا ہے۔
     */
    constructor (string memory name_, string memory symbol_) public {
        // Solidity ≥0.7.0 میں، 'public' مضمر ہے اور اسے چھوڑا جا سکتا ہے۔

        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
```

کنسٹرکٹر کو اس وقت کال کیا جاتا ہے جب کنٹریکٹ پہلی بار بنایا جاتا ہے۔ روایت کے مطابق، فنکشن پیرامیٹرز کا نام `<something>_` رکھا جاتا ہے۔

### یوزر انٹرفیس فنکشنز {#user-interface-functions}

```solidity
    /**
     * @dev ٹوکن کا نام واپس کرتا ہے۔
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev ٹوکن کی علامت واپس کرتا ہے، عام طور پر نام کا ایک چھوٹا ورژن۔
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev اس کی صارف کی نمائندگی حاصل کرنے کے لیے استعمال ہونے والے ڈیسیملز کی تعداد واپس کرتا ہے۔
     * مثال کے طور پر، اگر `decimals` `2` کے برابر ہے، تو `505` ٹوکنز کا بیلنس
     * صارف کو `5,05` (`505 / 10 ** 2`) کے طور پر دکھایا جانا چاہیے۔
     *
     * ٹوکنز عام طور پر 18 کی قدر کا انتخاب کرتے ہیں، جو ایتھر اور wei کے درمیان تعلق کی نقل کرتا ہے۔
     * یہ وہ قدر ہے جسے {ERC20} استعمال کرتا ہے، جب تک کہ {_setupDecimals} کو کال نہ کیا جائے۔
     *
     * نوٹ: یہ معلومات صرف _ڈسپلے_ کے مقاصد کے لیے استعمال ہوتی ہیں: یہ کسی بھی طرح
     * کنٹریکٹ کے کسی بھی اریتھمیٹک کو متاثر نہیں کرتی ہے، بشمول
     * {IERC20-balanceOf} اور {IERC20-transfer}۔
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
```

یہ فنکشنز، `name`، `symbol`، اور `decimals` یوزر انٹرفیسز کو آپ کے کنٹریکٹ کے بارے میں جاننے میں مدد کرتے ہیں تاکہ وہ اسے صحیح طریقے سے ڈسپلے کر سکیں۔

ریٹرن کی قسم `string memory` ہے، یعنی ایک سٹرنگ ریٹرن کریں جو میموری میں اسٹور ہے۔ ویری ایبلز، جیسے سٹرنگز، کو تین جگہوں پر اسٹور کیا جا سکتا ہے:

|          | لائف ٹائم     | کنٹریکٹ تک رسائی | گیس کی لاگت                                                            |
| -------- | ------------- | ---------------- | ---------------------------------------------------------------------- |
| میموری   | فنکشن کال     | پڑھنا/لکھنا      | دس یا سو (اونچی جگہوں کے لیے زیادہ)                 |
| کال ڈیٹا | فنکشن کال     | صرف پڑھنا        | ریٹرن ٹائپ کے طور پر استعمال نہیں کیا جا سکتا، صرف فنکشن پیرامیٹر ٹائپ |
| اسٹوریج  | تبدیل ہونے تک | پڑھنا/لکھنا      | زیادہ (پڑھنے کے لیے 800، لکھنے کے لیے 20k)          |

اس معاملے میں، `memory` بہترین انتخاب ہے۔

### ٹوکن کی معلومات پڑھیں {#read-token-information}

یہ وہ فنکشنز ہیں جو ٹوکن کے بارے میں معلومات فراہم کرتے ہیں، یا تو کل سپلائی یا کسی
اکاؤنٹ کا بیلنس۔

```solidity
    /**
     * @dev {IERC20-totalSupply} دیکھیں۔
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
```

`totalSupply` فنکشن ٹوکنز کی کل سپلائی واپس کرتا ہے۔

&nbsp;

```solidity
    /**
     * @dev {IERC20-balanceOf} دیکھیں۔
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }
```

ایک اکاؤنٹ کا بیلنس پڑھیں۔ نوٹ کریں کہ کسی کو بھی کسی دوسرے کے اکاؤنٹ کا بیلنس حاصل کرنے کی اجازت ہے۔ اس معلومات کو چھپانے کی کوشش کرنے کا کوئی فائدہ نہیں، کیونکہ یہ ہر نوڈ پر ویسے بھی دستیاب ہے۔ _بلاک چین پر کوئی راز نہیں ہے۔_

### ٹوکنز منتقل کریں {#transfer-tokens}

```solidity
    /**
     * @dev {IERC20-transfer} دیکھیں۔
     *
     * تقاضے:
     *
     * - `recipient` صفر ایڈریس نہیں ہو سکتا۔
     * - کالر کے پاس کم از کم `amount` کا بیلنس ہونا چاہیے۔
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
```

`transfer` فنکشن کو بھیجنے والے کے اکاؤنٹ سے ٹوکنز کو کسی دوسرے اکاؤنٹ میں منتقل کرنے کے لیے کال کیا جاتا ہے۔ نوٹ کریں کہ اگرچہ یہ ایک بولین قدر واپس کرتا ہے، وہ قدر ہمیشہ **true** ہوتی ہے۔ اگر منتقلی ناکام ہو جاتی ہے تو کنٹریکٹ کال کو ریورٹ کر دیتا ہے۔

&nbsp;

```solidity
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
```

`_transfer` فنکشن اصل کام کرتا ہے۔ یہ ایک پرائیویٹ فنکشن ہے جسے صرف دوسرے کنٹریکٹ فنکشنز کے ذریعے کال کیا جا سکتا ہے۔ روایت کے مطابق پرائیویٹ فنکشنز کا نام `_<something>` رکھا جاتا ہے، بالکل اسٹیٹ ویری ایبلز کی طرح۔

عام طور پر Solidity میں ہم میسج بھیجنے والے کے لیے `msg.sender` استعمال کرتے ہیں۔ تاہم، یہ [OpenGSN](http://opengsn.org/) کو توڑتا ہے۔ اگر ہم اپنے ٹوکن کے ساتھ ایتھر لیس ٹرانزیکشنز کی اجازت دینا چاہتے ہیں، تو ہمیں `_msgSender()` استعمال کرنے کی ضرورت ہے۔ یہ عام ٹرانزیکشنز کے لیے `msg.sender` واپس کرتا ہے، لیکن ایتھر لیس ٹرانزیکشنز کے لیے اصل دستخط کنندہ واپس کرتا ہے نہ کہ وہ کنٹریکٹ جس نے میسج ریلے کیا۔

### الاؤنس فنکشنز {#allowance-functions}

یہ وہ فنکشنز ہیں جو الاؤنس کی فعالیت کو لاگو کرتے ہیں: `allowance`، `approve`، `transferFrom`، اور `_approve`۔ مزید برآں، OpenZeppelin کا امپلیمینٹیشن بنیادی معیار سے آگے بڑھ کر کچھ خصوصیات شامل کرتا ہے جو سیکیورٹی کو بہتر بناتی ہیں: `increaseAllowance`، اور `decreaseAllowance`۔

#### الاؤنس فنکشن {#allowance}

```solidity
    /**
     * @dev {IERC20-allowance} دیکھیں۔
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
```

`allowance` فنکشن ہر کسی کو کسی بھی الاؤنس کو چیک کرنے کی اجازت دیتا ہے۔

#### approve فنکشن {#approve}

```solidity
    /**
     * @dev {IERC20-approve} دیکھیں۔
     *
     * تقاضے:
     *
     * - `spender` صفر ایڈریس نہیں ہو سکتا۔
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
```

یہ فنکشن الاؤنس بنانے کے لیے کال کیا جاتا ہے۔ یہ اوپر دیے گئے `transfer` فنکشن سے ملتا جلتا ہے:

- فنکشن صرف ایک اندرونی فنکشن (اس معاملے میں، `_approve`) کو کال کرتا ہے جو اصل کام کرتا ہے۔
- فنکشن یا تو `true` (اگر کامیاب ہو) واپس کرتا ہے یا ریورٹ (اگر نہیں)۔

&nbsp;

```solidity
        _approve(_msgSender(), spender, amount);
        return true;
    }
```

ہم اندرونی فنکشنز کا استعمال ان جگہوں کی تعداد کو کم سے کم کرنے کے لیے کرتے ہیں جہاں اسٹیٹ کی تبدیلیاں ہوتی ہیں۔ _کوئی بھی_ فنکشن جو اسٹیٹ کو تبدیل کرتا ہے وہ ایک ممکنہ سیکیورٹی رسک ہے جس کا سیکیورٹی کے لیے آڈٹ کرنے کی ضرورت ہے۔ اس طرح ہمارے پاس غلط ہونے کے امکانات کم ہیں۔

#### transferFrom فنکشن {#transferFrom}

یہ وہ فنکشن ہے جسے ایک خرچ کرنے والا الاؤنس خرچ کرنے کے لیے کال کرتا ہے۔ اس کے لیے دو آپریشنز کی ضرورت ہے: خرچ کی جانے والی رقم کو منتقل کریں اور الاؤنس کو اس رقم سے کم کریں۔

```solidity
    /**
     * @dev {IERC20-transferFrom} دیکھیں۔
     *
     * اپ ڈیٹ شدہ الاؤنس کی نشاندہی کرنے والا ایک {Approval} ایونٹ ایمٹ کرتا ہے۔ یہ
     * EIP کے ذریعہ ضروری نہیں ہے۔ {ERC20} کے آغاز میں نوٹ دیکھیں۔
     *
     * تقاضے:
     *
     * - `sender` اور `recipient` صفر ایڈریس نہیں ہو سکتے۔
     * - `sender` کے پاس کم از کم `amount` کا بیلنس ہونا چاہیے۔
     * - کالر کے پاس کم از کم `amount` کے `sender` کے ٹوکنز کے لیے الاؤنس ہونا چاہیے۔
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual
                                                override returns (bool) {
        _transfer(sender, recipient, amount);
```

&nbsp;

`a.sub(b, "message")` فنکشن کال دو کام کرتی ہے۔ سب سے پہلے، یہ `a-b` کا حساب لگاتا ہے، جو کہ نیا الاؤنس ہے۔
دوسرا، یہ چیک کرتا ہے کہ یہ نتیجہ منفی نہیں ہے۔ اگر یہ منفی ہے تو کال فراہم کردہ میسج کے ساتھ ریورٹ ہو جاتی ہے۔ نوٹ کریں کہ جب کوئی کال ریورٹ ہوتی ہے تو اس کال کے دوران پہلے کی گئی کوئی بھی پروسیسنگ نظر انداز کر دی جاتی ہے لہذا ہمیں `_transfer` کو انڈو کرنے کی ضرورت نہیں ہے۔

```solidity
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount,
             "ERC20: منتقلی کی رقم الاؤنس سے زیادہ ہے"));
        return true;
    }
```

#### OpenZeppelin سیفٹی ایڈیشنز {#openzeppelin-safety-additions}

ایک غیر صفر الاؤنس کو دوسری غیر صفر قدر پر سیٹ کرنا خطرناک ہے،
کیونکہ آپ صرف اپنی ٹرانزیکشنز کی ترتیب کو کنٹرول کرتے ہیں، کسی اور کی نہیں۔ تصور کریں کہ آپ کے پاس دو صارفین ہیں، ایلس جو سادہ لوح ہے اور بل جو بے ایمان ہے۔ ایلس بل سے کچھ سروس چاہتی ہے، جس کے بارے میں وہ سوچتی ہے کہ اس کی قیمت پانچ ٹوکن ہے - لہذا وہ بل کو پانچ ٹوکن کا الاؤنس دیتی ہے۔

پھر کچھ بدلتا ہے اور بل کی قیمت دس ٹوکن تک بڑھ جاتی ہے۔ ایلس، جو اب بھی سروس چاہتی ہے، ایک ٹرانزیکشن بھیجتی ہے جو بل کے الاؤنس کو دس پر سیٹ کرتی ہے۔ جس لمحے بل اس نئی ٹرانزیکشن کو ٹرانزیکشن پول میں دیکھتا ہے وہ ایک ٹرانزیکشن بھیجتا ہے جو ایلس کے پانچ ٹوکن خرچ کرتا ہے اور اس کی گیس کی قیمت بہت زیادہ ہے تاکہ اسے تیزی سے مائن کیا جا سکے۔ اس طرح بل پہلے پانچ ٹوکن خرچ کر سکتا ہے اور پھر، جب ایلس کا نیا الاؤنس مائن ہو جاتا ہے، تو پندرہ ٹوکن کی کل قیمت کے لیے دس مزید خرچ کر سکتا ہے، جو ایلس کی اجازت سے زیادہ ہے۔ اس تکنیک کو [فرنٹ رننگ](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/#front-running) کہا جاتا ہے

| ایلس ٹرانزیکشن                       | ایلس نانس | بل ٹرانزیکشن                                     | بل نانس | بل کا الاؤنس | ایلس سے بل کی کل آمدنی |
| ------------------------------------ | --------- | ------------------------------------------------ | ------- | ------------ | ---------------------- |
| approve(Bill, 5)  | 10        |                                                  |         | 5            | 0                      |
|                                      |           | transferFrom(Alice, Bill, 5)  | 10,123  | 0            | 5                      |
| approve(Bill, 10) | 11        |                                                  |         | 10           | 5                      |
|                                      |           | transferFrom(Alice, Bill, 10) | 10,124  | 0            | 15                     |

اس مسئلے سے بچنے کے لیے، یہ دو فنکشنز (`increaseAllowance` اور `decreaseAllowance`) آپ کو ایک مخصوص رقم سے الاؤنس میں ترمیم کرنے کی اجازت دیتے ہیں۔ لہذا اگر بل نے پہلے ہی پانچ ٹوکن خرچ کر لیے ہیں، تو وہ صرف پانچ مزید خرچ کر سکے گا۔ ٹائمنگ پر منحصر ہے، اس کے کام کرنے کے دو طریقے ہیں، دونوں کا اختتام بل کو صرف دس ٹوکن ملنے پر ہوتا ہے:

A:

| ایلس ٹرانزیکشن                                | ایلس نانس | بل ٹرانزیکشن                                    | بل نانس | بل کا الاؤنس | ایلس سے بل کی کل آمدنی |
| --------------------------------------------- | --------: | ----------------------------------------------- | ------: | -----------: | ---------------------- |
| approve(Bill, 5)           |        10 |                                                 |         |            5 | 0                      |
|                                               |           | transferFrom(Alice, Bill, 5) |  10,123 |            0 | 5                      |
| increaseAllowance(Bill, 5) |        11 |                                                 |         |      0+5 = 5 | 5                      |
|                                               |           | transferFrom(Alice, Bill, 5) |  10,124 |            0 | 10                     |

B:

| ایلس ٹرانزیکشن                                | ایلس نانس | بل ٹرانزیکشن                                     | بل نانس | بل کا الاؤنس | ایلس سے بل کی کل آمدنی |
| --------------------------------------------- | --------: | ------------------------------------------------ | ------: | -----------: | ---------------------: |
| approve(Bill, 5)           |        10 |                                                  |         |            5 |                      0 |
| increaseAllowance(Bill, 5) |        11 |                                                  |         |     5+5 = 10 |                      0 |
|                                               |           | transferFrom(Alice, Bill, 10) |  10,124 |            0 |                     10 |

```solidity
    /**
     * @dev کالر کے ذریعہ `spender` کو دیے گئے الاؤنس کو ایٹامک طور پر بڑھاتا ہے۔
     *
     * یہ {approve} کا ایک متبادل ہے جسے {IERC20-approve} میں بیان کردہ مسائل کے
     * ازالے کے طور پر استعمال کیا جا سکتا ہے۔
     *
     * اپ ڈیٹ شدہ الاؤنس کی نشاندہی کرنے والا ایک {Approval} ایونٹ ایمٹ کرتا ہے۔
     *
     * تقاضے:
     *
     * - `spender` صفر ایڈریس نہیں ہو سکتا۔
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
```

`a.add(b)` فنکشن ایک محفوظ اضافہ ہے۔ اس غیر امکانی صورت میں کہ `a`+`b`>=`2^256` یہ اس طرح سے ریپ نہیں ہوتا جس طرح عام اضافہ ہوتا ہے۔

```solidity

    /**
     * @dev کالر کے ذریعہ `spender` کو دیے گئے الاؤنس کو ایٹامک طور پر کم کرتا ہے۔
     *
     * یہ {approve} کا ایک متبادل ہے جسے {IERC20-approve} میں بیان کردہ مسائل کے
     * ازالے کے طور پر استعمال کیا جا سکتا ہے۔
     *
     * اپ ڈیٹ شدہ الاؤنس کی نشاندہی کرنے والا ایک {Approval} ایونٹ ایمٹ کرتا ہے۔
     *
     * تقاضے:
     *
     * - `spender` صفر ایڈریس نہیں ہو سکتا۔
     * - `spender` کے پاس کالر کے لیے کم از کم `subtractedValue` کا الاؤنس ہونا چاہیے۔
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue,
                "ERC20: الاؤنس صفر سے کم ہو گیا"));
        return true;
    }
```

### ٹوکن کی معلومات میں ترمیم کرنے والے فنکشنز {#functions-that-modify-token-information}

یہ وہ چار فنکشنز ہیں جو اصل کام کرتے ہیں: `_transfer`، `_mint`، `_burn`، اور `_approve`۔

#### _transfer فنکشن {#_transfer}

```solidity
    /**
     * @dev `sender` سے `recipient` کو `amount` ٹوکنز منتقل کرتا ہے۔
     *
     * یہ اندرونی فنکشن {transfer} کے برابر ہے، اور اسے
     * مثلاً، خودکار ٹوکن فیس، سلیشنگ میکانزم وغیرہ کو لاگو کرنے کے لیے استعمال کیا جا سکتا ہے۔
     *
     * ایک {Transfer} ایونٹ ایمٹ کرتا ہے۔
     *
     * تقاضے:
     *
     * - `sender` صفر ایڈریس نہیں ہو سکتا۔
     * - `recipient` صفر ایڈریس نہیں ہو سکتا۔
     * - `sender` کے پاس کم از کم `amount` کا بیلنس ہونا چاہیے۔
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
```

یہ فنکشن، `_transfer`، ایک اکاؤنٹ سے دوسرے اکاؤنٹ میں ٹوکنز منتقل کرتا ہے۔ اسے `transfer` (بھیجنے والے کے اپنے اکاؤنٹ سے منتقلی کے لیے) اور `transferFrom` (کسی اور کے اکاؤنٹ سے منتقلی کے لیے الاؤنسز کا استعمال کرتے ہوئے) دونوں کے ذریعے کال کیا جاتا ہے۔

&nbsp;

```solidity
        require(sender != address(0), "ERC20: صفر ایڈریس سے منتقلی");
        require(recipient != address(0), "ERC20: صفر ایڈریس پر منتقلی");
```

Ethereum میں کوئی بھی حقیقت میں صفر ایڈریس کا مالک نہیں ہے (یعنی، کوئی بھی ایسی پرائیویٹ کلید نہیں جانتا جس کی مماثل پبلک کلید کو صفر ایڈریس میں تبدیل کیا گیا ہو)۔ جب لوگ اس ایڈریس کا استعمال کرتے ہیں، تو یہ عام طور پر ایک سافٹ ویئر بگ ہوتا ہے - لہذا اگر صفر ایڈریس بھیجنے والے یا وصول کنندہ کے طور پر استعمال کیا جاتا ہے تو ہم ناکام ہو جاتے ہیں۔

&nbsp;

```solidity
        _beforeTokenTransfer(sender, recipient, amount);

```

اس کنٹریکٹ کو استعمال کرنے کے دو طریقے ہیں:

1. اسے اپنے کوڈ کے لیے بطور ٹیمپلیٹ استعمال کریں
2. [اس سے انہیریٹ کریں](https://www.bitdegree.org/learn/solidity-inheritance)، اور صرف ان فنکشنز کو اوور رائڈ کریں جن میں آپ کو ترمیم کرنے کی ضرورت ہے۔

دوسرا طریقہ بہت بہتر ہے کیونکہ OpenZeppelin ERC-20 کوڈ کا پہلے ہی آڈٹ کیا جا چکا ہے اور اسے محفوظ دکھایا گیا ہے۔ جب آپ انہیریٹنس استعمال کرتے ہیں تو یہ واضح ہوتا ہے کہ آپ کن فنکشنز میں ترمیم کرتے ہیں، اور اپنے کنٹریکٹ پر بھروسہ کرنے کے لیے لوگوں کو صرف ان مخصوص فنکشنز کا آڈٹ کرنے کی ضرورت ہوتی ہے۔

ہر بار جب ٹوکنز ہاتھ بدلتے ہیں تو ایک فنکشن انجام دینا اکثر مفید ہوتا ہے۔ تاہم، `_transfer` ایک بہت اہم فنکشن ہے اور اسے غیر محفوظ طریقے سے لکھنا ممکن ہے (نیچے دیکھیں)، لہذا اسے اوور رائڈ نہ کرنا بہتر ہے۔ اس کا حل `_beforeTokenTransfer` ہے، ایک [ہک فنکشن](https://wikipedia.org/wiki/Hooking)۔ آپ اس فنکشن کو اوور رائڈ کر سکتے ہیں، اور اسے ہر منتقلی پر کال کیا جائے گا۔

&nbsp;

```solidity
        _balances[sender] = _balances[sender].sub(amount, "ERC20: منتقلی کی رقم بیلنس سے زیادہ ہے");
        _balances[recipient] = _balances[recipient].add(amount);
```

یہ وہ لائنیں ہیں جو اصل میں منتقلی کرتی ہیں۔ نوٹ کریں کہ ان کے درمیان **کچھ بھی نہیں** ہے، اور یہ کہ ہم منتقل شدہ رقم کو وصول کنندہ میں شامل کرنے سے پہلے بھیجنے والے سے گھٹاتے ہیں۔ یہ اہم ہے کیونکہ اگر درمیان میں کسی دوسرے کنٹریکٹ کو کال کیا جاتا تو اسے اس کنٹریکٹ کو دھوکہ دینے کے لیے استعمال کیا جا سکتا تھا۔ اس طرح منتقلی ایٹامک ہوتی ہے، اس کے بیچ میں کچھ نہیں ہو سکتا۔

&nbsp;

```solidity
        emit Transfer(sender, recipient, amount);
    }
```

آخر میں، ایک `Transfer` ایونٹ ایمٹ کریں۔ ایونٹس اسمارٹ کنٹریکٹس کے لیے قابل رسائی نہیں ہیں، لیکن بلاک چین کے باہر چلنے والا کوڈ ایونٹس کو سن سکتا ہے اور ان پر رد عمل ظاہر کر سکتا ہے۔ مثال کے طور پر، ایک والیٹ اس بات کا ٹریک رکھ سکتا ہے کہ مالک کو کب مزید ٹوکنز ملتے ہیں۔

#### _mint اور _burn فنکشنز {#_mint-and-_burn}

یہ دو فنکشنز (`_mint` اور `_burn`) ٹوکنز کی کل سپلائی میں ترمیم کرتے ہیں۔
یہ اندرونی ہیں اور اس کنٹریکٹ میں انہیں کال کرنے والا کوئی فنکشن نہیں ہے، لہذا یہ صرف اس صورت میں مفید ہیں جب آپ کنٹریکٹ سے انہیریٹ کریں اور یہ فیصلہ کرنے کے لیے اپنی منطق شامل کریں کہ کن حالات میں نئے ٹوکنز منٹ کیے جائیں یا موجودہ کو برن کیا جائے۔

**نوٹ:** ہر ERC-20 ٹوکن کی اپنی کاروباری منطق ہوتی ہے جو ٹوکن مینجمنٹ کا حکم دیتی ہے۔
مثال کے طور پر، ایک فکسڈ سپلائی کنٹریکٹ کنسٹرکٹر میں صرف `_mint` کو کال کر سکتا ہے اور کبھی بھی `_burn` کو کال نہیں کرتا۔ ایک کنٹریکٹ جو ٹوکن بیچتا ہے وہ ادائیگی ہونے پر `_mint` کو کال کرے گا، اور قیاس ہے کہ کسی وقت `_burn` کو کال کرے گا تاکہ بے قابو افراط زر سے بچا جا سکے۔

```solidity
    /** @dev `amount` ٹوکنز بناتا ہے اور انہیں `account` کو تفویض کرتا ہے، کل سپلائی
     * میں اضافہ کرتا ہے۔
     *
     * ایک {Transfer} ایونٹ ایمٹ کرتا ہے جس میں `from` کو صفر ایڈریس پر سیٹ کیا جاتا ہے۔
     *
     * تقاضے:
     *
     * - `to` صفر ایڈریس نہیں ہو سکتا۔
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: صفر ایڈریس پر منٹ کریں");
        _beforeTokenTransfer(address(0), account, amount);
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
```

جب ٹوکنز کی کل تعداد تبدیل ہو تو `_totalSupply` کو اپ ڈیٹ کرنا یقینی بنائیں۔

&nbsp;

```solidity
    /**
     * @dev `account` سے `amount` ٹوکنز کو تباہ کرتا ہے، کل سپلائی کو
     * کم کرتا ہے۔
     *
     * ایک {Transfer} ایونٹ ایمٹ کرتا ہے جس میں `to` کو صفر ایڈریس پر سیٹ کیا جاتا ہے۔
     *
     * تقاضے:
     *
     * - `account` صفر ایڈریس نہیں ہو سکتا۔
     * - `account` کے پاس کم از کم `amount` ٹوکنز ہونے چاہئیں۔
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: صفر ایڈریس سے برن کریں");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: برن کی رقم بیلنس سے زیادہ ہے");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }
```

`_burn` فنکشن تقریباً `_mint` کی طرح ہے، سوائے اس کے کہ یہ دوسری سمت میں جاتا ہے۔

#### _approve فنکشن {#_approve}

یہ وہ فنکشن ہے جو اصل میں الاؤنسز کی وضاحت کرتا ہے۔ نوٹ کریں کہ یہ مالک کو ایک ایسا الاؤنس بیان کرنے کی اجازت دیتا ہے جو مالک کے موجودہ بیلنس سے زیادہ ہے۔ یہ ٹھیک ہے کیونکہ بیلنس منتقلی کے وقت چیک کیا جاتا ہے، جب یہ الاؤنس بنائے جانے کے وقت کے بیلنس سے مختلف ہو سکتا ہے۔

```solidity
    /**
     * @dev `owner` کے ٹوکنز پر `spender` کے الاؤنس کے طور پر `amount` سیٹ کرتا ہے۔
     *
     * یہ اندرونی فنکشن `approve` کے برابر ہے، اور اسے
     * مثلاً، کچھ سب سسٹمز کے لیے خودکار الاؤنس سیٹ کرنے وغیرہ کے لیے استعمال کیا جا سکتا ہے۔
     *
     * ایک {Approval} ایونٹ ایمٹ کرتا ہے۔
     *
     * تقاضے:
     *
     * - `owner` صفر ایڈریس نہیں ہو سکتا۔
     * - `spender` صفر ایڈریس نہیں ہو سکتا۔
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: صفر ایڈریس سے منظور کریں");
        require(spender != address(0), "ERC20: صفر ایڈریس پر منظور کریں");

        _allowances[owner][spender] = amount;
```

&nbsp;

ایک `Approval` ایونٹ ایمٹ کریں۔ ایپلیکیشن کیسے لکھی جاتی ہے اس پر منحصر ہے، خرچ کرنے والے کنٹریکٹ کو منظوری کے بارے میں یا تو مالک کے ذریعے بتایا جا سکتا ہے یا ایک سرور کے ذریعے جو ان ایونٹس کو سنتا ہے۔

```solidity
        emit Approval(owner, spender, amount);
    }

```

### ڈیسیملز ویری ایبل میں ترمیم کریں {#modify-the-decimals-variable}

```solidity


    /**
     * @dev {decimals} کو 18 کی ڈیفالٹ قدر کے علاوہ کسی اور قدر پر سیٹ کرتا ہے۔
     *
     * انتباہ: اس فنکشن کو صرف کنسٹرکٹر سے کال کیا جانا چاہیے۔ زیادہ تر
     * ایپلیکیشنز جو ٹوکن کنٹریکٹس کے ساتھ تعامل کرتی ہیں وہ توقع نہیں کریں گی کہ
     * {decimals} کبھی تبدیل ہو، اور اگر ایسا ہوتا ہے تو وہ غلط طریقے سے کام کر سکتی ہیں۔
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }
```

یہ فنکشن `_decimals` ویری ایبل میں ترمیم کرتا ہے جو یوزر انٹرفیس کو یہ بتانے کے لیے استعمال ہوتا ہے کہ رقم کی تشریح کیسے کی جائے۔
آپ کو اسے کنسٹرکٹر سے کال کرنا چاہیے۔ اسے کسی بھی بعد کے مقام پر کال کرنا بے ایمانی ہوگی، اور ایپلیکیشنز اسے سنبھالنے کے لیے ڈیزائن نہیں کی گئی ہیں۔

### ہکس {#hooks}

```solidity

    /**
     * @dev ہک جو ٹوکنز کی کسی بھی منتقلی سے پہلے کال کیا جاتا ہے۔ اس میں
     * منٹنگ اور برننگ شامل ہیں۔
     *
     * کالنگ کی شرائط:
     *
     * - جب `from` اور `to` دونوں غیر صفر ہوں، تو `from` کے `amount` ٹوکنز
     * `to` کو منتقل کیے جائیں گے۔
     * - جب `from` صفر ہو، تو `to` کے لیے `amount` ٹوکنز منٹ کیے جائیں گے۔
     * - جب `to` صفر ہو، تو `from` کے `amount` ٹوکنز برن کیے جائیں گے۔
     * - `from` اور `to` کبھی بھی دونوں صفر نہیں ہوتے۔
     *
     * ہکس کے بارے میں مزید جاننے کے لیے، xref:ROOT:extending-contracts.adoc#using-hooks[ہکس کا استعمال] پر جائیں۔
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}
```

یہ منتقلی کے دوران کال کیا جانے والا ہک فنکشن ہے۔ یہ یہاں خالی ہے، لیکن اگر آپ کو اس سے کچھ کروانے کی ضرورت ہے تو آپ اسے صرف اوور رائڈ کرتے ہیں۔

## نتیجہ {#conclusion}

جائزے کے لیے، اس کنٹریکٹ میں کچھ اہم ترین خیالات یہ ہیں (میری رائے میں، آپ کی رائے مختلف ہو سکتی ہے):

- _بلاک چین پر کوئی راز نہیں ہوتے_۔ کوئی بھی معلومات جس تک ایک اسمارٹ کنٹریکٹ رسائی حاصل کر سکتا ہے وہ پوری دنیا کے لیے دستیاب ہے۔
- آپ اپنی ٹرانزیکشنز کی ترتیب کو کنٹرول کر سکتے ہیں، لیکن یہ نہیں کہ دوسرے لوگوں کی ٹرانزیکشن کب ہوتی ہے۔ یہی وجہ ہے کہ الاؤنس تبدیل کرنا خطرناک ہو سکتا ہے، کیونکہ یہ خرچ کرنے والے کو دونوں الاؤنسز کی رقم خرچ کرنے دیتا ہے۔
- `uint256` قسم کی قدریں ریپ ہوتی ہیں۔ دوسرے لفظوں میں، _0-1=2^256-1_۔ اگر یہ مطلوبہ طرز عمل نہیں ہے، تو آپ کو اس کی جانچ کرنی ہوگی (یا SafeMath لائبریری کا استعمال کرنا ہوگا جو آپ کے لیے یہ کرتی ہے)۔ نوٹ کریں کہ یہ [Solidity 0.8.0](https://docs.soliditylang.org/en/breaking/080-breaking-changes.html) میں تبدیل ہو گیا ہے۔
- ایک مخصوص قسم کی تمام اسٹیٹ تبدیلیاں ایک مخصوص جگہ پر کریں، کیونکہ اس سے آڈٹ کرنا آسان ہو جاتا ہے۔
  یہی وجہ ہے کہ ہمارے پاس، مثال کے طور پر، `_approve` ہے، جسے `approve`، `transferFrom`، `increaseAllowance`، اور `decreaseAllowance` کے ذریعے کال کیا جاتا ہے
- اسٹیٹ کی تبدیلیاں ایٹامک ہونی چاہئیں، ان کے درمیان کوئی اور عمل نہیں ہونا چاہیے (جیسا کہ آپ `_transfer` میں دیکھ سکتے ہیں)۔ اس کی وجہ یہ ہے کہ اسٹیٹ کی تبدیلی کے دوران آپ کے پاس ایک غیر مستقل اسٹیٹ ہوتی ہے۔ مثال کے طور پر، جب آپ بھیجنے والے کے بیلنس سے کٹوتی کرتے ہیں اور جب آپ وصول کنندہ کے بیلنس میں اضافہ کرتے ہیں، اس کے درمیان وجود میں کم ٹوکن ہوتے ہیں جتنا ہونا چاہیے۔ اگر ان کے درمیان آپریشنز ہوں، خاص طور پر کسی دوسرے کنٹریکٹ کو کالز ہوں، تو اس کا ممکنہ طور پر غلط استعمال کیا جا سکتا ہے۔

اب جب کہ آپ نے دیکھ لیا ہے کہ OpenZeppelin ERC-20 کنٹریکٹ کیسے لکھا جاتا ہے، اور خاص طور پر اسے کیسے زیادہ محفوظ بنایا جاتا ہے، جائیں اور اپنے محفوظ کنٹریکٹس اور ایپلیکیشنز لکھیں۔

[میرے مزید کام کے لیے یہاں دیکھیں](https://cryptodocguy.pro/)۔
