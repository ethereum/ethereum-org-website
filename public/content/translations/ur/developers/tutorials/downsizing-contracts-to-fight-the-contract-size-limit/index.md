---
title: "کنٹریکٹ سائز کی حد سے نمٹنے کے لیے کنٹریکٹس کو چھوٹا کرنا"
description: آپ اپنے اسمارٹ کنٹریکٹس کو بہت بڑا ہونے سے روکنے کے لیے کیا کر سکتے ہیں؟
author: Markus Waas
lang: ur-in
tags: [ "solidity", "اسمارٹ معاہدات", "اسٹوریج" ]
skill: intermediate
published: 2020-06-26
source: soliditydeveloper.com
sourceUrl: https://soliditydeveloper.com/max-contract-size
---

## ایک حد کیوں ہے؟ {#why-is-there-a-limit}

[22 نومبر، 2016](https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon/) کو Spurious Dragon ہارڈ-فورک نے [EIP-170](https://eips.ethereum.org/EIPS/eip-170) متعارف کرایا جس نے 24.576 kb کی اسمارٹ کنٹریکٹ سائز کی حد شامل کی۔ ایک Solidity ڈویلپر کے طور پر آپ کے لیے اس کا مطلب یہ ہے کہ جب آپ اپنے کنٹریکٹ میں زیادہ سے زیادہ فعالیت شامل کرتے ہیں، تو کسی وقت آپ حد تک پہنچ جائیں گے اور ڈیپلائے کرتے وقت آپ کو یہ خرابی نظر آئے گی:

`انتباہ: کنٹریکٹ کوڈ کا سائز 24576 بائٹس سے زیادہ ہے (ایک حد جو Spurious Dragon میں متعارف کرائی گئی تھی)۔ یہ کنٹریکٹ شاید Mainnet پر ڈیپلائے نہ کیا جا سکے۔ آپٹیمائزر کو فعال کرنے پر غور کریں (کم "رنز" ویلیو کے ساتھ!)، ریورٹ اسٹرنگز کو بند کریں، یا لائبریریوں کا استعمال کریں۔`

یہ حد ڈینائل-آف-سروس (DOS) حملوں کو روکنے کے لیے متعارف کرائی گئی تھی۔ گیس کے لحاظ سے کسی کنٹریکٹ پر کوئی بھی کال نسبتاً سستی ہوتی ہے۔ تاہم، ایتھیریم نوڈز کے لیے کنٹریکٹ کال کا اثر بلائے گئے کنٹریکٹ کوڈ کے سائز کے لحاظ سے غیر متناسب طور پر بڑھ جاتا ہے (ڈسک سے کوڈ پڑھنا، کوڈ کی پری-پروسیسنگ، مرکل پروف میں ڈیٹا شامل کرنا)۔ جب بھی آپ کے پاس ایسی صورتحال ہوتی ہے جہاں حملہ آور کو دوسروں کے لیے بہت زیادہ کام کرنے کے لیے کم وسائل کی ضرورت ہوتی ہے، تو آپ کو DOS حملوں کا امکان ہوتا ہے۔

اصل میں یہ کم مسئلہ تھا کیونکہ ایک قدرتی کنٹریکٹ سائز کی حد بلاک گیس کی حد ہے۔ ظاہر ہے، ایک کنٹریکٹ کو ایک ٹرانزیکشن کے اندر ڈیپلائے کیا جانا چاہیے جس میں کنٹریکٹ کا تمام بائٹ کوڈ موجود ہو۔ اگر آپ صرف اس ایک ٹرانزیکشن کو ایک بلاک میں شامل کرتے ہیں، تو آپ وہ تمام گیس استعمال کر سکتے ہیں، لیکن یہ لامحدود نہیں ہے۔ [London Upgrade](/ethereum-forks/#london) کے بعد سے، بلاک گیس کی حد نیٹ ورک کی طلب کے لحاظ سے 15M اور 30M یونٹس کے درمیان مختلف ہو سکتی ہے۔

ذیل میں ہم ان کے ممکنہ اثرات کے مطابق ترتیب دیے گئے کچھ طریقوں پر غور کریں گے۔ اسے وزن کم کرنے کی اصطلاح میں سوچیں۔ کسی کے لیے اپنے ہدف کے وزن (ہمارے معاملے میں 24kb) تک پہنچنے کے لیے بہترین حکمت عملی یہ ہے کہ پہلے بڑے اثر والے طریقوں پر توجہ دی جائے۔ زیادہ تر معاملات میں صرف اپنی خوراک کو ٹھیک کرنے سے آپ وہاں پہنچ جائیں گے، لیکن بعض اوقات آپ کو تھوڑا اور کرنے کی ضرورت ہوتی ہے۔ پھر آپ کچھ ورزش (درمیانے اثر) یا سپلیمنٹس (چھوٹا اثر) بھی شامل کر سکتے ہیں۔

## بڑا اثر {#big-impact}

### اپنے کنٹریکٹس کو الگ کریں {#separate-your-contracts}

یہ ہمیشہ آپ کا پہلا طریقہ ہونا چاہیے۔ آپ کنٹریکٹ کو متعدد چھوٹے کنٹریکٹس میں کیسے الگ کر سکتے ہیں؟ یہ عام طور پر آپ کو اپنے کنٹریکٹس کے لیے ایک اچھا آرکیٹیکچر تیار کرنے پر مجبور کرتا ہے۔ کوڈ کی پڑھنے کی اہلیت کے نقطہ نظر سے چھوٹے کنٹریکٹس کو ہمیشہ ترجیح دی جاتی ہے۔ کنٹریکٹس کو تقسیم کرنے کے لیے، اپنے آپ سے پوچھیں:

- کون سے فنکشنز ایک ساتھ ہیں؟ فنکشنز کا ہر سیٹ اپنے کنٹریکٹ میں بہترین ہو سکتا ہے۔
- کن فنکشنز کو کنٹریکٹ اسٹیٹ پڑھنے کی ضرورت نہیں ہے یا صرف اسٹیٹ کے ایک مخصوص سب سیٹ کی ضرورت ہے؟
- کیا آپ اسٹوریج اور فعالیت کو تقسیم کر سکتے ہیں؟

### لائبریریاں {#libraries}

فعالیت کے کوڈ کو اسٹوریج سے دور منتقل کرنے کا ایک آسان طریقہ [لائبریری](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#libraries) کا استعمال ہے۔ لائبریری کے فنکشنز کو اندرونی قرار نہ دیں کیونکہ یہ کمپائلیشن کے دوران براہ راست [کنٹریکٹ میں شامل](https://ethereum.stackexchange.com/questions/12975/are-internal-functions-in-libraries-not-covered-by-linking) ہو جائیں گے۔ لیکن اگر آپ پبلک فنکشنز استعمال کرتے ہیں، تو وہ درحقیقت ایک الگ لائبریری کنٹریکٹ میں ہوں گے۔ لائبریریوں کے استعمال کو مزید آسان بنانے کے لیے [using for](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for) پر غور کریں۔

### پراکسیز {#proxies}

ایک مزید جدید حکمت عملی پراکسی سسٹم ہوگی۔ لائبریریاں پس پردہ `DELEGATECALL` کا استعمال کرتی ہیں جو کال کرنے والے کنٹریکٹ کی اسٹیٹ کے ساتھ دوسرے کنٹریکٹ کے فنکشن کو محض انجام دیتی ہیں۔ پراکسی سسٹمز کے بارے میں مزید جاننے کے لیے [یہ بلاگ پوسٹ](https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2) دیکھیں۔ وہ آپ کو مزید فعالیت فراہم کرتے ہیں، مثال کے طور پر، وہ اپ گریڈ کی اہلیت کو فعال کرتے ہیں، لیکن وہ بہت زیادہ پیچیدگی بھی شامل کرتے ہیں۔ میں انہیں صرف کنٹریکٹ کے سائز کو کم کرنے کے لیے شامل نہیں کروں گا جب تک کہ کسی بھی وجہ سے یہ آپ کا واحد آپشن نہ ہو۔

## درمیانہ اثر {#medium-impact}

### فنکشنز کو ہٹائیں {#remove-functions}

یہ تو ظاہر ہونا چاہیے۔ فنکشنز کنٹریکٹ کا سائز کافی حد تک بڑھا دیتے ہیں۔

- **بیرونی**: اکثر ہم سہولت کی وجوہات کی بنا پر بہت سے ویو فنکشنز شامل کرتے ہیں۔ یہ بالکل ٹھیک ہے جب تک کہ آپ سائز کی حد تک نہ پہنچ جائیں۔ پھر آپ کو واقعی ان تمام فنکشنز کو ہٹانے کے بارے میں سوچنا چاہیے سوائے ان کے جو بالکل ضروری ہیں۔
- **اندرونی**: آپ اندرونی/پرائیویٹ فنکشنز کو بھی ہٹا سکتے ہیں اور کوڈ کو سیدھا ان لائن کر سکتے ہیں جب تک کہ فنکشن کو صرف ایک بار کال کیا جائے۔

### اضافی متغیرات سے بچیں {#avoid-additional-variables}

```solidity
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
```

اس طرح کی ایک سادہ سی تبدیلی **0.28kb** کا فرق پیدا کرتی ہے۔ امکان ہے کہ آپ اپنے کنٹریکٹس میں بہت سی ملتی جلتی صورتحال تلاش کر سکتے ہیں اور وہ واقعی ایک بڑی مقدار میں اضافہ کر سکتی ہیں۔

### خرابی کے پیغام کو مختصر کریں {#shorten-error-message}

طویل ریورٹ پیغامات اور خاص طور پر بہت سے مختلف ریورٹ پیغامات کنٹریکٹ کو پھلا سکتے ہیں۔ اس کے بجائے مختصر ایرر کوڈز کا استعمال کریں اور انہیں اپنے کنٹریکٹ میں ڈی کوڈ کریں۔ ایک لمبا پیغام بہت چھوٹا ہو سکتا ہے:

```solidity
require(msg.sender == owner, "اس فنکشن کو صرف اس کنٹریکٹ کا مالک کال کر سکتا ہے");
```

```solidity
require(msg.sender == owner, "OW1");
```

### خرابی کے پیغامات کے بجائے کسٹم ایررز کا استعمال کریں

کسٹم ایررز [Solidity 0.8.4](https://blog.soliditylang.org/2021/04/21/custom-errors/) میں متعارف کرائے گئے ہیں۔ وہ آپ کے کنٹریکٹس کا سائز کم کرنے کا ایک بہترین طریقہ ہیں، کیونکہ وہ ABI-انکوڈڈ سلیکٹرز کے طور پر ہوتے ہیں (جیسے فنکشنز ہوتے ہیں)۔

```solidity
error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
```

### آپٹیمائزر میں کم رن ویلیو پر غور کریں {#consider-a-low-run-value-in-the-optimizer}

آپ آپٹیمائزر کی سیٹنگز کو بھی تبدیل کر سکتے ہیں۔ 200 کی ڈیفالٹ ویلیو کا مطلب ہے کہ یہ بائٹ کوڈ کو اس طرح آپٹیمائز کرنے کی کوشش کر رہا ہے جیسے کسی فنکشن کو 200 بار کال کیا گیا ہو۔ اگر آپ اسے 1 میں تبدیل کرتے ہیں، تو آپ بنیادی طور پر آپٹیمائزر کو ہر فنکشن کو صرف ایک بار چلانے کے معاملے کے لیے آپٹیمائز کرنے کے لیے کہتے ہیں۔ صرف ایک بار چلنے کے لیے ایک آپٹمائزڈ فنکشن کا مطلب ہے کہ یہ خود ڈیپلائمنٹ کے لیے آپٹمائزڈ ہے۔ آگاہ رہیں کہ **اس سے فنکشنز کو چلانے کے لیے [گیس کے اخراجات](/developers/docs/gas/) بڑھ جاتے ہیں**، اس لیے ہو سکتا ہے کہ آپ ایسا نہ کرنا چاہیں۔

## چھوٹا اثر {#small-impact}

### فنکشنز میں اسٹرکٹس کو پاس کرنے سے گریز کریں {#avoid-passing-structs-to-functions}

اگر آپ [ABIEncoderV2](https://solidity.readthedocs.io/en/v0.6.10/layout-of-source-files.html#abiencoderv2) استعمال کر رہے ہیں، تو یہ کسی فنکشن میں اسٹرکٹس کو پاس نہ کرنے میں مدد کر سکتا ہے۔ پیرامیٹر کو بطور اسٹرکٹ پاس کرنے کے بجائے، مطلوبہ پیرامیٹرز کو براہ راست پاس کریں۔ اس مثال میں ہم نے مزید **0.1kb** بچائے۔

```solidity
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
```

### فنکشنز اور متغیرات کے لیے درست مرئیت کا اعلان کریں {#declare-correct-visibility-for-functions-and-variables}

- فنکشنز یا متغیرات جو صرف باہر سے کال کیے جاتے ہیں؟ انہیں `public` کی بجائے `external` کے طور پر اعلان کریں۔
- فنکشنز یا متغیرات جو صرف کنٹریکٹ کے اندر سے کال کیے جاتے ہیں؟ انہیں `public` کی بجائے `private` یا `internal` کے طور پر اعلان کریں۔

### موڈیفائرز کو ہٹائیں {#remove-modifiers}

موڈیفائرز، خاص طور پر جب بہت زیادہ استعمال کیے جائیں، کنٹریکٹ کے سائز پر اہم اثر ڈال سکتے ہیں۔ انہیں ہٹانے اور اس کے بجائے فنکشنز استعمال کرنے پر غور کریں۔

```solidity
modifier checkStuff() {}

function doSomething() checkStuff {}
```

```solidity
function checkStuff() private {}

function doSomething() { checkStuff(); }
```

یہ ٹپس آپ کو کنٹریکٹ کا سائز نمایاں طور پر کم کرنے میں مدد کریں گی۔ ایک بار پھر، میں اس بات پر کافی زور نہیں دے سکتا، سب سے بڑے اثر کے لیے اگر ممکن ہو تو ہمیشہ کنٹریکٹس کو تقسیم کرنے پر توجہ دیں۔
