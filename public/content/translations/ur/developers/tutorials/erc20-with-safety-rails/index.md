---
title: حفاظتی ریلز کے ساتھ ERC-20
description: لوگوں کو معمولی غلطیوں سے بچنے میں مدد کرنے کا طریقہ
author: اوری پومیرانٹز
lang: ur-in
tags: [ "erc-20" ]
skill: beginner
published: 2022-08-15
---

## تعارف {#introduction}

ایتھیریم کی سب سے بڑی خوبیوں میں سے ایک یہ ہے کہ کوئی مرکزی اتھارٹی نہیں ہے جو آپ کے ٹرانزیکشنز میں ترمیم کر سکے یا انہیں کالعدم کر سکے۔ ایتھیریم کے ساتھ ایک بڑا مسئلہ یہ ہے کہ کوئی ایسی مرکزی اتھارٹی نہیں ہے جس کے پاس صارف کی غلطیوں یا غیر قانونی ٹرانزیکشنز کو کالعدم کرنے کا اختیار ہو۔ اس مضمون میں آپ ان کچھ عام غلطیوں کے بارے میں جانیں گے جو صارفین [ERC-20](/developers/docs/standards/tokens/erc-20/) ٹوکنز کے ساتھ کرتے ہیں، اور ساتھ ہی یہ بھی جانیں گے کہ ایسے ERC-20 کنٹریکٹس کیسے بنائے جائیں جو صارفین کو ان غلطیوں سے بچنے میں مدد کریں، یا جو کسی مرکزی اتھارٹی کو کچھ اختیارات دیں (مثال کے طور پر اکاؤنٹس کو منجمد کرنے کا اختیار)۔

نوٹ کریں کہ جب کہ ہم [OpenZeppelin ERC-20 ٹوکن کنٹریکٹ](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) کا استعمال کریں گے، یہ مضمون اس کی بہت زیادہ تفصیل سے وضاحت نہیں کرتا ہے۔ آپ یہ معلومات [یہاں](/developers/tutorials/erc20-annotated-code) حاصل کر سکتے ہیں۔

اگر آپ مکمل سورس کوڈ دیکھنا چاہتے ہیں:

1. [Remix IDE](https://remix.ethereum.org/) کھولیں۔
2. گٹ ہب کلون آئیکن (![گٹ ہب کلون آئیکن](icon-clone.png)) پر کلک کریں۔
3. گٹ ہب ریپوزٹری `https://github.com/qbzzt/20220815-erc20-safety-rails` کو کلون کریں۔
4. **contracts > erc20-safety-rails.sol** کھولیں۔

## ایک ERC-20 کنٹریکٹ بنانا {#creating-an-erc-20-contract}

حفاظتی ریل کی فعالیت شامل کرنے سے پہلے ہمیں ایک ERC-20 کنٹریکٹ کی ضرورت ہے۔ اس مضمون میں ہم [اوپن زیپلن کنٹریکٹس وزرڈ](https://docs.openzeppelin.com/contracts/5.x/wizard) کا استعمال کریں گے۔ اسے دوسرے براؤزر میں کھولیں اور ان ہدایات پر عمل کریں:

1. **ERC20** منتخب کریں۔

2. یہ سیٹنگز درج کریں:

   | پیرامیٹر        | قدر              |
   | --------------- | ---------------- |
   | نام             | SafetyRailsToken |
   | علامت           | SAFE             |
   | Premint         | 1000             |
   | خصوصیات         | کوئی نہیں        |
   | رسائی کنٹرول    | Ownable          |
   | اپ گریڈ ایبلیٹی | کوئی نہیں        |

3. اوپر اسکرول کریں اور (Remix کے لیے) **ری مکس میں کھولیں** پر کلک کریں یا ایک مختلف ماحول استعمال کرنے کے لیے **ڈاؤن لوڈ** کریں۔ میں یہ فرض کروں گا کہ آپ ری مکس استعمال کر رہے ہیں، اگر آپ کچھ اور استعمال کرتے ہیں تو بس مناسب تبدیلیاں کریں۔

4. اب ہمارے پاس ایک مکمل طور پر فعال ERC-20 کنٹریکٹ ہے۔ امپورٹڈ کوڈ دیکھنے کے لیے آپ `.deps` > `npm` کو بڑھا سکتے ہیں۔

5. کنٹریکٹ کو کمپائل کریں، ڈیپلائے کریں، اور اس کے ساتھ کھیلیں یہ دیکھنے کے لیے کہ یہ ایک ERC-20 کنٹریکٹ کے طور پر کام کرتا ہے۔ اگر آپ کو ریمکس استعمال کرنے کا طریقہ سیکھنے کی ضرورت ہے، [تو اس ٹیوٹوریل کا استعمال کریں](https://remix.ethereum.org/?#activate=udapp,solidity,LearnEth)۔

## عام غلطیاں {#common-mistakes}

### غلطیاں {#the-mistakes}

صارفین کبھی کبھی غلط ایڈریس پر ٹوکن بھیج دیتے ہیں۔ جبکہ ہم ان کے ذہنوں کو پڑھ کر یہ نہیں جان سکتے کہ وہ کیا کرنا چاہتے تھے، غلطی کی دو قسمیں ہیں جو بہت زیادہ ہوتی ہیں اور جن کا پتہ لگانا آسان ہے:

1. کنٹریکٹ کے اپنے ایڈریس پر ٹوکن بھیجنا۔ مثال کے طور پر، [Optimism کا OP ٹوکن](https://optimism.mirror.xyz/qvd0WfuLKnePm1Gxb9dpGchPf5uDz5NSMEFdgirDS4c) دو ماہ سے بھی کم عرصے میں [120,000 سے زیادہ](https://optimism.blockscout.com/address/0x4200000000000000000000000000000000000042) OP ٹوکن جمع کرنے میں کامیاب رہا۔ یہ دولت کی ایک اہم مقدار کی نمائندگی کرتا ہے جسے غالباً لوگوں نے کھو دیا ہے۔

2. ٹوکن کو ایک خالی ایڈریس پر بھیجنا، ایک ایسا ایڈریس جو [بیرونی ملکیت والے اکاؤنٹ](/developers/docs/accounts/#externally-owned-accounts-and-key-pairs) یا [اسمارٹ کنٹریکٹ](/developers/docs/smart-contracts) سے مطابقت نہیں رکھتا۔ اگرچہ میرے پاس اس بات کے اعداد و شمار نہیں ہیں کہ ایسا کتنی بار ہوتا ہے، [ایک واقعے میں 20,000,000 ٹوکنز کا نقصان ہو سکتا تھا](https://gov.optimism.io/t/message-to-optimism-community-from-wintermute/2595)۔

### ٹرانسفرز کو روکنا {#preventing-transfers}

OpenZeppelin ERC-20 کنٹریکٹ میں [ایک ہُک، `_beforeTokenTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L364-L368) شامل ہے، جسے ٹوکن کی منتقلی سے پہلے کال کیا جاتا ہے۔ ڈیفالٹ کے طور پر یہ ہُک کچھ نہیں کرتا، لیکن ہم اس پر اپنی فعالیت کو لٹکا سکتے ہیں، جیسے چیکس جو کوئی مسئلہ ہونے پر واپس ہو جاتے ہیں۔

ہُک استعمال کرنے کے لیے، کنسٹرکٹر کے بعد یہ فنکشن شامل کریں:

```solidity
    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal virtual
        override(ERC20)
    {
        super._beforeTokenTransfer(from, to, amount);
    }
```

اس فنکشن کے کچھ حصے نئے ہو سکتے ہیں اگر آپ Solidity سے بہت زیادہ واقف نہیں ہیں:

```solidity
        internal virtual
```

ورچوئل `virtual` کلیدی لفظ کا مطلب ہے کہ جس طرح ہم نے `ERC20` سے فعالیت وراثت میں حاصل کی اور اس فنکشن کو اوور رائیڈ کیا، اسی طرح دوسرے کنٹریکٹس ہم سے وراثت میں لے سکتے ہیں اور اس فنکشن کو اوور رائیڈ کر سکتے ہیں۔

```solidity
        override(ERC20)
```

ہمیں واضح طور پر یہ بتانا ہوگا کہ ہم `_beforeTokenTransfer` کی ERC20 ٹوکن تعریف کو [اوور رائیڈ](https://docs.soliditylang.org/en/v0.8.15/contracts.html#function-overriding) کر رہے ہیں۔ عام طور پر، سیکورٹی کے نقطہ نظر سے، واضح تعریفیں مضمر تعریفوں سے بہت بہتر ہیں - آپ یہ نہیں بھول سکتے کہ آپ نے کچھ کیا ہے اگر وہ آپ کے سامنے ہے۔ یہی وجہ ہے کہ ہمیں یہ بتانے کی ضرورت ہے کہ ہم کس سپر کلاس کے `_beforeTokenTransfer` کو اوور رائیڈ کر رہے ہیں۔

```solidity
        super._beforeTokenTransfer(from, to, amount);
```

یہ لائن اس کنٹریکٹ یا کنٹریکٹس کے `_beforeTokenTransfer` فنکشن کو کال کرتی ہے جس سے ہم نے وراثت میں حاصل کیا ہے جس میں یہ ہے۔ اس معاملے میں، وہ صرف `ERC20` ہے، `Ownable` میں یہ ہُک نہیں ہے۔ اگرچہ فی الحال `ERC20._beforeTokenTransfer` کچھ نہیں کرتا، ہم اسے اس صورت میں کال کرتے ہیں کہ مستقبل میں فعالیت شامل کی جائے (اور پھر ہم کنٹریکٹ کو دوبارہ ڈیپلائے کرنے کا فیصلہ کرتے ہیں، کیونکہ کنٹریکٹس ڈیپلائیمنٹ کے بعد تبدیل نہیں ہوتے)۔

### ضروریات کی کوڈنگ {#coding-the-requirements}

ہم فنکشن میں یہ ضروریات شامل کرنا چاہتے ہیں:

- ایڈریس `to` `address(this)` کے برابر نہیں ہو سکتا، جو کہ خود ERC-20 کنٹریکٹ کا ایڈریس ہے۔
- ایڈریس `to` خالی نہیں ہو سکتا، اسے یا تو ہونا چاہیے:
  - ایک بیرونی ملکیت والا اکاؤنٹ (EOA)۔ ہم براہ راست یہ نہیں جانچ سکتے کہ کوئی ایڈریس EOA ہے یا نہیں، لیکن ہم کسی ایڈریس کا ETH بیلنس چیک کر سکتے ہیں۔ EOAs کا تقریباً ہمیشہ ایک بیلنس ہوتا ہے، چاہے وہ اب استعمال نہ ہو رہے ہوں - انہیں آخری wei تک صاف کرنا مشکل ہے۔
  - ایک اسمارٹ کنٹریکٹ۔ یہ جانچنا کہ آیا کوئی ایڈریس ایک اسمارٹ کنٹریکٹ ہے، تھوڑا مشکل ہے۔ ایک آپ کوڈ ہے جو بیرونی کوڈ کی لمبائی کو چیک کرتا ہے، جسے [`EXTCODESIZE`](https://www.evm.codes/#3b) کہتے ہیں، لیکن یہ Solidity میں براہ راست دستیاب نہیں ہے۔ اس کے لیے ہمیں [Yul](https://docs.soliditylang.org/en/v0.8.15/yul.html) کا استعمال کرنا ہوگا، جو کہ EVM اسمبلی ہے۔ کچھ اور قدریں ہیں جنہیں ہم Solidity سے استعمال کر سکتے ہیں ([`<address>.code` اور `<address>.codehash`](https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#members-of-address-types))، لیکن ان کی لاگت زیادہ ہے۔

آئیے نئے کوڈ کو لائن بہ لائن دیکھتے ہیں:

```solidity
        require(to != address(this), "کنٹریکٹ ایڈریس پر ٹوکن نہیں بھیج سکتے");
```

یہ پہلی ضرورت ہے، جانچیں کہ `to` اور `this(address)` ایک ہی چیز نہیں ہیں۔

```solidity
        bool isToContract;
        assembly {
           isToContract := gt(extcodesize(to), 0)
        }
```

اس طرح ہم جانچتے ہیں کہ کوئی ایڈریس کنٹریکٹ ہے یا نہیں۔ ہم Yul سے براہ راست آؤٹ پٹ حاصل نہیں کر سکتے، اس لیے اس کے بجائے ہم نتیجہ رکھنے کے لیے ایک متغیر کی وضاحت کرتے ہیں (اس معاملے میں `isToContract`)۔ Yul اس طرح کام کرتا ہے کہ ہر آپ کوڈ کو ایک فنکشن سمجھا جاتا ہے۔ تو پہلے ہم کنٹریکٹ کا سائز حاصل کرنے کے لیے [`EXTCODESIZE`](https://www.evm.codes/#3b) کو کال کرتے ہیں، اور پھر [`GT`](https://www.evm.codes/#11) کا استعمال کرتے ہوئے یہ جانچتے ہیں کہ یہ صفر نہیں ہے (ہم غیر دستخط شدہ انٹیجرز کے ساتھ کام کر رہے ہیں، اس لیے یقیناً یہ منفی نہیں ہو سکتا)۔ پھر ہم نتیجہ `isToContract` میں لکھتے ہیں۔

```solidity
        require(to.balance != 0 || isToContract, "خالی ایڈریس پر ٹوکن نہیں بھیج سکتے");
```

اور آخر میں، ہمارے پاس خالی ایڈریسز کے لیے اصل جانچ ہے۔

## انتظامی رسائی {#admin-access}

کبھی کبھی ایک ایڈمنسٹریٹر کا ہونا مفید ہوتا ہے جو غلطیوں کو کالعدم کر سکے۔ غلط استعمال کے امکانات کو کم کرنے کے لیے، یہ ایڈمنسٹریٹر ایک [ملٹی سگ](https://blog.logrocket.com/security-choices-multi-signature-wallets/) ہو سکتا ہے تاکہ متعدد لوگوں کو کسی کارروائی پر متفق ہونا پڑے۔ اس مضمون میں ہمارے پاس دو انتظامی خصوصیات ہوں گی:

1. اکاؤنٹس کو منجمد اور غیر منجمد کرنا۔ یہ مفید ہو سکتا ہے، مثال کے طور پر، جب کسی اکاؤنٹ سے سمجھوتہ کیا گیا ہو۔
2. اثاثوں کی صفائی۔

   کبھی کبھی دھوکہ باز قانونی حیثیت حاصل کرنے کے لیے حقیقی ٹوکن کے کنٹریکٹ پر جعلی ٹوکن بھیجتے ہیں۔ مثال کے طور پر، [یہاں دیکھیں](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe?tab=holders)۔ جائز ERC-20 کنٹریکٹ [0x4200....0042](https://optimism.blockscout.com/token/0x4200000000000000000000000000000000000042) ہے۔ اسکیم جو اس کا دکھاوا کرتی ہے وہ [0x234....bbe](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe) ہے۔

   یہ بھی ممکن ہے کہ لوگ غلطی سے ہمارے کنٹریکٹ میں جائز ERC-20 ٹوکن بھیج دیں، جو انہیں باہر نکالنے کا ایک طریقہ رکھنے کی ایک اور وجہ ہے۔

OpenZeppelin انتظامی رسائی کو فعال کرنے کے لیے دو میکانزم فراہم کرتا ہے:

- [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/access-control#ownership-and-ownable) کنٹریکٹس کا ایک ہی مالک ہوتا ہے۔ وہ فنکشنز جن میں `onlyOwner` [موڈیفائر](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm) ہوتا ہے، انہیں صرف وہی مالک کال کر سکتا ہے۔ مالکان ملکیت کسی اور کو منتقل کر سکتے ہیں یا اسے مکمل طور پر ترک کر سکتے ہیں۔ دیگر تمام اکاؤنٹس کے حقوق عام طور پر یکساں ہوتے ہیں۔
- [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/access-control#role-based-access-control) کنٹریکٹس میں [کردار پر مبنی رسائی کنٹرول (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control) ہوتا ہے۔

سادگی کی خاطر، اس مضمون میں ہم `Ownable` کا استعمال کرتے ہیں۔

### کنٹریکٹس کو منجمد اور غیر منجمد کرنا {#freezing-and-thawing-contracts}

کنٹریکٹس کو منجمد اور غیر منجمد کرنے کے لیے کئی تبدیلیوں کی ضرورت ہوتی ہے:

- ایڈریسز سے [بولینز](https://en.wikipedia.org/wiki/Boolean_data_type) تک ایک [میپنگ](https://www.tutorialspoint.com/solidity/solidity_mappings.htm) یہ ٹریک رکھنے کے لیے کہ کون سے ایڈریسز منجمد ہیں۔ تمام قدریں ابتدائی طور پر صفر ہوتی ہیں، جس کی بولین قدروں کے لیے غلط تشریح کی جاتی ہے۔ یہ وہی ہے جو ہم چاہتے ہیں کیونکہ ڈیفالٹ کے طور پر اکاؤنٹس منجمد نہیں ہوتے ہیں۔

  ```solidity
      mapping(address => bool) public frozenAccounts;
  ```

- [ایونٹس](https://www.tutorialspoint.com/solidity/solidity_events.htm) کسی بھی دلچسپی رکھنے والے کو مطلع کرنے کے لیے جب کوئی اکاؤنٹ منجمد یا غیر منجمد کیا جاتا ہے۔ تکنیکی طور پر ان کارروائیوں کے لیے ایونٹس کی ضرورت نہیں ہے، لیکن یہ آف چین کوڈ کو ان ایونٹس کو سننے اور یہ جاننے میں مدد کرتا ہے کہ کیا ہو رہا ہے۔ جب کوئی ایسی چیز ہوتی ہے جو کسی اور سے متعلق ہو سکتی ہے تو اسمارٹ کنٹریکٹ کے لیے انہیں خارج کرنا اچھے آداب سمجھے جاتے ہیں۔

  ایونٹس انڈیکسڈ ہیں اس لیے ان تمام اوقات کو تلاش کرنا ممکن ہو گا جب کوئی اکاؤنٹ منجمد یا غیر منجمد کیا گیا ہو۔

  ```solidity
    // جب اکاؤنٹس منجمد یا غیر منجمد کیے جاتے ہیں
    event AccountFrozen(address indexed _addr);
    event AccountThawed(address indexed _addr);
  ```

- اکاؤنٹس کو منجمد اور غیر منجمد کرنے کے لیے فنکشنز۔ یہ دونوں فنکشنز تقریباً ایک جیسے ہیں، اس لیے ہم صرف فریز فنکشن پر غور کریں گے۔

  ```solidity
      function freezeAccount(address addr)
        public
        onlyOwner
  ```

  [`public`](https://www.tutorialspoint.com/solidity/solidity_contracts.htm) سے نشان زد فنکشنز کو دوسرے اسمارٹ کنٹریکٹس سے یا براہ راست ٹرانزیکشن کے ذریعے کال کیا جا سکتا ہے۔

  ```solidity
    {
        require(!frozenAccounts[addr], "اکاؤنٹ پہلے ہی منجمد ہے");
        frozenAccounts[addr] = true;
        emit AccountFrozen(addr);
    }  // freezeAccount
  ```

  اگر اکاؤنٹ پہلے سے ہی منجمد ہے، تو واپس جائیں۔ ورنہ، اسے منجمد کریں اور ایک ایونٹ `emit` کریں۔

- منجمد اکاؤنٹ سے رقم کی منتقلی کو روکنے کے لیے `_beforeTokenTransfer` کو تبدیل کریں۔ نوٹ کریں کہ منجمد اکاؤنٹ میں اب بھی رقم منتقل کی جا سکتی ہے۔

  ```solidity
       require(!frozenAccounts[from], "اکاؤنٹ منجمد ہے");
  ```

### اثاثوں کی صفائی {#asset-cleanup}

اس کنٹریکٹ کے ذریعے رکھے گئے ERC-20 ٹوکنز کو جاری کرنے کے لیے ہمیں اس ٹوکن کنٹریکٹ پر ایک فنکشن کال کرنے کی ضرورت ہے جس سے وہ تعلق رکھتے ہیں، یا تو [`transfer`](https://eips.ethereum.org/EIPS/eip-20#transfer) یا [`approve`](https://eips.ethereum.org/EIPS/eip-20#approve)۔ اس معاملے میں الاؤنسز پر گیس ضائع کرنے کا کوئی فائدہ نہیں، ہم براہ راست بھی منتقل کر سکتے ہیں۔

```solidity
    function cleanupERC20(
        address erc20,
        address dest
    )
        public
        onlyOwner
    {
        IERC20 token = IERC20(erc20);
```

جب ہم ایڈریس وصول کرتے ہیں تو یہ ایک کنٹریکٹ کے لیے آبجیکٹ بنانے کا نحو ہے۔ ہم ایسا کر سکتے ہیں کیونکہ ہمارے پاس سورس کوڈ کے حصے کے طور پر ERC20 ٹوکنز کی تعریف ہے (لائن 4 دیکھیں)، اور اس فائل میں [IERC20 کی تعریف](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) شامل ہے، جو ایک OpenZeppelin ERC-20 کنٹریکٹ کے لیے انٹرفیس ہے۔

```solidity
        uint balance = token.balanceOf(address(this));
        token.transfer(dest, balance);
    }
```

یہ ایک کلین اپ فنکشن ہے، اس لیے قیاس ہے کہ ہم کوئی ٹوکن نہیں چھوڑنا چاہتے۔ صارف سے دستی طور پر بیلنس حاصل کرنے کے بجائے، ہم اس عمل کو خودکار بھی بنا سکتے ہیں۔

## نتیجہ {#conclusion}

یہ ایک کامل حل نہیں ہے - "صارف نے غلطی کی" کے مسئلے کا کوئی کامل حل نہیں ہے۔ تاہم، اس قسم کی جانچ کا استعمال کم از کم کچھ غلطیوں کو روک سکتا ہے۔ اکاؤنٹس کو منجمد کرنے کی صلاحیت، اگرچہ خطرناک ہے، لیکن ہیکر کو چوری شدہ فنڈز سے انکار کرکے کچھ ہیکس کے نقصان کو محدود کرنے کے لیے استعمال کی جا سکتی ہے۔

[میرے مزید کام کے لیے یہاں دیکھیں](https://cryptodocguy.pro/)۔
