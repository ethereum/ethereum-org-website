---
title: آف لائن ڈیٹا کی سالمیت کے لیے مرکل پروفس
description: ایسے ڈیٹا کے لیے آن چین ڈیٹا کی سالمیت کو یقینی بنانا جو زیادہ تر آف چین اسٹور کیا جاتا ہے
author: اوری پومیرانٹز
tags: [ "اسٹوریج" ]
skill: advanced
lang: ur-in
published: 2021-12-30
---

## تعارف {#introduction}

مثالی طور پر ہم ہر چیز کو Ethereum اسٹوریج میں اسٹور کرنا چاہیں گے، جو ہزاروں کمپیوٹرز میں اسٹور ہوتا ہے اور اس میں
انتہائی زیادہ دستیابی (ڈیٹا کو سنسر نہیں کیا جا سکتا) اور سالمیت (ڈیٹا کو غیر مجاز طریقے سے تبدیل نہیں کیا جا سکتا) ہوتی ہے، لیکن 32-بائٹ ورڈ کو اسٹور کرنے پر عام طور پر 20,000 گیس خرچ ہوتی ہے۔ جب میں یہ لکھ رہا ہوں، تو یہ لاگت $6.60 کے برابر ہے۔ 21 سینٹ فی بائٹ پر یہ بہت سے استعمالات کے لیے بہت مہنگا ہے۔

اس مسئلے کو حل کرنے کے لیے Ethereum ایکو سسٹم نے [ڈیٹا کو وکندریقرت طریقے سے اسٹور کرنے کے بہت سے متبادل طریقے](/developers/docs/storage/) تیار کیے ہیں۔ عام طور پر ان میں دستیابی اور قیمت کے درمیان ایک سمجھوتہ شامل ہوتا ہے۔ تاہم، سالمیت کو عام طور پر یقینی بنایا جاتا ہے۔

اس مضمون میں آپ سیکھیں گے کہ [مرکل پروفس](https://computersciencewiki.org/index.php/Merkle_proof) کا استعمال کرتے ہوئے، بلاک چین پر ڈیٹا اسٹور کیے بغیر ڈیٹا کی سالمیت کو **کیسے** یقینی بنایا جائے۔

## یہ کیسے کام کرتا ہے؟ {#how-does-it-work}

نظریاتی طور پر ہم صرف ڈیٹا کا ہیش آن چین اسٹور کر سکتے ہیں، اور تمام ڈیٹا کو ان ٹرانزیکشنز میں بھیج سکتے ہیں جن میں اس کی ضرورت ہوتی ہے۔ تاہم، یہ اب بھی بہت مہنگا ہے۔ ایک ٹرانزیکشن میں ایک بائٹ ڈیٹا کی لاگت تقریباً 16 گیس ہوتی ہے، جو فی الحال تقریباً آدھا سینٹ، یا تقریباً 5 ڈالر فی کلو بائٹ ہے۔ 5000 ڈالر فی میگا بائٹ پر، یہ بہت سے استعمالات کے لیے اب بھی بہت مہنگا ہے، یہاں تک کہ ڈیٹا کو ہیش کرنے کی اضافی لاگت کے بغیر بھی۔

اس کا حل یہ ہے کہ ڈیٹا کے مختلف سب سیٹس کو بار بار ہیش کیا جائے، تاکہ جس ڈیٹا کو آپ کو بھیجنے کی ضرورت نہیں ہے اس کے لیے آپ صرف ایک ہیش بھیج سکیں۔ آپ یہ ایک مرکل ٹری کا استعمال کرتے ہوئے کرتے ہیں، جو ایک ٹری ڈیٹا اسٹرکچر ہے جہاں ہر نوڈ اس کے نیچے موجود نوڈس کا ہیش ہوتا ہے:

![مرکل ٹری](tree.png)

روٹ ہیش واحد حصہ ہے جسے آن چین اسٹور کرنے کی ضرورت ہے۔ ایک خاص قدر کو ثابت کرنے کے لیے، آپ وہ تمام ہیش فراہم کرتے ہیں جنہیں روٹ حاصل کرنے کے لیے اس کے ساتھ ملانے کی ضرورت ہوتی ہے۔ مثال کے طور پر، `C` کو ثابت کرنے کے لیے آپ `D`، `H(A-B)`، اور `H(E-H)` فراہم کرتے ہیں۔

![C کی قدر کا ثبوت](proof-c.png)

## عمل درآمد {#implementation}

[نمونہ کوڈ یہاں فراہم کیا گیا ہے](https://github.com/qbzzt/merkle-proofs-for-offline-data-integrity)۔

### آف چین کوڈ {#offchain-code}

اس مضمون میں ہم آف چین حسابات کے لیے JavaScript کا استعمال کرتے ہیں۔ زیادہ تر وکندریقرت ایپلی کیشنز کا آف چین جزو JavaScript میں ہوتا ہے۔

#### مرکل روٹ بنانا {#creating-the-merkle-root}

سب سے پہلے ہمیں چین کو مرکل روٹ فراہم کرنے کی ضرورت ہے۔

```javascript
const ethers = require("ethers")
```

[ہم ethers پیکیج سے ہیش فنکشن کا استعمال کرتے ہیں](https://docs.ethers.io/v5/api/utils/hashing/#utils-keccak256)۔

```javascript
// وہ خام ڈیٹا جس کی سالمیت کی ہمیں تصدیق کرنی ہے۔ پہلے دو بائٹس
// ایک صارف کی شناخت ہیں، اور آخری دو بائٹس اس صارف کے پاس موجود ٹوکنز کی
// مقدار ہیں۔
const dataArray = [
  0x0bad0010, 0x60a70020, 0xbeef0030, 0xdead0040, 0xca110050, 0x0e660060,
  0xface0070, 0xbad00080, 0x060d0091,
]
```

ہر اندراج کو ایک 256-بٹ انٹیجر میں انکوڈ کرنے سے، مثال کے طور پر JSON استعمال کرنے کے مقابلے میں، کم پڑھنے کے قابل کوڈ بنتا ہے۔ تاہم، اس کا مطلب ہے کہ کنٹریکٹ میں ڈیٹا کو بازیافت کرنے کے لیے کافی کم پروسیسنگ کی ضرورت ہوتی ہے، اس لیے گیس کی لاگت بہت کم ہوتی ہے۔ [آپ آن چین پر JSON پڑھ سکتے ہیں](https://github.com/chrisdotn/jsmnSol)، لیکن اگر اس سے بچا جا سکے تو یہ ایک برا خیال ہے۔

```javascript
// ہیش ویلیوز کا ایرے، بطور BigInts
const hashArray = dataArray
```

اس معاملے میں ہمارا ڈیٹا شروع میں 256-بٹ ویلیوز ہے، اس لیے کسی پروسیسنگ کی ضرورت نہیں ہے۔ اگر ہم زیادہ پیچیدہ ڈیٹا اسٹرکچر، جیسے کہ اسٹرنگز، استعمال کرتے ہیں، تو ہمیں یہ یقینی بنانا ہوگا کہ ہم ہیشز کا ایک ایرے حاصل کرنے کے لیے پہلے ڈیٹا کو ہیش کریں۔ نوٹ کریں کہ یہ اس لیے بھی ہے کہ ہمیں اس بات کی پرواہ نہیں ہے کہ آیا صارفین دوسرے صارفین کی معلومات جانتے ہیں۔ بصورت دیگر ہمیں ہیش کرنا پڑتا تاکہ صارف 1 کو صارف 0 کی قدر معلوم نہ ہو، صارف 2 کو صارف 3 کی قدر معلوم نہ ہو، وغیرہ۔

```javascript
// ہیش فنکشن جس اسٹرنگ کی توقع کرتا ہے اور جو BigInt
// ہم ہر جگہ استعمال کرتے ہیں، ان کے درمیان تبدیل کریں۔
const hash = (x) =>
  BigInt(ethers.utils.keccak256("0x" + x.toString(16).padStart(64, 0)))
```

ethers ہیش فنکشن ایک ہیکساڈیسیمل نمبر کے ساتھ ایک JavaScript اسٹرنگ حاصل کرنے کی توقع رکھتا ہے، جیسے `0x60A7`، اور اسی ساخت کے ساتھ ایک اور اسٹرنگ کے ساتھ جواب دیتا ہے۔ تاہم، باقی کوڈ کے لیے `BigInt` کا استعمال کرنا آسان ہے، اس لیے ہم ایک ہیکساڈیسیمل اسٹرنگ میں تبدیل کرتے ہیں اور پھر واپس۔

```javascript
// ایک جوڑے کا سیمیٹریکل ہیش تاکہ ہمیں پرواہ نہ ہو کہ ترتیب الٹ دی گئی ہے۔
const pairHash = (a, b) => hash(hash(a) ^ hash(b))
```

یہ فنکشن سیمیٹریکل ہے (a [xor](https://en.wikipedia.org/wiki/Exclusive_or) b کا ہیش)۔ اس کا مطلب ہے کہ جب ہم مرکل پروف کی جانچ کرتے ہیں تو ہمیں اس بارے میں فکر کرنے کی ضرورت نہیں ہے کہ پروف سے حاصل کردہ قدر کو حسابی قدر سے پہلے رکھنا ہے یا بعد میں۔ مرکل پروف کی جانچ آن چین کی جاتی ہے، لہذا ہمیں وہاں جتنا کم کام کرنے کی ضرورت ہوگی، اتنا ہی بہتر ہے۔

انتباہ:
کرپٹوگرافی جتنی نظر آتی ہے اس سے زیادہ مشکل ہے۔
اس مضمون کے ابتدائی ورژن میں ہیش فنکشن `hash(a^b)` تھا۔
یہ ایک **برا** خیال تھا کیونکہ اس کا مطلب یہ تھا کہ اگر آپ کو `a` اور `b` کی جائز قدریں معلوم ہوتیں تو آپ کسی بھی مطلوبہ `a'` قدر کو ثابت کرنے کے لیے `b' = a^b^a'` کا استعمال کر سکتے تھے۔
اس فنکشن کے ساتھ آپ کو `b'` کا حساب لگانا ہوگا تاکہ `hash(a') ^ hash(b')` ایک معلوم قدر (روٹ کے راستے پر اگلی شاخ) کے برابر ہو، جو کہ بہت زیادہ مشکل ہے۔

```javascript
// یہ قدر یہ ظاہر کرنے کے لیے کہ ایک خاص شاخ خالی ہے، اس میں
// کوئی قدر نہیں ہے
const empty = 0n
```

جب قدروں کی تعداد دو کی انٹیجر پاور نہیں ہوتی ہے تو ہمیں خالی شاخوں کو ہینڈل کرنے کی ضرورت ہوتی ہے۔ یہ پروگرام جس طرح سے یہ کرتا ہے وہ یہ ہے کہ صفر کو ایک پلیس ہولڈر کے طور پر رکھتا ہے۔

![غائب شاخوں کے ساتھ مرکل ٹری](merkle-empty-hash.png)

```javascript
// ایک ہیش ایرے کے ٹری میں ایک لیول اوپر کا حساب لگائیں، ہر جوڑے کا
// ترتیب سے ہیش لے کر
const oneLevelUp = (inputArray) => {
  var result = []
  var inp = [...inputArray] // ان پٹ پر اوور رائٹنگ سے بچنے کے لیے // اگر ضروری ہو تو ایک خالی قدر شامل کریں (ہمیں تمام لیوز کو // جوڑا بنانے کی ضرورت ہے)

  if (inp.length % 2 === 1) inp.push(empty)

  for (var i = 0; i < inp.length; i += 2)
    result.push(pairHash(inp[i], inp[i + 1]))

  return result
} // oneLevelUp
```

یہ فنکشن موجودہ لیئر پر قدروں کے جوڑوں کو ہیش کرکے مرکل ٹری میں ایک لیول "اوپر چڑھتا" ہے۔ نوٹ کریں کہ یہ سب سے موثر عمل درآمد نہیں ہے، ہم ان پٹ کو کاپی کرنے سے بچ سکتے تھے اور لوپ میں مناسب ہونے پر صرف `hashEmpty` شامل کر سکتے تھے، لیکن یہ کوڈ پڑھنے کی اہلیت کے لیے بہتر بنایا گیا ہے۔

```javascript
const getMerkleRoot = (inputArray) => {
  var result

  result = [...inputArray] // ٹری پر اس وقت تک چڑھیں جب تک کہ صرف ایک قدر نہ رہ جائے، جو کہ // روٹ ہے۔ // // اگر کسی لیئر میں اندراجات کی تعداد طاق ہے تو // oneLevelUp میں موجود کوڈ ایک خالی قدر شامل کرتا ہے، لہذا اگر ہمارے پاس، مثال کے طور پر، // 10 لیوز ہیں تو ہمارے پاس دوسری لیئر میں 5 شاخیں، تیسری میں 3 // شاخیں، چوتھی میں 2 ہوں گی اور روٹ پانچواں ہے

  while (result.length > 1) result = oneLevelUp(result)

  return result[0]
}
```

روٹ حاصل کرنے کے لیے، اس وقت تک چڑھیں جب تک کہ صرف ایک قدر باقی نہ رہ جائے۔

#### مرکل پروف بنانا {#creating-a-merkle-proof}

مرکل پروف وہ قدریں ہیں جنہیں ثابت کی جانے والی قدر کے ساتھ ہیش کرکے مرکل روٹ واپس حاصل کیا جاتا ہے۔ ثابت کرنے کی قدر اکثر دوسرے ڈیٹا سے دستیاب ہوتی ہے، اس لیے میں اسے کوڈ کے حصے کے طور پر فراہم کرنے کے بجائے الگ سے فراہم کرنا پسند کرتا ہوں۔

```javascript
// مرکل پروف ان اندراجات کی فہرست کی قدر پر مشتمل ہوتا ہے جن کے ساتھ
// ہیش کرنا ہے۔ چونکہ ہم ایک سیمیٹریکل ہیش فنکشن استعمال کرتے ہیں، ہمیں
// پروف کی تصدیق کے لیے آئٹم کے مقام کی ضرورت نہیں ہے، صرف اسے بنانے کے لیے
const getMerkleProof = (inputArray, n) => {
    var result = [], currentLayer = [...inputArray], currentN = n

    // جب تک ہم سب سے اوپر نہ پہنچ جائیں
    while (currentLayer.length > 1) {
        // کوئی طاق لمبائی کی لیئرز نہیں
        if (currentLayer.length % 2)
            currentLayer.push(empty)

        result.push(currentN % 2
               // اگر currentN طاق ہے، تو اس سے پہلے کی قدر کے ساتھ پروف میں شامل کریں
            ? currentLayer[currentN-1]
               // اگر یہ جفت ہے، تو اس کے بعد کی قدر شامل کریں
            : currentLayer[currentN+1])

```

ہم `(v[0],v[1])`، `(v[2],v[3])`، وغیرہ کو ہیش کرتے ہیں۔ لہذا جفت قدروں کے لیے ہمیں اگلی قدر کی ضرورت ہے، اور طاق قدروں کے لیے پچھلی قدر کی۔

```javascript
        // اگلی لیئر پر جائیں
        currentN = Math.floor(currentN/2)
        currentLayer = oneLevelUp(currentLayer)
    }   // جبکہ currentLayer.length > 1

    return result
}   // getMerkleProof
```

### آن چین کوڈ {#onchain-code}

آخر میں ہمارے پاس وہ کوڈ ہے جو پروف کی جانچ کرتا ہے۔ آن چین کوڈ [Solidity](https://docs.soliditylang.org/en/v0.8.11/) میں لکھا گیا ہے۔ یہاں آپٹیمائزیشن بہت زیادہ اہم ہے کیونکہ گیس نسبتاً مہنگی ہے۔

```solidity
//SPDX-License-Identifier: Public Domain
pragma solidity ^0.8.0;

import "hardhat/console.sol";
```

میں نے یہ [Hardhat ڈیولپمنٹ انوائرمنٹ](https://hardhat.org/) کا استعمال کرتے ہوئے لکھا ہے، جو ہمیں ڈیولپمنٹ کے دوران [Solidity سے کنسول آؤٹ پٹ](https://hardhat.org/docs/cookbook/debug-logs) حاصل کرنے کی اجازت دیتا ہے۔

```solidity

contract MerkleProof {
    uint merkleRoot;

    function getRoot() public view returns (uint) {
      return merkleRoot;
    }

    // انتہائی غیر محفوظ، پروڈکشن کوڈ میں اس فنکشن
    // تک رسائی کو سختی سے محدود کیا جانا چاہیے، شاید کسی
    // مالک تک
    function setRoot(uint _merkleRoot) external {
      merkleRoot = _merkleRoot;
    }   // setRoot
```

مرکل روٹ کے لیے سیٹ اور گیٹ فنکشنز۔ پروڈکشن سسٹم میں ہر کسی کو مرکل روٹ کو اپ ڈیٹ کرنے کی اجازت دینا ایک _انتہائی برا خیال_ ہے۔ میں یہاں نمونہ کوڈ کی سادگی کی خاطر ایسا کرتا ہوں۔ **اسے ایسے سسٹم پر نہ کریں جہاں ڈیٹا کی سالمیت واقعی اہمیت رکھتی ہو**۔

```solidity
    function hash(uint _a) internal pure returns(uint) {
      return uint(keccak256(abi.encode(_a)));
    }

    function pairHash(uint _a, uint _b) internal pure returns(uint) {
      return hash(hash(_a) ^ hash(_b));
    }
```

یہ فنکشن ایک جوڑے کا ہیش بناتا ہے۔ یہ `hash` اور `pairHash` کے لیے JavaScript کوڈ کا صرف Solidity ترجمہ ہے۔

**نوٹ:** یہ پڑھنے کی اہلیت کے لیے آپٹیمائزیشن کا ایک اور معاملہ ہے۔ [فنکشن کی تعریف](https://www.tutorialspoint.com/solidity/solidity_cryptographic_functions.htm) کی بنیاد پر، ڈیٹا کو [`bytes32`](https://docs.soliditylang.org/en/v0.5.3/types.html#fixed-size-byte-arrays) قدر کے طور پر اسٹور کرنا اور تبادلوں سے بچنا ممکن ہو سکتا ہے۔

```solidity
    // مرکل پروف کی تصدیق کریں
    function verifyProof(uint _value, uint[] calldata _proof)
        public view returns (bool) {
      uint temp = _value;
      uint i;

      for(i=0; i<_proof.length; i++) {
        temp = pairHash(temp, _proof[i]);
      }

      return temp == merkleRoot;
    }

}  // MarkleProof
```

ریاضیاتی اشارے میں مرکل پروف کی تصدیق اس طرح نظر آتی ہے: `H(proof_n, H(proof_n-1, H(proof_n-2, ...` H(proof_1, H(proof_0, value))...)))\`۔ یہ کوڈ اسے نافذ کرتا ہے۔

## مرکل پروفس اور رول اپس آپس میں نہیں ملتے {#merkle-proofs-and-rollups}

مرکل پروفس [رول اپس](/developers/docs/scaling/#rollups) کے ساتھ اچھی طرح کام نہیں کرتے ہیں۔ اس کی وجہ یہ ہے کہ رول اپس تمام ٹرانزیکشن ڈیٹا L1 پر لکھتے ہیں، لیکن L2 پر پروسیس کرتے ہیں۔ ایک ٹرانزیکشن کے ساتھ مرکل پروف بھیجنے کی لاگت اوسطاً 638 گیس فی لیئر ہے (فی الحال کال ڈیٹا میں ایک بائٹ کی لاگت 16 گیس ہے اگر یہ صفر نہیں ہے، اور 4 ہے اگر یہ صفر ہے)۔ اگر ہمارے پاس 1024 الفاظ کا ڈیٹا ہے، تو مرکل پروف کے لیے دس لیئرز، یا کل 6380 گیس کی ضرورت ہوتی ہے۔

مثال کے طور پر [Optimism](https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m) کو دیکھیں، L1 گیس لکھنے پر تقریباً 100 gwei اور L2 گیس پر 0.001 gwei لاگت آتی ہے (یہ عام قیمت ہے، یہ بھیڑ کے ساتھ بڑھ سکتی ہے)۔ لہذا ایک L1 گیس کی لاگت پر ہم L2 پروسیسنگ پر ایک لاکھ گیس خرچ کر سکتے ہیں۔ یہ فرض کرتے ہوئے کہ ہم اسٹوریج کو اوور رائٹ نہیں کرتے ہیں، اس کا مطلب ہے کہ ہم ایک L1 گیس کی قیمت پر L2 پر اسٹوریج میں تقریباً پانچ الفاظ لکھ سکتے ہیں۔ ایک مرکل پروف کے لیے ہم پورے 1024 الفاظ اسٹوریج میں لکھ سکتے ہیں (یہ فرض کرتے ہوئے کہ انہیں شروع میں آن چین کیلکولیٹ کیا جا سکتا ہے، بجائے اس کے کہ ٹرانزیکشن میں فراہم کیا جائے) اور پھر بھی زیادہ تر گیس بچی رہے گی۔

## نتیجہ {#conclusion}

حقیقی زندگی میں آپ شاید کبھی بھی خود سے مرکل ٹریز کو نافذ نہیں کریں گے۔ ایسی معروف اور آڈٹ شدہ لائبریریاں ہیں جنہیں آپ استعمال کر سکتے ہیں اور عام طور پر یہ بہتر ہے کہ آپ خود کرپٹوگرافک پرائمیٹیوز کو نافذ نہ کریں۔ لیکن مجھے امید ہے کہ اب آپ مرکل پروفس کو بہتر طور پر سمجھتے ہیں اور یہ فیصلہ کر سکتے ہیں کہ انہیں کب استعمال کرنا چاہیے۔

نوٹ کریں کہ جب مرکل پروفس _سالمیت_ کو محفوظ رکھتے ہیں، وہ _دستیابی_ کو محفوظ نہیں رکھتے ہیں۔ یہ جاننا کہ کوئی اور آپ کے اثاثے نہیں لے سکتا، یہ چھوٹی سی تسلی ہے اگر ڈیٹا اسٹوریج رسائی کو مسترد کرنے کا فیصلہ کرتا ہے اور آپ ان تک رسائی کے لیے مرکل ٹری بھی نہیں بنا سکتے ہیں۔ لہذا مرکل ٹریز کو کسی قسم کے وکندریقرت اسٹوریج، جیسے IPFS کے ساتھ بہترین طریقے سے استعمال کیا جاتا ہے۔

[میرے مزید کام کے لیے یہاں دیکھیں](https://cryptodocguy.pro/)۔
