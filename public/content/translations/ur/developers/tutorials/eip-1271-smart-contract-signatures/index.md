---
title: "EIP-1271: اسمارٹ کنٹریکٹ دستخط پر دستخط کرنا اور ان کی توثیق کرنا"
description: EIP-1271 کے ساتھ اسمارٹ کنٹریکٹ دستخط کی تخلیق اور توثیق کا ایک جائزہ۔ ہم اسمارٹ کنٹریکٹ ڈیولپرز کے لیے ایک ٹھوس مثال فراہم کرنے کے لیے Safe (پہلے Gnosis Safe) میں استعمال ہونے والے EIP-1271 نفاذ کا بھی جائزہ لیتے ہیں۔
author: Nathan H. Leung
lang: ur-in
tags: [ "eip-1271", "اسمارٹ معاہدات", "توثیق", "دستخط" ]
skill: intermediate
published: 2023-01-12
---

[EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) معیار اسمارٹ کنٹریکٹس کو دستخطوں کی توثیق کرنے کی اجازت دیتا ہے۔

اس ٹیوٹوریل میں، ہم ڈیجیٹل دستخطوں، EIP-1271 کے پس منظر، اور [Safe](https://safe.global/) (پہلے Gnosis Safe) کے ذریعے استعمال ہونے والے EIP-1271 کے مخصوص نفاذ کا ایک جائزہ دیتے ہیں۔ مجموعی طور پر، یہ آپ کے اپنے کنٹریکٹس میں EIP-1271 کو نافذ کرنے کے لیے ایک نقطہ آغاز کے طور پر کام کر سکتا ہے۔

## دستخط کیا ہے؟

اس تناظر میں، ایک دستخط (زیادہ واضح طور پر، ایک "ڈیجیٹل دستخط") ایک پیغام ہے جس کے ساتھ کسی قسم کا ثبوت ہوتا ہے کہ پیغام کسی مخصوص شخص/بھیجنے والے/ایڈریس سے آیا ہے۔

مثال کے طور پر، ایک ڈیجیٹل دستخط اس طرح نظر آ سکتا ہے:

1. پیغام: "میں اپنے Ethereum والیٹ کے ساتھ اس ویب سائٹ پر لاگ ان کرنا چاہتا ہوں۔"
2. دستخط کنندہ: میرا ایڈریس `0x000…` ہے
3. ثبوت: یہاں کچھ ثبوت ہے کہ میں نے، `0x000…`، درحقیقت یہ پورا پیغام بنایا ہے (یہ عام طور پر کوئی کرپٹوگرافک چیز ہوتی ہے)۔

یہ نوٹ کرنا ضروری ہے کہ ڈیجیٹل دستخط میں "پیغام" اور "دستخط" دونوں شامل ہیں۔

کیوں؟ مثال کے طور پر، اگر آپ نے مجھے دستخط کرنے کے لیے ایک کنٹریکٹ دیا، اور پھر میں نے دستخط کا صفحہ کاٹ کر باقی کنٹریکٹ کے بغیر صرف اپنے دستخط آپ کو واپس کر دیے، تو کنٹریکٹ درست نہیں ہوگا۔

اسی طرح، ایک ڈیجیٹل دستخط کا متعلقہ پیغام کے بغیر کوئی مطلب نہیں ہے!

## EIP-1271 کیوں موجود ہے؟

Ethereum پر مبنی بلاک چینز پر استعمال کے لیے ڈیجیٹل دستخط بنانے کے لیے، آپ کو عام طور پر ایک خفیہ پرائیویٹ کلید کی ضرورت ہوتی ہے جسے کوئی اور نہیں جانتا۔ یہی چیز آپ کے دستخط کو آپ کا بناتی ہے (خفیہ کلید کے علم کے بغیر کوئی اور وہی دستخط نہیں بنا سکتا)۔

آپ کے Ethereum اکاؤنٹ (یعنی، آپ کا بیرونی ملکیت والا اکاؤنٹ/EOA) کے ساتھ ایک پرائیویٹ کلید منسلک ہے، اور یہ وہ پرائیویٹ کلید ہے جو عام طور پر اس وقت استعمال ہوتی ہے جب کوئی ویب سائٹ یا ڈیپ آپ سے دستخط مانگتی ہے (مثال کے طور پر، "Ethereum کے ساتھ لاگ ان کریں" کے لیے)۔

ایک ایپ آپ کے بنائے ہوئے [دستخط کی توثیق](https://www.alchemy.com/docs/how-to-verify-a-message-signature-on-ethereum) ethers.js جیسی تھرڈ پارٹی لائبریری کا استعمال کرتے ہوئے [آپ کی پرائیویٹ کلید کو جانے بغیر](https://en.wikipedia.org/wiki/Public-key_cryptography) کر سکتی ہے اور اس بات پر یقین رکھ سکتی ہے کہ دستخط _آپ_ نے ہی بنایا تھا۔

> درحقیقت، چونکہ EOA ڈیجیٹل دستخط پبلک-کی کرپٹوگرافی کا استعمال کرتے ہیں، انہیں **آف چین** بنایا اور توثیق کیا جا سکتا ہے! گیس لیس DAO ووٹنگ اسی طرح کام کرتی ہے - آن چین ووٹ جمع کروانے کے بجائے، کرپٹوگرافک لائبریریوں کا استعمال کرتے ہوئے ڈیجیٹل دستخط آف چین بنائے اور ان کی توثیق کی جا سکتی ہے۔

جبکہ EOA اکاؤنٹس میں ایک پرائیویٹ کلید ہوتی ہے، اسمارٹ کنٹریکٹ اکاؤنٹس میں کسی بھی قسم کی پرائیویٹ یا خفیہ کلید نہیں ہوتی ہے (لہذا "Ethereum کے ساتھ لاگ ان کریں"، وغیرہ مقامی طور پر اسمارٹ کنٹریکٹ اکاؤنٹس کے ساتھ کام نہیں کر سکتے)۔

EIP-1271 جس مسئلے کو حل کرنا چاہتا ہے وہ یہ ہے: ہم کیسے بتا سکتے ہیں کہ اسمارٹ کنٹریکٹ کا دستخط درست ہے اگر اسمارٹ کنٹریکٹ میں کوئی "راز" نہیں ہے جسے وہ دستخط میں شامل کر سکے؟

## EIP-1271 کیسے کام کرتا ہے؟

اسمارٹ کنٹریکٹس میں پرائیویٹ کلیدیں نہیں ہوتیں جن کا استعمال پیغامات پر دستخط کرنے کے لیے کیا جا سکے۔ تو ہم کیسے بتا سکتے ہیں کہ دستخط اصلی ہے؟

ٹھیک ہے، ایک خیال یہ ہے کہ ہم صرف اسمارٹ کنٹریکٹ سے _پوچھ_ سکتے ہیں کہ کیا دستخط اصلی ہے!

EIP-1271 جو کرتا ہے وہ یہ ہے کہ یہ اس خیال کو معیاری بناتا ہے کہ کسی اسمارٹ کنٹریکٹ سے "پوچھا جائے" کہ آیا دیا گیا دستخط درست ہے۔

EIP-1271 کو نافذ کرنے والے کنٹریکٹ میں `isValidSignature` نامی ایک فنکشن ہونا چاہیے جو ایک پیغام اور ایک دستخط لیتا ہے۔ کنٹریکٹ پھر کچھ توثیقی منطق چلا سکتا ہے (اسپیک یہاں کسی خاص چیز کو نافذ نہیں کرتا) اور پھر ایک قدر واپس کرتا ہے جو یہ بتاتا ہے کہ دستخط درست ہے یا نہیں۔

اگر `isValidSignature` ایک درست نتیجہ واپس کرتا ہے، تو یہ تقریباً کنٹریکٹ کے یہ کہنے کے مترادف ہے کہ "ہاں، میں اس دستخط + پیغام کو منظور کرتا ہوں!"

### انٹرفیس

یہاں EIP-1271 اسپیک میں عین مطابق انٹرفیس ہے (ہم ذیل میں `_hash` پیرامیٹر کے بارے میں بات کریں گے، لیکن ابھی کے لیے، اسے وہ پیغام سمجھیں جس کی توثیق کی جا رہی ہے):

```jsx
pragma solidity ^0.5.0;

contract ERC1271 {

  // bytes4(keccak256("isValidSignature(bytes32,bytes)")
  bytes4 constant internal MAGICVALUE = 0x1626ba7e;

  /**
   * @dev یہ واپس کرنا چاہئے کہ آیا فراہم کردہ دستخط فراہم کردہ ہیش کے لئے درست ہے
   * @param _hash      دستخط کیے جانے والے ڈیٹا کا ہیش
   * @param _signature _hash سے وابستہ دستخط بائٹ ارے
   *
   * فنکشن کے پاس ہونے پر بائٹس4 میجک ویلیو 0x1626ba7e واپس کرنا لازمی ہے۔
   * اسٹیٹ میں ترمیم نہیں کرنی چاہئے (solc < 0.5 کے لیے STATICCALL کا استعمال کرتے ہوئے، solc > 0.5 کے لیے ویو موڈیفائر)
   * بیرونی کالز کی اجازت ہونی چاہئے
   */
  function isValidSignature(
    bytes32 _hash,
    bytes memory _signature)
    public
    view
    returns (bytes4 magicValue);
}
```

## مثال EIP-1271 نفاذ: Safe

کنٹریکٹس `isValidSignature` کو کئی طریقوں سے نافذ کر سکتے ہیں — اسپیک صرف عین مطابق نفاذ کے بارے میں زیادہ کچھ نہیں کہتا ہے۔

ایک قابل ذکر کنٹریکٹ جو EIP-1271 کو نافذ کرتا ہے وہ Safe ہے (پہلے Gnosis Safe)۔

Safe کے کوڈ میں، `isValidSignature` کو [نافذ کیا گیا ہے](https://github.com/safe-global/safe-contracts/blob/main/contracts/handler/CompatibilityFallbackHandler.sol) تاکہ دستخطوں کو [دو طریقوں سے](https://ethereum.stackexchange.com/questions/122635/signing-messages-as-a-gnosis-safe-eip1271-support) بنایا اور توثیق کیا جا سکے:

1. آن چین پیغامات
   1. تخلیق: ایک سیف مالک پیغام پر "دستخط" کرنے کے لیے ایک نیا سیف ٹرانزیکشن بناتا ہے، پیغام کو ٹرانزیکشن میں ڈیٹا کے طور پر منتقل کرتا ہے۔ ایک بار جب کافی مالکان ملٹی سگ تھریشولڈ تک پہنچنے کے لیے ٹرانزیکشن پر دستخط کر دیتے ہیں، تو ٹرانزیکشن کو براڈکاسٹ کیا جاتا ہے اور چلایا جاتا ہے۔ ٹرانزیکشن میں، ایک سیف فنکشن ہے جسے (`signMessage(bytes calldata _data)`) کہا جاتا ہے جو پیغام کو "منظور شدہ" پیغامات کی فہرست میں شامل کرتا ہے۔
   2. توثیق: Safe کنٹریکٹ پر `isValidSignature` کو کال کریں، اور توثیق کرنے کے لیے پیغام کو پیغام پیرامیٹر کے طور پر اور [دستخط پیرامیٹر کے لیے ایک خالی قدر](https://github.com/safe-global/safe-contracts/blob/main/contracts/handler/CompatibilityFallbackHandler.sol#L32) (یعنی `0x`) منتقل کریں۔ Safe دیکھے گا کہ دستخط پیرامیٹر خالی ہے اور دستخط کی کرپٹوگرافک طور پر توثیق کرنے کے بجائے، یہ جان لے گا کہ آگے بڑھ کر یہ چیک کرنا ہے کہ آیا پیغام "منظور شدہ" پیغامات کی فہرست میں ہے یا نہیں۔
2. آف چین پیغامات:
   1. تخلیق: ایک سیف مالک آف چین ایک پیغام بناتا ہے، پھر دوسرے سیف مالکان سے انفرادی طور پر پیغام پر دستخط کرواتا ہے جب تک کہ ملٹی سگ منظوری کی حد کو عبور کرنے کے لیے کافی دستخط نہ ہو جائیں۔
   2. توثیق: `isValidSignature` کو کال کریں۔ پیغام پیرامیٹر میں، توثیق کیے جانے والے پیغام کو منتقل کریں۔ دستخط پیرامیٹر میں، ہر سیف مالک کے انفرادی دستخطوں کو ایک ساتھ جوڑ کر، آگے پیچھے منتقل کریں۔ Safe یہ چیک کرے گا کہ حد کو پورا کرنے کے لیے کافی دستخط ہیں **اور** یہ کہ ہر دستخط درست ہے۔ اگر ایسا ہے تو، یہ ایک قدر واپس کرے گا جو دستخط کی کامیاب توثیق کی نشاندہی کرتا ہے۔

## `_hash` پیرامیٹر بالکل کیا ہے؟ پورا پیغام کیوں نہیں منتقل کرتے؟

آپ نے شاید دیکھا ہوگا کہ [EIP-1271 انٹرفیس](https://eips.ethereum.org/EIPS/eip-1271) میں `isValidSignature` فنکشن خود پیغام نہیں لیتا، بلکہ اس کے بجائے ایک `_hash` پیرامیٹر لیتا ہے۔ اس کا مطلب یہ ہے کہ `isValidSignature` میں پورا صوابدیدی لمبائی کا پیغام منتقل کرنے کے بجائے، ہم اس کے بجائے پیغام کا 32-بائٹ ہیش (عام طور پر keccak256) منتقل کرتے ہیں۔

کال ڈیٹا کا ہر بائٹ — یعنی، اسمارٹ کنٹریکٹ فنکشن میں منتقل کیا گیا فنکشن پیرامیٹر ڈیٹا — کی [لاگت 16 گیس (4 گیس اگر صفر بائٹ ہے)](https://eips.ethereum.org/EIPS/eip-2028) ہوتی ہے، لہذا اگر پیغام لمبا ہو تو یہ بہت زیادہ گیس بچا سکتا ہے۔

### پچھلی EIP-1271 تفصیلات

عام استعمال میں EIP-1271 کی ایسی تفصیلات ہیں جن میں `isValidSignature` فنکشن ہے جس کا پہلا پیرامیٹر `bytes` قسم کا (صوابدیدی لمبائی، بجائے مقررہ لمبائی `bytes32` کے) اور پیرامیٹر کا نام `message` ہے۔ یہ EIP-1271 معیار کا ایک [پرانا ورژن](https://github.com/safe-global/safe-contracts/issues/391#issuecomment-1075427206) ہے۔

## میرے اپنے کنٹریکٹس میں EIP-1271 کو کیسے نافذ کیا جانا چاہئے؟

اسپیک یہاں بہت کھلا ہے۔ Safe نفاذ میں کچھ اچھے خیالات ہیں:

- آپ کنٹریکٹ کے "مالک" کے EOA دستخطوں کو درست سمجھ سکتے ہیں۔
- آپ منظور شدہ پیغامات کی ایک فہرست محفوظ کر سکتے ہیں اور صرف انہیں ہی درست سمجھ سکتے ہیں۔

آخر میں، یہ کنٹریکٹ ڈیولپر کے طور پر آپ پر منحصر ہے!

## نتیجہ

[EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) ایک ہمہ جہت معیار ہے جو اسمارٹ کنٹریکٹس کو دستخطوں کی توثیق کرنے کی اجازت دیتا ہے۔ یہ اسمارٹ کنٹریکٹس کے لیے EOAs کی طرح زیادہ کام کرنے کا دروازہ کھولتا ہے — مثال کے طور پر "Ethereum کے ساتھ لاگ ان کریں" کو اسمارٹ کنٹریکٹس کے ساتھ کام کرنے کا ایک طریقہ فراہم کرتا ہے — اور اسے کئی طریقوں سے نافذ کیا جا سکتا ہے (Safe کا ایک غیر معمولی، دلچسپ نفاذ قابل غور ہے)۔
