---
title: "یلو پیپر کے EVM کی تفصیلات کو سمجھنا"
description: "یلو پیپر کے اس حصے کو سمجھنا، جو Ethereum کے لیے رسمی تفصیلات ہے، اور جو Ethereum ورچوئل مشین (EVM) کی وضاحت کرتا ہے۔"
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: ur-in
published: 2022-05-15
---

[یلو پیپر](https://ethereum.github.io/yellowpaper/paper.pdf) Ethereum کے لیے رسمی تفصیل ہے۔ سوائے ان جگہوں کے جہاں [EIP کے عمل](/eips/) کے ذریعے ترمیم کی گئی ہے، اس میں ہر چیز کے کام کرنے کے طریقے کی صحیح تفصیل موجود ہے۔ اسے ایک ریاضیاتی مقالے کے طور پر لکھا گیا ہے، جس میں ایسی اصطلاحات شامل ہیں جن سے پروگرامرز واقف نہیں ہو سکتے ہیں۔ اس مقالے میں آپ اسے پڑھنا سیکھتے ہیں، اور اس کے نتیجے میں دیگر متعلقہ ریاضیاتی مقالے بھی پڑھنا سیکھتے ہیں۔

## کون سا یلو پیپر؟ {#which-yellow-paper}

Ethereum میں تقریباً ہر دوسری چیز کی طرح، یلو پیپر بھی وقت کے ساتھ ساتھ تیار ہوتا ہے۔ ایک مخصوص ورژن کا حوالہ دینے کے قابل ہونے کے لیے، میں نے [لکھتے وقت کا موجودہ ورژن](yellow-paper-berlin.pdf) اپ لوڈ کیا ہے۔ میں جو سیکشن، صفحہ، اور مساوات کے نمبر استعمال کرتا ہوں وہ اسی ورژن کا حوالہ دیں گے۔ اس دستاویز کو پڑھتے وقت اسے ایک الگ ونڈو میں کھلا رکھنا ایک اچھا خیال ہے۔

### EVM کیوں؟ {#why-the-evm}

اصل یلو پیپر Ethereum کی ترقی کے بالکل آغاز میں لکھا گیا تھا۔ یہ اصل پروف آف ورک پر مبنی اتفاق رائے کے طریقہ کار کو بیان کرتا ہے جو اصل میں نیٹ ورک کو محفوظ بنانے کے لیے استعمال کیا گیا تھا۔ تاہم، Ethereum نے پروف آف ورک کو بند کر دیا اور ستمبر 2022 میں پروف آف اسٹیک پر مبنی اتفاق رائے کا استعمال شروع کر دیا۔ یہ ٹیوٹوریل یلو پیپر کے ان حصوں پر توجہ مرکوز کرے گا جو Ethereum ورچوئل مشین کی وضاحت کرتے ہیں۔ پروف آف اسٹیک میں منتقلی سے EVM میں کوئی تبدیلی نہیں ہوئی (سوائے DIFFICULTY آپ کوڈ کی واپسی کی قدر کے)۔

## 9 ایگزیکیوشن ماڈل {#9-execution-model}

اس سیکشن (صفحہ 12-14) میں EVM کی زیادہ تر تعریف شامل ہے۔

اصطلاح _سسٹم اسٹیٹ_ میں وہ سب کچھ شامل ہے جو آپ کو سسٹم کو چلانے کے لیے جاننے کی ضرورت ہے۔ ایک عام کمپیوٹر میں، اس کا مطلب ہے میموری، رجسٹرز کا مواد وغیرہ۔

ایک [Turing machine](https://en.wikipedia.org/wiki/Turing_machine) ایک کمپیوٹیشنل ماڈل ہے۔ بنیادی طور پر، یہ کمپیوٹر کا ایک آسان ورژن ہے، جس کے بارے میں یہ ثابت ہے کہ اس میں وہی کمپیوٹیشن چلانے کی صلاحیت ہے جو ایک عام کمپیوٹر کر سکتا ہے (ہر وہ چیز جو ایک کمپیوٹر کیلکولیٹ کر سکتا ہے، ایک ٹورنگ مشین بھی کیلکولیٹ کر سکتی ہے اور اس کے برعکس)۔ یہ ماڈل اس بارے میں مختلف نظریات کو ثابت کرنا آسان بناتا ہے کہ کیا کمپیوٹ ایبل ہے اور کیا نہیں۔

اصطلاح [Turing-complete](https://en.wikipedia.org/wiki/Turing_completeness) کا مطلب ایک ایسا کمپیوٹر ہے جو ٹورنگ مشین جیسی کیلکولیشنز چلا سکتا ہے۔ ٹورنگ مشینیں لامحدود لوپس میں جا سکتی ہیں، اور EVM نہیں جا سکتا کیونکہ اس کی گیس ختم ہو جائے گی، اس لیے یہ صرف نیم-ٹورنگ-کملپیٹ ہے۔

## 9.1 بنیادی باتیں {#91-basics}

یہ سیکشن EVM کی بنیادی باتیں بتاتا ہے اور یہ کہ یہ دوسرے کمپیوٹیشنل ماڈلز کے ساتھ کیسے موازنہ کرتا ہے۔

ایک [stack machine](https://en.wikipedia.org/wiki/Stack_machine) ایک ایسا کمپیوٹر ہے جو درمیانی ڈیٹا کو رجسٹرز میں نہیں، بلکہ ایک [**stack**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)) میں اسٹور کرتا ہے۔ یہ ورچوئل مشینوں کے لیے ترجیحی فن تعمیر ہے کیونکہ اسے لاگو کرنا آسان ہے، جس کا مطلب ہے کہ بگس اور سیکیورٹی کی کمزوریوں کا امکان بہت کم ہوتا ہے۔ اسٹیک میں میموری 256-بٹ ورڈز میں تقسیم ہے۔ اسے اس لیے چنا گیا کیونکہ یہ Ethereum کے بنیادی کرپٹوگرافک آپریشنز جیسے Keccak-256 ہیشنگ اور ایلیپٹک کرو کمپیوٹیشنز کے لیے آسان ہے۔ اسٹیک کا زیادہ سے زیادہ سائز 1024 آئٹمز (1024 x 256 بٹس) ہے۔ جب آپ کوڈز ایگزیکیوٹ ہوتے ہیں تو وہ عام طور پر اپنے پیرامیٹرز اسٹیک سے حاصل کر رہے ہوتے ہیں۔ اسٹیک میں عناصر کو دوبارہ ترتیب دینے کے لیے خاص طور پر آپ کوڈز ہیں جیسے `POP` (اسٹیک کے اوپر سے آئٹم ہٹاتا ہے)، `DUP_N` (اسٹیک میں N'واں آئٹم ڈپلیکیٹ کرتا ہے)، وغیرہ۔

EVM میں ایک غیر مستحکم جگہ بھی ہے جسے **میموری** کہا جاتا ہے جو ایگزیکیوشن کے دوران ڈیٹا اسٹور کرنے کے لیے استعمال ہوتی ہے۔ یہ میموری 32-بائٹ ورڈز میں منظم ہے۔ تمام میموری لوکیشنز کو صفر پر شروع کیا جاتا ہے۔ اگر آپ میموری میں ایک ورڈ شامل کرنے کے لیے یہ [Yul](https://docs.soliditylang.org/en/latest/yul.html) کوڈ ایگزیکیوٹ کرتے ہیں، تو یہ ورڈ میں خالی جگہ کو صفر سے بھر کر میموری کے 32 بائٹس بھر دے گا، یعنی، یہ ایک ورڈ بناتا ہے - لوکیشنز 0-29 میں صفر کے ساتھ، 30 پر 0x60، اور 31 پر 0xA7۔

```yul
mstore(0, 0x60A7)
```

`mstore` ان تین آپ کوڈز میں سے ایک ہے جو EVM میموری کے ساتھ تعامل کے لیے فراہم کرتا ہے - یہ میموری میں ایک ورڈ لوڈ کرتا ہے۔ دیگر دو `mstore8` ہیں جو میموری میں ایک ہی بائٹ لوڈ کرتا ہے، اور `mload` جو میموری سے اسٹیک میں ایک ورڈ منتقل کرتا ہے۔

EVM میں ایک الگ غیر مستحکم **اسٹوریج** ماڈل بھی ہے جسے سسٹم اسٹیٹ کے حصے کے طور پر برقرار رکھا جاتا ہے - یہ میموری ورڈ ارے میں منظم ہے (اسٹیک میں ورڈ-ایڈریس ایبل بائٹ ارے کے برعکس)۔ یہ اسٹوریج وہ جگہ ہے جہاں کنٹریکٹس مستقل ڈیٹا رکھتے ہیں - ایک کنٹریکٹ صرف اپنے اسٹوریج کے ساتھ ہی تعامل کر سکتا ہے۔ اسٹوریج کلیدی-قدر کی میپنگ میں منظم ہے۔

اگرچہ یلو پیپر کے اس سیکشن میں اس کا ذکر نہیں ہے، لیکن یہ جاننا بھی مفید ہے کہ میموری کی ایک چوتھی قسم بھی ہے۔ **Calldata** بائٹ-ایڈریس ایبل ریڈ-اونلی میموری ہے جو ٹرانزیکشن کے `data` پیرامیٹر کے ساتھ بھیجی گئی قدر کو اسٹور کرنے کے لیے استعمال ہوتی ہے۔ EVM میں `calldata` کو منظم کرنے کے لیے مخصوص آپ کوڈز ہیں۔ `calldatasize` ڈیٹا کا سائز واپس کرتا ہے۔ `calldataload` ڈیٹا کو اسٹیک میں لوڈ کرتا ہے۔ `calldatacopy` ڈیٹا کو میموری میں کاپی کرتا ہے۔

معیاری [Von Neumann architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture) کوڈ اور ڈیٹا کو ایک ہی میموری میں اسٹور کرتا ہے۔ EVM سیکورٹی وجوہات کی بنا پر اس معیار کی پیروی نہیں کرتا ہے - غیر مستحکم میموری کا اشتراک پروگرام کوڈ کو تبدیل کرنا ممکن بناتا ہے۔ اس کے بجائے، کوڈ کو اسٹوریج میں محفوظ کیا جاتا ہے۔

صرف دو صورتیں ہیں جن میں کوڈ میموری سے ایگزیکیوٹ ہوتا ہے:

- جب کوئی کنٹریکٹ دوسرا کنٹریکٹ بناتا ہے ([`CREATE`](https://www.evm.codes/#f0) یا [`CREATE2`](https://www.evm.codes/#f5) کا استعمال کرتے ہوئے)، تو کنٹریکٹ کنسٹرکٹر کا کوڈ میموری سے آتا ہے۔
- _کسی بھی_ کنٹریکٹ کی تخلیق کے دوران، کنسٹرکٹر کوڈ چلتا ہے اور پھر اصل کنٹریکٹ کے کوڈ کے ساتھ واپس آتا ہے، جو میموری سے بھی ہوتا ہے۔

اصطلاح 'غیر معمولی ایگزیکیوشن' کا مطلب ایک ایسی رعایت ہے جو موجودہ کنٹریکٹ کے ایگزیکیوشن کو روکنے کا سبب بنتی ہے۔

## 9.2 فیس کا جائزہ {#92-fees-overview}

یہ سیکشن بتاتا ہے کہ گیس کی فیس کا حساب کیسے لگایا جاتا ہے۔ تین لاگتیں ہیں:

### آپ کوڈ کی لاگت {#opcode-cost}

مخصوص آپ کوڈ کی موروثی لاگت۔ اس قدر کو حاصل کرنے کے لیے، اپینڈکس H (صفحہ 28، مساوات (327) کے تحت) میں آپ کوڈ کا لاگت گروپ تلاش کریں، اور مساوات (324) میں لاگت گروپ تلاش کریں۔ یہ آپ کو ایک لاگت کا فنکشن دیتا ہے، جو زیادہ تر معاملات میں اپینڈکس G (صفحہ 27) سے پیرامیٹرز کا استعمال کرتا ہے۔

مثال کے طور پر، آپ کوڈ [`CALLDATACOPY`](https://www.evm.codes/#37) گروپ _W<sub>copy</sub>_ کا رکن ہے۔ اس گروپ کے لیے آپ کوڈ کی لاگت _G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_ ہے۔ اپینڈکس G کو دیکھتے ہوئے، ہم دیکھتے ہیں کہ دونوں مستقل 3 ہیں، جو ہمیں _3+3×⌈μ<sub>s</sub>[2]÷32⌉_ دیتا ہے۔

ہمیں ابھی بھی _⌈μ<sub>s</sub>[2]÷32⌉_ کے اظہار کو سمجھنے کی ضرورت ہے۔ سب سے باہری حصہ، _⌈ \<value\> ⌉_ سیلنگ فنکشن ہے، ایک ایسا فنکشن جو دی گئی قدر کے لیے سب سے چھوٹا عدد لوٹاتا ہے جو اس قدر سے چھوٹا نہ ہو۔ مثال کے طور پر، _⌈2.5⌉ = ⌈3⌉ = 3_. اندرونی حصہ _μ<sub>s</sub>[2]÷32_ ہے۔ صفحہ 3 پر سیکشن 3 (کنونشنز) کو دیکھتے ہوئے، _μ_ مشین کی حالت ہے۔ مشین کی حالت کی تعریف صفحہ 13 پر سیکشن 9.4.1 میں کی گئی ہے۔ اس سیکشن کے مطابق، مشین اسٹیٹ کے پیرامیٹرز میں سے ایک اسٹیک کے لیے _s_ ہے۔ ان سب کو ایک ساتھ رکھتے ہوئے، ایسا لگتا ہے کہ _μ<sub>s</sub>[2]_ اسٹیک میں لوکیشن #2 ہے۔ [آپ کوڈ](https://www.evm.codes/#37) کو دیکھتے ہوئے، اسٹیک میں لوکیشن #2 بائٹس میں ڈیٹا کا سائز ہے۔ گروپ W<sub>copy</sub> میں دیگر آپ کوڈز، [`CODECOPY`](https://www.evm.codes/#39) اور [`RETURNDATACOPY`](https://www.evm.codes/#3e) کو دیکھتے ہوئے، ان کے پاس بھی اسی لوکیشن میں ڈیٹا کا سائز ہوتا ہے۔ لہذا _⌈μ<sub>s</sub>[2]÷32⌉_ کاپی کیے جانے والے ڈیٹا کو اسٹور کرنے کے لیے درکار 32 بائٹ ورڈز کی تعداد ہے۔ سب کچھ ایک ساتھ رکھتے ہوئے، [`CALLDATACOPY`](https://www.evm.codes/#37) کی موروثی لاگت 3 گیس ہے اور کاپی کیے جانے والے ڈیٹا کے ہر ورڈ کے لیے 3 ہے۔

### چلانے کی لاگت {#running-cost}

اس کوڈ کو چلانے کی لاگت جسے ہم کال کر رہے ہیں۔

- [`CREATE`](https://www.evm.codes/#f0) اور [`CREATE2`](https://www.evm.codes/#f5) کی صورت میں، نئے کنٹریکٹ کے لیے کنسٹرکٹر۔
- [`CALL`](https://www.evm.codes/#f1)، [`CALLCODE`](https://www.evm.codes/#f2)، [`STATICCALL`](https://www.evm.codes/#fa)، یا [`DELEGATECALL`](https://www.evm.codes/#f4) کی صورت میں، وہ کنٹریکٹ جسے ہم کال کرتے ہیں۔

### میموری کی توسیع کی لاگت {#expanding-memory-cost}

میموری کی توسیع کی لاگت (اگر ضروری ہو)۔

مساوات 324 میں، اس قدر کو _C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_ کے طور پر لکھا گیا ہے۔ دوبارہ سیکشن 9.4.1 کو دیکھتے ہوئے، ہم دیکھتے ہیں کہ _μ<sub>i</sub>_ میموری میں ورڈز کی تعداد ہے۔ لہذا _μ<sub>i</sub>_ آپ کوڈ سے پہلے میموری میں ورڈز کی تعداد ہے اور _μ<sub>i</sub>'_ آپ کوڈ کے بعد میموری میں ورڈز کی تعداد ہے۔

فنکشن _C<sub>mem</sub>_ مساوات 326 میں بیان کیا گیا ہے: _C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_۔ ⌊x⌋ فلور فنکشن ہے، ایک ایسا فنکشن جو دی گئی قدر کے لیے سب سے بڑا عدد لوٹاتا ہے جو اس قدر سے بڑا نہ ہو۔ مثال کے طور پر، _⌊2.5⌋ = ⌊2⌋ = 2._ جب _a < √512_, _a<sup>2</sup> < 512_, اور فلور فنکشن کا نتیجہ صفر ہوتا ہے۔ لہذا پہلے 22 ورڈز (704 بائٹس) کے لیے، لاگت درکار میموری ورڈز کی تعداد کے ساتھ لکیری طور پر بڑھتی ہے۔ اس نقطہ سے آگے _⌊a<sup>2</sup> ÷ 512⌋_ مثبت ہے۔ جب درکار میموری کافی زیادہ ہو تو گیس کی لاگت میموری کی مقدار کے مربع کے متناسب ہوتی ہے۔

**نوٹ** کریں کہ یہ عوامل صرف _موروثی_ گیس کی لاگت کو متاثر کرتے ہیں - یہ فیس مارکیٹ یا ویلیڈیٹرز کو دی جانے والی ٹپس کو مدنظر نہیں رکھتا جو یہ طے کرتی ہیں کہ ایک آخری صارف کو کتنی رقم ادا کرنے کی ضرورت ہے - یہ صرف EVM پر کسی خاص آپریشن کو چلانے کی خام لاگت ہے۔

[گیس کے بارے میں مزید پڑھیں](/developers/docs/gas/)۔

## 9.3 ایگزیکیوشن ماحول {#93-execution-env}

ایگزیکیوشن ماحول ایک ٹپل، _I_ ہے، جس میں ایسی معلومات شامل ہیں جو بلاکچین اسٹیٹ یا EVM کا حصہ نہیں ہیں۔

| پیرامیٹر        | ڈیٹا تک رسائی کے لیے آپ کوڈ                                                                               | ڈیٹا تک رسائی کے لیے Solidity کوڈ          |
| --------------- | --------------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                                    | `address(this)`                            |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                                     | `tx.origin`                                |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                                   | `tx.gasprice`                              |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35)، وغیرہ۔                                                       | `msg.data`                                 |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                                     | `msg.sender`                               |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                                  | `msg.value`                                |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                                   | `address(this).code`                       |
| _I<sub>H</sub>_ | بلاک ہیڈر فیلڈز، جیسے [`NUMBER`](https://www.evm.codes/#43) اور [`DIFFICULTY`](https://www.evm.codes/#44) | `block.number`, `block.difficulty`, وغیرہ۔ |
| _I<sub>e</sub>_ | کنٹریکٹس کے درمیان کالز کے لیے کال اسٹیک کی گہرائی (بشمول کنٹریکٹ کی تخلیق)            |                                            |
| _I<sub>w</sub>_ | کیا EVM کو اسٹیٹ تبدیل کرنے کی اجازت ہے، یا یہ جامد طور پر چل رہا ہے                                      |                                            |

سیکشن 9 کے باقی حصے کو سمجھنے کے لیے چند دیگر پیرامیٹرز ضروری ہیں:

| پیرامیٹر | سیکشن میں بیان کیا گیا ہے                        | مطلب                                                                                                                                                                                                                                              |
| -------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _σ_      | 2 (صفحہ 2، مساوات 1)          | بلاکچین کی حالت                                                                                                                                                                                                                                   |
| _g_      | 9.3 (صفحہ 13) | بقیہ گیس                                                                                                                                                                                                                                          |
| _A_      | 6.1 (صفحہ 8)  | جمع شدہ سب اسٹیٹ (ٹرانزیکشن ختم ہونے پر طے شدہ تبدیلیاں)                                                                                                                                                                       |
| _o_      | 9.3 (صفحہ 13) | آؤٹ پٹ - اندرونی ٹرانزیکشن (جب ایک کنٹریکٹ دوسرے کو کال کرتا ہے) اور ویو فنکشنز کو کال کرنے کی صورت میں واپس کیا گیا نتیجہ (جب آپ صرف معلومات مانگ رہے ہوں، لہذا ٹرانزیکشن کا انتظار کرنے کی ضرورت نہیں ہے) |

## 9.4 ایگزیکیوشن کا جائزہ {#94-execution-overview}

اب جب کہ ہمارے پاس تمام ابتدائی باتیں ہیں، ہم آخر کار اس پر کام کرنا شروع کر سکتے ہیں کہ EVM کیسے کام کرتا ہے۔

مساوات 137-142 ہمیں EVM چلانے کے لیے ابتدائی شرائط دیتی ہیں:

| علامت            | ابتدائی قدر                                                                      | مطلب                                                                                                                                                                                                                                                                                            |
| ---------------- | -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | بقیہ گیس                                                                                                                                                                                                                                                                                        |
| _μ<sub>pc</sub>_ | _0_                                                                              | پروگرام کاؤنٹر، ایگزیکیوٹ کرنے کے لیے اگلی ہدایت کا ایڈریس                                                                                                                                                                                                                                      |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | میموری، تمام صفروں پر شروع کی گئی                                                                                                                                                                                                                                                               |
| _μ<sub>i</sub>_  | _0_                                                                              | استعمال شدہ سب سے اونچی میموری لوکیشن                                                                                                                                                                                                                                                           |
| _μ<sub>s</sub>_  | _()_                                                          | اسٹیک، ابتدائی طور پر خالی                                                                                                                                                                                                                                                                      |
| _μ<sub>o</sub>_  | _∅_                                                                              | آؤٹ پٹ، خالی سیٹ جب تک کہ ہم یا تو واپسی کے ڈیٹا ([`RETURN`](https://www.evm.codes/#f3) یا [`REVERT`](https://www.evm.codes/#fd)) کے ساتھ یا اس کے بغیر ([`STOP`](https://www.evm.codes/#00) یا [`SELFDESTRUCT`](https://www.evm.codes/#ff)) رک نہ جائیں۔ |

مساوات 143 ہمیں بتاتی ہے کہ ایگزیکیوشن کے دوران ہر وقت چار ممکنہ شرائط ہوتی ہیں، اور ان کے ساتھ کیا کرنا ہے:

1. `Z(σ,μ,A,I)`۔ Z ایک فنکشن کی نمائندگی کرتا ہے جو یہ جانچتا ہے کہ آیا کوئی آپریشن ایک غلط اسٹیٹ ٹرانزیشن بناتا ہے (دیکھیں [غیر معمولی روک](#942-exceptional-halting))۔ اگر یہ سچ کا اندازہ کرتا ہے، تو نئی اسٹیٹ پرانی اسٹیٹ جیسی ہی ہے (سوائے اس کے کہ گیس جل جاتی ہے) کیونکہ تبدیلیاں نافذ نہیں کی گئی ہیں۔
2. اگر ایگزیکیوٹ کیا جانے والا آپ کوڈ [`REVERT`](https://www.evm.codes/#fd) ہے، تو نئی اسٹیٹ پرانی اسٹیٹ جیسی ہی ہے، کچھ گیس ضائع ہو جاتی ہے۔
3. اگر آپریشنز کا سلسلہ ختم ہو گیا ہے، جیسا کہ [`RETURN`](https://www.evm.codes/#f3) سے ظاہر ہوتا ہے، تو اسٹیٹ کو نئی اسٹیٹ میں اپ ڈیٹ کر دیا جاتا ہے۔
4. اگر ہم اختتامی شرائط 1-3 میں سے کسی ایک پر نہیں ہیں، تو چلنا جاری رکھیں۔

## 9.4.1 مشین اسٹیٹ {#941-machine-state}

یہ سیکشن مشین کی حالت کو مزید تفصیل سے بیان کرتا ہے۔ یہ بتاتا ہے کہ _w_ موجودہ آپ کوڈ ہے۔ اگر _μ<sub>pc</sub>_، _||I<sub>b</sub>||_ سے کم ہے، جو کوڈ کی لمبائی ہے، تو وہ بائٹ (_I<sub>b</sub>[μ<sub>pc</sub>]_) آپ کوڈ ہے۔ بصورت دیگر، آپ کوڈ کو [`STOP`](https://www.evm.codes/#00) کے طور پر بیان کیا گیا ہے۔

چونکہ یہ ایک [stack machine](https://en.wikipedia.org/wiki/Stack_machine) ہے، اس لیے ہمیں ہر آپ کوڈ کے ذریعے باہر نکالے گئے (_δ_) اور اندر ڈالے گئے (_α_) آئٹمز کی تعداد کا ٹریک رکھنے کی ضرورت ہے۔

## 9.4.2 غیر معمولی روک {#942-exceptional-halt}

یہ سیکشن _Z_ فنکشن کی وضاحت کرتا ہے، جو یہ بتاتا ہے کہ ہمارے پاس غیر معمولی خاتمہ کب ہوتا ہے۔ یہ ایک [Boolean](https://en.wikipedia.org/wiki/Boolean_data_type) فنکشن ہے، لہذا یہ [_∨_ کو منطقی 'یا'](https://en.wikipedia.org/wiki/Logical_disjunction) کے لیے اور [_∧_ کو منطقی 'اور'](https://en.wikipedia.org/wiki/Logical_conjunction) کے لیے استعمال کرتا ہے۔

ہمارے پاس ایک غیر معمولی روک ہے اگر ان شرائط میں سے کوئی بھی سچ ہے:

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  جیسا کہ ہم نے سیکشن 9.2 میں دیکھا، _C_ وہ فنکشن ہے جو گیس کی لاگت بتاتا ہے۔ اگلے آپ کوڈ کو پورا کرنے کے لیے کافی گیس باقی نہیں ہے۔

- **_δ<sub>w</sub>=∅_**
  اگر کسی آپ کوڈ کے لیے پاپ کیے گئے آئٹمز کی تعداد غیر متعین ہے، تو آپ کوڈ خود غیر متعین ہے۔

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  اسٹیک انڈر فلو، موجودہ آپ کوڈ کے لیے اسٹیک میں کافی آئٹمز نہیں ہیں۔

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  آپ کوڈ [`JUMP`](https://www.evm.codes/#56) ہے اور ایڈریس [`JUMPDEST`](https://www.evm.codes/#5b) نہیں ہے۔ جمپس _صرف_ اس وقت درست ہوتے ہیں جب منزل ایک [`JUMPDEST`](https://www.evm.codes/#5b) ہو۔

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  آپ کوڈ [`JUMPI`](https://www.evm.codes/#57) ہے، شرط سچ ہے (غیر صفر) اس لیے جمپ ہونا چاہیے، اور ایڈریس [`JUMPDEST`](https://www.evm.codes/#5b) نہیں ہے۔ جمپس _صرف_ اس وقت درست ہوتے ہیں جب منزل ایک [`JUMPDEST`](https://www.evm.codes/#5b) ہو۔

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  آپ کوڈ [`RETURNDATACOPY`](https://www.evm.codes/#3e) ہے۔ اس آپ کوڈ میں اسٹیک عنصر _μ<sub>s</sub>[1]_ واپسی ڈیٹا بفر میں پڑھنے کے لیے آفسیٹ ہے، اور اسٹیک عنصر _μ<sub>s</sub>[2]_ ڈیٹا کی لمبائی ہے۔ یہ حالت اس وقت ہوتی ہے جب آپ واپسی ڈیٹا بفر کے آخر سے آگے پڑھنے کی کوشش کرتے ہیں۔ نوٹ کریں کہ کال ڈیٹا یا خود کوڈ کے لیے کوئی ملتی جلتی شرط نہیں ہے۔ جب آپ ان بفرز کے آخر سے آگے پڑھنے کی کوشش کرتے ہیں تو آپ کو صرف صفر ملتے ہیں۔

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  اسٹیک اوور فلو۔ اگر آپ کوڈ چلانے سے 1024 سے زیادہ آئٹمز کا اسٹیک بنے گا، تو رک جائیں۔

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  کیا ہم جامد طور پر چل رہے ہیں ([¬ نفی ہے](https://en.wikipedia.org/wiki/Negation) اور _I<sub>w</sub>_ سچ ہے جب ہمیں بلاکچین اسٹیٹ کو تبدیل کرنے کی اجازت ہے)؟ اگر ایسا ہے، اور ہم اسٹیٹ تبدیل کرنے والا آپریشن آزما رہے ہیں، تو یہ نہیں ہو سکتا۔

  فنکشن _W(w,μ)_ بعد میں مساوات 150 میں بیان کیا گیا ہے۔ _W(w,μ)_ سچ ہے اگر ان میں سے کوئی ایک شرط سچ ہے:

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    یہ آپ کوڈز اسٹیٹ کو تبدیل کرتے ہیں، یا تو ایک نیا کنٹریکٹ بنا کر، ایک قدر کو اسٹور کر کے، یا موجودہ کنٹریکٹ کو تباہ کر کے۔

  - **_LOG0≤w ∧ w≤LOG4_**
    اگر ہمیں جامد طور پر کال کیا جاتا ہے تو ہم لاگ اندراجات خارج نہیں کر سکتے۔
    لاگ آپ کوڈز سب [`LOG0` (A0)](https://www.evm.codes/#a0) اور [`LOG4` (A4)](https://www.evm.codes/#a4) کے درمیان کی رینج میں ہیں۔
    لاگ آپ کوڈ کے بعد کا نمبر بتاتا ہے کہ لاگ اندراج میں کتنے موضوعات ہیں۔

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    جب آپ جامد ہوں تو آپ دوسرے کنٹریکٹ کو کال کر سکتے ہیں، لیکن اگر آپ ایسا کرتے ہیں تو آپ اسے ETH منتقل نہیں کر سکتے۔

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  آپ [`SSTORE`](https://www.evm.codes/#55) نہیں چلا سکتے جب تک کہ آپ کے پاس G<sub>callstipend</sub> (اپینڈکس G میں 2300 کے طور پر بیان کیا گیا ہے) سے زیادہ گیس نہ ہو۔

## 9.4.3 جمپ ڈیسٹینیشن کی درستگی {#943-jump-dest-valid}

یہاں ہم رسمی طور پر بیان کرتے ہیں کہ [`JUMPDEST`](https://www.evm.codes/#5b) آپ کوڈز کیا ہیں۔ ہم صرف بائٹ ویلیو 0x5B کو نہیں دیکھ سکتے، کیونکہ یہ PUSH کے اندر ہو سکتا ہے (اور اس لیے ڈیٹا ہے نہ کہ آپ کوڈ)۔

مساوات (153) میں ہم ایک فنکشن، _N(i,w)_ کی وضاحت کرتے ہیں۔ پہلا پیرامیٹر، _i_، آپ کوڈ کا مقام ہے۔ دوسرا، _w_، خود آپ کوڈ ہے۔ اگر _w∈[PUSH1, PUSH32]_ تو اس کا مطلب ہے کہ آپ کوڈ ایک PUSH ہے (مربع بریکٹ ایک رینج کی وضاحت کرتے ہیں جس میں اختتامی نقطے شامل ہیں)۔ اس صورت میں اگلا آپ کوڈ _i+2+(w−PUSH1)_ پر ہے۔ [`PUSH1`](https://www.evm.codes/#60) کے لیے ہمیں دو بائٹس آگے بڑھنے کی ضرورت ہے (خود PUSH اور ایک بائٹ ویلیو)، [`PUSH2`](https://www.evm.codes/#61) کے لیے ہمیں تین بائٹس آگے بڑھنے کی ضرورت ہے کیونکہ یہ دو بائٹ ویلیو ہے، وغیرہ۔ دیگر تمام EVM آپ کوڈز صرف ایک بائٹ لمبے ہوتے ہیں، لہذا دیگر تمام صورتوں میں _N(i,w)=i+1_۔

اس فنکشن کا استعمال مساوات (152) میں _D<sub>J</sub>(c,i)_ کی وضاحت کے لیے کیا جاتا ہے، جو کوڈ _c_ میں تمام درست جمپ ڈیسٹینیشنز کا [سیٹ](https://en.wikipedia.org/wiki/Set_\(mathematics\)) ہے، جو آپ کوڈ لوکیشن _i_ سے شروع ہوتا ہے۔ اس فنکشن کی وضاحت تکراری طور پر کی گئی ہے۔ اگر _i≥||c||_ ہے، تو اس کا مطلب ہے کہ ہم کوڈ کے آخر میں یا اس کے بعد ہیں۔ ہمیں مزید جمپ ڈیسٹینیشنز نہیں ملیں گی، لہذا صرف خالی سیٹ واپس کریں۔

دیگر تمام صورتوں میں ہم اگلے آپ کوڈ پر جا کر اور اس سے شروع ہونے والا سیٹ حاصل کر کے باقی کوڈ کو دیکھتے ہیں۔ _c[i]_ موجودہ آپ کوڈ ہے، لہذا _N(i,c[i])_ اگلے آپ کوڈ کا مقام ہے۔ لہذا _D<sub>J</sub>(c,N(i,c[i]))_ درست جمپ ڈیسٹینیشنز کا سیٹ ہے جو اگلے آپ کوڈ سے شروع ہوتا ہے۔ اگر موجودہ آپ کوڈ `JUMPDEST` نہیں ہے، تو صرف وہ سیٹ واپس کریں۔ اگر یہ `JUMPDEST` ہے، تو اسے نتیجہ سیٹ میں شامل کریں اور اسے واپس کریں۔

## 9.4.4 عمومی روک {#944-normal-halt}

روکنے کا فنکشن _H_، تین قسم کی قدریں واپس کر سکتا ہے۔

- اگر ہم روکنے والے آپ کوڈ میں نہیں ہیں، تو _∅_، یعنی خالی سیٹ واپس کریں۔ روایتی طور پر، اس قدر کو بولین فالس کے طور پر تعبیر کیا جاتا ہے۔
- اگر ہمارے پاس ایک ہالٹ آپ کوڈ ہے جو آؤٹ پٹ پیدا نہیں کرتا ہے (یا تو [`STOP`](https://www.evm.codes/#00) یا [`SELFDESTRUCT`](https://www.evm.codes/#ff))، تو واپسی کی قدر کے طور پر صفر سائز کے بائٹس کی ایک ترتیب واپس کریں۔ نوٹ کریں کہ یہ خالی سیٹ سے بہت مختلف ہے۔ اس قدر کا مطلب ہے کہ EVM واقعی رک گیا تھا، بس پڑھنے کے لیے کوئی واپسی ڈیٹا نہیں ہے۔
- اگر ہمارے پاس ایک ہالٹ آپ کوڈ ہے جو آؤٹ پٹ پیدا کرتا ہے (یا تو [`RETURN`](https://www.evm.codes/#f3) یا [`REVERT`](https://www.evm.codes/#fd))، تو اس آپ کوڈ کے ذریعہ بیان کردہ بائٹس کی ترتیب واپس کریں۔ یہ ترتیب میموری سے لی جاتی ہے، اسٹیک کے اوپر کی قدر (_μ<sub>s</sub>[0]_) پہلا بائٹ ہے، اور اس کے بعد کی قدر (_μ<sub>s</sub>[1]_) لمبائی ہے۔

## H.2 انسٹرکشن سیٹ {#h2-instruction-set}

EVM کے آخری سب سیکشن، 9.5، پر جانے سے پہلے، آئیے خود ہدایات کو دیکھتے ہیں۔ ان کی تعریف اپینڈکس H.2 میں کی گئی ہے جو صفحہ 29 سے شروع ہوتا ہے۔ کوئی بھی چیز جسے اس مخصوص آپ کوڈ کے ساتھ تبدیل ہونے کے طور پر بیان نہیں کیا گیا ہے، اس سے وہی رہنے کی توقع کی جاتی ہے۔ جو متغیرات تبدیل ہوتے ہیں انہیں \<something\> کے ساتھ بیان کیا جاتا ہے۔

مثال کے طور پر، آئیے [`ADD`](https://www.evm.codes/#01) آپ کوڈ کو دیکھتے ہیں۔

|  قدر | یادداشت | δ | α | تفصیل                                                                                                                                                                                                                 |
| ---: | ------- | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0x01 | ADD     | 2 | 1 | اضافے کا عمل۔                                                                                                                                                                                                         |
|      |         |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_ ان قدروں کی تعداد ہے جنہیں ہم اسٹیک سے پاپ کرتے ہیں۔ اس معاملے میں دو، کیونکہ ہم سب سے اوپر کی دو قدروں کو جوڑ رہے ہیں۔

_α_ ان قدروں کی تعداد ہے جنہیں ہم واپس پش کرتے ہیں۔ اس معاملے میں ایک، یعنی مجموعہ۔

لہذا نیا اسٹیک ٹاپ (_μ′<sub>s</sub>[0]_) پرانے اسٹیک ٹاپ (_μ<sub>s</sub>[0]_) اور اس کے نیچے کی پرانی قدر (_μ<sub>s</sub>[1]_) کا مجموعہ ہے۔

تمام آپ کوڈز کو "آنکھیں پھیرنے والی فہرست" کے ساتھ دیکھنے کے بجائے، یہ مضمون صرف ان آپ کوڈز کی وضاحت کرتا ہے جو کچھ نیا متعارف کراتے ہیں۔

|  قدر | یادداشت   | δ | α | تفصیل                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ---: | --------- | - | - | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 0x20 | KECCAK256 | 2 | 1 | Keccak-256 ہیش کا حساب لگائیں۔                                                                                                                                                                                                                                                                                                                                                                                                       |
|      |           |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] . ۔ ۔ (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|      |           |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                     |

یہ پہلا آپ کوڈ ہے جو میموری تک رسائی حاصل کرتا ہے (اس معاملے میں، صرف پڑھنے کے لیے)۔ تاہم، یہ میموری کی موجودہ حدود سے باہر پھیل سکتا ہے، لہذا ہمیں _μ<sub>i</sub>._ کو اپ ڈیٹ کرنے کی ضرورت ہے۔ ہم یہ _M_ فنکشن کا استعمال کرتے ہوئے کرتے ہیں جو صفحہ 29 پر مساوات 328 میں بیان کیا گیا ہے۔

|  قدر | یادداشت | δ | α | تفصیل                                               |
| ---: | ------- | - | - | --------------------------------------------------- |
| 0x31 | BALANCE | 1 | 1 | دیے گئے اکاؤنٹ کا بیلنس حاصل کریں۔                  |
|      |         |   |   | ... |

جس ایڈریس کا بیلنس ہمیں تلاش کرنا ہے وہ _μ<sub>s</sub>[0] mod 2<sup>160</sup>_ ہے۔ اسٹیک کا سب سے اوپر ایڈریس ہے، لیکن چونکہ ایڈریس صرف 160 بٹس کے ہوتے ہیں، اس لیے ہم قدر کا حساب [ماڈیولو](https://en.wikipedia.org/wiki/Modulo_operation) 2<sup>160</sup> کرتے ہیں۔

اگر _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_ ہے، تو اس کا مطلب ہے کہ اس ایڈریس کے بارے میں معلومات موجود ہیں۔ اس صورت میں، _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_ اس ایڈریس کا بیلنس ہے۔ اگر _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_ ہے، تو اس کا مطلب ہے کہ یہ ایڈریس غیر شروع شدہ ہے اور بیلنس صفر ہے۔ آپ صفحہ 4 پر سیکشن 4.1 میں اکاؤنٹ کی معلومات کے فیلڈز کی فہرست دیکھ سکتے ہیں۔

دوسری مساوات، _A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_، گرم اسٹوریج (وہ اسٹوریج جس تک حال ہی میں رسائی حاصل کی گئی ہے اور جس کے کیش ہونے کا امکان ہے) اور سرد اسٹوریج (وہ اسٹوریج جس تک رسائی حاصل نہیں کی گئی ہے اور جس کے سست اسٹوریج میں ہونے کا امکان ہے جسے بازیافت کرنا زیادہ مہنگا ہے) تک رسائی کی لاگت میں فرق سے متعلق ہے۔ _A<sub>a</sub>_ ان ایڈریسز کی فہرست ہے جن تک ٹرانزیکشن کے ذریعے پہلے رسائی حاصل کی گئی ہے، جن تک رسائی حاصل کرنا سستا ہونا چاہیے، جیسا کہ صفحہ 8 پر سیکشن 6.1 میں بیان کیا گیا ہے۔ آپ اس موضوع کے بارے میں [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929) میں مزید پڑھ سکتے ہیں۔

|  قدر | یادداشت | δ  | α  | تفصیل                                                                                                                                           |
| ---: | ------- | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 0x8F | DUP16   | 16 | 17 | 16 ویں اسٹیک آئٹم کو ڈپلیکیٹ کریں۔                                                                                                              |
|      |         |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

نوٹ کریں کہ کسی بھی اسٹیک آئٹم کو استعمال کرنے کے لیے، ہمیں اسے پاپ کرنے کی ضرورت ہے، جس کا مطلب ہے کہ ہمیں اس کے اوپر کے تمام اسٹیک آئٹمز کو بھی پاپ کرنے کی ضرورت ہے۔ [`DUP<n>`](https://www.evm.codes/#8f) اور [`SWAP<n>`](https://www.evm.codes/#9f) کے معاملے میں، اس کا مطلب ہے کہ سولہ تک کی قدروں کو پاپ کرنا اور پھر پش کرنا ہے۔

## 9.5 ایگزیکیوشن سائیکل {#95-exec-cycle}

اب جب کہ ہمارے پاس تمام حصے ہیں، ہم آخر کار سمجھ سکتے ہیں کہ EVM کا ایگزیکیوشن سائیکل کیسے دستاویزی کیا جاتا ہے۔

مساوات (155) کہتی ہے کہ دی گئی حالت:

- _σ_ (عالمی بلاکچین اسٹیٹ)
- _μ_ (EVM اسٹیٹ)
- _A_ (سب اسٹیٹ، ٹرانزیکشن ختم ہونے پر ہونے والی تبدیلیاں)
- _I_ (ایگزیکیوشن ماحول)

نئی اسٹیٹ _(σ', μ', A', I')_ ہے۔

مساوات (156)-(158) اسٹیک اور اس میں آپ کوڈ (_μ<sub>s</sub>_) کی وجہ سے ہونے والی تبدیلی کی وضاحت کرتی ہیں۔ مساوات (159) گیس (_μ<sub>g</sub>_) میں تبدیلی ہے۔ مساوات (160) پروگرام کاؤنٹر (_μ<sub>pc</sub>_) میں تبدیلی ہے۔ آخر میں، مساوات (161)-(164) بتاتی ہیں کہ دیگر پیرامیٹرز وہی رہتے ہیں، جب تک کہ آپ کوڈ کے ذریعہ واضح طور پر تبدیل نہ کیا جائے۔

اس کے ساتھ EVM مکمل طور پر بیان ہو جاتا ہے۔

## نتیجہ {#conclusion}

ریاضیاتی اشارے درست ہیں اور اس نے یلو پیپر کو Ethereum کی ہر تفصیل کو بیان کرنے کی اجازت دی ہے۔ تاہم، اس کے کچھ نقصانات بھی ہیں:

- اسے صرف انسان ہی سمجھ سکتے ہیں، جس کا مطلب ہے کہ [تعمیل ٹیسٹ](https://github.com/ethereum/tests) دستی طور پر لکھے جانے چاہئیں۔
- پروگرامرز کمپیوٹر کوڈ کو سمجھتے ہیں۔
  وہ ریاضیاتی اشارے کو سمجھ بھی سکتے ہیں اور نہیں بھی۔

شاید ان وجوہات کی بنا پر، نئے [کنسنسس لیئر کی تفصیلات](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md) Python میں لکھی گئی ہیں۔ [Python میں ایگزیکیوشن لیئر کی تفصیلات](https://ethereum.github.io/execution-specs) ہیں، لیکن وہ مکمل نہیں ہیں۔ جب تک کہ پورا یلو پیپر بھی Python یا کسی ملتی جلتی زبان میں ترجمہ نہ ہو جائے، یلو پیپر سروس میں رہے گا، اور اسے پڑھنا مددگار ہے۔
