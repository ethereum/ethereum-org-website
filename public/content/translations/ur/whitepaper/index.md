---
title: Ethereum وائٹ پیپر
description: ایتھیریم کا ایک تعارفی مقالہ، جو 2013 میں اس کے لانچ سے پہلے شائع ہوا تھا۔
lang: ur-in
sidebarDepth: 2
hideEditButton: true
---

# ایتھیریم وائٹ پیپر {#ethereum-whitepaper}

_یہ تعارفی مقالہ اصل میں 2014 میں [Ethereum](/what-is-ethereum/) کے بانی، Vitalik Buterin نے 2015 میں پروجیکٹ کے لانچ سے پہلے شائع کیا تھا۔ یہ بات قابل غور ہے کہ ایتھیریم، بہت سے کمیونٹی پر مبنی، اوپن سورس سافٹ ویئر پروجیکٹس کی طرح، اپنے ابتدائی آغاز کے بعد سے بہت ترقی کر چکا ہے۔_

_کئی سال پرانا ہونے کے باوجود، ہم اس مقالے کو برقرار رکھتے ہیں کیونکہ یہ ایک مفید حوالہ اور ایتھیریم اور اس کے وژن کی درست نمائندگی کرتا ہے۔ ایتھیریم کی تازہ ترین پیشرفتوں کے بارے میں جاننے کے لیے، اور پروٹوکول میں تبدیلیاں کیسے کی جاتی ہیں، ہم [اس گائیڈ](/learn/) کی سفارش کرتے ہیں۔_

[محققین اور ماہرین تعلیم جو وائٹ پیپر کا تاریخی یا روایتی ورژن [دسمبر 2014 سے] تلاش کر رہے ہیں انہیں یہ PDF استعمال کرنا چاہئے۔](./whitepaper-pdf/Ethereum_Whitepaper_-_Buterin_2014.pdf)

## ایک اگلی نسل کا اسمارٹ کنٹریکٹ اور ڈی سینٹرلائزڈ ایپلیکیشن پلیٹ فارم {#a-next-generation-smart-contract-and-decentralized-application-platform}

2009 میں Satoshi Nakamoto کی Bitcoin کی ترقی کو اکثر پیسے اور کرنسی میں ایک بنیادی ترقی کے طور پر سراہا گیا ہے، جو ایک ڈیجیٹل اثاثہ کی پہلی مثال ہے جس کی بیک وقت کوئی پشت پناہی یا "[اندرونی قدر](https://bitcoinmagazine.com/culture/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it)" نہیں ہے اور نہ ہی کوئی مرکزی جاری کنندہ یا کنٹرولر ہے۔ تاہم، Bitcoin کے تجربے کا ایک اور، بلاشبہ زیادہ اہم حصہ، تقسیم شدہ اتفاق رائے کے ایک آلے کے طور پر بنیادی بلاک چین ٹیکنالوجی ہے، اور توجہ تیزی سے Bitcoin کے اس دوسرے پہلو کی طرف منتقل ہونا شروع ہو رہی ہے۔ بلاک چین ٹیکنالوجی کے عام طور پر حوالہ دیے جانے والے متبادل ایپلی کیشنز میں کسٹم کرنسیوں اور مالیاتی آلات کی نمائندگی کے لیے آن-بلاک چین ڈیجیٹل اثاثوں کا استعمال شامل ہے (\"[colored coins](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)\")، کسی بنیادی جسمانی آلے کی ملکیت (\"[smart property](https://en.bitcoin.it/wiki/Smart_Property)\")، ڈومین ناموں جیسے نان-فنجیبل اثاثے (\"[Namecoin](http://namecoin.org)\")، نیز مزید پیچیدہ ایپلی کیشنز جن میں ڈیجیٹل اثاثوں کو براہ راست کوڈ کے ایک ٹکڑے کے ذریعے کنٹرول کیا جاتا ہے جو من مانی قوانین کو نافذ کرتا ہے (\"[smart contracts](http://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/idea.html)\") یا یہاں تک کہ بلاک چین پر مبنی \"[decentralized autonomous organizations](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/)\" (DAOs)۔ ایتھیریم کا مقصد ایک ایسی بلاک چین فراہم کرنا ہے جس میں ایک بلٹ-ان مکمل طور پر ٹورنگ-کمپلیٹ پروگرامنگ زبان ہو جسے \"کنٹریکٹس\" بنانے کے لیے استعمال کیا جا سکتا ہے جو من مانی اسٹیٹ ٹرانزیشن فنکشنز کو انکوڈ کرنے کے لیے استعمال ہو سکتے ہیں، جس سے صارفین اوپر بیان کردہ کسی بھی سسٹم کو بنا سکتے ہیں، ساتھ ہی بہت سے دوسرے جن کا ہم نے ابھی تک تصور بھی نہیں کیا ہے، صرف چند لائنوں کے کوڈ میں منطق لکھ کر۔

## بٹ کوائن اور موجودہ تصورات کا تعارف {#introduction-to-bitcoin-and-existing-concepts}

### تاریخ {#history}

ڈی سینٹرلائزڈ ڈیجیٹل کرنسی کا تصور، نیز پراپرٹی رجسٹری جیسے متبادل ایپلی کیشنز، کئی دہائیوں سے موجود ہیں۔ 1980 اور 1990 کی دہائیوں کے گمنام ای-کیش پروٹوکولز، جو زیادہ تر Chaumian blinding کے نام سے جانے والے ایک کرپٹوگرافک پریمیٹیو پر انحصار کرتے تھے، نے اعلی درجے کی رازداری والی کرنسی فراہم کی، لیکن یہ پروٹوکولز زیادہ تر ایک مرکزی ثالث پر انحصار کی وجہ سے مقبولیت حاصل کرنے میں ناکام رہے۔ 1998 میں، Wei Dai کا [b-money](http://www.weidai.com/bmoney.txt) پہلا پروپوزل تھا جس نے کمپیوٹیشنل پزلز کو حل کرنے کے ساتھ ساتھ ڈی سینٹرلائزڈ اتفاق رائے کے ذریعے پیسہ بنانے کا خیال پیش کیا، لیکن اس پروپوزل میں اس بارے میں تفصیلات کی کمی تھی کہ ڈی سینٹرلائزڈ اتفاق رائے کو حقیقت میں کیسے نافذ کیا جا سکتا ہے۔ 2005 میں، Hal Finney نے \"[reusable proofs of work](https://nakamotoinstitute.org/finney/rpow/)\" کا ایک تصور پیش کیا، ایک ایسا نظام جو b-money کے آئیڈیاز کو Adam Back کے کمپیوٹیشنلی مشکل Hashcash پزلز کے ساتھ ملا کر ایک کریپٹو کرنسی کا تصور تخلیق کرتا ہے، لیکن ایک بار پھر ایک بیک اینڈ کے طور پر قابل اعتماد کمپیوٹنگ پر انحصار کرکے آئیڈیل سے کم رہ گیا۔ 2009 میں، پہلی بار Satoshi Nakamoto نے ایک ڈی سینٹرلائزڈ کرنسی کو عملی طور پر نافذ کیا، جس میں پبلک کی کرپٹوگرافی کے ذریعے ملکیت کے انتظام کے لیے قائم کردہ پریمیٹوز کو ایک کنسنسس الگورتھم کے ساتھ ملایا گیا تاکہ یہ ٹریک رکھا جا سکے کہ سکوں کا مالک کون ہے، جسے \"پروف-آف-ورک\" کے نام سے جانا جاتا ہے۔

پروف-آف-ورک کے پیچھے کا میکانزم اس شعبے میں ایک اہم پیش رفت تھی کیونکہ اس نے بیک وقت دو مسائل حل کیے۔ پہلا، اس نے ایک سادہ اور معتدل طور پر موثر کنسنسس الگورتھم فراہم کیا، جس سے نیٹ ورک میں نوڈز کو Bitcoin لیجر کی حالت میں کینونیکل اپڈیٹس کے ایک سیٹ پر اجتماعی طور پر اتفاق کرنے کی اجازت ملی۔ دوسرا، اس نے کنسنسس کے عمل میں آزادانہ داخلے کی اجازت دینے کے لیے ایک میکانزم فراہم کیا، اس سیاسی مسئلے کو حل کیا کہ یہ فیصلہ کون کرے گا کہ کنسنسس پر کون اثر انداز ہو سکتا ہے، جبکہ بیک وقت سائبل حملوں کو بھی روکا جا سکے۔ یہ شرکت کی رسمی رکاوٹ، جیسے کسی خاص فہرست میں ایک منفرد ادارے کے طور پر رجسٹرڈ ہونے کی ضرورت، کو ایک اقتصادی رکاوٹ سے بدل کر ایسا کرتا ہے - کنسنسس ووٹنگ کے عمل میں ایک واحد نوڈ کا وزن براہ راست اس کمپیوٹنگ پاور کے متناسب ہے جو نوڈ لاتا ہے۔ اس کے بعد سے، ایک متبادل طریقہ تجویز کیا گیا ہے جسے _پروف-آف-اسٹیک_ کہا جاتا ہے، جو ایک نوڈ کے وزن کا حساب اس کی کرنسی ہولڈنگز کے متناسب کرتا ہے نہ کہ کمپیوٹیشنل وسائل کے؛ دونوں طریقوں کے نسبتی فوائد کی بحث اس مقالے کے دائرہ کار سے باہر ہے لیکن یہ نوٹ کیا جانا چاہئے کہ دونوں طریقے ایک کریپٹو کرنسی کی ریڑھ کی ہڈی کے طور پر کام کرنے کے لیے استعمال کیے جا سکتے ہیں۔

### Bitcoin ایک اسٹیٹ ٹرانزیشن سسٹم کے طور پر {#bitcoin-as-a-state-transition-system}

![ایتھیریم اسٹیٹ ٹرانزیشن](./ethereum-state-transition.png)

تکنیکی نقطہ نظر سے، Bitcoin جیسی کریپٹو کرنسی کے لیجر کو ایک اسٹیٹ ٹرانزیشن سسٹم کے طور پر سمجھا جا سکتا ہے، جہاں ایک \"اسٹیٹ\" موجود تمام بٹ کوائنز کی ملکیت کی حیثیت پر مشتمل ہوتا ہے اور ایک \"اسٹیٹ ٹرانزیشن فنکشن\" ہوتا ہے جو ایک اسٹیٹ اور ایک ٹرانزیکشن لیتا ہے اور ایک نیا اسٹیٹ آؤٹ پٹ کرتا ہے جو نتیجہ ہوتا ہے۔ ایک معیاری بینکنگ سسٹم میں، مثال کے طور پر، اسٹیٹ ایک بیلنس شیٹ ہے، ایک ٹرانزیکشن A سے B میں $X منتقل کرنے کی درخواست ہے، اور اسٹیٹ ٹرانزیشن فنکشن A کے اکاؤنٹ میں قدر کو $X سے کم کرتا ہے اور B کے اکاؤنٹ میں قدر کو $X سے بڑھاتا ہے۔ اگر A کے اکاؤنٹ میں پہلے سے $X سے کم ہے، تو اسٹیٹ ٹرانزیشن فنکشن ایک خرابی واپس کرتا ہے۔ لہذا، کوئی باضابطہ طور پر تعریف کر سکتا ہے:

```
APPLY(S,TX) -> S' or ERROR
```

اوپر بیان کردہ بینکنگ سسٹم میں:

```js
APPLY({ Alice: $50, Bob: $50 },\"send $20 from Alice to Bob\") = { Alice: $30, Bob: $70 }
```

لیکن:

```js
APPLY({ Alice: $50, Bob: $50 },\"send $70 from Alice to Bob\") = ERROR
```

Bitcoin میں \"اسٹیٹ\" تمام سکوں کا مجموعہ ہے (تکنیکی طور پر، \"غیر خرچ شدہ ٹرانزیکشن آؤٹ پٹس\" یا UTXO) جو بنائے گئے ہیں اور ابھی تک خرچ نہیں ہوئے ہیں، ہر UTXO کا ایک ڈینومینیشن اور ایک مالک ہوتا ہے (جس کی تعریف 20 بائٹ کے ایڈریس سے ہوتی ہے جو بنیادی طور پر ایک کرپٹوگرافک پبلک کی<sup>[fn1](#notes)</sup> ہے)۔ ایک ٹرانزیکشن میں ایک یا زیادہ ان پٹس ہوتے ہیں، ہر ان پٹ میں ایک موجودہ UTXO کا حوالہ اور مالک کے ایڈریس سے وابستہ پرائیویٹ کی کے ذریعے تیار کردہ ایک کرپٹوگرافک دستخط ہوتا ہے، اور ایک یا زیادہ آؤٹ پٹس ہوتے ہیں، ہر آؤٹ پٹ میں ایک نیا UTXO ہوتا ہے جسے اسٹیٹ میں شامل کیا جاتا ہے۔

اسٹیٹ ٹرانزیشن فنکشن `APPLY(S,TX) -> S'` کو تقریباً اس طرح بیان کیا جا سکتا ہے:

<ol>
  <li>
    <code>TX</code> میں ہر ان پٹ کے لیے:
    <ul>
    <li>
        اگر حوالہ دیا گیا UTXO <code>S</code> میں نہیں ہے، تو ایک خرابی واپس کریں۔
    </li>
    <li>
        اگر فراہم کردہ دستخط UTXO کے مالک سے میل نہیں کھاتا ہے، تو ایک خرابی واپس کریں۔
    </li>
    </ul>
  </li>
  <li>
    اگر تمام ان پٹ UTXO کے ڈینومینیشنز کا مجموعہ تمام آؤٹ پٹ UTXO کے ڈینومینیشنز کے مجموعے سے کم ہے، تو ایک خرابی واپس کریں۔
  </li>
  <li>
    تمام ان پٹ UTXO کو ہٹا کر اور تمام آؤٹ پٹ UTXO کو شامل کرکے <code>S</code> واپس کریں۔
  </li>
</ol>

پہلے مرحلے کا پہلا نصف ٹرانزیکشن بھیجنے والوں کو ایسے سکے خرچ کرنے سے روکتا ہے جو موجود نہیں ہیں، پہلے مرحلے کا دوسرا نصف ٹرانزیکشن بھیجنے والوں کو دوسرے لوگوں کے سکے خرچ کرنے سے روکتا ہے، اور دوسرا مرحلہ قدر کے تحفظ کو نافذ کرتا ہے۔ اسے ادائیگی کے لیے استعمال کرنے کے لیے، پروٹوکول مندرجہ ذیل ہے: فرض کریں ایلس باب کو 11.7 BTC بھیجنا چاہتی ہے۔ سب سے پہلے، ایلس اپنے ملکیت والے دستیاب UTXO کا ایک سیٹ تلاش کرے گی جس کا کل کم از کم 11.7 BTC ہو۔ حقیقت میں، ایلس کو بالکل 11.7 BTC نہیں مل پائے گا؛ مان لیں کہ سب سے چھوٹا جو وہ حاصل کر سکتی ہے وہ 6+4+2=12 ہے۔ پھر وہ ان تین ان پٹس اور دو آؤٹ پٹس کے ساتھ ایک ٹرانزیکشن بناتی ہے۔ پہلا آؤٹ پٹ 11.7 BTC ہوگا جس کا مالک باب کا ایڈریس ہوگا، اور دوسرا آؤٹ پٹ باقی 0.3 BTC \"چینج\" ہوگا، جس کی مالک خود ایلس ہوگی۔

### مائننگ {#mining}

![ایتھیریم بلاکس](./ethereum-blocks.png)

اگر ہمارے پاس ایک قابل اعتماد مرکزی سروس تک رسائی ہوتی، تو اس سسٹم کو نافذ کرنا بہت آسان ہوتا؛ اسے بالکل بیان کردہ طریقے سے کوڈ کیا جا سکتا تھا، اسٹیٹ کا ٹریک رکھنے کے لیے ایک مرکزی سرور کی ہارڈ ڈرائیو کا استعمال کرتے ہوئے۔ تاہم، Bitcoin کے ساتھ ہم ایک ڈی سینٹرلائزڈ کرنسی سسٹم بنانے کی کوشش کر رہے ہیں، لہذا ہمیں اسٹیٹ ٹرانزیکشن سسٹم کو ایک کنسنسس سسٹم کے ساتھ ملانے کی ضرورت ہوگی تاکہ یہ یقینی بنایا جا سکے کہ ہر کوئی ٹرانزیکشنز کی ترتیب پر متفق ہے۔ Bitcoin کے ڈی سینٹرلائزڈ کنسنسس کے عمل میں نیٹ ورک میں نوڈز سے مسلسل ٹرانزیکشنز کے پیکیجز تیار کرنے کی کوشش کی ضرورت ہوتی ہے جنہیں \"بلاکس\" کہا جاتا ہے۔ نیٹ ورک کا مقصد تقریباً ہر دس منٹ میں ایک بلاک تیار کرنا ہے، ہر بلاک میں ایک ٹائم اسٹیمپ، ایک نانس، پچھلے بلاک کا حوالہ (یعنی ہیش) اور پچھلے بلاک کے بعد ہونے والی تمام ٹرانزیکشنز کی فہرست ہوتی ہے۔ وقت کے ساتھ، یہ ایک مستقل، ہمیشہ بڑھتی ہوئی، \"بلاک چین\" بناتا ہے جو Bitcoin لیجر کی تازہ ترین حالت کی نمائندگی کرنے کے لیے مسلسل اپ ڈیٹ ہوتی رہتی ہے۔

اس پیراڈائم میں، ایک بلاک کے درست ہونے کی جانچ کا الگورتھم مندرجہ ذیل ہے:

1. چیک کریں کہ بلاک کے ذریعے حوالہ دیا گیا پچھلا بلاک موجود ہے اور درست ہے۔
2. چیک کریں کہ بلاک کا ٹائم اسٹیمپ پچھلے بلاک<sup>[fn2](#notes)</sup> کے ٹائم اسٹیمپ سے زیادہ ہے اور مستقبل میں 2 گھنٹے سے کم ہے۔
3. چیک کریں کہ بلاک پر پروف-آف-ورک درست ہے۔
4. `S[0]` کو پچھلے بلاک کے آخر میں اسٹیٹ ہونے دیں۔
5. فرض کریں `TX` `n` ٹرانزیکشنز کے ساتھ بلاک کی ٹرانزیکشن فہرست ہے۔ `0...n-1` میں تمام `i` کے لیے، `S[i+1] = APPLY(S[i],TX[i])` سیٹ کریں۔ اگر کوئی ایپلیکیشن خرابی واپس کرتی ہے، تو باہر نکلیں اور غلط واپس کریں۔
6. صحیح واپس کریں، اور `S[n]` کو اس بلاک کے آخر میں اسٹیٹ کے طور پر رجسٹر کریں۔

بنیادی طور پر، بلاک میں ہر ٹرانزیکشن کو اس کینونیکل اسٹیٹ سے جو ٹرانزیکشن کے عمل سے پہلے تھی، کسی نئے اسٹیٹ میں ایک درست اسٹیٹ ٹرانزیشن فراہم کرنا ضروری ہے۔ نوٹ کریں کہ اسٹیٹ کو بلاک میں کسی بھی طرح سے انکوڈ نہیں کیا گیا ہے؛ یہ خالصتاً ایک تجرید ہے جسے توثیق کرنے والے نوڈ کے ذریعے یاد رکھا جانا ہے اور اسے کسی بھی بلاک کے لیے صرف (محفوظ طریقے سے) جینیسس اسٹیٹ سے شروع کرکے اور ہر بلاک میں ہر ٹرانزیکشن کو ترتیب وار لاگو کرکے ہی شمار کیا جا سکتا ہے۔ مزید برآں، نوٹ کریں کہ جس ترتیب میں مائنر ٹرانزیکشنز کو بلاک میں شامل کرتا ہے وہ اہمیت رکھتا ہے؛ اگر ایک بلاک میں دو ٹرانزیکشنز A اور B ہیں اس طرح کہ B، A کے ذریعے بنائے گئے UTXO کو خرچ کرتا ہے، تو بلاک درست ہوگا اگر A، B سے پہلے آئے لیکن بصورت دیگر نہیں۔

مندرجہ بالا فہرست میں موجود ایک توثیقی شرط جو دوسرے سسٹمز میں نہیں پائی جاتی ہے وہ \"پروف-آف-ورک\" کی ضرورت ہے۔ عین شرط یہ ہے کہ ہر بلاک کا ڈبل-SHA256 ہیش، جسے 256 بٹ نمبر کے طور پر مانا جاتا ہے، ایک متحرک طور پر ایڈجسٹ کردہ ہدف سے کم ہونا چاہئے، جو اس تحریر کے وقت تقریباً 2<sup>187</sup> ہے۔ اس کا مقصد بلاک کی تخلیق کو کمپیوٹیشنلی \"مشکل\" بنانا ہے، اس طرح سائبل حملہ آوروں کو پوری بلاک چین کو اپنے حق میں دوبارہ بنانے سے روکا جا سکے۔ چونکہ SHA256 کو ایک مکمل طور پر غیر متوقع سیوڈو-رینڈم فنکشن کے طور پر ڈیزائن کیا گیا ہے، ایک درست بلاک بنانے کا واحد طریقہ صرف ٹرائل اینڈ ایرر ہے، نونس کو بار بار بڑھانا اور یہ دیکھنا کہ آیا نیا ہیش میل کھاتا ہے۔

موجودہ ہدف ~2<sup>187</sup> پر، نیٹ ورک کو ایک درست بلاک ملنے سے پہلے اوسطاً ~2<sup>69</sup> کوششیں کرنی پڑتی ہیں؛ عام طور پر، ہدف کو نیٹ ورک کے ذریعے ہر 2016 بلاکس پر دوبارہ کیلیبریٹ کیا جاتا ہے تاکہ اوسطاً ہر دس منٹ میں نیٹ ورک میں کسی نوڈ کے ذریعے ایک نیا بلاک تیار کیا جا سکے۔ اس کمپیوٹیشنل کام کے لیے مائنرز کو معاوضہ دینے کے لیے، ہر بلاک کا مائنر ایک ٹرانزیکشن شامل کرنے کا حقدار ہے جو خود کو کہیں سے بھی 25 BTC دیتا ہے۔ مزید برآں، اگر کسی ٹرانزیکشن کے ان پٹس میں اس کے آؤٹ پٹس سے زیادہ کل ڈینومینیشن ہے، تو فرق بھی مائنر کو بطور \"ٹرانزیکشن فیس\" جاتا ہے۔ اتفاق سے، یہ واحد میکانزم بھی ہے جس کے ذریعے BTC جاری کیے جاتے ہیں؛ جینیسس اسٹیٹ میں کوئی سکے نہیں تھے۔

مائننگ کے مقصد کو بہتر طور پر سمجھنے کے لیے، آئیے ہم ایک بدنیتی پر مبنی حملہ آور کی صورت میں کیا ہوتا ہے اس کا جائزہ لیں۔ چونکہ Bitcoin کی بنیادی کرپٹوگرافی کو محفوظ مانا جاتا ہے، حملہ آور Bitcoin سسٹم کے اس ایک حصے کو نشانہ بنائے گا جو براہ راست کرپٹوگرافی سے محفوظ نہیں ہے: ٹرانزیکشنز کی ترتیب۔ حملہ آور کی حکمت عملی سادہ ہے:

1. کسی پروڈکٹ کے بدلے میں ایک مرچنٹ کو 100 BTC بھیجیں (ترجیحاً ایک تیز رفتار ڈیجیٹل سامان)
2. پروڈکٹ کی ڈیلیوری کا انتظار کریں
3. ایک اور ٹرانزیکشن تیار کریں جس میں وہی 100 BTC خود کو بھیجے جائیں
4. نیٹ ورک کو یہ باور کرانے کی کوشش کریں کہ خود کو بھیجی گئی اس کی ٹرانزیکشن پہلے آئی تھی۔

ایک بار جب مرحلہ (1) ہو جاتا ہے، چند منٹوں کے بعد کوئی مائنر ٹرانزیکشن کو ایک بلاک میں شامل کر لے گا، مان لیں کہ بلاک نمبر 270000 ہے۔ تقریباً ایک گھنٹے کے بعد، اس بلاک کے بعد چین میں مزید پانچ بلاکس شامل ہو جائیں گے، جن میں سے ہر بلاک بالواسطہ طور پر ٹرانزیکشن کی طرف اشارہ کرے گا اور اس طرح اسے \"تصدیق\" کرے گا۔ اس مقام پر، مرچنٹ ادائیگی کو حتمی طور پر قبول کرے گا اور پروڈکٹ کی ڈیلیوری کرے گا؛ چونکہ ہم یہ فرض کر رہے ہیں کہ یہ ایک ڈیجیٹل سامان ہے، ڈیلیوری فوری ہے۔ اب، حملہ آور ایک اور ٹرانزیکشن بناتا ہے جس میں 100 BTC خود کو بھیجے جاتے ہیں۔ اگر حملہ آور اسے صرف کھلے عام جاری کرتا ہے، تو ٹرانزیکشن پر کارروائی نہیں کی جائے گی؛ مائنرز `APPLY(S,TX)` چلانے کی کوشش کریں گے اور دیکھیں گے کہ `TX` ایک ایسے UTXO کا استعمال کرتا ہے جو اب اسٹیٹ میں نہیں ہے۔ تو اس کے بجائے، حملہ آور بلاک چین کا ایک \"فورک\" بناتا ہے، بلاک 270000 کا ایک اور ورژن مائننگ کرکے شروع کرتا ہے جو اسی بلاک 269999 کو پیرنٹ کے طور پر اشارہ کرتا ہے لیکن پرانے کی جگہ نئی ٹرانزیکشن کے ساتھ۔ چونکہ بلاک ڈیٹا مختلف ہے، اس کے لیے پروف-آف-ورک کو دوبارہ کرنے کی ضرورت ہے۔ مزید برآں، حملہ آور کے بلاک 270000 کے نئے ورژن کا ایک مختلف ہیش ہے، لہذا اصل بلاکس 270001 سے 270005 اس کی طرف \"اشارہ\" نہیں کرتے ہیں؛ اس طرح، اصل چین اور حملہ آور کی نئی چین مکمل طور پر الگ ہیں۔ اصول یہ ہے کہ ایک فورک میں سب سے لمبی بلاک چین کو سچ مانا جاتا ہے، اور اس لیے جائز مائنرز 270005 چین پر کام کریں گے جبکہ حملہ آور اکیلے 270000 چین پر کام کر رہا ہوگا۔ حملہ آور کو اپنی بلاک چین کو سب سے لمبا بنانے کے لیے، اسے باقی نیٹ ورک سے زیادہ کمپیوٹیشنل پاور کی ضرورت ہوگی تاکہ وہ پکڑ سکے (لہذا، \"51% حملہ\")۔

### مرکل ٹریز {#merkle-trees}

![Bitcoin میں SPV](./spv-bitcoin.png)

_بائیں: ایک شاخ کی صداقت کا ثبوت دینے کے لیے مرکل ٹری میں صرف چند نوڈز پیش کرنا کافی ہے۔_

_دائیں: مرکل ٹری کے کسی بھی حصے کو تبدیل کرنے کی کوئی بھی کوشش بالآخر چین میں کہیں اوپر ایک عدم مطابقت کا باعث بنے گی۔_

Bitcoin کی ایک اہم اسکیل ایبلٹی خصوصیت یہ ہے کہ بلاک کو ایک ملٹی لیول ڈیٹا اسٹرکچر میں محفوظ کیا جاتا ہے۔ ایک بلاک کا \"ہیش\" دراصل صرف بلاک ہیڈر کا ہیش ہوتا ہے، جو تقریباً 200-بائٹ کا ڈیٹا کا ٹکڑا ہے جس میں ٹائم اسٹیمپ، نونس، پچھلے بلاک کا ہیش اور مرکل ٹری نامی ڈیٹا اسٹرکچر کا روٹ ہیش ہوتا ہے جو بلاک میں تمام ٹرانزیکشنز کو محفوظ کرتا ہے۔ ایک مرکل ٹری ایک قسم کا بائنری ٹری ہے، جو نوڈز کے ایک سیٹ پر مشتمل ہوتا ہے جس میں ٹری کے نچلے حصے میں بڑی تعداد میں لیف نوڈز ہوتے ہیں جن میں بنیادی ڈیٹا ہوتا ہے، انٹرمیڈیٹ نوڈز کا ایک سیٹ جہاں ہر نوڈ اپنے دو بچوں کا ہیش ہوتا ہے، اور آخر میں ایک واحد روٹ نوڈ، جو اپنے دو بچوں کے ہیش سے بھی بنتا ہے، ٹری کے \"ٹاپ\" کی نمائندگی کرتا ہے۔ مرکل ٹری کا مقصد یہ ہے کہ بلاک میں موجود ڈیٹا کو ٹکڑوں میں فراہم کیا جا سکے: ایک نوڈ ایک ذریعہ سے صرف ایک بلاک کا ہیڈر ڈاؤن لوڈ کر سکتا ہے، دوسرے ذریعہ سے ٹری کا چھوٹا سا حصہ جو ان سے متعلقہ ہے، اور پھر بھی یقین دہانی کر سکتا ہے کہ تمام ڈیٹا درست ہے۔ یہ کام کرنے کی وجہ یہ ہے کہ ہیشز اوپر کی طرف پھیلتے ہیں: اگر کوئی بدنیتی پر مبنی صارف مرکل ٹری کے نچلے حصے میں ایک جعلی ٹرانزیکشن کو تبدیل کرنے کی کوشش کرتا ہے، تو یہ تبدیلی اوپر والے نوڈ میں تبدیلی کا سبب بنے گی، اور پھر اس سے اوپر والے نوڈ میں تبدیلی کا سبب بنے گی، بالآخر ٹری کے روٹ کو تبدیل کر دے گی اور اس لیے بلاک کے ہیش کو، جس سے پروٹوکول اسے ایک مکمل طور پر مختلف بلاک کے طور پر رجسٹر کرے گا (تقریباً یقینی طور پر ایک غلط پروف-آف-ورک کے ساتھ)۔

مرکل ٹری پروٹوکول طویل مدتی پائیداری کے لیے بلاشبہ ضروری ہے۔ Bitcoin نیٹ ورک میں ایک \"فل نوڈ\"، جو ہر بلاک کی پوری کو محفوظ اور پروسیس کرتا ہے، اپریل 2014 تک Bitcoin نیٹ ورک میں تقریباً 15 جی بی ڈسک کی جگہ لیتا ہے، اور ہر ماہ ایک گیگا بائٹ سے زیادہ بڑھ رہا ہے۔ فی الحال، یہ کچھ ڈیسک ٹاپ کمپیوٹرز کے لیے قابل عمل ہے اور فونز کے لیے نہیں، اور بعد میں مستقبل میں صرف کاروبار اور شوقین افراد ہی حصہ لے سکیں گے۔ ایک پروٹوکول جسے \"آسان ادائیگی کی توثیق\" (SPV) کے نام سے جانا جاتا ہے، ایک اور قسم کے نوڈز کو موجود ہونے کی اجازت دیتا ہے، جنہیں \"لائٹ نوڈز\" کہا جاتا ہے، جو بلاک ہیڈرز کو ڈاؤن لوڈ کرتے ہیں، بلاک ہیڈرز پر پروف-آف-ورک کی توثیق کرتے ہیں، اور پھر صرف ان ٹرانزیکشنز سے وابستہ \"برانچز\" کو ڈاؤن لوڈ کرتے ہیں جو ان سے متعلقہ ہیں۔ یہ لائٹ نوڈز کو سیکیورٹی کی مضبوط ضمانت کے ساتھ یہ تعین کرنے کی اجازت دیتا ہے کہ کسی بھی Bitcoin ٹرانزیکشن کی حیثیت، اور ان کا موجودہ بیلنس کیا ہے، جبکہ پوری بلاک چین کا صرف ایک بہت چھوٹا حصہ ڈاؤن لوڈ کرتے ہیں۔

### متبادل بلاک چین ایپلی کیشنز {#alternative-blockchain-applications}

بنیادی بلاک چین کے خیال کو لے کر اسے دوسرے تصورات پر لاگو کرنے کا خیال بھی ایک طویل تاریخ رکھتا ہے۔ 2005 میں، Nick Szabo نے "[مالک کے اختیار کے ساتھ محفوظ پراپرٹی ٹائٹلز](https://nakamotoinstitute.org/library/secure-property-titles/)" کا تصور پیش کیا، ایک دستاویز جس میں بتایا گیا ہے کہ کس طرح "ریپلیکیٹڈ ڈیٹا بیس ٹیکنالوجی میں نئی پیشرفت" ایک بلاک چین پر مبنی نظام کی اجازت دے گی جو اس بات کی رجسٹری کو ذخیرہ کرنے کے لیے ہے کہ کون سی زمین کس کی ملکیت ہے، جس میں ہومسٹیڈنگ، ایڈورس پوزیشن اور جارجیائی لینڈ ٹیکس جیسے تصورات شامل ہیں۔ تاہم، بدقسمتی سے اس وقت کوئی موثر نقل شدہ ڈیٹا بیس سسٹم دستیاب نہیں تھا، اور اس لیے پروٹوکول کو عملی طور پر کبھی نافذ نہیں کیا گیا۔ 2009 کے بعد، تاہم، جب Bitcoin کا ڈی سینٹرلائزڈ کنسنسس تیار ہو گیا تو کئی متبادل ایپلی کیشنز تیزی سے ابھرنا شروع ہو گئیں۔

- **Namecoin** - 2010 میں بنایا گیا، [Namecoin](https://namecoin.org/) کو بہترین طور پر ایک ڈی سینٹرلائزڈ نام کی رجسٹریشن ڈیٹا بیس کے طور پر بیان کیا جا سکتا ہے۔ Tor، Bitcoin اور BitMessage جیسے ڈی سینٹرلائزڈ پروٹوکولز میں، اکاؤنٹس کی شناخت کا کوئی طریقہ ہونا چاہئے تاکہ دوسرے لوگ ان کے ساتھ بات چیت کر سکیں، لیکن تمام موجودہ حلوں میں دستیاب واحد قسم کا شناخت کنندہ `1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy` جیسا ایک سیوڈو-رینڈم ہیش ہے۔ مثالی طور پر، کوئی شخص \"george\" جیسے نام والا اکاؤنٹ رکھنے کے قابل ہونا چاہے گا۔ تاہم، مسئلہ یہ ہے کہ اگر ایک شخص \"george\" نامی اکاؤنٹ بنا سکتا ہے تو کوئی اور بھی اسی عمل کا استعمال کرکے اپنے لیے \"george\" رجسٹر کر سکتا ہے اور ان کی نقالی کر سکتا ہے۔ واحد حل فرسٹ-ٹو-فائل پیراڈائم ہے، جہاں پہلا رجسٹر کرنے والا کامیاب ہوتا ہے اور دوسرا ناکام - ایک مسئلہ جو Bitcoin کنسنسس پروٹوکول کے لیے بالکل موزوں ہے۔ Namecoin اس طرح کے خیال کا استعمال کرتے ہوئے نام کی رجسٹریشن کے نظام کا سب سے پرانا اور سب سے کامیاب نفاذ ہے۔
- **کلرڈ کوائنز** - [کلرڈ کوائنز](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit) کا مقصد ایک پروٹوکول کے طور پر کام کرنا ہے تاکہ لوگ اپنی ڈیجیٹل کرنسیاں بنا سکیں - یا، ایک یونٹ والی کرنسی کے اہم معمولی معاملے میں، Bitcoin بلاک چین پر ڈیجیٹل ٹوکنز۔ کلرڈ کوائنز پروٹوکول میں، کوئی ایک نئی کرنسی \"جاری\" کرتا ہے عوامی طور پر ایک مخصوص Bitcoin UTXO کو ایک رنگ تفویض کرکے، اور پروٹوکول دوسرے UTXO کے رنگ کو ان ان پٹس کے رنگ کے برابر ریکرسیولی طور پر بیان کرتا ہے جو انہیں بنانے والی ٹرانزیکشن نے خرچ کیے تھے (مخلوط رنگ کے ان پٹس کی صورت میں کچھ خاص اصول لاگو ہوتے ہیں)۔ یہ صارفین کو صرف ایک مخصوص رنگ کے UTXO والے والیٹس کو برقرار رکھنے اور انہیں باقاعدہ بٹ کوائنز کی طرح بھیجنے کی اجازت دیتا ہے، جو بھی UTXO وہ وصول کرتے ہیں اس کا رنگ تعین کرنے کے لیے بلاک چین کے ذریعے بیک ٹریکنگ کرتے ہیں۔
- **Metacoins** - ایک میٹا کوائن کے پیچھے کا خیال یہ ہے کہ ایک پروٹوکول ہو جو Bitcoin کے اوپر رہتا ہے، میٹا کوائن ٹرانزیکشنز کو ذخیرہ کرنے کے لیے Bitcoin ٹرانزیکشنز کا استعمال کرتا ہے لیکن ایک مختلف اسٹیٹ ٹرانزیشن فنکشن، `APPLY'` رکھتا ہے۔ چونکہ میٹا کوائن پروٹوکول Bitcoin بلاک چین میں غلط میٹا کوائن ٹرانزیکشنز کو ظاہر ہونے سے نہیں روک سکتا، ایک اصول شامل کیا گیا ہے کہ اگر `APPLY'(S,TX)` ایک خرابی واپس کرتا ہے، تو پروٹوکول `APPLY'(S,TX) = S` پر ڈیفالٹ ہو جاتا ہے۔ یہ ایک من مانی کریپٹو کرنسی پروٹوکول بنانے کے لیے ایک آسان میکانزم فراہم کرتا ہے، ممکنہ طور پر جدید خصوصیات کے ساتھ جو Bitcoin کے اندر ہی نافذ نہیں کی جا سکتیں، لیکن بہت کم ترقیاتی لاگت کے ساتھ کیونکہ مائننگ اور نیٹ ورکنگ کی پیچیدگیاں پہلے ہی Bitcoin پروٹوکول کے ذریعے سنبھالی جاتی ہیں۔ Metacoins کو کچھ قسم کے مالیاتی معاہدوں، نام کی رجسٹریشن اور ڈی سینٹرلائزڈ ایکسچینج کو نافذ کرنے کے لیے استعمال کیا گیا ہے۔

اس طرح، عام طور پر، ایک کنسنسس پروٹوکول بنانے کے دو طریقے ہیں: ایک آزاد نیٹ ورک بنانا، اور Bitcoin کے اوپر ایک پروٹوکول بنانا۔ پہلا طریقہ، اگرچہ Namecoin جیسی ایپلی کیشنز کی صورت میں معقول حد تک کامیاب ہے، نافذ کرنا مشکل ہے؛ ہر انفرادی نفاذ کو ایک آزاد بلاک چین کو بوٹ اسٹریپ کرنے کی ضرورت ہے، نیز تمام ضروری اسٹیٹ ٹرانزیشن اور نیٹ ورکنگ کوڈ کی تعمیر اور جانچ کی بھی۔ مزید برآں، ہم پیش گوئی کرتے ہیں کہ ڈی سینٹرلائزڈ کنسنسس ٹیکنالوجی کے لیے ایپلی کیشنز کا سیٹ ایک پاور لاء ڈسٹری بیوشن کی پیروی کرے گا جہاں ایپلی کیشنز کی بڑی اکثریت اپنی بلاک چین کی ضمانت دینے کے لیے بہت چھوٹی ہوگی، اور ہم نوٹ کرتے ہیں کہ ڈی سینٹرلائزڈ ایپلی کیشنز کی بڑی کلاسیں موجود ہیں، خاص طور پر ڈی سینٹرلائزڈ خود مختار تنظیمیں، جنہیں ایک دوسرے کے ساتھ بات چیت کرنے کی ضرورت ہے۔

دوسری طرف، Bitcoin پر مبنی نقطہ نظر میں یہ خامی ہے کہ یہ Bitcoin کی آسان ادائیگی کی توثیق کی خصوصیات کو وراثت میں نہیں لیتا ہے۔ SPV Bitcoin کے لیے کام کرتا ہے کیونکہ یہ بلاک چین کی گہرائی کو توثیق کے لیے ایک پراکسی کے طور پر استعمال کر سکتا ہے؛ کسی وقت، جب کسی ٹرانزیکشن کے آباؤ اجداد کافی پیچھے چلے جاتے ہیں، تو یہ کہنا محفوظ ہے کہ وہ جائز طور پر اسٹیٹ کا حصہ تھے۔ دوسری طرف، بلاک چین پر مبنی میٹا پروٹوکولز، بلاک چین کو ان ٹرانزیکشنز کو شامل نہ کرنے پر مجبور نہیں کر سکتے جو ان کے اپنے پروٹوکولز کے تناظر میں درست نہیں ہیں۔ لہذا، ایک مکمل طور پر محفوظ SPV میٹا پروٹوکول کے نفاذ کو یہ تعین کرنے کے لیے کہ آیا کچھ ٹرانزیکشنز درست ہیں یا نہیں، Bitcoin بلاک چین کے آغاز تک پیچھے کی طرف اسکین کرنے کی ضرورت ہوگی۔ فی الحال، Bitcoin پر مبنی میٹا پروٹوکولز کے تمام \"لائٹ\" نفاذات ڈیٹا فراہم کرنے کے لیے ایک قابل اعتماد سرور پر انحصار کرتے ہیں، جو بلاشبہ ایک انتہائی غیر بہترین نتیجہ ہے خاص طور پر جب ایک کریپٹو کرنسی کے بنیادی مقاصد میں سے ایک اعتماد کی ضرورت کو ختم کرنا ہے۔

### اسکرپٹنگ {#scripting}

کسی بھی توسیع کے بغیر بھی، Bitcoin پروٹوکول دراصل \"اسمارٹ کنٹریکٹس\" کے تصور کے ایک کمزور ورژن کی سہولت فراہم کرتا ہے۔ Bitcoin میں UTXO کی ملکیت صرف ایک پبلک کی کے ذریعے ہی نہیں ہو سکتی، بلکہ ایک سادہ اسٹیک پر مبنی پروگرامنگ زبان میں ظاہر کردہ ایک زیادہ پیچیدہ اسکرپٹ کے ذریعے بھی ہو سکتی ہے۔ اس پیراڈائم میں، اس UTXO کو خرچ کرنے والی ٹرانزیکشن کو ایسا ڈیٹا فراہم کرنا ہوگا جو اسکرپٹ کو مطمئن کرے۔ درحقیقت، بنیادی پبلک کی کی ملکیت کا میکانزم بھی ایک اسکرپٹ کے ذریعے نافذ کیا جاتا ہے: اسکرپٹ ایک الیپٹک کرو دستخط کو ان پٹ کے طور پر لیتا ہے، اسے ٹرانزیکشن اور اس ایڈریس کے خلاف توثیق کرتا ہے جو UTXO کا مالک ہے، اور اگر توثیق کامیاب ہوتی ہے تو 1 واپس کرتا ہے ورنہ 0۔ دیگر، زیادہ پیچیدہ، اسکرپٹس مختلف اضافی استعمال کے معاملات کے لیے موجود ہیں۔ مثال کے طور پر، کوئی ایک ایسا اسکرپٹ بنا سکتا ہے جس میں توثیق کے لیے دی گئی تین پرائیویٹ کیز میں سے دو کے دستخط کی ضرورت ہو (\"ملٹی سگ\")، ایک سیٹ اپ جو کارپوریٹ اکاؤنٹس، محفوظ بچت اکاؤنٹس اور کچھ مرچنٹ ایسکرو حالات کے لیے مفید ہے۔ اسکرپٹس کو کمپیوٹیشنل مسائل کے حل کے لیے انعامات ادا کرنے کے لیے بھی استعمال کیا جا سکتا ہے، اور کوئی شخص ایک ایسا اسکرپٹ بھی بنا سکتا ہے جو کچھ اس طرح کہتا ہو کہ \"یہ Bitcoin UTXO آپ کا ہے اگر آپ SPV ثبوت فراہم کر سکتے ہیں کہ آپ نے مجھے اس ڈینومینیشن کا Dogecoin ٹرانزیکشن بھیجا ہے\"، جو بنیادی طور پر ڈی سینٹرلائزڈ کراس-کریپٹو کرنسی ایکسچینج کی اجازت دیتا ہے۔

تاہم، Bitcoin میں نافذ کردہ اسکرپٹنگ زبان کی کئی اہم حدود ہیں:

- **ٹورنگ-کمپلیٹنس کی کمی** - یعنی، جبکہ Bitcoin اسکرپٹنگ زبان کمپیوٹیشن کے ایک بڑے سب سیٹ کی حمایت کرتی ہے، یہ تقریباً ہر چیز کی حمایت نہیں کرتی ہے۔ اہم زمرہ جو غائب ہے وہ لوپس ہیں۔ یہ ٹرانزیکشن کی توثیق کے دوران لامحدود لوپس سے بچنے کے لیے کیا جاتا ہے؛ نظریاتی طور پر یہ اسکرپٹ پروگرامرز کے لیے ایک قابل تسخیر رکاوٹ ہے، کیونکہ کسی بھی لوپ کو صرف بنیادی کوڈ کو کئی بار ایک if اسٹیٹمنٹ کے ساتھ دہرا کر نقل کیا جا سکتا ہے، لیکن یہ ایسے اسکرپٹس کی طرف جاتا ہے جو بہت زیادہ جگہ استعمال کرتے ہیں۔ مثال کے طور پر، ایک متبادل الیپٹک کرو دستخطی الگورتھم کو نافذ کرنے کے لیے ممکنہ طور پر 256 بار بار ضرب کے راؤنڈز کی ضرورت ہوگی جو سبھی انفرادی طور پر کوڈ میں شامل ہوں۔
- **ویلیو-بلائنڈنس** - UTXO اسکرپٹ کے لیے اس رقم پر باریک کنٹرول فراہم کرنے کا کوئی طریقہ نہیں ہے جسے نکالا جا سکتا ہے۔ مثال کے طور پر، ایک اوریکل کنٹریکٹ کا ایک طاقتور استعمال کا معاملہ ایک ہیجنگ کنٹریکٹ ہوگا، جہاں A اور B $1000 مالیت کے BTC ڈالتے ہیں اور 30 دنوں کے بعد اسکرپٹ A کو $1000 مالیت کے BTC اور باقی B کو بھیجتا ہے۔ اس کے لیے 1 BTC کی قیمت USD میں تعین کرنے کے لیے ایک اوریکل کی ضرورت ہوگی، لیکن پھر بھی یہ مکمل طور پر مرکزی حلوں کے مقابلے میں اعتماد اور بنیادی ڈھانچے کی ضرورت کے لحاظ سے ایک بہت بڑی بہتری ہے جو اب دستیاب ہیں۔ تاہم، چونکہ UTXO سب کچھ یا کچھ نہیں ہوتے ہیں، اس کو حاصل کرنے کا واحد طریقہ مختلف مالیت کے بہت سے UTXO رکھنے کا بہت غیر موثر ہیک ہے (مثال کے طور پر، 30 تک ہر k کے لیے 2<sup>k</sup> کا ایک UTXO) اور اوریکل سے یہ انتخاب کروانا ہے کہ کون سا UTXO A کو بھیجنا ہے اور کون سا B کو۔
- **اسٹیٹ کی کمی** - UTXO یا تو خرچ ہو سکتا ہے یا غیر خرچ شدہ؛ کثیر-مرحلہ کنٹریکٹس یا اسکرپٹس کے لیے کوئی موقع نہیں ہے جو اس سے آگے کوئی اور اندرونی اسٹیٹ رکھتے ہوں۔ یہ کثیر-مرحلہ آپشنز کنٹریکٹس، ڈی سینٹرلائزڈ ایکسچینج آفرز یا دو-مرحلہ کرپٹوگرافک کمٹمنٹ پروٹوکولز (محفوظ کمپیوٹیشنل انعامات کے لیے ضروری) بنانا مشکل بناتا ہے۔ اس کا یہ بھی مطلب ہے کہ UTXO کو صرف سادہ، یک طرفہ کنٹریکٹس بنانے کے لیے استعمال کیا جا سکتا ہے نہ کہ زیادہ پیچیدہ \"اسٹیٹ فل\" کنٹریکٹس جیسے ڈی سینٹرلائزڈ تنظیمیں، اور میٹا پروٹوکولز کو نافذ کرنا مشکل بناتا ہے۔ بائنری اسٹیٹ اور ویلیو-بلائنڈنس کا یہ بھی مطلب ہے کہ ایک اور اہم ایپلی کیشن، نکالنے کی حدود، ناممکن ہے۔
- **بلاک چین-بلائنڈنس** - UTXO بلاک چین کے ڈیٹا جیسے نونس، ٹائم اسٹیمپ اور پچھلے بلاک ہیش سے اندھے ہیں۔ یہ اسکرپٹنگ زبان کو بے ترتیب پن کے ممکنہ طور پر قیمتی ذریعہ سے محروم کرکے جوئے اور کئی دیگر زمروں میں ایپلی کیشنز کو شدید طور پر محدود کرتا ہے۔

اس طرح، ہم کریپٹو کرنسی کے اوپر جدید ایپلی کیشنز بنانے کے تین طریقے دیکھتے ہیں: ایک نئی بلاک چین بنانا، Bitcoin کے اوپر اسکرپٹنگ کا استعمال کرنا، اور Bitcoin کے اوپر ایک میٹا پروٹوکول بنانا۔ ایک نئی بلاک چین بنانے سے فیچر سیٹ بنانے میں لامحدود آزادی ملتی ہے، لیکن ترقیاتی وقت، بوٹ اسٹریپنگ کی کوشش اور سیکیورٹی کی قیمت پر۔ اسکرپٹنگ کا استعمال نافذ کرنا اور معیاری بنانا آسان ہے، لیکن اس کی صلاحیتوں میں بہت محدود ہے، اور میٹا پروٹوکولز، جبکہ آسان ہیں، اسکیل ایبلٹی میں خامیوں کا شکار ہیں۔ ایتھیریم کے ساتھ، ہم ایک متبادل فریم ورک بنانے کا ارادہ رکھتے ہیں جو ترقی کی آسانی میں اور بھی زیادہ فوائد فراہم کرتا ہے اور ساتھ ہی ساتھ مضبوط لائٹ کلائنٹ خصوصیات بھی، جبکہ بیک وقت ایپلی کیشنز کو ایک اقتصادی ماحول اور بلاک چین سیکیورٹی کا اشتراک کرنے کی اجازت دیتا ہے۔

## ایتھیریم {#ethereum}

ایتھیریم کا ارادہ ڈی سینٹرلائزڈ ایپلی کیشنز کی تعمیر کے لیے ایک متبادل پروٹوکول بنانا ہے، جو تجارتی سمجھوتوں کا ایک مختلف سیٹ فراہم کرتا ہے جو ہمارے خیال میں ڈی سینٹرلائزڈ ایپلی کیشنز کی ایک بڑی کلاس کے لیے بہت مفید ہوگا، خاص طور پر ان حالات پر زور دیتے ہوئے جہاں تیز رفتار ترقیاتی وقت، چھوٹی اور شاذ و نادر ہی استعمال ہونے والی ایپلی کیشنز کے لیے سیکیورٹی، اور مختلف ایپلی کیشنز کی بہت موثر طریقے سے بات چیت کرنے کی صلاحیت اہم ہے۔ ایتھیریم یہ کام بنیادی طور پر حتمی تجریدی بنیادی پرت کی تعمیر کے ذریعے کرتا ہے: ایک بلاک چین جس میں بلٹ-ان ٹورنگ-کمپلیٹ پروگرامنگ زبان ہوتی ہے، جس سے کوئی بھی اسمارٹ کنٹریکٹس اور ڈی سینٹرلائزڈ ایپلی کیشنز لکھ سکتا ہے جہاں وہ ملکیت، ٹرانزیکشن فارمیٹس اور اسٹیٹ ٹرانزیشن فنکشنز کے لیے اپنے من مانی اصول بنا سکتے ہیں۔ Namecoin کا ایک بنیادی ورژن دو لائنوں کے کوڈ میں لکھا جا سکتا ہے، اور دیگر پروٹوکولز جیسے کرنسیاں اور شہرت کے نظام بیس سے کم میں بنائے جا سکتے ہیں۔ اسمارٹ کنٹریکٹس، کرپٹوگرافک \"باکس\" جو قدر رکھتے ہیں اور اسے صرف اس صورت میں کھولتے ہیں جب کچھ شرائط پوری ہوں، پلیٹ فارم کے اوپر بھی بنائے جا سکتے ہیں، ٹورنگ-کمپلیٹنس، ویلیو-اویرنس، بلاک چین-اویرنس اور اسٹیٹ کی اضافی طاقتوں کی وجہ سے Bitcoin اسکرپٹنگ کی پیشکش سے کہیں زیادہ طاقت کے ساتھ۔

### ایتھیریم اکاؤنٹس {#ethereum-accounts}

ایتھیریم میں، اسٹیٹ \"اکاؤنٹس\" نامی اشیاء پر مشتمل ہے، ہر اکاؤنٹ کا 20 بائٹ کا ایڈریس ہوتا ہے اور اسٹیٹ ٹرانزیشنز اکاؤنٹس کے درمیان قدر اور معلومات کی براہ راست منتقلی ہوتی ہیں۔ ایک ایتھیریم اکاؤنٹ میں چار فیلڈز ہوتے ہیں:

- **نونس**، ایک کاؤنٹر جو اس بات کو یقینی بنانے کے لیے استعمال ہوتا ہے کہ ہر ٹرانزیکشن صرف ایک بار پروسیس ہو سکے۔
- اکاؤنٹ کا موجودہ **ایتھر بیلنس**
- اکاؤنٹ کا **کنٹریکٹ کوڈ**، اگر موجود ہو
- اکاؤنٹ کا **اسٹوریج** (بطور ڈیفالٹ خالی)

\"ایتھر\" ایتھیریم کا مرکزی اندرونی کرپٹو-ایندھن ہے، اور اسے ٹرانزیکشن فیس ادا کرنے کے لیے استعمال کیا جاتا ہے۔ عام طور پر، دو قسم کے اکاؤنٹس ہوتے ہیں: **بیرونی طور پر ملکیت والے اکاؤنٹس**، جو پرائیویٹ کیز کے ذریعے کنٹرول کیے جاتے ہیں، اور **کنٹریکٹ اکاؤنٹس**، جو ان کے کنٹریکٹ کوڈ کے ذریعے کنٹرول کیے جاتے ہیں۔ ایک بیرونی طور پر ملکیت والے اکاؤنٹ کا کوئی کوڈ نہیں ہوتا ہے، اور کوئی شخص ایک ٹرانزیکشن بنا کر اور دستخط کرکے بیرونی طور پر ملکیت والے اکاؤنٹ سے پیغامات بھیج سکتا ہے؛ ایک کنٹریکٹ اکاؤنٹ میں، ہر بار جب کنٹریکٹ اکاؤنٹ کو کوئی پیغام ملتا ہے تو اس کا کوڈ فعال ہو جاتا ہے، جس سے وہ اندرونی اسٹوریج کو پڑھنے اور لکھنے اور دوسرے پیغامات بھیجنے یا بدلے میں کنٹریکٹس بنانے کی اجازت دیتا ہے۔

نوٹ کریں کہ ایتھیریم میں \"کنٹریکٹس\" کو ایسی چیز کے طور پر نہیں دیکھا جانا چاہئے جسے \"پورا کیا جانا\" یا \"تعمیل کی جانی\" چاہئے؛ بلکہ، وہ \"خود مختار ایجنٹس\" کی طرح ہیں جو ایتھیریم کے عملدرآمد کے ماحول کے اندر رہتے ہیں، ہمیشہ ایک پیغام یا ٹرانزیکشن کے ذریعے \"پوک\" کیے جانے پر کوڈ کا ایک مخصوص ٹکڑا عمل میں لاتے ہیں، اور اپنے ایتھر بیلنس اور مستقل متغیرات کا ٹریک رکھنے کے لیے اپنے کلید/قدر اسٹور پر براہ راست کنٹرول رکھتے ہیں۔

### پیغامات اور ٹرانزیکشنز {#messages-and-transactions}

\"ٹرانزیکشن\" کی اصطلاح ایتھیریم میں اس دستخط شدہ ڈیٹا پیکیج کا حوالہ دینے کے لیے استعمال کی جاتی ہے جو ایک بیرونی طور پر ملکیت والے اکاؤنٹ سے بھیجے جانے والے پیغام کو محفوظ کرتا ہے۔ ٹرانزیکشنز میں شامل ہیں:

- پیغام کا وصول کنندہ
- بھیجنے والے کی شناخت کرنے والا ایک دستخط
- بھیجنے والے سے وصول کنندہ کو منتقل کیے جانے والے ایتھر کی رقم
- ایک اختیاری ڈیٹا فیلڈ
- ایک `STARTGAS` قدر، جو کمپیوٹیشنل اقدامات کی زیادہ سے زیادہ تعداد کی نمائندگی کرتی ہے جو ٹرانزیکشن کے عملدرآمد کے لیے اجازت یافتہ ہے۔
- ایک `GASPRICE` قدر، جو اس فیس کی نمائندگی کرتی ہے جو بھیجنے والا ہر کمپیوٹیشنل قدم پر ادا کرتا ہے۔

پہلے تین کسی بھی کریپٹو کرنسی میں متوقع معیاری فیلڈز ہیں۔ ڈیٹا فیلڈ کا بطور ڈیفالٹ کوئی فنکشن نہیں ہوتا ہے، لیکن ورچوئل مشین میں ایک اوپ کوڈ ہوتا ہے جس کا استعمال کرتے ہوئے ایک کنٹریکٹ ڈیٹا تک رسائی حاصل کر سکتا ہے؛ مثال کے طور پر، اگر کوئی کنٹریکٹ آن-بلاک چین ڈومین رجسٹریشن سروس کے طور پر کام کر رہا ہے، تو وہ اس کو بھیجے جانے والے ڈیٹا کو دو \"فیلڈز\" پر مشتمل سمجھنا چاہے گا، پہلا فیلڈ رجسٹر کرنے کے لیے ایک ڈومین اور دوسرا فیلڈ اسے رجسٹر کرنے کے لیے آئی پی ایڈریس ہو۔ کنٹریکٹ ان قدروں کو پیغام کے ڈیٹا سے پڑھے گا اور انہیں مناسب طریقے سے اسٹوریج میں رکھے گا۔

`STARTGAS` اور `GASPRICE` فیلڈز ایتھیریم کے اینٹی-ڈینائل آف سروس ماڈل کے لیے اہم ہیں۔ کوڈ میں حادثاتی یا دشمنانہ لامحدود لوپس یا دیگر کمپیوٹیشنل ضیاع کو روکنے کے لیے، ہر ٹرانزیکشن کو کوڈ کے عملدرآمد کے کتنے کمپیوٹیشنل اقدامات استعمال کر سکتی ہے اس کی ایک حد مقرر کرنا ضروری ہے۔ کمپیوٹیشن کی بنیادی اکائی \"گیس\" ہے؛ عام طور پر، ایک کمپیوٹیشنل قدم کی لاگت 1 گیس ہوتی ہے، لیکن کچھ آپریشنز کی لاگت زیادہ گیس ہوتی ہے کیونکہ وہ کمپیوٹیشنلی طور پر زیادہ مہنگے ہوتے ہیں، یا اس ڈیٹا کی مقدار کو بڑھاتے ہیں جسے اسٹیٹ کے حصے کے طور پر محفوظ کیا جانا چاہئے۔ ٹرانزیکشن ڈیٹا میں ہر بائٹ کے لیے 5 گیس کی فیس بھی ہے۔ فیس سسٹم کا مقصد یہ ہے کہ ایک حملہ آور کو ہر اس وسیلہ کے لیے متناسب طور پر ادائیگی کرنے کی ضرورت ہو جس کا وہ استعمال کرتا ہے، بشمول کمپیوٹیشن، بینڈوڈتھ اور اسٹوریج؛ لہذا، کوئی بھی ٹرانزیکشن جو نیٹ ورک کو ان میں سے کسی بھی وسیلہ کی زیادہ مقدار استعمال کرنے کا باعث بنتی ہے اس کی گیس فیس تقریباً اضافے کے متناسب ہونی چاہئے۔

### پیغامات {#messages}

کنٹریکٹس میں دوسرے کنٹریکٹس کو \"پیغامات\" بھیجنے کی صلاحیت ہوتی ہے۔ پیغامات ورچوئل اشیاء ہیں جو کبھی بھی سیریلائز نہیں ہوتیں اور صرف ایتھیریم کے عملدرآمد کے ماحول میں موجود ہوتی ہیں۔ ایک پیغام میں شامل ہیں:

- پیغام کا بھیجنے والا (مضمر)
- پیغام کا وصول کنندہ
- پیغام کے ساتھ منتقل کیے جانے والے ایتھر کی رقم
- ایک اختیاری ڈیٹا فیلڈ
- ایک `STARTGAS` قدر

بنیادی طور پر، ایک پیغام ایک ٹرانزیکشن کی طرح ہے، سوائے اس کے کہ یہ ایک کنٹریکٹ کے ذریعے تیار کیا جاتا ہے نہ کہ کسی بیرونی اداکار کے ذریعے۔ ایک پیغام اس وقت تیار ہوتا ہے جب ایک کنٹریکٹ جو فی الحال کوڈ پر عمل کر رہا ہے `CALL` اوپ کوڈ پر عمل کرتا ہے، جو ایک پیغام تیار کرتا ہے اور اس پر عمل کرتا ہے۔ ایک ٹرانزیکشن کی طرح، ایک پیغام وصول کنندہ اکاؤنٹ کو اپنا کوڈ چلانے کا باعث بنتا ہے۔ اس طرح، کنٹریکٹس کے دوسرے کنٹریکٹس کے ساتھ بالکل اسی طرح تعلقات ہو سکتے ہیں جیسے بیرونی اداکاروں کے ہو سکتے ہیں۔

نوٹ کریں کہ ایک ٹرانزیکشن یا کنٹریکٹ کے ذریعے تفویض کردہ گیس الاؤنس اس ٹرانزیکشن اور تمام ذیلی-عملدرآمدات کے ذریعے استعمال ہونے والی کل گیس پر لاگو ہوتا ہے۔ مثال کے طور پر، اگر ایک بیرونی اداکار A، B کو 1000 گیس کے ساتھ ایک ٹرانزیکشن بھیجتا ہے، اور B، C کو ایک پیغام بھیجنے سے پہلے 600 گیس استعمال کرتا ہے، اور C کا اندرونی عملدرآمد واپس آنے سے پہلے 300 گیس استعمال کرتا ہے، تو B گیس ختم ہونے سے پہلے مزید 100 گیس خرچ کر سکتا ہے۔

### ایتھیریم اسٹیٹ ٹرانزیشن فنکشن {#ethereum-state-transition-function}

![ایتھر اسٹیٹ ٹرانزیشن](./ether-state-transition.png)

ایتھیریم اسٹیٹ ٹرانزیشن فنکشن، `APPLY(S,TX) -> S'` کو اس طرح بیان کیا جا سکتا ہے:

1. چیک کریں کہ آیا ٹرانزیکشن اچھی طرح سے تشکیل شدہ ہے (یعنی، اس میں اقدار کی صحیح تعداد ہے)، سگنیچر درست ہے، اور نانس بھیجنے والے کے اکاؤنٹ میں موجود نانس سے میل کھاتا ہے۔ اگر نہیں، تو ایک خرابی واپس کریں۔
2. ٹرانزیکشن فیس کا حساب `STARTGAS * GASPRICE` کے طور پر کریں، اور دستخط سے بھیجنے کا ایڈریس تعین کریں۔ فیس کو بھیجنے والے کے اکاؤنٹ بیلنس سے گھٹائیں اور بھیجنے والے کے نونس کو بڑھائیں۔ اگر خرچ کرنے کے لیے کافی بیلنس نہیں ہے، تو ایک خرابی واپس کریں۔
3. `GAS = STARTGAS` کو شروع کریں، اور ٹرانزیکشن میں بائٹس کی ادائیگی کے لیے فی بائٹ گیس کی ایک خاص مقدار نکالیں۔
4. ٹرانزیکشن کی قدر کو بھیجنے والے کے اکاؤنٹ سے وصول کرنے والے اکاؤنٹ میں منتقل کریں۔ اگر وصول کرنے والا اکاؤنٹ ابھی تک موجود نہیں ہے، تو اسے بنائیں۔ اگر وصول کرنے والا اکاؤنٹ ایک کنٹریکٹ ہے، تو کنٹریکٹ کا کوڈ یا تو تکمیل تک چلائیں یا جب تک عملدرآمد گیس سے باہر نہ ہو جائے۔
5. اگر قدر کی منتقلی ناکام ہو گئی کیونکہ بھیجنے والے کے پاس کافی رقم نہیں تھی، یا کوڈ کے عملدرآمد میں گیس ختم ہو گئی، تو فیس کی ادائیگی کے علاوہ تمام اسٹیٹ کی تبدیلیوں کو واپس کر دیں، اور فیس کو مائنر کے اکاؤنٹ میں شامل کر دیں۔
6. بصورت دیگر، بھیجنے والے کو تمام باقی گیس کے لیے فیس واپس کر دیں، اور استعمال شدہ گیس کے لیے ادا کی گئی فیس مائنر کو بھیج دیں۔

مثال کے طور پر، فرض کریں کہ کنٹریکٹ کا کوڈ یہ ہے:

```py
if !self.storage[calldataload(0)]:
  self.storage[calldataload(0)] = calldataload(32)
```

نوٹ کریں کہ حقیقت میں کنٹریکٹ کوڈ نچلے درجے کے EVM کوڈ میں لکھا جاتا ہے؛ یہ مثال وضاحت کے لیے ہماری اعلی سطحی زبانوں میں سے ایک، Serpent میں لکھی گئی ہے، اور اسے EVM کوڈ میں کمپائل کیا جا سکتا ہے۔ فرض کریں کہ کنٹریکٹ کا اسٹوریج شروع میں خالی ہے، اور 10 ایتھر کی قدر، 2000 گیس، 0.001 ایتھر گیس پرائس، اور 64 بائٹس ڈیٹا کے ساتھ ایک ٹرانزیکشن بھیجی جاتی ہے، جس میں بائٹس 0-31 نمبر `2` اور بائٹس 32-63 اسٹرنگ `CHARLIE` کی نمائندگی کرتے ہیں۔ اس معاملے میں اسٹیٹ ٹرانزیشن فنکشن کا عمل مندرجہ ذیل ہے:

1. چیک کریں کہ ٹرانزیکشن درست اور اچھی طرح سے تشکیل شدہ ہے۔
2. چیک کریں کہ ٹرانزیکشن بھیجنے والے کے پاس کم از کم 2000 \* 0.001 = 2 ایتھر ہیں۔ اگر ایسا ہے، تو بھیجنے والے کے اکاؤنٹ سے 2 ایتھر گھٹائیں۔
3. گیس کو 2000 پر شروع کریں؛ فرض کریں کہ ٹرانزیکشن 170 بائٹس لمبی ہے اور بائٹ-فیس 5 ہے، 850 گھٹائیں تاکہ 1150 گیس باقی رہے۔
4. بھیجنے والے کے اکاؤنٹ سے مزید 10 ایتھر گھٹائیں، اور اسے کنٹریکٹ کے اکاؤنٹ میں شامل کریں۔
5. کوڈ چلائیں۔ اس معاملے میں، یہ سادہ ہے: یہ چیک کرتا ہے کہ آیا کنٹریکٹ کا اسٹوریج انڈیکس `2` پر استعمال ہوا ہے، دیکھتا ہے کہ نہیں ہوا ہے، اور اس لیے یہ اسٹوریج کو انڈیکس `2` پر قدر `CHARLIE` پر سیٹ کرتا ہے۔ فرض کریں اس میں 187 گیس لگتی ہے، تو باقی گیس کی مقدار 1150 - 187 = 963 ہے
6. 963 \* 0.001 = 0.963 ایتھر بھیجنے والے کے اکاؤنٹ میں واپس شامل کریں، اور نتیجے میں آنے والی اسٹیٹ کو واپس کریں۔

اگر ٹرانزیکشن کے وصول کرنے والے سرے پر کوئی کنٹریکٹ نہیں تھا، تو کل ٹرانزیکشن فیس صرف فراہم کردہ `GASPRICE` کو ٹرانزیکشن کی لمبائی بائٹس میں ضرب دینے کے برابر ہوگی، اور ٹرانزیکشن کے ساتھ بھیجا گیا ڈیٹا غیر متعلقہ ہوگا۔

نوٹ کریں کہ پیغامات ریورٹس کے لحاظ سے ٹرانزیکشنز کے برابر کام کرتے ہیں: اگر کسی پیغام کے عملدرآمد میں گیس ختم ہو جاتی ہے، تو اس پیغام کا عملدرآمد، اور اس عملدرآمد کے ذریعے شروع کیے گئے دیگر تمام عملدرآمد، ریورٹ ہو جاتے ہیں، لیکن پیرنٹ عملدرآمد کو ریورٹ کرنے کی ضرورت نہیں ہوتی۔ اس کا مطلب ہے کہ ایک کنٹریکٹ کے لیے دوسرے کنٹریکٹ کو کال کرنا \"محفوظ\" ہے، کیونکہ اگر A، B کو G گیس کے ساتھ کال کرتا ہے تو A کے عملدرآمد کو زیادہ سے زیادہ G گیس کھونے کی ضمانت ہے۔ آخر میں، نوٹ کریں کہ ایک اوپ کوڈ، `CREATE` ہے، جو ایک کنٹریکٹ بناتا ہے؛ اس کے عملدرآمد کے میکانکس عام طور پر `CALL` کی طرح ہیں، سوائے اس کے کہ عملدرآمد کا آؤٹ پٹ ایک نئے بنائے گئے کنٹریکٹ کے کوڈ کا تعین کرتا ہے۔

### کوڈ کا عملدرآمد {#code-execution}

ایتھیریم کنٹریکٹس میں کوڈ ایک نچلے درجے کی، اسٹیک پر مبنی بائٹ کوڈ زبان میں لکھا جاتا ہے، جسے \"ایتھیریم ورچوئل مشین کوڈ\" یا \"EVM کوڈ\" کہا جاتا ہے۔ کوڈ بائٹس کی ایک سیریز پر مشتمل ہوتا ہے، جہاں ہر بائٹ ایک آپریشن کی نمائندگی کرتا ہے۔ عام طور پر، کوڈ کا عملدرآمد ایک لامحدود لوپ ہے جو موجودہ پروگرام کاؤنٹر (جو صفر سے شروع ہوتا ہے) پر آپریشن کو بار بار انجام دینے اور پھر پروگرام کاؤنٹر کو ایک سے بڑھانے پر مشتمل ہوتا ہے، جب تک کہ کوڈ کا اختتام نہ ہو جائے یا کوئی خرابی یا `STOP` یا `RETURN` ہدایت کا پتہ نہ چل جائے۔ آپریشنز کو ڈیٹا کو ذخیرہ کرنے کے لیے تین قسم کی جگہ تک رسائی حاصل ہے:

- **اسٹیک**، ایک لاسٹ-ان-فرسٹ-آؤٹ کنٹینر جس میں قدروں کو پش اور پاپ کیا جا سکتا ہے۔
- **میموری**، ایک لامحدود طور پر قابل توسیع بائٹ ارے۔
- کنٹریکٹ کا طویل مدتی **اسٹوریج**، ایک کلید/قدر اسٹور۔ اسٹیک اور میموری کے برعکس، جو کمپیوٹیشن ختم ہونے کے بعد ری سیٹ ہو جاتے ہیں، اسٹوریج طویل مدت کے لیے برقرار رہتا ہے۔

کوڈ آنے والے پیغام کی قدر، بھیجنے والے اور ڈیٹا تک بھی رسائی حاصل کر سکتا ہے، ساتھ ہی بلاک ہیڈر کے ڈیٹا تک بھی، اور کوڈ آؤٹ پٹ کے طور پر ڈیٹا کا ایک بائٹ ارے بھی واپس کر سکتا ہے۔

EVM کوڈ کا رسمی عملدرآمد ماڈل حیرت انگیز طور پر سادہ ہے۔ جبکہ ایتھیریم ورچوئل مشین چل رہی ہے، اس کی مکمل کمپیوٹیشنل حالت کو ٹوپل `(block_state, transaction, message, code, memory, stack, pc, gas)` سے بیان کیا جا سکتا ہے، جہاں `block_state` تمام اکاؤنٹس پر مشتمل عالمی حالت ہے اور اس میں بیلنس اور اسٹوریج شامل ہیں۔ عملدرآمد کے ہر دور کے آغاز میں، موجودہ ہدایت `code` کے `pc`ویں بائٹ کو لے کر پائی جاتی ہے (یا 0 اگر `pc >= len(code)` ہو)، اور ہر ہدایت کی اپنی تعریف ہوتی ہے کہ یہ ٹوپل کو کیسے متاثر کرتی ہے۔ مثال کے طور پر، `ADD` اسٹیک سے دو آئٹمز کو پاپ کرتا ہے اور ان کا مجموعہ پش کرتا ہے، `gas` کو 1 سے کم کرتا ہے اور `pc` کو 1 سے بڑھاتا ہے، اور `SSTORE` اسٹیک سے اوپر کے دو آئٹمز کو پاپ کرتا ہے اور دوسرے آئٹم کو پہلے آئٹم کے ذریعے مخصوص کردہ انڈیکس پر کنٹریکٹ کے اسٹوریج میں داخل کرتا ہے۔ اگرچہ ایتھیریم ورچوئل مشین کے عملدرآمد کو جسٹ-ان-ٹائم کمپائلیشن کے ذریعے بہتر بنانے کے بہت سے طریقے ہیں، ایتھیریم کا ایک بنیادی نفاذ چند سو لائنوں کے کوڈ میں کیا جا سکتا ہے۔

### بلاک چین اور مائننگ {#blockchain-and-mining}

![ایتھیریم اپلائی بلاک ڈایاگرام](./ethereum-apply-block-diagram.png)

ایتھیریم بلاک چین کئی طریقوں سے Bitcoin بلاک چین کی طرح ہے، اگرچہ اس میں کچھ فرق بھی ہیں۔ بلاک چین کے فن تعمیر کے حوالے سے ایتھیریم اور Bitcoin کے درمیان بنیادی فرق یہ ہے کہ، Bitcoin کے برعکس، ایتھیریم بلاکس میں ٹرانزیکشن لسٹ اور تازہ ترین اسٹیٹ دونوں کی ایک کاپی ہوتی ہے۔ اس کے علاوہ، دو دیگر قدریں، بلاک نمبر اور مشکل، بھی بلاک میں محفوظ ہیں۔ ایتھیریم میں بنیادی بلاک کی توثیق کا الگورتھم مندرجہ ذیل ہے:

1. چیک کریں کہ حوالہ دیا گیا پچھلا بلاک موجود ہے اور درست ہے۔
2. چیک کریں کہ بلاک کا ٹائم اسٹیمپ حوالہ دیے گئے پچھلے بلاک کے ٹائم اسٹیمپ سے زیادہ ہے اور مستقبل میں 15 منٹ سے کم ہے۔
3. چیک کریں کہ بلاک نمبر، مشکل، ٹرانزیکشن روٹ، انکل روٹ اور گیس کی حد (مختلف نچلے درجے کے ایتھیریم کے مخصوص تصورات) درست ہیں۔
4. چیک کریں کہ بلاک پر پروف-آف-ورک درست ہے۔
5. `S[0]` کو پچھلے بلاک کے آخر میں اسٹیٹ ہونے دیں۔
6. `TX` کو `n` ٹرانزیکشنز کے ساتھ بلاک کی ٹرانزیکشن لسٹ ہونے دیں۔ `0...n-1` میں تمام `i` کے لیے، `S[i+1] = APPLY(S[i],TX[i])` سیٹ کریں۔ اگر کوئی ایپلی کیشن خرابی واپس کرتی ہے، یا اگر اس وقت تک بلاک میں استعمال ہونے والی کل گیس `GASLIMIT` سے تجاوز کر جاتی ہے، تو ایک خرابی واپس کریں۔
7. `S_FINAL` کو `S[n]` ہونے دیں، لیکن مائنر کو ادا کیے گئے بلاک انعام کو شامل کرتے ہوئے۔
8. چیک کریں کہ آیا اسٹیٹ `S_FINAL` کا مرکل ٹری روٹ بلاک ہیڈر میں فراہم کردہ حتمی اسٹیٹ روٹ کے برابر ہے۔ اگر یہ ہے، تو بلاک درست ہے؛ بصورت دیگر، یہ درست نہیں ہے۔

یہ طریقہ پہلی نظر میں بہت غیر موثر لگ سکتا ہے، کیونکہ اسے ہر بلاک کے ساتھ پوری اسٹیٹ کو محفوظ کرنے کی ضرورت ہے، لیکن حقیقت میں کارکردگی Bitcoin کی کارکردگی کے مقابلے کی ہونی چاہئے۔ وجہ یہ ہے کہ اسٹیٹ کو ٹری اسٹرکچر میں محفوظ کیا جاتا ہے، اور ہر بلاک کے بعد ٹری کے صرف ایک چھوٹے سے حصے کو تبدیل کرنے کی ضرورت ہوتی ہے۔ اس طرح، عام طور پر، دو ملحقہ بلاکس کے درمیان درخت کا بڑا حصہ ایک جیسا ہونا چاہیے، اور اس لیے ڈیٹا کو ایک بار ذخیرہ کیا جا سکتا ہے اور پوائنٹرز (یعنی سب ٹریز کے ہیش) کا استعمال کرتے ہوئے دو بار حوالہ دیا جا سکتا ہے۔ اس کو حاصل کرنے کے لیے ایک خاص قسم کا ٹری جسے \"پیٹریسیا ٹری\" کہا جاتا ہے، استعمال کیا جاتا ہے، جس میں مرکل ٹری کے تصور میں ایک ترمیم شامل ہے جو نوڈز کو موثر طریقے سے داخل اور حذف کرنے کی اجازت دیتی ہے، نہ کہ صرف تبدیل کرنے کی۔ مزید برآں، چونکہ تمام اسٹیٹ کی معلومات آخری بلاک کا حصہ ہیں، پوری بلاک چین کی تاریخ کو محفوظ کرنے کی کوئی ضرورت نہیں ہے - ایک حکمت عملی جو، اگر اسے Bitcoin پر لاگو کیا جا سکتا، تو جگہ میں 5-20 گنا بچت فراہم کرنے کا حساب لگایا جا سکتا ہے۔

ایک عام طور پر پوچھا جانے والا سوال یہ ہے کہ کنٹریکٹ کوڈ کو جسمانی ہارڈ ویئر کے لحاظ سے \"کہاں\" عمل میں لایا جاتا ہے۔ اس کا ایک سادہ جواب ہے: کنٹریکٹ کوڈ کو عمل میں لانے کا عمل اسٹیٹ ٹرانزیشن فنکشن کی تعریف کا حصہ ہے، جو بلاک کی توثیق کے الگورتھم کا حصہ ہے، لہذا اگر کوئی ٹرانزیکشن بلاک `B` میں شامل کی جاتی ہے تو اس ٹرانزیکشن کے ذریعے پیدا ہونے والا کوڈ کا عملدرآمد تمام نوڈز کے ذریعے، اب اور مستقبل میں، جو بلاک `B` کو ڈاؤن لوڈ اور توثیق کرتے ہیں، عمل میں لایا جائے گا۔

## ایپلی کیشنز {#applications}

عام طور پر، ایتھیریم کے اوپر تین قسم کی ایپلی کیشنز ہیں۔ پہلا زمرہ مالیاتی ایپلی کیشنز کا ہے، جو صارفین کو اپنے پیسے کے انتظام اور معاہدوں میں داخل ہونے کے زیادہ طاقتور طریقے فراہم کرتا ہے۔ اس میں ذیلی کرنسیاں، مالیاتی مشتقات، ہیجنگ کنٹریکٹس، بچت والیٹس، وصیتیں، اور بالآخر مکمل پیمانے پر روزگار کے معاہدوں کی کچھ کلاسیں بھی شامل ہیں۔ دوسرا زمرہ نیم-مالیاتی ایپلی کیشنز کا ہے، جہاں پیسہ شامل ہوتا ہے لیکن جو کیا جا رہا ہے اس کا ایک بھاری غیر-مالیاتی پہلو بھی ہوتا ہے؛ ایک بہترین مثال کمپیوٹیشنل مسائل کے حل کے لیے خود-نافذ ہونے والے انعامات ہیں۔ آخر میں، آن لائن ووٹنگ اور ڈی سینٹرلائزڈ گورننس جیسی ایپلی کیشنز ہیں جو بالکل بھی مالیاتی نہیں ہیں۔

### ٹوکن سسٹمز {#token-systems}

آن-بلاک چین ٹوکن سسٹمز کے بہت سے ایپلی کیشنز ہیں جو USD یا سونے جیسے اثاثوں کی نمائندگی کرنے والی ذیلی کرنسیوں سے لے کر کمپنی اسٹاکس، اسمارٹ پراپرٹی کی نمائندگی کرنے والے انفرادی ٹوکنز، محفوظ ناقابل جعل سازی کوپنز، اور یہاں تک کہ ایسے ٹوکن سسٹمز تک ہیں جن کا روایتی قدر سے کوئی تعلق نہیں ہے، جو ترغیبی طور پر پوائنٹ سسٹم کے طور پر استعمال ہوتے ہیں۔ ایتھیریم میں ٹوکن سسٹمز کو نافذ کرنا حیرت انگیز طور پر آسان ہے۔ سمجھنے کی کلیدی بات یہ ہے کہ تمام کرنسی، یا ٹوکن سسٹم، بنیادی طور پر ایک آپریشن والا ڈیٹا بیس ہے: A سے X یونٹس گھٹائیں اور B کو X یونٹس دیں، اس شرط کے ساتھ کہ (i) ٹرانزیکشن سے پہلے A کے پاس کم از کم X یونٹس تھے اور (2) ٹرانزیکشن A کی طرف سے منظور شدہ ہے۔ ٹوکن سسٹم کو نافذ کرنے کے لیے صرف اس منطق کو ایک کنٹریکٹ میں نافذ کرنا ہوتا ہے۔

Serpent میں ٹوکن سسٹم کو نافذ کرنے کا بنیادی کوڈ مندرجہ ذیل ہے:

```py
def send(to, value):
  if self.storage[msg.sender] >= value:
    self.storage[msg.sender] = self.storage[msg.sender] - value
    self.storage[to] = self.storage[to] + value
```

یہ بنیادی طور پر اس دستاویز میں اوپر بیان کردہ \"بینکنگ سسٹم\" اسٹیٹ ٹرانزیشن فنکشن کا لفظی نفاذ ہے۔ کچھ اضافی لائنوں کے کوڈ کو شامل کرنے کی ضرورت ہے تاکہ کرنسی یونٹس کو پہلی جگہ تقسیم کرنے کے ابتدائی مرحلے اور کچھ دیگر کنارے کے معاملات فراہم کیے جا سکیں، اور مثالی طور پر ایک فنکشن شامل کیا جائے گا تاکہ دوسرے کنٹریکٹس کسی ایڈریس کے بیلنس کے لیے استفسار کر سکیں۔ لیکن بس اتنا ہی ہے۔ نظریاتی طور پر، ایتھیریم پر مبنی ٹوکن سسٹمز جو ذیلی کرنسیوں کے طور پر کام کرتے ہیں، ممکنہ طور پر ایک اور اہم خصوصیت شامل کر سکتے ہیں جو آن چین Bitcoin پر مبنی میٹا کرنسیوں میں نہیں ہے: براہ راست اس کرنسی میں ٹرانزیکشن فیس ادا کرنے کی صلاحیت۔ اس کا نفاذ اس طرح ہوگا کہ کنٹریکٹ ایک ایتھر بیلنس برقرار رکھے گا جس سے وہ بھیجنے والے کو فیس ادا کرنے کے لیے استعمال ہونے والے ایتھر کو واپس کرے گا، اور وہ اس بیلنس کو فیس کے طور پر لیے گئے اندرونی کرنسی یونٹس کو جمع کرکے اور انہیں ایک مستقل چلنے والی نیلامی میں دوبارہ فروخت کرکے دوبارہ بھرے گا۔ اس طرح صارفین کو اپنے اکاؤنٹس کو ایتھر کے ساتھ \"فعال\" کرنے کی ضرورت ہوگی، لیکن ایک بار جب ایتھر وہاں ہو گا تو یہ دوبارہ قابل استعمال ہوگا کیونکہ کنٹریکٹ اسے ہر بار واپس کر دے گا۔

### مالیاتی مشتقات اور مستحکم-قدر والی کرنسیاں {#financial-derivatives-and-stable-value-currencies}

مالیاتی مشتقات \"اسمارٹ کنٹریکٹ\" کی سب سے عام ایپلی کیشن ہیں، اور کوڈ میں نافذ کرنے کے لیے سب سے آسان میں سے ایک ہیں۔ مالیاتی معاہدوں کو نافذ کرنے میں بنیادی چیلنج یہ ہے کہ ان میں سے زیادہ تر کو ایک بیرونی قیمت کے ٹکر کا حوالہ درکار ہوتا ہے؛ مثال کے طور پر، ایک بہت ہی مطلوبہ ایپلی کیشن ایک اسمارٹ کنٹریکٹ ہے جو امریکی ڈالر کے مقابلے میں ایتھر (یا کسی اور کریپٹو کرنسی) کی اتار چڑھاؤ کے خلاف ہیج کرتا ہے، لیکن ایسا کرنے کے لیے کنٹریکٹ کو یہ جاننا ضروری ہے کہ ETH/USD کی قدر کیا ہے۔ ایسا کرنے کا سب سے آسان طریقہ ایک "ڈیٹا فیڈ" معاہدے کے ذریعے ہے جسے ایک مخصوص پارٹی (مثال کے طور پر، NASDAQ) برقرار رکھتی ہے، جسے اس طرح ڈیزائن کیا گیا ہے کہ اس پارٹی کو ضرورت کے مطابق معاہدے کو اپ ڈیٹ کرنے کی صلاحیت حاصل ہو، اور ایک ایسا انٹرفیس فراہم کیا جائے جو دوسرے معاہدوں کو اس معاہدے کو پیغام بھیجنے اور قیمت فراہم کرنے والا جواب واپس حاصل کرنے کی اجازت دیتا ہے۔

اس اہم جزو کو دیکھتے ہوئے، ہیجنگ کنٹریکٹ مندرجہ ذیل نظر آئے گا:

1. پارٹی A کے 1000 ایتھر داخل کرنے کا انتظار کریں۔
2. پارٹی B کے 1000 ایتھر داخل کرنے کا انتظار کریں۔
3. 1000 ایتھر کی USD قدر کو ریکارڈ کریں، جسے ڈیٹا فیڈ کنٹریکٹ سے استفسار کرکے شمار کیا گیا ہے، اسٹوریج میں، مان لیں کہ یہ $x ہے۔
4. 30 دنوں کے بعد، A یا B کو کنٹریکٹ کو \"دوبارہ فعال\" کرنے کی اجازت دیں تاکہ A کو $x مالیت کا ایتھر (نئی قیمت حاصل کرنے کے لیے ڈیٹا فیڈ کنٹریکٹ سے دوبارہ استفسار کرکے شمار کیا گیا) بھیجا جا سکے اور باقی B کو۔

ایسا کنٹریکٹ کرپٹو-کامرس میں اہم صلاحیت رکھتا ہوگا۔ کریپٹو کرنسی کے بارے میں بیان کردہ اہم مسائل میں سے ایک یہ حقیقت ہے کہ یہ اتار چڑھاؤ والی ہے؛ اگرچہ بہت سے صارفین اور تاجر کرپٹوگرافک اثاثوں سے نمٹنے کی سیکیورٹی اور سہولت چاہتے ہیں، وہ ایک ہی دن میں اپنے فنڈز کی قدر کا 23% کھونے کے اس امکان کا سامنا نہیں کرنا چاہتے ہیں۔ اب تک، سب سے عام طور پر تجویز کردہ حل جاری کنندہ کے حمایت یافتہ اثاثے ہیں؛ خیال یہ ہے کہ ایک جاری کنندہ ایک ذیلی کرنسی بناتا ہے جس میں اسے یونٹس جاری کرنے اور منسوخ کرنے کا حق حاصل ہوتا ہے، اور کرنسی کا ایک یونٹ ہر اس شخص کو فراہم کرتا ہے جو انہیں (آف لائن) ایک مخصوص بنیادی اثاثہ (مثلاً، سونا، USD) کا ایک یونٹ فراہم کرتا ہے۔ جاری کنندہ پھر وعدہ کرتا ہے کہ وہ کسی بھی شخص کو بنیادی اثاثہ کی ایک اکائی فراہم کرے گا جو کرپٹو-اثاثہ کی ایک اکائی واپس بھیجتا ہے۔ یہ میکانزم کسی بھی غیر-کرپٹوگرافک اثاثہ کو ایک کرپٹوگرافک اثاثہ میں \"بلند\" کرنے کی اجازت دیتا ہے، بشرطیکہ جاری کنندہ پر بھروسہ کیا جا سکے۔

تاہم، عملی طور پر، جاری کنندگان ہمیشہ قابل بھروسہ نہیں ہوتے ہیں، اور کچھ معاملات میں بینکنگ کا بنیادی ڈھانچہ اتنا کمزور، یا اتنا مخالف ہوتا ہے کہ ایسی خدمات موجود نہیں ہو سکتیں۔ مالیاتی مشتقات ایک متبادل فراہم کرتے ہیں۔ یہاں، کسی اثاثے کی پشت پناہی کے لیے فنڈز فراہم کرنے والے ایک واحد جاری کنندہ کے بجائے، سٹے بازوں کا ایک غیر مرکزی بازار، جو اس بات پر شرط لگاتا ہے کہ کرپٹوگرافک حوالہ اثاثہ (مثلاً، ETH) کی قیمت بڑھے گی، یہ کردار ادا کرتا ہے۔ جاری کنندگان کے برعکس، قیاس آرائی کرنے والوں کے پاس اپنے سودے کے حصے پر ڈیفالٹ کرنے کا کوئی آپشن نہیں ہوتا کیونکہ ہیجنگ کنٹریکٹ ان کے فنڈز کو ایسکرو میں رکھتا ہے۔ نوٹ کریں کہ یہ نقطہ نظر مکمل طور پر ڈی سینٹرلائزڈ نہیں ہے، کیونکہ قیمت کا ٹکر فراہم کرنے کے لیے اب بھی ایک قابل اعتماد ذریعہ کی ضرورت ہے، اگرچہ بلاشبہ اب بھی یہ بنیادی ڈھانچے کی ضروریات کو کم کرنے (جاری کنندہ ہونے کے برعکس، قیمت کا فیڈ جاری کرنے کے لیے کوئی لائسنس درکار نہیں ہوتا اور اسے ممکنہ طور پر آزادانہ تقریر کے زمرے میں رکھا جا سکتا ہے) اور دھوکہ دہی کے امکان کو کم کرنے کے لحاظ سے ایک بہت بڑی بہتری ہے۔

### شناخت اور ساکھ کے نظام {#identity-and-reputation-systems}

سب سے قدیم متبادل کریپٹو کرنسی، [Namecoin](http://namecoin.org/)، نے Bitcoin جیسی بلاک چین کا استعمال کرتے ہوئے ایک نام کی رجسٹریشن کا نظام فراہم کرنے کی کوشش کی، جہاں صارفین اپنے نام کو عوامی ڈیٹا بیس میں دیگر ڈیٹا کے ساتھ رجسٹر کر سکتے ہیں۔ بڑا حوالہ دیا گیا استعمال کا معاملہ [DNS](https://wikipedia.org/wiki/Domain_Name_System) نظام کے لیے ہے، جو \"bitcoin.org\" جیسے ڈومین ناموں کو (یا، Namecoin کے معاملے میں، \"bitcoin.bit\") ایک IP ایڈریس پر میپ کرتا ہے۔ دیگر استعمال کے معاملات میں ای میل کی توثیق اور ممکنہ طور پر زیادہ جدید ساکھ کے نظام شامل ہیں۔ یہاں ایتھیریم پر Namecoin جیسا نام رجسٹریشن کا نظام فراہم کرنے کا بنیادی کنٹریکٹ ہے:

```py
def register(name, value):
  if !self.storage[name]:
    self.storage[name] = value
```

کنٹریکٹ بہت سادہ ہے؛ یہ صرف ایتھیریم نیٹ ورک کے اندر ایک ڈیٹا بیس ہے جس میں شامل کیا جا سکتا ہے، لیکن اس میں ترمیم یا اسے ہٹایا نہیں جا سکتا۔ کوئی بھی شخص کسی قدر کے ساتھ ایک نام رجسٹر کر سکتا ہے، اور وہ رجسٹریشن پھر ہمیشہ کے لیے قائم رہتی ہے۔ ایک زیادہ پیچیدہ نام کی رجسٹریشن کے معاہدے میں ایک "فنکشن کلاز" بھی ہوگا جو دوسرے معاہدوں کو اس سے استفسار کرنے کی اجازت دے گا، ساتھ ہی کسی نام کے "مالک" (یعنی پہلے رجسٹر کرنے والے) کے لیے ڈیٹا کو تبدیل کرنے یا ملکیت منتقل کرنے کا ایک میکانزم بھی ہوگا۔ کوئی شخص اس پر ساکھ اور ویب-آف-ٹرسٹ کی فعالیت بھی شامل کر سکتا ہے۔

### ڈی سینٹرلائزڈ فائل اسٹوریج {#decentralized-file-storage}

گزشتہ چند سالوں میں، کئی مقبول آن لائن فائل اسٹوریج کے اسٹارٹ اپس ابھرے ہیں، جن میں سب سے نمایاں Dropbox ہے، جو صارفین کو اپنی ہارڈ ڈرائیو کا بیک اپ اپ لوڈ کرنے کی اجازت دیتا ہے اور سروس اس بیک اپ کو محفوظ کرتی ہے اور صارف کو ماہانہ فیس کے بدلے میں اس تک رسائی کی اجازت دیتی ہے۔ تاہم، اس وقت فائل اسٹوریج کی مارکیٹ بعض اوقات نسبتاً غیر موثر ہوتی ہے؛ مختلف موجودہ حلوں پر ایک سرسری نظر سے پتہ چلتا ہے کہ، خاص طور پر 20-200 جی بی کی \"انیکینی ویلی\" کی سطح پر جس پر نہ تو مفت کوٹہ اور نہ ہی انٹرپرائز-سطح کی چھوٹ شروع ہوتی ہے، مرکزی دھارے کے فائل اسٹوریج کی ماہانہ قیمتیں ایسی ہیں کہ آپ ایک ہی مہینے میں پوری ہارڈ ڈرائیو کی لاگت سے زیادہ ادا کر رہے ہیں۔ ایتھیریم کنٹریکٹس ایک ڈی سینٹرلائزڈ فائل اسٹوریج ایکو سسٹم کی ترقی کی اجازت دے سکتے ہیں، جہاں انفرادی صارفین اپنی ہارڈ ڈرائیوز کرائے پر دے کر چھوٹی مقدار میں رقم کما سکتے ہیں اور غیر استعمال شدہ جگہ کو فائل اسٹوریج کی لاگت کو مزید کم کرنے کے لیے استعمال کیا جا سکتا ہے۔

ایسے آلے کا کلیدی بنیادی حصہ وہ ہوگا جسے ہم نے \"ڈی سینٹرلائزڈ ڈراپ باکس کنٹریکٹ\" کا نام دیا ہے۔ یہ کنٹریکٹ اس طرح کام کرتا ہے۔ سب سے پہلے، مطلوبہ ڈیٹا کو بلاکس میں تقسیم کیا جاتا ہے، رازداری کے لیے ہر بلاک کو انکرپٹ کیا جاتا ہے، اور اس سے ایک مرکل ٹری بنایا جاتا ہے۔ پھر ایک کنٹریکٹ اس اصول کے ساتھ بنایا جاتا ہے کہ، ہر N بلاکس پر، کنٹریکٹ مرکل ٹری میں ایک بے ترتیب انڈیکس کا انتخاب کرے گا (کنٹریکٹ کوڈ سے قابل رسائی پچھلے بلاک ہیش کو بے ترتیب پن کے ذریعہ کے طور پر استعمال کرتے ہوئے)، اور پہلی اکائی کو X ایتھر دے گا جو ٹری میں اس مخصوص انڈیکس پر بلاک کی ملکیت کے آسان ادائیگی کی توثیق جیسے ثبوت کے ساتھ ایک ٹرانزیکشن فراہم کرتی ہے۔ جب کوئی صارف اپنی فائل کو دوبارہ ڈاؤن لوڈ کرنا چاہتا ہے، تو وہ فائل کو بازیافت کرنے کے لیے ایک مائیکرو پیمنٹ چینل پروٹوکول (مثال کے طور پر، فی 32 کلو بائٹس 1 szabo ادا کریں) کا استعمال کر سکتا ہے؛ سب سے زیادہ فیس-موثر طریقہ یہ ہے کہ ادائیگی کرنے والا آخر تک ٹرانزیکشن شائع نہ کرے، بلکہ ہر 32 کلو بائٹس کے بعد اسی نانس کے ساتھ ٹرانزیکشن کو تھوڑا زیادہ منافع بخش والے سے تبدیل کر دے۔

پروٹوکول کی ایک اہم خصوصیت یہ ہے کہ، اگرچہ ایسا لگ سکتا ہے کہ کوئی شخص بہت سے بے ترتیب نوڈز پر بھروسہ کر رہا ہے کہ وہ فائل کو بھولنے کا فیصلہ نہیں کریں گے، کوئی بھی خفیہ شیئرنگ کے ذریعے فائل کو بہت سے ٹکڑوں میں تقسیم کرکے اور کنٹریکٹس کو دیکھ کر کہ ہر ٹکڑا ابھی بھی کسی نوڈ کے قبضے میں ہے، اس خطرے کو تقریباً صفر تک کم کر سکتا ہے۔ اگر کوئی کنٹریکٹ اب بھی رقم ادا کر رہا ہے، تو یہ ایک کرپٹوگرافک ثبوت فراہم کرتا ہے کہ کوئی وہاں اب بھی فائل کو محفوظ کر رہا ہے۔

### ڈی سینٹرلائزڈ خود مختار تنظیمیں {#decentralized-autonomous-organizations}

\"ڈی سینٹرلائزڈ خود مختار تنظیم\" کا عمومی تصور ایک مجازی اکائی کا ہے جس کے کچھ ممبران یا شیئر ہولڈرز ہوتے ہیں جو، شاید 67% کی اکثریت کے ساتھ، اکائی کے فنڈز کو خرچ کرنے اور اس کے کوڈ میں ترمیم کرنے کا حق رکھتے ہیں۔ ممبران اجتماعی طور پر فیصلہ کریں گے کہ تنظیم کو اپنے فنڈز کیسے مختص کرنے چاہئیں۔ DAO کے فنڈز کو مختص کرنے کے طریقے انعامات، تنخواہوں سے لے کر کام کو انعام دینے کے لیے ایک اندرونی کرنسی جیسے زیادہ غیر ملکی میکانزم تک ہو سکتے ہیں۔ یہ بنیادی طور پر ایک روایتی کمپنی یا غیر منفعتی تنظیم کے قانونی جال کو نقل کرتا ہے لیکن نفاذ کے لیے صرف کرپٹوگرافک بلاک چین ٹیکنالوجی کا استعمال کرتا ہے۔ اب تک DAOs کے بارے میں زیادہ تر باتیں \"سرمایہ دارانہ\" ماڈل یعنی ایک \"ڈی سینٹرلائزڈ خود مختار کارپوریشن\" (DAC) کے بارے میں ہوئی ہیں جس میں منافع وصول کرنے والے شیئر ہولڈرز اور قابل تجارت شیئرز ہوتے ہیں؛ ایک متبادل، جسے شاید \"ڈی سینٹرلائزڈ خود مختار کمیونٹی\" کے طور پر بیان کیا جائے، میں تمام ممبران کو فیصلہ سازی میں برابر کا حصہ ملے گا اور کسی ممبر کو شامل کرنے یا ہٹانے کے لیے 67% موجودہ ممبران کی رضامندی کی ضرورت ہوگی۔ یہ ضرورت کہ ایک شخص کی صرف ایک رکنیت ہو سکتی ہے، پھر گروپ کے ذریعے اجتماعی طور پر نافذ کی جانی ہوگی۔

DAO کو کوڈ کرنے کا ایک عمومی خاکہ مندرجہ ذیل ہے۔ سب سے سادہ ڈیزائن صرف خود کو تبدیل کرنے والے کوڈ کا ایک ٹکڑا ہے جو تبدیل ہوتا ہے اگر دو تہائی ممبران کسی تبدیلی پر متفق ہوں۔ اگرچہ کوڈ نظریاتی طور پر ناقابل تغیر ہے، کوئی بھی آسانی سے اس سے بچ سکتا ہے اور کوڈ کے ٹکڑوں کو الگ الگ کنٹریکٹس میں رکھ کر اور قابل ترمیم اسٹوریج میں محفوظ کردہ کنٹریکٹس کا ایڈریس رکھ کر ڈی-فیکٹو تغیر پذیری حاصل کر سکتا ہے۔ ایسے DAO کنٹریکٹ کے ایک سادہ نفاذ میں، تین ٹرانزیکشن کی قسمیں ہوں گی، جو ٹرانزیکشن میں فراہم کردہ ڈیٹا کے ذریعے ممتاز ہوں گی:

- `[0,i,K,V]` انڈیکس `i` کے ساتھ اسٹوریج انڈیکس `K` پر ایڈریس کو قدر `V` میں تبدیل کرنے کی تجویز کو رجسٹر کرنے کے لیے۔
- `[1,i]` تجویز `i` کے حق میں ووٹ رجسٹر کرنے کے لیے۔
- `[2,i]` تجویز `i` کو حتمی شکل دینے کے لیے اگر کافی ووٹ ڈالے گئے ہوں۔

کنٹریکٹ میں پھر ان میں سے ہر ایک کے لیے شقیں ہوں گی۔ یہ تمام کھلی اسٹوریج تبدیلیوں کا ریکارڈ برقرار رکھے گا، ساتھ ہی اس بات کی فہرست بھی کہ کس نے ان کے لیے ووٹ دیا ہے۔ اس میں تمام ممبران کی ایک فہرست بھی ہوگی۔ جب کسی بھی اسٹوریج کی تبدیلی کو دو تہائی ممبران کی حمایت حاصل ہو جاتی ہے، تو ایک حتمی ٹرانزیکشن تبدیلی کو عمل میں لا سکتی ہے۔ ایک زیادہ پیچیدہ ڈھانچے میں ٹرانزیکشن بھیجنے، اراکین کو شامل کرنے اور اراکین کو ہٹانے جیسی خصوصیات کے لیے بلٹ ان ووٹنگ کی اہلیت بھی ہوگی، اور یہاں تک کہ [لیکویڈ ڈیموکریسی](https://wikipedia.org/wiki/Liquid_democracy) طرز کی ووٹ کی نمائندگی بھی فراہم کر سکتا ہے (یعنی، کوئی بھی کسی کو اپنے لیے ووٹ دینے کے لیے تفویض کر سکتا ہے، اور تفویض متعدی ہے لہذا اگر A, B کو تفویض کرتا ہے اور B, C کو تفویض کرتا ہے تو C, A کے ووٹ کا تعین کرتا ہے)۔ یہ ڈیزائن DAO کو ایک ڈی سینٹرلائزڈ کمیونٹی کے طور پر منظم طریقے سے بڑھنے کی اجازت دے گا، جس سے لوگ بالآخر یہ فلٹر کرنے کا کام کہ کون ممبر ہے ماہرین کو سونپ سکیں گے، اگرچہ \"موجودہ نظام\" کے برعکس ماہرین آسانی سے وقت کے ساتھ ظاہر اور غائب ہو سکتے ہیں جیسے جیسے انفرادی کمیونٹی کے ممبران اپنی صف بندی تبدیل کرتے ہیں۔

ایک متبادل ماڈل ایک ڈی سینٹرلائزڈ کارپوریشن کا ہے، جہاں کسی بھی اکاؤنٹ کے صفر یا زیادہ شیئرز ہو سکتے ہیں، اور فیصلہ کرنے کے لیے دو تہائی شیئرز کی ضرورت ہوتی ہے۔ ایک مکمل ڈھانچے میں اثاثہ جات کے انتظام کی فعالیت، شیئرز خریدنے یا بیچنے کی پیشکش کرنے کی صلاحیت، اور پیشکشوں کو قبول کرنے کی صلاحیت (ترجیحاً کنٹریکٹ کے اندر آرڈر-میچنگ میکانزم کے ساتھ) شامل ہوگی۔ وفد بھی لیکوئڈ ڈیموکریسی-اسٹائل میں موجود ہوگا، جو \"بورڈ آف ڈائریکٹرز\" کے تصور کو عام کرتا ہے۔

### مزید ایپلی کیشنز {#further-applications}

**1.** بچت والیٹس\*\*۔ فرض کریں کہ ایلس اپنے فنڈز کو محفوظ رکھنا چاہتی ہے، لیکن وہ پریشان ہے کہ وہ اپنی پرائیویٹ کی کھو دے گی یا کوئی اسے ہیک کر لے گا۔ وہ ایتھر کو ایک بینک، باب کے ساتھ ایک کنٹریکٹ میں ڈالتی ہے، اس طرح:

- ایلس اکیلے روزانہ زیادہ سے زیادہ 1% فنڈز نکال سکتی ہے۔
- باب اکیلے روزانہ زیادہ سے زیادہ 1% فنڈز نکال سکتا ہے، لیکن ایلس کے پاس اپنی کی کے ساتھ ایک ٹرانزیکشن کرنے کی صلاحیت ہے جو اس صلاحیت کو بند کر دیتی ہے۔
- ایلس اور باب مل کر کچھ بھی نکال سکتے ہیں۔

عام طور پر، روزانہ 1% ایلس کے لیے کافی ہے، اور اگر ایلس زیادہ نکالنا چاہتی ہے تو وہ مدد کے لیے باب سے رابطہ کر سکتی ہے۔ اگر ایلس کی کی ہیک ہو جاتی ہے، تو وہ فنڈز کو ایک نئے کنٹریکٹ میں منتقل کرنے کے لیے باب کے پاس بھاگتی ہے۔ اگر وہ اپنی کی کھو دیتی ہے، تو باب بالآخر فنڈز نکال لے گا۔ اگر باب بدنیتی پر مبنی نکلتا ہے، تو وہ اس کی نکالنے کی صلاحیت کو بند کر سکتی ہے۔

**2.** فصل کا بیمہ\*\*۔ کوئی بھی آسانی سے ایک مالیاتی مشتقات کا کنٹریکٹ بنا سکتا ہے لیکن کسی بھی قیمت کے انڈیکس کی بجائے موسم کے ڈیٹا فیڈ کا استعمال کرتے ہوئے۔ اگر آئیووا میں ایک کسان ایک ایسا مشتق خریدتا ہے جو آئیووا میں بارش کی بنیاد پر الٹا ادائیگی کرتا ہے، تو اگر خشک سالی ہوتی ہے، تو کسان کو خود بخود رقم مل جائے گی اور اگر کافی بارش ہوتی ہے تو کسان خوش ہوگا کیونکہ اس کی فصلیں اچھی ہوں گی۔ اسے عام طور پر قدرتی آفات کے بیمہ تک بڑھایا جا سکتا ہے۔

**3.** ایک ڈی سینٹرلائزڈ ڈیٹا فیڈ\*\*۔ فرق کے لیے مالیاتی معاہدوں کے لیے، یہ دراصل "[SchellingCoin](https://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/)" نامی پروٹوکول کے ذریعے ڈیٹا فیڈ کو غیر مرکزی بنانا ممکن ہو سکتا ہے۔ SchellingCoin بنیادی طور پر اس طرح کام کرتا ہے: N پارٹیاں سبھی سسٹم میں ایک دیے گئے ڈیٹم کی قدر (مثلاً، ETH/USD قیمت) ڈالتی ہیں، قدروں کو ترتیب دیا جاتا ہے، اور 25ویں اور 75ویں پرسنٹائل کے درمیان ہر کسی کو انعام کے طور پر ایک ٹوکن ملتا ہے۔ ہر کسی کو وہ جواب فراہم کرنے کی ترغیب ملتی ہے جو ہر کوئی فراہم کرے گا، اور واحد قدر جس پر بڑی تعداد میں کھلاڑی حقیقت پسندانہ طور پر متفق ہو سکتے ہیں وہ واضح ڈیفالٹ ہے: سچائی۔ یہ ایک ڈی سینٹرلائزڈ پروٹوکول بناتا ہے جو نظریاتی طور پر کسی بھی تعداد میں قدریں فراہم کر سکتا ہے، بشمول ETH/USD کی قیمت، برلن میں درجہ حرارت یا یہاں تک کہ کسی خاص مشکل کمپیوٹیشن کا نتیجہ۔

**4۔ اسمارٹ ملٹی سگنیچر ایسکرو**۔ Bitcoin ملٹی سگنیچر ٹرانزیکشن کنٹریکٹس کی اجازت دیتا ہے جہاں، مثال کے طور پر، دی گئی پانچ کیز میں سے تین فنڈز خرچ کر سکتی ہیں۔ ایتھیریم زیادہ باریک بینی کی اجازت دیتا ہے؛ مثال کے طور پر، پانچ میں سے چار سب کچھ خرچ کر سکتے ہیں، پانچ میں سے تین روزانہ 10% تک خرچ کر سکتے ہیں، اور پانچ میں سے دو روزانہ 0.5% تک خرچ کر سکتے ہیں۔ مزید برآں، ایتھیریم ملٹی سگ غیر مطابقت پذیر ہے - دو پارٹیاں مختلف اوقات میں بلاک چین پر اپنے دستخط رجسٹر کر سکتی ہیں اور آخری دستخط خود بخود ٹرانزیکشن بھیج دے گا۔

**5۔ کلاؤڈ کمپیوٹنگ**۔ EVM ٹیکنالوجی کو ایک قابل تصدیق کمپیوٹنگ ماحول بنانے کے لیے بھی استعمال کیا جا سکتا ہے، جس سے صارفین دوسروں سے کمپیوٹیشنز کرنے کے لیے کہہ سکتے ہیں اور پھر اختیاری طور پر اس بات کے ثبوت مانگ سکتے ہیں کہ کچھ بے ترتیب منتخب چیک پوائنٹس پر کمپیوٹیشنز صحیح طریقے سے کی گئی تھیں۔ یہ ایک کلاؤڈ کمپیوٹنگ مارکیٹ بنانے کی اجازت دیتا ہے جہاں کوئی بھی صارف اپنے ڈیسک ٹاپ، لیپ ٹاپ یا خصوصی سرور کے ساتھ حصہ لے سکتا ہے، اور سیکیورٹی ڈپازٹس کے ساتھ موقع پر جانچ کا استعمال اس بات کو یقینی بنانے کے لیے کیا جا سکتا ہے کہ سسٹم قابل اعتماد ہے (یعنی، نوڈز منافع بخش طریقے سے دھوکہ نہیں دے سکتے)۔ اگرچہ ایسا نظام تمام کاموں کے لیے موزوں نہیں ہو سکتا؛ مثال کے طور پر، ایسے کام جن کے لیے اعلی سطح کی انٹر-پروسیس کمیونیکیشن کی ضرورت ہوتی ہے، نوڈز کے ایک بڑے کلاؤڈ پر آسانی سے نہیں کیے جا سکتے۔ تاہم، دیگر کاموں کو متوازی بنانا بہت آسان ہے؛ SETI@home، folding@home اور جینیاتی الگورتھم جیسے پروجیکٹس کو ایسے پلیٹ فارم پر آسانی سے نافذ کیا جا سکتا ہے۔

**6۔ پیئر-ٹو-پیئر جوا**۔ کسی بھی تعداد میں پیئر-ٹو-پیئر جوئے کے پروٹوکولز، جیسے فرینک اسٹاجانو اور رچرڈ کلیٹن کا [سائبر ڈائس](http://www.cl.cam.ac.uk/~fms27/papers/2008-StajanoCla-cyberdice.pdf)، ایتھیریم بلاک چین پر نافذ کیے جا سکتے ہیں۔ سب سے سادہ جوئے کا پروٹوکول دراصل اگلے بلاک ہیش پر فرق کے لیے ایک کنٹریکٹ ہے، اور وہاں سے مزید جدید پروٹوکولز بنائے جا سکتے ہیں، جو تقریباً صفر فیس والی جوئے کی خدمات بناتے ہیں جن میں دھوکہ دہی کی کوئی صلاحیت نہیں ہوتی۔

**7۔ پیش گوئی کی مارکیٹیں**۔ ایک اوریکل یا SchellingCoin فراہم کیے جانے پر، پیشین گوئی کے بازاروں کو نافذ کرنا بھی آسان ہے، اور SchellingCoin کے ساتھ مل کر پیشین گوئی کے بازار غیر مرکزی تنظیموں کے لیے ایک گورننس پروٹوکول کے طور پر [فیوٹرکی](https://mason.gmu.edu/~rhanson/futarchy.html) کی پہلی مرکزی دھارے کی ایپلیکیشن ثابت ہو سکتے ہیں۔

**8۔ آن چین ڈی سینٹرلائزڈ مارکیٹ پلیسز**، شناخت اور ساکھ کے نظام کو بنیاد کے طور پر استعمال کرتے ہوئے۔

## متفرقات اور خدشات {#miscellanea-and-concerns}

### ترمیم شدہ GHOST نفاذ {#modified-ghost-implementation}

\"گریڈی ہیویسٹ آبزرڈ سب ٹری\" (GHOST) پروٹوکول ایک جدت ہے جو سب سے پہلے یوناتن سومپولنسکی اور ایویو زوہر نے [دسمبر 2013](https://eprint.iacr.org/2013/881.pdf) میں متعارف کرائی تھی۔ GHOST کے پیچھے کی تحریک یہ ہے کہ تیز تصدیقی اوقات والی بلاک چینز فی الحال ایک اعلی اسٹیل ریٹ کی وجہ سے کم سیکیورٹی کا شکار ہیں - کیونکہ بلاکس کو نیٹ ورک کے ذریعے پھیلنے میں ایک خاص وقت لگتا ہے، اگر مائنر A ایک بلاک مائن کرتا ہے اور پھر مائنر B مائنر A کے بلاک کے B تک پھیلنے سے پہلے ایک اور بلاک مائن کرتا ہے، تو مائنر B کا بلاک ضائع ہو جائے گا اور نیٹ ورک سیکیورٹی میں کوئی حصہ نہیں ڈالے گا۔ مزید برآں، ایک مرکزیت کا مسئلہ ہے: اگر مائنر A 30% ہیش پاور والا ایک مائننگ پول ہے اور B کے پاس 10% ہیش پاور ہے، تو A کے پاس 70% وقت میں ایک اسٹیل بلاک پیدا کرنے کا خطرہ ہوگا (کیونکہ باقی 30% وقت میں A نے آخری بلاک پیدا کیا تھا اور اس لیے اسے فوراً مائننگ ڈیٹا مل جائے گا) جبکہ B کے پاس 90% وقت میں ایک اسٹیل بلاک پیدا کرنے کا خطرہ ہوگا۔ اس طرح، اگر بلاک کا وقفہ اتنا چھوٹا ہو کہ اسٹیل ریٹ زیادہ ہو، تو A صرف اپنے سائز کی وجہ سے کافی زیادہ موثر ہوگا۔ ان دونوں اثرات کے ساتھ مل کر، جو بلاکس تیزی سے پیدا کرتے ہیں وہ بلاک چینز بہت ممکن ہے کہ ایک مائننگ پول کو نیٹ ورک ہیش پاور کا اتنا بڑا فیصد حاصل ہو جائے کہ وہ مائننگ کے عمل پر ڈی فیکٹو کنٹرول حاصل کر لے۔

جیسا کہ سومپولنسکی اور زوہر نے بیان کیا ہے، GHOST نیٹ ورک سیکیورٹی کے نقصان کے پہلے مسئلے کو حل کرتا ہے جس میں اسٹیل بلاکس کو اس حساب میں شامل کیا جاتا ہے کہ کون سی چین \"سب سے لمبی\" ہے؛ یعنی، نہ صرف ایک بلاک کے پیرنٹ اور مزید آباؤ اجداد، بلکہ بلاک کے آباؤ اجداد کے اسٹیل اولاد (ایتھیریم کی اصطلاح میں، \"انکلز\") کو بھی اس حساب میں شامل کیا جاتا ہے کہ کس بلاک کے پیچھے سب سے زیادہ کل پروف-آف-ورک ہے۔ مرکزیت کے تعصب کے دوسرے مسئلے کو حل کرنے کے لیے، ہم سومپولنسکی اور زوہر کے بیان کردہ پروٹوکول سے آگے بڑھتے ہیں، اور اسٹیلز کو بلاک انعامات بھی فراہم کرتے ہیں: ایک اسٹیل بلاک کو اس کے بنیادی انعام کا 87.5% ملتا ہے، اور بھتیجے کو جو اسٹیل بلاک کو شامل کرتا ہے باقی 12.5% ملتا ہے۔ تاہم، ٹرانزیکشن فیس انکلز کو نہیں دی جاتی۔

ایتھیریم GHOST کا ایک آسان ورژن نافذ کرتا ہے جو صرف سات سطحوں تک نیچے جاتا ہے۔ خاص طور پر، اسے مندرجہ ذیل طور پر بیان کیا گیا ہے:

- ایک بلاک کو ایک پیرنٹ کی وضاحت کرنی چاہئے، اور اسے 0 یا زیادہ انکلز کی وضاحت کرنی چاہئے۔
- بلاک B میں شامل ایک انکل کو مندرجہ ذیل خصوصیات ہونی چاہئیں:
  - یہ B کی kth نسل کے آباؤ اجداد کا براہ راست بچہ ہونا چاہئے، جہاں `2 <= k <= 7`۔
  - یہ B کا آباؤ اجداد نہیں ہو سکتا۔
  - ایک انکل ایک درست بلاک ہیڈر ہونا چاہئے، لیکن اسے پہلے سے تصدیق شدہ یا یہاں تک کہ درست بلاک ہونے کی ضرورت نہیں ہے۔
  - ایک انکل پچھلے بلاکس میں شامل تمام انکلز اور اسی بلاک میں شامل دیگر تمام انکلز سے مختلف ہونا چاہئے (غیر-ڈبل-انکلوژن)۔
- بلاک B میں ہر انکل U کے لیے، B کے مائنر کو اس کے کوئن بیس انعام میں اضافی 3.125% ملتا ہے اور U کے مائنر کو ایک معیاری کوئن بیس انعام کا 93.75% ملتا ہے۔

GHOST کا یہ محدود ورژن، جس میں انکلز صرف 7 نسلوں تک شامل کیے جا سکتے ہیں، دو وجوہات کی بنا پر استعمال کیا گیا تھا۔ پہلا، لامحدود GHOST کسی دیے گئے بلاک کے لیے کون سے انکلز درست ہیں اس کے حساب میں بہت زیادہ پیچیدگیاں شامل کرے گا۔ دوسرا، ایتھیریم میں استعمال ہونے والے معاوضے کے ساتھ لامحدود GHOST ایک مائنر کو مرکزی چین پر مائن کرنے کی ترغیب کو ختم کرتا ہے نہ کہ کسی عوامی حملہ آور کی چین پر۔

### فیس {#fees}

چونکہ بلاک چین میں شائع ہونے والی ہر ٹرانزیکشن نیٹ ورک پر اسے ڈاؤن لوڈ کرنے اور اس کی تصدیق کرنے کی لاگت عائد کرتی ہے، اس لیے کسی نہ کسی ریگولیٹری میکانزم کی ضرورت ہے، جس میں عام طور پر ٹرانزیکشن فیس شامل ہوتی ہے، تاکہ غلط استعمال کو روکا جا سکے۔ Bitcoin میں استعمال ہونے والا ڈیفالٹ طریقہ خالصتاً رضاکارانہ فیس کا ہے، جو مائنرز پر بھروسہ کرتا ہے کہ وہ گیٹ کیپر کے طور پر کام کریں اور متحرک کم از کم حد مقرر کریں۔ اس نقطہ نظر کو Bitcoin کمیونٹی میں بہت پسند کیا گیا ہے خاص طور پر کیونکہ یہ \"مارکیٹ پر مبنی\" ہے، جو مائنرز اور ٹرانزیکشن بھیجنے والوں کے درمیان طلب اور رسد کو قیمت کا تعین کرنے کی اجازت دیتا ہے۔ تاہم، اس استدلال کی لائن میں مسئلہ یہ ہے کہ ٹرانزیکشن پروسیسنگ کوئی مارکیٹ نہیں ہے؛ اگرچہ ٹرانزیکشن پروسیسنگ کو ایک ایسی خدمت کے طور پر سمجھنا جو مائنر بھیجنے والے کو پیش کر رہا ہے، بدیہی طور پر پرکشش ہے، حقیقت میں ہر ٹرانزیکشن جسے ایک مائنر شامل کرتا ہے، اسے نیٹ ورک میں ہر نوڈ کے ذریعے پروسیس کرنے کی ضرورت ہوگی، لہذا ٹرانزیکشن پروسیسنگ کی لاگت کا بڑا حصہ تیسرے فریقوں کے ذریعے برداشت کیا جاتا ہے نہ کہ اس مائنر کے ذریعے جو یہ فیصلہ کر رہا ہے کہ اسے شامل کرنا ہے یا نہیں۔ لہذا، کامنز کی المیہ کے مسائل کا واقع ہونا بہت ممکن ہے۔

تاہم، جیسا کہ پتہ چلتا ہے، مارکیٹ پر مبنی میکانزم میں یہ خامی، جب ایک خاص غلط سادہ مفروضہ دیا جاتا ہے، جادوئی طور پر خود کو منسوخ کر دیتی ہے۔ دلیل مندرجہ ذیل ہے۔ فرض کریں کہ:

1. ایک ٹرانزیکشن `k` آپریشنز کا باعث بنتی ہے، جو کسی بھی مائنر کو جو اسے شامل کرتا ہے `kR` کا انعام پیش کرتی ہے جہاں `R` بھیجنے والے کے ذریعے سیٹ کیا جاتا ہے اور `k` اور `R` (تقریباً) مائنر کو پہلے سے نظر آتے ہیں۔
2. ایک آپریشن کی کسی بھی نوڈ کے لیے پروسیسنگ لاگت `C` ہے (یعنی، تمام نوڈز کی کارکردگی برابر ہے)
3. `N` مائننگ نوڈز ہیں، جن میں سے ہر ایک کے پاس بالکل برابر پروسیسنگ پاور ہے (یعنی، کل کا `1/N`)
4. کوئی غیر-مائننگ فل نوڈز موجود نہیں ہیں۔

ایک مائنر ایک ٹرانزیکشن پر کارروائی کرنے کے لیے تیار ہوگا اگر متوقع انعام لاگت سے زیادہ ہو۔ لہذا، متوقع انعام `kR/N` ہے کیونکہ مائنر کے پاس اگلے بلاک پر کارروائی کرنے کا `1/N` موقع ہے، اور مائنر کے لیے پروسیسنگ کی لاگت صرف `kC` ہے۔ لہذا، مائنرز ان ٹرانزیکشنز کو شامل کریں گے جہاں `kR/N > kC`، یا `R > NC`۔ نوٹ کریں کہ `R` بھیجنے والے کی طرف سے فراہم کردہ فی-آپریشن فیس ہے، اور اس طرح یہ اس فائدے پر ایک نچلی حد ہے جو بھیجنے والا ٹرانزیکشن سے حاصل کرتا ہے، اور `NC` ایک آپریشن پر کارروائی کرنے کے لیے پورے نیٹ ورک کی لاگت ہے۔ لہذا، مائنرز کو صرف ان ٹرانزیکشنز کو شامل کرنے کی ترغیب ملتی ہے جن کے لیے کل افادیت پسند فائدہ لاگت سے زیادہ ہو۔

تاہم، حقیقت میں ان مفروضوں سے کئی اہم انحرافات ہیں:

1. مائنر کو ٹرانزیکشن پر کارروائی کرنے کے لیے دیگر تصدیق کرنے والے نوڈز سے زیادہ لاگت ادا کرنی پڑتی ہے، کیونکہ اضافی تصدیق کا وقت بلاک کی تشہیر میں تاخیر کرتا ہے اور اس طرح اس امکان کو بڑھاتا ہے کہ بلاک ایک اسٹیل بن جائے گا۔
2. غیر-مائننگ فل نوڈز موجود ہیں۔
3. مائننگ پاور کی تقسیم عملی طور پر یکسر غیر مساوی ہو سکتی ہے۔
4. قیاس آرائی کرنے والے، سیاسی دشمن اور پاگل جن کی افادیت کا فنکشن نیٹ ورک کو نقصان پہنچانا شامل ہے، موجود ہیں، اور وہ چالاکی سے ایسے کنٹریکٹس قائم کر سکتے ہیں جہاں ان کی لاگت دیگر تصدیق کرنے والے نوڈز کی طرف سے ادا کی جانے والی لاگت سے بہت کم ہو۔

(1) مائنر کو کم ٹرانزیکشنز شامل کرنے کا رجحان فراہم کرتا ہے، اور
(2) `NC` کو بڑھاتا ہے؛ لہذا، یہ دونوں اثرات کم از کم جزوی طور پر
ایک دوسرے کو منسوخ کر دیتے ہیں <sup>[کیسے؟](https://web.archive.org/web/20250427212319/https://github.com/ethereum/wiki/issues/447#issuecomment-316972260#issuecomment-316972260)</sup>
(3) اور (4) بڑے مسئلے ہیں؛ انہیں حل کرنے کے لیے ہم صرف ایک
فلوٹنگ کیپ قائم کرتے ہیں: کوئی بھی بلاک طویل مدتی ایکسپونینشل موونگ ایوریج کے `BLK_LIMIT_FACTOR` گنا سے زیادہ آپریشنز نہیں رکھ سکتا۔
خاص طور پر:

```js
blk.oplimit = floor((blk.parent.oplimit \* (EMAFACTOR - 1) +
floor(parent.opcount \* BLK\_LIMIT\_FACTOR)) / EMA\_FACTOR)
```

`BLK_LIMIT_FACTOR` اور `EMA_FACTOR` مستقل ہیں جو فی الحال 65536 اور 1.5 پر سیٹ کیے جائیں گے، لیکن مزید تجزیے کے بعد ممکنہ طور پر تبدیل کیے جائیں گے۔

Bitcoin میں بڑے بلاک سائز کی حوصلہ شکنی کرنے والا ایک اور عنصر ہے: جو بلاکس بڑے ہوتے ہیں انہیں پھیلنے میں زیادہ وقت لگے گا، اور اس طرح ان کے اسٹیل بننے کا زیادہ امکان ہوتا ہے۔ ایتھیریم میں، بہت زیادہ گیس استعمال کرنے والے بلاکس کو پھیلنے میں زیادہ وقت لگ سکتا ہے کیونکہ وہ جسمانی طور پر بڑے ہوتے ہیں اور کیونکہ انہیں توثیق کے لیے ٹرانزیکشن اسٹیٹ ٹرانزیشن پر کارروائی کرنے میں زیادہ وقت لگتا ہے۔ یہ تاخیر کی حوصلہ شکنی Bitcoin میں ایک اہم غور ہے، لیکن ایتھیریم میں GHOST پروٹوکول کی وجہ سے کم ہے؛ لہذا، ریگولیٹڈ بلاک کی حدود پر انحصار کرنا ایک زیادہ مستحکم بنیاد فراہم کرتا ہے۔

### کمپیوٹیشن اور ٹورنگ-کمپلیٹنس {#computation-and-turing-completeness}

ایک اہم نوٹ یہ ہے کہ ایتھیریم ورچوئل مشین ٹورنگ-کمپلیٹ ہے؛ اس کا مطلب ہے کہ EVM کوڈ کسی بھی کمپیوٹیشن کو انکوڈ کر سکتا ہے جو ممکنہ طور پر کیا جا سکتا ہے، بشمول لامحدود لوپس۔ EVM کوڈ دو طریقوں سے لوپنگ کی اجازت دیتا ہے۔ پہلا، ایک `JUMP` ہدایت ہے جو پروگرام کو کوڈ میں پچھلی جگہ پر واپس جانے کی اجازت دیتی ہے، اور ایک `JUMPI` ہدایت ہے جو مشروط جمپنگ کرنے کی اجازت دیتی ہے، جس سے `while x < 27: x = x * 2` جیسے بیانات کی اجازت ملتی ہے۔ دوسرا، کنٹریکٹس دوسرے کنٹریکٹس کو کال کر سکتے ہیں، جو ممکنہ طور پر ریکرشن کے ذریعے لوپنگ کی اجازت دیتے ہیں۔ یہ قدرتی طور پر ایک مسئلہ پیدا کرتا ہے: کیا بدنیتی پر مبنی صارفین بنیادی طور پر مائنرز اور فل نوڈز کو لامحدود لوپ میں داخل ہونے پر مجبور کرکے بند کر سکتے ہیں؟ یہ مسئلہ کمپیوٹر سائنس میں ایک مسئلہ کی وجہ سے پیدا ہوتا ہے جسے ہالٹنگ پرابلم کے نام سے جانا جاتا ہے: عام معاملے میں، یہ بتانے کا کوئی طریقہ نہیں ہے کہ آیا کوئی دیا گیا پروگرام کبھی رکے گا یا نہیں۔

جیسا کہ اسٹیٹ ٹرانزیشن سیکشن میں بیان کیا گیا ہے، ہمارا حل ایک ٹرانزیکشن کو کمپیوٹیشنل اقدامات کی زیادہ سے زیادہ تعداد مقرر کرنے کی ضرورت کے ذریعے کام کرتا ہے جس کی اسے اجازت ہے، اور اگر عملدرآمد میں زیادہ وقت لگتا ہے تو کمپیوٹیشن کو واپس کر دیا جاتا ہے لیکن فیس پھر بھی ادا کی جاتی ہے۔ پیغامات اسی طرح کام کرتے ہیں۔ ہمارے حل کے پیچھے کی تحریک کو ظاہر کرنے کے لیے، مندرجہ ذیل مثالوں پر غور کریں:

- ایک حملہ آور ایک کنٹریکٹ بناتا ہے جو ایک لامحدود لوپ چلاتا ہے، اور پھر اس لوپ کو فعال کرنے کے لیے مائنر کو ایک ٹرانزیکشن بھیجتا ہے۔ مائنر ٹرانزیکشن پر کارروائی کرے گا، لامحدود لوپ چلائے گا، اور اس کے گیس سے باہر ہونے کا انتظار کرے گا۔ اگرچہ عملدرآمد گیس سے باہر ہو جاتا ہے اور آدھے راستے میں رک جاتا ہے، ٹرانزیکشن اب بھی درست ہے اور مائنر اب بھی حملہ آور سے ہر کمپیوٹیشنل قدم کے لیے فیس کا دعویٰ کرتا ہے۔
- ایک حملہ آور ایک بہت لمبا لامحدود لوپ بناتا ہے اس ارادے سے کہ مائنر کو اتنی دیر تک کمپیوٹنگ جاری رکھنے پر مجبور کیا جائے کہ جب تک کمپیوٹیشن ختم ہو جائے کچھ اور بلاکس نکل چکے ہوں گے اور مائنر کے لیے فیس کا دعویٰ کرنے کے لیے ٹرانزیکشن کو شامل کرنا ممکن نہیں ہوگا۔ تاہم، حملہ آور کو `STARTGAS` کے لیے ایک قدر جمع کرانی ہوگی جو عملدرآمد کے لے سکنے والے کمپیوٹیشنل اقدامات کی تعداد کو محدود کرتی ہے، لہذا مائنر کو پہلے سے معلوم ہوگا کہ کمپیوٹیشن میں بہت زیادہ اقدامات لگیں گے۔
- ایک حملہ آور `send(A,contract.storage[A]); contract.storage[A] = 0` جیسی شکل کے کوڈ کے ساتھ ایک معاہدہ دیکھتا ہے، اور صرف اتنی گیس کے ساتھ ایک ٹرانزیکشن بھیجتا ہے کہ وہ پہلا مرحلہ چلا سکے لیکن دوسرا نہیں (یعنی، رقم نکالنا لیکن بیلنس کو کم نہ ہونے دینا)۔ کنٹریکٹ کے مصنف کو ایسے حملوں سے بچنے کے بارے میں فکر کرنے کی ضرورت نہیں ہے، کیونکہ اگر عملدرآمد آدھے راستے میں رک جاتا ہے تو تبدیلیاں واپس کر دی جاتی ہیں۔
- ایک مالیاتی کنٹریکٹ خطرے کو کم کرنے کے لیے نو ملکیتی ڈیٹا فیڈز کے میڈین کو لے کر کام کرتا ہے۔ ایک حملہ آور ڈیٹا فیڈز میں سے ایک پر قبضہ کر لیتا ہے، جسے DAOs پر سیکشن میں بیان کردہ متغیر-ایڈریس-کال میکانزم کے ذریعے قابل ترمیم کرنے کے لیے ڈیزائن کیا گیا ہے، اور اسے ایک لامحدود لوپ چلانے کے لیے تبدیل کر دیتا ہے، اس طرح مالیاتی کنٹریکٹ سے فنڈز کا دعویٰ کرنے کی کسی بھی کوشش کو گیس سے باہر ہونے پر مجبور کرنے کی کوشش کرتا ہے۔ تاہم، مالیاتی کنٹریکٹ اس مسئلے کو روکنے کے لیے پیغام پر گیس کی حد مقرر کر سکتا ہے۔

ٹورنگ-کمپلیٹنس کا متبادل ٹورنگ-انکمپلیٹنس ہے، جہاں `JUMP` اور `JUMPI` موجود نہیں ہیں اور کسی بھی وقت کال اسٹیک میں ہر کنٹریکٹ کی صرف ایک کاپی موجود ہونے کی اجازت ہے۔ اس نظام کے ساتھ، بیان کردہ فیس سسٹم اور ہمارے حل کی تاثیر کے بارے میں غیر یقینی صورتحال ضروری نہیں ہو سکتی، کیونکہ ایک کنٹریکٹ پر عمل کرنے کی لاگت اس کے سائز سے اوپر محدود ہوگی۔ مزید برآں، ٹورنگ-انکمپلیٹنس اتنی بڑی حد بھی نہیں ہے؛ ہمارے اندرونی طور پر سوچے گئے تمام کنٹریکٹ کی مثالوں میں سے، اب تک صرف ایک کو لوپ کی ضرورت تھی، اور یہاں تک کہ اس لوپ کو بھی ایک لائن کے کوڈ کی 26 تکرار کرکے ہٹایا جا سکتا ہے۔ ٹورنگ-کمپلیٹنس کے سنگین مضمرات، اور محدود فائدے کو دیکھتے ہوئے، صرف ایک ٹورنگ-انکمپلیٹ زبان کیوں نہ ہو؟ تاہم، حقیقت میں، ٹورنگ-انکمپلیٹنس مسئلے کا ایک صاف ستھرا حل نہیں ہے۔ یہ دیکھنے کے لیے کہ کیوں، مندرجہ ذیل کنٹریکٹس پر غور کریں:

```sh
C0: call(C1); call(C1);
C1: call(C2); call(C2);
C2: call(C3); call(C3);
...
C49: call(C50); call(C50);
C50: (پروگرام کا ایک مرحلہ چلائیں اور اسٹوریج میں تبدیلی ریکارڈ کریں)
```

اب، A کو ایک ٹرانزیکشن بھیجیں۔ اس طرح، 51 ٹرانزیکشنز میں، ہمارے پاس ایک کنٹریکٹ ہے جو 2<sup>50</sup> کمپیوٹیشنل اقدامات لیتا ہے۔ مائنرز ہر کنٹریکٹ کے ساتھ ایک قدر برقرار رکھ کر ایسے لاجک بموں کا پہلے سے پتہ لگانے کی کوشش کر سکتے ہیں جو اس کے لے سکنے والے کمپیوٹیشنل اقدامات کی زیادہ سے زیادہ تعداد کی وضاحت کرتی ہے، اور دوسرے کنٹریکٹس کو ریکرسیولی طور پر کال کرنے والے کنٹریکٹس کے لیے اس کا حساب لگا سکتے ہیں، لیکن اس کے لیے مائنرز کو ان کنٹریکٹس پر پابندی لگانے کی ضرورت ہوگی جو دوسرے کنٹریکٹس بناتے ہیں (کیونکہ اوپر کے تمام 26 کنٹریکٹس کی تخلیق اور عملدرآمد کو آسانی سے ایک ہی کنٹریکٹ میں لپیٹا جا سکتا ہے)۔ ایک اور مشکل نکتہ یہ ہے کہ ایک پیغام کا ایڈریس فیلڈ ایک متغیر ہے، لہذا عام طور پر یہ بتانا بھی ممکن نہیں ہو سکتا کہ کوئی دیا گیا کنٹریکٹ پہلے سے کن دوسرے کنٹریکٹس کو کال کرے گا۔ لہذا، مجموعی طور پر، ہم ایک حیرت انگیز نتیجے پر پہنچتے ہیں: ٹورنگ-کمپلیٹنس کا انتظام حیرت انگیز طور پر آسان ہے، اور ٹورنگ-کمپلیٹنس کی کمی کا انتظام اتنا ہی حیرت انگیز طور پر مشکل ہے جب تک کہ وہی کنٹرولز موجود نہ ہوں - لیکن اس صورت میں پروٹوکول کو ٹورنگ-کمپلیٹ کیوں نہ رہنے دیا جائے؟

### کرنسی اور اجراء {#currency-and-issuance}

ایتھیریم نیٹ ورک میں اس کی اپنی بلٹ-ان کرنسی، ایتھر شامل ہے، جو مختلف قسم کے ڈیجیٹل اثاثوں کے درمیان موثر تبادلے کی اجازت دینے کے لیے ایک بنیادی لیکویڈیٹی پرت فراہم کرنے اور، زیادہ اہم بات، ٹرانزیکشن فیس ادا کرنے کے لیے ایک میکانزم فراہم کرنے کے دوہرے مقصد کو پورا کرتی ہے۔ سہولت کے لیے اور مستقبل کی بحث سے بچنے کے لیے (Bitcoin میں موجودہ mBTC/uBTC/satoshi بحث دیکھیں)، ڈینومینیشنز پہلے سے لیبل شدہ ہوں گی:

- 1: wei
- 10<sup>12</sup>: szabo
- 10<sup>15</sup>: finney
- 10<sup>18</sup>: ether

اسے \"ڈالر\" اور \"سینٹ\" یا \"BTC\" اور \"satoshi\" کے تصور کے ایک توسیع شدہ ورژن کے طور پر لیا جانا چاہئے۔ قریب مستقبل میں، ہم توقع کرتے ہیں کہ \"ether\" عام ٹرانزیکشنز کے لیے، \"finney\" مائیکرو ٹرانزیکشنز کے لیے اور \"szabo\" اور \"wei\" فیس اور پروٹوکول کے نفاذ کے بارے میں تکنیکی بحثوں کے لیے استعمال ہوں گے؛ باقی ڈینومینیشنز بعد میں مفید ہو سکتی ہیں اور اس وقت کلائنٹس میں شامل نہیں کی جانی چاہئیں۔

اجراء کا ماڈل مندرجہ ذیل ہوگا:

- ایتھر کو ایک کرنسی کی فروخت میں 1000-2000 ایتھر فی BTC کی قیمت پر جاری کیا جائے گا، ایک ایسا میکانزم جس کا مقصد ایتھیریم تنظیم کو فنڈ کرنا اور ترقی کے لیے ادائیگی کرنا ہے جو دیگر پلیٹ فارمز جیسے Mastercoin اور NXT کے ذریعے کامیابی کے ساتھ استعمال کیا گیا ہے۔ پہلے کے خریداروں کو بڑی چھوٹ سے فائدہ ہوگا۔ فروخت سے حاصل ہونے والی BTC کو مکمل طور پر ڈویلپرز کو تنخواہیں اور انعامات ادا کرنے اور ایتھیریم اور کریپٹو کرنسی ایکو سسٹم میں مختلف منافع بخش اور غیر منافع بخش منصوبوں میں سرمایہ کاری کرنے کے لیے استعمال کیا جائے گا۔
- کل فروخت شدہ رقم کا 0.099x (60102216 ETH) ابتدائی شراکت داروں کو معاوضہ دینے اور جینیسس بلاک سے پہلے ETH-ڈینوینیٹڈ اخراجات ادا کرنے کے لیے تنظیم کو مختص کیا جائے گا۔
- کل فروخت شدہ رقم کا 0.099x طویل مدتی ریزرو کے طور پر برقرار رکھا جائے گا۔
- اس کے بعد کل فروخت شدہ رقم کا 0.26x ہمیشہ کے لیے ہر سال مائنرز کو مختص کیا جائے گا۔

| گروپ                           | لانچ کے وقت            | 1 سال کے بعد           | 5 سال کے بعد           |
| ------------------------------ | ---------------------- | ---------------------- | ---------------------- |
| کرنسی یونٹس                    | 1.198X | 1.458X | 2.498X |
| خریدار                         | 83.5%  | 68.6%  | 40.0%  |
| پری-سیل میں خرچ شدہ ریزرو      | 8.26%  | 6.79%  | 3.96%  |
| پوسٹ-سیل میں استعمال شدہ ریزرو | 8.26%  | 6.79%  | 3.96%  |
| مائنرز                         | 0%                     | 17.8%  | 52.0%  |

#### طویل مدتی سپلائی گروتھ ریٹ (فیصد)

![ایتھیریم انفلیشن](./ethereum-inflation.png)

_لکیری کرنسی کے اجراء کے باوجود، Bitcoin کی طرح وقت کے ساتھ سپلائی کی شرح نمو صفر کی طرف مائل ہوتی ہے۔_

مذکورہ بالا ماڈل میں دو اہم انتخاب ہیں (1) ایک انڈومنٹ پول کا وجود اور سائز، اور (2) Bitcoin کی طرح محدود سپلائی کے برعکس، مستقل طور پر بڑھتی ہوئی لکیری سپلائی کا وجود۔ انڈومنٹ پول کا جواز مندرجہ ذیل ہے۔ اگر انڈومنٹ پول موجود نہ ہوتا، اور لکیری اجراء کو اسی افراط زر کی شرح فراہم کرنے کے لیے 0.217x تک کم کر دیا جاتا، تو ایتھر کی کل مقدار 16.5% کم ہوتی اور اس لیے ہر یونٹ 19.8% زیادہ قیمتی ہوتا۔ لہذا، توازن میں فروخت میں 19.8% زیادہ ایتھر خریدا جائے گا، لہذا ہر یونٹ ایک بار پھر بالکل پہلے کی طرح قیمتی ہوگا۔ تنظیم کے پاس بھی 1.198x زیادہ BTC ہوگا، جسے دو حصوں میں تقسیم کیا جا سکتا ہے: اصل BTC، اور اضافی 0.198x۔ لہذا، یہ صورتحال _بالکل مساوی_ ہے انڈومنٹ کے، لیکن ایک اہم فرق کے ساتھ: تنظیم خالصتاً BTC رکھتی ہے، اور اس لیے اسے ایتھر یونٹ کی قدر کی حمایت کرنے کی ترغیب نہیں ملتی ہے۔

مستقل لکیری سپلائی کی نمو کا ماڈل اس خطرے کو کم کرتا ہے جسے کچھ لوگ Bitcoin میں ضرورت سے زیادہ دولت کے ارتکاز کے طور پر دیکھتے ہیں، اور موجودہ اور مستقبل کے دور میں رہنے والے افراد کو کرنسی یونٹ حاصل کرنے کا ایک منصفانہ موقع فراہم کرتا ہے، جبکہ بیک وقت ایتھر حاصل کرنے اور رکھنے کی ایک مضبوط ترغیب کو برقرار رکھتا ہے کیونکہ فیصد کے طور پر \"سپلائی کی شرح نمو\" اب بھی وقت کے ساتھ صفر کی طرف مائل ہوتی ہے۔ ہم یہ بھی نظریہ پیش کرتے ہیں کہ چونکہ لاپرواہی، موت، وغیرہ کی وجہ سے سکے وقت کے ساتھ ہمیشہ ضائع ہو جاتے ہیں، اور سکوں کے نقصان کو سالانہ کل سپلائی کے فیصد کے طور پر ماڈل کیا جا سکتا ہے، کہ گردش میں کل کرنسی کی سپلائی درحقیقت آخرکار سالانہ اجراء کو نقصان کی شرح سے تقسیم کرنے کے برابر ایک قدر پر مستحکم ہو جائے گی (مثال کے طور پر، 1% کی نقصان کی شرح پر، جب سپلائی 26X تک پہنچ جائے گی تو ہر سال 0.26X مائن کیا جائے گا اور 0.26X ضائع ہو جائے گا، جس سے ایک توازن پیدا ہوگا)۔

نوٹ کریں کہ مستقبل میں، یہ امکان ہے کہ ایتھیریم سیکیورٹی کے لیے پروف-آف-اسٹیک ماڈل پر سوئچ کرے گا، جس سے اجراء کی ضرورت صفر اور 0.05X فی سال کے درمیان کہیں کم ہو جائے گی۔ اس صورت میں کہ ایتھیریم تنظیم فنڈنگ کھو دیتی ہے یا کسی اور وجہ سے غائب ہو جاتی ہے، ہم ایک \"سماجی معاہدہ\" کھلا چھوڑتے ہیں: کسی کو بھی ایتھیریم کا مستقبل کا امیدوار ورژن بنانے کا حق ہے، اس واحد شرط کے ساتھ کہ ایتھر کی مقدار زیادہ سے زیادہ `60102216 * (1.198 + 0.26 * n)` کے برابر ہونی چاہئے جہاں `n` جینیسس بلاک کے بعد سالوں کی تعداد ہے۔ تخلیق کار ترقی کے لیے ادائیگی کے لیے PoS سے چلنے والی سپلائی کی توسیع اور زیادہ سے زیادہ قابل اجازت سپلائی کی توسیع کے درمیان فرق کا کچھ یا تمام حصہ کراؤڈ سیل کرنے یا بصورت دیگر تفویض کرنے کے لیے آزاد ہیں۔ امیدوار اپ گریڈز جو سماجی معاہدے کی تعمیل نہیں کرتے ہیں انہیں جائز طور پر تعمیل کرنے والے ورژنز میں فورک کیا جا سکتا ہے۔

### مائننگ مرکزیت {#mining-centralization}

Bitcoin مائننگ الگورتھم کام کرتا ہے جس میں مائنرز بلاک ہیڈر کے قدرے ترمیم شدہ ورژنز پر لاکھوں بار SHA256 کا حساب لگاتے ہیں، جب تک کہ بالآخر ایک نوڈ ایک ایسا ورژن نہ لے آئے جس کا ہیش ہدف سے کم ہو (فی الحال تقریباً 2<sup>192</sup>)۔ تاہم، یہ مائننگ الگورتھم مرکزیت کی دو شکلوں کے لیے کمزور ہے۔ پہلا، مائننگ ایکو سسٹم پر ASICs (ایپلی کیشن-اسپیسفک انٹیگریٹڈ سرکٹس) کا غلبہ ہو گیا ہے، جو کمپیوٹر چپس ہیں جو Bitcoin مائننگ کے مخصوص کام کے لیے ڈیزائن کی گئی ہیں، اور اس لیے ہزاروں گنا زیادہ موثر ہیں۔ اس کا مطلب ہے کہ Bitcoin مائننگ اب ایک انتہائی ڈی سینٹرلائزڈ اور مساویانہ تعاقب نہیں رہی، جس میں مؤثر طریقے سے حصہ لینے کے لیے لاکھوں ڈالر کی سرمایہ کاری کی ضرورت ہے۔ دوسرا، زیادہ تر Bitcoin مائنرز اصل میں مقامی طور پر بلاک کی توثیق نہیں کرتے ہیں؛ اس کے بجائے، وہ بلاک ہیڈرز فراہم کرنے کے لیے ایک مرکزی مائننگ پول پر انحصار کرتے ہیں۔ یہ مسئلہ بلاشبہ بدتر ہے: اس تحریر کے وقت، سب سے اوپر کے تین مائننگ پولز بالواسطہ طور پر Bitcoin نیٹ ورک میں تقریباً 50% پروسیسنگ پاور کو کنٹرول کرتے ہیں، اگرچہ اس کو اس حقیقت سے کم کیا جاتا ہے کہ مائنرز دوسرے مائننگ پولز پر سوئچ کر سکتے ہیں اگر کوئی پول یا اتحاد 51% حملے کی کوشش کرتا ہے۔

ایتھیریم میں موجودہ ارادہ ایک ایسا مائننگ الگورتھم استعمال کرنا ہے جہاں مائنرز کو اسٹیٹ سے بے ترتیب ڈیٹا حاصل کرنے، بلاک چین میں آخری N بلاکس سے کچھ بے ترتیب منتخب ٹرانزیکشنز کا حساب لگانے، اور نتیجے کا ہیش واپس کرنے کی ضرورت ہوتی ہے۔ اس کے دو اہم فائدے ہیں۔ سب سے پہلے، Ethereum معاہدوں میں کسی بھی قسم کی کمپیوٹیشن شامل ہو سکتی ہے، لہذا ایک Ethereum ASIC بنیادی طور پر عمومی کمپیوٹیشن کے لیے ایک ASIC ہوگا - یعنی، ایک بہتر CPU۔ دوسرا، مائننگ کے لیے پوری بلاک چین تک رسائی کی ضرورت ہوتی ہے، جس سے مائنرز کو پوری بلاک چین کو محفوظ کرنے اور کم از کم ہر ٹرانزیکشن کی تصدیق کرنے کے قابل ہونے پر مجبور کیا جاتا ہے۔ یہ مرکزی مائننگ پولز کی ضرورت کو ختم کرتا ہے؛ اگرچہ مائننگ پولز اب بھی انعام کی تقسیم کی بے ترتیب پن کو برابر کرنے کا جائز کردار ادا کر سکتے ہیں، اس فنکشن کو بغیر کسی مرکزی کنٹرول کے پیئر-ٹو-پیئر پولز کے ذریعے بھی اتنا ہی اچھی طرح سے انجام دیا جا سکتا ہے۔

یہ ماڈل غیر آزمودہ ہے، اور کنٹریکٹ کے عملدرآمد کو مائننگ الگورتھم کے طور پر استعمال کرتے وقت کچھ ہوشیار اصلاحات سے بچنے میں راستے میں مشکلات ہو سکتی ہیں۔ تاہم، اس الگورتھم کی ایک قابل ذکر دلچسپ خصوصیت یہ ہے کہ یہ کسی کو بھی \"کنویں میں زہر گھولنے\" کی اجازت دیتا ہے، بلاک چین میں بڑی تعداد میں ایسے کنٹریکٹس متعارف کروا کر جو خاص طور پر کچھ ASICs کو ناکام بنانے کے لیے بنائے گئے ہیں۔ ASIC مینوفیکچررز کے لیے ایک دوسرے پر حملہ کرنے کے لیے ایسی چال کا استعمال کرنے کی اقتصادی ترغیبات موجود ہیں۔ اس طرح، جو حل ہم تیار کر رہے ہیں وہ بالآخر خالصتاً تکنیکی حل کے بجائے ایک انکولی اقتصادی انسانی حل ہے۔

### اسکیل ایبلٹی {#scalability}

ایتھیریم کے بارے میں ایک عام تشویش اسکیل ایبلٹی کا مسئلہ ہے۔ Bitcoin کی طرح، ایتھیریم بھی اس خامی کا شکار ہے کہ ہر ٹرانزیکشن کو نیٹ ورک میں ہر نوڈ کے ذریعے پروسیس کرنے کی ضرورت ہوتی ہے۔ Bitcoin کے ساتھ، موجودہ بلاک چین کا سائز تقریباً 15 جی بی ہے، جو تقریباً 1 ایم بی فی گھنٹہ کی شرح سے بڑھ رہا ہے۔ اگر Bitcoin نیٹ ورک کو ویزا کی 2000 ٹرانزیکشنز فی سیکنڈ پر کارروائی کرنی پڑے، تو یہ ہر تین سیکنڈ میں 1 ایم بی (1 جی بی فی گھنٹہ، 8 ٹی بی فی سال) بڑھے گا۔ ایتھیریم کو بھی اسی طرح کی ترقی کی طرز کا سامنا کرنے کا امکان ہے، اس حقیقت سے بدتر کہ ایتھیریم بلاک چین پر صرف ایک کرنسی کے بجائے بہت سی ایپلی کیشنز ہوں گی جیسا کہ Bitcoin کے معاملے میں ہے، لیکن اس حقیقت سے بہتر کہ ایتھیریم فل نوڈز کو پوری بلاک چین کی تاریخ کے بجائے صرف اسٹیٹ کو محفوظ کرنے کی ضرورت ہے۔

اتنے بڑے بلاک چین سائز کے ساتھ مسئلہ مرکزیت کا خطرہ ہے۔ اگر بلاک چین کا سائز بڑھ کر، مان لیں کہ، 100 ٹی بی ہو جاتا ہے، تو ممکنہ منظرنامہ یہ ہوگا کہ صرف بہت کم تعداد میں بڑے کاروبار فل نوڈز چلائیں گے، اور تمام باقاعدہ صارفین لائٹ SPV نوڈز استعمال کریں گے۔ ایسی صورت حال میں، یہ ممکنہ تشویش پیدا ہوتی ہے کہ فل نوڈز اکٹھے ہو سکتے ہیں اور سب کسی منافع بخش طریقے سے دھوکہ دینے پر متفق ہو سکتے ہیں (مثلاً، بلاک انعام کو تبدیل کرنا، خود کو BTC دینا)۔ لائٹ نوڈز کے پاس اس کا فوری طور پر پتہ لگانے کا کوئی طریقہ نہیں ہوگا۔ یقیناً، کم از کم ایک ایماندار فل نوڈ موجود ہونے کا امکان ہے، اور چند گھنٹوں کے بعد دھوکہ دہی کے بارے میں معلومات ریڈٹ جیسے چینلز کے ذریعے پھیل جائے گی، لیکن اس وقت تک بہت دیر ہو چکی ہوگی: یہ عام صارفین پر منحصر ہوگا کہ وہ دیے گئے بلاکس کو بلیک لسٹ کرنے کی کوشش منظم کریں، ایک بہت بڑا اور ممکنہ طور پر ناقابل عمل ہم آہنگی کا مسئلہ جو 51% حملے کو کامیابی سے انجام دینے کے پیمانے جیسا ہے۔ Bitcoin کے معاملے میں، یہ فی الحال ایک مسئلہ ہے، لیکن ایک بلاک چین میں ترمیم موجود ہے [جس کی تجویز پیٹر ٹوڈ نے دی ہے](https://web.archive.org/web/20140623061815/http://sourceforge.net/p/bitcoin/mailman/message/31709140/) جو اس مسئلے کو کم کرے گی۔

قریب مدت میں، ایتھیریم اس مسئلے سے نمٹنے کے لیے دو اضافی حکمت عملیوں کا استعمال کرے گا۔ پہلا، بلاک چین پر مبنی مائننگ الگورتھم کی وجہ سے، کم از کم ہر مائنر کو ایک فل نوڈ بننے پر مجبور کیا جائے گا، جس سے فل نوڈز کی تعداد پر ایک نچلی حد پیدا ہوگی۔ تاہم، دوسرا اور زیادہ اہم بات یہ ہے کہ، ہم ہر ٹرانزیکشن پر کارروائی کرنے کے بعد بلاک چین میں ایک انٹرمیڈیٹ اسٹیٹ ٹری روٹ شامل کریں گے۔ یہاں تک کہ اگر بلاک کی توثیق مرکزی ہے، جب تک ایک ایماندار تصدیق کرنے والا نوڈ موجود ہے، مرکزیت کے مسئلے کو ایک توثیقی پروٹوکول کے ذریعے بچایا جا سکتا ہے۔ اگر کوئی مائنر ایک غلط بلاک شائع کرتا ہے، تو وہ بلاک یا تو خراب فارمیٹ میں ہونا چاہیے، یا اسٹیٹ `S[n]` غلط ہے۔ چونکہ `S[0]` کو درست مانا جاتا ہے، لہذا کوئی پہلی اسٹیٹ `S[i]` ضرور غلط ہوگی جہاں `S[i-1]` درست ہے۔ تصدیق کرنے والا نوڈ انڈیکس `i` فراہم کرے گا، جس کے ساتھ "غلط ہونے کا ثبوت" ہوگا جو `APPLY(S[i-1],TX[i]) -> S[i]` پر عمل کرنے کے لیے ضروری پیٹریشیا ٹری نوڈس کے سب سیٹ پر مشتمل ہوگا۔ نوڈز ان نوڈز کا استعمال کمپیوٹیشن کے اس حصے کو چلانے کے لیے کر سکیں گے، اور یہ دیکھ سکیں گے کہ تیار کردہ `S[i]` فراہم کردہ `S[i]` سے میل نہیں کھاتا ہے۔

ایک اور، زیادہ پیچیدہ، حملے میں بدنیتی پر مبنی مائنرز کا نامکمل بلاکس شائع کرنا شامل ہوگا، تاکہ یہ تعین کرنے کے لیے پوری معلومات بھی موجود نہ ہو کہ بلاکس درست ہیں یا نہیں۔ اس کا حل ایک چیلنج-ریسپانس پروٹوکول ہے: تصدیقی نوڈز ٹارگیٹ ٹرانزیکشن انڈیکس کی شکل میں "چیلنجز" جاری کرتے ہیں، اور نوڈ موصول ہونے پر ایک لائٹ نوڈ بلاک کو اس وقت تک غیر معتبر سمجھتا ہے جب تک کہ کوئی دوسرا نوڈ، خواہ وہ مائنر ہو یا کوئی اور تصدیق کنندہ، درستگی کے ثبوت کے طور پر پیٹریشیا نوڈز کا ایک سب سیٹ فراہم نہ کرے۔

## نتیجہ {#conclusion}

Ethereum پروٹوکول کو اصل میں ایک کرپٹو کرنسی کے اپ گریڈ شدہ ورژن کے طور پر تصور کیا گیا تھا، جو ایک انتہائی عام پروگرامنگ زبان کے ذریعے آن-بلاک چین ایسکرو، نکالنے کی حدوں، مالیاتی معاہدوں، جوئے کے بازاروں اور اسی طرح کی جدید خصوصیات فراہم کرتا ہے۔ Ethereum پروٹوکول براہ راست کسی بھی ایپلیکیشن کو "سپورٹ" نہیں کرے گا، لیکن ٹیورنگ-کمپلیٹ پروگرامنگ زبان کی موجودگی کا مطلب ہے کہ نظریاتی طور پر کسی بھی ٹرانزیکشن کی قسم یا ایپلیکیشن کے لیے من مانے معاہدے بنائے جا سکتے ہیں۔ تاہم، Ethereum کے بارے میں زیادہ دلچسپ بات یہ ہے کہ Ethereum پروٹوکول صرف کرنسی سے بہت آگے ہے۔ غیر مرکزی فائل اسٹوریج، غیر مرکزی کمپیوٹیشن اور غیر مرکزی پیشین گوئی کے بازاروں کے ارد گرد کے پروٹوکول، درجنوں دیگر ایسے تصورات کے ساتھ، کمپیوٹیشنل انڈسٹری کی کارکردگی کو کافی حد تک بڑھانے کی صلاحیت رکھتے ہیں، اور پہلی بار ایک اقتصادی لیئر شامل کرکے دیگر پیئر-ٹو-پیئر پروٹوکولز کو زبردست فروغ فراہم کرتے ہیں۔ آخر میں، ایسی ایپلیکیشنز کی بھی ایک بڑی تعداد ہے جن کا پیسے سے کوئی تعلق نہیں ہے۔

Ethereum پروٹوکول کے ذریعے لاگو کردہ ایک من مانی اسٹیٹ ٹرانزیشن فنکشن کا تصور ایک منفرد صلاحیت والے پلیٹ فارم کے لیے فراہم کرتا ہے؛ ڈیٹا اسٹوریج، جوئے یا فنانس میں ایپلی کیشنز کی ایک مخصوص صف کے لیے بنائے گئے ایک بند، واحد مقصد والے پروٹوکول کے بجائے، Ethereum ڈیزائن کے لحاظ سے اوپن اینڈڈ ہے، اور ہمیں یقین ہے کہ یہ آنے والے سالوں میں مالی اور غیر مالی دونوں طرح کے پروٹوکولز کی ایک بہت بڑی تعداد کے لیے ایک بنیادی لیئر کے طور پر کام کرنے کے لیے انتہائی موزوں ہے۔

## نوٹس اور مزید پڑھنے کے لیے {#notes-and-further-reading}

### نوٹس {#notes}

1. ایک ماہر قاری یہ محسوس کر سکتا ہے کہ درحقیقت ایک Bitcoin ایڈریس ایلپٹک کرو پبلک کی کا ہیش ہے، نہ کہ خود پبلک کی۔ تاہم، درحقیقت پب کی ہیش کو خود ایک پبلک کی کے طور پر حوالہ دینا بالکل جائز کرپٹوگرافک اصطلاحات ہے۔ اس کی وجہ یہ ہے کہ Bitcoin کی کرپٹوگرافی کو ایک کسٹم ڈیجیٹل سگنیچر الگورتھم سمجھا جا سکتا ہے، جہاں پبلک کی ECC پب کی کے ہیش پر مشتمل ہوتی ہے، سگنیچر ECC پب کی کو ECC سگنیچر کے ساتھ جوڑ کر بنتا ہے، اور تصدیقی الگورتھم میں سگنیچر میں موجود ECC پب کی کو پبلک کی کے طور پر فراہم کردہ ECC پب کی ہیش کے خلاف چیک کرنا اور پھر ECC سگنیچر کو ECC پب کی کے خلاف تصدیق کرنا شامل ہے۔
2. تکنیکی طور پر، پچھلے 11 بلاکس کا میڈین۔
3. اندرونی طور پر، 2 اور "CHARLIE" دونوں نمبر ہیں<sup>[fn3](#notes)</sup>، جس میں بعد والا بگ-اینڈین بیس 256 نمائندگی میں ہے۔ نمبر کم از کم 0 اور زیادہ سے زیادہ 2<sup>256</sup>-1 ہو سکتے ہیں۔

### مزید مطالعہ {#further-reading}

1. [اندرونی قدر](https://bitcoinmagazine.com/culture/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it)
2. [اسمارٹ پراپرٹی](https://en.bitcoin.it/wiki/Smart_Property)
3. [اسمارٹ معاہدے](https://en.bitcoin.it/wiki/Contracts)
4. [B-money](http://www.weidai.com/bmoney.txt)
5. [دوبارہ قابل استعمال پروفس آف ورک](https://nakamotoinstitute.org/finney/rpow/)
6. [مالک کے اختیار کے ساتھ محفوظ پراپرٹی ٹائٹلز](https://nakamotoinstitute.org/library/secure-property-titles/)
7. [Bitcoin وائٹ پیپر](http://bitcoin.org/bitcoin.pdf)
8. [Namecoin](https://namecoin.org/)
9. [زوکو کا مثلث](https://wikipedia.org/wiki/Zooko's_triangle)
10. [کلرڈ کوائنز وائٹ پیپر](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)
11. [Mastercoin وائٹ پیپر](https://github.com/mastercoin-MSC/spec)
12. [غیر مرکزی خود مختار کارپوریشنز، Bitcoin میگزین](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/)
13. [آسان ادائیگی کی تصدیق](https://en.bitcoin.it/wiki/Scalability#Simplified_payment_verification)
14. [مرکل ٹریز](https://wikipedia.org/wiki/Merkle_tree)
15. [پیٹریشیا ٹریز](https://wikipedia.org/wiki/Patricia_tree)
16. [GHOST](https://eprint.iacr.org/2013/881.pdf)
17. [StorJ اور خود مختار ایجنٹس، Jeff Garzik](http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html)
18. [Mike Hearn ٹیورنگ فیسٹیول میں اسمارٹ پراپرٹی پر](https://www.youtube.com/watch?v=MVyv4t0OKe4)
19. [Ethereum RLP](/developers/docs/data-structures-and-encoding/rlp/)
20. [Ethereum مرکل پیٹریشیا ٹریز](/developers/docs/data-structures-and-encoding/patricia-merkle-trie/)
21. [Peter Todd مرکل سم ٹریز پر](https://web.archive.org/web/20140623061815/http://sourceforge.net/p/bitcoin/mailman/message/31709140/)

_وائٹ پیپر کی تاریخ کے لیے، [یہ وکی](https://web.archive.org/web/20250427212319/https://github.com/ethereum/wiki/blob/old-before-deleting-all-files-go-to-wiki-wiki-instead/old-whitepaper-for-historical-reference.md) دیکھیں۔_

_Ethereum، بہت سے کمیونٹی کے ذریعے چلنے والے، اوپن سورس سافٹ ویئر پروجیکٹس کی طرح، اپنے ابتدائی آغاز کے بعد سے تیار ہوا ہے۔ ایتھیریم کی تازہ ترین پیشرفتوں کے بارے میں جاننے کے لیے، اور پروٹوکول میں تبدیلیاں کیسے کی جاتی ہیں، ہم [اس گائیڈ](/learn/) کی سفارش کرتے ہیں۔_
