---
title: "பாதுகாப்புத் தண்டவாளங்களுடன் ERC-20"
description: "சின்னச் சின்ன தவறுகளைத் தவிர்க்க மக்களுக்கு உதவுவது எப்படி"
author: Ori Pomerantz
lang: ta
tags: [ "erc-20" ]
skill: beginner
published: 2022-08-15
---

## அறிமுகம் {#introduction}

எத்தேரியத்தைப் பற்றிய சிறந்த விஷயங்களில் ஒன்று என்னவென்றால், உங்கள் பரிவர்த்தனைகளை மாற்றவோ அல்லது செயல்தவிர்க்கவோ கூடிய எந்த மைய அதிகாரமும் இல்லை. எத்தேரியத்தில் உள்ள பெரிய சிக்கல்களில் ஒன்று என்னவென்றால், பயனர் தவறுகளையோ அல்லது சட்டவிரோத பரிவர்த்தனைகளையோ செயல்தவிர்க்கும் அதிகாரத்துடன் கூடிய எந்தவொரு மைய அதிகாரமும் இல்லை. இந்தக் கட்டுரையில், [ERC-20](/developers/docs/standards/tokens/erc-20/) டோக்கன்களைப் பயன்படுத்தும்போது பயனர்கள் செய்யும் சில பொதுவான தவறுகள் மற்றும் அந்தத் தவறுகளைத் தவிர்க்க பயனர்களுக்கு உதவும் ERC-20 ஒப்பந்தங்களை உருவாக்குவது எப்படி, அல்லது ஒரு மைய அதிகாரத்திற்கு சில அதிகாரங்களை (உதாரணமாக, கணக்குகளை முடக்குவது) கொடுப்பது எப்படி என்பது பற்றியும் நீங்கள் அறிந்து கொள்வீர்கள்.

[OpenZeppelin ERC-20 டோக்கன் ஒப்பந்தத்தை](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) நாம் பயன்படுத்தினாலும், இந்தக் கட்டுரை அதை மிக விரிவாக விளக்கவில்லை என்பதைக் கவனத்தில் கொள்ளவும். இந்தத் தகவலை நீங்கள் [இங்கே](/developers/tutorials/erc20-annotated-code) காணலாம்.

முழுமையான மூலக் குறியீட்டைப் பார்க்க விரும்பினால்:

1. [Remix IDE](https://remix.ethereum.org/)-ஐத் திறக்கவும்.
2. github குளோன் ஐகானைக் (![clone github icon](icon-clone.png)) கிளிக் செய்யவும்.
3. `https://github.com/qbzzt/20220815-erc20-safety-rails` என்ற github களஞ்சியத்தைக் குளோன் செய்யவும்.
4. **contracts > erc20-safety-rails.sol** கோப்பைத் திறக்கவும்.

## ஒரு ERC-20 ஒப்பந்தத்தை உருவாக்குதல் {#creating-an-erc-20-contract}

பாதுகாப்புத் தண்டவாளச் செயல்பாட்டைச் சேர்ப்பதற்கு முன், நமக்கு ஒரு ERC-20 ஒப்பந்தம் தேவை. இந்தக் கட்டுரையில் நாம் [OpenZeppelin ஒப்பந்த வழிகாட்டியை](https://docs.openzeppelin.com/contracts/5.x/wizard)ப் பயன்படுத்துவோம். அதை மற்றொரு உலாவியில் திறந்து இந்த வழிமுறைகளைப் பின்பற்றவும்:

1. **ERC20**-ஐத் தேர்ந்தெடுக்கவும்.

2. இந்த அமைப்புகளை உள்ளிடவும்:

   | அளவுரு              | மதிப்பு          |
   | ------------------- | ---------------- |
   | பெயர்               | SafetyRailsToken |
   | சின்னம்             | SAFE             |
   | Premint             | 1000             |
   | அம்சங்கள்           | ஏதுமில்லை        |
   | அணுகல் கட்டுப்பாடு  | Ownable          |
   | மேம்படுத்தும் தன்மை | ஏதுமில்லை        |

3. மேலே ஸ்க்ரோல் செய்து **Remix-இல் திற** (Remix-க்கு) அல்லது வேறுபட்ட சூழலைப் பயன்படுத்த **பதிவிறக்கு** என்பதைக் கிளிக் செய்யவும். நீங்கள் Remix-ஐப் பயன்படுத்துகிறீர்கள் என்று நான் கருதுகிறேன், நீங்கள் வேறு எதையாவது பயன்படுத்தினால், பொருத்தமான மாற்றங்களைச் செய்து கொள்ளுங்கள்.

4. இப்போது நம்மிடம் முழுமையாகச் செயல்படும் ஒரு ERC-20 ஒப்பந்தம் உள்ளது. இறக்குமதி செய்யப்பட்ட குறியீட்டைக் காண நீங்கள் `.deps` > `npm`-ஐ விரிவாக்கலாம்.

5. இது ஒரு ERC-20 ஒப்பந்தமாகச் செயல்படுவதைக் காண, ஒப்பந்தத்தைத் தொகுத்து, வரிசைப்படுத்தி, அதனுடன் இயக்கிப் பார்க்கவும். Remix-ஐ எப்படிப் பயன்படுத்துவது என்பதை நீங்கள் கற்றுக்கொள்ள வேண்டுமானால், [இந்தப் பயிற்சியைப்](https://remix.ethereum.org/?#activate=udapp,solidity,LearnEth) பயன்படுத்தவும்.

## பொதுவான தவறுகள் {#common-mistakes}

### தவறுகள் {#the-mistakes}

பயனர்கள் சில நேரங்களில் தவறான முகவரிக்கு டோக்கன்களை அனுப்புகிறார்கள். அவர்கள் என்ன செய்ய நினைத்தார்கள் என்பதை அறிய நாம் அவர்களின் மனதைப் படிக்க முடியாது என்றாலும், அடிக்கடி நிகழும் மற்றும் கண்டறிய எளிதான இரண்டு பிழை வகைகள் உள்ளன:

1. ஒப்பந்தத்தின் சொந்த முகவரிக்கு டோக்கன்களை அனுப்புதல். உதாரணமாக, [Optimism-இன் OP டோக்கன்](https://optimism.mirror.xyz/qvd0WfuLKnePm1Gxb9dpGchPf5uDz5NSMEFdgirDS4c) இரண்டு மாதங்களுக்கும் குறைவான காலத்தில் [120,000](https://optimism.blockscout.com/address/0x4200000000000000000000000000000000000042)-க்கும் மேற்பட்ட OP டோக்கன்களைத் திரட்டியது. இது ஒரு குறிப்பிடத்தக்க அளவு செல்வத்தைக் குறிக்கிறது, இதை மக்கள் வெறுமனே இழந்திருக்கக் கூடும்.

2. டோக்கன்களை ஒரு வெற்று முகவரிக்கு, அதாவது ஒரு [வெளிப்புற உரிமையாளர் கணக்குக்கோ](/developers/docs/accounts/#externally-owned-accounts-and-key-pairs) அல்லது ஒரு [திறன்மிகு ஒப்பந்தத்துக்கோ](/developers/docs/smart-contracts) உட்படாத முகவரிக்கு அனுப்புதல். இது எவ்வளவு அடிக்கடி நிகழ்கிறது என்பது குறித்த புள்ளிவிவரங்கள் என்னிடம் இல்லை என்றாலும், [ஒரு சம்பவம் 20,000,000 டோக்கன்கள் இழப்பை ஏற்படுத்தியிருக்கக்கூடும்](https://gov.optimism.io/t/message-to-optimism-community-from-wintermute/2595).

### பரிமாற்றங்களைத் தடுத்தல் {#preventing-transfers}

OpenZeppelin ERC-20 ஒப்பந்தம் [ஒரு கொக்கியை, `_beforeTokenTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L364-L368), கொண்டுள்ளது, இது ஒரு டோக்கன் மாற்றப்படுவதற்கு முன்பு அழைக்கப்படுகிறது. இயல்பாக, இந்தக் கொக்கி எதையும் செய்யாது, ஆனால் ஒரு சிக்கல் இருந்தால் செயல்தவிர்க்கும் சோதனைகள் போன்ற நமது சொந்த செயல்பாட்டை அதில் இணைக்கலாம்.

கொக்கியைப் பயன்படுத்த, கன்ஸ்ட்ரக்டருக்குப் பிறகு இந்தச் செயல்பாட்டைச் சேர்க்கவும்:

```solidity
    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal virtual
        override(ERC20)
    {
        super._beforeTokenTransfer(from, to, amount);
    }
```

நீங்கள் Solidity-இல் நன்கு பரிச்சயமில்லாதவராக இருந்தால், இந்தச் செயல்பாட்டின் சில பகுதிகள் உங்களுக்குப் புதியதாக இருக்கலாம்:

```solidity
        internal virtual
```

`ERC20`-இலிருந்து நாம் செயல்பாட்டைப் பெற்று இந்தச் செயல்பாட்டை மேலெழுதியது போலவே, மற்ற ஒப்பந்தங்களும் நம்மிடமிருந்து மரபுரிமையாகப் பெற்று இந்தச் செயல்பாட்டை மேலெழுத முடியும் என்பதையே `virtual` என்ற முக்கியச்சொல் குறிக்கிறது.

```solidity
        override(ERC20)
```

`_beforeTokenTransfer`-இன் ERC20 டோக்கன் வரையறையை நாம் [மேலெழுதுகிறோம்](https://docs.soliditylang.org/en/v0.8.15/contracts.html#function-overriding) என்பதை நாம் வெளிப்படையாகக் குறிப்பிட வேண்டும். பொதுவாக, பாதுகாப்புக் கண்ணோட்டத்தில், மறைமுகமான வரையறைகளை விட வெளிப்படையான வரையறைகள் மிகவும் சிறந்தவை - நீங்கள் செய்த ஒன்று உங்கள் கண் முன்னே இருந்தால் அதை உங்களால் மறக்க முடியாது. எந்த சூப்பர் கிளாஸின் `_beforeTokenTransfer`-ஐ நாம் மேலெழுதுகிறோம் என்பதைக் குறிப்பிட வேண்டியதற்கும் இதுவே காரணம்.

```solidity
        super._beforeTokenTransfer(from, to, amount);
```

இந்த வரியானது, நாம் மரபுரிமையாகப் பெற்ற மற்றும் அதைக் கொண்டிருக்கும் ஒப்பந்தம் அல்லது ஒப்பந்தங்களின் `_beforeTokenTransfer` செயல்பாட்டை அழைக்கிறது. இந்த நேர்வில், அது `ERC20` மட்டுமே, `Ownable`-இல் இந்தக் கொக்கி இல்லை. தற்போது `ERC20._beforeTokenTransfer` எதுவும் செய்யாவிட்டாலும், எதிர்காலத்தில் செயல்பாடு சேர்க்கப்பட்டால் நாம் அதை அழைக்கிறோம் (பின்னர் ஒப்பந்தத்தை மீண்டும் வரிசைப்படுத்த நாங்கள் முடிவு செய்தால், ஏனெனில் வரிசைப்படுத்தப்பட்ட பிறகு ஒப்பந்தங்கள் மாறாது).

### தேவைகளைக் குறியீடாக்குதல் {#coding-the-requirements}

பின்வரும் தேவைகளை நாம் செயல்பாட்டில் சேர்க்க விரும்புகிறோம்:

- `to` முகவரியானது `address(this)`-க்கு, அதாவது ERC-20 ஒப்பந்தத்தின் சொந்த முகவரிக்கு சமமாக இருக்க முடியாது.
- `to` முகவரி காலியாக இருக்க முடியாது, அது பின்வருவனவற்றில் ஒன்றாக இருக்க வேண்டும்:
  - வெளிப்புற உரிமையாளர் கணக்கு (EOA). ஒரு முகவரி EOA-வா என்பதை நம்மால் நேரடியாகச் சரிபார்க்க முடியாது, ஆனால் ஒரு முகவரியின் ETH இருப்பைச் சரிபார்க்கலாம். EOA-க்களில் அவை இனி பயன்படுத்தப்படாவிட்டாலும் கூட, எப்போதும் இருப்பு இருக்கும் - கடைசி wei வரை அவற்றை முழுமையாக காலி செய்வது கடினம்.
  - ஒரு திறன்மிகு ஒப்பந்தம். ஒரு முகவரி திறன்மிகு ஒப்பந்தமா என்பதைச் சோதிப்பது சற்று கடினமானது. வெளிப்புறக் குறியீட்டின் நீளத்தைச் சரிபார்க்கும் [`EXTCODESIZE`](https://www.evm.codes/#3b) என்ற ஒரு செயல்பாட்டுக் குறியீடு உள்ளது, ஆனால் அது Solidity-இல் நேரடியாகக் கிடைப்பதில்லை. அதற்கு, நாம் [Yul](https://docs.soliditylang.org/en/v0.8.15/yul.html)-ஐப் பயன்படுத்த வேண்டும், இது EVM அசெம்பிளி ஆகும். Solidity-இலிருந்து நாம் பயன்படுத்தக்கூடிய பிற மதிப்புகளும் ([`<address>.code` மற்றும் `<address>.codehash`](https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#members-of-address-types)) உள்ளன, ஆனால் அவை அதிக செலவு பிடிக்கும்.

புதிய குறியீட்டை வரி வரியாகப் பார்ப்போம்:

```solidity
        require(to != address(this), "ஒப்பந்த முகவரிக்கு டோக்கன்களை அனுப்ப முடியாது");
```

இது முதல் தேவை, `to` மற்றும் `this(address)` இரண்டும் ஒன்றல்ல என்பதைச் சரிபார்க்க வேண்டும்.

```solidity
        bool isToContract;
        assembly {
           isToContract := gt(extcodesize(to), 0)
        }
```

ஒரு முகவரி ஒப்பந்தமா என்பதை இப்படித்தான் சரிபார்க்கிறோம். Yul-இலிருந்து நேரடியாக வெளியீட்டைப் பெற முடியாது, எனவே பதிலாக முடிவைத் வைத்திருக்க ஒரு மாறியை (`isToContract` இந்த நேர்வில்) வரையறுக்கிறோம். Yul செயல்படும் விதம் என்னவென்றால், ஒவ்வொரு செயல்பாட்டுக் குறியீடும் ஒரு செயல்பாடாகக் கருதப்படுகிறது. எனவே முதலில் ஒப்பந்த அளவைப் பெற [`EXTCODESIZE`](https://www.evm.codes/#3b)-ஐ அழைக்கிறோம், பின்னர் அது பூஜ்ஜியம் அல்ல என்பதைச் சரிபார்க்க [`GT`](https://www.evm.codes/#11)-ஐப் பயன்படுத்துகிறோம் (நாம் குறியிடப்படாத முழு எண்களைக் கையாளுகிறோம், எனவே அது எதிர்மறையாக இருக்க முடியாது). பிறகு முடிவை `isToContract`-இல் எழுதுகிறோம்.

```solidity
        require(to.balance != 0 || isToContract, "வெற்று முகவரிக்கு டோக்கன்களை அனுப்ப முடியாது");
```

இறுதியாக, வெற்று முகவரிகளுக்கான உண்மையான சோதனை நம்மிடம் உள்ளது.

## நிர்வாக அணுகல் {#admin-access}

தவறுகளைச் செயல்தவிர்க்கக்கூடிய ஒரு நிர்வாகி இருப்பது சில நேரங்களில் பயனுள்ளதாக இருக்கும். துஷ்பிரயோகத்திற்கான வாய்ப்பைக் குறைக்க, இந்த நிர்வாகி ஒரு [பல்கையொப்பமாக](https://blog.logrocket.com/security-choices-multi-signature-wallets/) இருக்கலாம், இதன் மூலம் ஒரு செயலுக்கு பல நபர்கள் ஒப்புக்கொள்ள வேண்டும். இந்தக் கட்டுரையில் இரண்டு நிர்வாக அம்சங்களைக் காண்போம்:

1. கணக்குகளை முடக்குதல் மற்றும் விடுவித்தல். உதாரணமாக, ஒரு கணக்கு ஹேக் செய்யப்பட்டிருக்கும்போது இது பயனுள்ளதாக இருக்கும்.
2. சொத்துக்களைச் சுத்தப்படுத்துதல்.

   சில நேரங்களில் மோசடியாளர்கள் சட்டப்பூர்வத்தன்மையைப் பெறுவதற்காக உண்மையான டோக்கனின் ஒப்பந்தத்திற்கு மோசடியான டோக்கன்களை அனுப்புகிறார்கள். உதாரணமாக, [இங்கே பார்க்கவும்](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe?tab=holders). சட்டப்பூர்வமான ERC-20 ஒப்பந்தம் [0x4200....0042](https://optimism.blockscout.com/token/0x4200000000000000000000000000000000000042) ஆகும். அதுபோல பாசாங்கு செய்யும் மோசடி [0x234....bbe](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe) ஆகும்.

   மக்கள் தவறுதலாக நமது ஒப்பந்தத்திற்கு முறையான ERC-20 டோக்கன்களை அனுப்பவும் வாய்ப்புள்ளது, இது அவற்றை வெளியேற்றுவதற்கான ஒரு வழியைக் கொண்டிருப்பதற்கு மற்றொரு காரணமாகும்.

நிர்வாக அணுகலை இயக்க OpenZeppelin இரண்டு வழிமுறைகளை வழங்குகிறது:

- [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/access-control#ownership-and-ownable) ஒப்பந்தங்கள் ஒரேயொரு உரிமையாளரைக் கொண்டுள்ளன. `onlyOwner` [மாற்றியைக்](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm) கொண்ட செயல்பாடுகளை அந்த உரிமையாளர் மட்டுமே அழைக்க முடியும். உரிமையாளர்கள் உரிமையை வேறொருவருக்கு மாற்றலாம் அல்லது அதை முழுமையாகத் துறக்கலாம். மற்ற அனைத்துக் கணக்குகளின் உரிமைகளும் பொதுவாக ஒரே மாதிரியானவை.
- [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/access-control#role-based-access-control) ஒப்பந்தங்கள் [பங்கு அடிப்படையிலான அணுகல் கட்டுப்பாட்டைக் (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control) கொண்டுள்ளன.

எளிமைக்காக, இந்தக் கட்டுரையில் நாம் `Ownable`-ஐப் பயன்படுத்துகிறோம்.

### ஒப்பந்தங்களை முடக்குதல் மற்றும் விடுவித்தல் {#freezing-and-thawing-contracts}

ஒப்பந்தங்களை முடக்குவதற்கும் விடுவிப்பதற்கும் பல மாற்றங்கள் தேவை:

- எந்த முகவரிகள் முடக்கப்பட்டுள்ளன என்பதைக் கண்காணிக்க முகவரிகளிலிருந்து [பூலியன்களுக்கு](https://en.wikipedia.org/wiki/Boolean_data_type) ஒரு [மேப்பிங்](https://www.tutorialspoint.com/solidity/solidity_mappings.htm). அனைத்து மதிப்புகளும் ஆரம்பத்தில் பூஜ்ஜியமாக இருக்கும், இது பூலியன் மதிப்புகளுக்கு தவறு எனப் பொருள்படும். இதுதான் நாம் விரும்புவது, ஏனெனில் இயல்பாக கணக்குகள் முடக்கப்படுவதில்லை.

  ```solidity
      mapping(address => bool) public frozenAccounts;
  ```

- ஒரு கணக்கு முடக்கப்படும்போதோ அல்லது விடுவிக்கப்படும்போதோ ஆர்வமுள்ள எவருக்கும் தெரிவிக்க உதவும் [நிகழ்வுகள்](https://www.tutorialspoint.com/solidity/solidity_events.htm). தொழில்நுட்ப ரீதியாக, இந்தச் செயல்களுக்கு நிகழ்வுகள் தேவையில்லை, ஆனால் ஆஃப்செயின் குறியீடு இந்த நிகழ்வுகளைக் கேட்டு என்ன நடக்கிறது என்பதை அறிய இது உதவுகிறது. வேறு ஒருவருக்குத் தொடர்புடைய ஏதாவது நிகழும்போது ஒரு திறன்மிகு ஒப்பந்தம் அவற்றை வெளியிடுவது நல்ல பழக்கமாகக் கருதப்படுகிறது.

  நிகழ்வுகள் அட்டவணைப்படுத்தப்பட்டுள்ளதால், ஒரு கணக்கு முடக்கப்பட்ட அல்லது விடுவிக்கப்பட்ட எல்லா நேரங்களையும் தேட முடியும்.

  ```solidity
    // கணக்குகள் முடக்கப்படும்போது அல்லது விடுவிக்கப்படும்போது
    event AccountFrozen(address indexed _addr);
    event AccountThawed(address indexed _addr);
  ```

- கணக்குகளை முடக்குவதற்கும் விடுவிப்பதற்குமான செயல்பாடுகள். இந்த இரண்டு செயல்பாடுகளும் கிட்டத்தட்ட ஒரே மாதிரியானவை, எனவே நாம் முடக்கும் செயல்பாட்டை மட்டும் பார்ப்போம்.

  ```solidity
      function freezeAccount(address addr)
        public
        onlyOwner
  ```

  [`public`](https://www.tutorialspoint.com/solidity/solidity_contracts.htm) எனக் குறிக்கப்பட்ட செயல்பாடுகளை மற்ற திறன்மிகு ஒப்பந்தங்களிலிருந்து அல்லது நேரடியாக ஒரு பரிவர்த்தனை மூலம் அழைக்கலாம்.

  ```solidity
    {
        require(!frozenAccounts[addr], "கணக்கு ஏற்கனவே முடக்கப்பட்டுள்ளது");
        frozenAccounts[addr] = true;
        emit AccountFrozen(addr);
    }  // freezeAccount
  ```

  கணக்கு ஏற்கனவே முடக்கப்பட்டிருந்தால், செயல்தவிர்க்கவும். இல்லையெனில், அதை முடக்கி ஒரு நிகழ்வை `emit` செய்யவும்.

- முடக்கப்பட்ட கணக்கிலிருந்து பணம் மாற்றப்படுவதைத் தடுக்க `_beforeTokenTransfer`-ஐ மாற்றவும். முடக்கப்பட்ட கணக்கிற்குள் பணம் இன்னும் மாற்றப்படலாம் என்பதைக் கவனத்தில் கொள்ளவும்.

  ```solidity
       require(!frozenAccounts[from], "கணக்கு முடக்கப்பட்டுள்ளது");
  ```

### சொத்துக்களைச் சுத்தப்படுத்துதல் {#asset-cleanup}

இந்த ஒப்பந்தத்தால் வைக்கப்பட்டிருக்கும் ERC-20 டோக்கன்களை விடுவிக்க, அவை சொந்தமான டோக்கன் ஒப்பந்தத்தில் உள்ள [`transfer`](https://eips.ethereum.org/EIPS/eip-20#transfer) அல்லது [`approve`](https://eips.ethereum.org/EIPS/eip-20#approve) செயல்பாட்டை நாம் அழைக்க வேண்டும். இந்த நேர்வில் அனுமதிகளுக்காக எரிவாயுவை வீணடிப்பதில் அர்த்தமில்லை, நாம் நேரடியாகவே மாற்றலாம்.

```solidity
    function cleanupERC20(
        address erc20,
        address dest
    )
        public
        onlyOwner
    {
        IERC20 token = IERC20(erc20);
```

நாம் முகவரியைப் பெறும்போது ஒரு ஒப்பந்தத்திற்கான பொருளை உருவாக்குவதற்கான தொடரியல் இது. மூலக் குறியீட்டின் ஒரு பகுதியாக (வரி 4-ஐப் பார்க்கவும்) ERC20 டோக்கன்களுக்கான வரையறை நம்மிடம் இருப்பதால் இதை நம்மால் செய்ய முடியும், மேலும் அந்தக் கோப்பில் ஒரு OpenZeppelin ERC-20 ஒப்பந்தத்திற்கான இடைமுகமான [IERC20-க்கான வரையறை](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) உள்ளது.

```solidity
        uint balance = token.balanceOf(address(this));
        token.transfer(dest, balance);
    }
```

இது ஒரு சுத்தப்படுத்தும் செயல்பாடு, எனவே நாம் எந்த டோக்கன்களையும் விட்டுச் செல்ல விரும்பவில்லை என்று கருதலாம். பயனரிடமிருந்து இருப்பை கைமுறையாகப் பெறுவதற்குப் பதிலாக, நாம் இந்த செயல்முறையைத் தானியக்கமாக்கலாம்.

## முடிவுரை {#conclusion}

இது ஒரு சரியான தீர்வு அல்ல - "பயனர் தவறு செய்துவிட்டார்" என்ற பிரச்சனைக்கு சரியான தீர்வு என்று எதுவும் இல்லை. இருப்பினும், இந்த வகையான சோதனைகளைப் பயன்படுத்துவது குறைந்தபட்சம் சில தவறுகளைத் தடுக்க முடியும். கணக்குகளை முடக்கும் திறன், ஆபத்தானது என்றாலும், திருடப்பட்ட நிதியை ஹேக்கருக்கு மறுப்பதன் மூலம் சில ஹேக்குகளின் சேதத்தைக் கட்டுப்படுத்தப் பயன்படுத்தப்படலாம்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).
