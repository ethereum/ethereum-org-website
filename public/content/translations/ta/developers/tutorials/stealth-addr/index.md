---
title: "மறை முகவரிகளைப் பயன்படுத்துதல்"
description: "மறை முகவரிகள் பயனர்கள் சொத்துக்களை அநாமதேயமாக மாற்ற அனுமதிக்கின்றன. இந்தக் கட்டுரையைப் படித்த பிறகு, உங்களால் முடியும்: மறை முகவரிகள் என்றால் என்ன, அவை எவ்வாறு செயல்படுகின்றன என்பதை விளக்கவும், அநாமதேயத்தைப் பாதுகாக்கும் வகையில் மறை முகவரிகளை எவ்வாறு பயன்படுத்துவது என்பதைப் புரிந்துகொள்ளவும், மற்றும் மறை முகவரிகளைப் பயன்படுத்தும் வலை அடிப்படையிலான பயன்பாட்டை எழுதவும்."
author: Ori Pomerantz
tags:
  [
    "மறை முகவரி",
    "தனியுரிமை",
    "குறியாக்கவியல்",
    "rust",
    "wasm"
  ]
skill: intermediate
published: 2025-11-30
lang: ta
sidebarDepth: 3
---

நீங்கள் பில். நாம் ஆராயாத காரணங்களுக்காக, நீங்கள் "உலக ராணியாக ஆலிஸ்" பிரச்சாரத்திற்கு நன்கொடை அளிக்க விரும்புகிறீர்கள், மேலும் நீங்கள் நன்கொடை அளித்ததை ஆலிஸ் அறிந்து கொள்ள வேண்டும், அதனால் அவள் வென்றால் உங்களுக்கு வெகுமதி அளிப்பாள். துரதிர்ஷ்டவசமாக, அவளது வெற்றிக்கு உத்தரவாதம் இல்லை. போட்டியிடும் ஒரு பிரச்சாரம் உள்ளது, "சூரிய மண்டலத்தின் பேரரசியாக கரோல்". கரோல் வென்றால், நீங்கள் ஆலிஸுக்கு நன்கொடை அளித்ததை அவள் கண்டுபிடித்தால், உங்களுக்கு சிக்கல் ஏற்படும். எனவே உங்கள் கணக்கிலிருந்து ஆலிஸின் கணக்கிற்கு 200 ETHஐ மாற்ற முடியாது.

[ERC-5564](https://eips.ethereum.org/EIPS/eip-5564) தீர்வைக் கொண்டுள்ளது. இந்த ERC, அநாமதேய பரிமாற்றத்திற்காக [மறை முகவரிகளை](https://nerolation.github.io/stealth-utils) எவ்வாறு பயன்படுத்துவது என்பதை விளக்குகிறது.

**எச்சரிக்கை**: மறை முகவரிகளுக்குப் பின்னால் உள்ள குறியாக்கவியல், எங்களுக்குத் தெரிந்தவரை, உறுதியானது. இருப்பினும், சாத்தியமான பக்க-சேனல் தாக்குதல்கள் உள்ளன. [கீழே](#go-wrong), இந்த ஆபத்தைக் குறைக்க நீங்கள் என்ன செய்ய முடியும் என்பதைப் பார்ப்பீர்கள்.

## மறை முகவரிகள் எவ்வாறு செயல்படுகின்றன {#how}

இந்தக் கட்டுரை மறை முகவரிகளை இரண்டு வழிகளில் விளக்க முயற்சிக்கும். முதலாவது [அவற்றை எவ்வாறு பயன்படுத்துவது](#how-use). கட்டுரையின் மீதமுள்ள பகுதியைப் புரிந்துகொள்ள இந்தப் பகுதி போதுமானது. பின்னர், [அதன் பின்னணியில் உள்ள கணிதத்தின் விளக்கம்](#how-math) உள்ளது. நீங்கள் குறியாக்கவியலில் ஆர்வமாக இருந்தால், இந்தப் பகுதியையும் படியுங்கள்.

### எளிய பதிப்பு (மறை முகவரிகளை எவ்வாறு பயன்படுத்துவது) {#how-use}

ஆலிஸ் இரண்டு தனிப்பட்ட திறவுகோல்களை உருவாக்கி, அதனுடன் தொடர்புடைய பொதுத் திறவுகோல்களை வெளியிடுகிறார் (அவற்றை ஒற்றை இரட்டை நீள மெட்டா-முகவரியில் இணைக்கலாம்). பில் ஒரு தனிப்பட்ட திறவுகோலை உருவாக்கி, அதனுடன் தொடர்புடைய பொதுத் திறவுகோலை வெளியிடுகிறார்.

ஒரு தரப்பினரின் பொதுத் திறவுகோல் மற்றும் மற்றவரின் தனிப்பட்ட திறவுகோலைப் பயன்படுத்தி, ஆலிஸ் மற்றும் பில்லுக்கு மட்டுமே தெரிந்த பகிரப்பட்ட ரகசியத்தை நீங்கள் பெறலாம் (அதை பொதுத் திறவுகோல்களிலிருந்து மட்டும் பெற முடியாது). இந்தப் பகிரப்பட்ட ரகசியத்தைப் பயன்படுத்தி, பில் மறை முகவரியைப் பெற்று அதற்குச் சொத்துக்களை அனுப்பலாம்.

ஆலிஸும் பகிரப்பட்ட ரகசியத்திலிருந்து முகவரியைப் பெறுகிறார், ஆனால் அவர் வெளியிட்ட பொதுத் திறவுகோல்களுக்கான தனிப்பட்ட திறவுகோல்களை அவர் அறிந்திருப்பதால், அந்த முகவரியிலிருந்து திரும்பப் பெற அனுமதிக்கும் தனிப்பட்ட திறவுகோலையும் அவரால் பெற முடியும்.

### கணிதம் (ஏன் மறை முகவரிகள் இப்படிச் செயல்படுகின்றன) {#how-math}

நிலையான மறை முகவரிகள் குறைவான திறவுகோல் பிட்களுடன் சிறந்த செயல்திறனைப் பெற [நீள்வட்ட வளைவு குறியாக்கவியலைப் (ECC)](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/#elliptic-curves-building-blocks-of-a-better-trapdoor) பயன்படுத்துகின்றன, அதே நேரத்தில் அதே அளவிலான பாதுகாப்பை வைத்திருக்கின்றன. ஆனால் பெரும்பாலும் நாம் அதை புறக்கணித்துவிட்டு, வழக்கமான எண்கணிதத்தைப் பயன்படுத்துவது போல் பாசாங்கு செய்யலாம்.

எல்லோருக்கும் தெரிந்த ஒரு எண் உள்ளது, _G_. நீங்கள் _G_ ஆல் பெருக்கலாம். ஆனால் ECCயின் தன்மை காரணமாக, _G_ ஆல் வகுப்பது நடைமுறையில் சாத்தியமற்றது. எத்தேரியத்தில் பொதுத் திறவுகோல் குறியாக்கவியல் பொதுவாகச் செயல்படும் விதம் என்னவென்றால், ஒரு தனிப்பட்ட திறவுகோலான _P<sub>priv</sub>_ ஐப் பயன்படுத்தி பரிவர்த்தனைகளில் கையொப்பமிடலாம், அவை பின்னர் ஒரு பொதுத் திறவுகோலான _P<sub>pub</sub> = GP<sub>priv</sub>_ மூலம் சரிபார்க்கப்படுகின்றன.

ஆலிஸ் இரண்டு தனிப்பட்ட திறவுகோல்களை உருவாக்குகிறார், _K<sub>priv</sub>_ மற்றும் _V<sub>priv</sub>_. _K<sub>priv</sub>_ மறை முகவரியிலிருந்து பணத்தைச் செலவழிக்கப் பயன்படுத்தப்படும், மற்றும் _V<sub>priv</sub>_ ஆலிஸுக்குச் சொந்தமான முகவரிகளைக் காணப் பயன்படுத்தப்படும். பின்னர் ஆலிஸ் பொதுத் திறவுகோல்களை வெளியிடுகிறார்: _K<sub>pub</sub> = GK<sub>priv</sub>_ மற்றும் _V<sub>pub</sub> = GV<sub>priv</sub>_

பில் மூன்றாவது தனிப்பட்ட திறவுகோலான _R<sub>priv</sub>_ ஐ உருவாக்கி, _R<sub>pub</sub> = GR<sub>priv</sub>_ ஐ ஒரு மையப் பதிவேட்டில் வெளியிடுகிறார் (பில் அதை ஆலிஸுக்கும் அனுப்பியிருக்கலாம், ஆனால் கரோல் கேட்டுக்கொண்டிருக்கிறார் என்று நாம் கருதுகிறோம்).

பில் _R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ ஐக் கணக்கிடுகிறார், இது ஆலிஸுக்கும் தெரியும் என்று அவர் எதிர்பார்க்கிறார் (கீழே விளக்கப்பட்டுள்ளது). இந்த மதிப்பு _S_ என்று அழைக்கப்படுகிறது, இதுவே பகிரப்பட்ட ரகசியம். இது பில்லுக்கு ஒரு பொதுத் திறவுகோலை அளிக்கிறது, _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_. இந்த பொதுத் திறவுகோலிலிருந்து, அவர் ஒரு முகவரியைக் கணக்கிட்டு, அவர் விரும்பும் எந்த வளங்களையும் அதற்கு அனுப்பலாம். எதிர்காலத்தில், ஆலிஸ் வென்றால், வளங்கள் அவரிடமிருந்து வந்தவை என்பதை நிரூபிக்க பில் அவளிடம் _R<sub>priv</sub>_ ஐச் சொல்லலாம்.

ஆலிஸ் _R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ ஐக் கணக்கிடுகிறார். இது அவளுக்கு அதே பகிரப்பட்ட ரகசியமான _S_ ஐ அளிக்கிறது. அவளுக்குத் தனிப்பட்ட திறவுகோலான _K<sub>priv</sub>_ தெரியும் என்பதால், அவளால் _P<sub>priv</sub> = K<sub>priv</sub>+hash(S)_ ஐக் கணக்கிட முடியும். இந்தத் திறவுகோல் _P<sub>pub</sub> = GP<sub>priv</sub> = GK<sub>priv</sub>+G\*hash(S) = K<sub>pub</sub>+G\*hash(S)_ இலிருந்து விளையும் முகவரியில் உள்ள சொத்துக்களை அணுக அவளுக்கு உதவுகிறது.

டேவின் உலக ஆதிக்கப் பிரச்சாரச் சேவைகளுக்கு ஆலிஸ் துணை ஒப்பந்தம் செய்ய அனுமதிக்க எங்களிடம் ஒரு தனிப்பட்ட பார்வைத் திறவுகோல் உள்ளது. பொது முகவரிகளை டேவ்வுக்குத் தெரியப்படுத்தவும், மேலும் பணம் கிடைக்கும்போது தனக்குத் தெரிவிக்கவும் ஆலிஸ் தயாராக இருக்கிறார், ஆனால் அவர் தனது பிரச்சாரப் பணத்தைச் செலவிடுவதை அவர் விரும்பவில்லை.

பார்ப்பதற்கும் செலவழிப்பதற்கும் தனித்தனி திறவுகோல்கள் பயன்படுத்தப்படுவதால், ஆலிஸ் டேவுக்கு _V<sub>priv</sub>_ ஐக் கொடுக்கலாம். பின்னர் டேவ் _S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ ஐக் கணக்கிட்டு, அந்த வழியில் பொதுத் திறவுகோல்களைப் பெறலாம் (_P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_). ஆனால் _K<sub>priv</sub>_ இல்லாமல் டேவால் தனிப்பட்ட திறவுகோலைப் பெற முடியாது.

சுருக்கமாக, இவை வெவ்வேறு பங்கேற்பாளர்களால் அறியப்பட்ட மதிப்புகள்.

| ஆலிஸ்                                                                     | வெளியிடப்பட்டது   | பில்                                                                      | டேவ்                                                                        |                                                |
| ------------------------------------------------------------------------- | ----------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------- |
| G                                                                         | G                 | G                                                                         | G                                                                           |                                                |
| _K<sub>priv</sub>_                                                        | \ -               | \ -                                                                       | \ -                                                                         |                                                |
| _V<sub>priv</sub>_                                                        | \ -               | \ -                                                                       | _V<sub>priv</sub>_                                                          |                                                |
| _K<sub>pub</sub> = GK<sub>priv</sub>_                                     | _K<sub>pub</sub>_ | _K<sub>pub</sub>_                                                         | _K<sub>pub</sub>_                                                           |                                                |
| _V<sub>pub</sub> = GV<sub>priv</sub>_                                     | _V<sub>pub</sub>_ | _V<sub>pub</sub>_                                                         | _V<sub>pub</sub>_                                                           |                                                |
| \ -                                                                       | \ -               | _R<sub>priv</sub>_                                                        | \ -                                                                         |                                                |
| _R<sub>pub</sub>_                                                         | _R<sub>pub</sub>_ | _R<sub>pub</sub> = GR<sub>priv</sub>_                                     | _R<sub>pub</sub>_                                                           |                                                |
| _S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | \ -               | _S = R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | _S = _R<sub>pub</sub>V<sub>priv</sub>_ = GR<sub>priv</sub>V<sub>priv</sub>_ |                                                |
| _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | \ -               | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_           |                                                |
| _முகவரி=f(P<sub>pub</sub>)_                            | \ -               | _முகவரி=f(P<sub>pub</sub>)_                            | _முகவரி=f(P<sub>pub</sub>)_                              | _முகவரி=f(P<sub>pub</sub>)_ |
| _P<sub>priv</sub> = K<sub>priv</sub>+hash(S)_          | \ -               | \ -                                                                       | \ -                                                                         |                                                |

## மறை முகவரிகள் தவறாகப் போகும்போது {#go-wrong}

_பிளாக்செயினில் ரகசியங்கள் இல்லை_. மறை முகவரிகள் உங்களுக்கு தனியுரிமையை வழங்க முடியும் என்றாலும், அந்தத் தனியுரிமை போக்குவரத்துப் பகுப்பாய்வுக்கு ஆளாக நேரிடும். ஒரு சிறிய உதாரணத்திற்கு, பில் ஒரு முகவரிக்கு நிதியளித்து, உடனடியாக ஒரு _R<sub>pub</sub>_ மதிப்பை வெளியிட ஒரு பரிவர்த்தனையை அனுப்புகிறார் என்று கற்பனை செய்து கொள்ளுங்கள். ஆலிஸின் _V<sub>priv</sub>_ இல்லாமல், இது ஒரு மறை முகவரி என்று நம்மால் உறுதியாகக் கூற முடியாது, ஆனால் அதுதான் பந்தயம் கட்டுவதற்கான வழி. பின்னர், அந்த முகவரியிலிருந்து அனைத்து ETH ஐயும் ஆலிஸின் பிரச்சார நிதி முகவரிக்கு மாற்றும் மற்றொரு பரிவர்த்தனையைப் பார்க்கிறோம். நம்மால் அதை நிரூபிக்க முடியாமல் இருக்கலாம், ஆனால் பில் ஆலிஸின் பிரச்சாரத்திற்கு நன்கொடை அளித்திருக்கலாம். கரோல் நிச்சயமாக அப்படித்தான் நினைப்பார்.

_R<sub>pub</sub>_ வெளியீட்டை மறை முகவரியின் நிதியளிப்பிலிருந்து பில் பிரிப்பது எளிது (அவற்றை வெவ்வேறு நேரங்களில், வெவ்வேறு முகவரிகளிலிருந்து செய்யுங்கள்). இருப்பினும், அது போதுமானதாக இல்லை. கரோல் தேடும் முறை என்னவென்றால், பில் ஒரு முகவரிக்கு நிதியளிக்கிறார், பின்னர் ஆலிஸின் பிரச்சார நிதி அதிலிருந்து திரும்பப் பெறுகிறது.

ஒரு தீர்வு, ஆலிஸின் பிரச்சாரம் பணத்தை நேரடியாகத் திரும்பப் பெறாமல், மூன்றாம் தரப்பினருக்குச் செலுத்த அதைப் பயன்படுத்துவதாகும். ஆலிஸின் பிரச்சாரம் டேவின் உலக ஆதிக்கப் பிரச்சார சேவைகளுக்கு 10 ETH அனுப்பினால், டேவின் வாடிக்கையாளர்களில் ஒருவருக்கு பில் நன்கொடை அளித்துள்ளார் என்பது மட்டுமே கரோலுக்குத் தெரியும். டேவுக்குப் போதுமான வாடிக்கையாளர்கள் இருந்தால், பில் தன்னுடன் போட்டியிடும் ஆலிஸுக்கு நன்கொடை அளித்தாரா, அல்லது கரோல் கவலைப்படாத ஆடம், ஆல்பர்ட் அல்லது அபிகாயிலுக்கு நன்கொடை அளித்தாரா என்பதை கரோலால் அறிய முடியாது. ஆலிஸ் பணம் செலுத்துதலுடன் ஒரு துண்டிக்கப்பட்ட மதிப்பைச் சேர்க்கலாம், பின்னர் அது தனது நன்கொடை என்பதை நிரூபிக்க, டேவுக்கு முன் பிம்பத்தை வழங்கலாம். மாற்றாக, மேலே குறிப்பிட்டுள்ளபடி, ஆலிஸ் டேவுக்கு தனது _V<sub>priv</sub>_ ஐக் கொடுத்தால், பணம் செலுத்துதல் யாரிடமிருந்து வந்தது என்பது அவருக்கு ஏற்கனவே தெரியும்.

இந்தத் தீர்வில் உள்ள முக்கியப் பிரச்சினை என்னவென்றால், அந்த ரகசியம் பில்லுக்குப் பயனளிக்கும் போது ஆலிஸ் ரகசியத்தைப் பற்றிக் கவலைப்பட வேண்டும். பில்லின் நண்பர் பாப் அவளுக்கு நன்கொடை அளிப்பதற்காக ஆலிஸ் தனது நற்பெயரைப் பராமரிக்க விரும்பலாம். ஆனால் பில்லை அம்பலப்படுத்துவதைப் பற்றி அவள் கவலைப்படாமல் இருக்கவும் வாய்ப்புள்ளது, ஏனென்றால் கரோல் வென்றால் என்ன நடக்கும் என்று அவர் பயப்படுவார். பில் இறுதியில் ஆலிஸுக்கு இன்னும் அதிக ஆதரவை வழங்கக்கூடும்.

### பல மறை அடுக்குகளைப் பயன்படுத்துதல் {#multi-layer}

பில்லின் தனியுரிமையைப் பாதுகாக்க ஆலிஸை நம்புவதற்குப் பதிலாக, பில் அதைத் தானாகவே செய்ய முடியும். அவர் கற்பனையான நபர்களான பாப் மற்றும் பெல்லாவிற்கு பல மெட்டா-முகவரிகளை உருவாக்க முடியும். பின்னர் பில் பாபுக்கு ETH ஐ அனுப்புகிறார், மேலும் "பாப்" (உண்மையில் பில்) அதை பெல்லாவுக்கு அனுப்புகிறார். "பெல்லா" (பில்லும் கூட) அதை ஆலிஸுக்கு அனுப்புகிறார்.

கரோல் இன்னும் போக்குவரத்து பகுப்பாய்வு செய்து பில்-டு-பாப்-டு-பெல்லா-டு-ஆலிஸ் பைப்லைனைப் பார்க்க முடியும். இருப்பினும், "பாப்" மற்றும் "பெல்லா" மற்ற நோக்கங்களுக்காகவும் ETH ஐப் பயன்படுத்தினால், ஆலிஸ் உடனடியாக மறை முகவரியிலிருந்து தனது அறியப்பட்ட பிரச்சார முகவரிக்குத் திரும்பப் பெற்றாலும், பில் ஆலிஸுக்கு எதையும் மாற்றியதாகத் தெரியவில்லை.

## ஒரு மறை-முகவரி பயன்பாட்டை எழுதுதல் {#write-app}

இந்தக் கட்டுரை [GitHub இல் கிடைக்கும்](https://github.com/qbzzt/251022-stealth-addresses.git) ஒரு மறை-முகவரி பயன்பாட்டை விளக்குகிறது.

### கருவிகள் {#tools}

நாம் பயன்படுத்தக்கூடிய [ஒரு typescript மறை முகவரி நூலகம்](https://github.com/ScopeLift/stealth-address-sdk) உள்ளது. இருப்பினும், குறியாக்கவியல் செயல்பாடுகள் CPU-தீவிரமானவையாக இருக்கலாம். [Rust](https://rust-lang.org/) போன்ற ஒரு தொகுக்கப்பட்ட மொழியில் அவற்றைச் செயல்படுத்த நான் விரும்புகிறேன், மேலும் உலாவியில் குறியீட்டை இயக்க [WASM](https://webassembly.org/) ஐப் பயன்படுத்துகிறேன்.

நாம் [Vite](https://vite.dev/) மற்றும் [React](https://react.dev/) ஐப் பயன்படுத்தப் போகிறோம். இவை தொழில்-தரமான கருவிகள்; உங்களுக்கு அவை பரிச்சயமில்லை என்றால், நீங்கள் [இந்த வழிகாட்டியைப்](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/) பயன்படுத்தலாம். Vite ஐப் பயன்படுத்த, நமக்கு Node தேவை.

### செயல்பாட்டில் உள்ள மறை முகவரிகளைப் பார்க்கவும் {#in-action}

1. தேவையான கருவிகளை நிறுவவும்: [Rust](https://rust-lang.org/tools/install/) மற்றும் [Node](https://nodejs.org/en/download).

2. GitHub களஞ்சியத்தை நகலெடுக்கவும்.

   ```sh
   git clone https://github.com/qbzzt/251022-stealth-addresses.git
   cd 251022-stealth-addresses
   ```

3. முன்நிபந்தனைகளை நிறுவி Rust குறியீட்டைத் தொகுக்கவும்.

   ```sh
   cd src/rust-wasm
   rustup target add wasm32-unknown-unknown   
   cargo install wasm-pack   
   wasm-pack build --target web
   ```

4. வலை சேவையகத்தைத் தொடங்கவும்.

   ```sh
   cd ../..
   npm install
   npm run dev
   ```

5. [பயன்பாட்டிற்குச்](http://localhost:5173/) செல்லவும். இந்த பயன்பாட்டுப் பக்கத்தில் இரண்டு பிரேம்கள் உள்ளன: ஒன்று ஆலிஸின் பயனர் இடைமுகத்திற்காகவும் மற்றொன்று பில்லின் இடைமுகத்திற்காகவும். இரண்டு பிரேம்களும் தொடர்பு கொள்ளாது; அவை வசதிக்காக மட்டுமே ஒரே பக்கத்தில் உள்ளன.

6. ஆலிஸாக, **ஒரு மறை மெட்டா-முகவரியை உருவாக்கு** என்பதைக் கிளிக் செய்யவும். இது புதிய மறை முகவரியையும் அதனுடன் தொடர்புடைய தனிப்பட்ட திறவுகோல்களையும் காண்பிக்கும். மறை மெட்டா-முகவரியை கிளிப்போர்டுக்கு நகலெடுக்கவும்.

7. பில்லாக, புதிய மறை மெட்டா-முகவரியை ஒட்டி, **ஒரு முகவரியை உருவாக்கு** என்பதைக் கிளிக் செய்யவும். இது ஆலிஸுக்காக நிதியளிக்க வேண்டிய முகவரியை உங்களுக்கு வழங்குகிறது.

8. முகவரியையும் பில்லின் பொதுத் திறவுகோலையும் நகலெடுத்து, ஆலிஸின் பயனர் இடைமுகத்தில் உள்ள "பில்லால் உருவாக்கப்பட்ட முகவரிக்கான தனிப்பட்ட திறவுகோல்" பகுதியில் ஒட்டவும். அந்தப் புலங்கள் நிரப்பப்பட்டவுடன், அந்த முகவரியில் உள்ள சொத்துக்களை அணுகுவதற்கான தனிப்பட்ட திறவுகோலைக் காண்பீர்கள்.

9. தனிப்பட்ட திறவுகோல் முகவரியுடன் பொருந்துகிறதா என்பதை உறுதிப்படுத்த, நீங்கள் [ஒரு ஆன்லைன் கால்குலேட்டரைப்](https://iancoleman.net/ethereum-private-key-to-address/) பயன்படுத்தலாம்.

### நிரல் எவ்வாறு செயல்படுகிறது {#how-the-program-works}

#### WASM கூறு {#wasm}

WASM ஆகத் தொகுக்கும் மூலக் குறியீடு [Rust](https://rust-lang.org/) இல் எழுதப்பட்டுள்ளது. அதை நீங்கள் [`src/rust_wasm/src/lib.rs`](https://github.com/qbzzt/251022-stealth-addresses/blob/main/src/rust-wasm/src/lib.rs) இல் காணலாம். இந்தக் குறியீடு முதன்மையாக JavaScript குறியீட்டிற்கும் [`eth-stealth-addresses` நூலகத்திற்கும்](https://github.com/kassandraoftroy/eth-stealth-addresses) இடையே ஒரு இடைமுகமாகும்.

**`Cargo.toml`**

Rust இல் உள்ள [`Cargo.toml`](https://doc.rust-lang.org/cargo/reference/manifest.html) என்பது JavaScript இல் உள்ள [`package.json`](https://docs.npmjs.com/cli/v9/configuring-npm/package-json) ஐப் போன்றது. இது தொகுப்புத் தகவல், சார்புநிலை அறிவிப்புகள் போன்றவற்றைக் கொண்டுள்ளது.

```toml
[package]
name = "rust-wasm"
version = "0.1.0"
edition = "2024"

[dependencies]
eth-stealth-addresses = "0.1.0"
hex = "0.4.3"
wasm-bindgen = "0.2.104"
getrandom = { version = "0.2", features = ["js"] }
```

[`getrandom`](https://docs.rs/getrandom/latest/getrandom/) தொகுப்பு சீரற்ற மதிப்புகளை உருவாக்க வேண்டும். அதை முற்றிலும் வழிமுறை வழிகளில் செய்ய முடியாது; அதற்கு என்ட்ரோபியின் ஆதாரமாக ஒரு பௌதீக செயல்முறைக்கான அணுகல் தேவை. இந்த வரையறை, நாம் இயங்கும் உலாவியிடம் கேட்பதன் மூலம் அந்த என்ட்ரோபியைப் பெறுவோம் என்று குறிப்பிடுகிறது.

```toml
console_error_panic_hook = "0.1.7"
```

[இந்த நூலகம்](https://docs.rs/console_error_panic_hook/latest/console_error_panic_hook/) WASM குறியீடு செயலிழந்து தொடர முடியாதபோது நமக்கு மேலும் அர்த்தமுள்ள பிழைச் செய்திகளை வழங்குகிறது.

```toml
[lib]
crate-type = ["cdylib", "rlib"]
```

WASM குறியீட்டை உருவாக்கத் தேவையான வெளியீட்டு வகை.

**`lib.rs`**

இது உண்மையான Rust குறியீடு.

```rust
use wasm_bindgen::prelude::*;
```

Rust இலிருந்து ஒரு WASM தொகுப்பை உருவாக்குவதற்கான வரையறைகள். அவை [இங்கே](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/index.html) ஆவணப்படுத்தப்பட்டுள்ளன.

```rust
use eth_stealth_addresses::{
    generate_stealth_meta_address,
    generate_stealth_address,
    compute_stealth_key
};
```

[`eth-stealth-addresses` நூலகத்திலிருந்து](https://github.com/kassandraoftroy/eth-stealth-addresses) நமக்குத் தேவையான செயல்பாடுகள்.

```rust
use hex::{decode,encode};
```

Rust பொதுவாக மதிப்புகளுக்கு பைட் [அணிகளை](https://doc.rust-lang.org/std/primitive.array.html) (`[u8; <size>]`) பயன்படுத்துகிறது. ஆனால் JavaScript இல், நாம் பொதுவாக ஹெக்ஸாடெசிமல் சரங்களைப் பயன்படுத்துகிறோம். [`hex` நூலகம்](https://docs.rs/hex/latest/hex/) நமக்காக ஒரு பிரதிநிதித்துவத்திலிருந்து மற்றொன்றிற்கு மொழிபெயர்க்கிறது.

```rust
#[wasm_bindgen]
```

JavaScript இலிருந்து இந்தச் செயல்பாட்டை அழைக்கக்கூடிய வகையில் WASM இணைப்புகளை உருவாக்கவும்.

```rust
pub fn wasm_generate_stealth_meta_address() -> String {
```

பல புலங்களைக் கொண்ட ஒரு பொருளைத் திருப்பித் தருவதற்கான எளிதான வழி, ஒரு JSON சரத்தைத் திருப்பித் தருவதாகும்.

```rust
    let (address, spend_private_key, view_private_key) = 
        generate_stealth_meta_address();
```

[`generate_stealth_meta_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_meta_address.html) மூன்று புலங்களைத் திருப்பித் தருகிறது:

- மெட்டா-முகவரி (_K<sub>pub</sub>_ மற்றும் _V<sub>pub</sub>_)
- பார்வையிடும் தனிப்பட்ட திறவுகோல் (_V<sub>priv</sub>_)
- செலவழிக்கும் தனிப்பட்ட திறவுகோல் (_K<sub>priv</sub>_)

[tuple](https://doc.rust-lang.org/std/primitive.tuple.html) தொடரியல் அந்த மதிப்புகளை மீண்டும் பிரிக்க நம்மை அனுமதிக்கிறது.

```rust
    format!("{{\"address\":\"{}\",\"view_private_key\":\"{}\",\"spend_private_key\":\"{}\"}}",
        encode(address),
        encode(view_private_key),
        encode(spend_private_key)
    )
}
```

JSON-குறியாக்கம் செய்யப்பட்ட சரத்தை உருவாக்க [`format!`](https://doc.rust-lang.org/std/fmt/index.html) மேக்ரோவைப் பயன்படுத்தவும். அணிகளை ஹெக்ஸ் சரங்களாக மாற்ற [`hex::encode`](https://docs.rs/hex/latest/hex/fn.encode.html) ஐப் பயன்படுத்தவும்.

```rust
fn str_to_array<const N: usize>(s: &str) -> Option<[u8; N]> {
```

இந்தச் செயல்பாடு ஒரு ஹெக்ஸ் சரத்தை (JavaScript வழங்கியது) ஒரு பைட் அணியாக மாற்றுகிறது. JavaScript குறியீட்டால் வழங்கப்பட்ட மதிப்புகளை அலச இதைப் பயன்படுத்துகிறோம். Rust அணிகளையும் திசையன்களையும் கையாளும் விதம் காரணமாக இந்தச் செயல்பாடு சிக்கலானது.

`<const N: usize>` கோவை ஒரு [பொதுவானது](https://doc.rust-lang.org/book/ch10-01-syntax.html) என்று அழைக்கப்படுகிறது. `N` என்பது திருப்பியனுப்பப்படும் அணியின் நீளத்தைக் கட்டுப்படுத்தும் ஒரு அளவுருவாகும். இந்தச் செயல்பாடு உண்மையில் `str_to_array::<n>` என்று அழைக்கப்படுகிறது, இங்கு `n` என்பது அணியின் நீளமாகும்.

திரும்பப் பெறப்படும் மதிப்பு `Option<[u8; N]>` ஆகும், அதாவது திரும்பப் பெறப்படும் அணி [விருப்பத்திற்குரியது](https://doc.rust-lang.org/std/option/). இது Rust இல் தோல்வியடையக்கூடிய செயல்பாடுகளுக்கான ஒரு பொதுவான வடிவமாகும்.

உதாரணமாக, நாம் `str_to_array::10("bad060a7")` ஐ அழைத்தால், செயல்பாடு பத்து-மதிப்பு அணியைத் திருப்பித் தர வேண்டும், ஆனால் உள்ளீடு நான்கு பைட்டுகள் மட்டுமே. செயல்பாடு தோல்வியடைய வேண்டும், அது `None` ஐத் திருப்பித் தருவதன் மூலம் அதைச் செய்கிறது. `str_to_array::4("bad060a7")` க்கான திரும்பும் மதிப்பு `Some<[0xba, 0xd0, 0x60, 0xa7]>` ஆக இருக்கும்.

```rust
    // decode returns Result<Vec<u8>, _>
    let vec = decode(s).ok()?;
```

[`hex::decode`](https://docs.rs/hex/latest/hex/fn.decode.html) செயல்பாடு ஒரு `Result<Vec<u8>, FromHexError>` ஐத் திருப்பித் தருகிறது. [`Result`](https://doc.rust-lang.org/std/result/) வகை ஒரு வெற்றிகரமான முடிவையோ (`Ok(value)`) அல்லது ஒரு பிழையையோ (`Err(error)`) கொண்டிருக்கலாம்.

`.ok()` முறை `Result` ஐ ஒரு `Option` ஆக மாற்றுகிறது, அதன் மதிப்பு வெற்றிகரமாக இருந்தால் `Ok()` மதிப்பாகவோ அல்லது இல்லையெனில் `None` ஆகவோ இருக்கும். இறுதியாக, [கேள்விக்குறி செயலி](https://doc.rust-lang.org/std/option/#the-question-mark-operator-) தற்போதைய செயல்பாடுகளை நிறுத்தி, `Option` காலியாக இருந்தால் `None` ஐத் திருப்பித் தருகிறது. இல்லையெனில், அது மதிப்பை அவிழ்த்து அதைத் திருப்பித் தருகிறது (இந்த வழக்கில், `vec` க்கு ஒரு மதிப்பை ஒதுக்க).

இது பிழைகளைக் கையாள ஒரு விசித்திரமான சிக்கலான முறையாகத் தெரிகிறது, ஆனால் `Result` மற்றும் `Option` அனைத்துப் பிழைகளும் ஒரு வழியில் அல்லது இன்னொரு வழியில் கையாளப்படுவதை உறுதி செய்கின்றன.

```rust
    if vec.len() != N { return None; }
```

பைட்டுகளின் எண்ணிக்கை தவறாக இருந்தால், அது ஒரு தோல்வி, மேலும் நாம் `None` ஐத் திருப்பித் தருகிறோம்.

```rust
    // try_into consumes vec and attempts to make [u8; N]
    let array: [u8; N] = vec.try_into().ok()?;
```

Rust இரண்டு அணி வகைகளைக் கொண்டுள்ளது. [அணிகள்](https://doc.rust-lang.org/std/primitive.array.html) ஒரு நிலையான அளவைக் கொண்டுள்ளன. [திசையன்கள்](https://doc.rust-lang.org/std/vec/index.html) வளரவும் சுருங்கவும் முடியும். `hex::decode` ஒரு திசையனைத் திருப்பித் தருகிறது, ஆனால் `eth_stealth_addresses` நூலகம் அணிகளைப் பெற விரும்புகிறது. [`.try_into()`](https://doc.rust-lang.org/std/convert/trait.TryInto.html#required-methods) ஒரு மதிப்பை மற்றொரு வகையாக மாற்றுகிறது, எடுத்துக்காட்டாக, ஒரு திசையனை ஒரு அணியாக.

```rust
    Some(array)
}
```

Rust ஒரு செயல்பாட்டின் முடிவில் ஒரு மதிப்பைத் திருப்பும்போது [`return`](https://doc.rust-lang.org/std/keyword.return.html) முக்கிய சொல்லைப் பயன்படுத்தத் தேவையில்லை.

```rust
#[wasm_bindgen]
pub fn wasm_generate_stealth_address(stealth_address: &str) -> Option<String> {
```

இந்தச் செயல்பாடு பொது மெட்டா-முகவரியை பெறுகிறது, இதில் _V<sub>pub</sub>_ மற்றும் _K<sub>pub</sub>_ ஆகிய இரண்டும் அடங்கும். இது மறை முகவரியை, வெளியிடப்பட வேண்டிய பொதுத் திறவுகோலை (_R<sub>pub</sub>_), மற்றும் எந்த வெளியிடப்பட்ட முகவரிகள் ஆலிஸுக்குச் சொந்தமானதாக இருக்கலாம் என்பதை அடையாளம் காண உதவும் ஒரு-பைட் ஸ்கேன் மதிப்பையும் திருப்பித் தருகிறது.

ஸ்கேன் மதிப்பு பகிரப்பட்ட இரகசியத்தின் ஒரு பகுதியாகும் (_S = GR<sub>priv</sub>V<sub>priv</sub>_). இந்த மதிப்பு ஆலிஸுக்குக் கிடைக்கிறது, மேலும் _f(K<sub>pub</sub>+G\*hash(S))_ வெளியிடப்பட்ட முகவரிக்குச் சமமா என்று சரிபார்ப்பதை விட, அதைச் சரிபார்ப்பது மிகவும் வேகமானது.

```rust
    let (address, r_pub, scan) = 
        generate_stealth_address(&str_to_array::<66>(stealth_address)?);
```

நாம் நூலகத்தின் [`generate_stealth_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_address.html) ஐப் பயன்படுத்துகிறோம்.

```rust
    format!("{{\"address\":\"{}\",\"rPub\":\"{}\",\"scan\":\"{}\"}}",
        encode(address),
        encode(r_pub),
        encode(&[scan])
    ).into()
}
```

JSON-குறியிடப்பட்ட வெளியீட்டுச் சரத்தைத் தயாரிக்கவும்.

```rust
#[wasm_bindgen]
pub fn wasm_compute_stealth_key(
    address: &str, 
    bill_pub_key: &str, 
    view_private_key: &str,
    spend_private_key: &str    
) -> Option<String> {
    .
    .
    .
}
```

இந்தச் செயல்பாடு முகவரியிலிருந்து (_R<sub>priv</sub>_) திரும்பப் பெறுவதற்கான தனிப்பட்ட திறவுகோலைக் கணக்கிட நூலகத்தின் [`compute_stealth_key`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.compute_stealth_key.html) ஐப் பயன்படுத்துகிறது. இந்தக் கணக்கீட்டிற்கு இந்த மதிப்புகள் தேவை:

- முகவரி (_முகவரி=f(P<sub>pub</sub>)_)
- பில்லால் உருவாக்கப்பட்ட பொதுத் திறவுகோல் (_R<sub>pub</sub>_)
- பார்வை தனிப்பட்ட திறவுகோல் (_V<sub>priv</sub>_)
- செலவு தனிப்பட்ட திறவுகோல் (_K<sub>priv</sub>_)

```rust
#[wasm_bindgen(start)]
```

[`#[wasm_bindgen(start)]`](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html) WASM குறியீடு துவக்கப்படும்போது இந்தச் செயல்பாடு செயல்படுத்தப்படும் என்று குறிப்பிடுகிறது.

```rust
pub fn main() {
    console_error_panic_hook::set_once();
}
```

இந்த குறியீடு பீதி வெளியீடு JavaScript கன்சோலுக்கு அனுப்பப்பட வேண்டும் என்று குறிப்பிடுகிறது. அதைச் செயலில் காண, பயன்பாட்டைப் பயன்படுத்தி, பில்லுக்கு தவறான மெட்டா-முகவரியைக் கொடுக்கவும் (ஒரு ஹெக்ஸாடெசிமல் இலக்கத்தை மட்டும் மாற்றவும்). JavaScript கன்சோலில் இந்தப் பிழையைக் காண்பீர்கள்:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs:701:9:
assertion `left == right` failed
  left: 0
 right: 1
```

அதனைத் தொடர்ந்து ஒரு அடுக்குத் தடம். பிறகு பில்லுக்குச் சரியான மெட்டா-முகவரியைக் கொடுத்துவிட்டு, ஆலிஸுக்கு ஒரு தவறான முகவரியையோ அல்லது தவறான பொதுத் திறவுகோலையோ கொடுக்கவும். இந்தப் பிழையைக் காண்பீர்கள்:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/eth-stealth-addresses-0.1.0/src/lib.rs:78:9:
keys do not generate stealth address
```

மீண்டும், அதனைத் தொடர்ந்து ஒரு அடுக்குத் தடம்.

#### பயனர் இடைமுகம் {#ui}

பயனர் இடைமுகம் [React](https://react.dev/) ஐப் பயன்படுத்தி எழுதப்பட்டு [Vite](https://vite.dev/) மூலம் வழங்கப்படுகிறது. அவற்றைப் பற்றி [இந்த வழிகாட்டியைப்](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/) பயன்படுத்தி நீங்கள் அறிந்து கொள்ளலாம். இங்கே [WAGMI](https://wagmi.sh/) தேவையில்லை, ஏனென்றால் நாம் ஒரு பிளாக்செயின் அல்லது ஒரு பணப்பையுடன் நேரடியாகத் தொடர்புகொள்வதில்லை.

பயனர் இடைமுகத்தின் ஒரே வெளிப்படையான பகுதி WASM இணைப்பு ஆகும். இது எவ்வாறு செயல்படுகிறது என்பது இங்கே.

**`vite.config.js`**

இந்தக் கோப்பில் [Vite கட்டமைப்பு](https://vite.dev/config/) உள்ளது.

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import wasm from "vite-plugin-wasm";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), wasm()],
})
```

நமக்கு இரண்டு Vite செருகுநிரல்கள் தேவை: [react](https://www.npmjs.com/package/@vitejs/plugin-react) மற்றும் [wasm](https://github.com/Menci/vite-plugin-wasm#readme).

**`App.jsx`**

இந்தக் கோப்பு பயன்பாட்டின் முக்கியக் கூறு ஆகும். இது இரண்டு கூறுகளைக் கொண்ட ஒரு கொள்கலன்: `Alice` மற்றும் `Bill`, அந்தப் பயனர்களுக்கான பயனர் இடைமுகங்கள். WASM க்கான தொடர்புடைய பகுதி தொடக்கக் குறியீடு ஆகும்.

```jsx
import init from './rust-wasm/pkg/rust_wasm.js'
```

நாம் [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/) ஐப் பயன்படுத்தும்போது, அது நாம் இங்கு பயன்படுத்தும் இரண்டு கோப்புகளை உருவாக்குகிறது: உண்மையான குறியீட்டைக் கொண்ட ஒரு wasm கோப்பு (இங்கே, `src/rust-wasm/pkg/rust_wasm_bg.wasm`) மற்றும் அதைப் பயன்படுத்துவதற்கான வரையறைகளைக் கொண்ட ஒரு JavaScript கோப்பு (இங்கே, `src/rust_wasm/pkg/rust_wasm.js`). அந்த JavaScript கோப்பின் இயல்புநிலை ஏற்றுமதி WASM ஐத் தொடங்குவதற்கு இயக்கப்பட வேண்டிய குறியீடு ஆகும்.

```jsx
function App() {
    .
    .
    .
  useEffect(() => {
    const loadWasm = async () => {
      try {
        await init();
        setWasmReady(true)
      } catch (err) {
        console.error('Error loading wasm:', err)
        alert("Wasm error: " + err)
      }
    }

    loadWasm()
    }, []
  )
```

[`useEffect` ஹூக்](https://react.dev/reference/react/useEffect) நிலை மாறிகள் மாறும்போது செயல்படுத்தப்படும் ஒரு செயல்பாட்டைக் குறிப்பிட உங்களை அனுமதிக்கிறது. இங்கே, நிலை மாறிகளின் பட்டியல் காலியாக உள்ளது (`[]`), எனவே பக்கம் ஏற்றப்படும்போது இந்த செயல்பாடு ஒரு முறை மட்டுமே செயல்படுத்தப்படுகிறது.

விளைவு செயல்பாடு உடனடியாகத் திரும்ப வேண்டும். WASM `init` போன்ற ஒத்திசைவற்ற குறியீட்டைப் பயன்படுத்த (இது `.wasm` கோப்பை ஏற்ற வேண்டும், எனவே நேரம் எடுக்கும்), நாம் ஒரு உள் [`async`](https://en.wikipedia.org/wiki/Async/await) செயல்பாட்டை வரையறுத்து, `await` இல்லாமல் அதை இயக்குகிறோம்.

**`Bill.jsx`**

இது பில்லுக்கான பயனர் இடைமுகம். ஆலிஸால் வழங்கப்பட்ட மறை மெட்டா-முகவரியின் அடிப்படையில் ஒரு முகவரியை உருவாக்குவது மட்டுமே இதன் ஒரே செயல்பாடு.

```jsx
import { wasm_generate_stealth_address } from './rust-wasm/pkg/rust_wasm.js'
```

இயல்புநிலை ஏற்றுமதிக்கு கூடுதலாக, `wasm-pack` ஆல் உருவாக்கப்பட்ட JavaScript குறியீடு WASM குறியீட்டில் உள்ள ஒவ்வொரு செயல்பாட்டிற்கும் ஒரு செயல்பாட்டை ஏற்றுமதி செய்கிறது.

```jsx
            <button onClick={() => {
              setPublicAddress(JSON.parse(wasm_generate_stealth_address(stealthMetaAddress)))
            }}>
```

WASM செயல்பாடுகளை அழைக்க, `wasm-pack` ஆல் உருவாக்கப்பட்ட JavaScript கோப்பால் ஏற்றுமதி செய்யப்பட்ட செயல்பாட்டை நாம் அழைக்கிறோம்.

**`Alice.jsx`**

`Alice.jsx` இல் உள்ள குறியீடு ஒத்ததாகும், ஆனால் ஆலிஸுக்கு இரண்டு செயல்பாடுகள் உள்ளன:

- ஒரு மெட்டா-முகவரியை உருவாக்கவும்
- பில்லால் வெளியிடப்பட்ட ஒரு முகவரிக்கான தனிப்பட்ட திறவுகோலைப் பெறவும்

## முடிவுரை {#conclusion}

மறை முகவரிகள் சர்வ ரோக நிவாரணிகள் அல்ல; அவை [சரியாகப் பயன்படுத்தப்பட வேண்டும்](#go-wrong). ஆனால் சரியாகப் பயன்படுத்தும்போது, அவை ஒரு பொதுப் பிளாக்செயினில் தனியுரிமையைச் செயல்படுத்த முடியும்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).