---
title: "சோதிப்பதற்காக சொலிடிட்டி ஸ்மார்ட் ஒப்பந்தங்களை எப்படி மாக் செய்வது"
description: "சோதிக்கும் போது உங்கள் ஒப்பந்தங்களை ஏன் கேலி செய்ய வேண்டும்"
author: Markus Waas
lang: ta
tags:
  [
    "திட்பம்",
    "ஸ்மார்ட் ஒப்பந்தங்கள்",
    "சோதனை",
    "மாக் செய்தல்"
  ]
skill: intermediate
published: 2020-05-02
source: soliditydeveloper.com
sourceUrl: https://soliditydeveloper.com/mocking-contracts
---

[மாக் பொருள்கள்](https://wikipedia.org/wiki/Mock_object) பொருள் சார்ந்த நிரலாக்கத்தில் ஒரு பொதுவான வடிவமைப்பு முறையாகும். பழைய பிரெஞ்சு வார்த்தையான 'mocquer' என்பதிலிருந்து 'கேலி செய்தல்' என்ற அர்த்தத்தில் வந்து, அது 'உண்மையான ஒன்றைப் பின்பற்றுதல்' என்று உருவானது, இதுதான் உண்மையில் நாம் நிரலாக்கத்தில் செய்கிறோம். நீங்கள் விரும்பினால் மட்டுமே உங்கள் ஸ்மார்ட் ஒப்பந்தங்களைக் கேலி செய்யுங்கள், ஆனால் உங்களால் முடிந்த போதெல்லாம் அவற்றை மாக் செய்யுங்கள். அது உங்கள் வாழ்க்கையை எளிதாக்குகிறது.

## மாக்குகளுடன் ஒப்பந்தங்களை யூனிட்-சோதனை செய்தல் {#unit-testing-contracts-with-mocks}

ஒரு ஒப்பந்தத்தை மாக் செய்வது என்பது அடிப்படையில் அந்த ஒப்பந்தத்தின் இரண்டாவது பதிப்பை உருவாக்குவதாகும், இது அசல் ஒன்றைப் போலவே செயல்படும், ஆனால் டெவலப்பரால் எளிதாகக் கட்டுப்படுத்தக்கூடிய வகையில். நீங்கள் பெரும்பாலும் சிக்கலான ஒப்பந்தங்களில் முடிவடைகிறீர்கள், அங்கு நீங்கள் [ஒப்பந்தத்தின் சிறிய பகுதிகளை யூனிட்-சோதனை செய்ய](/developers/docs/smart-contracts/testing/) மட்டுமே விரும்புவீர்கள். இந்தப் சிறிய பகுதியைச் சோதிப்பதற்கு மிகவும் குறிப்பிட்ட ஒப்பந்த நிலை தேவைப்பட்டால், அதை அடைவது கடினமாக இருந்தால் என்ன செய்வது என்பதுதான் பிரச்சனை.

ஒப்பந்தத்தை தேவையான நிலைக்குக் கொண்டுவரும் சிக்கலான சோதனை அமைப்பு தர்க்கத்தை ஒவ்வொரு முறையும் எழுதலாம் அல்லது நீங்கள் ஒரு மாக்கை எழுதலாம். மரபுரிமையுடன் ஒரு ஒப்பந்தத்தை மாக் செய்வது எளிது. அசல் ஒப்பந்தத்திலிருந்து மரபுரிமையாக வரும் இரண்டாவது மாக் ஒப்பந்தத்தை உருவாக்கவும். இப்போது உங்கள் மாக்கிற்கு செயல்பாடுகளை மேலெழுதலாம். இதை ஒரு எடுத்துக்காட்டுடன் பார்ப்போம்.

## எடுத்துக்காட்டு: தனிப்பட்ட ERC20 {#example-private-erc20}

ஆரம்பத்தில் ஒரு தனிப்பட்ட நேரத்தைக் கொண்ட ஒரு எடுத்துக்காட்டு ERC-20 ஒப்பந்தத்தைப் பயன்படுத்துகிறோம். உரிமையாளர் தனிப்பட்ட பயனர்களை நிர்வகிக்க முடியும், மேலும் ஆரம்பத்தில் அவர்கள் மட்டுமே டோக்கன்களைப் பெற அனுமதிக்கப்படுவார்கள். ஒரு குறிப்பிட்ட நேரம் கடந்தவுடன், அனைவரும் டோக்கன்களைப் பயன்படுத்த அனுமதிக்கப்படுவார்கள். நீங்கள் ஆர்வமாக இருந்தால், புதிய OpenZeppelin ஒப்பந்தங்கள் v3-இலிருந்து [`_beforeTokenTransfer`](https://docs.openzeppelin.com/contracts/5.x/extending-contracts#using-hooks) ஹூக்கைப் பயன்படுத்துகிறோம்.

```solidity
pragma solidity ^0.6.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract PrivateERC20 is ERC20, Ownable {
    mapping (address => bool) public isPrivateUser;
    uint256 private publicAfterTime;

    constructor(uint256 privateERC20timeInSec) ERC20("PrivateERC20", "PRIV") public {
        publicAfterTime = now + privateERC20timeInSec;
    }

    function addUser(address user) external onlyOwner {
        isPrivateUser[user] = true;
    }

    function isPublic() public view returns (bool) {
        return now >= publicAfterTime;
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        require(_validRecipient(to), "PrivateERC20: invalid recipient");
    }

    function _validRecipient(address to) private view returns (bool) {
        if (isPublic()) {
            return true;
        }

        return isPrivateUser[to];
    }
}
```

இப்போது அதை மாக் செய்வோம்.

```solidity
pragma solidity ^0.6.0;
import "../PrivateERC20.sol";

contract PrivateERC20Mock is PrivateERC20 {
    bool isPublicConfig;

    constructor() public PrivateERC20(0) {}

    function setIsPublic(bool isPublic) external {
        isPublicConfig = isPublic;
    }

    function isPublic() public view returns (bool) {
        return isPublicConfig;
    }
}
```

பின்வரும் பிழைச் செய்திகளில் ஒன்றை நீங்கள் பெறுவீர்கள்:

- `PrivateERC20Mock.sol: TypeError: Overriding function is missing "override" specifier.`
- `PrivateERC20.sol: TypeError: Trying to override non-virtual function. Did you forget to add "virtual"?.`

நாம் புதிய 0.6 சொலிடிட்டி பதிப்பைப் பயன்படுத்துவதால், மேலெழுதப்படக்கூடிய செயல்பாடுகளுக்கு `virtual` என்ற முக்கியச்சொல்லையும், மேலெழுதும் செயல்பாட்டிற்கு override என்பதையும் சேர்க்க வேண்டும். எனவே அவற்றை இரண்டு `isPublic` செயல்பாடுகளுக்கும் சேர்ப்போம்.

இப்போது உங்கள் யூனிட் சோதனைகளில், நீங்கள் பதிலாக `PrivateERC20Mock`-ஐப் பயன்படுத்தலாம். தனிப்பட்ட பயன்பாட்டு நேரத்தின் போது நடத்தையை சோதிக்க விரும்பும்போது, `setIsPublic(false)`-ஐப் பயன்படுத்தவும், அதே போல் பொது பயன்பாட்டு நேரத்தைச் சோதிக்க `setIsPublic(true)`-ஐப் பயன்படுத்தவும். நிச்சயமாக நமது எடுத்துக்காட்டில், நேரங்களை அதற்கேற்ப மாற்றுவதற்கும் [நேர உதவியாளர்களை](https://docs.openzeppelin.com/test-helpers/0.5/api#increase) நாம் பயன்படுத்தலாம். ஆனால் மாக் செய்வதற்கான யோசனை இப்போது தெளிவாக இருக்க வேண்டும், மேலும் நேரத்தை முன்னேற்றுவது போல் எளிதாக இல்லாத சூழ்நிலைகளை நீங்கள் கற்பனை செய்யலாம்.

## பல ஒப்பந்தங்களை மாக் செய்தல் {#mocking-many-contracts}

ஒவ்வொரு மாக்கிற்கும் மற்றொரு ஒப்பந்தத்தை உருவாக்க வேண்டியிருந்தால் அது குழப்பமாக மாறக்கூடும். இது உங்களுக்குத் தொந்தரவாக இருந்தால், [MockContract](https://github.com/gnosis/mock-contract) லைப்ரரியைப் பார்க்கலாம். இது ஒப்பந்தங்களின் நடத்தைகளை உடனடியாக மேலெழுதவும் மாற்றவும் உங்களை அனுமதிக்கிறது. இருப்பினும், இது மற்றொரு ஒப்பந்தத்திற்கான அழைப்புகளை மாக் செய்வதற்கு மட்டுமே வேலை செய்யும், எனவே இது நமது எடுத்துக்காட்டிற்கு வேலை செய்யாது.

## மாக் செய்வது இன்னும் சக்திவாய்ந்ததாக இருக்கும் {#mocking-can-be-even-more-powerful}

மாக் செய்வதன் சக்திகள் அத்துடன் முடிவடைவதில்லை.

- செயல்பாடுகளைச் சேர்த்தல்: ஒரு குறிப்பிட்ட செயல்பாட்டை மேலெழுதுவது மட்டுமல்ல, கூடுதல் செயல்பாடுகளைச் சேர்ப்பதும் பயனுள்ளது. டோக்கன்களுக்கு ஒரு நல்ல எடுத்துக்காட்டு, எந்தவொரு பயனரும் இலவசமாக புதிய டோக்கன்களைப் பெற அனுமதிக்கும் கூடுதல் `mint` செயல்பாட்டைக் கொண்டிருப்பதாகும்.
- டெஸ்ட்நெட்களில் பயன்பாடு: உங்கள் dapp உடன் டெஸ்ட்நெட்களில் உங்கள் ஒப்பந்தங்களை வரிசைப்படுத்தி சோதிக்கும்போது, மாக் செய்யப்பட்ட பதிப்பைப் பயன்படுத்துவதைக் கருத்தில் கொள்ளுங்கள். நீங்கள் உண்மையில் செய்ய வேண்டியிருந்தால் தவிர, செயல்பாடுகளை மேலெழுதுவதைத் தவிர்க்கவும். எல்லாவற்றிற்கும் மேலாக நீங்கள் உண்மையான தர்க்கத்தை சோதிக்க விரும்புகிறீர்கள். ஆனால் எடுத்துக்காட்டாக, ஒப்பந்த நிலையை ஆரம்பத்திற்கு மீட்டமைக்கும் ஒரு மீட்டமைப்பு செயல்பாட்டைச் சேர்ப்பது பயனுள்ளதாக இருக்கும், புதிய வரிசைப்படுத்தல் தேவையில்லை. வெளிப்படையாக நீங்கள் அதை ஒரு Mainnet ஒப்பந்தத்தில் வைத்திருக்க விரும்ப மாட்டீர்கள்.
