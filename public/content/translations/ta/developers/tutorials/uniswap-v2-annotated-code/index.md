---
title: "Uniswap-v2 ஒப்பந்தத்தின் வழிகாட்டல்"
description: Uniswap-v2 ஒப்பந்தம் எவ்வாறு செயல்படுகிறது? அது ஏன் அவ்வாறு எழுதப்பட்டுள்ளது?
author: Ori Pomerantz
tags: [ "திட்பம்" ]
skill: intermediate
published: 2021-05-01
lang: ta
---

## அறிமுகம் {#introduction}

[Uniswap v2](https://app.uniswap.org/whitepaper.pdf) எந்த இரண்டு ERC-20 டோக்கன்களுக்கும் இடையில் ஒரு பரிமாற்றச் சந்தையை உருவாக்க முடியும். இந்தக் கட்டுரையில், இந்த நெறிமுறையைச் செயல்படுத்தும் ஒப்பந்தங்களுக்கான மூலக் குறியீட்டைப் பார்ப்போம், மேலும் அவை ஏன் இந்த வழியில் எழுதப்பட்டுள்ளன என்பதையும் காண்போம்.

### Uniswap என்ன செய்கிறது? {#what-does-uniswap-do}

அடிப்படையில், இரண்டு வகையான பயனர்கள் உள்ளனர்: பணப்புழக்க வழங்குநர்கள் மற்றும் வர்த்தகர்கள்.

_பணப்புழக்க வழங்குநர்கள்_ பரிமாற்றம் செய்யக்கூடிய இரண்டு டோக்கன்களைக் கொண்டு குளத்திற்கு வழங்குகிறார்கள் (நாங்கள் அவற்றை **டோக்கன்0** மற்றும் **டோக்கன்1** என்று அழைப்போம்). அதற்குப் பதிலாக, அவர்கள் _பணப்புழக்க டோக்கன்_ எனப்படும் குளத்தின் பகுதி உரிமையைக் குறிக்கும் மூன்றாவது டோக்கனைப் பெறுகிறார்கள்.

_வர்த்தகர்கள்_ ஒரு வகை டோக்கனை குளத்திற்கு அனுப்பி மற்றொன்றைப் பெறுகிறார்கள் (உதாரணமாக, **டோக்கன்0** ஐ அனுப்பி, பணப்புழக்க வழங்குநர்களால் வழங்கப்பட்ட குளத்திலிருந்து **டோக்கன்1** ஐப் பெறுகிறார்கள்). பரிமாற்ற விகிதம், குளத்தில் உள்ள **டோக்கன்0**கள் மற்றும் **டோக்கன்1**களின் சார்பு எண்ணிக்கையால் தீர்மானிக்கப்படுகிறது. கூடுதலாக, பணப்புழக்கக் குளத்திற்கு வெகுமதியாக ஒரு சிறிய சதவீதத்தை குளம் எடுத்துக்கொள்கிறது.

பணப்புழக்க வழங்குநர்கள் தங்கள் சொத்துக்களைத் திரும்பப் பெற விரும்பும்போது, அவர்கள் குள டோக்கன்களை எரித்து, வெகுமதிகளில் தங்கள் பங்கு உட்பட, தங்கள் டோக்கன்களைத் திரும்பப் பெறலாம்.

[முழுமையான விளக்கத்திற்கு இங்கே கிளிக் செய்யவும்](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/swaps/).

### ஏன் v2? ஏன் v3 இல்லை? {#why-v2}

[Uniswap v3](https://app.uniswap.org/whitepaper-v3.pdf) என்பது v2 ஐ விட மிகவும் சிக்கலான ஒரு மேம்படுத்தல் ஆகும். முதலில் v2 ஐக் கற்றுக்கொண்டு பின்னர் v3 க்குச் செல்வது எளிது.

### முக்கிய ஒப்பந்தங்கள் மற்றும் புற ஒப்பந்தங்கள் {#contract-types}

Uniswap v2 இரண்டு கூறுகளாகப் பிரிக்கப்பட்டுள்ளது, ஒரு முக்கிய பகுதி மற்றும் ஒரு புறப்பகுதி. இந்தப் பிரிவு, சொத்துக்களை வைத்திருக்கும் முக்கிய ஒப்பந்தங்களை, எனவே _பாதுகாப்பாக_ இருக்க வேண்டியவை, எளிமையானதாகவும் தணிக்கை செய்ய எளிதாகவும் இருக்க அனுமதிக்கிறது. வர்த்தகர்களுக்குத் தேவைப்படும் அனைத்து கூடுதல் செயல்பாடுகளையும் புற ஒப்பந்தங்கள் மூலம் வழங்க முடியும்.

## தரவு மற்றும் கட்டுப்பாட்டுப் பாய்வுகள் {#flows}

Uniswap-இன் மூன்று முக்கியச் செயல்பாடுகளை நீங்கள் செய்யும்போது நடக்கும் தரவு மற்றும் கட்டுப்பாட்டுப் பாய்வு இதுதான்:

1. பல்வேறு டோக்கன்களுக்கு இடையில் பரிமாற்றம் செய்தல்
2. சந்தைக்குப் பணப்புழக்கத்தைச் சேர்த்து, ஜோடி பரிமாற்ற ERC-20 பணப்புழக்க டோக்கன்களுடன் வெகுமதி பெறுங்கள்
3. ERC-20 பணப்புழக்க டோக்கன்களை எரித்து, ஜோடி பரிமாற்றம் வர்த்தகர்களைப் பரிமாறிக்கொள்ள அனுமதிக்கும் ERC-20 டோக்கன்களைத் திரும்பப் பெறுங்கள்

### பரிமாற்றம் {#swap-flow}

வர்த்தகர்களால் பயன்படுத்தப்படும் இது மிகவும் பொதுவான பாய்வாகும்:

#### அழைப்பாளர் {#caller}

1. பரிமாற்றம் செய்யப்பட வேண்டிய தொகையில் புறக் கணக்கிற்கு ஒரு ஒதுக்கீட்டை வழங்கவும்.
2. புற ஒப்பந்தத்தின் பல பரிமாற்றச் செயல்பாடுகளில் ஒன்றை அழைக்கவும் (எது ETH சம்பந்தப்பட்டதா இல்லையா, வர்த்தகர் டெபாசிட் செய்ய வேண்டிய டோக்கன்களின் அளவைக் குறிப்பிடுகிறாரா அல்லது திரும்பப் பெற வேண்டிய டோக்கன்களின் அளவைக் குறிப்பிடுகிறாரா என்பதைப் பொறுத்தது).
   ஒவ்வொரு பரிமாற்றச் செயல்பாடும் ஒரு `path`-ஐ ஏற்றுக்கொள்கிறது, இது செல்ல வேண்டிய பரிமாற்றங்களின் ஒரு வரிசையாகும்.

#### புற ஒப்பந்தத்தில் (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02-sol}

3. பாதையில் உள்ள ஒவ்வொரு பரிமாற்றத்திலும் வர்த்தகம் செய்யப்பட வேண்டிய தொகைகளைக் கண்டறியவும்.
4. பாதையின் மீது மீண்டும் மீண்டும் செயல்படுகிறது. வழியில் உள்ள ஒவ்வொரு பரிமாற்றத்திற்கும் அது உள்ளீட்டு டோக்கனை அனுப்பி, பின்னர் பரிமாற்றத்தின் `swap` செயல்பாட்டை அழைக்கிறது.
   பெரும்பாலான சந்தர்ப்பங்களில், டோக்கன்களுக்கான சேருமிட முகவரி பாதையில் அடுத்த ஜோடி பரிமாற்றமாகும். இறுதிப் பரிமாற்றத்தில் அது வர்த்தகரால் வழங்கப்பட்ட முகவரியாகும்.

#### முக்கிய ஒப்பந்தத்தில் (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

5. முக்கிய ஒப்பந்தம் ஏமாற்றப்படவில்லை என்பதைச் சரிபார்த்து, பரிமாற்றத்திற்குப் பிறகு போதுமான பணப்புழக்கத்தைப் பராமரிக்க முடியும் என்பதை உறுதிப்படுத்தவும்.
6. தெரிந்த இருப்புகளுக்குக் கூடுதலாக எங்களிடம் எத்தனை கூடுதல் டோக்கன்கள் உள்ளன என்பதைப் பார்க்கவும். அந்தத் தொகை, பரிமாற்றத்திற்காக நாங்கள் பெற்ற உள்ளீட்டு டோக்கன்களின் எண்ணிக்கையாகும்.
7. வெளியீட்டு டோக்கன்களை சேருமிடத்திற்கு அனுப்பவும்.
8. இருப்புத் தொகைகளைப் புதுப்பிக்க `_update`-ஐ அழைக்கவும்

#### புற ஒப்பந்தத்திற்குத் திரும்பி (UniswapV2Router02.sol) {#back-in-the-periphery-contract-uniswapv2router02-sol}

9. தேவையான எந்தவொரு சுத்திகரிப்பையும் செய்யவும் (உதாரணமாக, வர்த்தகருக்கு அனுப்ப ETH-ஐத் திரும்பப் பெற WETH டோக்கன்களை எரிக்கவும்)

### பணப்புழக்கத்தைச் சேர்க்கவும் {#add-liquidity-flow}

#### அழைப்பாளர் {#caller-2}

1. பணப்புழக்கக் குளத்தில் சேர்க்கப்பட வேண்டிய தொகைகளில் புறக் கணக்கிற்கு ஒரு ஒதுக்கீட்டை வழங்கவும்.
2. புற ஒப்பந்தத்தின் `addLiquidity` செயல்பாடுகளில் ஒன்றை அழைக்கவும்.

#### புற ஒப்பந்தத்தில் (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-2}

3. தேவைப்பட்டால் ஒரு புதிய ஜோடி பரிமாற்றத்தை உருவாக்கவும்
4. ஏற்கனவே ஒரு ஜோடி பரிமாற்றம் இருந்தால், சேர்க்க வேண்டிய டோக்கன்களின் அளவைக் கணக்கிடவும். இது இரண்டு டோக்கன்களுக்கும் ஒரே மாதிரியான மதிப்பாக இருக்க வேண்டும், எனவே புதிய டோக்கன்களுக்கும் ஏற்கனவே உள்ள டோக்கன்களுக்கும் ஒரே விகிதம்.
5. தொகைகள் ஏற்றுக்கொள்ளக்கூடியவையா எனச் சரிபார்க்கவும் (அழைப்பாளர்கள் ஒரு குறைந்தபட்ச அளவைக் குறிப்பிடலாம், அதற்குக் கீழே அவர்கள் பணப்புழக்கத்தைச் சேர்க்க விரும்ப மாட்டார்கள்)
6. முக்கிய ஒப்பந்தத்தை அழைக்கவும்.

#### முக்கிய ஒப்பந்தத்தில் (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

7. பணப்புழக்க டோக்கன்களை உருவாக்கி அவற்றை அழைப்பாளருக்கு அனுப்பவும்
8. இருப்புத் தொகைகளைப் புதுப்பிக்க `_update`-ஐ அழைக்கவும்

### பணப்புழக்கத்தை அகற்றவும் {#remove-liquidity-flow}

#### அழைப்பாளர் {#caller-3}

1. அடிப்படை டோக்கன்களுக்குப் பதிலாக எரிக்கப்பட வேண்டிய பணப்புழக்க டோக்கன்களின் ஒதுக்கீட்டை புறக் கணக்கிற்கு வழங்கவும்.
2. புற ஒப்பந்தத்தின் `removeLiquidity` செயல்பாடுகளில் ஒன்றை அழைக்கவும்.

#### புற ஒப்பந்தத்தில் (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-3}

3. பணப்புழக்க டோக்கன்களை ஜோடி பரிமாற்றத்திற்கு அனுப்பவும்

#### முக்கிய ஒப்பந்தத்தில் (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-3}

4. எரிக்கப்பட்ட டோக்கன்களின் விகிதத்தில் அடிப்படை டோக்கன்களை சேருமிட முகவரிக்கு அனுப்பவும். உதாரணமாக, குளத்தில் 1000 A டோக்கன்கள், 500 B டோக்கன்கள், மற்றும் 90 பணப்புழக்க டோக்கன்கள் இருந்தால், நாம் எரிப்பதற்கு 9 டோக்கன்களைப் பெற்றால், நாம் பணப்புழக்க டோக்கன்களில் 10% எரிக்கிறோம், எனவே பயனருக்கு 100 A டோக்கன்களையும் 50 B டோக்கன்களையும் திரும்ப அனுப்புகிறோம்.
5. பணப்புழக்க டோக்கன்களை எரிக்கவும்
6. இருப்புத் தொகைகளைப் புதுப்பிக்க `_update`-ஐ அழைக்கவும்

## முக்கிய ஒப்பந்தங்கள் {#core-contracts}

இவை பணப்புழக்கத்தை வைத்திருக்கும் பாதுகாப்பான ஒப்பந்தங்கள்.

### UniswapV2Pair.sol {#UniswapV2Pair}

[இந்த ஒப்பந்தம்](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol) டோக்கன்களைப் பரிமாறிக்கொள்ளும் உண்மையான குளத்தைச் செயல்படுத்துகிறது. இது முக்கிய Uniswap செயல்பாடாகும்.

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';
```

ஒப்பந்தம் அவற்றைச் செயல்படுத்துவதாலோ (`IUniswapV2Pair` மற்றும் `UniswapV2ERC20`) அல்லது அவற்றைச் செயல்படுத்தும் ஒப்பந்தங்களை அழைப்பதாலோ, ஒப்பந்தம் தெரிந்து கொள்ள வேண்டிய அனைத்து இடைமுகங்களும் இவையே.

```solidity
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
```

இந்த ஒப்பந்தம் `UniswapV2ERC20` இலிருந்து பெறப்பட்டது, இது பணப்புழக்க டோக்கன்களுக்கான ERC-20 செயல்பாடுகளை வழங்குகிறது.

```solidity
    using SafeMath  for uint;
```

[SafeMath நூலகம்](https://docs.openzeppelin.com/contracts/2.x/api/math) ஓவர்ஃப்ளோ மற்றும் அண்டர்ஃப்ளோக்களைத் தவிர்க்கப் பயன்படுத்தப்படுகிறது. இது முக்கியமானது, ஏனெனில் இல்லையெனில் ஒரு மதிப்பு `-1` ஆக இருக்க வேண்டிய சூழ்நிலையில், அதற்குப் பதிலாக `2^256-1` ஆக இருக்கும்.

```solidity
    using UQ112x112 for uint224;
```

குள ஒப்பந்தத்தில் உள்ள பல கணக்கீடுகளுக்குப் பின்னங்கள் தேவைப்படுகின்றன. இருப்பினும், EVM-ஆல் பின்னங்கள் ஆதரிக்கப்படவில்லை.
Uniswap கண்டறிந்த தீர்வு 224 பிட் மதிப்புகளைப் பயன்படுத்துவதாகும், இதில் முழு எண்ணுக்கு 112 பிட்கள் மற்றும் பின்னத்திற்கு 112 பிட்கள். எனவே `1.0` என்பது `2^112` ஆகவும், `1.5` என்பது `2^112 + 2^111` ஆகவும் குறிக்கப்படுகிறது.

இந்த நூலகம் பற்றிய கூடுதல் விவரங்கள் [ஆவணத்தில் பின்னர்](#FixedPoint) கிடைக்கும்.

#### மாறிகள் {#pair-vars}

```solidity
    uint public constant MINIMUM_LIQUIDITY = 10**3;
```

பூஜ்ஜியத்தால் வகுத்தல் நிகழ்வுகளைத் தவிர்க்க, எப்போதும் இருக்கும் ஒரு குறைந்தபட்ச பணப்புழக்க டோக்கன்கள் உள்ளன (ஆனால் அவை பூஜ்ஜியக் கணக்கிற்குச் சொந்தமானவை). அந்த எண் **MINIMUM_LIQUIDITY**, அதாவது ஆயிரம்.

```solidity
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
```

இது ERC-20 பரிமாற்றச் செயல்பாட்டிற்கான ABI தேர்வி ஆகும். இது இரண்டு டோக்கன் கணக்குகளில் ERC-20 டோக்கன்களைப் பரிமாற்றப் பயன்படுகிறது.

```solidity
    address public factory;
```

இது இந்தக் குளத்தை உருவாக்கிய ஃபேக்டரி ஒப்பந்தம். ஒவ்வொரு குளமும் இரண்டு ERC-20 டோக்கன்களுக்கு இடையேயான ஒரு பரிமாற்றம், ஃபேக்டரி என்பது இந்தக் குளங்கள் அனைத்தையும் இணைக்கும் ஒரு மையப் புள்ளியாகும்.

```solidity
    address public token0;
    address public token1;
```

இந்தக் குளத்தால் பரிமாறிக்கொள்ளக்கூடிய இரண்டு வகையான ERC-20 டோக்கன்களுக்கான ஒப்பந்தங்களின் முகவரிகள் இங்கே உள்ளன.

```solidity
    uint112 private reserve0;           // ஒற்றைச் சேமிப்பக இடத்தைப் பயன்படுத்துகிறது, getReserves வழியாக அணுகலாம்
    uint112 private reserve1;           // ஒற்றைச் சேமிப்பக இடத்தைப் பயன்படுத்துகிறது, getReserves வழியாக அணுகலாம்
```

ஒவ்வொரு டோக்கன் வகைக்கும் குளம் வைத்திருக்கும் இருப்புகள். இரண்டும் ஒரே அளவு மதிப்பைக் குறிக்கின்றன என்று நாங்கள் கருதுகிறோம், எனவே ஒவ்வொரு டோக்கன்0-ம் reserve1/reserve0 டோக்கன்1-களுக்கு மதிப்புடையது.

```solidity
    uint32  private blockTimestampLast; // ஒற்றைச் சேமிப்பக இடத்தைப் பயன்படுத்துகிறது, getReserves வழியாக அணுகலாம்
```

பரிமாற்றம் நடந்த கடைசித் தொகுதிக்கான நேர முத்திரை, இது காலப்போக்கில் பரிமாற்ற விகிதங்களைக் கண்காணிக்கப் பயன்படுகிறது.

Ethereum ஒப்பந்தங்களின் மிகப்பெரிய கேஸ் செலவுகளில் ஒன்று சேமிப்பகம், இது ஒப்பந்தத்தின் ஒரு அழைப்பிலிருந்து அடுத்த அழைப்பு வரை நீடிக்கும். ஒவ்வொரு சேமிப்பக கலமும் 256 பிட்கள் நீளமானது. எனவே மூன்று மாறிகள், `reserve0`, `reserve1`, மற்றும் `blockTimestampLast`, ஒரு ஒற்றைச் சேமிப்பக மதிப்பு அவை மூன்றையும் உள்ளடக்கும் வகையில் ஒதுக்கப்பட்டுள்ளன (112+112+32=256).

```solidity
    uint public price0CumulativeLast;
    uint public price1CumulativeLast;
```

இந்த மாறிகள் ஒவ்வொரு டோக்கனுக்கான மொத்தச் செலவுகளை (ஒவ்வொன்றும் மற்றொன்றின் அடிப்படையில்) வைத்திருக்கின்றன. ஒரு குறிப்பிட்ட காலப்பகுதியில் சராசரி பரிமாற்ற விகிதத்தைக் கணக்கிட அவை பயன்படுத்தப்படலாம்.

```solidity
    uint public kLast; // reserve0 * reserve1, மிகச் சமீபத்திய பணப்புழக்க நிகழ்விற்குப் பிறகு உடனடியாக
```

ஜோடி பரிமாற்றம் டோக்கன்0 மற்றும் டோக்கன்1 க்கு இடையிலான பரிமாற்ற விகிதத்தை வர்த்தகங்களின் போது இரண்டு இருப்புகளின் பெருக்கத்தை நிலையானதாக வைத்து தீர்மானிக்கிறது. `kLast` இந்த மதிப்பாகும். ஒரு பணப்புழக்க வழங்குநர் டோக்கன்களை டெபாசிட் செய்யும்போதோ அல்லது திரும்பப் பெறும்போதோ இது மாறுகிறது, மேலும் 0.3% சந்தைக் கட்டணம் காரணமாக இது சற்று அதிகரிக்கிறது.

இதோ ஒரு எளிய உதாரணம். எளிமைக்காக, அட்டவணையில் தசம புள்ளிக்குப் பிறகு மூன்று இலக்கங்கள் மட்டுமே உள்ளன என்பதை நினைவில் கொள்ளவும், மேலும் 0.3% வர்த்தகக் கட்டணத்தை நாங்கள் புறக்கணிக்கிறோம், எனவே எண்கள் துல்லியமானவை அல்ல.

| நிகழ்வு                                                                          |                  reserve0 |                  reserve1 | reserve0 \* reserve1 | சராசரி பரிமாற்ற விகிதம் (டோக்கன்1 / டோக்கன்0) |
| -------------------------------------------------------------------------------- | ------------------------: | ------------------------: | -------------------: | ---------------------------------------------------------------- |
| தொடக்க அமைப்பு                                                                   | 1,000.000 | 1,000.000 |            1,000,000 |                                                                  |
| வர்த்தகர் A, 50 டோக்கன்0-ஐ 47.619 டோக்கன்1-க்கு பரிமாற்றுகிறார்  | 1,050.000 |   952.381 |            1,000,000 | 0.952                                            |
| வர்த்தகர் B, 10 டோக்கன்0-ஐ 8.984 டோக்கன்1-க்கு பரிமாற்றுகிறார்   | 1,060.000 |   943.396 |            1,000,000 | 0.898                                            |
| வர்த்தகர் C, 40 டோக்கன்0-ஐ 34.305 டோக்கன்1-க்கு பரிமாற்றுகிறார்  | 1,100.000 |   909.090 |            1,000,000 | 0.858                                            |
| வர்த்தகர் D, 100 டோக்கன்1-ஐ 109.01 டோக்கன்0-க்கு பரிமாற்றுகிறார் |   990.990 | 1,009.090 |            1,000,000 | 0.917                                            |
| வர்த்தகர் E, 10 டோக்கன்0-ஐ 10.079 டோக்கன்1-க்கு பரிமாற்றுகிறார்  | 1,000.990 |   999.010 |            1,000,000 | 1.008                                            |

வர்த்தகர்கள் அதிக டோக்கன்0-ஐ வழங்கும்போது, டோக்கன்1-இன் சார்பு மதிப்பு அதிகரிக்கிறது, மேலும் நேர்மாறாக, வழங்கல் மற்றும் தேவையின் அடிப்படையில்.

#### பூட்டு {#pair-lock}

```solidity
    uint private unlocked = 1;
```

பாதுகாப்புக் குறைபாடுகளின் ஒரு வகை [மீள்நுழைவு துஷ்பிரயோகத்தை](https://medium.com/coinmonks/ethernaut-lvl-10-re-entrancy-walkthrough-how-to-abuse-execution-ordering-and-reproduce-the-dao-7ec88b912c14) அடிப்படையாகக் கொண்டது. Uniswap தன்னிச்சையான ERC-20 டோக்கன்களை மாற்ற வேண்டும், அதாவது அவற்றை அழைக்கும் Uniswap சந்தையை துஷ்பிரயோகம் செய்ய முயற்சிக்கும் ERC-20 ஒப்பந்தங்களை அழைப்பது.
ஒப்பந்தத்தின் ஒரு பகுதியாக `unlocked` மாறி இருப்பதன் மூலம், செயல்பாடுகள் இயங்கும் போது (ஒரே பரிவர்த்தனைக்குள்) அழைக்கப்படுவதைத் தடுக்கலாம்.

```solidity
    modifier lock() {
```

இந்தச் செயல்பாடு ஒரு [மாற்றி](https://docs.soliditylang.org/en/v0.8.3/contracts.html#function-modifiers) ஆகும், இது ஒரு சாதாரண செயல்பாட்டின் நடத்தையை ஏதேனும் ஒரு வழியில் மாற்ற அதைச் சுற்றி வருகிறது.

```solidity
        require(unlocked == 1, 'UniswapV2: LOCKED');
        unlocked = 0;
```

`unlocked` ஒன்றுக்கு சமமாக இருந்தால், அதை பூஜ்ஜியமாக அமைக்கவும். அது ஏற்கனவே பூஜ்ஜியமாக இருந்தால், அழைப்பைத் திருப்பி, அதைத் தோல்வியடையச் செய்யவும்.

```solidity
        _;
```

ஒரு மாற்றியில் `_;` என்பது அசல் செயல்பாட்டு அழைப்பு (அனைத்து அளவுருக்களுடன்). இங்கே, அது அழைக்கப்படும் போது `unlocked` ஒன்றாக இருந்தால் மட்டுமே செயல்பாட்டு அழைப்பு நடக்கும் என்றும், அது இயங்கும் போது `unlocked` இன் மதிப்பு பூஜ்ஜியமாக இருக்கும் என்றும் பொருள்.

```solidity
        unlocked = 1;
    }
```

முக்கியச் செயல்பாடு திரும்பிய பிறகு, பூட்டை விடுவிக்கவும்.

#### இதர. செயல்பாடுகள் {#pair-misc}

```solidity
    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }
```

இந்தச் செயல்பாடு பரிமாற்றத்தின் தற்போதைய நிலையை அழைப்பாளர்களுக்கு வழங்குகிறது. Solidity செயல்பாடுகள் [பல மதிப்புகளைத் திருப்ப முடியும்](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values) என்பதைக் கவனியுங்கள்.

```solidity
    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
```

இந்த உள் செயல்பாடு ஒரு குறிப்பிட்ட அளவு ERC20 டோக்கன்களை பரிமாற்றத்திலிருந்து வேறு ஒருவருக்கு மாற்றுகிறது. நாங்கள் அழைக்கும் செயல்பாடு `transfer(address,uint)` என்பதை `SELECTOR` குறிப்பிடுகிறது (மேலே உள்ள வரையறையைப் பார்க்கவும்).

டோக்கன் செயல்பாட்டிற்கான ஒரு இடைமுகத்தை இறக்குமதி செய்வதைத் தவிர்க்க, [ABI செயல்பாடுகளில்](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions) ஒன்றைப் பயன்படுத்தி "கைமுறையாக" அழைப்பை உருவாக்குகிறோம்.

```solidity
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }
```

ஒரு ERC-20 பரிமாற்ற அழைப்பு தோல்வியைப் புகாரளிக்க இரண்டு வழிகள் உள்ளன:

1. திரும்பப்பெறுதல். ஒரு வெளிப்புற ஒப்பந்தத்திற்கான அழைப்பு திரும்பப்பெற்றால், பூலியன் ரிட்டர்ன் மதிப்பு `false` ஆகும்
2. சாதாரணமாக முடித்து, ஆனால் ஒரு தோல்வியைப் புகாரளிக்கவும். அந்த நிலையில், ரிட்டர்ன் மதிப்பு இடையகத்திற்கு பூஜ்ஜியமற்ற நீளம் உள்ளது, மேலும் பூலியன் மதிப்பாக டிகோட் செய்யப்படும்போது அது `false` ஆக இருக்கும்

இந்த நிபந்தனைகளில் ஏதேனும் ஒன்று நடந்தால், திரும்பப்பெறவும்.

#### நிகழ்வுகள் {#pair-events}

```solidity
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
```

ஒரு பணப்புழக்க வழங்குநர் பணப்புழக்கத்தை டெபாசிட் செய்யும்போதோ (`Mint`) அல்லது திரும்பப் பெறும்போதோ (`Burn`) இந்த இரண்டு நிகழ்வுகளும் வெளியிடப்படுகின்றன. இரண்டு நிகழ்வுகளிலும், டெபாசிட் செய்யப்பட்ட அல்லது திரும்பப் பெறப்பட்ட டோக்கன்0 மற்றும் டோக்கன்1 இன் அளவுகள் நிகழ்வின் ஒரு பகுதியாகும், அத்துடன் எங்களை அழைத்த கணக்கின் அடையாளம் (`sender`). திரும்பப் பெறும் பட்சத்தில், டோக்கன்களைப் பெற்ற இலக்கையும் (`to`) நிகழ்வு உள்ளடக்குகிறது, இது அனுப்புநராக இருக்காது.

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

ஒரு வர்த்தகர் ஒரு டோக்கனை மற்றொன்றுக்கு மாற்றும்போது இந்த நிகழ்வு வெளியிடப்படுகிறது. மீண்டும், அனுப்புநரும் சேருமிடமும் ஒன்றாக இருக்காது.
ஒவ்வொரு டோக்கனும் பரிமாற்றத்திற்கு அனுப்பப்படலாம் அல்லது அதிலிருந்து பெறப்படலாம்.

```solidity
    event Sync(uint112 reserve0, uint112 reserve1);
```

இறுதியாக, `Sync` டோக்கன்கள் சேர்க்கப்படும்போதோ அல்லது திரும்பப் பெறப்படும்போதோ, காரணத்தைப் பொருட்படுத்தாமல், சமீபத்திய இருப்புத் தகவலை (எனவே பரிமாற்ற வீதம்) வழங்க வெளியிடப்படுகிறது.

#### அமைவு செயல்பாடுகள் {#pair-setup}

புதிய ஜோடி பரிமாற்றம் அமைக்கப்பட்டவுடன் இந்தச் செயல்பாடுகள் ஒருமுறை அழைக்கப்பட வேண்டும்.

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

கட்டமைப்பாளர் ஜோடியை உருவாக்கிய தொழிற்சாலையின் முகவரியை நாங்கள் கண்காணிப்போம் என்பதை உறுதி செய்கிறது. இந்தத் தகவல் `initialize` மற்றும் தொழிற்சாலையின் கட்டணத்திற்கு (ஏதேனும் இருந்தால்) தேவைப்படுகிறது

```solidity
    // called once by the factory at time of deployment
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
        token0 = _token0;
        token1 = _token1;
    }
```

இந்தச் செயல்பாடு தொழிற்சாலையை (மற்றும் தொழிற்சாலையை மட்டும்) இந்தப் ஜோடி பரிமாறிக்கொள்ளும் இரண்டு ERC-20 டோக்கன்களைக் குறிப்பிட அனுமதிக்கிறது.

#### உள் புதுப்பிப்பு செயல்பாடுகள் {#pair-update-internal}

##### \_புதுப்பிப்பு

```solidity
    // update reserves and, on the first call per block, price accumulators
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

டோக்கன்கள் டெபாசிட் செய்யப்படும்போதோ அல்லது திரும்பப் பெறப்படும்போதோ இந்தச் செயல்பாடு அழைக்கப்படுகிறது.

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

balance0 அல்லது balance1 (uint256) uint112(-1) (=2^112-1) ஐ விட அதிகமாக இருந்தால் (எனவே அது ஓவர்ஃப்ளோ ஆகி uint112 ஆக மாற்றப்படும்போது 0 க்குத் திரும்புகிறது) ஓவர்ஃப்ளோக்களைத் தடுக்க \_update ஐத் தொடர மறுக்கவும். 10^18 அலகுகளாகப் பிரிக்கக்கூடிய ஒரு சாதாரண டோக்கனுடன், ஒவ்வொரு பரிமாற்றமும் ஒவ்வொரு டோக்கனிலும் சுமார் 5.1\*10^15 ஆக வரையறுக்கப்பட்டுள்ளது. இதுவரை அது ஒரு பிரச்சனையாக இல்லை.

```solidity
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
```

கடந்த நேரம் பூஜ்ஜியமாக இல்லாவிட்டால், இந்தத் தொகுதியில் முதல் பரிமாற்ற பரிவர்த்தனை நாங்கள் தான் என்று அர்த்தம். அந்த நிலையில், செலவு திரட்டிகளை நாங்கள் புதுப்பிக்க வேண்டும்.

```solidity
            // * never overflows, and + overflow is desired
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
```

ஒவ்வொரு செலவு திரட்டியும் சமீபத்திய செலவுடன் (மற்ற டோக்கனின் இருப்பு/இந்த டோக்கனின் இருப்பு) வினாடிகளில் கடந்த நேரத்தால் பெருக்கி புதுப்பிக்கப்படுகிறது. சராசரி விலையைப் பெற, நீங்கள் இரண்டு நேரப் புள்ளிகளில் திரட்டப்பட்ட விலையைப் படித்து, அவற்றுக்கிடையேயான நேர வேறுபாட்டால் வகுக்கவும். உதாரணமாக, இந்த நிகழ்வுகளின் வரிசையை எடுத்துக்கொள்வோம்:

| நிகழ்வு                                                                                              |                  reserve0 |                  reserve1 | நேர முத்திரை | ஓரளவு பரிமாற்ற விகிதம் (இருப்பு1 / இருப்பு0) |                                                     விலை0திரட்டப்பட்டகடைசி |
| ---------------------------------------------------------------------------------------------------- | ------------------------: | ------------------------: | ------------ | --------------------------------------------------------------: | -------------------------------------------------------------------------: |
| தொடக்க அமைப்பு                                                                                       | 1,000.000 | 1,000.000 | 5,000        |                                           1.000 |                                                                          0 |
| வர்த்தகர் A 50 டோக்கன்0 ஐ டெபாசிட் செய்து, 47.619 டோக்கன்1 ஐத் திரும்பப் பெறுகிறார்  | 1,050.000 |   952.381 | 5,020        |                                           0.907 |                                                                         20 |
| வர்த்தகர் B 10 டோக்கன்0 ஐ டெபாசிட் செய்து, 8.984 டோக்கன்1 ஐத் திரும்பப் பெறுகிறார்   | 1,060.000 |   943.396 | 5,030        |                                           0.890 |                       20+10\*0.907 = 29.07 |
| வர்த்தகர் C 40 டோக்கன்0 ஐ டெபாசிட் செய்து, 34.305 டோக்கன்1 ஐத் திரும்பப் பெறுகிறார்  | 1,100.000 |   909.090 | 5,100        |                                           0.826 |    29.07+70\*0.890 = 91.37 |
| வர்த்தகர் D 100 டோக்கன்1 ஐ டெபாசிட் செய்து, 109.01 டோக்கன்0 ஐத் திரும்பப் பெறுகிறார் |   990.990 | 1,009.090 | 5,110        |                                           1.018 |    91.37+10\*0.826 = 99.63 |
| வர்த்தகர் E 10 டோக்கன்0 ஐ டெபாசிட் செய்து, 10.079 டோக்கன்1 ஐத் திரும்பப் பெறுகிறார்  | 1,000.990 |   999.010 | 5,150        |                                           0.998 | 99.63+40\*1.1018 = 143.702 |

5,030 மற்றும் 5,150 நேர முத்திரைகளுக்கு இடையில் **டோக்கன்0** இன் சராசரி விலையைக் கணக்கிட விரும்புகிறோம் என்று வைத்துக்கொள்வோம். `price0Cumulative` மதிப்பில் உள்ள வேறுபாடு 143.702-29.07=114.632 ஆகும். இது இரண்டு நிமிடங்களில் (120 வினாடிகள்) சராசரியாகும். எனவே சராசரி விலை 114.632/120 = 0.955.

இந்த விலை கணக்கீடுதான் பழைய இருப்பு அளவுகளை நாங்கள் தெரிந்து கொள்ள வேண்டிய காரணம்.

```solidity
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }
```

இறுதியாக, உலகளாவிய மாறிகளைப் புதுப்பித்து, ஒரு `Sync` நிகழ்வை வெளியிடவும்.

##### \_மின்ட் கட்டணம்

```solidity
    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
```

Uniswap 2.0 இல் வர்த்தகர்கள் சந்தையைப் பயன்படுத்த 0.30% கட்டணம் செலுத்துகின்றனர். அந்தக் கட்டணத்தின் பெரும்பகுதி (வர்த்தகத்தில் 0.25%) எப்போதும் பணப்புழக்க வழங்குநர்களுக்குச் செல்கிறது. மீதமுள்ள 0.05% பணப்புழக்க வழங்குநர்களுக்கு அல்லது தொழிற்சாலையால் நெறிமுறைக் கட்டணமாகக் குறிப்பிடப்பட்ட ஒரு முகவரிக்குச் செல்லலாம், இது Uniswap இன் வளர்ச்சி முயற்சிக்கு பணம் செலுத்துகிறது.

கணக்கீடுகளைக் குறைப்பதற்காக (எனவே கேஸ் செலவுகள்), இந்தக் கட்டணம் ஒவ்வொரு பரிவர்த்தனையிலும் கணக்கிடப்படாமல், குளத்தில் பணப்புழக்கம் சேர்க்கப்படும்போதோ அல்லது அகற்றப்படும்போதோ மட்டுமே கணக்கிடப்படுகிறது.

```solidity
        address feeTo = IUniswapV2Factory(factory).feeTo();
        feeOn = feeTo != address(0);
```

தொழிற்சாலையின் கட்டண சேருமிடத்தைப் படிக்கவும். அது பூஜ்ஜியமாக இருந்தால், நெறிமுறைக் கட்டணம் இல்லை, அந்தக் கட்டணத்தைக் கணக்கிடத் தேவையில்லை.

```solidity
        uint _kLast = kLast; // gas savings
```

`kLast` மாநில மாறி சேமிப்பகத்தில் அமைந்துள்ளது, எனவே இது ஒப்பந்தத்திற்கு வெவ்வேறு அழைப்புகளுக்கு இடையில் ஒரு மதிப்பைக் கொண்டிருக்கும்.
ஒப்பந்தத்திற்கான செயல்பாட்டு அழைப்பு முடிவடையும் போது வெளியிடப்படும் நிலையற்ற நினைவகத்திற்கான அணுகலை விட சேமிப்பகத்திற்கான அணுகல் மிகவும் விலை உயர்ந்தது, எனவே கேஸைச் சேமிக்க ஒரு உள் மாறியைப் பயன்படுத்துகிறோம்.

```solidity
        if (feeOn) {
            if (_kLast != 0) {
```

பணப்புழக்க வழங்குநர்கள் தங்கள் பணப்புழக்க டோக்கன்களின் மதிப்பீட்டின் மூலம் தங்கள் பங்கைப் பெறுகிறார்கள். ஆனால் நெறிமுறைக் கட்டணத்திற்கு புதிய பணப்புழக்க டோக்கன்கள் உருவாக்கப்பட்டு, `feeTo` முகவரிக்கு வழங்கப்பட வேண்டும்.

```solidity
                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
                uint rootKLast = Math.sqrt(_kLast);
                if (rootK > rootKLast) {
```

ஒரு நெறிமுறைக் கட்டணத்தைச் சேகரிக்க புதிய பணப்புழக்கம் இருந்தால். இந்தக் கட்டுரையில் பின்னர் வர்க்க மூலச் செயல்பாட்டைக் காணலாம் (#Math)

```solidity
                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                    uint denominator = rootK.mul(5).add(rootKLast);
                    uint liquidity = numerator / denominator;
```

இந்தச் சிக்கலான கட்டணக் கணக்கீடு [வெள்ளை அறிக்கையில்](https://app.uniswap.org/whitepaper.pdf) பக்கம் 5-ல் விளக்கப்பட்டுள்ளது. `kLast` கணக்கிடப்பட்ட நேரத்திற்கும் தற்போதுக்கும் இடையில் பணப்புழக்கம் சேர்க்கப்படவில்லை அல்லது அகற்றப்படவில்லை என்பதை நாங்கள் அறிவோம் (ஏனெனில் ஒவ்வொரு முறையும் பணப்புழக்கம் சேர்க்கப்படும்போதோ அல்லது அகற்றப்படும்போதோ, அது உண்மையில் மாறுவதற்கு முன்பு இந்தக் கணக்கீட்டை நாங்கள் இயக்குகிறோம்), எனவே `reserve0 * reserve1` இல் ஏற்படும் எந்த மாற்றமும் பரிவர்த்தனைக் கட்டணங்களிலிருந்து வர வேண்டும் (அவை இல்லாமல் நாங்கள் `reserve0 * reserve1` ஐ நிலையானதாக வைத்திருப்போம்).

```solidity
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
```

கூடுதல் பணப்புழக்க டோக்கன்களை உருவாக்கி, அவற்றை `feeTo` க்கு ஒதுக்க `UniswapV2ERC20._mint` செயல்பாட்டைப் பயன்படுத்தவும்.

```solidity
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }
```

கட்டணம் இல்லை என்றால், `kLast` ஐ பூஜ்ஜியத்திற்கு அமைக்கவும் (அது ஏற்கனவே இல்லை என்றால்). இந்த ஒப்பந்தம் எழுதப்பட்டபோது, Ethereum மாநிலத்தின் ஒட்டுமொத்த அளவைக் குறைக்க ஒப்பந்தங்களை ஊக்குவித்த ஒரு [கேஸ் ரீஃபண்ட் அம்சம்](https://eips.ethereum.org/EIPS/eip-3298) இருந்தது, அவை தேவைப்படாத சேமிப்பகத்தை பூஜ்ஜியமாக்குவதன் மூலம்.
இந்தக் குறியீடு முடிந்தால் அந்தப் பணத்தைத் திரும்பப் பெறுகிறது.

#### வெளிப்புறமாக அணுகக்கூடிய செயல்பாடுகள் {#pair-external}

எந்தவொரு பரிவர்த்தனையும் அல்லது ஒப்பந்தமும் இந்தச் செயல்பாடுகளை அழைக்க _முடியும்_ என்றாலும், அவை புற ஒப்பந்தத்திலிருந்து அழைக்க வடிவமைக்கப்பட்டுள்ளன. நீங்கள் அவற்றை நேரடியாக அழைத்தால், ஜோடி பரிமாற்றத்தை நீங்கள் ஏமாற்ற முடியாது, ஆனால் நீங்கள் ஒரு தவறு மூலம் மதிப்பை இழக்கக்கூடும்.

##### மின்ட்

```solidity
    // this low-level function should be called from a contract which performs important safety checks
    function mint(address to) external lock returns (uint liquidity) {
```

ஒரு பணப்புழக்க வழங்குநர் குளத்திற்கு பணப்புழக்கத்தைச் சேர்க்கும்போது இந்தச் செயல்பாடு அழைக்கப்படுகிறது. இது வெகுமதியாக கூடுதல் பணப்புழக்க டோக்கன்களை உருவாக்குகிறது. இது [ஒரு புற ஒப்பந்தத்திலிருந்து](#UniswapV2Router02) அழைக்கப்பட வேண்டும், இது அதே பரிவர்த்தனையில் பணப்புழக்கத்தைச் சேர்த்த பிறகு அதை அழைக்கிறது (எனவே வேறு யாரும் முறையான உரிமையாளருக்கு முன்பு புதிய பணப்புழக்கத்தைக் கோரும் ஒரு பரிவர்த்தனையைச் சமர்ப்பிக்க முடியாது).

```solidity
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
```

பல மதிப்புகளைத் திருப்பும் ஒரு Solidity செயல்பாட்டின் முடிவுகளைப் படிக்கும் முறை இது. கடைசியாகத் திருப்பப்பட்ட மதிப்புகளை நாங்கள் நிராகரிக்கிறோம், தொகுதி நேர முத்திரை, ஏனெனில் எங்களுக்கு அது தேவையில்லை.

```solidity
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0.sub(_reserve0);
        uint amount1 = balance1.sub(_reserve1);
```

தற்போதைய இருப்புகளைப் பெற்று, ஒவ்வொரு டோக்கன் வகையிலும் எவ்வளவு சேர்க்கப்பட்டுள்ளது என்பதைப் பார்க்கவும்.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
```

சேகரிக்க வேண்டிய நெறிமுறைக் கட்டணங்களைக் கணக்கிடவும், ஏதேனும் இருந்தால், அதற்கேற்ப பணப்புழக்க டோக்கன்களை உருவாக்கவும். `_mintFee` க்கான அளவுருக்கள் பழைய இருப்பு மதிப்புகள் என்பதால், கட்டணம் துல்லியமாக குள மாற்றங்களின் அடிப்படையில் மட்டுமே கணக்கிடப்படுகிறது, கட்டணங்கள் காரணமாக.

```solidity
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
```

இது முதல் டெபாசிட் என்றால், `MINIMUM_LIQUIDITY` டோக்கன்களை உருவாக்கி, அவற்றை பூஜ்ஜிய முகவரிக்கு அனுப்பிப் பூட்டவும். அவற்றை ஒருபோதும் மீட்க முடியாது, அதாவது குளம் ஒருபோதும் முழுமையாகக் காலியாகாது (இது சில இடங்களில் பூஜ்ஜியத்தால் வகுப்பதிலிருந்து நம்மைக் காப்பாற்றுகிறது). `MINIMUM_LIQUIDITY` இன் மதிப்பு ஆயிரம் ஆகும், இது பெரும்பாலான ERC-20 டோக்கன்கள் ஒரு டோக்கனின் 10^-18 அலகுகளாகப் பிரிக்கப்படுவதைக் கருத்தில் கொண்டு, ETH wei ஆகப் பிரிக்கப்படுவதைப் போல, ஒரு டோக்கனின் மதிப்பில் 10^-15 ஆகும். அதிக செலவு இல்லை.

முதல் டெபாசிட் நேரத்தில் இரண்டு டோக்கன்களின் சார்பு மதிப்பை நாங்கள் அறியவில்லை, எனவே நாங்கள் அளவுகளைப் பெருக்கி, ஒரு வர்க்க மூலத்தை எடுத்துக்கொள்கிறோம், டெபாசிட் இரண்டு டோக்கன்களிலும் சம மதிப்பைக் கொடுக்கிறது என்று கருதி.

இதை நாங்கள் நம்பலாம், ஏனெனில் டெபாசிட்டரின் நலனுக்காக சம மதிப்பைக் கொடுப்பது, நடுவர் தீர்ப்பால் மதிப்பை இழப்பதைத் தவிர்க்க.
இரண்டு டோக்கன்களின் மதிப்பு ஒரே மாதிரியாக உள்ளது என்று வைத்துக்கொள்வோம், ஆனால் எங்கள் டெபாசிட்டர் **டோக்கன்1** ஐ விட நான்கு மடங்கு அதிகமாக **டோக்கன்0** ஐ டெபாசிட் செய்தார். ஒரு வர்த்தகர், ஜோடி பரிமாற்றம் **டோக்கன்0** மிகவும் மதிப்புமிக்கது என்று நினைக்கும் உண்மையை அதிலிருந்து மதிப்பை எடுக்கப் பயன்படுத்தலாம்.

| நிகழ்வு                                                                                           | reserve0 | reserve1 | reserve0 \* reserve1 | குளத்தின் மதிப்பு (இருப்பு0 + இருப்பு1) |
| ------------------------------------------------------------------------------------------------- | -------: | -------: | -------------------: | ---------------------------------------------------------: |
| தொடக்க அமைப்பு                                                                                    |        8 |       32 |                  256 |                                                         40 |
| வர்த்தகர் 8 **டோக்கன்0** டோக்கன்களை டெபாசிட் செய்கிறார், 16 **டோக்கன்1** ஐத் திரும்பப் பெறுகிறார் |       16 |       16 |                  256 |                                                         32 |

நீங்கள் பார்க்கிறபடி, வர்த்தகர் ஒரு கூடுதல் 8 டோக்கன்களை சம்பாதித்தார், இது குளத்தின் மதிப்பில் குறைவிலிருந்து வருகிறது, அதன் உரிமையாளரான டெபாசிட்டரைக் காயப்படுத்துகிறது.

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);

```

ஒவ்வொரு அடுத்தடுத்த டெபாசிட்டுடனும், இரண்டு சொத்துக்களுக்கும் இடையிலான பரிமாற்ற விகிதத்தை நாங்கள் ஏற்கனவே அறிவோம், மேலும் பணப்புழக்க வழங்குநர்கள் இரண்டிலும் சம மதிப்பைக் கொடுப்பார்கள் என்று எதிர்பார்க்கிறோம். அவர்கள் அவ்வாறு செய்யாவிட்டால், அவர்கள் வழங்கிய குறைந்த மதிப்பைக் கொண்டு, தண்டனையாக பணப்புழக்க டோக்கன்களை நாங்கள் அவர்களுக்குக் கொடுக்கிறோம்.

இது ஆரம்ப டெபாசிட் அல்லது அடுத்தடுத்த டெபாசிட் ஆக இருந்தாலும், நாங்கள் வழங்கும் பணப்புழக்க டோக்கன்களின் எண்ணிக்கை `reserve0*reserve1` இல் ஏற்படும் மாற்றத்தின் வர்க்க மூலத்திற்கு சமம் மற்றும் பணப்புழக்க டோக்கனின் மதிப்பு மாறாது (இரண்டு வகைகளிலும் சம மதிப்புகள் இல்லாத டெபாசிட்டை நாங்கள் பெற்றால் தவிர, அந்த நிலையில் "அபராதம்" விநியோகிக்கப்படுகிறது). ஒரே மதிப்பைக் கொண்ட இரண்டு டோக்கன்களுடன் மற்றொரு உதாரணம் இங்கே, மூன்று நல்ல டெபாசிட்கள் மற்றும் ஒரு மோசமான டெபாசிட் (ஒரு டோக்கன் வகையின் டெபாசிட் மட்டுமே, எனவே அது எந்தப் பணப்புழக்க டோக்கன்களையும் உருவாக்காது).

| நிகழ்வு                                     |                                reserve0 |                                reserve1 | reserve0 \* reserve1 | குள மதிப்பு (இருப்பு0 + இருப்பு1) | இந்த டெபாசிட்டிற்காக உருவாக்கப்பட்ட பணப்புழக்க டோக்கன்கள் | மொத்த பணப்புழக்க டோக்கன்கள் |   ஒவ்வொரு பணப்புழக்க டோக்கனின் மதிப்பு |
| ------------------------------------------- | --------------------------------------: | --------------------------------------: | -------------------: | ---------------------------------------------------: | --------------------------------------------------------: | --------------------------: | -------------------------------------: |
| தொடக்க அமைப்பு                              |                   8.000 |                   8.000 |                   64 |                               16.000 |                                                         8 |                           8 |                  2.000 |
| ஒவ்வொரு வகையிலும் நான்கை டெபாசிட் செய்யவும் |                  12.000 |                  12.000 |                  144 |                               24.000 |                                                         4 |                          12 |                  2.000 |
| ஒவ்வொரு வகையிலும் இரண்டை டெபாசிட் செய்யவும் |                  14.000 |                  14.000 |                  196 |                               28.000 |                                                         2 |                          14 |                  2.000 |
| சமமற்ற மதிப்பு டெபாசிட்                     |                  18.000 |                  14.000 |                  252 |                               32.000 |                                                         0 |                          14 | ~2.286 |
| நடுவர் தீர்ப்புக்குப் பிறகு                 | ~15.874 | ~15.874 |                  252 |              ~31.748 |                                                         0 |                          14 | ~2.267 |

```solidity
        }
        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
        _mint(to, liquidity);
```

`UniswapV2ERC20._mint` செயல்பாட்டைப் பயன்படுத்தி கூடுதல் பணப்புழக்க டோக்கன்களை உருவாக்கி, அவற்றை சரியான கணக்கிற்கு வழங்கவும்.

```solidity

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Mint(msg.sender, amount0, amount1);
    }
```

மாநில மாறிகளைப் புதுப்பிக்கவும் (`reserve0`, `reserve1`, மற்றும் தேவைப்பட்டால் `kLast`) மற்றும் பொருத்தமான நிகழ்வை வெளியிடவும்.

##### எரித்தல்

```solidity
    // this low-level function should be called from a contract which performs important safety checks
    function burn(address to) external lock returns (uint amount0, uint amount1) {
```

பணப்புழக்கம் திரும்பப் பெறப்படும்போது இந்தச் செயல்பாடு அழைக்கப்படுகிறது மற்றும் பொருத்தமான பணப்புழக்க டோக்கன்கள் எரிக்கப்பட வேண்டும்.
இது [ஒரு புறக் கணக்கிலிருந்தும்](#UniswapV2Router02) அழைக்கப்பட வேண்டும்.

```solidity
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        address _token0 = token0;                                // gas savings
        address _token1 = token1;                                // gas savings
        uint balance0 = IERC20(_token0).balanceOf(address(this));
        uint balance1 = IERC20(_token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];
```

புற ஒப்பந்தம் அழைப்புக்கு முன்பு எரிக்கப்பட வேண்டிய பணப்புழக்கத்தை இந்த ஒப்பந்தத்திற்கு மாற்றியது. அந்த வழியில் எவ்வளவு பணப்புழக்கத்தை எரிக்க வேண்டும் என்பதை நாங்கள் அறிவோம், மேலும் அது எரிக்கப்படுவதை நாங்கள் உறுதிசெய்ய முடியும்.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
```

பணப்புழக்க வழங்குநர் இரண்டு டோக்கன்களுக்கும் சம மதிப்பைப் பெறுகிறார். இந்த வழியில் நாங்கள் பரிமாற்ற விகிதத்தை மாற்றுவதில்லை.

```solidity
        _burn(address(this), liquidity);
        _safeTransfer(_token0, to, amount0);
        _safeTransfer(_token1, to, amount1);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Burn(msg.sender, amount0, amount1, to);
    }

```

`burn` செயல்பாட்டின் மீதமுள்ளவை மேலே உள்ள `mint` செயல்பாட்டின் கண்ணாடிப் பிம்பமாகும்.

##### இடமாற்றம்

```solidity
    // this low-level function should be called from a contract which performs important safety checks
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
```

இந்தச் செயல்பாடும் [ஒரு புற ஒப்பந்தத்திலிருந்து](#UniswapV2Router02) அழைக்கப்பட வேண்டும்.

```solidity
        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

        uint balance0;
        uint balance1;
        { // scope for _token{0,1}, avoids stack too deep errors
```

உள்ளூர் மாறிகள் நினைவகத்தில் சேமிக்கப்படலாம் அல்லது, அவற்றில் அதிகமானவை இல்லை என்றால், நேரடியாக ஸ்டாக்கில் சேமிக்கப்படலாம்.
ஸ்டாக்கை நாங்கள் பயன்படுத்தும் எண்ணிக்கையை நாங்கள் வரம்பிட முடிந்தால், நாங்கள் குறைவான கேஸைப் பயன்படுத்துகிறோம். மேலும் விவரங்களுக்கு, [மஞ்சள் காகிதத்தைப் பார்க்கவும், முறையான Ethereum குறிப்புகள்](https://ethereum.github.io/yellowpaper/paper.pdf), ப. 26, சமன்பாடு 298.

```solidity
            address _token0 = token0;
            address _token1 = token1;
            require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
```

இந்த மாற்றம் நம்பிக்கையானது, ஏனெனில் அனைத்து நிபந்தனைகளும் பூர்த்தி செய்யப்பட்டுள்ளதா என்பதை நாங்கள் உறுதியாகத் தெரிந்துகொள்வதற்கு முன்பு நாங்கள் மாற்றுகிறோம். Ethereum இல் இது சரிதான், ஏனெனில் அழைப்பில் பின்னர் நிபந்தனைகள் பூர்த்தி செய்யப்படாவிட்டால், நாங்கள் அதிலிருந்தும் அது உருவாக்கிய எந்த மாற்றங்களிலிருந்தும் திரும்பப் பெறுகிறோம்.

```solidity
            if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
```

கோரப்பட்டால், இடமாற்றம் குறித்து பெறுநருக்குத் தெரிவிக்கவும்.

```solidity
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
```

```
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
    } தற்போதைய இருப்புகளைப் பெறவும். புற ஒப்பந்தம் டோக்கன்களை இடமாற்றத்திற்காக எங்களுக்கு அழைப்பதற்கு முன்பு அனுப்புகிறது.
```

```solidity
இது ஒப்பந்தத்திற்கு ஏமாற்றப்படவில்லை என்பதைச் சரிபார்ப்பதை எளிதாக்குகிறது, இது முக்கிய ஒப்பந்தத்தில் _நடக்க வேண்டும்_ (ஏனெனில் நாங்கள் எங்கள் புற ஒப்பந்தத்தை விட மற்ற நிறுவனங்களால் அழைக்கப்படலாம்).
```

```
    uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
    require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
    { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K'); இது இடமாற்றத்தால் நாங்கள் இழக்கவில்லை என்பதை உறுதிப்படுத்த ஒரு நல்ல சோதனையாகும். `reserve0*reserve1` ஐ எந்த சூழ்நிலையிலும் ஒரு இடமாற்றம் குறைக்கக்கூடாது.
```

```solidity
இடமாற்றத்தில் 0.3% கட்டணம் அனுப்பப்படுவதை நாங்கள் உறுதிசெய்வதும் இங்கேதான்; K இன் மதிப்பை நல்ல சோதனையிடுவதற்கு முன்பு, நாங்கள் இரண்டு இருப்புகளையும் 1000 ஆல் பெருக்கி, அளவுகளை 3 ஆல் பெருக்கியதைக் கழிக்கிறோம், இதன் பொருள் 0.3% (3/1000 = 0.003 = 0.3%) இருப்பிலிருந்து கழிக்கப்படுகிறது, அதன் K மதிப்பை தற்போதைய இருப்பு K மதிப்புடன் ஒப்பிடுவதற்கு முன்பு.
```

```
    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

##### `reserve0` மற்றும் `reserve1` ஐப் புதுப்பிக்கவும், தேவைப்பட்டால் விலை திரட்டிகள் மற்றும் நேர முத்திரை மற்றும் ஒரு நிகழ்வை வெளியிடவும்.

ஒருங்கிணைத்தல் அல்லது நீக்குதல்
உண்மையான இருப்புகள் ஜோடி பரிமாற்றம் வைத்திருப்பதாக நினைக்கும் இருப்புகளுடன் ஒத்திசைவிலிருந்து விலகிச் செல்ல வாய்ப்புள்ளது. ஒப்பந்தத்தின் ஒப்புதல் இல்லாமல் டோக்கன்களை திரும்பப் பெற வழி இல்லை, ஆனால் டெபாசிட்கள் வேறு விஷயம்.

ஒரு கணக்கு `mint` அல்லது `swap` ஐ அழைக்காமல் பரிமாற்றத்திற்கு டோக்கன்களை மாற்ற முடியும்.

- அந்த நிலையில் இரண்டு தீர்வுகள் உள்ளன:
- `sync`, தற்போதைய இருப்புகளுக்கு இருப்புகளைப் புதுப்பிக்கவும் `skim`, கூடுதல் தொகையைத் திரும்பப் பெறவும். டோக்கன்களை யார் டெபாசிட் செய்தார்கள் என்பது எங்களுக்குத் தெரியாததால், எந்தக் கணக்கும் `skim` ஐ அழைக்க அனுமதிக்கப்படுகிறது.

```solidity
இந்தத் தகவல் ஒரு நிகழ்வில் வெளியிடப்படுகிறது, ஆனால் நிகழ்வுகள் பிளாக்செயினிலிருந்து அணுக முடியாதவை.
```

### ```
// force balances to match reserves
function skim(address to) external lock {
    address _token0 = token0; // gas savings
    address _token1 = token1; // gas savings
    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
}



// force reserves to match balances
function sync() external lock {
    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
}
```}

UniswapV2Factory.sol {#UniswapV2Factory}

```solidity
[இந்த ஒப்பந்தம்](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol) ஜோடி பரிமாற்றங்களை உருவாக்குகிறது.
```

pragma solidity =0.5.16;import './interfaces/IUniswapV2Factory.sol';
import './UniswapV2Pair.sol';contract UniswapV2Factory is IUniswapV2Factory {
address public feeTo;
address public feeToSetter;
இந்த மாநில மாறிகள் நெறிமுறை கட்டணத்தை செயல்படுத்த அவசியமானவை (பார்க்க [வெள்ளையறிக்கை](https://app.uniswap.org/whitepaper.pdf), ப. 5).

```solidity
`feeTo` முகவரி நெறிமுறை கட்டணத்திற்கான பணப்புழக்க டோக்கன்களைக் குவிக்கிறது, மேலும் `feeToSetter` என்பது `feeTo` ஐ வேறு முகவரிக்கு மாற்ற அனுமதிக்கப்பட்ட முகவரி.
```

```
mapping(address => mapping(address => address)) public getPair;
address[] public allPairs;
```

இந்த மாறிகள் ஜோடிகளைக் கண்காணிக்கின்றன, இரண்டு டோக்கன் வகைகளுக்கு இடையேயான பரிமாற்றங்கள். முதலாவது, `getPair`, இரண்டு ERC-20 டோக்கன்கள் பரிமாறிக்கொள்ளும் ஒரு ஜோடி பரிமாற்ற ஒப்பந்தத்தை அடையாளம் காணும் ஒரு மேப்பிங் ஆகும். ERC-20 டோக்கன்கள் அவற்றைச் செயல்படுத்தும் ஒப்பந்தங்களின் முகவரிகளால் அடையாளம் காணப்படுகின்றன, எனவே விசைகள் மற்றும் மதிப்பு அனைத்தும் முகவரிகள்.

`tokenA` இலிருந்து `tokenB` ஆக மாற்ற அனுமதிக்கும் ஜோடி பரிமாற்றத்தின் முகவரியைப் பெற, நீங்கள் `getPair[<tokenA address>][<tokenB address>]` (அல்லது வேறு வழியில்) பயன்படுத்துகிறீர்கள். இரண்டாவது மாறி, `allPairs`, இந்தத் தொழிற்சாலையால் உருவாக்கப்பட்ட ஜோடி பரிமாற்றங்களின் அனைத்து முகவரிகளையும் உள்ளடக்கிய ஒரு வரிசை.

Ethereum இல் நீங்கள் ஒரு மேப்பிங்கின் உள்ளடக்கத்தில் மீண்டும் மீண்டும் செய்ய முடியாது, அல்லது அனைத்து விசைகளின் பட்டியலையும் பெற முடியாது, எனவே இந்த மாறி இந்தத் தொழிற்சாலை நிர்வகிக்கும் பரிமாற்றங்கள் எவை என்பதை அறிவதற்கான ஒரே வழி. குறிப்பு: நீங்கள் ஒரு மேப்பிங்கின் அனைத்து விசைகளிலும் மீண்டும் மீண்டும் செய்ய முடியாததற்குக் காரணம், ஒப்பந்தத் தரவுச் சேமிப்பகம் _விலை உயர்ந்தது_, எனவே நாங்கள் அதைக் குறைவாகப் பயன்படுத்தினால் நல்லது, மேலும் நாங்கள் அதை குறைவாக மாற்றினால் நல்லது. நீங்கள் [மீண்டும் மீண்டும் செய்வதை ஆதரிக்கும் மேப்பிங்குகளை](https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol) உருவாக்கலாம், ஆனால் அவற்றுக்கு விசைகளின் பட்டியலுக்கு கூடுதல் சேமிப்பகம் தேவை.

```solidity
பெரும்பாலான பயன்பாடுகளில் உங்களுக்கு அது தேவையில்லை.
```

```
event PairCreated(address indexed token0, address indexed token1, address pair, uint); ஒரு புதிய ஜோடி பரிமாற்றம் உருவாக்கப்படும்போது இந்த நிகழ்வு வெளியிடப்படுகிறது.
```

```solidity
இது டோக்கன்களின் முகவரிகள், ஜோடி பரிமாற்றத்தின் முகவரி மற்றும் தொழிற்சாலையால் நிர்வகிக்கப்படும் பரிமாற்றங்களின் மொத்த எண்ணிக்கை ஆகியவற்றை உள்ளடக்கியது.
```

```
constructor(address _feeToSetter) public {
    feeToSetter = _feeToSetter;
} கட்டமைப்பாளர் செய்யும் ஒரே விஷயம் `feeToSetter` ஐக் குறிப்பிடுவது.
```

```solidity
தொழிற்சாலைகள் கட்டணம் இல்லாமல் தொடங்குகின்றன, மேலும் `feeSetter` மட்டுமே அதை மாற்ற முடியும்.
```

```
function allPairsLength() external view returns (uint) {
    return allPairs.length;
}
```

```solidity
இந்தச் செயல்பாடு பரிமாற்ற ஜோடிகளின் எண்ணிக்கையைத் திருப்புகிறது.
```

```
function createPair(address tokenA, address tokenB) external returns (address pair) { இது தொழிற்சாலையின் முக்கியச் செயல்பாடு, இரண்டு ERC-20 டோக்கன்களுக்கு இடையில் ஒரு ஜோடி பரிமாற்றத்தை உருவாக்குவது. யார் வேண்டுமானாலும் இந்தச் செயல்பாட்டை அழைக்கலாம் என்பதைக் கவனியுங்கள்.
```

```solidity
ஒரு புதிய ஜோடி பரிமாற்றத்தை உருவாக்க உங்களுக்கு Uniswap இடமிருந்து அனுமதி தேவையில்லை.
```

```
    require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
    (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
```புதிய பரிமாற்றத்தின் முகவரி தீர்மானிக்கக்கூடியதாக இருக்க நாங்கள் விரும்புகிறோம், எனவே அதை ஆஃப்செயினில் முன்கூட்டியே கணக்கிடலாம் (இது [லேயர் 2 பரிவர்த்தனைகளுக்கு](/developers/docs/scaling/) பயனுள்ளதாக இருக்கும்).

```solidity
இதைச் செய்ய, டோக்கன் முகவரிகளின் வரிசையைப் பொருட்படுத்தாமல், நாங்கள் அவற்றைப் பெற்ற வரிசையைப் பொருட்படுத்தாமல், ஒரு நிலையான வரிசை தேவை, எனவே நாங்கள் அவற்றை இங்கே வரிசைப்படுத்துகிறோம்.
```

```
    require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
    require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient பெரிய பணப்புழக்க குளங்கள் சிறியவற்றை விட சிறந்தவை, ஏனெனில் அவை அதிக நிலையான விலைகளைக் கொண்டுள்ளன. ஒவ்வொரு ஜோடி டோக்கன்களுக்கும் ஒரு பணப்புழக்க குளத்திற்கு மேல் நாங்கள் விரும்பவில்லை.
```

```solidity
ஏற்கனவே ஒரு பரிமாற்றம் இருந்தால், அதே ஜோடிக்கு இன்னொன்றை உருவாக்கத் தேவையில்லை.
```

```
    bytes memory bytecode = type(UniswapV2Pair).creationCode; ஒரு புதிய ஒப்பந்தத்தை உருவாக்க, அதை உருவாக்கும் குறியீடு எங்களுக்குத் தேவை (கட்டமைப்பாளர் செயல்பாடு மற்றும் உண்மையான ஒப்பந்தத்தின் EVM பைட்கோடை நினைவகத்திற்கு எழுதும் குறியீடு இரண்டும்).
```பொதுவாக Solidity இல் நாங்கள் `addr = new <name of contract>(<constructor parameters>)` ஐப் பயன்படுத்துகிறோம், மேலும் கம்பைலர் எல்லாவற்றையும் எங்களுக்காக கவனித்துக்கொள்கிறது, ஆனால் ஒரு தீர்மானகரமான ஒப்பந்த முகவரியைக் கொண்டிருக்க, நாங்கள் [CREATE2 ஆப்கோடை](https://eips.ethereum.org/EIPS/eip-1014) பயன்படுத்த வேண்டும். இந்தக் குறியீடு எழுதப்பட்டபோது, அந்த ஆப்கோடை Solidity இன்னும் ஆதரிக்கவில்லை, எனவே குறியீட்டை கைமுறையாகப் பெறுவது அவசியமாக இருந்தது.

```solidity
இது இனி ஒரு பிரச்சனை இல்லை, ஏனெனில் [Solidity இப்போது CREATE2 ஐ ஆதரிக்கிறது](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2).
```

```
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    }
```

```solidity
ஒரு ஆப்கோடை Solidity இன்னும் ஆதரிக்காதபோது, நாங்கள் அதை [இன்லைன் அசெம்பிளி](https://docs.soliditylang.org/en/v0.8.3/assembly.html) ஐப் பயன்படுத்தி அழைக்கலாம்.
```

```
    IUniswapV2Pair(pair).initialize(token0, token1);
```

```solidity
புதிய பரிமாற்றம் எந்த இரண்டு டோக்கன்களைப் பரிமாறிக்கொள்கிறது என்பதைத் தெரிவிக்க `initialize` செயல்பாட்டை அழைக்கவும்.
```

```
    getPair[token0][token1] = pair;
    getPair[token1][token0] = pair; // populate mapping in the reverse direction
    allPairs.push(pair);
    emit PairCreated(token0, token1, pair, allPairs.length);
```

```solidity
புதிய ஜோடி தகவலை மாநில மாறிகளில் சேமித்து, புதிய ஜோடி பரிமாற்றம் குறித்து உலகிற்குத் தெரிவிக்க ஒரு நிகழ்வை வெளியிடவும்.
```

```
function setFeeTo(address _feeTo) external {
    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
    feeTo = _feeTo;
}

function setFeeToSetter(address _feeToSetter) external {
    require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
    feeToSetter = _feeToSetter;
}
```}

### இந்த இரண்டு செயல்பாடுகளும் `feeSetter` கட்டணப் பெறுநரைக் கட்டுப்படுத்தவும் (ஏதேனும் இருந்தால்), மேலும் `feeSetter` ஐ ஒரு புதிய முகவரிக்கு மாற்றவும் அனுமதிக்கின்றன.

UniswapV2ERC20.sol {#UniswapV2ERC20} [இந்த ஒப்பந்தம்](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol) ERC-20 பணப்புழக்க டோக்கனைச் செயல்படுத்துகிறது.

இது [OpenZeppelin ERC-20 ஒப்பந்தத்தைப்](/developers/tutorials/erc20-annotated-code) போன்றது, எனவே நான் வேறுபட்ட பகுதியை மட்டுமே விளக்குவேன், `permit` செயல்பாடு. Ethereum இல் பரிவர்த்தனைகளுக்கு ஈதர் (ETH) செலவாகும், இது உண்மையான பணத்திற்குச் சமம். உங்களிடம் ERC-20 டோக்கன்கள் இருந்தாலும் ETH இல்லை என்றால், நீங்கள் பரிவர்த்தனைகளை அனுப்ப முடியாது, எனவே நீங்கள் அவற்றுடன் எதுவும் செய்ய முடியாது.
இந்த சிக்கலைத் தவிர்க்க ஒரு தீர்வு [மெட்டா-பரிவர்த்தனைகள்](https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/supporting-meta-transactions). டோக்கன்களின் உரிமையாளர் ஒரு பரிவர்த்தனையில் கையொப்பமிடுகிறார், அது வேறு ஒருவரை ஆஃப்செயினில் டோக்கன்களைத் திரும்பப் பெற அனுமதிக்கிறது, மேலும் அதை இணையம் மூலம் பெறுநருக்கு அனுப்புகிறார்.

```solidity
ETH ஐ வைத்திருக்கும் பெறுநர், பின்னர் உரிமையாளர் சார்பாக அனுமதியைச் சமர்ப்பிக்கிறார்.
```

```
bytes32 public DOMAIN_SEPARATOR;
// keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; இந்த ஹாஷ் [பரிவர்த்தனை வகைக்கான அடையாளங்காட்டி](https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash).
```

```solidity
நாங்கள் இங்கு ஆதரிப்பது `Permit` மட்டுமே, இந்த அளவுருக்களுடன்.
```

```
mapping(address => uint) public nonces; ஒரு பெறுநர் டிஜிட்டல் கையொப்பத்தைப் போலியாக உருவாக்குவது சாத்தியமற்றது. இருப்பினும், அதே பரிவர்த்தனையை இருமுறை அனுப்புவது அற்பமானது (இது [மறுதாக்குதல்](https://wikipedia.org/wiki/Replay_attack) ஒரு வடிவமாகும்). இதைத் தடுக்க, நாங்கள் ஒரு [நான்ஸ்](https://wikipedia.org/wiki/Cryptographic_nonce) ஐப் பயன்படுத்துகிறோம்.
```

```solidity
ஒரு புதிய `Permit` இன் நான்ஸ் கடைசியாகப் பயன்படுத்தப்பட்டதை விட ஒன்று அதிகமாக இல்லை என்றால், அது செல்லாதது என்று நாங்கள் கருதுகிறோம்.
```

```
constructor() public {
    uint chainId;
    assembly {
        chainId := chainid
    } இது [சங்கிலி அடையாளங்காட்டியை](https://chainid.network/) மீட்டெடுப்பதற்கான குறியீடு. இது [Yul](https://docs.soliditylang.org/en/v0.8.4/yul.html) எனப்படும் ஒரு EVM அசெம்பிளி பேச்சுவழக்கைப் பயன்படுத்துகிறது.
```

```solidity
Yul இன் தற்போதைய பதிப்பில் நீங்கள் `chainid()` ஐப் பயன்படுத்த வேண்டும், `chainid` அல்ல என்பதைக் கவனியுங்கள்.
```

```
    DOMAIN_SEPARATOR = keccak256(
        abi.encode(
            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
            keccak256(bytes(name)),
            keccak256(bytes('1')),
            chainId,
            address(this)
        )
    );
}
```

```solidity
EIP-712 க்கான [டொமைன் பிரிப்பானைக்](https://eips.ethereum.org/EIPS/eip-712#rationale-for-domainseparator) கணக்கிடவும்.
```

```
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external { இது அனுமதிகளைச் செயல்படுத்தும் செயல்பாடு.
```

```solidity
இது அளவுருக்களாக பொருத்தமான புலங்களையும், [கையொப்பத்திற்கான](https://yos.io/2018/11/16/ethereum-signatures/) மூன்று ஸ்கேலார் மதிப்புகளையும் (v, r, மற்றும் s) பெறுகிறது.
```

```
    require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
```

```solidity
காலக்கெடுவிற்குப் பிறகு பரிவர்த்தனைகளை ஏற்க வேண்டாம்.
```

```
    bytes32 digest = keccak256(
        abi.encodePacked(
            '\x19\x01',
            DOMAIN_SEPARATOR,
            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
        )
    ); `abi.encodePacked(...)` என்பது நாங்கள் பெற எதிர்பார்க்கும் செய்தி.
```

நான்ஸ் என்னவாக இருக்க வேண்டும் என்பது எங்களுக்குத் தெரியும், எனவே அதை ஒரு அளவுருவாகப் பெற எங்களுக்குத் தேவையில்லை.

```solidity
Ethereum கையொப்ப வழிமுறை கையொப்பமிட 256 பிட்களைப் பெறும் என்று எதிர்பார்க்கிறது, எனவே நாங்கள் `keccak256` ஹாஷ் செயல்பாட்டைப் பயன்படுத்துகிறோம்.
```

```
    address recoveredAddress = ecrecover(digest, v, r, s);
```

```solidity
டைஜஸ்ட் மற்றும் கையொப்பத்திலிருந்து, [ecrecover](https://coders-errand.com/ecrecover-signature-verification-ethereum/) ஐப் பயன்படுத்தி கையொப்பமிட்ட முகவரியைப் பெறலாம்.
```

```
    require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
    _approve(owner, spender, value);
}
```

## எல்லாம் சரியாக இருந்தால், இதை [ஒரு ERC-20 approve](https://eips.ethereum.org/EIPS/eip-20#approve) ஆகக் கருதவும்.

புற ஒப்பந்தங்கள் {#periphery-contracts} புற ஒப்பந்தங்கள் Uniswap க்கான API (பயன்பாட்டு நிரல் இடைமுகம்) ஆகும். அவை வெளிப்புற அழைப்புகளுக்குக் கிடைக்கின்றன, மற்ற ஒப்பந்தங்களிலிருந்து அல்லது பரவலாக்கப்பட்ட பயன்பாடுகளிலிருந்து. நீங்கள் முக்கிய ஒப்பந்தங்களை நேரடியாக அழைக்கலாம், ஆனால் அது மிகவும் சிக்கலானது, மேலும் நீங்கள் தவறு செய்தால் மதிப்பை இழக்க நேரிடும். முக்கிய ஒப்பந்தங்கள் அவை ஏமாற்றப்படவில்லை என்பதை உறுதிப்படுத்த சோதனைகளை மட்டுமே கொண்டிருக்கின்றன, வேறு யாருக்கும் நல்ல சோதனைகள் அல்ல.

### அவை புறத்தில் உள்ளன, எனவே தேவைக்கேற்ப அவற்றைப் புதுப்பிக்கலாம்.

UniswapV2Router01.sol {#UniswapV2Router01} [இந்த ஒப்பந்தத்தில்](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol) சிக்கல்கள் உள்ளன, மேலும் [இனி பயன்படுத்தக்கூடாது](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01).

### அதிர்ஷ்டவசமாக, புற ஒப்பந்தங்கள் நிலையற்றவை மற்றும் எந்தச் சொத்துக்களையும் கொண்டிருக்கவில்லை, எனவே அதை நீக்குவது எளிது மற்றும் அதற்குப் பதிலாக மாற்று, `UniswapV2Router02` ஐப் பயன்படுத்த மக்களைப் பரிந்துரைப்பது எளிது.

UniswapV2Router02.sol {#UniswapV2Router02}
பெரும்பாலான சந்தர்ப்பங்களில் நீங்கள் [இந்த ஒப்பந்தத்தின்](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol) மூலம் Uniswap ஐப் பயன்படுத்துவீர்கள்.

```solidity
அதை எவ்வாறு பயன்படுத்துவது என்பதை [இங்கே](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02) பார்க்கலாம்.
```

pragma solidity =0.6.6;import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';
import '@uniswap/lib/contracts/libraries/TransferHelper.sol';import './interfaces/IUniswapV2Router02.sol';
import './libraries/UniswapV2Library.sol';
import './libraries/SafeMath.sol';
import './interfaces/IERC20.sol';
import './interfaces/IWETH.sol'; இவற்றில் பெரும்பாலானவற்றை நாங்கள் முன்பு சந்தித்தோம், அல்லது மிகவும் வெளிப்படையானவை. ஒரே விதிவிலக்கு `IWETH.sol`. Uniswap v2 எந்த ஜோடி ERC-20 டோக்கன்களுக்கும் பரிமாற்றங்களை அனுமதிக்கிறது, ஆனால் ஈதர் (ETH) ஒரு ERC-20 டோக்கன் அல்ல. இது தரநிலைக்கு முந்தியது மற்றும் தனித்துவமான வழிமுறைகளால் மாற்றப்படுகிறது. ERC-20 டோக்கன்களுக்குப் பொருந்தும் ஒப்பந்தங்களில் ETH ஐப் பயன்படுத்த மக்கள் [சுற்றப்பட்ட ஈதர் (WETH)](https://weth.tkn.eth.limo/) ஒப்பந்தத்துடன் வந்தனர். நீங்கள் இந்த ஒப்பந்தத்திற்கு ETH அனுப்புகிறீர்கள், மேலும் அது உங்களுக்கு சமமான அளவு WETH ஐ உருவாக்குகிறது.

```solidity
அல்லது நீங்கள் WETH ஐ எரிக்கலாம், மேலும் ETH ஐத் திரும்பப் பெறலாம்.
```

contract UniswapV2Router02 is IUniswapV2Router02 {
using SafeMath for uint;```
address public immutable override factory;
address public immutable override WETH; ரவுட்டர் எந்த தொழிற்சாலையைப் பயன்படுத்த வேண்டும், மற்றும் WETH தேவைப்படும் பரிவர்த்தனைகளுக்கு எந்த WETH ஒப்பந்தத்தைப் பயன்படுத்த வேண்டும் என்பதைத் தெரிந்து கொள்ள வேண்டும். இந்த மதிப்புகள் [மாற்ற முடியாதவை](https://docs.soliditylang.org/en/v0.8.3/contracts.html#constant-and-immutable-state-variables), அதாவது அவை கட்டமைப்பாளரில் மட்டுமே அமைக்கப்பட முடியும்.
```

```solidity
யாரும் அவற்றை குறைவான நேர்மையான ஒப்பந்தங்களுக்கு மாற்றுவதற்கு மாற்ற முடியாது என்ற நம்பிக்கையை இது பயனர்களுக்கு அளிக்கிறது.
```

```
modifier ensure(uint deadline) {
    require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
    _;
}
```

```solidity
இந்த மாற்றி நேர வரையறுக்கப்பட்ட பரிவர்த்தனைகள் ("Y நேரத்திற்கு முன்பு X ஐச் செய்யவும்") அவற்றின் நேர வரம்பிற்குப் பிறகு நடக்காது என்பதை உறுதி செய்கிறது.
```

```
constructor(address _factory, address _WETH) public {
    factory = _factory;
    WETH = _WETH;
}
```

```solidity
கட்டமைப்பாளர் மாறாத மாநில மாறிகளை மட்டுமே அமைக்கிறது.
```

```
receive() external payable {
    assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
} WETH ஒப்பந்தத்திலிருந்து டோக்கன்களை மீண்டும் ETH ஆக மீட்கும் போது இந்தச் செயல்பாடு அழைக்கப்படுகிறது.
```

#### நாங்கள் பயன்படுத்தும் WETH ஒப்பந்தம் மட்டுமே அதைச் செய்ய அங்கீகரிக்கப்பட்டுள்ளது.

பணப்புழக்கத்தைச் சேர்க்கவும் {#add-liquidity}

```solidity
இந்தச் செயல்பாடுகள் ஜோடி பரிமாற்றத்திற்கு டோக்கன்களைச் சேர்க்கின்றன, இது பணப்புழக்கக் குளத்தை அதிகரிக்கிறது.
```

```
// **** ADD LIQUIDITY ****
function _addLiquidity(
```

```solidity
இந்தச் செயல்பாடு ஜோடி பரிமாற்றத்தில் டெபாசிட் செய்யப்பட வேண்டிய A மற்றும் B டோக்கன்களின் அளவைக் கணக்கிடப் பயன்படுகிறது.
```

```
    address tokenA,
    address tokenB,
```

```solidity
இவை ERC-20 டோக்கன் ஒப்பந்தங்களின் முகவரிகள்.
```

```
    uint amountADesired,
    uint amountBDesired, இவை பணப்புழக்க வழங்குநர் டெபாசிட் செய்ய விரும்பும் அளவுகள்.
```

```solidity
அவை டெபாசிட் செய்யப்பட வேண்டிய A மற்றும் B இன் அதிகபட்ச அளவுகளும் ஆகும்.
```

```
    uint amountAMin,
    uint amountBMin இவை டெபாசிட் செய்ய ஏற்றுக்கொள்ளக்கூடிய குறைந்தபட்ச அளவுகள். இந்த அளவுகள் அல்லது அதற்கு மேற்பட்டவற்றுடன் பரிவர்த்தனை நடக்கவில்லை என்றால், அதிலிருந்து திரும்பப் பெறவும்.
```

இந்த அம்சத்தை நீங்கள் விரும்பவில்லை என்றால், பூஜ்ஜியத்தைக் குறிப்பிடவும். பணப்புழக்க வழங்குநர்கள் பொதுவாக ஒரு குறைந்தபட்சத்தைக் குறிப்பிடுகிறார்கள், ஏனெனில் அவர்கள் பரிவர்த்தனையை தற்போதைய பரிமாற்ற விகிதத்திற்கு நெருக்கமான பரிமாற்ற விகிதத்திற்கு வரம்பிட விரும்புகிறார்கள்.

பரிமாற்ற விகிதம் அதிகமாக ஏற்ற இறக்கமாக இருந்தால், அது அடிப்படை மதிப்புகளை மாற்றும் செய்திகள் என்று அர்த்தம், மேலும் அவர்கள் கைமுறையாக என்ன செய்வது என்பதைத் தீர்மானிக்க விரும்புகிறார்கள்.

| அளவுரு             | மதிப்பு |
| ------------------ | ------: |
| விரும்பிய அளவு A   |    1000 |
| விரும்பிய அளவு B   |    1000 |
| குறைந்தபட்ச அளவு A |     900 |
| குறைந்தபட்ச அளவு B |     800 |

பரிமாற்ற விகிதம் 0.9 மற்றும் 1.25 க்கு இடையில் இருக்கும் வரை, பரிவர்த்தனை நடைபெறுகிறது. பரிமாற்ற விகிதம் அந்த வரம்பிற்கு வெளியே சென்றால், பரிவர்த்தனை ரத்து செய்யப்படுகிறது.

இந்த முன்னெச்சரிக்கைக்குக் காரணம், பரிவர்த்தனைகள் உடனடியாக நடப்பதில்லை, நீங்கள் அவற்றைச் சமர்ப்பிக்கிறீர்கள், இறுதியில் ஒரு சரிபார்ப்பவர் அவற்றை ஒரு தொகுதியில் சேர்ப்பார் (உங்கள் கேஸ் விலை மிகவும் குறைவாக இல்லாவிட்டால், அந்த நிலையில் நீங்கள் அதே நான்ஸ் மற்றும் அதிக கேஸ் விலையுடன் மற்றொரு பரிவர்த்தனையைச் சமர்ப்பிக்க வேண்டும், அதை மேலெழுத). சமர்ப்பிப்பதற்கும் சேர்ப்பதற்கும் இடையேயான இடைவெளியில் என்ன நடக்கிறது என்பதைக் கட்டுப்படுத்த முடியாது.

```solidity
    ) internal virtual returns (uint amountA, uint amountB) {
```

இந்தச் செயல்பாடு தற்போதைய இருப்புக்களுக்கு இடையேயான விகிதத்திற்கு சமமான விகிதத்தைக் கொண்டிருக்க பணப்புழக்க வழங்குநர் டெபாசிட் செய்ய வேண்டிய அளவுகளைத் திருப்புகிறது.

```solidity
        // create the pair if it doesn't exist yet
        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
            IUniswapV2Factory(factory).createPair(tokenA, tokenB);
        }
```

இந்த டோக்கன் ஜோடிக்கு இன்னும் பரிமாற்றம் இல்லை என்றால், அதை உருவாக்கவும்.

```solidity
        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
```

ஜோடியில் உள்ள தற்போதைய இருப்புகளைப் பெறவும்.

```solidity
        if (reserveA == 0 && reserveB == 0) {
            (amountA, amountB) = (amountADesired, amountBDesired);
```

தற்போதைய இருப்புகள் காலியாக இருந்தால், இது ஒரு புதிய ஜோடி பரிமாற்றம். டெபாசிட் செய்யப்பட வேண்டிய அளவுகள் பணப்புழக்க வழங்குநர் வழங்க விரும்பும் அளவுகளுக்குச் சமமாக இருக்க வேண்டும்.

```solidity
        } else {
            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
```

என்ன அளவுகள் இருக்கும் என்பதை நாங்கள் பார்க்க வேண்டுமானால், [இந்தச் செயல்பாட்டை](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol#L35)ப் பயன்படுத்தி உகந்த அளவைப் பெறுகிறோம். தற்போதைய இருப்புக்களுக்கு சமமான விகிதத்தை நாங்கள் விரும்புகிறோம்.

```solidity
            if (amountBOptimal <= amountBDesired) {
                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
                (amountA, amountB) = (amountADesired, amountBOptimal);
```

`amountBOptimal` பணப்புழக்க வழங்குநர் டெபாசிட் செய்ய விரும்பும் அளவை விடச் சிறியதாக இருந்தால், டோக்கன் B தற்போது பணப்புழக்க டெபாசிட்டர் நினைப்பதை விட அதிக மதிப்புடையது என்று அர்த்தம், எனவே ஒரு சிறிய அளவு தேவைப்படுகிறது.

```solidity
            } else {
                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
                assert(amountAOptimal <= amountADesired);
                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
                (amountA, amountB) = (amountAOptimal, amountBDesired);
```

உகந்த B அளவு விரும்பிய B அளவை விட அதிகமாக இருந்தால், B டோக்கன்கள் தற்போது பணப்புழக்க டெபாசிட்டர் நினைப்பதை விட குறைவான மதிப்புடையவை என்று அர்த்தம், எனவே அதிக அளவு தேவைப்படுகிறது. இருப்பினும், விரும்பிய அளவு ஒரு அதிகபட்சம், எனவே நாங்கள் அதைச் செய்ய முடியாது. அதற்கு பதிலாக, விரும்பிய அளவு B டோக்கன்களுக்கு உகந்த அளவு A டோக்கன்களை நாங்கள் கணக்கிடுகிறோம்.

அனைத்தையும் ஒன்றாக வைத்தால் இந்தக் வரைபடத்தைப் பெறுகிறோம். நீங்கள் ஆயிரம் A டோக்கன்களையும் (நீல கோடு) மற்றும் ஆயிரம் B டோக்கன்களையும் (சிவப்பு கோடு) டெபாசிட் செய்ய முயற்சிக்கிறீர்கள் என்று வைத்துக் கொள்ளுங்கள். x அச்சு பரிமாற்ற விகிதம், A/B. x=1 என்றால், அவை சமமான மதிப்பில் உள்ளன, மேலும் நீங்கள் ஒவ்வொன்றிலும் ஆயிரத்தை டெபாசிட் செய்கிறீர்கள். x=2 என்றால், A B ஐ விட இரு மடங்கு மதிப்புடையது (நீங்கள் ஒவ்வொரு A டோக்கனுக்கும் இரண்டு B டோக்கன்களைப் பெறுகிறீர்கள்) எனவே நீங்கள் ஆயிரம் B டோக்கன்களை டெபாசிட் செய்கிறீர்கள், ஆனால் 500 A டோக்கன்கள் மட்டுமே. x=0.5 என்றால், நிலைமை தலைகீழாக உள்ளது, ஆயிரம் A டோக்கன்கள் மற்றும் ஐநூறு B டோக்கன்கள்.

![வரைபடம்](liquidityProviderDeposit.png)

நீங்கள் பணப்புழக்கத்தை நேரடியாக முக்கிய ஒப்பந்தத்தில் டெபாசிட் செய்யலாம் (பயன்படுத்தி [UniswapV2Pair::mint](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol#L110)), ஆனால் முக்கிய ஒப்பந்தம் அது ஏமாற்றப்படவில்லை என்பதை மட்டுமே சரிபார்க்கிறது, எனவே நீங்கள் உங்கள் பரிவர்த்தனையைச் சமர்ப்பிக்கும் நேரத்திற்கும் அது செயல்படுத்தப்படும் நேரத்திற்கும் இடையில் பரிமாற்ற விகிதம் மாறினால் மதிப்பை இழக்கும் அபாயம் உள்ளது. நீங்கள் புற ஒப்பந்தத்தைப் பயன்படுத்தினால், அது நீங்கள் டெபாசிட் செய்ய வேண்டிய அளவைக் கண்டுபிடித்து உடனடியாக டெபாசிட் செய்கிறது, எனவே பரிமாற்ற விகிதம் மாறாது, நீங்கள் எதையும் இழக்க மாட்டீர்கள்.

```solidity
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
```

இந்தச் செயல்பாடு ஒரு பரிவர்த்தனையால் பணப்புழக்கத்தை டெபாசிட் செய்ய அழைக்கப்படலாம். மேலே உள்ள `_addLiquidity` இல் உள்ள பெரும்பாலான அளவுருக்கள் ஒரே மாதிரியானவை, இரண்டு விதிவிலக்குகள் தவிர:

. `to` என்பது பணப்புழக்க வழங்குநரின் குளத்தின் பங்கைக் காட்ட உருவாக்கப்பட்ட புதிய பணப்புழக்க டோக்கன்களைப் பெறும் முகவரி
. `deadline` என்பது பரிவர்த்தனைக்கான நேர வரம்பு

```solidity
    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
```

உண்மையில் டெபாசிட் செய்ய வேண்டிய அளவுகளை நாங்கள் கணக்கிட்டு, பின்னர் பணப்புழக்கக் குளத்தின் முகவரியைக் கண்டுபிடிக்கிறோம். கேஸைச் சேமிக்க, நாங்கள் தொழிற்சாலையைக் கேட்பதன் மூலம் இதைச் செய்யவில்லை, ஆனால் நூலகச் செயல்பாடு `pairFor` ஐப் பயன்படுத்துகிறோம் (நூலகங்களில் கீழே பார்க்கவும்)

```solidity
        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
```

சரியான அளவு டோக்கன்களை பயனரிடமிருந்து ஜோடி பரிமாற்றத்திற்கு மாற்றவும்.

```solidity
        liquidity = IUniswapV2Pair(pair).mint(to);
    }
```

அதற்குப் பதிலாக, குளத்தின் பகுதி உரிமையாளராக பணப்புழக்க டோக்கன்களை `to` முகவரிக்குக் கொடுங்கள். முக்கிய ஒப்பந்தத்தின் `mint` செயல்பாடு, அது எவ்வளவு கூடுதல் டோக்கன்களைக் கொண்டுள்ளது என்பதைப் பார்க்கிறது (கடைசியாகப் பணப்புழக்கம் மாறியதை ஒப்பிடும்போது) மற்றும் அதற்கேற்ப பணப்புழக்கத்தை உருவாக்குகிறது.

```solidity
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
```

ஒரு பணப்புழக்க வழங்குநர் ஒரு டோக்கன்/ETH ஜோடி பரிமாற்றத்திற்கு பணப்புழக்கத்தை வழங்க விரும்பும்போது, சில வேறுபாடுகள் உள்ளன. ஒப்பந்தம் பணப்புழக்க வழங்குநருக்கான ETH ஐச் சுற்றிக் கையாளுகிறது. பயனர் எவ்வளவு ETH டெபாசிட் செய்ய விரும்புகிறார் என்பதைக் குறிப்பிடத் தேவையில்லை, ஏனெனில் பயனர் அவற்றை பரிவர்த்தனையுடன் அனுப்புகிறார் (தொகை `msg.value` இல் கிடைக்கிறது).

```solidity
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
        (amountToken, amountETH) = _addLiquidity(
            token,
            WETH,
            amountTokenDesired,
            msg.value,
            amountTokenMin,
            amountETHMin
        );
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
        IWETH(WETH).deposit{value: amountETH}();
        assert(IWETH(WETH).transfer(pair, amountETH));
```

ETH ஐ டெபாசிட் செய்ய, ஒப்பந்தம் முதலில் அதை WETH ஆகச் சுற்றி, பின்னர் WETH ஐ ஜோடிக்கு மாற்றுகிறது. மாற்றம் ஒரு `assert` இல் சுற்றப்பட்டுள்ளது என்பதைக் கவனியுங்கள். இதன் பொருள், மாற்றம் தோல்வியடைந்தால் இந்த ஒப்பந்த அழைப்பும் தோல்வியடைகிறது, எனவே சுற்றிக்கொள்ளுதல் உண்மையில் நடக்காது.

```solidity
        liquidity = IUniswapV2Pair(pair).mint(to);
        // refund dust eth, if any
        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
    }
```

பயனர் ஏற்கனவே எங்களுக்கு ETH ஐ அனுப்பியுள்ளார், எனவே ஏதேனும் கூடுதல் மீதம் இருந்தால் (மற்ற டோக்கன் பயனர் நினைத்ததை விட குறைவான மதிப்புடையது என்பதால்), நாங்கள் ஒரு பணத்தைத் திரும்ப வழங்க வேண்டும்.

#### பணப்புழக்கத்தை அகற்றவும் {#remove-liquidity}

இந்தச் செயல்பாடுகள் பணப்புழக்கத்தை அகற்றி, பணப்புழக்க வழங்குநருக்குத் திருப்பிச் செலுத்தும்.

```solidity
    // **** REMOVE LIQUIDITY ****
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {
```

பணப்புழக்கத்தை அகற்றுவதற்கான எளிய வழக்கு. பணப்புழக்க வழங்குநர் ஒவ்வொரு டோக்கனுக்கும் குறைந்தபட்ச தொகையை ஏற்க ஒப்புக்கொள்கிறார், மேலும் அது காலக்கெடுவிற்கு முன்பு நடக்க வேண்டும்.

```solidity
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
```

முக்கிய ஒப்பந்தத்தின் `burn` செயல்பாடு பயனருக்கு டோக்கன்களைத் திருப்பிச் செலுத்துவதைக் கையாளுகிறது.

```solidity
        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
```

ஒரு செயல்பாடு பல மதிப்புகளைத் திருப்பும்போது, ஆனால் நாங்கள் அவற்றில் சிலவற்றில் மட்டுமே ஆர்வமாக உள்ளோம் என்றால், அந்த மதிப்புகளை மட்டுமே நாங்கள் இப்படிப் பெறுகிறோம். ஒரு மதிப்பை வாசித்து, அதை ஒருபோதும் பயன்படுத்தாமல் இருப்பதை விட இது கேஸ் அடிப்படையில் சற்றே மலிவானது.

```solidity
        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
```

முக்கிய ஒப்பந்தம் அவற்றைத் திருப்பும் வழியிலிருந்து (குறைந்த முகவரி டோக்கன் முதலில்) பயனர் அவற்றை எதிர்பார்க்கும் வழியில் (tokenA மற்றும் tokenB க்கு ஒத்ததாக) அளவுகளை மொழிபெயர்க்கவும்.

```solidity
        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
    }
```

முதலில் மாற்றத்தைச் செய்து, பின்னர் அது சட்டப்பூர்வமானது என்பதை சரிபார்ப்பது சரி, ஏனெனில் அது இல்லை என்றால், நாங்கள் அனைத்து மாநில மாற்றங்களிலிருந்தும் திரும்பப் பெறுவோம்.

```solidity
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {
        (amountToken, amountETH) = removeLiquidity(
            token,
            WETH,
            liquidity,
            amountTokenMin,
            amountETHMin,
            address(this),
            deadline
        );
        TransferHelper.safeTransfer(token, to, amountToken);
        IWETH(WETH).withdraw(amountETH);
        TransferHelper.safeTransferETH(to, amountETH);
    }
```

ETH க்கான பணப்புழக்கத்தை அகற்றுவது கிட்டத்தட்ட ஒரே மாதிரியானது, நாங்கள் WETH டோக்கன்களைப் பெற்று, பின்னர் அவற்றை பணப்புழக்க வழங்குநருக்குத் திருப்பித் தருவதற்காக ETH க்காக மீட்கிறோம்.

```solidity
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountA, uint amountB) {
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);
    }


    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountToken, uint amountETH) {
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);
    }
```

இந்தச் செயல்பாடுகள் மெட்டா-பரிவர்த்தனைகளை அனுப்புகின்றன, ஈதர் இல்லாத பயனர்கள் குளத்திலிருந்து திரும்பப் பெற அனுமதிக்கின்றன, [அனுமதி பொறிமுறையைப்](#UniswapV2ERC20) பயன்படுத்தி.

```solidity

    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountETH) {
        (, amountETH) = removeLiquidity(
            token,
            WETH,
            liquidity,
            amountTokenMin,
            amountETHMin,
            address(this),
            deadline
        );
        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
        IWETH(WETH).withdraw(amountETH);
        TransferHelper.safeTransferETH(to, amountETH);
    }

```

இந்தச் செயல்பாடு பரிமாற்ற அல்லது சேமிப்புக் கட்டணங்களைக் கொண்ட டோக்கன்களுக்குப் பயன்படுத்தப்படலாம். ஒரு டோக்கனுக்கு அத்தகைய கட்டணங்கள் இருக்கும்போது, டோக்கனில் எவ்வளவு திரும்பப் பெறுகிறோம் என்பதை எங்களுக்குத் தெரிவிக்க `removeLiquidity` செயல்பாட்டை நாங்கள் நம்ப முடியாது, எனவே நாங்கள் முதலில் திரும்பப் பெற வேண்டும், பின்னர் இருப்பைப் பெற வேண்டும்.

```solidity


    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external virtual override returns (uint amountETH) {
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(
            token, liquidity, amountTokenMin, amountETHMin, to, deadline
        );
    }
```

இறுதிச் செயல்பாடு, சேமிப்புக் கட்டணங்களை மெட்டா-பரிவர்த்தனைகளுடன் இணைக்கிறது.

#### வர்த்தகம் {#trade}

```solidity
    // **** இடமாற்று ****
    // முதல் ஜோடிக்கு ஆரம்பத் தொகை ஏற்கெனவே அனுப்பப்பட்டிருக்க வேண்டும்
    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {
```

வர்த்தகர்களுக்கு வழங்கப்படும் செயல்பாடுகளுக்குத் தேவையான உள்செயலாக்கத்தை இந்தச் செயல்பாடு செய்கிறது.

```solidity
        for (uint i; i < path.length - 1; i++) {
```

இதை நான் எழுதும்போது [388,160 ERC-20 டோக்கன்கள்](https://eth.blockscout.com/tokens) உள்ளன. ஒவ்வொரு டோக்கன் ஜோடிக்கும் ஒரு ஜோடி பரிமாற்றம் இருந்திருந்தால், அது 150 பில்லியனுக்கும் அதிகமான ஜோடி பரிமாற்றங்களாக இருந்திருக்கும். முழுச் சங்கிலியும், தற்போதைக்கு, [அந்த எண்ணிக்கையில் 0.1% கணக்குகளை மட்டுமே கொண்டுள்ளது](https://eth.blockscout.com/stats/accountsGrowth). அதற்குப் பதிலாக, இடமாற்றுச் செயல்பாடுகள் ஒரு பாதை என்ற கருத்தை ஆதரிக்கின்றன. ஒரு வர்த்தகர் A-ஐ B-க்காகவும், B-ஐ C-க்காகவும், C-ஐ D-க்காகவும் பரிமாறிக்கொள்ளலாம், எனவே நேரடியான A-D ஜோடிப் பரிமாற்றத்திற்குத் தேவையில்லை.

இந்தச் சந்தைகளில் உள்ள விலைகள் ஒத்திசைக்கப்படுகின்றன, ஏனெனில் அவை ஒத்திசைவில் இல்லாதபோது அது நடுவர் ஆதாயத்திற்கான வாய்ப்பை உருவாக்குகிறது. உதாரணமாக, A, B, மற்றும் C ஆகிய மூன்று டோக்கன்களைக் கற்பனை செய்து கொள்ளுங்கள். மூன்று ஜோடி பரிமாற்றங்கள் உள்ளன, ஒவ்வொரு ஜோடிக்கும் ஒன்று.

1. ஆரம்ப நிலைமை
2. ஒரு வர்த்தகர் 24.695 A டோக்கன்களை விற்று 25.305 B டோக்கன்களைப் பெறுகிறார்.
3. வர்த்தகர் 24.695 B டோக்கன்களை 25.305 C டோக்கன்களுக்கு விற்று, தோராயமாக 0.61 B டோக்கன்களை லாபமாக வைத்துக்கொள்கிறார்.
4. பின்னர் வர்த்தகர் 24.695 C டோக்கன்களை 25.305 A டோக்கன்களுக்கு விற்று, தோராயமாக 0.61 C டோக்கன்களை லாபமாக வைத்துக்கொள்கிறார். வர்த்தகரிடம் 0.61 கூடுதல் A டோக்கன்களும் உள்ளன (வர்த்தகர் இறுதியில் பெற்ற 25.305-லிருந்து அசல் முதலீடான 24.695-ஐக் கழித்தால் கிடைப்பது).

| படி | A-B பரிமாற்றம்                                                                              | B-C பரிமாற்றம்                                                                              | A-C பரிமாற்றம்                                                                              |
| --- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| 1   | A:1000 B:1050 A/B=1.05                      | B:1000 C:1050 B/C=1.05                      | A:1050 C:1000 C/A=1.05                      |
| 2   | A:1024.695 B:1024.695 A/B=1 | B:1000 C:1050 B/C=1.05                      | A:1050 C:1000 C/A=1.05                      |
| 3   | A:1024.695 B:1024.695 A/B=1 | B:1024.695 C:1024.695 B/C=1 | A:1050 C:1000 C/A=1.05                      |
| 4   | A:1024.695 B:1024.695 A/B=1 | B:1024.695 C:1024.695 B/C=1 | A:1024.695 C:1024.695 C/A=1 |

```solidity
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            uint amountOut = amounts[i + 1];
```

நாம் தற்போது கையாளும் ஜோடியைப் பெற்று, அதை வரிசைப்படுத்தி (ஜோடியுடன் பயன்படுத்த) எதிர்பார்க்கப்படும் வெளியீட்டுத் தொகையைப் பெறுங்கள்.

```solidity
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
```

ஜோடிப் பரிமாற்றம் எதிர்பார்க்கும் விதத்தில் வரிசைப்படுத்தப்பட்ட, எதிர்பார்க்கப்படும் வெளிவரும் தொகைகளைப் பெறுங்கள்.

```solidity
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
```

இது கடைசிப் பரிமாற்றமா? அப்படியானால், வர்த்தகத்திற்காகப் பெறப்பட்ட டோக்கன்களை இலக்குக்கு அனுப்புங்கள். இல்லையெனில், அதை அடுத்த ஜோடி பரிமாற்றத்திற்கு அனுப்புங்கள்.

```solidity

            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
                amount0Out, amount1Out, to, new bytes(0)
            );
        }
    }
```

டோக்கன்களை இடமாற்ற, ஜோடிப் பரிமாற்றத்தை உண்மையில் அழையுங்கள். பரிமாற்றத்தைப் பற்றி அறிவிக்க எங்களுக்கு ஒரு கால்பேக் தேவையில்லை, எனவே அந்தப் புலத்தில் நாங்கள் எந்த பைட்டுகளையும் அனுப்புவதில்லை.

```solidity
    function swapExactTokensForTokens(
```

ஒரு டோக்கனை மற்றொன்றுக்கு இடமாற்ற, இந்தச் செயல்பாடு வர்த்தகர்களால் நேரடியாகப் பயன்படுத்தப்படுகிறது.

```solidity
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
```

இந்த அளவுரு ERC-20 ஒப்பந்தங்களின் முகவரிகளைக் கொண்டுள்ளது. மேலே விளக்கியபடி, இது ஒரு வரிசை ஆகும். ஏனெனில் உங்களிடம் உள்ள சொத்திலிருந்து நீங்கள் விரும்பும் சொத்தைப் பெற, நீங்கள் பல ஜோடிப் பரிமாற்றங்கள் வழியாகச் செல்ல வேண்டியிருக்கலாம்.

Solidity-இல் ஒரு செயல்பாட்டு அளவுரு `memory` அல்லது `calldata`-வில் சேமிக்கப்படலாம். செயல்பாடு ஒப்பந்தத்திற்கான ஒரு நுழைவுப் புள்ளியாக இருந்து, ஒரு பயனரிடமிருந்து (ஒரு பரிவர்த்தனையைப் பயன்படுத்தி) அல்லது வேறு ஒப்பந்தத்திலிருந்து நேரடியாக அழைக்கப்பட்டால், அப்போது அளவுருவின் மதிப்பை அழைப்புத் தரவிலிருந்து நேரடியாக எடுக்கலாம். மேலே உள்ள `_swap` போல, செயல்பாடு உள்நாட்டில் அழைக்கப்பட்டால், அப்போது அளவுருக்கள் `memory`-இல் சேமிக்கப்பட வேண்டும். அழைக்கப்பட்ட ஒப்பந்தத்தின் கண்ணோட்டத்தில் `calldata` படிக்க மட்டுமேயானது.

`uint` அல்லது `address` போன்ற அளவீட்டு வகைகளுக்கு, கம்பைலர் நமக்கான சேமிப்பகத் தேர்வைக் கையாளுகிறது, ஆனால் நீண்ட மற்றும் அதிக விலையுயர்ந்த வரிசைகளுக்கு, பயன்படுத்தப்பட வேண்டிய சேமிப்பக வகையை நாம் குறிப்பிடுகிறோம்.

```solidity
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
```

திருப்பி அனுப்பும் மதிப்புகள் எப்போதும் நினைவகத்தில் திருப்பி அனுப்பப்படுகின்றன.

```solidity
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
```

ஒவ்வொரு இடமாற்றத்திலும் வாங்கப்பட வேண்டிய தொகையைக் கணக்கிடுங்கள். முடிவு, வர்த்தகர் ஏற்கத் தயாராக இருக்கும் குறைந்தபட்சத்தை விட குறைவாக இருந்தால், பரிவர்த்தனையிலிருந்து பின்வாங்கவும்.

```solidity
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

இறுதியாக, ஆரம்ப ERC-20 டோக்கனை முதல் ஜோடி பரிமாற்றத்திற்கான கணக்கிற்கு மாற்றி, `_swap`-ஐ அழைக்கவும். இவை அனைத்தும் ஒரே பரிவர்த்தனையில் நடப்பதால், எதிர்பாராத எந்த டோக்கன்களும் இந்த மாற்றத்தின் ஒரு பகுதியாகும் என்று ஜோடிப் பரிமாற்றத்திற்குத் தெரியும்.

```solidity
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

முந்தைய `swapTokensForTokens` செயல்பாடு, ஒரு வர்த்தகரை அவர் கொடுக்கத் தயாராக உள்ள உள்ளீட்டு டோக்கன்களின் சரியான எண்ணிக்கையையும், பதிலுக்கு அவர் பெறத் தயாராக உள்ள வெளியீட்டு டோக்கன்களின் குறைந்தபட்ச எண்ணிக்கையையும் குறிப்பிட அனுமதிக்கிறது. இந்தச் செயல்பாடு தலைகீழ் இடமாற்றத்தைச் செய்கிறது, இது ஒரு வர்த்தகரை அவர் விரும்பும் வெளியீட்டு டோக்கன்களின் எண்ணிக்கையையும், அவற்றுக்காக அவர் செலுத்தத் தயாராக உள்ள உள்ளீட்டு டோக்கன்களின் அதிகபட்ச எண்ணிக்கையையும் குறிப்பிட அனுமதிக்கிறது.

இரண்டு சந்தர்ப்பங்களிலும், வர்த்தகர் அவற்றை மாற்றுவதற்கு அனுமதிப்பதற்காக, முதலில் இந்தப் புற ஒப்பந்தத்திற்கு ஒரு படியை வழங்க வேண்டும்.

```solidity
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
    }


    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }



    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }


    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
        // refund dust eth, if any
        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);
    }
```

இந்த நான்கு வகைகளும் ETH மற்றும் டோக்கன்களுக்கு இடையில் வர்த்தகம் செய்வதை உள்ளடக்கியவை. ஒரே வித்தியாசம் என்னவென்றால், நாம் ஒன்று வர்த்தகரிடமிருந்து ETH-ஐப் பெற்று அதை WETH-ஐ உருவாக்கப் பயன்படுத்துகிறோம், அல்லது பாதையில் உள்ள கடைசிப் பரிமாற்றத்திலிருந்து WETH-ஐப் பெற்று அதை எரித்து, அதன் விளைவாக வரும் ETH-ஐ வர்த்தகருக்குத் திருப்பி அனுப்புகிறோம்.

```solidity
    // **** இடமாற்று (மாற்றத்தின்போது கட்டணம் வசூலிக்கும் டோக்கன்களுக்கு ஆதரவளித்தல்) ****
    // முதல் ஜோடிக்கு ஆரம்பத் தொகை ஏற்கெனவே அனுப்பப்பட்டிருக்க வேண்டும்
    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {
```

மாற்ற அல்லது சேமிப்புக் கட்டணங்களைக் கொண்ட டோக்கன்களை இடமாற்றுவதற்கான உள் செயல்பாடு இதுவாகும் ([இந்தச் சிக்கலைத்](https://github.com/Uniswap/uniswap-interface/issues/835) தீர்க்க).

```solidity
        for (uint i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));
            uint amountInput;
            uint amountOutput;
            { // stack too deep பிழைகளைத் தவிர்க்கும் நோக்கம்
            (uint reserve0, uint reserve1,) = pair.getReserves();
            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
```

மாற்றுக் கட்டணங்கள் காரணமாக, ஒவ்வொரு மாற்றத்திலிருந்தும் எவ்வளவு பெறுகிறோம் என்பதைச் சொல்ல `getAmountsOut` செயல்பாட்டை நாம் சார்ந்திருக்க முடியாது (அசல் `_swap`-ஐ அழைப்பதற்கு முன்பு நாம் செய்வது போல). அதற்குப் பதிலாக, நாம் முதலில் மாற்ற வேண்டும், பிறகு எத்தனை டோக்கன்கள் திரும்பக் கிடைத்தன என்று பார்க்க வேண்டும்.

குறிப்பு: கோட்பாட்டளவில், `_swap`-க்குப் பதிலாக இந்தச் செயல்பாட்டை நாம் பயன்படுத்தலாம், ஆனால் சில சந்தர்ப்பங்களில் (உதாரணமாக, தேவையான குறைந்தபட்சத்தை பூர்த்தி செய்ய இறுதியில் போதுமான அளவு இல்லாததால் மாற்றம் ரத்து செய்யப்பட்டால்) அது அதிக gas செலவாகும். மாற்றுக் கட்டணம் உள்ள டோக்கன்கள் மிகவும் அரிதானவை. எனவே நாம் அவற்றை உள்ளடக்க வேண்டியிருந்தாலும், அனைத்து இடமாற்றங்களும் அவற்றில் குறைந்தபட்சம் ஒன்றின் வழியாகச் செல்லும் என்று கருதத் தேவையில்லை.

```solidity
            }
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
            pair.swap(amount0Out, amount1Out, to, new bytes(0));
        }
    }


    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) {
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        payable
        ensure(deadline)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        uint amountIn = msg.value;
        IWETH(WETH).deposit{value: amountIn}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        ensure(deadline)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        _swapSupportingFeeOnTransferTokens(path, address(this));
        uint amountOut = IERC20(WETH).balanceOf(address(this));
        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).withdraw(amountOut);
        TransferHelper.safeTransferETH(to, amountOut);
    }
```

இவை சாதாரண டோக்கன்களுக்குப் பயன்படுத்தப்படும் அதே வகைகளாகும், ஆனால் அவை அதற்குப் பதிலாக `_swapSupportingFeeOnTransferTokens`-ஐ அழைக்கின்றன.

```solidity
    // **** நூலகச் செயல்பாடுகள் ****
    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {
        return UniswapV2Library.quote(amountA, reserveA, reserveB);
    }

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountOut)
    {
        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
    }

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountIn)
    {
        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);
    }

    function getAmountsOut(uint amountIn, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsOut(factory, amountIn, path);
    }

    function getAmountsIn(uint amountOut, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsIn(factory, amountOut, path);
    }
}
```

இந்தச் செயல்பாடுகள் [UniswapV2Library செயல்பாடுகளை](#uniswapV2library) அழைக்கும் பதிலாள்கள் மட்டுமே.

### UniswapV2Migrator.sol {#UniswapV2Migrator}

பழைய v1-லிருந்து v2-க்கு பரிமாற்றங்களை மாற்றுவதற்கு இந்த ஒப்பந்தம் பயன்படுத்தப்பட்டது. அவை மாற்றப்பட்டுவிட்டதால், அது இப்போது பொருத்தமற்றது.

## நூலகங்கள் {#libraries}

[SafeMath நூலகம்](https://docs.openzeppelin.com/contracts/2.x/api/math) நன்கு ஆவணப்படுத்தப்பட்டுள்ளது, எனவே அதை இங்கே ஆவணப்படுத்தத் தேவையில்லை.

### கணிதம் {#Math}

இந்த நூலகம் சில கணிதச் செயல்பாடுகளைக் கொண்டுள்ளது, அவை பொதுவாக Solidity குறியீட்டில் தேவையில்லை, எனவே அவை மொழியின் ஒரு பகுதியாக இல்லை.

```solidity
pragma solidity =0.5.16;

// பல்வேறு கணிதச் செயல்பாடுகளைச் செய்வதற்கான ஒரு நூலகம்

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // பாபிலோனிய முறை (https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
```

வர்க்கமூலத்தை விட அதிகமான மதிப்பீடாக x-ஐத் தொடங்குங்கள் (அதனால் தான் 1-3-ஐ சிறப்பு நிகழ்வுகளாக நாம் கருத வேண்டும்).

```solidity
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
```

நெருக்கமான மதிப்பீட்டைப் பெறுங்கள்: முந்தைய மதிப்பீட்டின் சராசரி மற்றும் நாம் வர்க்கமூலத்தைக் கண்டுபிடிக்க முயற்சிக்கும் எண்ணை முந்தைய மதிப்பீட்டால் வகுத்ததன் சராசரி. புதிய மதிப்பீடு ஏற்கனவே உள்ளதை விட குறைவாக இல்லாத வரை மீண்டும் செய்யவும். மேலும் விவரங்களுக்கு, [இங்கே பார்க்கவும்](https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).

```solidity
            }
        } else if (y != 0) {
            z = 1;
```

நமக்கு பூஜ்ஜியத்தின் வர்க்கமூலம் ஒருபோதும் தேவைப்படாது. ஒன்று, இரண்டு மற்றும் மூன்றின் வர்க்கமூலங்கள் தோராயமாக ஒன்று (நாம் முழு எண்களைப் பயன்படுத்துவதால், பின்னத்தை நாம் புறக்கணிக்கிறோம்).

```solidity
        }
    }
}
```

### நிலையான புள்ளி பின்னங்கள் (UQ112x112) {#FixedPoint}

இந்த நூலகம் பின்னங்களைக் கையாளுகிறது, அவை பொதுவாக எத்தேரியம் எண்கணிதத்தின் ஒரு பகுதியாக இல்லை. இது _x_ என்ற எண்ணை _x\*2^112_ என்று குறியாக்கம் செய்வதன் மூலம் இதைச் செய்கிறது. இது அசல் கூட்டல் மற்றும் கழித்தல் opcodes-களை மாற்றம் இல்லாமல் பயன்படுத்த அனுமதிக்கிறது.

```solidity
pragma solidity =0.5.16;

// பைனரி நிலையான புள்ளி எண்களைக் கையாள்வதற்கான ஒரு நூலகம் (https://wikipedia.org/wiki/Q_(number_format))

// வரம்பு: [0, 2**112 - 1]
// தீர்வு: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;
```

`Q112` என்பது ஒன்றுக்கான குறியாக்கம்.

```solidity
    // ஒரு uint112-ஐ ஒரு UQ112x112 ஆக குறியாக்கம் செய்யவும்
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // ஒருபோதும் நிரம்பி வழியாது
    }
```

y என்பது `uint112` என்பதால், அது அதிகபட்சம் 2^112-1 ஆக இருக்கலாம். அந்த எண்ணை இன்னும் `UQ112x112` ஆக குறியாக்கம் செய்ய முடியும்.

```solidity
    // ஒரு UQ112x112-ஐ ஒரு uint112 ஆல் வகுத்து, ஒரு UQ112x112-ஐத் திருப்பி அனுப்பவும்
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}
```

இரண்டு `UQ112x112` மதிப்புகளை நாம் வகுத்தால், அதன் விளைவாக வரும் மதிப்பு இனி 2^112 ஆல் பெருக்கப்படாது. எனவே அதற்குப் பதிலாக, பகுதிக்கு ஒரு முழு எண்ணை எடுத்துக்கொள்கிறோம். பெருக்கத்தைச் செய்ய நாம் இதேபோன்ற ஒரு தந்திரத்தைப் பயன்படுத்தியிருக்க வேண்டும், ஆனால் `UQ112x112` மதிப்புகளின் பெருக்கத்தை நாம் செய்யத் தேவையில்லை.

### UniswapV2Library {#uniswapV2library}

இந்த நூலகம் புற ஒப்பந்தங்களால் மட்டுமே பயன்படுத்தப்படுகிறது.

```solidity
pragma solidity >=0.5.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import "./SafeMath.sol";

library UniswapV2Library {
    using SafeMath for uint;

    // வரிசைப்படுத்தப்பட்ட டோக்கன் முகவரிகளைத் திருப்பித் தரும், இந்த வரிசையில் வரிசைப்படுத்தப்பட்ட ஜோடிகளிலிருந்து வரும் ரிட்டர்ன் மதிப்புகளைக் கையாளப் பயன்படுகிறது
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }
```

இரண்டு டோக்கன்களையும் முகவரிப்படி வரிசைப்படுத்துங்கள், அப்போது அவற்றுக்கான ஜோடி பரிமாற்றத்தின் முகவரியை நாம் பெற முடியும். இது அவசியமானது, ஏனெனில் இல்லையெனில் நமக்கு இரண்டு சாத்தியக்கூறுகள் இருக்கும், ஒன்று A,B அளவுருக்களுக்கும் மற்றொன்று B,A அளவுருக்களுக்கும், இது ஒன்றுக்குப் பதிலாக இரண்டு பரிமாற்றங்களுக்கு வழிவகுக்கும்.

```solidity
    // எந்த வெளி அழைப்புகளையும் செய்யாமல் ஒரு ஜோடிக்கான CREATE2 முகவரியைக் கணக்கிடுகிறது
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init குறியீட்டுத் துண்டிப்பு
            ))));
    }
```

இந்தச் செயல்பாடு இரண்டு டோக்கன்களுக்கான ஜோடிப் பரிமாற்றத்தின் முகவரியைக் கணக்கிடுகிறது. இந்த ஒப்பந்தம் [CREATE2 opcode-ஐப்](https://eips.ethereum.org/EIPS/eip-1014) பயன்படுத்தி உருவாக்கப்பட்டுள்ளது, எனவே அது பயன்படுத்தும் அளவுருக்களை நாம் அறிந்தால், அதே நெறிமுறையைப் பயன்படுத்தி முகவரியைக் கணக்கிடலாம். இது தொழிற்சாலையிடம் கேட்பதை விட மிகவும் மலிவானது, மேலும்

```solidity
    // ஒரு ஜோடிக்கான இருப்புக்களைப் பெற்று வரிசைப்படுத்துகிறது
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
```

இந்தச் செயல்பாடு, ஜோடிப் பரிமாற்றம் வைத்திருக்கும் இரண்டு டோக்கன்களின் இருப்புகளைத் திருப்பித் தருகிறது. இது டோக்கன்களை எந்த வரிசையிலும் பெற முடியும் என்பதையும், உள் பயன்பாட்டிற்காக அவற்றை வரிசைப்படுத்துகிறது என்பதையும் கவனத்தில் கொள்ளவும்.

```solidity
    // ஒரு சொத்தின் குறிப்பிட்ட அளவு மற்றும் ஜோடி இருப்புகளைக் கொண்டு, மற்ற சொத்தின் சமமான அளவைத் திருப்பித் தருகிறது
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }
```

கட்டணம் எதுவும் இல்லாத பட்சத்தில், டோக்கன் A-க்கு பதிலாக நீங்கள் பெறும் டோக்கன் B-யின் அளவை இந்தச் செயல்பாடு வழங்குகிறது. இந்தக் கணக்கீடு, பரிமாற்றம் பரிமாற்ற வீதத்தை மாற்றுகிறது என்பதை கணக்கில் எடுத்துக்கொள்கிறது.

```solidity
    // ஒரு சொத்தின் உள்ளீட்டுத் தொகை மற்றும் ஜோடி இருப்புகளைக் கொண்டு, மற்ற சொத்தின் அதிகபட்ச வெளியீட்டுத் தொகையைத் திருப்பித் தருகிறது
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
```

மேலே உள்ள `quote` செயல்பாடு, ஜோடிப் பரிமாற்றத்தைப் பயன்படுத்த கட்டணம் இல்லாதபோது சிறப்பாகச் செயல்படுகிறது. இருப்பினும், 0.3% பரிமாற்றக் கட்டணம் இருந்தால், நீங்கள் உண்மையில் பெறும் தொகை குறைவாக இருக்கும். இந்தச் செயல்பாடு பரிமாற்றக் கட்டணத்திற்குப் பிறகான தொகையைக் கணக்கிடுகிறது.

```solidity

        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
```

Solidity பின்னங்களை இயல்பாகக் கையாளுவதில்லை, எனவே வெளியீட்டுத் தொகையை 0.997 ஆல் பெருக்க முடியாது. அதற்குப் பதிலாக, தொகுதியை 997 ஆலயும், பகுதியை 1000 ஆலயும் பெருக்குகிறோம், இது அதே விளைவை ஏற்படுத்துகிறது.

```solidity
    // ஒரு சொத்தின் வெளியீட்டுத் தொகை மற்றும் ஜோடி இருப்புகளைக் கொண்டு, மற்ற சொத்தின் தேவையான உள்ளீட்டுத் தொகையைத் திருப்பித் தருகிறது
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }
```

இந்தச் செயல்பாடு ஏறக்குறைய அதே வேலையைச் செய்கிறது, ஆனால் இது வெளியீட்டுத் தொகையைப் பெற்று உள்ளீட்டை வழங்குகிறது.

```solidity

    // எந்த எண்ணிக்கையிலான ஜோடிகளிலும் தொடர்ச்சியான getAmountOut கணக்கீடுகளைச் செய்கிறது
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // எந்த எண்ணிக்கையிலான ஜோடிகளிலும் தொடர்ச்சியான getAmountIn கணக்கீடுகளைச் செய்கிறது
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}
```

பல ஜோடிப் பரிமாற்றங்கள் வழியாகச் செல்ல வேண்டியிருக்கும் போது, இந்த இரண்டு செயல்பாடுகளும் மதிப்புகளை அடையாளம் காண உதவுகின்றன.

### பரிமாற்ற உதவியாளர் {#transfer-helper}

[இந்த நூலகம்](https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol) ERC-20 மற்றும் எத்தேரியம் பரிமாற்றங்களைச் சுற்றி வெற்றிச் சரிபார்ப்புகளைச் சேர்க்கிறது, இது ஒரு ரத்து மற்றும் `false` மதிப்புத் திரும்புதலை ஒரே மாதிரியாகக் கையாளுகிறது.

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.6.0;

// ERC20 டோக்கன்களுடன் தொடர்புகொள்வதற்கும், தொடர்ந்து true/false என்று தராத ETH-ஐ அனுப்புவதற்கும் உதவும் முறைகள்
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));

```

ஒரு வேறுபட்ட ஒப்பந்தத்தை நாம் இரண்டு வழிகளில் ஒன்றில் அழைக்கலாம்:

- ஒரு செயல்பாட்டு அழைப்பை உருவாக்க இடைமுக வரையறையைப் பயன்படுத்தவும்
- அழைப்பை உருவாக்க [பயன்பாட்டு பைனரி இடைமுகத்தை (ABI)](https://docs.soliditylang.org/en/v0.8.3/abi-spec.html) "கைமுறையாக" பயன்படுத்தவும். குறியீட்டின் ஆசிரியர் இதைச் செய்ய முடிவு செய்துள்ளார்.

```solidity
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }
```

ERC-20 தரநிலைக்கு முன்பு உருவாக்கப்பட்ட டோக்கன்களுடன் பின்னோக்கிய பொருந்தக்கூடியன்மைக்காக, ஒரு ERC-20 அழைப்பு ரத்து செய்வதன் மூலம் (அதில் `success` என்பது `false` ஆக இருக்கும்) அல்லது வெற்றிகரமாக இருந்து `false` மதிப்பைத் திருப்புவதன் மூலம் (அதில் வெளியீட்டுத் தரவு இருக்கும், மற்றும் நீங்கள் அதை ஒரு பூலியனாக டிகோட் செய்தால் `false` கிடைக்கும்) தோல்வியடையலாம்.

```solidity


    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }
```

இந்த செயல்பாடு [ERC-20 இன் பரிமாற்ற செயல்பாட்டை](https://eips.ethereum.org/EIPS/eip-20#transfer) செயல்படுத்துகிறது, இது ஒரு கணக்கு வேறு கணக்கு வழங்கிய படியைச் செலவழிக்க அனுமதிக்கிறது.

```solidity

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }
```

இந்த செயல்பாடு [ERC-20 இன் transferFrom செயல்பாட்டை](https://eips.ethereum.org/EIPS/eip-20#transferfrom) செயல்படுத்துகிறது, இது ஒரு கணக்கு வேறு கணக்கு வழங்கிய படியைச் செலவழிக்க அனுமதிக்கிறது.

```solidity

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}
```

இந்தச் செயல்பாடு ஒரு கணக்கிற்கு ஈதரை மாற்றுகிறது. ஒரு வேறுபட்ட ஒப்பந்தத்திற்கு எந்த அழைப்பும் ஈதரை அனுப்ப முயற்சிக்கலாம். நாம் உண்மையில் எந்தச் செயல்பாட்டையும் அழைக்கத் தேவையில்லாததால், அழைப்புடன் எந்தத் தரவையும் அனுப்புவதில்லை.

## முடிவுரை {#conclusion}

இது சுமார் 50 பக்கங்கள் கொண்ட ஒரு நீண்ட கட்டுரை. நீங்கள் இங்கு வந்திருந்தால், வாழ்த்துகள்! ஒரு நிஜ வாழ்க்கை பயன்பாட்டை (குறுகிய மாதிரி நிரல்களுக்கு மாறாக) எழுதுவதில் உள்ள பரிசீலனைகளை இப்போது நீங்கள் புரிந்துகொண்டிருப்பீர்கள் என்றும், உங்கள் சொந்த பயன்பாட்டு நிகழ்வுகளுக்கு ஒப்பந்தங்களை எழுதுவதில் சிறப்பாக இருப்பீர்கள் என்றும் நம்புகிறேன்.

இப்போது சென்று பயனுள்ள ஒன்றை எழுதி எங்களை வியக்க வையுங்கள்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).
