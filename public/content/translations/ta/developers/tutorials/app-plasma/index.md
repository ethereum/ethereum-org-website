---
title: "தனியுரிமையைப் பாதுகாக்கும் ஒரு செயலி-குறிப்பிட்ட பிளாஸ்மாவை எழுதுங்கள்"
description: "இந்த பயிற்சியில், வைப்புகளுக்காக ஒரு அரை-இரகசிய வங்கியை உருவாக்குகிறோம். வங்கி ஒரு மையப்படுத்தப்பட்ட கூறு; அது ஒவ்வொரு பயனரின் இருப்பையும் அறியும். இருப்பினும், இந்த தகவல் ஆன்செயினில் சேமிக்கப்படவில்லை. பதிலாக, வங்கி நிலையின் ஒரு துண்டியை வெளியிடுகிறது. ஒவ்வொரு முறை ஒரு பரிவர்த்தனை நிகழும்போதும், வங்கி புதிய துண்டியை வெளியிடுகிறது, அதனுடன் துண்டி நிலையை புதியதாக மாற்றும் ஒரு கையொப்பமிடப்பட்ட பரிவர்த்தனையைக் கொண்டிருப்பதற்கான பூஜ்ஜிய-அறிவு ஆதாரத்தையும் வெளியிடுகிறது. இந்த பயிற்சியைப் படித்த பிறகு, பூஜ்ஜிய-அறிவு ஆதாரங்களை எவ்வாறு பயன்படுத்துவது என்பது மட்டுமல்லாமல், அவற்றை ஏன் பயன்படுத்துகிறீர்கள் மற்றும் அதை எவ்வாறு பாதுகாப்பாகச் செய்வது என்பதையும் நீங்கள் புரிந்துகொள்வீர்கள்."
author: Ori Pomerantz
tags:
  [
    "பூஜ்ஜிய-அறிவு",
    "சேவையகம்",
    "ஆஃப்செயின்",
    "தனியுரிமை"
  ]
skill: advanced
lang: ta
published: 2025-10-15
---

## அறிமுகம் {#introduction}

[ரோல்அப்களுக்கு](/developers/docs/scaling/zk-rollups/) மாறாக, [பிளாஸ்மாக்கள்](/developers/docs/scaling/plasma) ஒருமைப்பாட்டிற்காக Ethereum மெயின்நெட்டைப் பயன்படுத்துகின்றன, ஆனால் கிடைப்பதற்கல்ல. இந்தக் கட்டுரையில், நாங்கள் ஒரு பிளாஸ்மா போல செயல்படும் ஒரு செயலியை எழுதுகிறோம், Ethereum ஒருமைப்பாட்டிற்கு உத்தரவாதம் அளிக்கிறது (அங்கீகரிக்கப்படாத மாற்றங்கள் இல்லை) ஆனால் கிடைப்பதற்கல்ல (ஒரு மையப்படுத்தப்பட்ட கூறு செயலிழந்து முழு அமைப்பையும் முடக்கக்கூடும்).

நாங்கள் இங்கு எழுதும் செயலி ஒரு தனியுரிமையைப் பாதுகாக்கும் வங்கியாகும். வெவ்வேறு முகவரிகள் இருப்புடன் கூடிய கணக்குகளைக் கொண்டுள்ளன, மேலும் அவர்களால் மற்ற கணக்குகளுக்கு பணம் (ETH) அனுப்ப முடியும். வங்கி நிலையின் (கணக்குகள் மற்றும் அவற்றின் இருப்புகள்) மற்றும் பரிவர்த்தனைகளின் துண்டிகளை வெளியிடுகிறது, ஆனால் உண்மையான இருப்புகளை ஆஃப்செயினில் வைத்திருக்கிறது, அங்கு அவை தனியாக இருக்க முடியும்.

## வடிவமைப்பு {#design}

இது ஒரு உற்பத்திக்கு-தயாரான அமைப்பு அல்ல, ஆனால் ஒரு கற்பித்தல் கருவி. அதுபோல, இது பல எளிமைப்படுத்தும் அனுமானங்களுடன் எழுதப்பட்டுள்ளது.

- நிலையான கணக்குத் தொகுப்பு. ஒரு குறிப்பிட்ட எண்ணிக்கையிலான கணக்குகள் உள்ளன, மற்றும் ஒவ்வொரு கணக்கும் ஒரு முன்னரே தீர்மானிக்கப்பட்ட முகவரிக்கு சொந்தமானது. இது மிகவும் எளிமையான அமைப்பை உருவாக்குகிறது, ஏனென்றால் பூஜ்ஜிய-அறிவு ஆதாரங்களில் மாறி-அளவு தரவு கட்டமைப்புகளைக் கையாள்வது கடினம். ஒரு உற்பத்திக்கு-தயாரான அமைப்புக்கு, நாம் நிலைத் துண்டியாக [மெர்க்கல் ரூட்டை](/developers/tutorials/merkle-proofs-for-offline-data-integrity/)ப் பயன்படுத்தலாம் மற்றும் தேவையான இருப்புகளுக்கு மெர்க்கல் ஆதாரங்களை வழங்கலாம்.

- நினைவகச் சேமிப்பு. ஒரு உற்பத்தி அமைப்பில், மறுதொடக்கத்தின் போது அவற்றை பாதுகாக்க அனைத்து கணக்கு இருப்புகளையும் வட்டில் எழுத வேண்டும். இங்கு, தகவல் வெறுமனே இழந்தால் பரவாயில்லை.

- இடமாற்றங்கள் மட்டும். ஒரு உற்பத்தி அமைப்புக்கு வங்கியில் சொத்துக்களை வைப்பு செய்யவும் அவற்றை திரும்பப் பெறவும் ஒரு வழி தேவைப்படும். ஆனால் இங்கு நோக்கம் கருத்தை விளக்குவது மட்டுமே, எனவே இந்த வங்கி இடமாற்றங்களுக்கு மட்டுமே வரையறுக்கப்பட்டுள்ளது.

### பூஜ்ஜிய-அறிவு ஆதாரங்கள் {#zero-knowledge-proofs}

ஒரு அடிப்படை மட்டத்தில், ஒரு பூஜ்ஜிய-அறிவு ஆதாரம், சில பொது தரவு, _Data<sub>public</sub>_, மற்றும் _Data<sub>private</sub>_ க்கு இடையில் ஒரு உறவு _Relationship_ இருக்கும் வகையில், நிரூபிப்பவருக்கு சில தரவு, _Data<sub>private</sub>_ தெரியும் என்பதைக் காட்டுகிறது. சரிபார்ப்பவர் _Relationship_ மற்றும் _Data<sub>public</sub>_ ஐ அறிவார்.

தனியுரிமையைப் பாதுகாக்க, நிலைகளும் பரிவர்த்தனைகளும் தனியாக இருக்க வேண்டும். ஆனால் ஒருமைப்பாட்டை உறுதிப்படுத்த, நிலைகளின் [மறைகுறியீட்டுத் துண்டி](https://en.wikipedia.org/wiki/Cryptographic_hash_function) பொதுவில் இருக்க வேண்டும். பரிவர்த்தனைகளைச் சமர்ப்பிக்கும் மக்களுக்கு அந்த பரிவர்த்தனைகள் உண்மையில் நடந்தன என்று நிரூபிக்க, நாம் பரிவர்த்தனைத் துண்டிகளையும் வெளியிட வேண்டும்.

பெரும்பாலான சந்தர்ப்பங்களில், _Data<sub>private</sub>_ என்பது பூஜ்ஜிய-அறிவு ஆதார நிரலுக்கான உள்ளீடு ஆகும், மற்றும் _Data<sub>public</sub>_ என்பது வெளியீடு ஆகும்.

_Data<sub>private</sub>_ இல் உள்ள இந்தப் புலங்கள்:

- _State<sub>n</sub>_, பழைய நிலை
- _State<sub>n+1</sub>_, புதிய நிலை
- _Transaction_, பழைய நிலையிலிருந்து புதிய நிலைக்கு மாற்றும் ஒரு பரிவர்த்தனை. இந்தப் பரிவர்த்தனையில் இந்தப் புலங்கள் சேர்க்கப்பட வேண்டும்:
  - இடமாற்றத்தைப் பெறும் _இலக்கு முகவரி_
  - இடமாற்றப்படும் _தொகை_
  - ஒவ்வொரு பரிவர்த்தனையும் ஒரு முறை மட்டுமே செயலாக்கப்பட முடியும் என்பதை உறுதிப்படுத்த _நான்ஸ்_.
    மூல முகவரி பரிவர்த்தனையில் இருக்கத் தேவையில்லை, ஏனென்றால் அது கையொப்பத்திலிருந்து மீட்கப்படலாம்.
- _கையொப்பம்_, பரிவர்த்தனையைச் செய்ய அங்கீகரிக்கப்பட்ட கையொப்பம். எங்கள் விஷயத்தில், ஒரு பரிவர்த்தனையைச் செய்ய அங்கீகரிக்கப்பட்ட ஒரே முகவரி மூல முகவரி மட்டுமே. நமது பூஜ்ஜிய-அறிவு அமைப்பு செயல்படும் விதத்தின் காரணமாக, Ethereum கையொப்பத்துடன், கணக்கின் பொது திறவுகோலும் நமக்குத் தேவை.

இவை _Data<sub>public</sub>_ இல் உள்ள புலங்கள்:

- _Hash(State<sub>n</sub>)_ பழைய நிலையின் துண்டி
- _Hash(State<sub>n+1</sub>)_ புதிய நிலையின் துண்டி
- _Hash(Transaction)_ நிலையை _State<sub>n</sub>_ இலிருந்து _State<sub>n+1</sub>_ க்கு மாற்றும் பரிவர்த்தனையின் துண்டி.

உறவு பல நிபந்தனைகளைச் சரிபார்க்கிறது:

- பொதுத் துண்டிகள் உண்மையில் தனிப்பட்ட புலங்களுக்கான சரியான துண்டிகள்.
- பரிவர்த்தனை, பழைய நிலைக்குப் பயன்படுத்தப்படும்போது, புதிய நிலையை விளைவிக்கிறது.
- கையொப்பம் பரிவர்த்தனையின் மூல முகவரியிலிருந்து வருகிறது.

மறைகுறியீட்டுத் துண்டி செயல்பாடுகளின் பண்புகளின் காரணமாக, இந்த நிபந்தனைகளை நிரூபிப்பதே ஒருமைப்பாட்டை உறுதிப்படுத்தப் போதுமானது.

### தரவுக் கட்டமைப்புகள் {#data-structures}

முதன்மை தரவு கட்டமைப்பு சேவையகத்தால் வைத்திருக்கும் நிலை ஆகும். ஒவ்வொரு கணக்கிற்கும், சேவையகம் கணக்கு இருப்பையும் மற்றும் ஒரு [நான்ஸையும்](https://en.wikipedia.org/wiki/Cryptographic_nonce) கண்காணிக்கிறது, இது [மீண்டும் தாக்குதல்களை](https://en.wikipedia.org/wiki/Replay_attack)த் தடுக்கப் பயன்படுகிறது.

### கூறுகள் {#components}

இந்த அமைப்புக்கு இரண்டு கூறுகள் தேவை:

- பரிவர்த்தனைகளைப் பெற்று, அவற்றைச் செயலாக்கி, பூஜ்ஜிய-அறிவு ஆதாரங்களுடன் சங்கிலிக்குத் துண்டிகளை வெளியிடும் _சேவையகம்_.
- துண்டிகளை சேமித்து, நிலை மாற்றங்கள் சட்டபூர்வமானவை என்பதை உறுதிப்படுத்த பூஜ்ஜிய-அறிவு ஆதாரங்களை சரிபார்க்கும் ஒரு _ஸ்மார்ட் ஒப்பந்தம்_.

### தரவு மற்றும் கட்டுப்பாட்டு ஓட்டம் {#flows}

இவை ஒரு கணக்கிலிருந்து மற்றொரு கணக்கிற்கு மாற்ற பல்வேறு கூறுகள் தொடர்பு கொள்ளும் வழிகள்.

1. ஒரு வலை உலாவி, கையொப்பமிட்டவரின் கணக்கிலிருந்து வேறு கணக்கிற்கு இடமாற்றம் கோரி கையொப்பமிடப்பட்ட பரிவர்த்தனையைச் சமர்ப்பிக்கிறது.

2. சேவையகம் பரிவர்த்தனை செல்லுபடியாகும் என்பதை சரிபார்க்கிறது:

   - கையொப்பமிட்டவருக்கு வங்கியில் போதுமான இருப்புடன் ஒரு கணக்கு உள்ளது.
   - பெறுநருக்கு வங்கியில் ஒரு கணக்கு உள்ளது.

3. சேவையகம், இடமாற்றப்பட்ட தொகையை கையொப்பமிட்டவரின் இருப்பிலிருந்து கழித்து, பெறுநரின் இருப்பில் சேர்ப்பதன் மூலம் புதிய நிலையை கணக்கிடுகிறது.

4. நிலை மாற்றம் செல்லுபடியானது என்பதற்கு சேவையகம் ஒரு பூஜ்ஜிய-அறிவு ஆதாரத்தைக் கணக்கிடுகிறது.

5. சேவையகம் Ethereum க்கு ஒரு பரிவர்த்தனையைச் சமர்ப்பிக்கிறது, அதில் அடங்குவன:

   - புதிய நிலைத் துண்டி
   - பரிவர்த்தனைத் துண்டி (அதனால் பரிவர்த்தனை அனுப்புநர் அது செயலாக்கப்பட்டது என்பதை அறிய முடியும்)
   - புதிய நிலைக்கு மாற்றம் செல்லுபடியானது என்பதை நிரூபிக்கும் பூஜ்ஜிய-அறிவு ஆதாரம்

6. ஸ்மார்ட் ஒப்பந்தம் பூஜ்ஜிய-அறிவு ஆதாரத்தை சரிபார்க்கிறது.

7. பூஜ்ஜிய-அறிவு ஆதாரம் சரிபார்த்தால், ஸ்மார்ட் ஒப்பந்தம் இந்த செயல்களைச் செய்கிறது:
   - தற்போதைய நிலைத் துண்டியை புதிய நிலைத் துண்டியாக புதுப்பிக்கவும்
   - புதிய நிலைத் துண்டி மற்றும் பரிவர்த்தனைத் துண்டியுடன் ஒரு பதிவு நுழைவை வெளியிடவும்

### கருவிகள் {#tools}

வாடிக்கையாளர்-பக்கக் குறியீட்டிற்கு, நாங்கள் [Vite](https://vite.dev/), [React](https://react.dev/), [Viem](https://viem.sh/), மற்றும் [Wagmi](https://wagmi.sh/) ஆகியவற்றைப் பயன்படுத்தப் போகிறோம். இவை தொழில்-தரமான கருவிகள்; உங்களுக்கு அவை பரிச்சயமில்லை என்றால், நீங்கள் [இந்த வழிகாட்டியைப்](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/) பயன்படுத்தலாம்.

சேவையகத்தின் பெரும்பகுதி [Node](https://nodejs.org/en) ஐப் பயன்படுத்தி ஜாவாஸ்கிரிப்டில் எழுதப்பட்டுள்ளது. பூஜ்ஜிய-அறிவு பகுதி [Noir](https://noir-lang.org/) இல் எழுதப்பட்டுள்ளது. எங்களுக்கு பதிப்பு `1.0.0-beta.10` தேவை, எனவே நீங்கள் [Noir ஐ அறிவுறுத்தப்பட்டபடி நிறுவிய பிறகு](https://noir-lang.org/docs/getting_started/quick_start), இயக்கவும்:

```
noirup -v 1.0.0-beta.10
```

நாம் பயன்படுத்தும் பிளாக்செயின் `anvil` ஆகும், இது [Foundry](https://getfoundry.sh/introduction/installation) இன் பகுதியாக உள்ள ஒரு உள்ளூர் சோதனை பிளாக்செயின் ஆகும்.

## செயல்படுத்துதல் {#implementation}

இது ஒரு சிக்கலான அமைப்பு என்பதால், நாங்கள் அதை நிலைகளாகச் செயல்படுத்துவோம்.

### நிலை 1 - கைமுறை பூஜ்ஜிய அறிவு {#stage-1}

முதல் கட்டமாக, நாங்கள் உலாவியில் ஒரு பரிவர்த்தனையில் கையெழுத்திட்டு, பின்னர் பூஜ்ஜிய-அறிவு ஆதாரத்திற்கு தகவலை கைமுறையாக வழங்குவோம். பூஜ்ஜிய-அறிவு குறியீடு `server/noir/Prover.toml` இல் அந்த தகவலைப் பெறும் என எதிர்பார்க்கிறது (இங்கே ஆவணப்படுத்தப்பட்டுள்ளது [here](https://noir-lang.org/docs/getting_started/project_breakdown#provertoml-1)).

அதைச் செயலில் காண:

1. [Node](https://nodejs.org/en/download) மற்றும் [Noir](https://noir-lang.org/install) ஐ நிறுவியுள்ளீர்கள் என்பதை உறுதிப்படுத்தவும். முன்னுரிமையாக, அவற்றை macOS, Linux, அல்லது [WSL](https://learn.microsoft.com/en-us/windows/wsl/install) போன்ற ஒரு UNIX கணினியில் நிறுவவும்.

2. நிலை 1 குறியீட்டைப் பதிவிறக்கி, வாடிக்கையாளர் குறியீட்டை வழங்க வலை சேவையகத்தைத் தொடங்கவும்.

   ```sh
   git clone https://github.com/qbzzt/250911-zk-bank.git -b 01-manual-zk
   cd 250911-zk-bank
   cd client
   npm install
   npm run dev
   ```

   உங்களுக்கு இங்கு ஒரு வலை சேவையகம் தேவைப்படுவதற்கான காரணம், சில வகையான மோசடிகளைத் தடுக்க, பல பணப்பைகள் (MetaMask போன்றவை) வட்டில் இருந்து நேரடியாக வழங்கப்படும் கோப்புகளை ஏற்றுக்கொள்வதில்லை.

3. ஒரு பணப்பையுடன் ஒரு உலாவியைத் திறக்கவும்.

4. பணப்பையில், ஒரு புதிய கடவுச்சொற்றொடரை உள்ளிடவும். இது உங்கள் தற்போதைய கடவுச்சொற்றொடரை நீக்கிவிடும் என்பதை நினைவில் கொள்ளவும், எனவே _உங்களிடம் ஒரு காப்புப் பிரதி இருப்பதை உறுதிப்படுத்தவும்_.

   கடவுச்சொற்றொடர் `test test test test test test test test test test test junk`, இது anvil க்கான இயல்புநிலை சோதனை கடவுச்சொற்றொடர் ஆகும்.

5. [வாடிக்கையாளர்-பக்கக் குறியீட்டிற்குச்](http://localhost:5173/) செல்லவும்.

6. பணப்பையுடன் இணைத்து உங்கள் இலக்கு கணக்கையும் தொகையையும் தேர்ந்தெடுக்கவும்.

7. **கையொப்பமிடுக** என்பதைக் கிளிக் செய்து பரிவர்த்தனையில் கையெழுத்திடவும்.

8. **Prover.toml** தலைப்பின் கீழ், நீங்கள் உரையைக் காண்பீர்கள். `server/noir/Prover.toml` ஐ அந்த உரையுடன் மாற்றவும்.

9. பூஜ்ஜிய-அறிவு ஆதாரத்தைச் செயல்படுத்தவும்.

   ```sh
   cd ../server/noir
   nargo execute
   ```

   வெளியீடு இதுபோன்று இருக்க வேண்டும்

   ```
   ori@CryptoDocGuy:~/noir/250911-zk-bank/server/noir$ nargo execute

   [zkBank] Circuit witness successfully solved
   [zkBank] Witness saved to target/zkBank.gz
   [zkBank] Circuit output: (0x199aa62af8c1d562a6ec96e66347bf3240ab2afb5d022c895e6bf6a5e617167b, 0x0cfc0a67cb7308e4e9b254026b54204e34f6c8b041be207e64c5db77d95dd82d, 0x450cf9da6e180d6159290554ae3d8787, 0x6d8bc5a15b9037e52fb59b6b98722a85)
   ```

10. செய்தி சரியாகத் துண்டிக்கப்பட்டுள்ளதா என்பதைப் பார்க்க, கடைசி இரண்டு மதிப்புகளை வலை உலாவியில் நீங்கள் காணும் துண்டியுடன் ஒப்பிடவும்.

#### `server/noir/Prover.toml` {#server-noir-prover-toml}

[இந்தக் கோப்பு](https://github.com/qbzzt/250911-zk-bank/blob/01-manual-zk/server/noir/Prover.toml) Noir ஆல் எதிர்பார்க்கப்படும் தகவல் வடிவமைப்பைக் காட்டுகிறது.

```toml
message="send 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 500 finney (milliEth) 0                             "
```

செய்தி உரை வடிவத்தில் உள்ளது, இது பயனருக்குப் புரிந்துகொள்வதை எளிதாக்குகிறது (கையெழுத்திடும்போது இது அவசியம்) மற்றும் Noir குறியீடுக்கு பகுப்பாய்வு செய்வதை எளிதாக்குகிறது. ஒருபுறம் பின்ன இடமாற்றங்களை இயக்கவும், மறுபுறம் எளிதாகப் படிக்கவும் தொகை ஃபின்னிகளில் குறிப்பிடப்பட்டுள்ளது. கடைசி எண் [நான்ஸ்](https://en.wikipedia.org/wiki/Cryptographic_nonce) ஆகும்.

சரம் 100 எழுத்துகள் நீளமானது. பூஜ்ஜிய-அறிவு ஆதாரங்கள் மாறி அளவுள்ள தரவை நன்றாகக் கையாளுவதில்லை, எனவே தரவை நிரப்புவது பெரும்பாலும் அவசியம்.

```toml
pubKeyX=["0x83",...,"0x75"]
pubKeyY=["0x35",...,"0xa5"]
signature=["0xb1",...,"0x0d"]
```

இந்த மூன்று அளவுருக்களும் நிலையான அளவுள்ள பைட் வரிசைகள்.

```toml
[[accounts]]
address="0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
balance=100_000
nonce=0

[[accounts]]
address="0x70997970C51812dc3A010C7d01b50e0d17dc79C8"
balance=100_000
nonce=0
```

கட்டமைப்புகளின் வரிசையைக் குறிப்பிடுவதற்கான வழி இது. ஒவ்வொரு நுழைவுக்கும், நாங்கள் முகவரி, இருப்பு (milliETH எனப்படும் [ஃபின்னி](https://cryptovalleyjournal.com/glossary/finney/)-யில்), மற்றும் அடுத்த நான்ஸ் மதிப்பைக் குறிப்பிடுகிறோம்.

#### `client/src/Transfer.tsx` {#client-src-transfer-tsx}

[இந்தக் கோப்பு](https://github.com/qbzzt/250911-zk-bank/blob/01-manual-zk/client/src/Transfer.tsx) வாடிக்கையாளர் பக்க செயலாக்கத்தை செயல்படுத்துகிறது மற்றும் `server/noir/Prover.toml` கோப்பை (பூஜ்ஜிய-அறிவு அளவுருக்களை உள்ளடக்கியது) உருவாக்குகிறது.

இங்கே மிகவும் சுவாரஸ்யமான பகுதிகளின் விளக்கம் உள்ளது.

```tsx
export default attrs =>  {
```

இந்த செயல்பாடு `Transfer` React கூறுகளை உருவாக்குகிறது, மற்ற கோப்புகள் இறக்குமதி செய்ய முடியும்.

```tsx
  const accounts = [
    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
    "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
    "0x90F79bf6EB2c4f870365E785982E1f101E93b906",
    "0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65",
  ]
```

இவை கணக்கு முகவரிகள், `test ...` மூலம் உருவாக்கப்பட்ட முகவரிகள். test junk` கடவுச்சொற்றொடர். உங்கள் சொந்த முகவரிகளைப் பயன்படுத்த விரும்பினால், இந்த வரையறையை மாற்றியமைக்கவும்.

```tsx
  const account = useAccount()
  const wallet = createWalletClient({
    transport: custom(window.ethereum!)
  })
```

இந்த [Wagmi hooks](https://wagmi.sh/react/api/hooks) [viem](https://viem.sh/) நூலகத்தையும் பணப்பையையும் அணுக அனுமதிக்கின்றன.

```tsx
  const message = `send ${toAccount} ${ethAmount*1000} finney (milliEth) ${nonce}`.padEnd(100, " ")
```

இது செய்தி, இடைவெளிகளுடன் நிரப்பப்பட்டுள்ளது. ஒவ்வொரு முறையும் [`useState`](https://react.dev/reference/react/useState) மாறிகளில் ஒன்று மாறும் போது, கூறு மீண்டும் வரையப்படுகிறது மற்றும் `செய்தி` புதுப்பிக்கப்படுகிறது.

```tsx
  const sign = async () => {
```

பயனர் **கையொப்பமிடுக** பொத்தானைக் கிளிக் செய்யும் போது இந்த செயல்பாடு அழைக்கப்படுகிறது. செய்தி தானாகவே புதுப்பிக்கப்படுகிறது, ஆனால் கையொப்பத்திற்கு பணப்பையில் பயனர் ஒப்புதல் தேவை, மற்றும் தேவைப்படாவிட்டால் அதைக் கேட்க நாங்கள் விரும்பவில்லை.

```tsx
    const signature = await wallet.signMessage({
        account: fromAccount,
        message,
    })
```

பணப்பையிடம் [செய்தியில் கையொப்பமிடுமாறு](https://viem.sh/docs/accounts/local/signMessage) கேட்கவும்.

```tsx
    const hash = hashMessage(message)
```

செய்தித் துண்டியைப் பெறுங்கள். Noir குறியீட்டின் பிழைத்திருத்தத்திற்காக பயனருக்கு அதை வழங்குவது உதவியாக இருக்கும்.

```tsx
    const pubKey = await recoverPublicKey({
        hash,
        signature
    })
```

[பொது திறவுகோலைப் பெறுக](https://viem.sh/docs/utilities/recoverPublicKey). [Noir `ecrecover`](https://github.com/colinnielsen/ecrecover-noir) செயல்பாட்டிற்கு இது தேவைப்படுகிறது.

```tsx
    setSignature(signature)
    setHash(hash)
    setPubKey(pubKey)
```

நிலை மாறிகளை அமைக்கவும். இதைச் செய்வது கூறுகளை மீண்டும் வரைகிறது (`sign` செயல்பாடு வெளியேறிய பிறகு) மற்றும் பயனருக்குப் புதுப்பிக்கப்பட்ட மதிப்புகளைக் காட்டுகிறது.

```tsx
    let proverToml = `
```

`Prover.toml` க்கான உரை.

```tsx
message="${message}"

pubKeyX=${hexToArray(pubKey.slice(4,4+2*32))}
pubKeyY=${hexToArray(pubKey.slice(4+2*32))}
```

Viem எங்களுக்கு பொது திறவுகோலை 65-பைட் ஹெக்ஸாடெசிமல் சரமாக வழங்குகிறது. முதல் பைட் `0x04`, ஒரு பதிப்பு குறிப்பான். இதனைத் தொடர்ந்து பொது திறவுகோலின் `x` க்காக 32 பைட்டுகள் மற்றும் பின்னர் பொது திறவுகோலின் `y` க்காக 32 பைட்டுகள் உள்ளன.

இருப்பினும், Noir இந்தத் தகவலை இரண்டு-பைட் வரிசைகளாக, ஒன்று `x` க்காகவும் மற்றொன்று `y` க்காகவும் பெற எதிர்பார்க்கிறது. பூஜ்ஜிய-அறிவு ஆதாரத்தின் பகுதியாக இல்லாமல், வாடிக்கையாளரில் இங்கே அதைப் பகுப்பாய்வு செய்வது எளிது.

பொதுவாக பூஜ்ஜிய-அறிவில் இது நல்ல நடைமுறை என்பதை நினைவில் கொள்க. ஒரு பூஜ்ஜிய-அறிவு ஆதாரத்திற்குள் குறியீடு விலை உயர்ந்தது, எனவே பூஜ்ஜிய-அறிவு ஆதாரத்திற்கு வெளியே செய்யக்கூடிய எந்த செயலாக்கமும் பூஜ்ஜிய-அறிவு ஆதாரத்திற்கு வெளியே செய்யப்பட _வேண்டும்_.

```tsx
signature=${hexToArray(signature.slice(2,-2))}
```

கையொப்பமும் 65-பைட் ஹெக்ஸாடெசிமல் சரமாக வழங்கப்படுகிறது. இருப்பினும், கடைசி பைட் பொது திறவுகோலை மீட்க மட்டுமே அவசியம். பொது திறவுகோல் ஏற்கனவே Noir குறியீட்டிற்கு வழங்கப்பட்டிருப்பதால், கையொப்பத்தைச் சரிபார்க்க அது நமக்குத் தேவையில்லை, மற்றும் Noir குறியீடு அதைக் கோரவில்லை.

```tsx
${accounts.map(accountInProverToml).reduce((a,b) => a+b, "")}
`
```

கணக்குகளை வழங்கவும்.

```tsx
    setProverToml(proverToml)
  }

  return (
    <>
        <h2>Transfer</h2>
```

இது HTML (மிகவும் துல்லியமாக, [JSX](https://react.dev/learn/writing-markup-with-jsx)) கூறின் வடிவம்.

#### `server/noir/src/main.nr` {#server-noir-src-main-nr}

[இந்தக் கோப்பு](https://github.com/qbzzt/250911-zk-bank/blob/01-manual-zk/server/noir/src/main.nr) உண்மையான பூஜ்ஜிய-அறிவு குறியீடு.

```
use std::hash::pedersen_hash;
```

[பெடெர்சென் துண்டி](https://rya-sge.github.io/access-denied/2024/05/07/pedersen-hash-function/) [Noir நிலையான நூலகத்துடன்](https://noir-lang.org/docs/noir/standard_library/cryptographic_primitives/hashes#pedersen_hash) வழங்கப்படுகிறது. பூஜ்ஜிய-அறிவு ஆதாரங்கள் பொதுவாக இந்தத் துண்டி செயல்பாட்டைப் பயன்படுத்துகின்றன. [கணித சுற்றுகளுக்கு](https://rareskills.io/post/arithmetic-circuit) உள்ளே நிலையான துண்டி செயல்பாடுகளுடன் ஒப்பிடும்போது இது கணக்கிடுவது மிகவும் எளிது.

```
use keccak256::keccak256;
use dep::ecrecover;
```

இந்த இரண்டு செயல்பாடுகளும் வெளி நூலகங்கள், [`Nargo.toml`](https://github.com/qbzzt/250911-zk-bank/blob/01-manual-zk/server/noir/Nargo.toml) இல் வரையறுக்கப்பட்டுள்ளன. அவை அவற்றின் பெயர்களுக்கு ஏற்றவாறு துல்லியமாக உள்ளன, [keccak256 துண்டியை](https://emn178.github.io/online-tools/keccak_256.html) கணக்கிடும் ஒரு செயல்பாடு மற்றும் Ethereum கையொப்பங்களைச் சரிபார்த்து கையொப்பமிட்டவரின் Ethereum முகவரியை மீட்டெடுக்கும் ஒரு செயல்பாடு.

```
global ACCOUNT_NUMBER : u32 = 5;
```

Noir [Rust](https://www.rust-lang.org/) ஆல் ஈர்க்கப்பட்டது. இயல்பாக, மாறிகள் மாறிலிகளாகும். உலகளாவிய கட்டமைப்பு மாறிலிகளை நாங்கள் இப்படி வரையறுக்கிறோம். குறிப்பாக, `ACCOUNT_NUMBER` என்பது நாங்கள் சேமிக்கும் கணக்குகளின் எண்ணிக்கை.

`u<எண்>` எனப் பெயரிடப்பட்ட தரவு வகைகள் அந்த எண்ணிக்கையிலான பிட்கள், கையொப்பமிடப்படாதவை. ஆதரிக்கப்படும் வகைகள் `u8`, `u16`, `u32`, `u64`, மற்றும் `u128` மட்டுமே.

```
global FLAT_ACCOUNT_FIELDS : u32 = 2;
```

கீழே விளக்கப்பட்டுள்ளபடி, இந்த மாறி கணக்குகளின் பெடெர்சென் துண்டிக்குப் பயன்படுத்தப்படுகிறது.

```
global MESSAGE_LENGTH : u32 = 100;
```

மேலே விளக்கப்பட்டுள்ளபடி, செய்தி நீளம் நிலையானது. இது இங்கே குறிப்பிடப்பட்டுள்ளது.

```
global ASCII_MESSAGE_LENGTH : [u8; 3] = [0x31, 0x30, 0x30];
global HASH_BUFFER_SIZE : u32 = 26+3+MESSAGE_LENGTH;
```

[EIP-191 கையொப்பங்கள்](https://eips.ethereum.org/EIPS/eip-191) 26-பைட் முன்னொட்டுடன் ஒரு இடையகம், ASCII-இல் செய்தி நீளம், மற்றும் இறுதியாக செய்தி ஆகியவற்றைக் கோருகின்றன.

```
struct Account {
    balance: u128,
    address: Field,
    nonce: u32,
}
```

ஒரு கணக்கு பற்றி நாங்கள் சேமிக்கும் தகவல். [`புலம்`](https://noir-lang.org/docs/noir/concepts/data_types/fields) என்பது ஒரு எண், பொதுவாக 253 பிட்கள் வரை, இது பூஜ்ஜிய-அறிவு ஆதாரத்தை செயல்படுத்தும் [கணித சுற்றமைப்பில்](https://rareskills.io/post/arithmetic-circuit) நேரடியாக பயன்படுத்தப்படலாம். இங்கே நாங்கள் 160-பிட் Ethereum முகவரியைச் சேமிக்க `புலத்தைப்` பயன்படுத்துகிறோம்.

```
struct TransferTxn {
    from: Field,
    to: Field,
    amount: u128,
    nonce: u32
}
```

ஒரு இடமாற்றப் பரிவர்த்தனைக்காக நாங்கள் சேமிக்கும் தகவல்.

```
fn flatten_account(account: Account) -> [Field; FLAT_ACCOUNT_FIELDS] {
```

ஒரு செயல்பாட்டு வரையறை. அளவுரு `கணக்கு` தகவல். முடிவு `புலம்` மாறிகளின் வரிசையாகும், அதன் நீளம் `FLAT_ACCOUNT_FIELDS` ஆகும்.

```
    let flat = [
        account.address,
        ((account.balance << 32) + account.nonce.into()).into(),
    ];
```

வரிசையின் முதல் மதிப்பு கணக்கு முகவரி. இரண்டாவது இருப்பும் நான்ஸும் உள்ளடக்கியது. `.into()` அழைப்புகள் ஒரு எண்ணை அது இருக்க வேண்டிய தரவு வகைக்கு மாற்றுகின்றன. `account.nonce` ஒரு `u32` மதிப்பாகும், ஆனால் அதை `account.balance « 32` உடன் சேர்க்க, ஒரு `u128` மதிப்பு, அது `u128` ஆக இருக்க வேண்டும். அதுதான் முதல் `.into()`. இரண்டாவது `u128` முடிவை ஒரு `புலமாக` மாற்றுகிறது, அதனால் அது வரிசையில் பொருந்தும்.

```
    flat
}
```

Noir இல், செயல்பாடுகள் இறுதியில் மட்டுமே ஒரு மதிப்பைத் திருப்ப முடியும் (முன்பே திருப்புதல் இல்லை). திருப்பு மதிப்பைக் குறிப்பிட, நீங்கள் அதை செயல்பாட்டின் மூடும் அடைப்புக்குறிக்கு முன் மதிப்பீடு செய்ய வேண்டும்.

```
fn flatten_accounts(accounts: [Account; ACCOUNT_NUMBER]) -> [Field; FLAT_ACCOUNT_FIELDS*ACCOUNT_NUMBER] {
```

இந்த செயல்பாடு கணக்குகள் வரிசையை ஒரு `புலம்` வரிசையாக மாற்றுகிறது, இது ஒரு பீட்டர்சன் துண்டியின் உள்ளீடாகப் பயன்படுத்தப்படலாம்.

```
    let mut flat: [Field; FLAT_ACCOUNT_FIELDS*ACCOUNT_NUMBER] = [0; FLAT_ACCOUNT_FIELDS*ACCOUNT_NUMBER];
```

ஒரு மாறக்கூடிய மாறியைக் குறிப்பிடுவது இப்படித்தான், அதாவது, ஒரு _மாறிலி அல்ல_. Noir இல் உள்ள மாறிகள் எப்போதும் ஒரு மதிப்பைக் கொண்டிருக்க வேண்டும், எனவே நாங்கள் இந்த மாறியை அனைத்து பூஜ்ஜியங்களுக்கும் ஆரம்பிக்கிறோம்.

```
    for i in 0..ACCOUNT_NUMBER {
```

இது ஒரு `for` சுழற்சி. எல்லைகள் மாறிலிகள் என்பதை நினைவில் கொள்ளவும். Noir சுழற்சிகள் அவற்றின் எல்லைகளை தொகுக்கும் நேரத்தில் அறிய வேண்டும். காரணம், கணித சுற்றுகள் பாய்வு கட்டுப்பாட்டை ஆதரிக்காது. ஒரு `for` சுழற்சியைச் செயலாக்கும்போது, தொகுப்பி வெறுமனே குறியீட்டை பல முறை உள்ளே வைக்கிறது, ஒவ்வொரு மறு செய்கைக்கும் ஒன்று.

```
        let fields = flatten_account(accounts[i]);
        for j in 0..FLAT_ACCOUNT_FIELDS {
            flat[i*FLAT_ACCOUNT_FIELDS + j] = fields[j];
        }
    }

    flat
}

fn hash_accounts(accounts: [Account; ACCOUNT_NUMBER]) -> Field {
    pedersen_hash(flatten_accounts(accounts))
}
```

இறுதியாக, நாங்கள் கணக்குகள் வரிசையைத் துண்டிக்கும் செயல்பாட்டிற்கு வந்தோம்.

```
fn find_account(accounts: [Account; ACCOUNT_NUMBER], address: Field) -> u32 {
    let mut account : u32 = ACCOUNT_NUMBER;

    for i in 0..ACCOUNT_NUMBER {
        if accounts[i].address == address {
            account = i;
        }
    }

```

இந்த செயல்பாடு ஒரு குறிப்பிட்ட முகவரியுடன் கணக்கைக் கண்டறிகிறது. இந்த செயல்பாடு நிலையான குறியீட்டில் மிகவும் திறமையற்றதாக இருக்கும், ஏனெனில் இது முகவரியைக் கண்டறிந்த பிறகும் அனைத்து கணக்குகளிலும் மீண்டும் மீண்டும் செயல்படுகிறது.

இருப்பினும், பூஜ்ஜிய-அறிவு ஆதாரங்களில், பாய்வு கட்டுப்பாடு இல்லை. நாங்கள் எப்போதாவது ஒரு நிபந்தனையைச் சரிபார்க்க வேண்டும் என்றால், ஒவ்வொரு முறையும் அதைச் சரிபார்க்க வேண்டும்.

`if` கூற்றுகளுடன் இதே போன்ற ஒன்று நிகழ்கிறது. மேலே உள்ள சுழற்சியில் உள்ள `if` கூற்று இந்த கணித கூற்றுகளுக்கு மொழிபெயர்க்கப்பட்டுள்ளது.

_condition<sub>result</sub> = accounts[i].address == address_ // அவை சமமாக இருந்தால் ஒன்று, இல்லையெனில் பூஜ்ஜியம்

_account<sub>new</sub> = condition<sub>result</sub>\*i + (1-condition<sub>result</sub>)\*account<sub>old</sub>_

```rust
    assert (account < ACCOUNT_NUMBER, f"{address} does not have an account");

    account
}
```

[`assert`](https://noir-lang.org/docs/dev/noir/concepts/assert) செயல்பாடு உறுதிப்படுத்தல் தவறாக இருந்தால் பூஜ்ஜிய-அறிவு ஆதாரத்தை செயலிழக்கச் செய்கிறது. இந்த வழக்கில், தொடர்புடைய முகவரியுடன் ஒரு கணக்கைக் கண்டுபிடிக்க முடியாவிட்டால். முகவரியைப் புகாரளிக்க, நாங்கள் ஒரு [வடிவமைப்புச் சரத்தைப்](https://noir-lang.org/docs/noir/concepts/data_types/strings#format-strings) பயன்படுத்துகிறோம்.

```rust
fn apply_transfer_txn(accounts: [Account; ACCOUNT_NUMBER], txn: TransferTxn) -> [Account; ACCOUNT_NUMBER] {
```

இந்த செயல்பாடு ஒரு இடமாற்றப் பரிவர்த்தனையைப் பயன்படுத்துகிறது மற்றும் புதிய கணக்குகள் வரிசையைத் திருப்புகிறது.

```rust
    let from = find_account(accounts, txn.from);
    let to = find_account(accounts, txn.to);

    let (txnFrom, txnAmount, txnNonce, accountNonce) =
        (txn.from, txn.amount, txn.nonce, accounts[from].nonce);
```

Noir இல் ஒரு வடிவமைப்புச் சரத்திற்குள் கட்டமைப்பு உறுப்புகளை அணுக முடியாது, எனவே நாங்கள் ஒரு பயன்படுத்தக்கூடிய நகலை உருவாக்குகிறோம்.

```rust
    assert (accounts[from].balance >= txn.amount,
        f"{txnFrom} does not have {txnAmount} finney");

    assert (accounts[from].nonce == txn.nonce,
        f"Transaction has nonce {txnNonce}, but the account is expected to use {accountNonce}");
```

இவை ஒரு பரிவர்த்தனையை செல்லுபடியற்றதாக்கக்கூடிய இரண்டு நிபந்தனைகள்.

```rust
    let mut newAccounts = accounts;

    newAccounts[from].balance -= txn.amount;
    newAccounts[from].nonce += 1;
    newAccounts[to].balance += txn.amount;

    newAccounts
}
```

புதிய கணக்குகள் வரிசையை உருவாக்கி பின்னர் அதைத் திருப்பவும்.

```rust
fn readAddress(messageBytes: [u8; MESSAGE_LENGTH]) -> Field
```

இந்த செயல்பாடு செய்தியிலிருந்து முகவரியைப் படிக்கிறது.

```rust
{
    let mut result : Field = 0;

    for i in 7..47 {
```

முகவரி எப்போதும் 20 பைட்டுகள் (அதாவது 40 ஹெக்ஸாடெசிமல் இலக்கங்கள்) நீளமானது, மற்றும் எழுத்து #7 இல் தொடங்குகிறது.

```rust
        result *= 0x10;
        if messageBytes[i] >= 48 & messageBytes[i] <= 57 {    // 0-9
            result += (messageBytes[i]-48).into();
        }
        if messageBytes[i] >= 65 & messageBytes[i] <= 70 {    // A-F
            result += (messageBytes[i]-65+10).into()
        }
        if messageBytes[i] >= 97 & messageBytes[i] <= 102 {   // a-f
            result += (messageBytes[i]-97+10).into()
        }        
    }    

    result
}

fn readAmountAndNonce(messageBytes: [u8; MESSAGE_LENGTH]) -> (u128, u32)
```

செய்தியிலிருந்து தொகையையும் நான்ஸையும் படிக்கவும்.

```rust
{
    let mut amount : u128 = 0;
    let mut nonce: u32 = 0;
    let mut stillReadingAmount: bool = true;
    let mut lookingForNonce: bool = false;
    let mut stillReadingNonce: bool = false;
```

செய்தியில், முகவரிக்குப் பிறகு வரும் முதல் எண் ஃபின்னி (அதாவது, ஒரு ETH இன் ஆயிரத்தில் ஒரு பங்கு) இடமாற்றம் செய்வதற்கான அளவு. இரண்டாவது எண் நான்ஸ். அவற்றுக்கிடையேயான எந்த உரையும் புறக்கணிக்கப்படுகிறது.

```rust
    for i in 48..MESSAGE_LENGTH {
        if messageBytes[i] >= 48 & messageBytes[i] <= 57 {    // 0-9
            let digit = (messageBytes[i]-48);

            if stillReadingAmount {
                amount = amount*10 + digit.into();
            }

            if lookingForNonce {    // We just found it
                stillReadingNonce = true;
                lookingForNonce = false;
            }

            if stillReadingNonce {
                nonce = nonce*10 + digit.into();
            }
        } else {
            if stillReadingAmount {
                stillReadingAmount = false;
                lookingForNonce = true;
            }
            if stillReadingNonce {
                stillReadingNonce = false;
            }
        }
    }

    (amount, nonce)
}
```

ஒரு [டுபிளைத்](https://noir-lang.org/docs/noir/concepts/data_types/tuples) திருப்புவது, ஒரு செயல்பாட்டிலிருந்து பல மதிப்புகளைத் திருப்ப Noir வழி.

```rust
fn readTransferTxn(message: str<MESSAGE_LENGTH>) -> TransferTxn 
{
    let mut txn: TransferTxn = TransferTxn { from: 0, to: 0, amount:0, nonce:0 };
    let messageBytes = message.as_bytes();

    txn.to = readAddress(messageBytes);
    let (amount, nonce) = readAmountAndNonce(messageBytes);
    txn.amount = amount;
    txn.nonce = nonce;

    txn
}
```

இந்த செயல்பாடு செய்தியை பைட்டுகளாக மாற்றுகிறது, பின்னர் அளவுகளை ஒரு `TransferTxn` ஆக மாற்றுகிறது.

```rust
// Viem's hashMessage-க்கு சமமானது
// https://viem.sh/docs/utilities/hashMessage#hashmessage
fn hashMessage(message: str<MESSAGE_LENGTH>) -> [u8;32] {
```

கணக்குகளுக்கு பெடெர்சன் துண்டியைப் பயன்படுத்த முடிந்தது, ஏனெனில் அவை பூஜ்ஜிய-அறிவு ஆதாரத்திற்குள் மட்டுமே துண்டிக்கப்படுகின்றன. இருப்பினும், இந்த குறியீட்டில் நாங்கள் செய்தியின் கையொப்பத்தைச் சரிபார்க்க வேண்டும், இது உலாவியால் உருவாக்கப்படுகிறது. அதற்கு, நாங்கள் Ethereum கையொப்பமிடும் வடிவத்தை [EIP 191](https://eips.ethereum.org/EIPS/eip-191) இல் பின்பற்ற வேண்டும். இதன் பொருள், ஒரு நிலையான முன்னொட்டு, ASCII-இல் செய்தி நீளம், மற்றும் செய்தி ஆகியவற்றைக் கொண்ட ஒரு ஒருங்கிணைந்த இடையகத்தை உருவாக்க வேண்டும், மற்றும் அதைத் துண்டிக்க Ethereum நிலையான keccak256 ஐப் பயன்படுத்த வேண்டும்.

```rust
    // ASCII முன்னொட்டு
    let prefix_bytes = [
        0x19, // \x19
        0x45, // 'E'
        0x74, // 't'
        0x68, // 'h'
        0x65, // 'e'
        0x72, // 'r'
        0x65, // 'e'
        0x75, // 'u'
        0x6D, // 'm'
        0x20, // ' '
        0x53, // 'S'
        0x69, // 'i'
        0x67, // 'g'
        0x6E, // 'n'
        0x65, // 'e'
        0x64, // 'd'
        0x20, // ' '
        0x4D, // 'M'
        0x65, // 'e'
        0x73, // 's'
        0x73, // 's'
        0x61, // 'a'
        0x67, // 'g'
        0x65, // 'e'
        0x3A, // ':'
        0x0A  // '\n'
    ];
```

ஒரு செயலி பயனரிடம் ஒரு செய்தியில் கையொப்பமிடுமாறு கேட்கும் நிகழ்வுகளைத் தவிர்க்க, அது ஒரு பரிவர்த்தனையாகவோ அல்லது வேறு சில நோக்கங்களுக்காகவோ பயன்படுத்தப்படலாம், EIP 191 அனைத்து கையொப்பமிடப்பட்ட செய்திகளும் 0x19 எழுத்துடன் (ஒரு செல்லுபடியான ASCII எழுத்து அல்ல) தொடங்கி `Ethereum Signed Message:` மற்றும் ஒரு புதிய வரியுடன் தொடங்கும் என்று குறிப்பிடுகிறது.

```rust
    let mut buffer: [u8; HASH_BUFFER_SIZE] = [0u8; HASH_BUFFER_SIZE];
    for i in 0..26 {
        buffer[i] = prefix_bytes[i];
    }

    let messageBytes : [u8; MESSAGE_LENGTH] = message.as_bytes();

    if MESSAGE_LENGTH <= 9 {
        for i in 0..1 {
            buffer[i+26] = ASCII_MESSAGE_LENGTH[i];
        }

        for i in 0..MESSAGE_LENGTH {
            buffer[i+26+1] = messageBytes[i];
        }
    }

    if MESSAGE_LENGTH >= 10 & MESSAGE_LENGTH <= 99 {
        for i in 0..2 {
            buffer[i+26] = ASCII_MESSAGE_LENGTH[i];
        }

        for i in 0..MESSAGE_LENGTH {
            buffer[i+26+2] = messageBytes[i];
        }
    }

    if MESSAGE_LENGTH >= 100 {
        for i in 0..3 {
            buffer[i+26] = ASCII_MESSAGE_LENGTH[i];
        }

        for i in 0..MESSAGE_LENGTH {
            buffer[i+26+3] = messageBytes[i];
        }
    }

    assert(MESSAGE_LENGTH < 1000, "Messages whose length is over three digits are not supported");
```

999 வரையிலான செய்தி நீளங்களைக் கையாளுங்கள் மற்றும் அது அதிகமாக இருந்தால் தோல்வியடையச் செய்யுங்கள். செய்தி நீளம் ஒரு மாறிலியாக இருந்தாலும், நான் இந்த குறியீட்டைச் சேர்த்தேன், ஏனெனில் இது அதை மாற்றுவதை எளிதாக்குகிறது. ஒரு உற்பத்தி அமைப்பில், நீங்கள் ஒருவேளை சிறந்த செயல்திறனுக்காக `MESSAGE_LENGTH` மாறாது என்று கருதுவீர்கள்.

```rust
    keccak256::keccak256(buffer, HASH_BUFFER_SIZE)
}
```

Ethereum நிலையான `keccak256` செயல்பாட்டைப் பயன்படுத்தவும்.

```rust
fn signatureToAddressAndHash(
        message: str<MESSAGE_LENGTH>, 
        pubKeyX: [u8; 32],
        pubKeyY: [u8; 32],
        signature: [u8; 64]
    ) -> (Field, Field, Field)   // address, first 16 bytes of hash, last 16 bytes of hash        
{
```

இந்த செயல்பாடு கையொப்பத்தைச் சரிபார்க்கிறது, இதற்கு செய்தித் துண்டி தேவை. பின்னர் அது கையொப்பமிட்ட முகவரியையும் செய்தித் துண்டையும் நமக்கு வழங்குகிறது. செய்தித் துண்டி இரண்டு `புலம்` மதிப்புகளில் வழங்கப்படுகிறது, ஏனெனில் அவை பைட் வரிசையை விட நிரலின் மீதமுள்ள பகுதிகளில் பயன்படுத்த எளிதானவை.

நாங்கள் இரண்டு `புலம்` மதிப்புகளைப் பயன்படுத்த வேண்டும், ஏனெனில் புலம் கணக்கீடுகள் ஒரு பெரிய எண்ணின் [மாடுலோ](https://en.wikipedia.org/wiki/Modulo)வில் செய்யப்படுகின்றன, ஆனால் அந்த எண் பொதுவாக 256 பிட்களை விடக் குறைவாக இருக்கும் (இல்லையெனில் EVM-இல் அந்த கணக்கீடுகளைச் செய்வது கடினமாக இருக்கும்).

```rust
    let hash = hashMessage(message);

    let mut (hash1, hash2) = (0,0);

    for i in 0..16 {
        hash1 = hash1*256 + hash[31-i].into();
        hash2 = hash2*256 + hash[15-i].into();
    }
```

`hash1` மற்றும் `hash2` ஐ மாறக்கூடிய மாறிகளாகக் குறிப்பிடுங்கள், மற்றும் துண்டியை பைட் பைட்டாக அவற்றில் எழுதவும்.

```rust
    (
        ecrecover::ecrecover(pubKeyX, pubKeyY, signature, hash), 
```

இது [Solidity-யின் `ecrecover`](https://docs.soliditylang.org/en/v0.8.30/cheatsheet.html#mathematical-and-cryptographic-functions) க்கு ஒத்ததாகும், இரண்டு முக்கியமான வேறுபாடுகளுடன்:

- கையொப்பம் செல்லுபடியாகாவிட்டால், அழைப்பு `assert` இல் தோல்வியடைந்து நிரல் நிறுத்தப்படும்.
- பொது திறவுகோல் கையொப்பம் மற்றும் துண்டியிலிருந்து மீட்கப்பட முடியும் என்றாலும், இது வெளிப்புறமாக செய்யக்கூடிய செயலாக்கம் ஆகும், எனவே, பூஜ்ஜிய-அறிவு ஆதாரத்திற்குள் செய்வது மதிப்புக்குரியதல்ல. யாராவது இங்கே எங்களை ஏமாற்ற முயன்றால், கையொப்ப சரிபார்ப்பு தோல்வியடையும்.

```rust
        hash1,
        hash2
    )
}

fn main(
        accounts: [Account; ACCOUNT_NUMBER],
        message: str<MESSAGE_LENGTH>,
        pubKeyX: [u8; 32],
        pubKeyY: [u8; 32],
        signature: [u8; 64],
    ) -> pub (
        Field,  // Hash of old accounts array
        Field,  // Hash of new accounts array
        Field,  // First 16 bytes of message hash
        Field,  // Last 16 bytes of message hash
    )
```

இறுதியாக, நாங்கள் `main` செயல்பாட்டை அடைகிறோம். ஒரு பரிவர்த்தனை கணக்குகளின் துண்டியை பழைய மதிப்பிலிருந்து புதிய மதிப்பிற்குச் செல்லுபடியாக மாற்றுகிறது என்பதை நாங்கள் நிரூபிக்க வேண்டும். மேலும், இந்த குறிப்பிட்ட பரிவர்த்தனைத் துண்டி உள்ளது என்பதை நாங்கள் நிரூபிக்க வேண்டும், அதனால் அதை அனுப்பியவர் தங்கள் பரிவர்த்தனை செயலாக்கப்பட்டது என்பதை அறிவார்கள்.

```rust
{
    let mut txn = readTransferTxn(message);
```

`txn` மாறக்கூடியதாக இருக்க வேண்டும், ஏனெனில் நாங்கள் செய்தியிலிருந்து இருந்து முகவரியைப் படிப்பதில்லை, கையொப்பத்திலிருந்து அதைப் படிக்கிறோம்.

```rust
    let (fromAddress, txnHash1, txnHash2) = signatureToAddressAndHash(
        message,
        pubKeyX,
        pubKeyY,
        signature);

    txn.from = fromAddress;

    let newAccounts = apply_transfer_txn(accounts, txn);

    (
        hash_accounts(accounts),
        hash_accounts(newAccounts),
        txnHash1,
        txnHash2
    )
}
```

### நிலை 2 - ஒரு சேவையகத்தைச் சேர்த்தல் {#stage-2}

இரண்டாம் கட்டத்தில், உலாவியிலிருந்து இடமாற்றப் பரிவர்த்தனைகளைப் பெற்றுச் செயல்படுத்தும் ஒரு சேவையகத்தைச் சேர்க்கிறோம்.

அதைச் செயலில் காண:

1. Vite இயங்கினால் அதை நிறுத்தவும்.

2. சேவையகத்தை உள்ளடக்கிய கிளையைப் பதிவிறக்கி, தேவையான அனைத்து தொகுதிகளும் உங்களிடம் இருப்பதை உறுதிப்படுத்தவும்.

   ```sh
   git checkout 02-add-server
   cd client
   npm install
   cd ../server
   npm install
   ```

   Noir குறியீட்டைத் தொகுக்கத் தேவையில்லை, இது நீங்கள் நிலை 1 க்காகப் பயன்படுத்திய குறியீட்டைப் போன்றது.

3. சேவையகத்தைத் தொடங்கவும்.

   ```sh
   npm run start
   ```

4. தனி கட்டளை-வரி சாளரத்தில், உலாவி குறியீட்டை வழங்க Vite ஐ இயக்கவும்.

   ```sh
   cd client
   npm run dev
   ```

5. வாடிக்கையாளர் குறியீட்டிற்கு [http://localhost:5173](http://localhost:5173) இல் உலாவவும்

6. ஒரு பரிவர்த்தனையை வழங்குவதற்கு முன், நீங்கள் நான்ஸையும், நீங்கள் அனுப்பக்கூடிய தொகையையும் அறிய வேண்டும். இந்த தகவலைப் பெற, **கணக்குத் தரவைப் புதுப்பிக்கவும்** என்பதைக் கிளிக் செய்து செய்தியில் கையொப்பமிடுங்கள்.

   எங்களுக்கு இங்கே ஒரு தர்மசங்கடம் உள்ளது. ஒருபுறம், மீண்டும் பயன்படுத்தக்கூடிய ஒரு செய்தியில் கையொப்பமிட நாங்கள் விரும்பவில்லை ([மீண்டும் தாக்குதல்](https://en.wikipedia.org/wiki/Replay_attack)), இதற்காகத்தான் நாங்கள் முதலில் ஒரு நான்ஸை விரும்புகிறோம். இருப்பினும், எங்களுக்கு இன்னும் ஒரு நான்ஸ் இல்லை. ஒருமுறை மட்டுமே பயன்படுத்தக்கூடிய ஒரு நான்ஸைத் தேர்ந்தெடுப்பதே தீர்வு, அது இருபுறமும் ஏற்கனவே உள்ளது, தற்போதைய நேரம் போன்றவை.

   இந்தத் தீர்வுடன் உள்ள சிக்கல் என்னவென்றால், நேரம் சரியாக ஒத்திசைக்கப்படாமல் இருக்கலாம். எனவே அதற்கு பதிலாக, ஒவ்வொரு நிமிடமும் மாறும் ஒரு மதிப்பில் கையொப்பமிடுகிறோம். இதன் பொருள், மீண்டும் தாக்குதல்களுக்கு எங்கள் பாதிப்புக்கான சாளரம் அதிகபட்சம் ஒரு நிமிடம். உற்பத்தியில் கையொப்பமிடப்பட்ட கோரிக்கை TLS ஆல் பாதுகாக்கப்படும் என்பதையும், சுரங்கப்பாதையின் மறுபக்கம்---சேவையகம்---இருப்பு மற்றும் நான்ஸை ஏற்கனவே வெளியிட முடியும் (அது வேலை செய்ய அவற்றை அறிந்திருக்க வேண்டும்) என்பதையும் கருத்தில் கொண்டு, இது ஒரு ஏற்றுக்கொள்ளக்கூடிய ஆபத்து.

7. உலாவி இருப்பு மற்றும் நான்ஸைத் திரும்பப் பெற்றவுடன், அது இடமாற்றப் படிவத்தைக் காட்டுகிறது. இலக்கு முகவரியையும் தொகையையும் தேர்ந்தெடுத்து **இடமாற்று** என்பதைக் கிளிக் செய்யவும். இந்தக் கோரிக்கையில் கையொப்பமிடவும்.

8. இடமாற்றத்தைக் காண, **கணக்குத் தரவைப் புதுப்பிக்கவும்** அல்லது நீங்கள் சேவையகத்தை இயக்கும் சாளரத்தில் பார்க்கவும். சேவையகம் ஒவ்வொரு முறை மாறும்போதும் நிலையைப் பதிவு செய்கிறது.

    ```
    ori@CryptoDocGuy:~/x/250911-zk-bank/server$ npm run start
    
    > server@1.0.0 start
    > node --experimental-json-modules index.mjs
    
    Listening on port 3000
    Txn send 0x90F79bf6EB2c4f870365E785982E1f101E93b906 36000 finney (milliEth) 0 processed
    New state:
    0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 has 64000 (1)
    0x70997970C51812dc3A010C7d01b50e0d17dc79C8 has 100000 (0)
    0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC has 100000 (0)
    0x90F79bf6EB2c4f870365E785982E1f101E93b906 has 136000 (0)
    0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65 has 100000 (0)
    Txn send 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 7200 finney (milliEth) 1 processed
    New state:
    0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 has 56800 (2)
    0x70997970C51812dc3A010C7d01b50e0d17dc79C8 has 107200 (0)
    0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC has 100000 (0)
    0x90F79bf6EB2c4f870365E785982E1f101E93b906 has 136000 (0)
    0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65 has 100000 (0)
    Txn send 0x90F79bf6EB2c4f870365E785982E1f101E93b906 3000 finney (milliEth) 2 processed
    New state:
    0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 has 53800 (3)
    0x70997970C51812dc3A010C7d01b50e0d17dc79C8 has 107200 (0)
    0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC has 100000 (0)
    0x90F79bf6EB2c4f870365E785982E1f101E93b906 has 139000 (0)
    0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65 has 100000 (0)
    ```

#### `server/index.mjs` {#server-index-mjs-1}

[இந்தக் கோப்பு](https://github.com/qbzzt/250911-zk-bank/blob/02-add-server/server/index.mjs) சேவையகச் செயல்முறையைக் கொண்டுள்ளது, மற்றும் [`main.nr`](https://github.com/qbzzt/250911-zk-bank/blob/02-add-server/server/noir/src/main.nr) இல் உள்ள Noir குறியீட்டுடன் தொடர்பு கொள்கிறது. இங்கே சுவாரஸ்யமான பகுதிகளின் விளக்கம் உள்ளது.

```js
import { Noir } from '@noir-lang/noir_js'
```

[noir.js](https://www.npmjs.com/package/@noir-lang/noir_js) நூலகம் ஜாவாஸ்கிரிப்ட் குறியீடு மற்றும் Noir குறியீட்டிற்கு இடையில் இடைமுகமாக உள்ளது.

```js
const circuit = JSON.parse(await fs.readFile("./noir/target/zkBank.json"))
const noir = new Noir(circuit)
```

கணித சுற்றை---முந்தைய கட்டத்தில் நாங்கள் உருவாக்கிய தொகுக்கப்பட்ட Noir நிரல்---ஏற்றி, அதைச் செயல்படுத்தத் தயாராகுங்கள்.

```js
// கையொப்பமிடப்பட்ட கோரிக்கையின் பதிலில் மட்டுமே கணக்குத் தகவலை வழங்குகிறோம்
const accountInformation = async signature => {
    const fromAddress = await recoverAddress({
        hash: hashMessage("Get account data " + Math.floor((new Date().getTime())/60000)),
        signature
    })
```

கணக்குத் தகவலை வழங்க, எங்களுக்கு கையொப்பம் மட்டுமே தேவை. காரணம் என்னவென்றால், செய்தி என்னவாக இருக்கும் என்பது எங்களுக்கு ஏற்கனவே தெரியும், எனவே செய்தித் துண்டியும் தெரியும்.

```js
const processMessage = async (message, signature) => {
```

ஒரு செய்தியைச் செயலாக்கி, அது குறியீடாக்கிய பரிவர்த்தனையைச் செயல்படுத்தவும்.

```js
    // பொதுத் திறவுகோலைப் பெறவும்
    const pubKey = await recoverPublicKey({
        hash,
        signature
    })
```

இப்போது நாங்கள் சேவையகத்தில் ஜாவாஸ்கிரிப்ட்டை இயக்குவதால், வாடிக்கையாளரில் இல்லாமல் பொதுத் திறவுகோலை அங்கே மீட்டெடுக்கலாம்.

```js
    let noirResult
    try {
        noirResult = await noir.execute({
            message,
            signature: signature.slice(2,-2).match(/.{2}/g).map(x => `0x${x}`),
            pubKeyX,
            pubKeyY,
            accounts: Accounts
        })
```

`noir.execute` Noir நிரலை இயக்குகிறது. அளவுருக்கள் [`Prover.toml`](https://github.com/qbzzt/250911-zk-bank/blob/01-manual-zk/server/noir/Prover.toml) இல் வழங்கப்பட்டவற்றுக்குச் சமமானவை. நீண்ட மதிப்புகள் ஹெக்ஸாடெசிமல் சரங்களின் வரிசையாக (`["0x60", "0xA7"]`) வழங்கப்படுகின்றன என்பதை நினைவில் கொள்ளவும், Viem செய்வது போல ஒரு பெரிய ஹெக்ஸாடெசிமல் மதிப்பாக (`0x60A7`) அல்ல.

```js
    } catch (err) {
        console.log(`Noir error: ${err}`)
        throw Error("Invalid transaction, not processed")
    }
```

பிழை இருந்தால், அதைப் பிடித்து, எளிமைப்படுத்தப்பட்ட பதிப்பை வாடிக்கையாளருக்கு அனுப்பவும்.

```js
    Accounts[fromAccountNumber].nonce++
    Accounts[fromAccountNumber].balance -= amount
    Accounts[toAccountNumber].balance += amount
```

பரிவர்த்தனையைப் பயன்படுத்தவும். நாங்கள் அதை ஏற்கனவே Noir குறியீட்டில் செய்தோம், ஆனால் முடிவை அங்கிருந்து பிரித்தெடுப்பதை விட இங்கே மீண்டும் செய்வது எளிது.

```js
let Accounts = [
    {
        address: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
        balance: 5000,
        nonce: 0,
    },
```

ஆரம்ப `கணக்குகள்` கட்டமைப்பு.

### நிலை 3 - Ethereum ஸ்மார்ட் ஒப்பந்தங்கள் {#stage-3}

1. சேவையகம் மற்றும் வாடிக்கையாளர் செயல்முறைகளை நிறுத்தவும்.

2. ஸ்மார்ட் ஒப்பந்தங்களுடன் கிளையைப் பதிவிறக்கி, தேவையான அனைத்து தொகுதிகளும் உங்களிடம் இருப்பதை உறுதிப்படுத்தவும்.

   ```sh
   git checkout 03-smart-contracts
   cd client
   npm install
   cd ../server
   npm install
   ```

3. `anvil` ஐ தனி கட்டளை-வரி சாளரத்தில் இயக்கவும்.

4. சரிபார்ப்புத் திறவுகோல் மற்றும் சாலிடிட்டி சரிபார்ப்பியை உருவாக்கவும், பின்னர் சரிபார்ப்புக் குறியீட்டை Solidity திட்டத்திற்கு நகலெடுக்கவும்.

   ```sh
   cd noir
   bb write_vk -b ./target/zkBank.json -o ./target --oracle_hash keccak
   bb write_solidity_verifier -k ./target/vk -o ./target/Verifier.sol
   cp target/Verifier.sol ../../smart-contracts/src
   ```

5. ஸ்மார்ட் ஒப்பந்தங்களுக்குச் சென்று `anvil` பிளாக்செயினைப் பயன்படுத்த சூழல் மாறிகளை அமைக்கவும்.

   ```sh
   cd ../../smart-contracts
   export ETH_RPC_URL=http://localhost:8545
   ETH_PRIVATE_KEY=ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
   ```

6. `Verifier.sol` ஐப் பயன்படுத்தவும் மற்றும் முகவரியை ஒரு சூழல் மாறியில் சேமிக்கவும்.

   ```sh
   VERIFIER_ADDRESS=`forge create src/Verifier.sol:HonkVerifier --private-key $ETH_PRIVATE_KEY --optimize --broadcast | awk '/Deployed to:/ {print $3}'`
   echo $VERIFIER_ADDRESS
   ```

7. `ZkBank` ஒப்பந்தத்தைப் பயன்படுத்தவும்.

   ```sh
   ZKBANK_ADDRESS=`forge create ZkBank --private-key $ETH_PRIVATE_KEY --broadcast --constructor-args $VERIFIER_ADDRESS 0x199aa62af8c1d562a6ec96e66347bf3240ab2afb5d022c895e6bf6a5e617167b | awk '/Deployed to:/ {print $3}'`
   echo $ZKBANK_ADDRESS
   ```

   `0x199..67b` மதிப்பு `கணக்குகள்` இன் ஆரம்ப நிலையின் பெடர்சன் துண்டி. `server/index.mjs` இல் இந்த ஆரம்ப நிலையை நீங்கள் மாற்றினால், பூஜ்ஜிய-அறிவு ஆதாரத்தால் அறிவிக்கப்பட்ட ஆரம்பத் துண்டியைப் பார்க்க ஒரு பரிவர்த்தனையை இயக்கலாம்.

8. சேவையகத்தை இயக்கவும்.

   ```sh
   cd ../server
   npm run start
   ```

9. வாடிக்கையாளரை வேறு கட்டளை-வரி சாளரத்தில் இயக்கவும்.

   ```sh
   cd client
   npm run dev
   ```

10. சில பரிவர்த்தனைகளை இயக்கவும்.

11. ஆன்செயினில் நிலை மாறியுள்ளதா என்பதைச் சரிபார்க்க, சேவையகச் செயல்முறையை மீண்டும் தொடங்கவும். பரிவர்த்தனைகளில் உள்ள அசல் துண்டி மதிப்பு ஆன்செயினில் சேமிக்கப்பட்டுள்ள துண்டி மதிப்பிலிருந்து வேறுபடுவதால், `ZkBank` இனி பரிவர்த்தனைகளை ஏற்காது என்பதைப் பார்க்கவும்.

    இது எதிர்பார்க்கப்படும் பிழை வகை.

    ```
    ori@CryptoDocGuy:~/x/250911-zk-bank/server$ npm run start

    > server@1.0.0 start
    > node --experimental-json-modules index.mjs

    Listening on port 3000
    Verification error: ContractFunctionExecutionError: The contract function "processTransaction" reverted with the following reason:
    Wrong old state hash

    Contract Call:
        address:   0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
        function:  processTransaction(bytes _proof, bytes32[] _publicInputs)
        args:                        (0x0000000000000000000000000000000000000000000000042ab5d6d1986846cf00000000000000000000000000000000000000000000000b75c020998797da7800000000000000000000000000000000000000000000000
    ```

#### `server/index.mjs` {#server-index-mjs-2}

இந்தக் கோப்பில் உள்ள மாற்றங்கள் பெரும்பாலும் உண்மையான ஆதாரத்தை உருவாக்கி அதை ஆன்செயினில் சமர்ப்பிப்பது தொடர்பானது.

```js
import { exec } from 'child_process'
import util from 'util'

const execPromise = util.promisify(exec)
```

ஆன்செயினுக்கு அனுப்ப உண்மையான ஆதாரத்தை உருவாக்க [பார்ரெட்டன்பெர்க் தொகுப்பைப்](https://github.com/AztecProtocol/aztec-packages/tree/next/barretenberg) பயன்படுத்த வேண்டும். கட்டளை-வரி இடைமுகத்தை (`bb`) இயக்குவதன் மூலம் அல்லது [ஜாவாஸ்கிரிப்ட் நூலகத்தைப், `bb.js`](https://www.npmjs.com/package/@aztec/bb.js) பயன்படுத்துவதன் மூலம் இந்தத் தொகுப்பைப் பயன்படுத்தலாம். ஜாவாஸ்கிரிப்ட் நூலகம் குறியீட்டை இயல்பாக இயக்குவதை விட மிகவும் மெதுவாக உள்ளது, எனவே நாங்கள் இங்கே கட்டளை-வரியைப் பயன்படுத்த [`exec`](https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback) ஐப் பயன்படுத்துகிறோம்.

`bb.js` ஐப் பயன்படுத்த நீங்கள் முடிவு செய்தால், நீங்கள் பயன்படுத்தும் Noir பதிப்பிற்கு இணக்கமான பதிப்பைப் பயன்படுத்த வேண்டும் என்பதை நினைவில் கொள்ளவும். எழுதும் நேரத்தில், தற்போதைய Noir பதிப்பு (1.0.0-beta.11) `bb.js` பதிப்பு 0.87 ஐப் பயன்படுத்துகிறது.

```js
const zkBankAddress = process.env.ZKBANK_ADDRESS || "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
```

இங்கே உள்ள முகவரி, நீங்கள் ஒரு சுத்தமான `anvil` உடன் தொடங்கி மேலே உள்ள வழிமுறைகளைப் பின்பற்றும்போது கிடைக்கும்.

```js
const walletClient = createWalletClient({ 
    chain: anvil, 
    transport: http(), 
    account: privateKeyToAccount("0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6")
})
```

இந்த தனிப்பட்ட திறவுகோல் `anvil` இல் உள்ள இயல்புநிலை முன்கூட்டியே நிதியளிக்கப்பட்ட கணக்குகளில் ஒன்றாகும்.

```js
const generateProof = async (witness, fileID) => {
```

`bb` இயங்கக்கூடியதைப் பயன்படுத்தி ஒரு ஆதாரத்தை உருவாக்கவும்.

```js
    const fname = `witness-${fileID}.gz`    
    await fs.writeFile(fname, witness)
```

சாட்சியை ஒரு கோப்பில் எழுதவும்.

```js
    await execPromise(`bb prove -b ./noir/target/zkBank.json -w ${fname} -o ${fileID} --oracle_hash keccak --output_format fields`)
```

உண்மையில் ஆதாரத்தை உருவாக்கவும். இந்த படி பொது மாறிகளுடன் ஒரு கோப்பை உருவாக்குகிறது, ஆனால் எங்களுக்கு அது தேவையில்லை. `noir.execute` இலிருந்து அந்த மாறிகளை நாங்கள் ஏற்கனவே பெற்றுள்ளோம்.

```js
    const proof = "0x" + JSON.parse(await fs.readFile(`./${fileID}/proof_fields.json`)).reduce((a,b) => a+b, "").replace(/0x/g, "")
```

ஆதாரம் `புலம்` மதிப்புகளின் ஒரு JSON வரிசையாகும், ஒவ்வொன்றும் ஒரு ஹெக்ஸாடெசிமல் மதிப்பாகக் குறிப்பிடப்படுகிறது. இருப்பினும், அதை பரிவர்த்தனையில் ஒரு `bytes` மதிப்பாக அனுப்ப வேண்டும், அதை Viem ஒரு பெரிய ஹெக்ஸாடெசிமல் சரத்தால் குறிக்கிறது. இங்கே நாங்கள் அனைத்து மதிப்புகளையும் இணைத்து, அனைத்து `0x` களையும் அகற்றி, இறுதியில் ஒன்றைச் சேர்ப்பதன் மூலம் வடிவமைப்பை மாற்றுகிறோம்.

```js
    await execPromise(`rm -r ${fname} ${fileID}`)

    return proof
}
```

சுத்தப்படுத்தி ஆதாரத்தைத் திருப்பவும்.

```js
const processMessage = async (message, signature) => {
    .
    .
    .

    const publicFields = noirResult.returnValue.map(x=>'0x' + x.slice(2).padStart(64, "0"))
```

பொதுப் புலங்கள் 32-பைட் மதிப்புகளின் வரிசையாக இருக்க வேண்டும். இருப்பினும், நாங்கள் பரிவர்த்தனைத் துண்டியை இரண்டு `புலம்` மதிப்புகளுக்கு இடையில் பிரிக்க வேண்டியிருந்ததால், அது 16-பைட் மதிப்பாகத் தோன்றுகிறது. இங்கே நாங்கள் பூஜ்ஜியங்களைச் சேர்க்கிறோம், அதனால் Viem அது உண்மையில் 32 பைட்டுகள் என்பதைப் புரிந்து கொள்ளும்.

```js
    const proof = await generateProof(noirResult.witness, `${fromAddress}-${nonce}`)
```

ஒவ்வொரு முகவரியும் ஒவ்வொரு நான்ஸையும் ஒரு முறை மட்டுமே பயன்படுத்துகிறது, அதனால் நாங்கள் சாட்சிக் கோப்பு மற்றும் வெளியீட்டு அடைவுக்கான தனித்துவமான அடையாளங்காட்டியாக `fromAddress` மற்றும் `நான்ஸ்` கலவையைப் பயன்படுத்தலாம்.

```js
    try {
        await zkBank.write.processTransaction([
            proof, publicFields])
    } catch (err) {
        console.log(`Verification error: ${err}`)
        throw Error("Can't verify the transaction onchain")
    }
    .
    .
    .
}
```

பரிவர்த்தனையை சங்கிலிக்கு அனுப்பவும்.

#### `smart-contracts/src/ZkBank.sol` {#smart-contracts-src-zkbank-sol}

இது பரிவர்த்தனையைப் பெறும் ஆன்செயின் குறியீடு.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity >=0.8.21;

import {HonkVerifier} from "./Verifier.sol";

contract ZkBank {
    HonkVerifier immutable myVerifier;
    bytes32 currentStateHash;

    constructor(address _verifierAddress, bytes32 _initialStateHash) {
        currentStateHash = _initialStateHash;
        myVerifier = HonkVerifier(_verifierAddress);
    }
```

ஆன்செயின் குறியீடு இரண்டு மாறிகளைக் கண்காணிக்க வேண்டும்: சரிபார்ப்பவர் (`nargo` ஆல் உருவாக்கப்பட்ட ஒரு தனி ஒப்பந்தம்) மற்றும் தற்போதைய நிலைத் துண்டி.

```solidity
    event TransactionProcessed(
        bytes32 indexed transactionHash,
        bytes32 oldStateHash,
        bytes32 newStateHash
    );
```

ஒவ்வொரு முறை நிலை மாறும் போதும், நாங்கள் ஒரு `TransactionProcessed` நிகழ்வை வெளியிடுகிறோம்.

```solidity
    function processTransaction(
        bytes calldata _proof,
        bytes32[] calldata _publicFields
    ) public {
```

இந்த செயல்பாடு பரிவர்த்தனைகளைச் செயலாக்குகிறது. இது ஆதாரத்தை (`bytes` ஆக) மற்றும் பொது உள்ளீடுகளை (`bytes32` வரிசையாக) பெறுகிறது, சரிபார்ப்பவர் தேவைப்படும் வடிவத்தில் (ஆன்செயின் செயலாக்கத்தைக் குறைத்து, எனவே எரிவாயு செலவுகளைக் குறைக்க).

```solidity
        require(_publicInputs[0] == currentStateHash,
            "Wrong old state hash");
```

பூஜ்ஜிய-அறிவு ஆதாரம் என்னவென்றால், பரிவர்த்தனை நமது தற்போதைய துண்டியிலிருந்து ஒரு புதியதாக மாறுகிறது.

```solidity
        myVerifier.verify(_proof, _publicFields);
```

பூஜ்ஜிய-அறிவு ஆதாரத்தைச் சரிபார்க்க சரிபார்ப்பாளர் ஒப்பந்தத்தை அழைக்கவும். பூஜ்ஜிய-அறிவு ஆதாரம் தவறாக இருந்தால், இந்த படி பரிவர்த்தனையைத் திருப்புகிறது.

```solidity
        currentStateHash = _publicFields[1];

        emit TransactionProcessed(
            _publicFields[2]<<128 | _publicFields[3],
            _publicFields[0],
            _publicFields[1]
        );
    }
}
```

எல்லாம் சரி பார்த்தால், நிலைத் துண்டியை புதிய மதிப்பிற்குப் புதுப்பித்து, ஒரு `TransactionProcessed` நிகழ்வை வெளியிடவும்.

## மையப்படுத்தப்பட்ட கூறுகளால் துஷ்பிரயோகங்கள் {#abuses}

தகவல் பாதுகாப்பு மூன்று பண்புகளைக் கொண்டுள்ளது:

- _இரகசியத்தன்மை_, பயனர்கள் படிக்க அங்கீகரிக்கப்படாத தகவலைப் படிக்க முடியாது.
- _ஒருமைப்பாடு_, அங்கீகரிக்கப்பட்ட பயனர்களால் அங்கீகரிக்கப்பட்ட முறையில் தவிர, தகவலை மாற்ற முடியாது.
- _கிடைத்தல்_, அங்கீகரிக்கப்பட்ட பயனர்கள் அமைப்பைப் பயன்படுத்தலாம்.

இந்த அமைப்பில், பூஜ்ஜிய-அறிவு ஆதாரங்கள் மூலம் ஒருமைப்பாடு வழங்கப்படுகிறது. கிடைப்பதை உத்தரவாதம் செய்வது மிகவும் கடினம், மற்றும் இரகசியத்தன்மை சாத்தியமற்றது, ஏனெனில் வங்கி ஒவ்வொரு கணக்கின் இருப்பு மற்றும் அனைத்து பரிவர்த்தனைகளையும் அறிந்திருக்க வேண்டும். தகவல் உள்ள ஒரு நிறுவனம் அந்த தகவலைப் பகிர்வதைத் தடுக்க வழியில்லை.

[ஸ்டீல்த் முகவரிகளைப்](https://vitalik.eth.limo/general/2023/01/20/stealth.html) பயன்படுத்தி ஒரு உண்மையான இரகசிய வங்கியை உருவாக்குவது சாத்தியமாக இருக்கலாம், ஆனால் அது இந்தக் கட்டுரையின் எல்லைக்கு அப்பாற்பட்டது.

### தவறான தகவல் {#false-info}

சேவையகம் ஒருமைப்பாட்டை மீறும் ஒரு வழி [தரவு கோரப்படும் போது](https://github.com/qbzzt/250911-zk-bank/blob/03-smart-contracts/server/index.mjs#L278-L291) தவறான தகவலை வழங்குவதாகும்.

இதைத் தீர்க்க, கணக்குகளை ஒரு தனிப்பட்ட உள்ளீடாகவும், தகவல் கோரப்பட்ட முகவரியை ஒரு பொது உள்ளீடாகவும் பெறும் இரண்டாவது Noir நிரலை எழுதலாம். வெளியீடு அந்த முகவரியின் இருப்பு மற்றும் நான்ஸ், மற்றும் கணக்குகளின் துண்டி ஆகும்.

நிச்சயமாக, இந்த ஆதாரத்தை ஆன்செயினில் சரிபார்க்க முடியாது, ஏனெனில் நாங்கள் நான்ஸ்களையும் இருப்புகளையும் ஆன்செயினில் வெளியிட விரும்பவில்லை. இருப்பினும், அதை உலாவியில் இயங்கும் வாடிக்கையாளர் குறியீட்டால் சரிபார்க்க முடியும்.

### கட்டாயப் பரிவர்த்தனைகள் {#forced-txns}

L2-களில் கிடைப்பதை உறுதி செய்வதற்கும் தணிக்கையைத் தடுப்பதற்கும் வழக்கமான வழிமுறை [கட்டாயப் பரிவர்த்தனைகள்](https://docs.optimism.io/stack/transactions/forced-transaction) ஆகும். ஆனால் கட்டாயப் பரிவர்த்தனைகள் பூஜ்ஜிய-அறிவு ஆதாரங்களுடன் இணைவதில்லை. சேவையகம் மட்டுமே பரிவர்த்தனைகளைச் சரிபார்க்கக்கூடிய நிறுவனம்.

`smart-contracts/src/ZkBank.sol` ஐ கட்டாயப் பரிவர்த்தனைகளை ஏற்கவும், அவை செயலாக்கப்படும் வரை சேவையகம் நிலையை மாற்றுவதைத் தடுக்கவும் மாற்றலாம். இருப்பினும், இது எங்களை ஒரு எளிய சேவை மறுப்பு தாக்குதலுக்குத் திறக்கிறது. ஒரு கட்டாயப் பரிவர்த்தனை செல்லுபடியாகாவிட்டால் மற்றும் எனவே செயலாக்க முடியாததாக இருந்தால் என்ன செய்வது?

ஒரு கட்டாயப் பரிவர்த்தனை செல்லுபடியாகாது என்பதற்கான பூஜ்ஜிய-அறிவு ஆதாரம் இருப்பதே தீர்வு. இது சேவையகத்திற்கு மூன்று விருப்பங்களை வழங்குகிறது:

- கட்டாயப் பரிவர்த்தனையைச் செயலாக்கவும், அது செயலாக்கப்பட்டது என்பதற்கும் புதிய நிலைத் துண்டிக்கும் ஒரு பூஜ்ஜிய-அறிவு ஆதாரத்தை வழங்கவும்.
- கட்டாயப் பரிவர்த்தனையை நிராகரிக்கவும், மற்றும் பரிவர்த்தனை செல்லுபடியாகாது (தெரியாத முகவரி, மோசமான நான்ஸ், அல்லது போதுமான இருப்பு இல்லை) என்பதற்கு ஒப்பந்தத்திற்கு ஒரு பூஜ்ஜிய-அறிவு ஆதாரத்தை வழங்கவும்.
- கட்டாயப் பரிவர்த்தனையைப் புறக்கணிக்கவும். சேவையகத்தை உண்மையில் பரிவர்த்தனையைச் செயலாக்க கட்டாயப்படுத்த வழியில்லை, ஆனால் இதன் பொருள் முழு அமைப்பும் கிடைக்கவில்லை.

#### கிடைக்கும் பிணைப்புகள் {#avail-bonds}

ஒரு நிஜ வாழ்க்கைச் செயல்பாட்டில், சேவையகத்தை இயங்க வைப்பதற்கு ஒருவித இலாப நோக்கம் இருக்கலாம். ஒரு குறிப்பிட்ட காலத்திற்குள் ஒரு கட்டாயப் பரிவர்த்தனை செயலாக்கப்படாவிட்டால் யார் வேண்டுமானாலும் எரிக்கக்கூடிய ஒரு கிடைக்கும் பிணைப்பை சேவையகம் வெளியிடுவதன் மூலம் இந்த ஊக்கத்தை வலுப்படுத்தலாம்.

### மோசமான Noir குறியீடு {#bad-noir-code}

பொதுவாக, மக்கள் ஒரு ஸ்மார்ட் ஒப்பந்தத்தை நம்ப வைக்க, மூலக் குறியீட்டை ஒரு [தொகுதி ஆய்வு கருவிக்கு](https://eth.blockscout.com/address/0x7D16d2c4e96BCFC8f815E15b771aC847EcbDB48b?tab=contract) பதிவேற்றுகிறோம். இருப்பினும், பூஜ்ஜிய-அறிவு ஆதாரங்களின் விஷயத்தில், அது போதுமானதல்ல.

`Verifier.sol` சரிபார்ப்புத் திறவுகோலைக் கொண்டுள்ளது, இது Noir நிரலின் ஒரு செயல்பாடாகும். இருப்பினும், அந்தத் திறவுகோல் Noir நிரல் என்ன என்பதை எங்களுக்குச் சொல்லாது. உண்மையில் ஒரு நம்பகமான தீர்வைக் கொண்டிருக்க, நீங்கள் Noir நிரலை (மற்றும் அதை உருவாக்கிய பதிப்பை) பதிவேற்ற வேண்டும். இல்லையெனில், பூஜ்ஜிய-அறிவு ஆதாரங்கள் வேறுபட்ட நிரலை, ஒரு பின் வாசல் கொண்ட ஒன்றை பிரதிபலிக்கக்கூடும்.

தொகுதி ஆய்வு கருவிகள் Noir நிரல்களைப் பதிவேற்றவும் சரிபார்க்கவும் அனுமதிக்கும் வரை, நீங்களே அதைச் செய்ய வேண்டும் (முன்னுரிமையாக [IPFS](/developers/tutorials/ipfs-decentralized-ui/)-க்கு). பின்னர் அதிநவீன பயனர்கள் மூலக் குறியீட்டைப் பதிவிறக்க முடியும், அதை அவர்களே தொகுக்கலாம், `Verifier.sol` ஐ உருவாக்கலாம், மற்றும் அது ஆன்செயினில் உள்ளதை ஒத்திருக்கிறது என்பதைச் சரிபார்க்கலாம்.

## முடிவுரை {#conclusion}

பிளாஸ்மா-வகை செயலிகளுக்கு தகவல் சேமிப்பகமாக ஒரு மையப்படுத்தப்பட்ட கூறு தேவைப்படுகிறது. இது சாத்தியமான பாதிப்புகளைத் திறக்கிறது, ஆனால், பதிலுக்கு, பிளாக்செயினில் கிடைக்காத வழிகளில் தனியுரிமையைப் பாதுகாக்க அனுமதிக்கிறது. பூஜ்ஜிய-அறிவு ஆதாரங்களுடன் நாங்கள் ஒருமைப்பாட்டை உறுதிப்படுத்த முடியும் மற்றும் மையப்படுத்தப்பட்ட கூறுகளை இயக்கும் எவருக்கும் கிடைப்பதை பராமரிப்பது பொருளாதார ரீதியாக சாதகமாக இருக்கலாம்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).

## ஒப்புதல்கள் {#acknowledgements}

- ஜோஷ் கிரைட்ஸ் இந்தக் கட்டுரையின் ஒரு வரைவைப் படித்து ஒரு முள்ளான Noir சிக்கலுக்கு எனக்கு உதவினார்.

மீதமுள்ள எந்தப் பிழைகளும் எனது பொறுப்பு.
