---
title: "ஒப்பந்த அளவு வரம்பை சமாளிக்க ஒப்பந்தங்களின் அளவைக் குறைத்தல்"
description: "உங்கள் ஸ்மார்ட் ஒப்பந்தங்கள் மிகப் பெரியதாக வளர்வதைத் தடுக்க நீங்கள் என்ன செய்ய முடியும்?"
author: Markus Waas
lang: ta
tags: [ "திட்பம்", "ஸ்மார்ட் ஒப்பந்தங்கள்", "சேமிப்பு" ]
skill: intermediate
published: 2020-06-26
source: soliditydeveloper.com
sourceUrl: https://soliditydeveloper.com/max-contract-size
---

## ஏன் ஒரு வரம்பு இருக்கிறது? {#why-is-there-a-limit}

[நவம்பர் 22, 2016](https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon/) அன்று, Spurious Dragon ஹார்ட்-ஃபோர்க் [EIP-170](https://eips.ethereum.org/EIPS/eip-170)-ஐ அறிமுகப்படுத்தியது, இது 24.576 kb என்ற ஸ்மார்ட் ஒப்பந்த அளவு வரம்பை சேர்த்தது. ஒரு Solidity உருவாக்குநராக, உங்கள் ஒப்பந்தத்தில் மேலும் மேலும் செயல்பாடுகளைச் சேர்க்கும்போது, ஒரு கட்டத்தில் நீங்கள் வரம்பை அடைந்து, வரிசைப்படுத்தும்போது பின்வரும் பிழையைக் காண்பீர்கள்:

`எச்சரிக்கை: ஒப்பந்தக் குறியீட்டின் அளவு 24576 பைட்டுகளை மீறுகிறது (Spurious Dragon-இல் அறிமுகப்படுத்தப்பட்ட வரம்பு).` இந்த ஒப்பந்தத்தை Mainnet-இல் வரிசைப்படுத்த முடியாமல் போகலாம். `ஆப்டிமைசரை இயக்குவதைக் கவனியுங்கள் (குறைந்த "runs" மதிப்புடன்!), ரிவெர்ட் சரங்களை முடக்குங்கள், அல்லது நூலகங்களைப் பயன்படுத்துங்கள்.`

சேவை மறுப்பு (DOS) தாக்குதல்களைத் தடுப்பதற்காக இந்த வரம்பு அறிமுகப்படுத்தப்பட்டது. ஒரு ஒப்பந்தத்திற்கான எந்த அழைப்பும் கேஸ் செலவின் அடிப்படையில் ஒப்பீட்டளவில் மலிவானது. இருப்பினும், அழைக்கப்படும் ஒப்பந்தக் குறியீட்டின் அளவைப் பொறுத்து (வட்டிலிருந்து குறியீட்டைப் படித்தல், குறியீட்டை முன்கூட்டியே செயலாக்குதல், Merkle சான்றில் தரவைச் சேர்ப்பது) Ethereum முனைகளுக்கு ஒரு ஒப்பந்த அழைப்பின் தாக்கம் விகிதாசாரமின்றி அதிகரிக்கிறது. தாக்குபவர் மற்றவர்களுக்கு அதிக வேலையை ஏற்படுத்த சில வளங்களை மட்டும் பயன்படுத்தும் சூழ்நிலை ஏற்படும்போதெல்லாம், DOS தாக்குதல்களுக்கான சாத்தியம் உருவாகிறது.

ஆரம்பத்தில் இது ஒரு பெரிய பிரச்சனையாக இருக்கவில்லை, ஏனெனில் பிளாக் கேஸ் வரம்பு என்பது ஒரு இயற்கையான ஒப்பந்த அளவு வரம்பாகும். வெளிப்படையாக, ஒப்பந்தத்தின் அனைத்து பைட் குறியீட்டையும் கொண்டிருக்கும் ஒரு பரிவர்த்தனைக்குள் ஒரு ஒப்பந்தம் வரிசைப்படுத்தப்பட வேண்டும். அந்த ஒரு பரிவர்த்தனையை மட்டும் ஒரு பிளாக்கில் நீங்கள் சேர்த்தால், அந்த முழு கேஸையும் நீங்கள் பயன்படுத்தலாம், ஆனால் அது எல்லையற்றது அல்ல. [லண்டன் மேம்படுத்தல்](/ethereum-forks/#london) முதல், நெட்வொர்க் தேவையைப் பொறுத்து பிளாக் கேஸ் வரம்பு 15M மற்றும் 30M யூனிட்டுகளுக்கு இடையில் மாறுபடும் திறன் கொண்டது.

பின்வருவனவற்றில், அவற்றின் சாத்தியமான தாக்கத்தின் அடிப்படையில் வரிசைப்படுத்தப்பட்ட சில முறைகளைப் பார்ப்போம். இதை எடை குறைப்பு அடிப்படையில் சிந்தியுங்கள். ஒருவர் தங்கள் இலக்கு எடையை (நமது விஷயத்தில் 24kb) அடைய சிறந்த உத்தி, முதலில் பெரிய தாக்கத்தை ஏற்படுத்தும் முறைகளில் கவனம் செலுத்துவதாகும். பெரும்பாலான சந்தர்ப்பங்களில், உங்கள் உணவைச் சரிசெய்வது மட்டுமே உங்களை இலக்கை அடையச் செய்யும், ஆனால் சில நேரங்களில் உங்களுக்கு இன்னும் கொஞ்சம் கூடுதலாகத் தேவைப்படலாம். பிறகு நீங்கள் சில உடற்பயிற்சிகளை (நடுத்தர தாக்கம்) அல்லது சப்ளிமென்ட்களை (சிறிய தாக்கம்) கூட சேர்க்கலாம்.

## பெரிய தாக்கம் {#big-impact}

### உங்கள் ஒப்பந்தங்களைப் பிரிக்கவும் {#separate-your-contracts}

இது எப்போதும் உங்கள் முதல் அணுகுமுறையாக இருக்க வேண்டும். ஒப்பந்தத்தை பல சிறிய ஒப்பந்தங்களாக நீங்கள் எவ்வாறு பிரிக்க முடியும்? இது பொதுவாக உங்கள் ஒப்பந்தங்களுக்கு ஒரு நல்ல கட்டமைப்பை உருவாக்க உங்களைத் தூண்டுகிறது. குறியீடு வாசிப்புத் திறனின் கண்ணோட்டத்தில் சிறிய ஒப்பந்தங்கள் எப்போதும் விரும்பப்படுகின்றன. ஒப்பந்தங்களைப் பிரிப்பதற்கு, உங்களை நீங்களே கேட்டுக்கொள்ளுங்கள்:

- எந்த செயல்பாடுகள் ஒன்றாகச் சேர்ந்தவை? ஒவ்வொரு செயல்பாடுகளின் தொகுப்பும் அதன் சொந்த ஒப்பந்தத்தில் இருப்பது சிறந்ததாக இருக்கலாம்.
- ஒப்பந்த நிலையைப் படிக்கத் தேவையில்லாத அல்லது நிலையின் ஒரு குறிப்பிட்ட துணைக்குழு மட்டும் தேவைப்படும் செயல்பாடுகள் எவை?
- சேமிப்பகத்தையும் செயல்பாட்டையும் உங்களால் பிரிக்க முடியுமா?

### நூலகங்கள் {#libraries}

சேமிப்பகத்திலிருந்து செயல்பாட்டுக் குறியீட்டை நகர்த்துவதற்கான ஒரு எளிய வழி [நூலகத்தைப்](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#libraries) பயன்படுத்துவதாகும். நூலக செயல்பாடுகளை இன்டர்னல் என அறிவிக்காதீர்கள், ஏனெனில் அவை தொகுப்பின் போது நேரடியாக [ஒப்பந்தத்தில் சேர்க்கப்படும்](https://ethereum.stackexchange.com/questions/12975/are-internal-functions-in-libraries-not-covered-by-linking). ஆனால் நீங்கள் பொதுச் செயல்பாடுகளைப் பயன்படுத்தினால், அவை உண்மையில் ஒரு தனி நூலக ஒப்பந்தத்தில் இருக்கும். நூலகங்களின் பயன்பாட்டை மிகவும் வசதியானதாக மாற்ற [using for](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for) ஐப் பயன்படுத்துவதைக் கவனியுங்கள்.

### ப்ராக்ஸிகள் {#proxies}

ஒரு ப்ராக்ஸி அமைப்பு மேலும் மேம்பட்ட உத்தியாக இருக்கும். நூலகங்கள் பின்னணியில் `DELEGATECALL` ஐப் பயன்படுத்துகின்றன, இது அழைக்கும் ஒப்பந்தத்தின் நிலையுடன் மற்றொரு ஒப்பந்தத்தின் செயல்பாட்டை வெறுமனே செயல்படுத்துகிறது. ப்ராக்ஸி அமைப்புகளைப் பற்றி மேலும் அறிய [இந்த வலைப்பதிவு இடுகையைப்](https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2) பாருங்கள். அவை உங்களுக்கு அதிக செயல்பாடுகளை வழங்குகின்றன, எ.கா., அவை மேம்படுத்தலை செயல்படுத்துகின்றன, ஆனால் அவை அதிக சிக்கலையும் சேர்க்கின்றன. எந்தவொரு காரணத்திற்காகவும் அது உங்கள் ஒரே விருப்பமாக இல்லாவிட்டால், ஒப்பந்த அளவுகளைக் குறைப்பதற்காக மட்டும் நான் அவற்றைச் சேர்க்க மாட்டேன்.

## நடுத்தர தாக்கம் {#medium-impact}

### செயல்பாடுகளை நீக்கவும் {#remove-functions}

இது வெளிப்படையாக இருக்க வேண்டும். செயல்பாடுகள் ஒரு ஒப்பந்தத்தின் அளவை கணிசமாக அதிகரிக்கின்றன.

- **வெளிப்புறம்**: பல நேரங்களில் வசதிக்காக பல பார்வைச் செயல்பாடுகளைச் சேர்க்கிறோம். நீங்கள் அளவு வரம்பை அடையும் வரை அது முற்றிலும் சரி. அப்படியானால், முற்றிலும் அவசியமானவற்றைத் தவிர மற்ற அனைத்தையும் நீக்குவது பற்றி நீங்கள் தீவிரமாக சிந்திக்க விரும்பலாம்.
- **உட்புறம்**: செயல்பாடு ஒரு முறை மட்டுமே அழைக்கப்படும் வரை, நீங்கள் இன்டர்னல்/பிரைவேட் செயல்பாடுகளை அகற்றி, குறியீட்டை எளிமையாக இன்லைன் செய்யலாம்.

### கூடுதல் மாறிகளைத் தவிர்க்கவும் {#avoid-additional-variables}

```solidity
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
```

இது போன்ற ஒரு எளிய மாற்றம் **0.28kb** வித்தியாசத்தை ஏற்படுத்துகிறது. உங்கள் ஒப்பந்தங்களில் இது போன்ற பல சூழ்நிலைகளைக் கண்டறிய வாய்ப்புள்ளது, மேலும் அவை அனைத்தும் சேர்ந்து குறிப்பிடத்தக்க அளவைக் குறைக்கக்கூடும்.

### பிழைச் செய்தியைச் சுருக்கவும் {#shorten-error-message}

நீண்ட ரிவெர்ட் செய்திகள் மற்றும் குறிப்பாக பல வேறுபட்ட ரிவெர்ட் செய்திகள் ஒப்பந்தத்தை பெரிதாக்கக்கூடும். அதற்குப் பதிலாக, குறுகிய பிழைக் குறியீடுகளைப் பயன்படுத்தி அவற்றை உங்கள் ஒப்பந்தத்தில் டிகோட் செய்யுங்கள். ஒரு நீண்ட செய்தியை மிகவும் சுருக்கமாக மாற்றலாம்:

```solidity
require(msg.sender == owner, "இந்த ஒப்பந்தத்தின் உரிமையாளர் மட்டுமே இந்த செயல்பாட்டை அழைக்க முடியும்");
```

```solidity
require(msg.sender == owner, "OW1");
```

### பிழைச் செய்திகளுக்குப் பதிலாக தனிப்பயன் பிழைகளைப் பயன்படுத்தவும்

[Solidity 0.8.4](https://blog.soliditylang.org/2021/04/21/custom-errors/) இல் தனிப்பயன் பிழைகள் அறிமுகப்படுத்தப்பட்டுள்ளன. உங்கள் ஒப்பந்தங்களின் அளவைக் குறைக்க அவை ஒரு சிறந்த வழியாகும், ஏனெனில் அவை தேர்வாளர்களாக (செயல்பாடுகளைப் போலவே) ABI-குறியாக்கம் செய்யப்பட்டுள்ளன.

```solidity
error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
```

### ஆப்டிமைசரில் குறைந்த ரன் மதிப்பைக் கருத்தில் கொள்ளுங்கள் {#consider-a-low-run-value-in-the-optimizer}

நீங்கள் ஆப்டிமைசர் அமைப்புகளையும் மாற்றலாம். 200 என்ற இயல்புநிலை மதிப்பு, ஒரு செயல்பாடு 200 முறை அழைக்கப்படுவது போல பைட் குறியீட்டை மேம்படுத்த முயற்சிப்பதை குறிக்கிறது. நீங்கள் அதை 1 ஆக மாற்றினால், ஒவ்வொரு செயல்பாட்டையும் ஒரு முறை மட்டுமே இயக்கும் வழக்கிற்காக மேம்படுத்துமாறு ஆப்டிமைசரிடம் கூறுகிறீர்கள். ஒரு முறை மட்டும் இயங்குவதற்காக மேம்படுத்தப்பட்ட ஒரு செயல்பாடு, வரிசைப்படுத்தலுக்காகவே மேம்படுத்தப்பட்டுள்ளது என்று பொருள். **இது செயல்பாடுகளை இயக்குவதற்கான [கேஸ் செலவுகளை](/developers/docs/gas/) அதிகரிக்கிறது** என்பதை நினைவில் கொள்ளுங்கள், எனவே நீங்கள் அதைச் செய்ய விரும்பாமல் இருக்கலாம்.

## சிறிய தாக்கம் {#small-impact}

### செயல்பாடுகளுக்கு ஸ்டிரக்ட்களை அனுப்புவதைத் தவிர்க்கவும் {#avoid-passing-structs-to-functions}

நீங்கள் [ABIEncoderV2](https://solidity.readthedocs.io/en/v0.6.10/layout-of-source-files.html#abiencoderv2) ஐப் பயன்படுத்தினால், ஒரு செயல்பாட்டிற்கு ஸ்டிரக்ட்களை அனுப்பாமல் இருப்பது உதவக்கூடும். அளவுருவை ஒரு ஸ்டிரக்ட்டாக அனுப்புவதற்குப் பதிலாக, தேவையான அளவுருக்களை நேரடியாக அனுப்பவும். இந்த எடுத்துக்காட்டில் நாம் மேலும் **0.1kb** சேமித்துள்ளோம்.

```solidity
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
```

### செயல்பாடுகள் மற்றும் மாறிகளுக்கான சரியான விசிபிலிட்டியை அறிவிக்கவும் {#declare-correct-visibility-for-functions-and-variables}

- வெளியிலிருந்து மட்டுமே அழைக்கப்படும் செயல்பாடுகள் அல்லது மாறிகளா? `public` என்பதற்குப் பதிலாக அவற்றை `external` என அறிவிக்கவும்.
- ஒப்பந்தத்திற்குள் இருந்து மட்டுமே அழைக்கப்படும் செயல்பாடுகள் அல்லது மாறிகளா? `public` என்பதற்குப் பதிலாக அவற்றை `private` அல்லது `internal` என அறிவிக்கவும்.

### மாற்றி அமைப்பிகளை அகற்றவும் {#remove-modifiers}

மாற்றி அமைப்பிகள், குறிப்பாக தீவிரமாகப் பயன்படுத்தப்படும்போது, ஒப்பந்தத்தின் அளவில் குறிப்பிடத்தக்க தாக்கத்தை ஏற்படுத்தக்கூடும். அவற்றை அகற்றி, அதற்குப் பதிலாக செயல்பாடுகளைப் பயன்படுத்துவதைக் கவனியுங்கள்.

```solidity
modifier checkStuff() {}

function doSomething() checkStuff {}
```

```solidity
function checkStuff() private {}

function doSomething() { checkStuff(); }
```

இந்தக் குறிப்புகள் ஒப்பந்த அளவைக் கணிசமாகக் குறைக்க உங்களுக்கு உதவும். மீண்டும் ஒருமுறை, மிகப்பெரிய தாக்கத்தைப் பெற முடிந்தால் ஒப்பந்தங்களைப் பிரிப்பதில் எப்போதும் கவனம் செலுத்துங்கள் என்பதை நான் எவ்வளவு வலியுறுத்தினாலும் போதாது.
