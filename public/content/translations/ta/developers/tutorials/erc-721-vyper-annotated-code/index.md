---
title: "Vyper ERC-721 ஒப்பந்த வழிமுறை விளக்கம்"
description: "ரியூயா நகமுராவின் ERC-721 ஒப்பந்தம் மற்றும் அது செயல்படும் விதம்"
author: Ori Pomerantz
lang: ta
tags: [ "vyper", "erc-721", "python" ]
skill: beginner
published: 2021-04-01
---

## அறிமுகம் {#introduction}

[ERC-721](/developers/docs/standards/tokens/erc-721/) தரநிலையானது பதிலீடு செய்ய முடியாத டோக்கன்களின் (NFT) உரிமையை வைத்திருக்கப் பயன்படுகிறது.
[ERC-20](/developers/docs/standards/tokens/erc-20/) டோக்கன்கள் ஒரு பண்டத்தைப் போல செயல்படுகின்றன, ஏனெனில் தனிப்பட்ட டோக்கன்களுக்கு இடையில் எந்த வேறுபாடும் இல்லை.
அதற்கு மாறாக, ERC-721 டோக்கன்கள், வெவ்வேறு பூனை
கார்ட்டூன்கள் அல்லது வெவ்வேறு நில உடைமைகளின் பட்டயங்கள் போன்று ஒரே மாதிரியாக ஆனால் ஒரே தன்மையற்று இருக்கும் சொத்துக்களுக்காக வடிவமைக்கப்பட்டுள்ளன.

இந்தக் கட்டுரையில், [ரியூயா நகமுராவின் ERC-721 ஒப்பந்தத்தை](https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC721.vy) நாங்கள் ஆய்வு செய்வோம்.
இந்த ஒப்பந்தம் [Vyper](https://vyper.readthedocs.io/en/latest/index.html) இல் எழுதப்பட்டுள்ளது, இது பைத்தானைப் போன்ற ஒரு ஒப்பந்த மொழியாகும், இது Solidity-ஐ விடப் பாதுகாப்பற்ற குறியீட்டை எழுதுவதைக் கடினமாக்கும் வகையில் வடிவமைக்கப்பட்டுள்ளது.

## ஒப்பந்தம் {#contract}

```python
# @dev ERC-721 பதிலீடு செய்ய முடியாத டோக்கன் தரநிலையின் செயலாக்கம்.
# @author ரியூயா நகமுரா (@nrryuya)
# இதிலிருந்து மாற்றியமைக்கப்பட்டது: https://github.com/vyperlang/vyper/blob/de74722bf2d8718cca46902be165f9fe0e3641dd/examples/tokens/ERC721.vy
```

Vyper இல், பைத்தானைப் போலவே, குறிப்புரைகள் ஒரு ஹாஷ் (`#`) குறியுடன் தொடங்கி, வரியின் இறுதி வரை தொடரும். `@<keyword>` ஐ உள்ளடக்கிய குறிப்புரைகள், மனிதர்கள் படிக்கக்கூடிய
ஆவணத்தை உருவாக்க [NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) ஆல் பயன்படுத்தப்படுகின்றன.

```python
from vyper.interfaces import ERC721

implements: ERC721
```

ERC-721 இடைமுகம் Vyper மொழியில் கட்டமைக்கப்பட்டுள்ளது.
[குறியீட்டு வரையறையை இங்கே காணலாம்](https://github.com/vyperlang/vyper/blob/master/vyper/builtin_interfaces/ERC721.py).
இடைமுக வரையறை Vyper-ஐ விட பைத்தானில் எழுதப்பட்டுள்ளது, ஏனெனில் இடைமுகங்கள்
பிளாக்செயினுக்குள் மட்டுமல்லாமல், பைத்தானில் எழுதப்பட்டிருக்கக்கூடிய ஒரு வெளிப்புற கிளையண்டிலிருந்து பிளாக்செயினுக்கு ஒரு பரிவர்த்தனையை அனுப்பும்போதும்
பயன்படுத்தப்படுகின்றன.

முதல் வரி இடைமுகத்தை இறக்குமதி செய்கிறது, மற்றும் இரண்டாவது அதை இங்கே செயல்படுத்துகிறோம் என்பதைக் குறிப்பிடுகிறது.

### ERC721Receiver இடைமுகம் {#receiver-interface}

```python
# safeTransferFrom() ஆல் அழைக்கப்படும் ஒப்பந்தத்திற்கான இடைமுகம்
interface ERC721Receiver:
    def onERC721Received(
```

ERC-721 இரண்டு வகையான இடமாற்றங்களை ஆதரிக்கிறது:

- `transferFrom`, இது அனுப்புநரை எந்தவொரு சேருமிட முகவரியையும் குறிப்பிட அனுமதிக்கிறது மற்றும் இடமாற்றத்திற்கான பொறுப்பை
  அனுப்புநர் மீது வைக்கிறது. இதன் பொருள் நீங்கள் ஒரு தவறான முகவரிக்கு மாற்றலாம், அப்படிப்பட்ட நிலையில்
  NFT நிரந்தரமாக இழக்கப்படும்.
- `safeTransferFrom`, இது சேருமிட முகவரி ஒரு ஒப்பந்தமா என்று சோதிக்கிறது. அப்படி இருந்தால், ERC-721 ஒப்பந்தம்
  பெறும் ஒப்பந்தத்திடம் அது NFT-ஐப் பெற விரும்புகிறதா என்று கேட்கும்.

`safeTransferFrom` கோரிக்கைகளுக்குப் பதிலளிக்க, ஒரு பெறும் ஒப்பந்தம் `ERC721Receiver`-ஐச் செயல்படுத்த வேண்டும்.

```python
            _operator: address,
            _from: address,
```

`_from` முகவரி டோக்கனின் தற்போதைய உரிமையாளர் ஆகும். `_operator` முகவரி என்பது இடமாற்றத்தைக்
கோரியவர் (அனுமதிகளின் காரணமாக அந்த இரண்டும் ஒன்றாக இருக்காது).

```python
            _tokenId: uint256,
```

ERC-721 டோக்கன் ID-கள் 256 பிட்கள் கொண்டவை. பொதுவாக, டோக்கன் எதைப் பிரதிபலிக்கிறதோ அதன் விளக்கத்தை
ஹாஷ் செய்வதன் மூலம் அவை உருவாக்கப்படுகின்றன.

```python
            _data: Bytes[1024]
```

கோரிக்கையில் 1024 பைட்டுகள் வரை பயனர் தரவு இருக்கலாம்.

```python
        ) -> bytes32: view
```

ஒரு ஒப்பந்தம் தற்செயலாக ஒரு இடமாற்றத்தை ஏற்கும் நிலைகளைத் தடுக்க, திருப்பி அனுப்பும் மதிப்பு ஒரு பூலியன் அல்ல,
மாறாக ஒரு குறிப்பிட்ட மதிப்புடன் கூடிய 256 பிட்கள் ஆகும்.

இந்தச் செயல்பாடு ஒரு `view` ஆகும், அதாவது அது பிளாக்செயினின் நிலையைப் படிக்க முடியும், ஆனால் அதை மாற்றியமைக்க முடியாது.

### நிகழ்வுகள் {#events}

பிளாக்செயினுக்கு வெளியே உள்ள பயனர்கள் மற்றும் சர்வர்களுக்கு நிகழ்வுகளைத் தெரிவிக்க [நிகழ்வுகள்](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e) வெளியிடப்படுகின்றன. நிகழ்வுகளின்
உள்ளடக்கம் பிளாக்செயினில் உள்ள ஒப்பந்தங்களுக்குக் கிடைக்காது என்பதைக் கவனத்தில் கொள்ளவும்.

```python
# @dev எந்தவொரு NFT-இன் உரிமையும் ஏதேனும் ஒரு இயங்குமுறையால் மாறும்போது வெளியிடப்படுகிறது. NFT-கள்
#      உருவாக்கப்படும்போதும் (`from` == 0) மற்றும் அழிக்கப்படும்போதும் (`to` == 0) இந்த நிகழ்வு வெளியிடப்படுகிறது. விதிவிலக்கு: ஒப்பந்தம் உருவாக்கப்படும்போது, எந்தவொரு
#      எண்ணிக்கையிலான NFT-களும் Transfer-ஐ வெளியிடாமலேயே உருவாக்கப்பட்டு ஒதுக்கப்படலாம். எந்தவொரு
#      இடமாற்றத்தின் போதும், அந்த NFT-க்கான அங்கீகரிக்கப்பட்ட முகவரி (ஏதேனும் இருந்தால்) எதுவுமில்லை என மீட்டமைக்கப்படும்.
# @param _from NFT-ஐ அனுப்புபவர் (முகவரி பூஜ்ஜிய முகவரியாக இருந்தால் அது டோக்கன் உருவாக்கத்தைக் குறிக்கிறது).
# @param _to NFT-ஐப் பெறுபவர் (முகவரி பூஜ்ஜிய முகவரியாக இருந்தால் அது டோக்கன் அழிவைக் குறிக்கிறது).
# @param _tokenId மாற்றப்பட்ட NFT.
event Transfer:
    sender: indexed(address)
    receiver: indexed(address)
    tokenId: indexed(uint256)
```

இது ERC-20 Transfer நிகழ்வைப் போன்றது, ஆனால் ஒரு தொகைக்குப் பதிலாக `tokenId` ஐ நாங்கள் அறிவிக்கிறோம்.
பூஜ்ஜிய முகவரியை யாரும் கொண்டிருக்கவில்லை, எனவே மரபுப்படி டோக்கன்களின் உருவாக்கம் மற்றும் அழிவைப் புகாரளிக்க அதைப் பயன்படுத்துகிறோம்.

```python
# @dev ஒரு NFT-க்கான அங்கீகரிக்கப்பட்ட முகவரி மாற்றப்படும்போது அல்லது மீண்டும் உறுதிசெய்யப்படும்போது இது வெளியிடப்படுகிறது. பூஜ்ஜிய
#      முகவரி அங்கீகரிக்கப்பட்ட முகவரி எதுவும் இல்லை என்பதைக் குறிக்கிறது. ஒரு Transfer நிகழ்வு வெளியிடப்படும்போது, இதுவும்
#      அந்த NFT-க்கான அங்கீகரிக்கப்பட்ட முகவரி (ஏதேனும் இருந்தால்) எதுவுமில்லை என மீட்டமைக்கப்பட்டுள்ளதைக் குறிக்கிறது.
# @param _owner NFT-இன் உரிமையாளர்.
# @param _approved நாங்கள் அங்கீகரிக்கும் முகவரி.
# @param _tokenId நாங்கள் அங்கீகரிக்கும் NFT.
event Approval:
    owner: indexed(address)
    approved: indexed(address)
    tokenId: indexed(uint256)
```

ஒரு ERC-721 அங்கீகாரம் என்பது ஒரு ERC-20 ஒதுக்கீட்டைப் போன்றது. ஒரு குறிப்பிட்ட முகவரி, ஒரு குறிப்பிட்ட
டோக்கனை மாற்ற அனுமதிக்கப்படுகிறது. ஒப்பந்தங்கள் ஒரு டோக்கனை ஏற்கும் போது பதிலளிக்க இது ஒரு இயங்குமுறையை அளிக்கிறது. ஒப்பந்தங்களால்
நிகழ்வுகளைக் கேட்க முடியாது, எனவே நீங்கள் டோக்கனை அவர்களுக்கு மாற்றினால், அவர்களுக்கு அது பற்றித் "தெரியாது". இந்த வழியில்
உரிமையாளர் முதலில் ஒரு ஒப்புதலைச் சமர்ப்பித்து, பின்னர் ஒப்பந்தத்திற்கு ஒரு கோரிக்கையை அனுப்புகிறார்: "டோக்கன்
X-ஐ மாற்ற நான் உங்களுக்கு ஒப்புதல் அளித்தேன், தயவுசெய்து செய்யுங்கள் ...".

ERC-721 தரநிலையை ERC-20 தரநிலையைப் போலவே உருவாக்குவதற்கான ஒரு வடிவமைப்புத் தேர்வு இது. ஏனெனில்
ERC-721 டோக்கன்கள் பதிலீடு செய்ய முடியாதவை, ஒரு ஒப்பந்தம் டோக்கனின் உரிமையைப் பார்ப்பதன் மூலம்
ஒரு குறிப்பிட்ட டோக்கனைப் பெற்றதை அடையாளம் காண முடியும்.

```python
# @dev ஒரு உரிமையாளருக்காக ஒரு ஆபரேட்டர் இயக்கப்படும்போது அல்லது முடக்கப்படும்போது இது வெளியிடப்படுகிறது. ஆபரேட்டர் உரிமையாளரின்
#      அனைத்து NFT-களையும் நிர்வகிக்க முடியும்.
# @param _owner NFT-இன் உரிமையாளர்.
# @param _operator நாங்கள் ஆபரேட்டர் உரிமைகளை அமைக்கும் முகவரி.
# @param _approved ஆபரேட்டர் உரிமைகளின் நிலை (ஆபரேட்டர் உரிமைகள் வழங்கப்பட்டால் சரி, மற்றும்
# ரத்து செய்யப்பட்டால் தவறு).
event ApprovalForAll:
    owner: indexed(address)
    operator: indexed(address)
    approved: bool
```

ஒரு குறிப்பிட்ட வகை கணக்கின் அனைத்து டோக்கன்களையும் (ஒரு குறிப்பிட்ட ஒப்பந்தத்தால்
நிர்வகிக்கப்படுபவை) நிர்வகிக்கக்கூடிய ஒரு _ஆபரேட்டரைக்_ கொண்டிருப்பது சில நேரங்களில் பயனுள்ளதாக இருக்கும், இது ஒரு அதிகாரப் பத்திரத்தைப் போன்றது. உதாரணமாக, நான் ஆறு மாதங்களாகத் தொடர்பு கொள்ளவில்லை என்பதைச் சரிபார்த்து, அவ்வாறு இருந்தால், என் சொத்துக்களை என் வாரிசுகளுக்குப் பகிர்ந்தளிக்கும் ஒரு ஒப்பந்தத்திற்கு அத்தகைய அதிகாரத்தை வழங்க நான் விரும்பலாம் (அவர்களில் ஒருவர் கேட்டால், ஒரு பரிவர்த்தனையால் அழைக்கப்படாமல் ஒப்பந்தங்கள் எதையும் செய்ய முடியாது). ERC-20 இல் நாம் ஒரு வாரிசு ஒப்பந்தத்திற்கு அதிக ஒதுக்கீட்டைக் கொடுக்கலாம்,
ஆனால் டோக்கன்கள் பதிலீடு செய்ய முடியாததால் இது ERC-721 க்கு வேலை செய்யாது. இது அதற்குச் சமமானது.

`approved` மதிப்பு, நிகழ்வு ஒரு ஒப்புதலுக்கானதா அல்லது ஒரு ஒப்புதலைத் திரும்பப் பெறுவதற்கானதா என்பதை நமக்குத் தெரிவிக்கிறது.

### நிலை மாறிகள் {#state-vars}

இந்த மாறிகள் டோக்கன்களின் தற்போதைய நிலையைக் கொண்டிருக்கின்றன: எவை கிடைக்கின்றன, அவற்றை யார் வைத்திருக்கிறார்கள். இவற்றில் பெரும்பாலானவை
`HashMap` பொருள்கள், [இரண்டு வகைகளுக்கு இடையே இருக்கும் ஒருதிசை வரைபடங்கள்](https://vyper.readthedocs.io/en/latest/types.html#mappings).

```python
# @dev NFT ஐடியிலிருந்து அதை வைத்திருக்கும் முகவரிக்கு வரைபடம்.
idToOwner: HashMap[uint256, address]

# @dev NFT ஐடியிலிருந்து அங்கீகரிக்கப்பட்ட முகவரிக்கு வரைபடம்.
idToApprovals: HashMap[uint256, address]
```

எத்தேரியத்தில் பயனர் மற்றும் ஒப்பந்த அடையாளங்கள் 160-பிட் முகவரிகளால் குறிப்பிடப்படுகின்றன. இந்த இரண்டு மாறிகளும்
டோக்கன் ஐடிகளிலிருந்து அவற்றின் உரிமையாளர்கள் மற்றும் அவற்றை மாற்ற அனுமதிக்கப்பட்டவர்களுடன் (ஒவ்வொன்றிற்கும் அதிகபட்சம் ஒன்று) வரைபடம் செய்கின்றன. எத்தேரியத்தில்,
துவக்கப்படாத தரவு எப்போதும் பூஜ்ஜியமாக இருக்கும், எனவே ஒரு உரிமையாளர் அல்லது அங்கீகரிக்கப்பட்ட மாற்றுபவர் இல்லை என்றால் அந்த டோக்கனுக்கான
மதிப்பு பூஜ்ஜியமாக இருக்கும்.

```python
# @dev உரிமையாளர் முகவரியிலிருந்து அவரது டோக்கன்களின் எண்ணிக்கைக்கான வரைபடம்.
ownerToNFTokenCount: HashMap[address, uint256]
```

இந்த மாறி ஒவ்வொரு உரிமையாளருக்கான டோக்கன்களின் எண்ணிக்கையைக் கொண்டுள்ளது. உரிமையாளர்களிடமிருந்து டோக்கன்களுக்கு எந்த வரைபடமும் இல்லை, எனவே
ஒரு குறிப்பிட்ட உரிமையாளர் வைத்திருக்கும் டோக்கன்களை அடையாளம் காண ஒரே வழி, பிளாக்செயினின் நிகழ்வு வரலாற்றில் பின்னோக்கிப் பார்த்து
பொருத்தமான `Transfer` நிகழ்வுகளைப் பார்ப்பதுதான். நம்மிடம் அனைத்து NFTகளும் இருக்கும்போது, இன்னும்
காலத்தில் பின்னோக்கிப் பார்க்க வேண்டியதில்லை என்பதை அறிய இந்த மாறியைப் பயன்படுத்தலாம்.

இந்த வழிமுறை பயனர் இடைமுகங்கள் மற்றும் வெளிப்புற சர்வர்களுக்கு மட்டுமே செயல்படும் என்பதை நினைவில் கொள்ளவும். பிளாக்செயினில் இயங்கும்
குறியீடு கடந்த நிகழ்வுகளைப் படிக்க முடியாது.

```python
# @dev உரிமையாளர் முகவரியிலிருந்து ஆபரேட்டர் முகவரிகளின் வரைபடத்திற்கான வரைபடம்.
ownerToOperators: HashMap[address, HashMap[address, bool]]
```

ஒரு கணக்கில் ஒன்றுக்கு மேற்பட்ட ஆபரேட்டர்கள் இருக்கலாம். ஒவ்வொரு விசைக்கும் ஒரு ஒற்றை மதிப்புக்கு வழிவகுப்பதால், அவற்றைக்
கண்காணிக்க ஒரு எளிய `HashMap` போதாது. அதற்கு பதிலாக, நீங்கள்
மதிப்பாக `HashMap[address, bool]` ஐப் பயன்படுத்தலாம். இயல்பாக ஒவ்வொரு முகவரிக்குமான மதிப்பு `False` ஆகும், அதாவது அது
ஒரு ஆபரேட்டர் அல்ல. தேவைக்கேற்ப மதிப்புகளை `True` என அமைக்கலாம்.

```python
# @dev ஒரு டோக்கனை உருவாக்கக்கூடிய, மின்ட்டரின் முகவரி
minter: address
```

புதிய டோக்கன்கள் எப்படியாவது உருவாக்கப்பட வேண்டும். இந்த ஒப்பந்தத்தில் அதைச் செய்ய அனுமதிக்கப்பட்ட ஒரே ஒரு நிறுவனம் உள்ளது, அது
`minter` ஆகும். உதாரணமாக, ஒரு விளையாட்டுக்கு இது போதுமானதாக இருக்கலாம். மற்ற நோக்கங்களுக்காக, ஒரு
சிக்கலான வணிக தர்க்கத்தை உருவாக்க வேண்டியிருக்கலாம்.

```python
# @dev இடைமுக ஐடியிலிருந்து அது ஆதரிக்கப்படுகிறதா இல்லையா என்பது பற்றிய பூலியனுக்கான வரைபடம்
supportedInterfaces: HashMap[bytes32, bool]

# @dev ERC165-இன் ERC165 இடைமுக ஐடி
ERC165_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000001ffc9a7

# @dev ERC721-இன் ERC165 இடைமுக ஐடி
ERC721_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000080ac58cd
```

[ERC-165](https://eips.ethereum.org/EIPS/eip-165) ஆனது ஒரு ஒப்பந்தம், பயன்பாடுகள்
அதனுடன் எவ்வாறு தொடர்பு கொள்ளலாம், அது எந்த ERC-களுடன் ஒத்துப்போகிறது என்பதை வெளிப்படுத்த ஒரு வழிமுறையைக் குறிப்பிடுகிறது. இந்த வழக்கில், ஒப்பந்தம் ERC-165 மற்றும் ERC-721 உடன் ஒத்துப்போகிறது.

### செயல்பாடுகள் {#functions}

இவைதான் ERC-721 ஐ உண்மையில் செயல்படுத்தும் செயல்பாடுகள்.

#### உருவாக்குபவர் {#constructor}

```python
@external
def __init__():
```

பைத்தானைப் போலவே, Vyper-இலும், உருவாக்குபவர் செயல்பாடு `__init__` என்று அழைக்கப்படுகிறது.

```python
    """
    @dev ஒப்பந்த உருவாக்குபவர்.
    """
```

பைத்தான் மற்றும் Vyper-இல், ஒரு பல-வரி சரத்தை (`"""` உடன் தொடங்கி முடியும்) குறிப்பிட்டு, அதை எந்த வகையிலும் பயன்படுத்தாமல் ஒரு குறிப்புரையை உருவாக்கலாம். இந்தக் குறிப்புரைகளில்
[NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) உம் இருக்கலாம்.

```python
    self.supportedInterfaces[ERC165_INTERFACE_ID] = True
    self.supportedInterfaces[ERC721_INTERFACE_ID] = True
    self.minter = msg.sender
```

நிலை மாறிகளை அணுக, நீங்கள் `self.<மாறி பெயர்>` ஐப் பயன்படுத்துகிறீர்கள்` (மீண்டும், பைத்தானில் உள்ளதைப் போலவே).

#### செயல்பாடுகளைக் காண்க {#views}

இவை பிளாக்செயினின் நிலையை மாற்றியமைக்காத செயல்பாடுகள், எனவே அவை வெளிப்புறமாக அழைக்கப்பட்டால் இலவசமாக
செயல்படுத்தப்படலாம். பார்வை செயல்பாடுகள் ஒரு ஒப்பந்தத்தால் அழைக்கப்பட்டால், அவை ஒவ்வொரு
முனையிலும் செயல்படுத்தப்பட வேண்டும், எனவே எரிவாயு செலவாகும்.

```python
@view
@external
```

ஒரு செயல்பாட்டு வரையறைக்கு முன்னர் ஒரு அட் குறியுடன் (`@`) தொடங்கும் இந்த முக்கிய வார்த்தைகள் _அலங்காரங்கள்_ என்று அழைக்கப்படுகின்றன. ஒரு
செயல்பாட்டை எந்தச் சூழ்நிலைகளில் அழைக்கலாம் என்பதை அவை குறிப்பிடுகின்றன.

- `@view` இந்த செயல்பாடு ஒரு பார்வை என்பதைக் குறிப்பிடுகிறது.
- `@external` இந்த குறிப்பிட்ட செயல்பாட்டை பரிவர்த்தனைகள் மற்றும் பிற ஒப்பந்தங்கள் மூலம் அழைக்கலாம் என்பதைக் குறிப்பிடுகிறது.

```python
def supportsInterface(_interfaceID: bytes32) -> bool:
```

பைத்தானுக்கு மாறாக, Vyper ஒரு [நிலையான தட்டச்சு செய்யப்பட்ட மொழி](https://wikipedia.org/wiki/Type_system#Static_type_checking) ஆகும்.
[தரவு வகையை](https://vyper.readthedocs.io/en/latest/types.html) அடையாளம் காணாமல் நீங்கள் ஒரு மாறி அல்லது செயல்பாட்டு அளவுருவை அறிவிக்க முடியாது. இந்த வழக்கில் உள்ளீட்டு அளவுரு `bytes32` ஆகும், இது ஒரு 256-பிட் மதிப்பு
([எத்தேரியம் மெய்நிகர் இயந்திரத்தின்](/developers/docs/evm/) சொந்த சொல் அளவு 256 பிட்கள்). வெளியீடு ஒரு பூலியன்
மதிப்பு. மரபுப்படி, செயல்பாட்டு அளவுருக்களின் பெயர்கள் ஒரு அடிக்கோடிட்டு (`_`) உடன் தொடங்குகின்றன.

```python
    """
    @dev இடைமுக அடையாளம் ERC-165 இல் குறிப்பிடப்பட்டுள்ளது.
    @param _interfaceID இடைமுகத்தின் ஐடி
    """
    return self.supportedInterfaces[_interfaceID]
```

`self.supportedInterfaces` HashMap-லிருந்து மதிப்பைத் திருப்புக, இது உருவாக்குபவரில் (`__init__`) அமைக்கப்பட்டுள்ளது.

```python
### காட்சி செயல்பாடுகள் ###
```

டோக்கன்கள் பற்றிய தகவல்களைப் பயனர்கள் மற்றும் பிற ஒப்பந்தங்களுக்குக் கிடைக்கச் செய்யும் பார்வை செயல்பாடுகள் இவை.

```python
@view
@external
def balanceOf(_owner: address) -> uint256:
    """
    @dev `_owner`-க்கு சொந்தமான NFT-களின் எண்ணிக்கையைத் திருப்புகிறது.
         `_owner` பூஜ்ஜிய முகவரியாக இருந்தால் எறியும். பூஜ்ஜிய முகவரிக்கு ஒதுக்கப்பட்ட NFT-கள் செல்லாதவையாகக் கருதப்படுகின்றன.
    @param _owner இருப்புத்தொகையைக் கோர வேண்டியவருக்கான முகவரி.
    """
    assert _owner != ZERO_ADDRESS
```

இந்த வரி `_owner` பூஜ்ஜியமாக
இல்லை என்று [உறுதிப்படுத்துகிறது](https://vyper.readthedocs.io/en/latest/statements.html#assert). அப்படி இருந்தால், ஒரு பிழை ஏற்பட்டு செயல்பாடு மாற்றியமைக்கப்படுகிறது.

```python
    return self.ownerToNFTokenCount[_owner]

@view
@external
def ownerOf(_tokenId: uint256) -> address:
    """
    @dev NFT-யின் உரிமையாளரின் முகவரியைத் திருப்புகிறது.
         `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்.
    @param _tokenId ஒரு NFT-க்கான அடையாளம்.
    """
    owner: address = self.idToOwner[_tokenId]
    # `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்
    assert owner != ZERO_ADDRESS
    return owner
```

எத்தேரியம் மெய்நிகர் இயந்திரத்தில் (evm) எந்தவொரு சேமிப்பகத்தில் மதிப்பு சேமிக்கப்படவில்லை என்றாலும் அது பூஜ்ஜியமாகும்.
`_tokenId`-ல் டோக்கன் இல்லை என்றால், `self.idToOwner[_tokenId]`-ன் மதிப்பு பூஜ்ஜியமாகும். அப்படியானால்
செயல்பாடு மாற்றியமைக்கப்படுகிறது.

```python
@view
@external
def getApproved(_tokenId: uint256) -> address:
    """
    @dev ஒரு ஒற்றை NFT-க்கான அங்கீகரிக்கப்பட்ட முகவரியைப் பெறவும்.
         `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்.
    @param _tokenId அங்கீகாரத்தைக் கோர NFT-யின் ஐடி.
    """
    # `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்
    assert self.idToOwner[_tokenId] != ZERO_ADDRESS
    return self.idToApprovals[_tokenId]
```

`getApproved` பூஜ்ஜியத்தைத் _திருப்ப முடியும்_ என்பதை நினைவில் கொள்ளவும். டோக்கன் செல்லுபடியாகும் என்றால், அது `self.idToApprovals[_tokenId]`-ஐத் திருப்புகிறது.
அங்கீகரிப்பவர் இல்லை என்றால் அந்த மதிப்பு பூஜ்ஜியமாகும்.

```python
@view
@external
def isApprovedForAll(_owner: address, _operator: address) -> bool:
    """
    @dev `_operator` `_owner`-க்கான அங்கீகரிக்கப்பட்ட ஆபரேட்டரா என்பதைச் சரிபார்க்கிறது.
    @param _owner NFT-களை வைத்திருக்கும் முகவரி.
    @param _operator உரிமையாளர் சார்பாகச் செயல்படும் முகவரி.
    """
    return (self.ownerToOperators[_owner])[_operator]
```

இந்த ஒப்பந்தத்தில் `_operator` `_owner`-இன் அனைத்து டோக்கன்களையும் நிர்வகிக்க அனுமதிக்கப்பட்டுள்ளதா என்பதை இந்தச் செயல்பாடு சரிபார்க்கிறது.
பல ஆபரேட்டர்கள் இருக்க முடியும் என்பதால், இது இரண்டு நிலை HashMap ஆகும்.

#### உதவிச் செயல்பாடுகளை மாற்றவும் {#transfer-helpers}

இந்தச் செயல்பாடுகள் டோக்கன்களை மாற்றுவது அல்லது நிர்வகிப்பதன் ஒரு பகுதியாக இருக்கும் செயல்பாடுகளைச் செயல்படுத்துகின்றன.

```python

### இடமாற்ற செயல்பாட்டு உதவிகள் ###

@view
@internal
```

இந்த அலங்காரம், `@internal`, இந்தச் செயல்பாடு அதே ஒப்பந்தத்தில் உள்ள மற்ற செயல்பாடுகளிலிருந்து மட்டுமே அணுகக்கூடியது என்பதைக் குறிக்கிறது. மரபுப்படி, இந்தச் செயல்பாட்டுப் பெயர்களும் ஒரு அடிக்கோடிட்டு (`_`) உடன் தொடங்குகின்றன.

```python
def _isApprovedOrOwner(_spender: address, _tokenId: uint256) -> bool:
    """
    @dev கொடுக்கப்பட்ட செலவாளி ஒரு குறிப்பிட்ட டோக்கன் ஐடியை மாற்ற முடியுமா என்பதைத் திருப்புகிறது
    @param spender கோர வேண்டிய செலவாளியின் முகவரி
    @param tokenId மாற்றப்பட வேண்டிய டோக்கனின் uint256 ஐடி
    @return bool msg.sender கொடுக்கப்பட்ட டோக்கன் ஐடிக்கு அங்கீகரிக்கப்பட்டுள்ளாரா,
        உரிமையாளரின் ஒரு ஆபரேட்டரா, அல்லது டோக்கனின் உரிமையாளரா என்பதைத் திருப்புகிறது
    """
    owner: address = self.idToOwner[_tokenId]
    spenderIsOwner: bool = owner == _spender
    spenderIsApproved: bool = _spender == self.idToApprovals[_tokenId]
    spenderIsApprovedForAll: bool = (self.ownerToOperators[owner])[_spender]
    return (spenderIsOwner or spenderIsApproved) or spenderIsApprovedForAll
```

ஒரு டோக்கனை மாற்ற ஒரு முகவரி அனுமதிக்கப்படுவதற்கு மூன்று வழிகள் உள்ளன:

1. முகவரி டோக்கனின் உரிமையாளர்
2. அந்த டோக்கனைச் செலவழிக்க முகவரி அங்கீகரிக்கப்பட்டுள்ளது
3. முகவரி டோக்கனின் உரிமையாளருக்கான ஒரு ஆபரேட்டர்

மேலே உள்ள செயல்பாடு நிலையை மாற்றாததால் ஒரு பார்வையாக இருக்கலாம். செயல்பாட்டுச் செலவுகளைக் குறைக்க, ஒரு
பார்வையாக இருக்க _கூடிய_ எந்தவொரு செயல்பாடும் ஒரு பார்வையாக _இருக்க வேண்டும்_.

```python
@internal
def _addTokenTo(_to: address, _tokenId: uint256):
    """
    @dev ஒரு NFT-ஐக் கொடுக்கப்பட்ட முகவரியில் சேர்க்கவும்
         `_tokenId` ஒருவருக்குச் சொந்தமானது என்றால் எறியும்.
    """
    # `_tokenId` ஒருவருக்குச் சொந்தமானது என்றால் எறியும்
    assert self.idToOwner[_tokenId] == ZERO_ADDRESS
    # உரிமையாளரை மாற்றவும்
    self.idToOwner[_tokenId] = _to
    # எண்ணிக்கை கண்காணிப்பை மாற்றவும்
    self.ownerToNFTokenCount[_to] += 1


@internal
def _removeTokenFrom(_from: address, _tokenId: uint256):
    """
    @dev ஒரு NFT-ஐக் கொடுக்கப்பட்ட முகவரியிலிருந்து அகற்றவும்
         `_from` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்.
    """
    # `_from` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்
    assert self.idToOwner[_tokenId] == _from
    # உரிமையாளரை மாற்றவும்
    self.idToOwner[_tokenId] = ZERO_ADDRESS
    # எண்ணிக்கை கண்காணிப்பை மாற்றவும்
    self.ownerToNFTokenCount[_from] -= 1
```

ஒரு பரிமாற்றத்தில் சிக்கல் ஏற்படும்போது, நாங்கள் அழைப்பை மாற்றியமைக்கிறோம்.

```python
@internal
def _clearApproval(_owner: address, _tokenId: uint256):
    """
    @dev கொடுக்கப்பட்ட முகவரியின் அங்கீகாரத்தைத் தெளிவுபடுத்தவும்
         `_owner` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்.
    """
    # `_owner` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்
    assert self.idToOwner[_tokenId] == _owner
    if self.idToApprovals[_tokenId] != ZERO_ADDRESS:
        # அங்கீகாரங்களை மீட்டமைக்கவும்
        self.idToApprovals[_tokenId] = ZERO_ADDRESS
```

தேவைப்பட்டால் மட்டுமே மதிப்பை மாற்றவும். நிலை மாறிகள் சேமிப்பகத்தில் வாழ்கின்றன. சேமிப்பகத்தில் எழுதுவது EVM (எத்தேரியம் மெய்நிகர் இயந்திரம்) செய்யும் மிகவும் விலையுயர்ந்த செயல்பாடுகளில் ஒன்றாகும்
([gas](/developers/docs/gas/) அடிப்படையில்). எனவே, அதை மிகக்குறைவாக வைத்திருப்பது ஒரு நல்ல யோசனையாகும், தற்போதைய
மதிப்பை எழுதுவது கூட அதிக செலவைக் கொண்டுள்ளது.

```python
@internal
def _transferFrom(_from: address, _to: address, _tokenId: uint256, _sender: address):
    """
    @dev ஒரு NFT-யின் இடமாற்றத்தைச் செயல்படுத்தவும்.
         `msg.sender` தற்போதைய உரிமையாளர், அங்கீகரிக்கப்பட்ட ஆபரேட்டர், அல்லது இந்த NFT-க்கான அங்கீகரிக்கப்பட்ட
         முகவரி இல்லை என்றால் எறியும். (குறிப்பு: `msg.sender` தனிப்பட்ட செயல்பாட்டில் அனுமதிக்கப்படவில்லை, எனவே `_sender` ஐ அனுப்பவும்.)
         `_to` பூஜ்ஜிய முகவரியாக இருந்தால் எறியும்.
         `_from` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்.
         `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்.
    """
```

டோக்கன்களை மாற்றுவதற்கு இரண்டு வழிகள் (வழக்கமான மற்றும் பாதுகாப்பான) இருப்பதால்தான் இந்த உள் செயல்பாடு உள்ளது, ஆனால் தணிக்கையை எளிதாக்க குறியீட்டில் ஒரே ஒரு இடத்தில் மட்டுமே அதைச் செய்ய விரும்புகிறோம்.

```python
    # தேவைகளைச் சரிபார்க்கவும்
    assert self._isApprovedOrOwner(_sender, _tokenId)
    # `_to` பூஜ்ஜிய முகவரியாக இருந்தால் எறியும்
    assert _to != ZERO_ADDRESS
    # அங்கீகாரத்தைத் தெளிவுபடுத்தவும். `_from` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்
    self._clearApproval(_from, _tokenId)
    # NFT-ஐ அகற்றவும். `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்
    self._removeTokenFrom(_from, _tokenId)
    # NFT-ஐச் சேர்க்கவும்
    self._addTokenTo(_to, _tokenId)
    # இடமாற்றத்தைப் பதிவு செய்யவும்
    log Transfer(_from, _to, _tokenId)
```

Vyper இல் ஒரு நிகழ்வை வெளியிட, நீங்கள் ஒரு `log` அறிக்கையைப் பயன்படுத்துகிறீர்கள் ([மேலும் விவரங்களுக்கு இங்கே பார்க்கவும்](https://vyper.readthedocs.io/en/latest/event-logging.html#event-logging)).

#### இடமாற்று செயல்பாடுகள் {#transfer-funs}

```python

### இடமாற்று செயல்பாடுகள் ###

@external
def transferFrom(_from: address, _to: address, _tokenId: uint256):
    """
    @dev `msg.sender` தற்போதைய உரிமையாளர், அங்கீகரிக்கப்பட்ட ஆபரேட்டர், அல்லது இந்த NFT-க்கான அங்கீகரிக்கப்பட்ட
         முகவரி இல்லை என்றால் எறியும்.
         `_from` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்.
         `_to` பூஜ்ஜிய முகவரியாக இருந்தால் எறியும்.
         `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்.
    @notice `_to` NFT-களைப் பெறும் திறன் உள்ளதா என்பதை அழைப்பாளர் உறுதிப்படுத்துவது அவரின் பொறுப்பாகும், இல்லையெனில்
            அவை நிரந்தரமாக இழக்கப்படலாம்.
    @param _from NFT-யின் தற்போதைய உரிமையாளர்.
    @param _to புதிய உரிமையாளர்.
    @param _tokenId மாற்ற வேண்டிய NFT.
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

இந்தச் செயல்பாடு உங்களை ஒரு தன்னிச்சையான முகவரிக்கு மாற்ற அனுமதிக்கிறது. முகவரி ஒரு பயனராகவோ அல்லது டோக்கன்களை எப்படி மாற்றுவது என்று தெரிந்த ஒரு ஒப்பந்தமாகவோ
இல்லாவிட்டால், நீங்கள் மாற்றும் எந்த டோக்கனும் அந்த முகவரியில் சிக்கி பயனற்றதாகிவிடும்.

```python
@external
def safeTransferFrom(
        _from: address,
        _to: address,
        _tokenId: uint256,
        _data: Bytes[1024]=b""
    ):
    """
    @dev ஒரு முகவரியிலிருந்து மற்றொரு முகவரிக்கு ஒரு NFT-யின் உரிமையை மாற்றுகிறது.
         `msg.sender` தற்போதைய உரிமையாளர், அங்கீகரிக்கப்பட்ட ஆபரேட்டர், அல்லது இந்த NFT-க்கான
         அங்கீகரிக்கப்பட்ட முகவரி இல்லை என்றால் எறியும்.
         `_from` தற்போதைய உரிமையாளர் இல்லை என்றால் எறியும்.
         `_to` பூஜ்ஜிய முகவரியாக இருந்தால் எறியும்.
         `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்.
         `_to` ஒரு ஸ்மார்ட் ஒப்பந்தமாக இருந்தால், அது `onERC721Received` ஐ `_to` மீது அழைத்து, திருப்பு மதிப்பு
         `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` இல்லை என்றால் எறியும்.
         குறிப்பு: bytes4 என்பது பேடிங்குடன் bytes32 ஆல் குறிப்பிடப்படுகிறது
    @param _from NFT-யின் தற்போதைய உரிமையாளர்.
    @param _to புதிய உரிமையாளர்.
    @param _tokenId மாற்ற வேண்டிய NFT.
    @param _data எந்தவொரு குறிப்பிட்ட வடிவமும் இல்லாத கூடுதல் தரவு, `_to`-க்கு அழைப்பில் அனுப்பப்பட்டது.
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

முதலில் பரிமாற்றத்தைச் செய்வது சரியானது, ஏனெனில் சிக்கல் ஏற்பட்டால் எப்படியும் மாற்றியமைக்கப் போகிறோம்,
எனவே அழைப்பில் செய்யப்படும் அனைத்தும் ரத்து செய்யப்படும்.

```python
    if _to.is_contract: # `_to` ஒரு ஒப்பந்த முகவரியா என்று சரிபார்க்கவும்
```

முதலில் முகவரி ஒரு ஒப்பந்தமா (அதற்கு குறியீடு உள்ளதா) என்பதைச் சரிபார்க்கவும். இல்லை என்றால், அது ஒரு பயனர்
முகவரி என்று கருதி, பயனர் டோக்கனைப் பயன்படுத்த அல்லது மாற்ற முடியும். ஆனால் அது உங்களை ஒரு
தவறான பாதுகாப்பு உணர்வுக்குள் தள்ளிவிட வேண்டாம். நீங்கள் டோக்கன்களை யாருக்கும் தெரியாத தனிப்பட்ட விசை கொண்ட ஒரு முகவரிக்கு மாற்றினால்,
`safeTransferFrom` பயன்படுத்தினாலும், டோக்கன்களை இழக்க நேரிடலாம்.

```python
        returnValue: bytes32 = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data)
```

இலக்கு ஒப்பந்தம் ERC-721 டோக்கன்களைப் பெற முடியுமா என்று பார்க்க அதை அழைக்கவும்.

```python
        # இடமாற்று சேருமிடம் 'onERC721Received' ஐ செயல்படுத்தாத ஒரு ஒப்பந்தமாக இருந்தால் எறியும்
        assert returnValue == method_id("onERC721Received(address,address,uint256,bytes)", output_type=bytes32)
```

சேருமிடம் ஒரு ஒப்பந்தமாக இருந்தாலும், அது ERC-721 டோக்கன்களை ஏற்காத (அல்லது இந்த
குறிப்பிட்ட பரிமாற்றத்தை ஏற்க வேண்டாம் என்று முடிவு செய்த) ஒன்றாக இருந்தால், மாற்றியமைக்கவும்.

```python
@external
def approve(_approved: address, _tokenId: uint256):
    """
    @dev ஒரு NFT-க்கான அங்கீகரிக்கப்பட்ட முகவரியை அமைக்கவும் அல்லது மீண்டும் உறுதிப்படுத்தவும். பூஜ்ஜிய முகவரி அங்கீகரிக்கப்பட்ட முகவரி இல்லை என்பதைக் குறிக்கிறது.
         `msg.sender` தற்போதைய NFT உரிமையாளர் அல்லது தற்போதைய உரிமையாளரின் அங்கீகரிக்கப்பட்ட ஆபரேட்டர் இல்லை என்றால் எறியும்.
         `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும். (குறிப்பு: இது EIP இல் எழுதப்படவில்லை)
         `_approved` தற்போதைய உரிமையாளராக இருந்தால் எறியும். (குறிப்பு: இது EIP இல் எழுதப்படவில்லை)
    @param _approved கொடுக்கப்பட்ட NFT ஐடிக்கு அங்கீகரிக்கப்பட வேண்டிய முகவரி.
    @param _tokenId அங்கீகரிக்கப்பட வேண்டிய டோக்கனின் ஐடி.
    """
    owner: address = self.idToOwner[_tokenId]
    # `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்
    assert owner != ZERO_ADDRESS
    # `_approved` தற்போதைய உரிமையாளராக இருந்தால் எறியும்
    assert _approved != owner
```

மரபுப்படி, நீங்கள் ஒரு அங்கீகரிப்பாளரைக் கொண்டிருக்க விரும்பவில்லை என்றால், பூஜ்ஜிய முகவரியை நியமிக்கிறீர்கள், உங்களை அல்ல.

```python
    # தேவைகளைச் சரிபார்க்கவும்
    senderIsOwner: bool = self.idToOwner[_tokenId] == msg.sender
    senderIsApprovedForAll: bool = (self.ownerToOperators[owner])[msg.sender]
    assert (senderIsOwner or senderIsApprovedForAll)
```

ஒரு ஒப்புதலை அமைக்க, நீங்கள் உரிமையாளராக இருக்கலாம் அல்லது உரிமையாளரால் அங்கீகரிக்கப்பட்ட ஒரு ஆபரேட்டராக இருக்கலாம்.

```python
    # அங்கீகாரத்தை அமைக்கவும்
    self.idToApprovals[_tokenId] = _approved
    log Approval(owner, _approved, _tokenId)


@external
def setApprovalForAll(_operator: address, _approved: bool):
    """
    @dev `msg.sender`-இன் அனைத்து சொத்துக்களையும் நிர்வகிக்க ஒரு மூன்றாம் தரப்பினருக்கு ("ஆபரேட்டர்") அங்கீகாரத்தை இயக்குகிறது அல்லது முடக்குகிறது. இது ApprovalForAll நிகழ்வையும் வெளியிடுகிறது.
         `_operator` `msg.sender` ஆக இருந்தால் எறியும். (குறிப்பு: இது EIP இல் எழுதப்படவில்லை)
    @notice அனுப்புநர் அந்த நேரத்தில் எந்த டோக்கன்களையும் வைத்திருக்கவில்லை என்றாலும் இது வேலை செய்யும்.
    @param _operator அங்கீகரிக்கப்பட்ட ஆபரேட்டர்களின் தொகுப்பில் சேர்க்க வேண்டிய முகவரி.
    @param _approved ஆபரேட்டர்கள் அங்கீகரிக்கப்பட்டால் True, அங்கீகாரத்தை ரத்து செய்ய false.
    """
    # `_operator` `msg.sender` ஆக இருந்தால் எறியும்
    assert _operator != msg.sender
    self.ownerToOperators[msg.sender][_operator] = _approved
    log ApprovalForAll(msg.sender, _operator, _approved)
```

#### புதிய டோக்கன்களை மின்ட் செய்யவும் மற்றும் தற்போதுள்ளவற்றை அழிக்கவும் {#mint-burn}

ஒப்பந்தத்தை உருவாக்கிய கணக்கு `minter` ஆகும், இது புதிய NFT-களை
மின்ட் செய்ய அங்கீகரிக்கப்பட்ட சூப்பர் பயனர் ஆகும். இருப்பினும், தற்போதுள்ள டோக்கன்களை எரிக்க அது கூட அனுமதிக்கப்படவில்லை. உரிமையாளர் அல்லது உரிமையாளரால்
அங்கீகரிக்கப்பட்ட ஒரு நிறுவனம் மட்டுமே அதைச் செய்ய முடியும்.

```python
### மின்ட் & பர்ன் செயல்பாடுகள் ###

@external
def mint(_to: address, _tokenId: uint256) -> bool:
```

இந்தச் செயல்பாடு எப்போதும் `True` ஐத் திருப்புகிறது, ஏனெனில் செயல்பாடு தோல்வியுற்றால் அது மாற்றியமைக்கப்படுகிறது.

```python
    """
    @dev டோக்கன்களை மின்ட் செய்வதற்கான செயல்பாடு
         `msg.sender` மின்ட்டராக இல்லாவிட்டால் எறியும்.
         `_to` பூஜ்ஜிய முகவரியாக இருந்தால் எறியும்.
         `_tokenId` ஒருவருக்குச் சொந்தமானது என்றால் எறியும்.
    @param _to மின்ட் செய்யப்பட்ட டோக்கன்களைப் பெறும் முகவரி.
    @param _tokenId மின்ட் செய்ய வேண்டிய டோக்கன் ஐடி.
    @return செயல்பாடு வெற்றிகரமாக இருந்ததா என்பதைக் குறிக்கும் ஒரு பூலியன்.
    """
    # `msg.sender` மின்ட்டராக இல்லாவிட்டால் எறியும்
    assert msg.sender == self.minter
```

மின்ட்டர் (ERC-721 ஒப்பந்தத்தை உருவாக்கிய கணக்கு) மட்டுமே புதிய டோக்கன்களை மின்ட் செய்ய முடியும். எதிர்காலத்தில் மின்ட்டரின் அடையாளத்தை மாற்ற விரும்பினால் இது ஒரு
பிரச்சனையாக இருக்கலாம். ஒரு
தயாரிப்பு ஒப்பந்தத்தில், மின்ட்டர் சிறப்புரிமைகளை
வேறு யாருக்காவது மாற்ற அனுமதிக்கும் ஒரு செயல்பாடு நீங்கள் விரும்பலாம்.

```python
    # `_to` பூஜ்ஜிய முகவரியாக இருந்தால் எறியும்
    assert _to != ZERO_ADDRESS
    # NFT-ஐச் சேர்க்கவும். `_tokenId` ஒருவருக்குச் சொந்தமானது என்றால் எறியும்
    self._addTokenTo(_to, _tokenId)
    log Transfer(ZERO_ADDRESS, _to, _tokenId)
    return True
```

மரபுப்படி, புதிய டோக்கன்களை மின்ட் செய்வது பூஜ்ஜிய முகவரியிலிருந்து ஒரு இடமாற்றமாகக் கருதப்படுகிறது.

```python

@external
def burn(_tokenId: uint256):
    """
    @dev ஒரு குறிப்பிட்ட ERC721 டோக்கனை எரிக்கிறது.
         `msg.sender` தற்போதைய உரிமையாளர், அங்கீகரிக்கப்பட்ட ஆபரேட்டர், அல்லது இந்த NFT-க்கான அங்கீகரிக்கப்பட்ட
         முகவரி இல்லை என்றால் எறியும்.
         `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்.
    @param _tokenId எரிக்கப்பட வேண்டிய ERC721 டோக்கனின் uint256 ஐடி.
    """
    # தேவைகளைச் சரிபார்க்கவும்
    assert self._isApprovedOrOwner(msg.sender, _tokenId)
    owner: address = self.idToOwner[_tokenId]
    # `_tokenId` ஒரு செல்லுபடியாகும் NFT இல்லை என்றால் எறியும்
    assert owner != ZERO_ADDRESS
    self._clearApproval(owner, _tokenId)
    self._removeTokenFrom(owner, _tokenId)
    log Transfer(owner, ZERO_ADDRESS, _tokenId)
```

ஒரு டோக்கனை மாற்ற அனுமதிக்கப்பட்ட எவரும் அதை எரிக்க அனுமதிக்கப்படுகிறார்கள். ஒரு எரிப்பு என்பது பூஜ்ஜிய முகவரிக்கு மாற்றுவதற்குச்
சமமாகத் தோன்றினாலும், பூஜ்ஜிய முகவரி உண்மையில் டோக்கனைப் பெறுவதில்லை. இது டோக்கனுக்காகப் பயன்படுத்தப்பட்ட அனைத்து சேமிப்பகத்தையும் விடுவிக்க
அனுமதிக்கிறது, இது பரிவர்த்தனையின் எரிவாயு செலவைக் குறைக்கும்.

## இந்த ஒப்பந்தத்தைப் பயன்படுத்துதல் {#using-contract}

Solidity-க்கு மாறாக, Vyper-க்கு மரபுரிமை இல்லை. குறியீட்டைத் தெளிவாகவும், எனவே பாதுகாக்கவும் எளிதாக்குவதற்காக இது ஒரு திட்டமிட்ட வடிவமைப்புத் தேர்வாகும். எனவே உங்கள் சொந்த Vyper ERC-721 ஒப்பந்தத்தை உருவாக்க, நீங்கள் இந்த
ஒப்பந்தத்தை எடுத்து, நீங்கள் விரும்பும் வணிக தர்க்கத்தைச் செயல்படுத்த
அதை மாற்றியமைக்கிறீர்கள்.

## முடிவுரை {#conclusion}

மதிப்பாய்வுக்காக, இந்த ஒப்பந்தத்தில் உள்ள சில மிக முக்கியமான யோசனைகள் இங்கே:

- பாதுகாப்பான இடமாற்றத்துடன் ERC-721 டோக்கன்களைப் பெற, ஒப்பந்தங்கள் `ERC721Receiver` இடைமுகத்தைச் செயல்படுத்த வேண்டும்.
- பாதுகாப்பான இடமாற்றத்தைப் பயன்படுத்தினாலும், டோக்கன்களை அதன் தனிப்பட்ட விசை
  தெரியாத முகவரிக்கு அனுப்பினால் அவை சிக்கிக்கொள்ளக்கூடும்.
- ஒரு செயல்பாட்டில் சிக்கல் ஏற்படும்போது, தோல்வி மதிப்பைத் திருப்புவதை விட,
  அழைப்பை `revert` செய்வது ஒரு நல்ல யோசனை.
- ERC-721 டோக்கன்கள் ஒரு உரிமையாளரைக் கொண்டிருக்கும்போது இருக்கும்.
- ஒரு NFT ஐ மாற்றுவதற்கு அங்கீகரிக்கப்படுவதற்கு மூன்று வழிகள் உள்ளன. நீங்கள் உரிமையாளராக இருக்கலாம், ஒரு குறிப்பிட்ட டோக்கனுக்கு அங்கீகரிக்கப்பட்டிருக்கலாம்,
  அல்லது உரிமையாளரின் அனைத்து டோக்கன்களுக்கும் ஒரு ஆபரேட்டராக இருக்கலாம்.
- கடந்த கால நிகழ்வுகள் பிளாக்செயினுக்கு வெளியே மட்டுமே தெரியும். பிளாக்செயினுக்குள் இயங்கும் குறியீடு அவற்றைப் பார்க்க முடியாது.

இப்போது சென்று பாதுகாப்பான Vyper ஒப்பந்தங்களைச் செயல்படுத்தவும்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).

