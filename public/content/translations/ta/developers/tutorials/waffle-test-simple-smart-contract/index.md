---
title: "Waffle நூலகத்துடன் எளிய ஸ்மார்ட் கான்ட்ராக்ட்டை சோதித்தல்"
description: "தொடக்கநிலையாளர்களுக்கான பயிற்சி"
author: Ewa Kowalska
tags: [ "ஸ்மார்ட் ஒப்பந்தங்கள்", "திட்பம்", "Waffle", "சோதனை" ]
skill: beginner
lang: ta
published: 2021-02-26
---

## இந்த பயிற்சியில் நீங்கள் கற்றுக்கொள்வது {#in-this-tutorial-youll-learn-how-to}

- பணப்பை இருப்பின் மாற்றங்களைச் சோதித்தல்
- குறிப்பிட்ட தருமதிப்புகளுடன் நிகழ்வுகளின் வெளியீட்டைச் சோதித்தல்
- ஒரு பரிவர்த்தனை ரத்து செய்யப்பட்டது என்பதை உறுதி செய்தல்

## அனுமானங்கள் {#assumptions}

- நீங்கள் ஒரு புதிய JavaScript அல்லது TypeScript திட்டத்தை உருவாக்க முடியும்
- JavaScript-இல் சோதனைகளில் உங்களுக்கு சில அடிப்படை அனுபவம் உள்ளது
- yarn அல்லது npm போன்ற சில தொகுப்பு மேலாளர்களை நீங்கள் பயன்படுத்தியுள்ளீர்கள்
- ஸ்மார்ட் கான்ட்ராக்ட்கள் மற்றும் Solidity பற்றி உங்களுக்கு மிக அடிப்படையான அறிவு உள்ளது

## தொடங்குதல் {#getting-started}

இந்த பயிற்சி yarn-ஐப் பயன்படுத்தி சோதனை அமைப்பு மற்றும் இயக்கத்தை விளக்குகிறது, ஆனால் நீங்கள் npm-ஐ விரும்பினால் எந்தப் பிரச்சனையும் இல்லை - நான் அதிகாரப்பூர்வ Waffle [ஆவணத்திற்கான](https://ethereum-waffle.readthedocs.io/en/latest/index.html) சரியான குறிப்புகளை வழங்குவேன்.

## சார்புநிலைகளை நிறுவுதல் {#install-dependencies}

உங்கள் திட்டத்தின் dev சார்புநிலைகளில் ethereum-waffle மற்றும் typescript சார்புநிலைகளை [சேர்க்கவும்](https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html#installation).

```bash
yarn add --dev ethereum-waffle ts-node typescript @types/jest
```

## எடுத்துக்காட்டு ஸ்மார்ட் கான்ட்ராக்ட் {#example-smart-contract}

பயிற்சியின் போது, EtherSplitter என்ற ஒரு எளிய ஸ்மார்ட் கான்ட்ராக்ட் எடுத்துக்காட்டில் நாம் வேலை செய்வோம். யாரும் சில wei அனுப்பி அதை முன்னரே வரையறுக்கப்பட்ட இரண்டு பெறுநர்களுக்கு இடையில் சமமாகப் பிரிக்க அனுமதிப்பதைத் தவிர இது வேறு அதிகமாக எதையும் செய்வதில்லை.
split செயல்பாடு wei-இன் எண்ணிக்கை இரட்டைப்படை எண்ணாக இருக்க வேண்டும் என்று கோருகிறது, இல்லையெனில் அது ரத்து செய்யப்படும். இரண்டு பெறுநர்களுக்கும் இது ஒரு wei பரிமாற்றத்தைச் செய்கிறது, அதைத் தொடர்ந்து Transfer நிகழ்வு வெளியிடப்படுகிறது.

EtherSplitter குறியீட்டின் துணுக்கை `src/EtherSplitter.sol` இல் வைக்கவும்.

```solidity
pragma solidity ^0.6.0;

contract EtherSplitter {
    address payable receiver1;
    address payable receiver2;

    event Transfer(address from, address to, uint256 amount);

    constructor(address payable _address1, address payable _address2) public {
        receiver1 = _address1;
        receiver2 = _address2;
    }

    function split() public payable {
        require(msg.value % 2 == 0, 'ஒற்றைப்படை wei தொகை அனுமதிக்கப்படவில்லை');
        receiver1.transfer(msg.value / 2);
        emit Transfer(msg.sender, receiver1, msg.value / 2);
        receiver2.transfer(msg.value / 2);
        emit Transfer(msg.sender, receiver2, msg.value / 2);
    }
}
```

## கான்ட்ராக்ட்டை தொகுத்தல் {#compile-the-contract}

கான்ட்ராக்ட்டை [தொகுக்க](https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html#compiling-the-contract), package.json கோப்பில் பின்வரும் உள்ளீட்டைச் சேர்க்கவும்:

```json
"scripts": {
    "build": "waffle"
  }
```

அடுத்து, திட்டத்தின் மூல கோப்பகத்தில் Waffle உள்ளமைவு கோப்பை உருவாக்கவும் - `waffle.json` - பின்னர் அங்கு பின்வரும் உள்ளமைவை ஒட்டவும்:

```json
{
  "compilerType": "solcjs",
  "compilerVersion": "0.6.2",
  "sourceDirectory": "./src",
  "outputDirectory": "./build"
}
```

`yarn build`-ஐ இயக்கவும். இதன் விளைவாக, `build` கோப்பகம், தொகுக்கப்பட்ட EtherSplitter கான்ட்ராக்ட்டுடன் JSON வடிவத்தில் தோன்றும்.

## சோதனை அமைப்பு {#test-setup}

Waffle உடன் சோதிப்பதற்கு Chai மேட்சர்கள் மற்றும் Mocha-ஐப் பயன்படுத்த வேண்டும், எனவே நீங்கள் அவற்றை உங்கள் திட்டத்தில் [சேர்க்க](https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html#writing-tests) வேண்டும். உங்கள் package.json கோப்பைப் புதுப்பித்து, scripts பகுதியில் `test` உள்ளீட்டைச் சேர்க்கவும்:

```json
"scripts": {
    "build": "waffle",
    "test": "export NODE_ENV=test && mocha -r ts-node/register 'test/**/*.test.ts'"
  }
```

உங்கள் சோதனைகளை [இயக்க](https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html#running-tests) விரும்பினால், `yarn test`-ஐ இயக்கவும்.

## சோதனை {#testing}

இப்போது `test` கோப்பகத்தை உருவாக்கி, புதிய கோப்பான `test\EtherSplitter.test.ts`-ஐ உருவாக்கவும்.
கீழே உள்ள துணுக்கை நகலெடுத்து நமது சோதனை கோப்பில் ஒட்டவும்.

```ts
import { expect, use } from "chai"
import { Contract } from "ethers"
import { deployContract, MockProvider, solidity } from "ethereum-waffle"
import EtherSplitter from "../build/EtherSplitter.json"

use(solidity)

describe("Ether Splitter", () => {
  const [sender, receiver1, receiver2] = new MockProvider().getWallets()
  let splitter: Contract

  beforeEach(async () => {
    splitter = await deployContract(sender, EtherSplitter, [
      receiver1.address,
      receiver2.address,
    ])
  })

  // சோதனைகளை இங்கே சேர்க்கவும்
})
```

நாம் தொடங்குவதற்கு முன் சில வார்த்தைகள்.
`MockProvider` பிளாக்செயினின் ஒரு போலி பதிப்பை வழங்குகிறது. EtherSplitter கான்ட்ராக்ட்டைச் சோதிக்க நமக்கு உதவும் போலி பணப்பைகளையும் இது வழங்குகிறது. வழங்குநரில் `getWallets()` முறையை அழைப்பதன் மூலம் நாம் பத்து பணப்பைகள் வரை பெறலாம். எடுத்துக்காட்டில், நாம் மூன்று பணப்பைகளைப் பெறுகிறோம் - அனுப்புநருக்காக ஒன்றும், இரண்டு பெறுநர்களுக்காக இரண்டும்.

அடுத்து, 'splitter' என்ற ஒரு மாறியை நாம் அறிவிக்கிறோம் - இது நமது போலி EtherSplitter கான்ட்ராக்ட் ஆகும். ஒவ்வொரு தனி சோதனையின் இயக்கத்திற்கும் முன் இது `deployContract` முறையால் உருவாக்கப்படுகிறது. இந்த முறையானது, முதல் தருமதிப்பாக அனுப்பப்பட்ட பணப்பையிலிருந்து (நமது விஷயத்தில் அனுப்புநரின் பணப்பை) ஒரு கான்ட்ராக்ட்டின் வரிசைப்படுத்தலை உருவகப்படுத்துகிறது. இரண்டாவது தருமதிப்பு, சோதிக்கப்பட்ட கான்ட்ராக்ட்டின் ABI மற்றும் பைட்குறியீடு ஆகும் - `build` கோப்பகத்திலிருந்து தொகுக்கப்பட்ட EtherSplitter கான்ட்ராக்ட்டின் json கோப்பை நாம் அங்கு அனுப்புகிறோம். மூன்றாவது தருமதிப்பு கான்ட்ராக்ட்டின் கட்டமைப்பாளர் தருமதிப்புகளைக் கொண்ட ஒரு வரிசை ஆகும், நமது விஷயத்தில், அவை இரண்டு பெறுநர்களின் முகவரிகள் ஆகும்.

## இருப்பு மாற்றங்கள் {#changebalances}

முதலில், split முறை உண்மையில் பெறுநர்களின் பணப்பைகளின் இருப்புகளை மாற்றுகிறதா என்று சோதிப்போம். அனுப்புநரின் கணக்கிலிருந்து 50 wei-ஐப் பிரித்தால், இரண்டு பெறுநர்களின் இருப்புகளும் 25 wei அதிகரிக்கும் என்று நாம் எதிர்பார்ப்போம். நாம் Waffle-இன் `changeBalances` மேட்சரைப் பயன்படுத்துவோம்:

```ts
it("கணக்கு இருப்புகளை மாற்றுகிறது", async () => {
  await expect(() => splitter.split({ value: 50 })).to.changeBalances(
    [receiver1, receiver2],
    [25, 25]
  )
})
```

மேட்சரின் முதல் தருமதிப்பாக, பெறுநர்களின் பணப்பைகளின் ஒரு வரிசையையும், இரண்டாவதாக, தொடர்புடைய கணக்குகளில் எதிர்பார்க்கப்படும் அதிகரிப்புகளின் ஒரு வரிசையையும் அனுப்புகிறோம்.
ஒரு குறிப்பிட்ட பணப்பையின் இருப்பைச் சரிபார்க்க விரும்பினால், நாம் `changeBalance` மேட்சரையும் பயன்படுத்தலாம், கீழேயுள்ள எடுத்துக்காட்டில் உள்ளதைப் போல அதற்கு வரிசைகளை அனுப்பத் தேவையில்லை:

```ts
it("கணக்கு இருப்பை மாற்றுகிறது", async () => {
  await expect(() => splitter.split({ value: 50 })).to.changeBalance(
    receiver1,
    25
  )
})
```

`changeBalance` மற்றும் `changeBalances` ஆகிய இரண்டிலும், நாம் split செயல்பாட்டை ஒரு கால்பேக்காக அனுப்புகிறோம், ஏனெனில் மேட்சர் அழைப்பிற்கு முன்னும் பின்னும் இருப்புகளின் நிலையை அணுக வேண்டும் என்பதை கவனத்தில் கொள்ளவும்.

அடுத்து, ஒவ்வொரு wei பரிமாற்றத்திற்குப் பிறகும் Transfer நிகழ்வு வெளியிடப்பட்டதா என்று சோதிப்போம். நாம் Waffle-இலிருந்து மற்றொரு மேட்சரைப் பயன்படுத்துவோம்:

## வெளியீடு {#emit}

```ts
it("முதல் பெறுநருக்கான பரிமாற்றத்தில் நிகழ்வை வெளியிடுகிறது", async () => {
  await expect(splitter.split({ value: 50 }))
    .to.emit(splitter, "Transfer")
    .withArgs(sender.address, receiver1.address, 25)
})

it("இரண்டாவது பெறுநருக்கான பரிமாற்றத்தில் நிகழ்வை வெளியிடுகிறது", async () => {
  await expect(splitter.split({ value: 50 }))
    .to.emit(splitter, "Transfer")
    .withArgs(sender.address, receiver2.address, 25)
})
```

ஒரு முறையை அழைக்கும்போது ஒரு கான்ட்ராக்ட் ஒரு நிகழ்வை வெளியிட்டதா என்பதைச் சரிபார்க்க `emit` மேட்சர் நம்மை அனுமதிக்கிறது. `emit` மேட்சருக்கான தருமதிப்புகளாக, நிகழ்வை வெளியிடும் என்று நாம் கணிக்கும் போலி கான்ட்ராக்ட்டையும், அந்த நிகழ்வின் பெயரையும் வழங்குகிறோம். நமது விஷயத்தில், போலி கான்ட்ராக்ட் `splitter` மற்றும் நிகழ்வின் பெயர் - `Transfer` ஆகும். நிகழ்வு வெளியிடப்பட்ட தருமதிப்புகளின் சரியான மதிப்புகளையும் நம்மால் சரிபார்க்க முடியும் - நமது நிகழ்வு அறிவிப்பு எத்தனை தருமதிப்புகளை எதிர்பார்க்கிறதோ, அத்தனை தருமதிப்புகளை நாம் `withArgs` மேட்சருக்கு அனுப்புகிறோம். EtherSplitter கான்ட்ராக்ட்டைப் பொறுத்தவரை, நாம் அனுப்புநர் மற்றும் பெறுநரின் முகவரிகளை, பரிமாற்றம் செய்யப்பட்ட wei தொகையுடன் அனுப்புகிறோம்.

## ரத்து செய்யப்பட்டது {#revertedwith}

கடைசி எடுத்துக்காட்டாக, ஒற்றைப்படை wei எண்ணிக்கை இருக்கும் பட்சத்தில் பரிவர்த்தனை ரத்து செய்யப்பட்டதா என்று சரிபார்ப்போம். நாம் `revertedWith` மேட்சரைப் பயன்படுத்துவோம்:

```ts
it("wei தொகை ஒற்றைப்படையாக இருக்கும்போது ரத்துசெய்கிறது", async () => {
  await expect(splitter.split({ value: 51 })).to.be.revertedWith(
    "ஒற்றைப்படை wei தொகை அனுமதிக்கப்படவில்லை"
  )
})
```

இந்த சோதனை தேர்ச்சி பெற்றால், பரிவர்த்தனை உண்மையில் ரத்து செய்யப்பட்டது என்பதை நமக்கு உறுதியளிக்கும். இருப்பினும், `require` அறிக்கையில் நாம் அனுப்பிய செய்திக்கும் `revertedWith` இல் நாம் எதிர்பார்க்கும் செய்திக்கும் இடையே ஒரு சரியான பொருத்தம் இருக்க வேண்டும். நாம் EtherSplitter கான்ட்ராக்ட்டின் குறியீட்டிற்குத் திரும்பச் சென்றால், wei தொகைக்கான `require` அறிக்கையில், நாம் இந்தச் செய்தியை வழங்குகிறோம்: 'ஒற்றைப்படை wei தொகை அனுமதிக்கப்படவில்லை'. இது நமது சோதனையில் நாம் எதிர்பார்க்கும் செய்தியுடன் பொருந்துகிறது. அவை சமமாக இல்லையென்றால், சோதனை தோல்வியடையும்.

## வாழ்த்துக்கள்! {#congratulations}

Waffle உடன் ஸ்மார்ட் கான்ட்ராக்ட்களை சோதிப்பதை நோக்கி உங்கள் முதல் பெரிய படியை எடுத்து வைத்துள்ளீர்கள்!
