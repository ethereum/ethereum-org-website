---
title: "கால்டேட்டா தேர்வுமுறைக்கான குறுகிய ABIகள்"
description: "ஆப்டிமிஸ்டிக் ரோலப்களுக்காக ஸ்மார்ட் ஒப்பந்தங்களை மேம்படுத்துதல்"
author: Ori Pomerantz
lang: ta
tags: [ "2ம் அடுக்கு" ]
skill: intermediate
published: 2022-04-01
---

## அறிமுகம் {#introduction}

இந்தக் கட்டுரையில், [ஆப்டிமிஸ்டிக் ரோலப்கள்](/developers/docs/scaling/optimistic-rollups), அவற்றில் பரிவர்த்தனைகளின் செலவு மற்றும் எத்தேரியம் மெயின்நெட்டை விட மாறுபட்ட விஷயங்களுக்கு மேம்படுத்த அந்த மாறுபட்ட செலவுக் கட்டமைப்பு எவ்வாறு தேவைப்படுகிறது என்பதைப் பற்றி நீங்கள் அறிந்து கொள்கிறீர்கள்.
இந்த மேம்படுத்தலை எவ்வாறு செயல்படுத்துவது என்பதையும் நீங்கள் கற்றுக்கொள்கிறீர்கள்.

### முழு வெளிப்படுத்தல் {#full-disclosure}

நான் ஒரு முழு நேர [Optimism](https://www.optimism.io/) ஊழியர், எனவே இந்தக் கட்டுரையில் உள்ள எடுத்துக்காட்டுகள் Optimism-இல் இயங்கும்.
இருப்பினும், இங்கு விளக்கப்பட்டுள்ள நுட்பம் மற்ற ரோலப்களுக்கும் நன்றாக வேலை செய்ய வேண்டும்.

### சொற்களஞ்சியம் {#terminology}

ரோலப்களைப் பற்றி விவாதிக்கும்போது, 'அடுக்கு 1' (L1) என்ற சொல் மெயின்நெட், அதாவது உற்பத்தி எத்தேரியம் நெட்வொர்க்கிற்காகப் பயன்படுத்தப்படுகிறது.
'அடுக்கு 2' (L2) என்ற சொல், பாதுகாப்பிற்காக L1-ஐ நம்பியிருக்கும் ஆனால் அதன் பெரும்பாலான செயலாக்கங்களை ஆஃப்செயினில் செய்யும் ரோலப் அல்லது வேறு எந்த அமைப்புக்கும் பயன்படுத்தப்படுகிறது.

## L2 பரிவர்த்தனைகளின் செலவை நாம் மேலும் எவ்வாறு குறைக்க முடியும்? {#how-can-we-further-reduce-the-cost-of-L2-transactions}

[ஆப்டிமிஸ்டிக் ரோலப்கள்](/developers/docs/scaling/optimistic-rollups), ஒவ்வொரு வரலாற்று பரிவர்த்தனையின் பதிவையும் பாதுகாக்க வேண்டும். அப்போதுதான் எவரும் அவற்றைப் படித்து, தற்போதைய நிலை சரியானதா என்பதை சரிபார்க்க முடியும்.
எத்தேரியம் மெயின்நெட்டிற்குள் தரவை உள்ளிடுவதற்கான மலிவான வழி, அதை கால்டேட்டாவாக எழுதுவதாகும்.
இந்தத் தீர்வு [Optimism](https://help.optimism.io/hc/en-us/articles/4413163242779-What-is-a-rollup-) மற்றும் [Arbitrum](https://developer.offchainlabs.com/docs/rollup_basics#intro-to-rollups) இரண்டாலும் தேர்ந்தெடுக்கப்பட்டது.

### L2 பரிவர்த்தனைகளின் விலை {#cost-of-l2-transactions}

L2 பரிவர்த்தனைகளின் செலவு இரண்டு கூறுகளைக் கொண்டுள்ளது:

1. L2 செயலாக்கம், இது பொதுவாக மிகவும் மலிவானது
2. L1 சேமிப்பகம், இது மெயின்நெட் எரிவாயு செலவுகளுடன் பிணைக்கப்பட்டுள்ளது

நான் இதை எழுதும்போது, Optimism-இல் L2 எரிவாயுவின் விலை 0.001 [Gwei](/developers/docs/gas/#pre-london) ஆகும்.
மறுபுறம், L1 எரிவாயுவின் விலை தோராயமாக 40 gwei ஆகும்.
[தற்போதைய விலைகளை இங்கே பார்க்கலாம்](https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m).

ஒரு பைட் கால்டேட்டாவிற்கு 4 எரிவாயு (அது பூஜ்ஜியமாக இருந்தால்) அல்லது 16 எரிவாயு (அது வேறு ஏதேனும் மதிப்பாக இருந்தால்) செலவாகும்.
EVM-இல் மிகவும் விலையுயர்ந்த செயல்பாடுகளில் ஒன்று சேமிப்பகத்தில் எழுதுவதுதான்.
L2-இல் ஒரு 32-பைட் சொல்லை சேமிப்பகத்தில் எழுதுவதற்கான அதிகபட்ச செலவு 22100 எரிவாயு ஆகும். தற்போது, இது 22.1 gwei.
எனவே நாம் ஒரு பூஜ்ஜிய பைட் கால்டேட்டாவை சேமிக்க முடிந்தால், நாம் சுமார் 200 பைட்களை சேமிப்பகத்தில் எழுத முடியும், அப்போதும் நாம் லாபம் அடைவோம்.

### ABI {#the-abi}

பெரும்பாலான பரிவர்த்தனைகள் வெளிப்புற கணக்கிலிருந்து (externally-owned account) ஒரு ஒப்பந்தத்தை அணுகுகின்றன.
பெரும்பாலான ஒப்பந்தங்கள் சாலிடீட்டியில் எழுதப்பட்டுள்ளன, மேலும் அவற்றின் தரவுப் புலத்தை [பயன்பாட்டு பைனரி இடைமுகம் (ABI)](https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding) இன் படி விளக்குகின்றன.

இருப்பினும், ABI ஆனது L1-க்காக வடிவமைக்கப்பட்டது, அங்கு ஒரு பைட் கால்டேட்டாவின் விலை தோராயமாக நான்கு எண்கணித செயல்பாடுகளுக்கு சமம், ஆனால் L2-இல் ஒரு பைட் கால்டேட்டாவின் விலை ஆயிரம் எண்கணித செயல்பாடுகளை விட அதிகமாகும்.
கால்டேட்டா இதுபோன்று பிரிக்கப்பட்டுள்ளது:

| பிரிவு             | நீளம் | பைட்டுகள் | வீணான பைட்டுகள் | வீணான எரிவாயு | தேவையான பைட்டுகள் | தேவையான எரிவாயு |
| ------------------ | ----: | --------: | --------------: | ------------: | ----------------: | --------------: |
| செயல்பாட்டு தேர்வி |     4 |       0-3 |               3 |            48 |                 1 |              16 |
| பூஜ்ஜியங்கள்       |    12 |      4-15 |              12 |            48 |                 0 |               0 |
| இலக்கு முகவரி      |    20 |     16-35 |               0 |             0 |                20 |             320 |
| தொகை               |    32 |     36-67 |              17 |            64 |                15 |             240 |
| மொத்தம்            |    68 |           |                 |           160 |                   |             576 |

விளக்கம்:

- **செயல்பாட்டு தேர்வி**: ஒப்பந்தத்தில் 256 க்கும் குறைவான செயல்பாடுகள் உள்ளன, எனவே நாம் அவற்றை ஒரு ஒற்றை பைட் மூலம் வேறுபடுத்தலாம்.
  இந்த பைட்டுகள் பொதுவாக பூஜ்ஜியமற்றவை, எனவே [பதினாறு எரிவாயு செலவாகும்](https://eips.ethereum.org/EIPS/eip-2028).
- **பூஜ்ஜியங்கள்**: இந்த பைட்டுகள் எப்போதும் பூஜ்ஜியமாகவே இருக்கும், ஏனெனில் ஒரு இருபது-பைட் முகவரியை வைத்திருக்க முப்பத்திரண்டு-பைட் வார்த்தை தேவையில்லை.
  பூஜ்ஜியத்தைக் கொண்டிருக்கும் பைட்டுகளுக்கு நான்கு எரிவாயு செலவாகும் ([மஞ்சள் தாளைப் பார்க்கவும்](https://ethereum.github.io/yellowpaper/paper.pdf), பின் இணைப்பு G, ப. 27, `G`<sub>`txdatazero`</sub> க்கான மதிப்பு).
- **தொகை**: இந்த ஒப்பந்தத்தில் `decimals` என்பது பதினெட்டு (சாதாரண மதிப்பு) என்றும், நாம் மாற்றும் டோக்கன்களின் அதிகபட்ச அளவு 10<sup>18</sup> ஆக இருக்கும் என்றும் நாம் கருதினால், நாம் 10<sup>36</sup> என்ற அதிகபட்ச அளவைப் பெறுகிறோம்.
  256<sup>15</sup> &gt; 10<sup>36</sup>, எனவே பதினைந்து பைட்டுகள் போதுமானவை.

L1 இல் 160 எரிவாயு வீணாவது பொதுவாக புறக்கணிக்கத்தக்கது. ஒரு பரிவர்த்தனைக்கு குறைந்தது [21,000 எரிவாயு](https://yakkomajuri.medium.com/blockchain-definition-of-the-week-ethereum-gas-2f976af774ed) செலவாகும், எனவே கூடுதலாக 0.8% என்பது ஒரு பொருட்டல்ல.
இருப்பினும், L2-இல், விஷயங்கள் வேறுபட்டவை. பரிவர்த்தனையின் கிட்டத்தட்ட முழு செலவும் அதை L1 இல் எழுதுவதில்தான் உள்ளது.
பரிவர்த்தனை கால்டேட்டாவைத் தவிர, 109 பைட்டுகள் பரிவர்த்தனை தலைப்பு (இலக்கு முகவரி, கையொப்பம், முதலியன) உள்ளன.
எனவே மொத்த செலவு `109*16+576+160=2480` ஆகும், அதில் சுமார் 6.5%-ஐ நாம் வீணாக்குகிறோம்.

## நீங்கள் இலக்கைக் கட்டுப்படுத்தாதபோது செலவுகளைக் குறைத்தல் {#reducing-costs-when-you-dont-control-the-destination}

இலக்கு ஒப்பந்தத்தின் மீது உங்களுக்குக் கட்டுப்பாடு இல்லை என்று வைத்துக் கொண்டால், நீங்கள் இன்னும் [இதைப்](https://github.com/qbzzt/ethereum.org-20220330-shortABI) போன்ற ஒரு தீர்வைப் பயன்படுத்தலாம்.
தொடர்புடைய கோப்புகளைப் பார்ப்போம்.

### Token.sol {#token-sol}

[இது இலக்கு ஒப்பந்தம்](https://github.com/qbzzt/ethereum.org-20220330-shortABI/blob/master/contracts/Token.sol).
இது ஒரு நிலையான ERC-20 ஒப்பந்தமாகும், ஒரு கூடுதல் அம்சத்துடன்.
இந்த `faucet` செயல்பாடு எந்தவொரு பயனரையும் பயன்படுத்த சில டோக்கன்களைப் பெற அனுமதிக்கிறது.
இது ஒரு உற்பத்தி ERC-20 ஒப்பந்தத்தை பயனற்றதாக்கும், ஆனால் ஒரு ERC-20 சோதனையை எளிதாக்குவதற்காக மட்டுமே இருக்கும்போது இது வாழ்க்கையை எளிதாக்குகிறது.

```solidity
    /**
     * @dev அழைப்பாளருக்கு விளையாட 1000 டோக்கன்களை வழங்குகிறது
     */
    function faucet() external {
        _mint(msg.sender, 1000);
    }   // செயல்பாடு faucet
```

### CalldataInterpreter.sol {#calldatainterpreter-sol}

[பரிவர்த்தனைகள் குறுகிய கால்டேட்டாவுடன் அழைக்க வேண்டிய ஒப்பந்தம் இதுவாகும்](https://github.com/qbzzt/ethereum.org-20220330-shortABI/blob/master/contracts/CalldataInterpreter.sol).
அதை வரி வரியாகப் பார்ப்போம்.

```solidity
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;


import { OrisUselessToken } from "./Token.sol";
```

அதை எப்படி அழைப்பது என்பதை அறிய எங்களுக்கு டோக்கன் செயல்பாடு தேவை.

```solidity
contract CalldataInterpreter {

    OrisUselessToken public immutable token;
```

நாங்கள் ப்ராக்ஸியாக செயல்படும் டோக்கனின் முகவரி.

```solidity
    /**
     * @dev டோக்கன் முகவரியைக் குறிப்பிடவும்
     * @param tokenAddr_ ERC-20 ஒப்பந்த முகவரி
     */
    constructor(
        address tokenAddr_
    )  {
        token = OrisUselessToken(tokenAddr_);
    }   // constructor
```

டோக்கன் முகவரி மட்டுமே நாம் குறிப்பிட வேண்டிய அளவுருவாகும்.

```solidity
    function calldataVal(uint startByte, uint length)
        private pure returns (uint) {
```

கால்டேட்டாவிலிருந்து ஒரு மதிப்பைப் படிக்கவும்.

```solidity
        uint _retVal;

        require(length < 0x21,
            "calldataVal நீள வரம்பு 32 பைட்டுகள்");

        require(length + startByte <= msg.data.length,
            "calldataVal ஆனது calldatasize-ஐத் தாண்டிப் படிக்க முயற்சிக்கிறது");
```

நாம் ஒரு 32-பைட் (256-பிட்) வார்த்தையை நினைவகத்தில் ஏற்றி, நாம் விரும்பும் புலத்தின் பகுதியாக இல்லாத பைட்டுகளை அகற்றப் போகிறோம்.
இந்த நெறிமுறை 32 பைட்டுகளுக்கு மேல் உள்ள மதிப்புகளுக்கு வேலை செய்யாது, மேலும் நிச்சயமாக நாம் கால்டேட்டாவின் முடிவைத் தாண்டிப் படிக்க முடியாது.
L1-இல் எரிவாயுவைச் சேமிக்க இந்தச் சோதனைகளைத் தவிர்ப்பது அவசியமாக இருக்கலாம், ஆனால் L2-இல் எரிவாயு மிகவும் மலிவானது, இது நாம் சிந்திக்கக்கூடிய எந்தவொரு சரிபார்ப்புகளையும் செயல்படுத்துகிறது.

```solidity
        assembly {
            _retVal := calldataload(startByte)
        }
```

`fallback()` அழைப்பிலிருந்து (கீழே காண்க) தரவை நாம் நகலெடுத்திருக்கலாம், ஆனால் EVM இன் அசெம்பிளி மொழியான [Yul](https://docs.soliditylang.org/en/v0.8.12/yul.html) ஐப் பயன்படுத்துவது எளிதானது.

இங்கே நாம் [CALLDATALOAD opcode](https://www.evm.codes/#35) ஐப் பயன்படுத்தி `startByte` முதல் `startByte+31` வரையிலான பைட்டுகளை ஸ்டேக்கில் படிக்கிறோம்.
பொதுவாக, Yul இல் ஒரு ஆப்கோடின் தொடரியல் `<opcode name>(<first stack value, if any>,<second stack value, if any>...)` ஆகும்.

```solidity

        _retVal = _retVal >> (256-length*8);
```

மிகவும் குறிப்பிடத்தக்க `length` பைட்டுகள் மட்டுமே புலத்தின் பகுதியாகும், எனவே மற்ற மதிப்புகளை அகற்ற நாம் [வலது-நகர்த்தல்](https://en.wikipedia.org/wiki/Logical_shift) செய்கிறோம்.
இது மதிப்பை புலத்தின் வலதுபுறம் நகர்த்துவதன் கூடுதல் நன்மையைக் கொண்டுள்ளது, எனவே இது மதிப்பு பெருக்கல் 256<sup>ஏதோ ஒன்று</sup> என்பதை விட மதிப்பு தானே ஆகும்.

```solidity

        return _retVal;
    }


    fallback() external {
```

ஒரு சாலிடீட்டி ஒப்பந்தத்திற்கான அழைப்பு எந்தவொரு செயல்பாட்டு கையொப்பங்களுடனும் பொருந்தாதபோது, அது [`fallback()` செயல்பாட்டை](https://docs.soliditylang.org/en/v0.8.12/contracts.html#fallback-function) (ஒன்று இருப்பதாகக் கருதி) அழைக்கிறது.
`CalldataInterpreter` விஷயத்தில், வேறு எந்த `external` அல்லது `public` செயல்பாடுகளும் இல்லாததால், _எந்த_ அழைப்பும் இங்கே வந்து சேரும்.

```solidity
        uint _func;

        _func = calldataVal(0, 1);
```

கால்டேட்டாவின் முதல் பைட்டைப் படிக்கவும், இது நமக்கு செயல்பாட்டைச் சொல்கிறது.
ஒரு செயல்பாடு இங்கே கிடைக்காமல் இருப்பதற்கு இரண்டு காரணங்கள் உள்ளன:

1. `pure` அல்லது `view` ஆக இருக்கும் செயல்பாடுகள் நிலையை மாற்றுவதில்லை மற்றும் எரிவாயு செலவு இல்லை (ஆஃப்செயினில் அழைக்கப்படும் போது).
   அவற்றின் எரிவாயு செலவைக் குறைக்க முயற்சிப்பதில் அர்த்தமில்லை.
2. [`msg.sender`](https://docs.soliditylang.org/en/v0.8.12/units-and-global-variables.html#block-and-transaction-properties)-ஐ சார்ந்திருக்கும் செயல்பாடுகள்.
   `msg.sender` இன் மதிப்பு `CalldataInterpreter` இன் முகவரியாக இருக்கும், அழைப்பாளர் அல்ல.

துரதிர்ஷ்டவசமாக, [ERC-20 விவரக்குறிப்புகளைப் பார்க்கும்போது](https://eips.ethereum.org/EIPS/eip-20), இது `transfer` என்ற ஒரு செயல்பாட்டை மட்டுமே விட்டுச்செல்கிறது.
இது நமக்கு இரண்டு செயல்பாடுகளை மட்டுமே விட்டுச்செல்கிறது: `transfer` (ஏனெனில் நாம் `transferFrom` ஐ அழைக்கலாம்) மற்றும் `faucet` (ஏனெனில் நம்மை அழைத்தவருக்கே டோக்கன்களை திரும்ப மாற்றலாம்).

```solidity
        // கால்டேட்டாவிலிருந்து வரும் தகவலைப் பயன்படுத்தி டோக்கனின்
        // நிலையை மாற்றும் முறைகளை அழைக்கவும்

        // faucet
        if (_func == 1) {
```

`faucet()` க்கான அழைப்பு, இதில் அளவுருக்கள் இல்லை.

```solidity
            token.faucet();
            token.transfer(msg.sender,
                token.balanceOf(address(this)));
        }
```

நாம் `token.faucet()` ஐ அழைத்த பிறகு டோக்கன்களைப் பெறுகிறோம். இருப்பினும், ப்ராக்ஸி ஒப்பந்தமாக, எங்களுக்கு டோக்கன்கள் **தேவை இல்லை**.
நம்மை அழைத்த EOA (வெளிப்புறமாக சொந்தமான கணக்கு) அல்லது ஒப்பந்தத்திற்கு தேவை.
எனவே நம்மிடம் உள்ள அனைத்து டோக்கன்களையும் நம்மை அழைத்தவருக்கு மாற்றுகிறோம்.

```solidity
        // பரிமாற்றம் (அதற்கு எங்களிடம் அனுமதி உள்ளது என்று வைத்துக்கொள்வோம்)
        if (_func == 2) {
```

டோக்கன்களை மாற்றுவதற்கு இரண்டு அளவுருக்கள் தேவை: இலக்கு முகவரி மற்றும் தொகை.

```solidity
            token.transferFrom(
                msg.sender,
```

அழைப்பாளர்கள் தங்களுக்கு சொந்தமான டோக்கன்களை மாற்றுவதற்கு மட்டுமே நாங்கள் அனுமதிக்கிறோம்

```solidity
                address(uint160(calldataVal(1, 20))),
```

இலக்கு முகவரி பைட் #1 இல் தொடங்குகிறது (பைட் #0 செயல்பாடு ஆகும்).
ஒரு முகவரியாக, இது 20-பைட்டுகள் நீளமானது.

```solidity
                calldataVal(21, 2)
```

இந்த குறிப்பிட்ட ஒப்பந்தத்திற்கு, யாரேனும் மாற்ற விரும்பும் அதிகபட்ச டோக்கன்களின் எண்ணிக்கை இரண்டு பைட்டுகளுக்குள் (65536 க்கும் குறைவாக) பொருந்தும் என்று நாங்கள் கருதுகிறோம்.

```solidity
            );
        }
```

மொத்தத்தில், ஒரு இடமாற்றத்திற்கு 35 பைட்டுகள் கால்டேட்டா தேவைப்படுகிறது:

| பிரிவு             | நீளம் | பைட்டுகள் |
| ------------------ | ----: | --------: |
| செயல்பாட்டு தேர்வி |     1 |         0 |
| இலக்கு முகவரி      |    32 |      1-32 |
| தொகை               |     2 |     33-34 |

```solidity
    }   // fallback

}       // contract CalldataInterpreter
```

### test.js {#test-js}

[இந்த JavaScript யூனிட் சோதனை](https://github.com/qbzzt/ethereum.org-20220330-shortABI/blob/master/test/test.js) இந்த பொறிமுறையை எவ்வாறு பயன்படுத்துவது (மற்றும் அது சரியாக செயல்படுகிறதா என்பதை எவ்வாறு சரிபார்ப்பது) என்பதைக் காட்டுகிறது.
நீங்கள் [chai](https://www.chaijs.com/) மற்றும் [ethers](https://docs.ethers.io/v5/) ஐப் புரிந்துகொள்கிறீர்கள் என்று நான் கருதுகிறேன், மேலும் ஒப்பந்தத்திற்கு குறிப்பாகப் பொருந்தும் பகுதிகளை மட்டுமே விளக்குகிறேன்.

```js
const { expect } = require("chai");

describe("CalldataInterpreter", function () {
  it("டோக்கன்களைப் பயன்படுத்த எங்களை அனுமதிக்க வேண்டும்", async function () {
    const Token = await ethers.getContractFactory("OrisUselessToken")
    const token = await Token.deploy()
    await token.deployed()
    console.log("டோக்கன் முகவரி:", token.address)

    const Cdi = await ethers.getContractFactory("CalldataInterpreter")
    const cdi = await Cdi.deploy(token.address)
    await cdi.deployed()
    console.log("CalldataInterpreter முகவரி:", cdi.address)

    const signer = await ethers.getSigner()
```

இரண்டு ஒப்பந்தங்களையும் வரிசைப்படுத்துவதன் மூலம் தொடங்குகிறோம்.

```javascript
    // விளையாட டோக்கன்களைப் பெறுங்கள்
    const faucetTx = {
```

பரிவர்த்தனைகளை உருவாக்க நாம் வழக்கமாகப் பயன்படுத்தும் உயர்-நிலை செயல்பாடுகளை (`token.faucet()` போன்றவை) பயன்படுத்த முடியாது, ஏனெனில் நாங்கள் ABI-ஐப் பின்பற்றுவதில்லை.
அதற்கு பதிலாக, நாமே பரிவர்த்தனையை உருவாக்கி அதை அனுப்ப வேண்டும்.

```javascript
      to: cdi.address,
      data: "0x01"
```

பரிவர்த்தனைக்கு நாம் வழங்க வேண்டிய இரண்டு அளவுருக்கள் உள்ளன:

1. `to`, இலக்கு முகவரி.
   இது கால்டேட்டா மொழிபெயர்ப்பாளர் ஒப்பந்தம்.
2. `data`, அனுப்ப வேண்டிய கால்டேட்டா.
   ஒரு faucet அழைப்பின் விஷயத்தில், தரவு ஒரு ஒற்றை பைட், `0x01`.

```javascript
    }
    await (await signer.sendTransaction(faucetTx)).wait()
```

நாம் கையொப்பமிடுபவரின் `sendTransaction` முறையை அழைக்கிறோம், ஏனெனில் நாம் ஏற்கனவே இலக்கை (`faucetTx.to`) குறிப்பிட்டுள்ளோம், மேலும் பரிவர்த்தனை கையொப்பமிடப்பட வேண்டும்.

```javascript
// faucet டோக்கன்களை சரியாக வழங்குகிறதா என சரிபார்க்கவும்
expect(await token.balanceOf(signer.address)).to.equal(1000)
```

இங்கே நாம் இருப்பை சரிபார்க்கிறோம்.
`view` செயல்பாடுகளில் எரிவாயுவை சேமிக்க வேண்டிய அவசியமில்லை, எனவே அவற்றை சாதாரணமாக இயக்குகிறோம்.

```javascript
// CDI க்கு ஒரு அனுமதியை வழங்கவும் (ஒப்புதல்களை ப்ராக்ஸி செய்ய முடியாது)
const approveTX = await token.approve(cdi.address, 10000)
await approveTX.wait()
expect(await token.allowance(signer.address, cdi.address)).to.equal(10000)
```

இடமாற்றங்களைச் செய்ய கால்டேட்டா மொழிபெயர்ப்பாளருக்கு அனுமதி வழங்கவும்.

```javascript
// டோக்கன்களை மாற்றவும்
const destAddr = "0xf5a6ead936fb47f342bb63e676479bddf26ebe1d"
const transferTx = {
  to: cdi.address,
  data: "0x02" + destAddr.slice(2, 42) + "0100",
}
```

ஒரு இடமாற்ற பரிவர்த்தனையை உருவாக்கவும். முதல் பைட் "0x02" ஆகும், அதைத் தொடர்ந்து இலக்கு முகவரி, மற்றும் இறுதியாக தொகை (0x0100, இது தசமத்தில் 256).

```javascript
    await (await signer.sendTransaction(transferTx)).wait()

    // எங்களிடம் 256 டோக்கன்கள் குறைவாக உள்ளதா என சரிபார்க்கவும்
    expect (await token.balanceOf(signer.address)).to.equal(1000-256)

    // மற்றும் எங்கள் இலக்கு அவற்றை பெற்றதா என சரிபார்க்கவும்
    expect (await token.balanceOf(destAddr)).to.equal(256)
  })    // it
})      // describe
```

## நீங்கள் இலக்கு ஒப்பந்தத்தைக் கட்டுப்படுத்தும்போது செலவைக் குறைத்தல் {#reducing-the-cost-when-you-do-control-the-destination-contract}

நீங்கள் இலக்கு ஒப்பந்தத்தின் மீது கட்டுப்பாடு வைத்திருந்தால், நீங்கள் `msg.sender` சோதனைகளைத் தவிர்க்கும் செயல்பாடுகளை உருவாக்கலாம், ஏனெனில் அவை கால்டேட்டா மொழிபெயர்ப்பாளரை நம்புகின்றன.
[இது எவ்வாறு செயல்படுகிறது என்பதற்கான ஒரு எடுத்துக்காட்டை இங்கே `control-contract` கிளையில் நீங்கள் காணலாம்](https://github.com/qbzzt/ethereum.org-20220330-shortABI/tree/control-contract).

ஒப்பந்தம் வெளிப்புற பரிவர்த்தனைகளுக்கு மட்டுமே பதிலளித்தால், ஒரே ஒரு ஒப்பந்தம் வைத்திருப்பதன் மூலம் நாம் சமாளிக்கலாம்.
இருப்பினும், அது [இணைதிறனை](/developers/docs/smart-contracts/composability/) உடைத்துவிடும்.
சாதாரண ERC-20 அழைப்புகளுக்கு பதிலளிக்கும் ஒரு ஒப்பந்தம் மற்றும் குறுகிய அழைப்பு தரவு கொண்ட பரிவர்த்தனைகளுக்கு பதிலளிக்கும் மற்றொரு ஒப்பந்தம் இருப்பது மிகவும் நல்லது.

### Token.sol {#token-sol-2}

இந்த எடுத்துக்காட்டில் நாம் `Token.sol` ஐ மாற்றலாம்.
இது ப்ராக்ஸி மட்டுமே அழைக்கக்கூடிய பல செயல்பாடுகளைக் கொண்டிருக்க அனுமதிக்கிறது.
புதிய பகுதிகள் இதோ:

```solidity
    // CalldataInterpreter முகவரியைக் குறிப்பிட அனுமதிக்கப்பட்ட ஒரே முகவரி
    address owner;

    // CalldataInterpreter முகவரி
    address proxy = address(0);
```

ERC-20 ஒப்பந்தம் அங்கீகரிக்கப்பட்ட ப்ராக்ஸியின் அடையாளத்தை அறிந்து கொள்ள வேண்டும்.
இருப்பினும், நாம் இந்த மாறியை constructor-இல் அமைக்க முடியாது, ஏனெனில் நமக்கு இன்னும் மதிப்பு தெரியாது.
ப்ராக்ஸி அதன் constructor-இல் டோக்கனின் முகவரியை எதிர்பார்ப்பதால் இந்த ஒப்பந்தம் முதலில் செயல்படுத்தப்படுகிறது.

```solidity
    /**
     * @dev ERC20 constructor ஐ அழைக்கிறது.
     */
    constructor(
    ) ERC20("Oris useless token-2", "OUT-2") {
        owner = msg.sender;
    }
```

படைப்பாளரின் முகவரி ( `owner` என அழைக்கப்படுகிறது) இங்கே சேமிக்கப்படுகிறது, ஏனெனில் அந்த முகவரி மட்டுமே ப்ராக்ஸியை அமைக்க அனுமதிக்கப்படுகிறது.

```solidity
    /**
     * @dev ப்ராக்ஸிக்கான முகவரியை அமைக்கவும் (CalldataInterpreter).
     * உரிமையாளரால் ஒருமுறை மட்டுமே அழைக்க முடியும்
     */
    function setProxy(address _proxy) external {
        require(msg.sender == owner, "உரிமையாளரால் மட்டுமே அழைக்க முடியும்");
        require(proxy == address(0), "ப்ராக்ஸி ஏற்கனவே அமைக்கப்பட்டுள்ளது");

        proxy = _proxy;
    }    // செயல்பாடு setProxy
```

ப்ராக்ஸிக்கு சிறப்புரிமை அணுகல் உள்ளது, ஏனெனில் அது பாதுகாப்பு சோதனைகளைத் தவிர்க்க முடியும்.
ப்ராக்ஸியை நம்பலாம் என்பதை உறுதிசெய்ய, `owner` மட்டுமே இந்த செயல்பாட்டை அழைக்க அனுமதிக்கிறோம், அதுவும் ஒருமுறை மட்டுமே.
`proxy` க்கு ஒரு உண்மையான மதிப்பு (பூஜ்ஜியம் அல்ல) கிடைத்தவுடன், அந்த மதிப்பு மாறாது, எனவே உரிமையாளர் தீங்கிழைப்பவராக மாற முடிவு செய்தாலும், அல்லது அதற்கான நினைவூட்டல் வெளிப்படுத்தப்பட்டாலும், நாங்கள் இன்னும் பாதுகாப்பாக இருக்கிறோம்.

```solidity
    /**
     * @dev சில செயல்பாடுகளை ப்ராக்ஸி மட்டுமே அழைக்க முடியும்.
     */
    modifier onlyProxy {
```

இது ஒரு [`modifier` செயல்பாடு](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm), இது மற்ற செயல்பாடுகள் செயல்படும் முறையை மாற்றியமைக்கிறது.

```solidity
      require(msg.sender == proxy);
```

முதலில், ப்ராக்ஸியால் அழைக்கப்பட்டோமா என்பதை சரிபார்க்கவும், வேறு யாராலும் இல்லை.
இல்லையெனில், `revert` செய்யவும்.

```solidity
      _;
    }
```

அப்படியானால், நாம் மாற்றியமைக்கும் செயல்பாட்டை இயக்கவும்.

```solidity
   /* ப்ராக்ஸியை கணக்குகளுக்காக உண்மையில் ப்ராக்ஸி செய்ய அனுமதிக்கும் செயல்பாடுகள் */

    function transferProxy(address from, address to, uint256 amount)
        public virtual onlyProxy() returns (bool)
    {
        _transfer(from, to, amount);
        return true;
    }

    function approveProxy(address from, address spender, uint256 amount)
        public virtual onlyProxy() returns (bool)
    {
        _approve(from, spender, amount);
        return true;
    }

    function transferFromProxy(
        address spender,
        address from,
        address to,
        uint256 amount
    ) public virtual onlyProxy() returns (bool)
    {
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }
```

இவை மூன்று செயல்பாடுகள், பொதுவாக டோக்கன்களை மாற்றும் அல்லது அனுமதியை அங்கீகரிக்கும் நிறுவனத்திலிருந்து நேரடியாக செய்தி வர வேண்டும்.
இங்கே இந்த செயல்பாடுகளின் ஒரு ப்ராக்ஸி பதிப்பு உள்ளது:

1. `onlyProxy()` மூலம் மாற்றியமைக்கப்பட்டுள்ளது, எனவே வேறு யாரும் அவர்களைக் கட்டுப்படுத்த அனுமதிக்கப்படுவதில்லை.
2. சாதாரணமாக `msg.sender` ஆக இருக்கும் முகவரியை ஒரு கூடுதல் அளவுருவாகப் பெறுகிறது.

### CalldataInterpreter.sol {#calldatainterpreter-sol-2}

கால்டேட்டா மொழிபெயர்ப்பாளர் மேலே உள்ளதைப் போலவே உள்ளது, தவிர ப்ராக்ஸி செய்யப்பட்ட செயல்பாடுகள் ஒரு `msg.sender` அளவுருவைப் பெறுகின்றன, மேலும் `transfer` க்கான அனுமதி தேவையில்லை.

```solidity
        // பரிமாற்றம் (அனுமதி தேவையில்லை)
        if (_func == 2) {
            token.transferProxy(
                msg.sender,
                address(uint160(calldataVal(1, 20))),
                calldataVal(21, 2)
            );
        }

        // அங்கீகரிக்கவும்
        if (_func == 3) {
            token.approveProxy(
                msg.sender,
                address(uint160(calldataVal(1, 20))),
                calldataVal(21, 2)
            );
        }

        // transferFrom
        if (_func == 4) {
            token.transferFromProxy(
                msg.sender,
                address(uint160(calldataVal( 1, 20))),
                address(uint160(calldataVal(21, 20))),
                calldataVal(41, 2)
            );
        }
```

### Test.js {#test-js-2}

முந்தைய சோதனை குறியீட்டிற்கும் இதற்கும் இடையில் சில மாற்றங்கள் உள்ளன.

```js
const Cdi = await ethers.getContractFactory("CalldataInterpreter")
const cdi = await Cdi.deploy(token.address)
await cdi.deployed()
await token.setProxy(cdi.address)
```

எந்த ப்ராக்ஸியை நம்ப வேண்டும் என்பதை ERC-20 ஒப்பந்தத்திற்கு சொல்ல வேண்டும்.

```js
console.log("CalldataInterpreter முகவரி:", cdi.address)

// அனுமதிகளை சரிபார்க்க இரண்டு கையொப்பமிடுபவர்கள் தேவை
const signers = await ethers.getSigners()
const signer = signers[0]
const poorSigner = signers[1]
```

`approve()` மற்றும் `transferFrom()` ஐ சரிபார்க்க நமக்கு ஒரு இரண்டாவது கையொப்பமிடுபவர் தேவை.
அதை `poorSigner` என்று அழைக்கிறோம், ஏனெனில் அது எங்கள் டோக்கன்களில் எதையும் பெறாது (நிச்சயமாக அதற்கு ETH இருக்க வேண்டும்).

```js
// டோக்கன்களை மாற்றவும்
const destAddr = "0xf5a6ead936fb47f342bb63e676479bddf26ebe1d"
const transferTx = {
  to: cdi.address,
  data: "0x02" + destAddr.slice(2, 42) + "0100",
}
await (await signer.sendTransaction(transferTx)).wait()
```

ERC-20 ஒப்பந்தம் ப்ராக்ஸியை (`cdi`) நம்புவதால், இடமாற்றங்களை ரிலே செய்ய நமக்கு அனுமதி தேவையில்லை.

```js
// ஒப்புதல் மற்றும் transferFrom
const approveTx = {
  to: cdi.address,
  data: "0x03" + poorSigner.address.slice(2, 42) + "00FF",
}
await (await signer.sendTransaction(approveTx)).wait()

const destAddr2 = "0xE1165C689C3e9642cA7606F5287e708d846206"

const transferFromTx = {
  to: cdi.address,
  data: "0x04" + signer.address.slice(2, 42) + destAddr2.slice(2, 42) + "00FF",
}
await (await poorSigner.sendTransaction(transferFromTx)).wait()

// approve / transferFrom காம்போ சரியாக செய்யப்பட்டதா என சரிபார்க்கவும்
expect(await token.balanceOf(destAddr2)).to.equal(255)
```

இரண்டு புதிய செயல்பாடுகளை சோதிக்கவும்.
`transferFromTx` க்கு இரண்டு முகவரி அளவுருக்கள் தேவை என்பதை கவனத்தில் கொள்ளவும்: அனுமதியை வழங்குபவர் மற்றும் பெறுபவர்.

## முடிவுரை {#conclusion}

[Optimism](https://medium.com/ethereum-optimism/the-road-to-sub-dollar-transactions-part-2-compression-edition-6bb2890e3e92) மற்றும் [Arbitrum](https://developer.offchainlabs.com/docs/special_features) இரண்டும் L1 இல் எழுதப்பட்ட கால்டேட்டாவின் அளவைக் குறைப்பதற்கான வழிகளைத் தேடுகின்றன, இதனால் பரிவர்த்தனைகளின் செலவும் குறைகிறது.
இருப்பினும், பொதுவான தீர்வுகளைத் தேடும் உள்கட்டமைப்பு வழங்குநர்களாக, எங்கள் திறன்கள் குறைவாகவே உள்ளன.
dapp உருவாக்குநராக, உங்களிடம் பயன்பாடு சார்ந்த அறிவு உள்ளது, இது ஒரு பொதுவான தீர்வில் எங்களால் முடிந்ததை விட உங்கள் கால்டேட்டாவை மிகச் சிறப்பாக மேம்படுத்த உங்களை அனுமதிக்கிறது.
இந்த கட்டுரை உங்கள் தேவைகளுக்கான சிறந்த தீர்வைக் கண்டறிய உதவும் என்று நம்புகிறோம்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).

