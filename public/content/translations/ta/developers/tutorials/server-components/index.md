---
title: "web3 பயன்பாடுகளுக்கான சேவையகக் கூறுகள் மற்றும் முகவர்கள்"
description: "இந்த பயிற்சிவகுப்பை படித்து முடித்த பிறகு, பிளாக்செயினில் நடக்கும் நிகழ்வுகளைக் கேட்டு, அதற்கேற்ப தங்கள் சொந்த பரிவர்த்தனைகளுடன் பதிலளிக்கும் TypeScript சேவையகங்களை உங்களால் எழுத முடியும். மையப்படுத்தப்பட்ட பயன்பாடுகளை எழுத இது உங்களுக்கு உதவும் (ஏனென்றால் சேவையகம் தோல்வியின் ஒரு புள்ளியாகும்), ஆனால் web3 நிறுவனங்களுடன் தொடர்பு கொள்ள முடியும். மனித தலையீடு இல்லாமல் ஆன்செயின் நிகழ்வுகளுக்குப் பதிலளிக்கும் ஒரு ஏஜென்டை எழுத அதே நுட்பங்களையும் பயன்படுத்தலாம்."

author: Ori Pomerantz
lang: ta
tags: [ "ஏஜென்ட்", "சேவையகம்", "ஆஃப்செயின்" ]
skill: beginner
published: 2024-07-15
---

## அறிமுகம் {#introduction}

பெரும்பாலான சந்தர்ப்பங்களில், ஒரு பரவலாக்கப்பட்ட செயலி மென்பொருளை விநியோகிக்க ஒரு சேவையகத்தைப் பயன்படுத்துகிறது, ஆனால் அனைத்து உண்மையான தொடர்புகளும் கிளையண்டிற்கும் (வழக்கமாக, வலை உலாவி) மற்றும் பிளாக்செயினுக்கும் இடையில் நடைபெறுகின்றன.

![இணைய சேவையகம், கிளையன்ட் மற்றும் பிளாக்செயின் இடையேயான இயல்பான தொடர்பு](./fig-1.svg)

இருப்பினும், தன்னிச்சையாக இயங்கும் ஒரு சேவையகக் கூறைக் கொண்டிருப்பதன் மூலம் ஒரு பயன்பாடு பயனடையக்கூடிய சில சந்தர்ப்பங்கள் உள்ளன. அத்தகைய ஒரு சேவையகமானது பரிவர்த்தனைகளை வெளியிடுவதன் மூலம், நிகழ்வுகளுக்கும், ஒரு API போன்ற பிற மூலங்களிலிருந்து வரும் கோரிக்கைகளுக்கும் பதிலளிக்க முடியும்.

![ஒரு சேவையகத்தை சேர்த்த பிறகு நடக்கும் தொடர்பு](./fig-2.svg)

அத்தகைய சேவையகம் நிறைவேற்றக்கூடிய பல சாத்தியமான பணிகள் உள்ளன.

- இரகசிய நிலையை வைத்திருப்பவர். கேமிங்கில், கேம் அறிந்திருக்கும் அனைத்து தகவல்களும் பிளேயர்களுக்குக் கிடைக்காமல் இருப்பது பெரும்பாலும் பயனுள்ளதாக இருக்கும். இருப்பினும், _பிளாக்செயினில் எந்த ரகசியங்களும் இல்லை_, பிளாக்செயினில் உள்ள எந்த தகவலையும் யார் வேண்டுமானாலும் எளிதாகக் கண்டுபிடிக்கலாம். எனவே, கேம் நிலையின் ஒரு பகுதியை ரகசியமாக வைத்திருக்க வேண்டுமானால், அது வேறு இடத்தில் சேமிக்கப்பட வேண்டும் (மேலும் அந்த நிலையின் விளைவுகள் [பூஜ்ஜிய-அறிவு ஆதாரங்கள்](/zero-knowledge-proofs) மூலம் சரிபார்க்கப்படலாம்).

- மையப்படுத்தப்பட்ட ஆரக்கிள். பங்குகள் போதுமான அளவு குறைவாக இருந்தால், ஆன்லைனில் சில தகவல்களைப் படித்து, பின்னர் அதை செயினில் இடுகையிடும் ஒரு வெளிப்புற சேவையகம் [ஆரக்கிள்](/developers/docs/oracles/) ஆகப் பயன்படுத்த போதுமானதாக இருக்கலாம்.

- ஏஜென்ட். அதைச் செயல்படுத்த பரிவர்த்தனை இல்லாமல் பிளாக்செயினில் எதுவும் நடக்காது. வாய்ப்பு கிடைக்கும்போது [ஆர்பிட்ரேஜ்](/developers/docs/mev/#mev-examples-dex-arbitrage) போன்ற செயல்களைச் செய்ய ஒரு பயனரின் சார்பாக ஒரு சேவையகம் செயல்படலாம்.

## மாதிரி நிரல் {#sample-program}

நீங்கள் ஒரு மாதிரி சேவையகத்தை [கிட்ஹப்பில்](https://github.com/qbzzt/20240715-server-component) பார்க்கலாம். இந்த சேவையகம் [இந்த ஒப்பந்தத்திலிருந்து](https://eth-holesky.blockscout.com/address/0xB8f6460Dc30c44401Be26B0d6eD250873d8a50A6?tab=contract_code), Hardhat இன் Greeter இன் மாற்றியமைக்கப்பட்ட பதிப்பிலிருந்து வரும் நிகழ்வுகளைக் கேட்கிறது. வாழ்த்து மாற்றப்படும்போது, அது அதை மீண்டும் மாற்றுகிறது.

அதை இயக்க:

1. களஞ்சியத்தை குளோன் செய்யவும்.

   ```sh copy
   git clone https://github.com/qbzzt/20240715-server-component.git
   cd 20240715-server-component
   ```

2. தேவையான தொகுப்புகளை நிறுவவும். உங்களிடம் ஏற்கனவே இல்லையென்றால், [முதலில் Node-ஐ நிறுவவும்](https://nodejs.org/en/download/package-manager).

   ```sh copy
   npm install
   ```

3. Holesky டெஸ்ட்நெட்டில் ETH உள்ள ஒரு கணக்கின் தனிப்பட்ட திறவுக்கோலைக் குறிப்பிட `.env` ஐத் திருத்தவும். உங்களிடம் Holesky இல் ETH இல்லையென்றால், நீங்கள் [இந்த faucet ஐப் பயன்படுத்தலாம்](https://holesky-faucet.pk910.de/).

   ```sh filename=".env" copy
   PRIVATE_KEY=0x <private key goes here>
   ```

4. சேவையகத்தைத் தொடங்கவும்.

   ```sh copy
   npm start
   ```

5. [ஒரு பிளாக் எக்ஸ்புளோரருக்குச்](https://eth-holesky.blockscout.com/address/0xB8f6460Dc30c44401Be26B0d6eD250873d8a50A6?tab=write_contract) சென்று, தனிப்பட்ட திறவுக்கோல் உள்ள முகவரியைத் தவிர வேறு முகவரியைப் பயன்படுத்தி வாழ்த்தை மாற்றியமைக்கவும். வாழ்த்து தானாகவே மீண்டும் மாற்றியமைக்கப்படுவதைக் காணவும்.

### இது எவ்வாறு வேலை செய்கிறது? {#how-it-works}

ஒரு சேவையகக் கூறுகளை எப்படி எழுதுவது என்பதைப் புரிந்துகொள்வதற்கான எளிதான வழி, மாதிரியை வரி வரியாகப் பார்ப்பதுதான்.

#### `src/app.ts` {#src-app-ts}

நிரலின் பெரும்பகுதி [`src/app.ts`](https://github.com/qbzzt/20240715-server-component/blob/main/src/app.ts) இல் உள்ளது.

##### முன்தேவையான பொருட்களை உருவாக்குதல்

```typescript
import {
  createPublicClient,
  createWalletClient,
  getContract,
  http,
  Address,
} from "viem"
```

இவை நமக்குத் தேவையான [Viem](https://viem.sh/) நிறுவனங்கள், செயல்பாடுகள் மற்றும் [`முகவரி` வகை](https://viem.sh/docs/glossary/types#address). இந்த சேவையகம் [TypeScript](https://www.typescriptlang.org/) இல் எழுதப்பட்டுள்ளது, இது ஜாவாஸ்கிரிப்டின் ஒரு நீட்டிப்பாகும், இது அதை [வலுவாக தட்டச்சு](https://en.wikipedia.org/wiki/Strong_and_weak_typing) செய்கிறது.

```typescript
import { privateKeyToAccount } from "viem/accounts"
```

[இந்த செயல்பாடு](https://viem.sh/docs/accounts/privateKey) ஒரு தனிப்பட்ட திறவுகோலுக்குரிய வாலட் தகவல், முகவரி உட்பட, உருவாக்க அனுமதிக்கிறது.

```typescript
import { holesky } from "viem/chains"
```

Viem இல் ஒரு பிளாக்செயினைப் பயன்படுத்த, அதன் வரையறையை நீங்கள் இறக்குமதி செய்ய வேண்டும். இந்த விஷயத்தில், நாங்கள் [Holesky](https://github.com/eth-clients/holesky) டெஸ்ட் பிளாக்செயினுடன் இணைய விரும்புகிறோம்.

```typescript
// .env இல் உள்ள வரையறைகளை process.env இல் சேர்ப்பது இப்படித்தான்.
import * as dotenv from "dotenv"
dotenv.config()
```

`.env` ஐ சூழலில் படிப்பது இப்படித்தான். தனிப்பட்ட திறவுக்கோலுக்கு இது நமக்குத் தேவை (பின்னர் பார்க்கவும்).

```typescript
const greeterAddress : Address = "0xB8f6460Dc30c44401Be26B0d6eD250873d8a50A6"
const greeterABI = [
    {
        "inputs": [
            {
                "internalType": "string",
                "name": "_greeting",
                "type": "string"
            }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
         .
         .
         .
    {
        "inputs": [
            {
                "internalType": "string",
                "name": "_greeting",
                "type": "string"
            }
        ],
        "name": "setGreeting",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
] as const
```

ஒரு ஒப்பந்தத்தைப் பயன்படுத்த, அதன் முகவரி மற்றும் அதற்கான [ABI](/glossary/#abi) நமக்குத் தேவை. நாங்கள் இரண்டையும் இங்கே வழங்குகிறோம்.

ஜாவாஸ்கிரிப்டில் (எனவே டைப்ஸ்கிரிப்ட்டில்) நீங்கள் ஒரு மாறிலிக்கு ஒரு புதிய மதிப்பை ஒதுக்க முடியாது, ஆனால் அதில் சேமிக்கப்பட்ட பொருளை நீங்கள் மாற்றலாம். `as const` என்ற பின்னொட்டைப் பயன்படுத்துவதன் மூலம், பட்டியல் நிலையானது மற்றும் மாற்றப்படக்கூடாது என்று டைப்ஸ்கிரிப்ட்டிடம் கூறுகிறோம்.

```typescript
const publicClient = createPublicClient({
  chain: holesky,
  transport: http(),
})
```

ஒரு Viem [பொது கிளையன்ட்](https://viem.sh/docs/clients/public.html) ஐ உருவாக்கவும். பொது கிளையண்டுகளுக்கு இணைக்கப்பட்ட தனிப்பட்ட திறவுக்கோல் இல்லை, எனவே பரிவர்த்தனைகளை அனுப்ப முடியாது. அவர்கள் [`view` செயல்பாடுகளை](https://www.tutorialspoint.com/solidity/solidity_view_functions.htm) அழைக்கலாம், கணக்கு நிலுவைகளைப் படிக்கலாம், முதலியன.

```typescript
const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`)
```

சூழல் மாறிகள் [`process.env`](https://www.totaltypescript.com/how-to-strongly-type-process-env) இல் கிடைக்கின்றன. இருப்பினும், டைப்ஸ்கிரிப்ட் வலுவாக தட்டச்சு செய்யப்பட்டுள்ளது. ஒரு சூழல் மாறி எந்த சரமாகவும் அல்லது காலியாகவும் இருக்கலாம், எனவே ஒரு சூழல் மாறியின் வகை `string | undefined` ஆகும். இருப்பினும், Viem இல் ஒரு திறவுக்கோல் `0x${string}` (`0x` ஐத் தொடர்ந்து ஒரு சரம்) என வரையறுக்கப்படுகிறது. இங்கே `PRIVATE_KEY` சூழல் மாறி அந்த வகையாக இருக்கும் என்று டைப்ஸ்கிரிப்ட்டிடம் கூறுகிறோம். இல்லையெனில், எங்களுக்கு ஒரு இயக்கநேரப் பிழை ஏற்படும்.

[`privateKeyToAccount`](https://viem.sh/docs/accounts/privateKey) செயல்பாடு இந்த தனிப்பட்ட திறவுக்கோலைப் பயன்படுத்தி ஒரு முழு கணக்கு பொருளை உருவாக்குகிறது.

```typescript
const walletClient = createWalletClient({
  account,
  chain: holesky,
  transport: http(),
})
```

அடுத்து, [வாலட் கிளையன்டை](https://viem.sh/docs/clients/wallet) உருவாக்க கணக்கு பொருளைப் பயன்படுத்துகிறோம். இந்த கிளையண்டிற்கு ஒரு தனிப்பட்ட திறவுக்கோல் மற்றும் ஒரு முகவரி உள்ளது, எனவே பரிவர்த்தனைகளை அனுப்ப இதைப் பயன்படுத்தலாம்.

```typescript
const greeter = getContract({
  address: greeterAddress,
  abi: greeterABI,
  client: { public: publicClient, wallet: walletClient },
})
```

இப்போது நம்மிடம் அனைத்து முன்நிபந்தனைகளும் இருப்பதால், இறுதியாக ஒரு [ஒப்பந்த நிகழ்வை](https://viem.sh/docs/contract/getContract) உருவாக்கலாம். ஆன்செயின் ஒப்பந்தத்துடன் தொடர்பு கொள்ள இந்த ஒப்பந்த நிகழ்வைப் பயன்படுத்துவோம்.

##### பிளாக்செயினில் இருந்து படித்தல்

```typescript
console.log(`Current greeting:`, await greeter.read.greet())
```

படிக்க மட்டுமேயான ஒப்பந்த செயல்பாடுகள் ([`view`](https://www.tutorialspoint.com/solidity/solidity_view_functions.htm) மற்றும் [`pure`](https://www.tutorialspoint.com/solidity/solidity_pure_functions.htm)) `read` இன் கீழ் கிடைக்கின்றன. இந்த விஷயத்தில், வாழ்த்தைத் தரும் [`greet`](https://eth-holesky.blockscout.com/address/0xB8f6460Dc30c44401Be26B0d6eD250873d8a50A6?tab=read_contract#cfae3217) செயல்பாட்டை அணுக இதைப் பயன்படுத்துகிறோம்.

ஜாவாஸ்கிரிப்ட் ஒரு ஒற்றை-திரி கொண்டது, எனவே ஒரு நீண்ட கால செயல்முறையை நாம் துவக்கும்போது, அதை [ஒத்திசைவற்ற முறையில் செய்கிறோம் என்பதைக் குறிப்பிட வேண்டும்](https://eloquentjavascript.net/11_async.html#h-XvLsfAhtsE). பிளாக்செயினை அழைப்பது, படிக்க மட்டுமேயான செயல்பாட்டிற்கு கூட, கணினிக்கும் பிளாக்செயின் முனையத்திற்கும் இடையில் ஒரு சுற்று பயணம் தேவை. குறியீடு முடிவுக்காக `await` செய்ய வேண்டும் என்று இங்கே குறிப்பிடுவதற்கு இதுவே காரணம்.

இது எப்படி வேலை செய்கிறது என்பதில் உங்களுக்கு ஆர்வமிருந்தால், நீங்கள் [இங்கே அதைப் பற்றி படிக்கலாம்](https://www.w3schools.com/js/js_promise.asp), ஆனால் நடைமுறையில் நீங்கள் தெரிந்து கொள்ள வேண்டியது எல்லாம், நீண்ட நேரம் எடுக்கும் ஒரு செயல்பாட்டை நீங்கள் தொடங்கினால், முடிவுகளுக்காக `await` செய்ய வேண்டும், மேலும் இதைச் செய்யும் எந்தவொரு செயல்பாடும் `async` என அறிவிக்கப்பட வேண்டும்.

##### பரிவர்த்தனைகளை வெளியிடுதல்

```typescript
const setGreeting = async (greeting: string): Promise<any> => {
```

வாழ்த்தை மாற்றும் ஒரு பரிவர்த்தனையை வெளியிட நீங்கள் அழைக்கும் செயல்பாடு இது. இது ஒரு நீண்ட செயல்பாடு என்பதால், செயல்பாடு `async` என அறிவிக்கப்படுகிறது. உள் செயலாக்கம் காரணமாக, எந்த `async` செயல்பாடும் ஒரு `Promise` பொருளைத் திருப்பித் தர வேண்டும். இந்த விஷயத்தில், `Promise<any>` என்பது `Promise` இல் சரியாக என்ன திரும்பப் பெறப்படும் என்பதைக் குறிப்பிடவில்லை என்பதாகும்.

```typescript
const txHash = await greeter.write.setGreeting([greeting])
```

ஒப்பந்த நிகழ்வின் `write` புலம், பிளாக்செயின் நிலைக்கு எழுதும் அனைத்து செயல்பாடுகளையும் கொண்டுள்ளது (பரிவர்த்தனை அனுப்பத் தேவையானது), அதாவது [`setGreeting`](https://eth-holesky.blockscout.com/address/0xB8f6460Dc30c44401Be26B0d6eD250873d8a50A6?tab=write_contract#a4136862). அளவுருக்கள் ஏதேனும் இருந்தால், அவை ஒரு பட்டியலாக வழங்கப்படுகின்றன, மேலும் செயல்பாடு பரிவர்த்தனையின் ஹாஷைத் திருப்பித் தருகிறது.

```typescript
    console.log(`Working on a fix, see https://eth-holesky.blockscout.com/tx/${txHash}`)

    return txHash
}
```

பரிவர்த்தனையின் ஹாஷை (அதைப் பார்க்க பிளாக் எக்ஸ்புளோரருக்கான URL இன் ஒரு பகுதியாக) புகாரளித்து அதைத் திருப்பித் தரவும்.

##### நிகழ்வுகளுக்கு பதிலளித்தல்

```typescript
greeter.watchEvent.SetGreeting({
```

[`watchEvent` செயல்பாடு](https://viem.sh/docs/actions/public/watchEvent) ஒரு நிகழ்வு வெளியிடப்படும்போது ஒரு செயல்பாடு இயங்க வேண்டும் என்பதைக் குறிப்பிட உங்களை அனுமதிக்கிறது. நீங்கள் ஒரு வகை நிகழ்வைப் பற்றி மட்டுமே கவலைப்படுகிறீர்கள் என்றால் (இந்த விஷயத்தில், `SetGreeting`), அந்த நிகழ்வு வகைக்கு உங்களை மட்டுப்படுத்த இந்த தொடரியலைப் பயன்படுத்தலாம்.

```typescript
    onLogs: logs => {
```

`onLogs` செயல்பாடு பதிவு உள்ளீடுகள் இருக்கும்போது அழைக்கப்படுகிறது. எத்தேரியமில் "log" மற்றும் "event" பொதுவாக ஒன்றுக்கொன்று மாற்றாகப் பயன்படுத்தப்படுகின்றன.

```typescript
console.log(
  `Address ${logs[0].args.sender} changed the greeting to ${logs[0].args.greeting}`
)
```

பல நிகழ்வுகள் இருக்கலாம், ஆனால் எளிமைக்காக முதல் நிகழ்வைப் பற்றி மட்டுமே நாங்கள் கவலைப்படுகிறோம். `logs[0].args` என்பது நிகழ்வின் வாதங்கள், இந்த வழக்கில் `sender` மற்றும் `greeting`.

```typescript
        if (logs[0].args.sender != account.address)
            setGreeting(`${account.address} insists on it being Hello!`)
    }
})
```

அனுப்புநர் இந்த சேவையகம் _இல்லை_ என்றால், வாழ்த்தை மாற்ற `setGreeting` ஐப் பயன்படுத்தவும்.

#### `package.json` {#package-json}

[இந்த கோப்பு](https://github.com/qbzzt/20240715-server-component/blob/main/package.json) [Node.js](https://nodejs.org/en) உள்ளமைவைக் கட்டுப்படுத்துகிறது. இந்தக் கட்டுரை முக்கியமான வரையறைகளை மட்டுமே விளக்குகிறது.

```json
{
  "main": "dist/index.js",
```

இந்த வரையறை எந்த ஜாவாஸ்கிரிப்ட் கோப்பை இயக்க வேண்டும் என்பதைக் குறிப்பிடுகிறது.

```json
  "scripts": {
    "start": "tsc && node dist/app.js",
  },
```

ஸ்கிரிப்டுகள் பல்வேறு பயன்பாட்டுச் செயல்கள். இந்த வழக்கில், எங்களிடம் இருப்பது `start` மட்டுமே, இது சேவையகத்தை தொகுத்து பின்னர் இயக்குகிறது. `tsc` கட்டளை `typescript` தொகுப்பின் ஒரு பகுதியாகும் மற்றும் TypeScript ஐ ஜாவாஸ்கிரிப்டாக தொகுக்கிறது. நீங்கள் அதை கைமுறையாக இயக்க விரும்பினால், அது `node_modules/.bin` இல் அமைந்துள்ளது. இரண்டாவது கட்டளை சேவையகத்தை இயக்குகிறது.

```json
  "type": "module",
```

பல வகையான ஜாவாஸ்கிரிப்ட் முனை பயன்பாடுகள் உள்ளன. `module` வகை உயர் மட்டக் குறியீட்டில் `await` ஐ வைத்திருக்க அனுமதிக்கிறது, இது நீங்கள் மெதுவாக (மற்றும் அங்கு ஒத்திசைவற்ற) செயல்பாடுகளைச் செய்யும்போது முக்கியமானது.

```json
  "devDependencies": {
    "@types/node": "^20.14.2",
    "typescript": "^5.4.5"
  },
```

இவை வளர்ச்சிக்கு மட்டுமே தேவைப்படும் தொகுப்புகள். இங்கே நமக்கு `typescript` தேவை, மேலும் நாங்கள் அதை Node.js உடன் பயன்படுத்துவதால், முனை மாறிகள் மற்றும் `process` போன்ற பொருட்களுக்கான வகைகளையும் நாங்கள் பெறுகிறோம். [`^<version>` குறியீடு](https://github.com/npm/node-semver?tab=readme-ov-file#caret-ranges-123-025-004) என்பது அந்த பதிப்பு அல்லது உடைக்கும் மாற்றங்கள் இல்லாத உயர் பதிப்பு என்று பொருள். பதிப்பு எண்களின் பொருள் பற்றிய கூடுதல் தகவலுக்கு [இங்கே](https://semver.org) பார்க்கவும்.

```json
  "dependencies": {
    "dotenv": "^16.4.5",
    "viem": "2.14.1"
  }
}
```

`dist/app.js` இயக்கும்போது, இயக்க நேரத்தில் தேவைப்படும் தொகுப்புகள் இவை.

## முடிவுரை {#conclusion}

நாங்கள் இங்கு உருவாக்கிய மையப்படுத்தப்பட்ட சேவையகம் அதன் வேலையைச் செய்கிறது, அதாவது ஒரு பயனருக்கான முகவராக செயல்படுவது. டாப் தொடர்ந்து செயல்பட வேண்டும் மற்றும் கேஸை செலவழிக்கத் தயாராக இருக்கும் வேறு எவரும் தங்கள் சொந்த முகவரியுடன் சேவையகத்தின் புதிய நிகழ்வை இயக்கலாம்.

இருப்பினும், மையப்படுத்தப்பட்ட சேவையகத்தின் செயல்களை எளிதில் சரிபார்க்க முடிந்தால் மட்டுமே இது செயல்படும். மையப்படுத்தப்பட்ட சேவையகத்தில் ஏதேனும் இரகசிய நிலைத் தகவல் இருந்தால், அல்லது கடினமான கணக்கீடுகளைச் செய்தால், அது ஒரு மையப்படுத்தப்பட்ட நிறுவனம், பயன்பாட்டைப் பயன்படுத்த உங்களுக்கு நம்பிக்கை தேவை, இதுதான் பிளாக்செயின்கள் தவிர்க்க முயற்சிப்பது. எதிர்கால கட்டுரையில், இந்தச் சிக்கலைச் சமாளிக்க [பூஜ்ஜிய-அறிவு ஆதாரங்களை](/zero-knowledge-proofs) எவ்வாறு பயன்படுத்துவது என்பதைக் காட்ட திட்டமிட்டுள்ளேன்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).
