---
title: "ERC-20 ஒப்பந்த வழிகாட்டி"
description: "OpenZeppelin ERC-20 ஒப்பந்தத்தில் என்ன இருக்கிறது, அது ஏன் அங்கே இருக்கிறது?"
author: Ori Pomerantz
lang: ta
tags: [ "திட்பம்", "erc-20" ]
skill: beginner
published: 2021-03-09
---

## அறிமுகம் {#introduction}

எதீரியத்தைப் பயன்படுத்துவதற்கான பொதுவான பயன்பாடுகளில் ஒன்றாக, ஒரு குழு தங்கள் சொந்த நாணயமாக ஒரு பரிமாற்றக்கூடிய டோக்கனை உருவாக்குவது உள்ளது. இந்த டோக்கன்கள் பொதுவாக ஒரு தரநிலையைப் பின்பற்றுகின்றன,
[ERC-20](/developers/docs/standards/tokens/erc-20/). இந்த தரநிலை, பணப்புழக்கக் குளங்கள் மற்றும் பணப்பைகள் போன்ற கருவிகளை எழுதுவதை சாத்தியமாக்குகிறது, அவை அனைத்து ERC-20 டோக்கன்களுடன் செயல்படுகின்றன. இந்தக் கட்டுரையில், [OpenZeppelin Solidity ERC20 செயலாக்கத்தையும்](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol) மற்றும் [இடைமுக வரையறையையும்](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) நாங்கள் பகுப்பாய்வு செய்வோம்.

இது குறிப்புரையிடப்பட்ட மூலக் குறியீடு. நீங்கள் ERC-20-ஐ செயல்படுத்த விரும்பினால், [இந்த வழிகாட்டியைப் படிக்கவும்](https://docs.openzeppelin.com/contracts/2.x/erc20-supply).

## இடைமுகம் {#the-interface}

ERC-20 போன்ற ஒரு தரநிலையின் நோக்கம், பணப்பைகள் மற்றும் பரவலாக்கப்பட்ட பரிமாற்றங்கள் போன்ற பயன்பாடுகளில் ஒன்றுக்கொன்று இயங்கக்கூடிய பல டோக்கன் செயலாக்கங்களை அனுமதிப்பதாகும். அதை அடைய, நாங்கள் ஒரு [இடைமுகத்தை](https://www.geeksforgeeks.org/solidity/solidity-basics-of-interface/) உருவாக்குகிறோம். டோக்கன் ஒப்பந்தத்தைப் பயன்படுத்த வேண்டிய எந்தவொரு குறியீடும் இடைமுகத்தில் உள்ள அதே வரையறைகளைப் பயன்படுத்தலாம் மற்றும் அதைப் பயன்படுத்தும் அனைத்து டோக்கன் ஒப்பந்தங்களுடனும் இணக்கமாக இருக்கலாம், அது MetaMask போன்ற பணப்பையாக இருந்தாலும், etherscan.io போன்ற ஒரு dapp-ஆக இருந்தாலும், அல்லது பணப்புழக்கக் குளம் போன்ற வேறுபட்ட ஒப்பந்தமாக இருந்தாலும் சரி.

![ERC-20 இடைமுகத்தின் விளக்கம்](erc20_interface.png)

நீங்கள் ஒரு அனுபவமிக்க புரோகிராமராக இருந்தால், [ஜாவா](https://www.w3schools.com/java/java_interface.asp) அல்லது [சி தலைப்புக் கோப்புகளில்](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html) கூட இதே போன்ற கட்டமைப்புகளைப் பார்த்தது உங்களுக்கு நினைவிருக்கலாம்.

இது OpenZeppelin-இலிருந்து [ERC-20 இடைமுகத்தின்](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) ஒரு வரையறை. இது [மனிதனால் படிக்கக்கூடிய தரநிலையின்](https://eips.ethereum.org/EIPS/eip-20) Solidity குறியீடாக மாற்றப்பட்ட மொழிபெயர்ப்பாகும். நிச்சயமாக, இடைமுகம் எதையும் _எப்படி_ செய்வது என்பதை வரையறுக்கவில்லை. அது கீழே உள்ள ஒப்பந்த மூலக் குறியீட்டில் விளக்கப்பட்டுள்ளது.

&nbsp;

```solidity
// SPDX-License-Identifier: MIT
```

Solidity கோப்புகளில் உரிம அடையாளங்காட்டி சேர்க்கப்பட வேண்டும். [உரிமங்களின் பட்டியலை இங்கே காணலாம்](https://spdx.org/licenses/). உங்களுக்கு வேறுபட்ட உரிமம் தேவைப்பட்டால், அதை கருத்துரைகளில் விளக்கவும்.

&nbsp;

```solidity
pragma solidity >=0.6.0 <0.8.0;
```

Solidity மொழி இன்னும் வேகமாக வளர்ந்து வருகிறது, மேலும் புதிய பதிப்புகள் பழைய குறியீட்டுடன் இணக்கமாக இல்லாமல் இருக்கலாம் ([இங்கே பார்க்கவும்](https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html)). எனவே, மொழியின் குறைந்தபட்ச பதிப்பை மட்டும் குறிப்பிடாமல், குறியீட்டை நீங்கள் சோதித்த சமீபத்திய பதிப்பான அதிகபட்ச பதிப்பையும் குறிப்பிடுவது நல்லது.

&nbsp;

```solidity
/**
 * @dev EIP-இல் வரையறுக்கப்பட்டுள்ள ERC20 தரநிலையின் இடைமுகம்.
 */
```

கருத்துரையில் உள்ள `@dev` என்பது [NatSpec வடிவத்தின்](https://docs.soliditylang.org/en/develop/natspec-format.html) ஒரு பகுதியாகும், இது மூலக் குறியீட்டிலிருந்து ஆவணங்களை உருவாக்கப் பயன்படுகிறது.

&nbsp;

```solidity
interface IERC20 {
```

வழக்கமாக, இடைமுகப் பெயர்கள் `I` உடன் தொடங்கும்.

&nbsp;

```solidity
    /**
     * @dev பயன்பாட்டில் உள்ள டோக்கன்களின் அளவை வழங்குகிறது.
     */
    function totalSupply() external view returns (uint256);
```

இந்தச் செயல்பாடு `external` ஆகும், அதாவது [இதை ஒப்பந்தத்திற்கு வெளியே இருந்து மட்டுமே அழைக்க முடியும்](https://docs.soliditylang.org/en/v0.7.0/cheatsheet.html#index-2).
இது ஒப்பந்தத்தில் உள்ள டோக்கன்களின் மொத்த விநியோகத்தை வழங்குகிறது. இந்த மதிப்பு எத்தேரியத்தில் உள்ள மிகவும் பொதுவான வகையைப் பயன்படுத்தி வழங்கப்படுகிறது, அதாவது unsigned 256 பிட்கள் (256 பிட்கள் EVM-இன் இயல்பான சொல் அளவு). இந்த செயல்பாடு ஒரு `view` ஆகும், அதாவது இது நிலையை மாற்றாது, எனவே பிளாக்செயினில் உள்ள ஒவ்வொரு முனையும் இதை இயக்குவதற்குப் பதிலாக, இது ஒரு முனையில் செயல்படுத்தப்படலாம். இந்த வகையான செயல்பாடு ஒரு பரிவர்த்தனையை உருவாக்காது மற்றும் [கேஸ்](/developers/docs/gas/) செலவாகாது.

**குறிப்பு:** கோட்பாட்டளவில், ஒரு ஒப்பந்தத்தை உருவாக்கியவர் உண்மையான மதிப்பை விட குறைவான மொத்த விநியோகத்தை வழங்குவதன் மூலம் ஏமாற்றக்கூடும், இது ஒவ்வொரு டோக்கனையும் உண்மையில் இருப்பதை விட மதிப்புமிக்கதாகக் காட்டும். இருப்பினும், அந்த பயம் பிளாக்செயினின் உண்மையான தன்மையை புறக்கணிக்கிறது. பிளாக்செயினில் நடக்கும் அனைத்தையும் ஒவ்வொரு முனையாலும் சரிபார்க்க முடியும். இதை அடைய, ஒவ்வொரு ஒப்பந்தத்தின் இயந்திர மொழி குறியீடு மற்றும் சேமிப்பு ஒவ்வொரு முனையிலும் கிடைக்கும். உங்கள் ஒப்பந்தத்திற்கான Solidity குறியீட்டை வெளியிட வேண்டிய கட்டாயம் இல்லை என்றாலும், நீங்கள் மூலக் குறியீட்டையும் அது தொகுக்கப்பட்ட Solidity பதிப்பையும் வெளியிடாவிட்டால் யாரும் உங்களை தீவிரமாக எடுத்துக் கொள்ள மாட்டார்கள், அதனால் அதை நீங்கள் வழங்கிய இயந்திர மொழி குறியீட்டிற்கு எதிராக சரிபார்க்க முடியும்.
உதாரணமாக, [இந்த ஒப்பந்தத்தைப்](https://eth.blockscout.com/address/0xa530F85085C6FE2f866E7FdB716849714a89f4CD?tab=contract) பார்க்கவும்.

&nbsp;

```solidity
    /**
     * @dev `account`-க்கு சொந்தமான டோக்கன்களின் அளவை வழங்குகிறது.
     */
    function balanceOf(address account) external view returns (uint256);
```

பெயர் குறிப்பிடுவது போல, `balanceOf` ஒரு கணக்கின் இருப்பை வழங்குகிறது. எத்தேரியம் கணக்குகள் Solidity-இல் `address` வகையைப் பயன்படுத்தி அடையாளம் காணப்படுகின்றன, இது 160 பிட்களைக் கொண்டுள்ளது.
இது `external` மற்றும் `view` ஆகும்.

&nbsp;

```solidity
    /**
     * @dev அழைப்பாளரின் கணக்கிலிருந்து `recipient`-க்கு `amount` டோக்கன்களை நகர்த்துகிறது.
     *
     * செயல்பாடு வெற்றி பெற்றதா என்பதைக் குறிக்கும் ஒரு பூலியன் மதிப்பை வழங்குகிறது.
     *
     * ஒரு {Transfer} நிகழ்வை வெளியிடுகிறது.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
```

`transfer` செயல்பாடு அழைப்பாளரிடமிருந்து வேறு முகவரிக்கு டோக்கன்களை மாற்றுகிறது. இதில் ஒரு நிலை மாற்றம் உள்ளது, எனவே இது ஒரு `view` அல்ல.
ஒரு பயனர் இந்தச் செயல்பாட்டை அழைக்கும்போது, அது ஒரு பரிவர்த்தனையை உருவாக்கி கேஸ் செலவாகிறது. இது `Transfer` என்ற ஒரு நிகழ்வையும் வெளியிடுகிறது, இது பிளாக்செயினில் உள்ள அனைவருக்கும் அந்த நிகழ்வைப் பற்றித் தெரிவிக்கும்.

இந்தச் செயல்பாட்டில் இரண்டு வெவ்வேறு வகையான அழைப்பாளர்களுக்கு இரண்டு வகையான வெளியீடுகள் உள்ளன:

- பயனர் இடைமுகத்திலிருந்து நேரடியாக செயல்பாட்டை அழைக்கும் பயனர்கள். பொதுவாக பயனர் ஒரு பரிவர்த்தனையைச் சமர்ப்பித்து, ஒரு பதிலுக்காக காத்திருக்க மாட்டார், இது காலவரையற்ற நேரத்தை எடுக்கக்கூடும். பரிவர்த்தனை ரசீதைத் (பரிவர்த்தனை துண்டி மூலம் அடையாளம் காணப்படுகிறது) தேடுவதன் மூலமோ அல்லது `Transfer` நிகழ்வைத் தேடுவதன் மூலமோ என்ன நடந்தது என்பதைப் பயனர் பார்க்கலாம்.
- மற்ற ஒப்பந்தங்கள், அவை ஒட்டுமொத்த பரிவர்த்தனையின் ஒரு பகுதியாக இந்தச் செயல்பாட்டை அழைக்கின்றன. அந்த ஒப்பந்தங்கள் உடனடியாக முடிவைப் பெறுகின்றன, ஏனெனில் அவை ஒரே பரிவர்த்தனையில் இயங்குகின்றன, எனவே அவை செயல்பாட்டின் திரும்பும் மதிப்பை பயன்படுத்தலாம்.

ஒப்பந்தத்தின் நிலையை மாற்றும் பிற செயல்பாடுகளால் அதே வகையான வெளியீடு உருவாக்கப்படுகிறது.

&nbsp;

அனுமதிகள் ஒரு கணக்கை வேறு உரிமையாளருக்குச் சொந்தமான சில டோக்கன்களைச் செலவழிக்க அனுமதிக்கின்றன.
உதாரணமாக, விற்பனையாளர்களாக செயல்படும் ஒப்பந்தங்களுக்கு இது பயனுள்ளதாக இருக்கும். ஒப்பந்தங்கள் நிகழ்வுகளைக் கண்காணிக்க முடியாது, எனவே வாங்குபவர் டோக்கன்களை விற்பனையாளர் ஒப்பந்தத்திற்கு நேரடியாக மாற்றினால், அந்த ஒப்பந்தத்திற்கு பணம் செலுத்தப்பட்டதா என்பது தெரியாது. அதற்கு பதிலாக, வாங்குபவர் விற்பனையாளர் ஒப்பந்தத்தை ஒரு குறிப்பிட்ட தொகையை செலவழிக்க அனுமதிக்கிறார், மேலும் விற்பனையாளர் அந்த தொகையை மாற்றுகிறார்.
இது விற்பனையாளர் ஒப்பந்தம் அழைக்கும் ஒரு செயல்பாடு மூலம் செய்யப்படுகிறது, எனவே விற்பனையாளர் ஒப்பந்தம் அது வெற்றிகரமாக இருந்ததா என்பதை அறிந்து கொள்ள முடியும்.

```solidity
    /**
     * @dev `spender` என்பவர் `owner`-இன் சார்பாக {transferFrom} மூலம் செலவழிக்க அனுமதிக்கப்படும் மீதமுள்ள டோக்கன்களின் எண்ணிக்கையை வழங்குகிறது. இது இயல்பாக பூஜ்ஜியமாக இருக்கும்.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);
```

`allowance` செயல்பாடு ஒரு முகவரி (`owner`) மற்றொரு முகவரிக்கு (`spender`) செலவழிக்க அனுமதிக்கும் அனுமதி என்ன என்பதை யார் வேண்டுமானாலும் வினவ அனுமதிக்கிறது.

&nbsp;

```solidity
    /**
     * @dev அழைப்பாளரின் டோக்கன்கள் மீது `spender`-இன் அனுமதியாக `amount`-ஐ அமைக்கிறது.
     *
     * செயல்பாடு வெற்றி பெற்றதா என்பதைக் குறிக்கும் ஒரு பூலியன் மதிப்பை வழங்குகிறது.
     *
     * முக்கியமானது: இந்த முறையைப் பயன்படுத்தி அனுமதியை மாற்றுவது, துரதிர்ஷ்டவசமான பரிவர்த்தனை வரிசைப்படுத்துதலால் ஒருவர் பழைய மற்றும் புதிய அனுமதி இரண்டையும் பயன்படுத்தும் அபாயத்தை ஏற்படுத்துகிறது. இந்த போட்டி நிலையைத் தணிக்க ஒரு சாத்தியமான தீர்வு, முதலில் செலவழிப்பாளரின் அனுமதியை 0 ஆகக் குறைத்து, பின்னர் விரும்பிய மதிப்பை அமைப்பதாகும்:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * ஒரு {Approval} நிகழ்வை வெளியிடுகிறது.
     */
    function approve(address spender, uint256 amount) external returns (bool);
```

`approve` செயல்பாடு ஒரு அனுமதியை உருவாக்குகிறது. அது எவ்வாறு தவறாகப் பயன்படுத்தப்படலாம் என்பது பற்றிய செய்தியைப் படிக்க மறவாதீர்கள். எத்தேரியத்தில் உங்கள் சொந்தப் பரிவர்த்தனைகளின் வரிசையை நீங்கள் கட்டுப்படுத்துகிறீர்கள்,
ஆனால் மற்றவர்களின் பரிவர்த்தனைகள் செயல்படுத்தப்படும் வரிசையை நீங்கள் கட்டுப்படுத்த முடியாது, மறுபக்கத்தின் பரிவர்த்தனை நடந்ததை நீங்கள் பார்க்கும் வரை உங்கள் சொந்தப் பரிவர்த்தனையை நீங்கள் சமர்ப்பிக்காத வரையில்.

&nbsp;

```solidity
    /**
     * @dev அனுமதிப் பொறிமுறையைப் பயன்படுத்தி `sender` இடமிருந்து `recipient`க்கு `amount` டோக்கன்களை நகர்த்துகிறது. `amount` பின்னர் அழைப்பவரின் அனுமதியிலிருந்து கழிக்கப்படுகிறது.
     *
     * செயல்பாடு வெற்றியடைந்ததா என்பதைக் குறிக்கும் பூலியன் மதிப்பை வழங்குகிறது.
     *
     * ஒரு {Transfer} நிகழ்வை வெளியிடுகிறது.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```

இறுதியாக, `transferFrom` செலவழிப்பாளரால் அனுமதியைச் செலவழிக்கப் பயன்படுத்தப்படுகிறது.

&nbsp;

```solidity
    /**
     * @dev ஒரு கணக்கிலிருந்து (`from`) மற்றொரு கணக்கிற்கு (`to`) `value` டோக்கன்கள் நகர்த்தப்படும்போது வெளியிடப்படுகிறது.
     *
     * `value` பூஜ்ஜியமாக இருக்கலாம் என்பதை நினைவில் கொள்க.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev ஒரு `owner`க்கான `spender` இன் அனுமதி {approve}க்கான அழைப்பின் மூலம் அமைக்கப்படும்போது வெளியிடப்படுகிறது. `value` என்பது புதிய அனுமதி.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```

ERC-20 ஒப்பந்தத்தின் நிலை மாறும்போது இந்த நிகழ்வுகள் வெளியிடப்படுகின்றன.

## உண்மையான ஒப்பந்தம் {#the-actual-contract}

இது ERC-20 தரநிலையைச் செயல்படுத்தும் உண்மையான ஒப்பந்தம், [இங்கிருந்து எடுக்கப்பட்டது](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol).
இதை அப்படியே பயன்படுத்த வேண்டும் என்பதல்ல, ஆனால் அதைப் பயன்படுத்தக்கூடிய ஒன்றாக விரிவுபடுத்த நீங்கள் அதிலிருந்து [மரபுரிமை பெறலாம்](https://www.tutorialspoint.com/solidity/solidity_inheritance.htm).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;
```

&nbsp;

### இறக்குமதி அறிக்கைகள் {#import-statements}

மேலே உள்ள இடைமுக வரையறைகளுக்குக் கூடுதலாக, ஒப்பந்த வரையறை மற்ற இரண்டு கோப்புகளை இறக்குமதி செய்கிறது:

```solidity

import "../../GSN/Context.sol";
import "./IERC20.sol";
import "../../math/SafeMath.sol";
```

- `GSN/Context.sol` என்பது [OpenGSN](https://www.opengsn.org/)ஐப் பயன்படுத்தத் தேவையான வரையறைகளாகும், இது ஈதர் இல்லாத பயனர்கள் பிளாக்செயினைப் பயன்படுத்த அனுமதிக்கும் ஒரு அமைப்பாகும். இது ஒரு பழைய பதிப்பு என்பதை நினைவில் கொள்க, நீங்கள் OpenGSN உடன் ஒருங்கிணைக்க விரும்பினால் [இந்தப் பயிற்சியைப் பயன்படுத்தவும்](https://docs.opengsn.org/javascript-client/tutorial.html).
- [SafeMath லைப்ரரி](https://ethereumdev.io/using-safe-math-library-to-prevent-from-overflows/), இது **&lt;0.8.0** சாலிடிட்டி பதிப்புகளுக்கான எண்கணித ஓவர்ஃப்ளோ/அண்டர்ஃப்ளோக்களைத் தடுக்கிறது. சாலிடிட்டி ≥0.8.0 இல், ஓவர்ஃப்ளோ/அண்டர்ஃப்ளோவின்போது எண்கணித செயல்பாடுகள் தானாகவே மாற்றியமைக்கப்படும், இதனால் SafeMath தேவையற்றதாகிறது. பழைய கம்பைலர் பதிப்புகளுடன் பின்னோக்கிய இணக்கத்தன்மைக்காக இந்த ஒப்பந்தம் SafeMath-ஐப் பயன்படுத்துகிறது.

&nbsp;

இந்தக் கருத்து ஒப்பந்தத்தின் நோக்கத்தை விளக்குகிறது.

```solidity
/**
 * @dev {IERC20} இடைமுகத்தின் செயலாக்கம்.
 *
 * டோக்கன்கள் உருவாக்கப்படும் விதத்தில் இந்தச் செயலாக்கம் சார்பற்றது. இதன் பொருள் {_mint}ஐப் பயன்படுத்தி பெறப்பட்ட ஒப்பந்தத்தில் ஒரு வழங்கல் பொறிமுறை சேர்க்கப்பட வேண்டும். ஒரு பொதுவான பொறிமுறைக்கு {ERC20PresetMinterPauser}ஐப் பார்க்கவும்.
 *
 * உதவிக்குறிப்பு: ஒரு விரிவான எழுத்துரைக்கு எங்கள் வழிகாட்டியைப் பார்க்கவும் https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[விநியோக வழிமுறைகளை எவ்வாறு செயல்படுத்துவது].
 *
 * பொதுவான OpenZeppelin வழிகாட்டுதல்களைப் நாங்கள் பின்பற்றியுள்ளோம்: தோல்வியுற்றால் `false` என்பதைத் திருப்பியளிப்பதற்குப் பதிலாகச் செயல்பாடுகள் மாற்றியமைக்கப்படுகின்றன. இந்த நடத்தை வழக்கமானது மற்றும் ERC20 பயன்பாடுகளின் எதிர்பார்ப்புகளுடன் முரண்படாது.
 *
 * கூடுதலாக, {transferFrom}க்கான அழைப்புகளில் ஒரு {Approval} நிகழ்வு வெளியிடப்படுகிறது. இது பயன்பாடுகளைக் கூறப்பட்ட நிகழ்வுகளைக் கேட்பதன் மூலம் அனைத்து கணக்குகளுக்கான அனுமதியையும் புனரமைக்க அனுமதிக்கிறது. EIPயின் பிற செயலாக்கங்கள் இந்தக் குறிப்பால் தேவைப்படாததால் இந்த நிகழ்வுகளை வெளியிடாமல் இருக்கலாம்.
 *
 * இறுதியாக, அனுமதிகளை அமைப்பதில் உள்ள நன்கு அறியப்பட்ட சிக்கல்களைத் தணிக்க தரமற்ற {decreaseAllowance} மற்றும் {increaseAllowance} செயல்பாடுகள் சேர்க்கப்பட்டுள்ளன. {IERC20-approve}ஐப் பார்க்கவும்.
 */
```

### ஒப்பந்த வரையறை {#contract-definition}

```solidity
contract ERC20 is Context, IERC20 {
```

இந்த வரி மரபுரிமையைக் குறிப்பிடுகிறது, இந்த விடயத்தில் மேலே இருந்து `IERC20` மற்றும் OpenGSNக்கான `Context`.

&nbsp;

```solidity

    using SafeMath for uint256;

```

இந்த வரி `SafeMath` லைப்ரரியை `uint256` வகையுடன் இணைக்கிறது. இந்த லைப்ரரியை நீங்கள் [இங்கே](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol) காணலாம்.

### மாறி வரையறைகள் {#variable-definitions}

இந்த வரையறைகள் ஒப்பந்தத்தின் நிலை மாறிகளைக் குறிப்பிடுகின்றன. இந்த மாறிகள் `private` என அறிவிக்கப்பட்டுள்ளன, ஆனால் பிளாக்செயினில் உள்ள மற்ற ஒப்பந்தங்கள் அவற்றைப் படிக்க முடியாது என்று மட்டுமே அர்த்தம். _பிளாக்செயினில் ரகசியங்கள் ஏதும் இல்லை_, ஒவ்வொரு முனையிலும் உள்ள மென்பொருள் ஒவ்வொரு பிளாக்கிலும் ஒவ்வொரு ஒப்பந்தத்தின் நிலையையும் கொண்டுள்ளது. வழக்கமாக, நிலை மாறிகள் `_<something>` எனப் பெயரிடப்படுகின்றன.

முதல் இரண்டு மாறிகளும் [மேப்பிங்குகள்](https://www.tutorialspoint.com/solidity/solidity_mappings.htm), அதாவது அவை தோராயமாக [இணைப்பு வரிசைகள்](https://wikipedia.org/wiki/Associative_array) போலவே செயல்படுகின்றன, திறவுகோல்கள் எண் மதிப்புகளாக இருப்பதைத் தவிர. இயல்புநிலையிலிருந்து (பூஜ்ஜியம்) வேறுபட்ட மதிப்புகளைக் கொண்ட உள்ளீடுகளுக்கு மட்டுமே சேமிப்பகம் ஒதுக்கப்படுகிறது.

```solidity
    mapping (address => uint256) private _balances;
```

முதல் மேப்பிங், `_balances`, முகவரிகள் மற்றும் இந்த டோக்கனின் அந்தந்த இருப்புகளாகும். இருப்பை அணுக, இந்த தொடரியலைப் பயன்படுத்தவும்: `_balances[<address>]`.

&nbsp;

```solidity
    mapping (address => mapping (address => uint256)) private _allowances;
```

இந்த மாறி, `_allowances`, முன்னரே விளக்கப்பட்ட அனுமதிகளைச் சேமிக்கிறது. முதல் குறியீடு டோக்கன்களின் உரிமையாளர், மற்றும் இரண்டாவது அனுமதியுடன் கூடிய ஒப்பந்தம். முகவரி B-யின் கணக்கிலிருந்து முகவரி A செலவழிக்கக்கூடிய தொகையை அணுக, `_allowances[B][A]` ஐப் பயன்படுத்தவும்.

&nbsp;

```solidity
    uint256 private _totalSupply;
```

பெயர் குறிப்பிடுவது போல, இந்த மாறி டோக்கன்களின் மொத்த விநியோகத்தைக் கண்காணிக்கும்.

&nbsp;

```solidity
    string private _name;
    string private _symbol;
    uint8 private _decimals;
```

இந்த மூன்று மாறிகளும் வாசிப்புத் திறனை மேம்படுத்தப் பயன்படுகின்றன. முதல் இரண்டும் சுய விளக்கமளிக்கின்றன, ஆனால் `_decimals` அப்படி இல்லை.

ஒருபுறம், எத்தேரியத்தில் மிதவைப் புள்ளி அல்லது பின்ன மாறிகள் இல்லை. மறுபுறம், மனிதர்கள் டோக்கன்களைப் பிரிக்க விரும்புவார்கள். மக்கள் நாணயமாகத் தங்கத்தைத் தேர்ந்தெடுத்ததற்குக் காரணம், யாராவது ஒரு மாட்டின் மதிப்பில் ஒரு வாத்து வாங்க விரும்பும்போது சில்லறை கொடுப்பது கடினமாக இருந்தது.

தீர்வு முழு எண்களைக் கண்காணிப்பதாகும், ஆனால் உண்மையான டோக்கனுக்குப் பதிலாக கிட்டத்தட்ட மதிப்பற்ற ஒரு பின்ன டோக்கனைக் கணக்கிடுவதாகும். ஈதர் விஷயத்தில், பின்ன டோக்கன் wei என்று அழைக்கப்படுகிறது, மேலும் 10^18 wei ஒரு ETHக்குச் சமம். எழுதும்போது, 10,000,000,000,000 wei என்பது தோராயமாக ஒரு அமெரிக்க அல்லது யூரோ சென்ட் ஆகும்.

டோக்கன் இருப்பை எவ்வாறு காண்பிப்பது என்பதைப் பயன்பாடுகள் தெரிந்து கொள்ள வேண்டும். ஒரு பயனர் 3,141,000,000,000,000,000 wei வைத்திருந்தால், அது 3.14 ETH ஆகுமா? 31.41 ETH? 3,141 ETH? ஈதர் விஷயத்தில், ETH-க்கு 10^18 wei என வரையறுக்கப்படுகிறது, ஆனால் உங்கள் டோக்கனுக்கு நீங்கள் வேறு மதிப்பைத் தேர்ந்தெடுக்கலாம். டோக்கனைப் பிரிப்பதில் அர்த்தமில்லை என்றால், நீங்கள் பூஜ்ஜியத்தின் `_decimals` மதிப்பைப் பயன்படுத்தலாம். நீங்கள் ETH போன்ற அதே தரத்தைப் பயன்படுத்த விரும்பினால், **18** மதிப்பைப் பயன்படுத்தவும்.

### கன்ஸ்ட்ரக்டர் {#the-constructor}

```solidity
    /**
     * @dev {name} மற்றும் {symbol}க்கான மதிப்புகளை அமைக்கிறது, {decimals}ஐ 18 என்ற இயல்புநிலை மதிப்புடன் துவக்குகிறது.
     *
     * {decimals}க்கு வேறு மதிப்பைத் தேர்ந்தெடுக்க, {_setupDecimals}ஐப் பயன்படுத்தவும்.
     *
     * இந்த மூன்று மதிப்புகளும் மாறாதவை: அவற்றை கட்டுமானத்தின் போது ஒரு முறை மட்டுமே அமைக்க முடியும்.
     */
    constructor (string memory name_, string memory symbol_) public {
        // சாலிடிட்டி ≥0.7.0 இல், 'public' என்பது மறைமுகமானது மற்றும் தவிர்க்கப்படலாம்.

        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
```

ஒப்பந்தம் முதலில் உருவாக்கப்படும்போது கன்ஸ்ட்ரக்டர் அழைக்கப்படுகிறது. வழக்கமாக, செயல்பாட்டு அளவுருக்கள் `<something>_` எனப் பெயரிடப்படுகின்றன.

### பயனர் இடைமுக செயல்பாடுகள் {#user-interface-functions}

```solidity
    /**
     * @dev டோக்கனின் பெயரை வழங்குகிறது.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev டோக்கனின் சின்னத்தை வழங்குகிறது, பொதுவாகப் பெயரின் ஒரு குறுகிய பதிப்பு.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev அதன் பயனர் பிரதிநிதித்துவத்தைப் பெறப் பயன்படுத்தப்படும் தசமங்களின் எண்ணிக்கையை வழங்குகிறது.
     * எடுத்துக்காட்டாக, `decimals` `2` க்குச் சமமாக இருந்தால், `505` டோக்கன்களின் இருப்பு பயனருக்கு `5,05` (`505 / 10 ** 2`) ஆகக் காட்டப்பட வேண்டும்.
     *
     * டோக்கன்கள் பொதுவாக ஈதர் மற்றும் வெய் இடையேயான உறவைப் பின்பற்றி 18 என்ற மதிப்பைத் தேர்வு செய்கின்றன. {_setupDecimals} அழைக்கப்படாவிட்டால், இது {ERC20} பயன்படுத்தும் மதிப்பு.
     *
     * குறிப்பு: இந்தத் தகவல் _காட்சி_ நோக்கங்களுக்காக மட்டுமே பயன்படுத்தப்படுகிறது: இது {IERC20-balanceOf} மற்றும் {IERC20-transfer} உட்பட, ஒப்பந்தத்தின் எந்தவொரு எண்கணிதத்தையும் எந்த வகையிலும் பாதிக்காது.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
```

இந்தச் செயல்பாடுகள், `name`, `symbol`, மற்றும் `decimals` ஆகியவை உங்கள் ஒப்பந்தத்தைப் பற்றி பயனர் இடைமுகங்களுக்குத் தெரியப்படுத்த உதவுகின்றன, இதனால் அவர்களால் அதைச் சரியாகக் காட்ட முடியும்.

திரும்பும் வகை `string memory`, அதாவது நினைவகத்தில் சேமிக்கப்பட்ட ஒரு சரத்தைத் திருப்பித் தருவதாகும். சரங்கள் போன்ற மாறிகள் மூன்று இடங்களில் சேமிக்கப்படலாம்:

|          | வாழ்நாள்            | ஒப்பந்த அணுகல் | எரிவாயுச் செலவு                                                                                    |
| -------- | ------------------- | -------------- | -------------------------------------------------------------------------------------------------- |
| நினைவகம் | செயல்பாட்டு அழைப்பு | படிக்க/எழுத    | பத்துகள் அல்லது நூறுகள் (உயர் இடங்களுக்கு அதிகம்)                               |
| Calldata | செயல்பாட்டு அழைப்பு | படிக்க மட்டும் | திரும்பும் வகையாகப் பயன்படுத்த முடியாது, ஒரு செயல்பாட்டு அளவுரு வகையாக மட்டுமே பயன்படுத்த முடியும் |
| சேமிப்பு | மாறும் வரை          | படிக்க/எழுத    | அதிகம் (படிக்க 800, எழுத 20k)                                                   |

இந்த விடயத்தில், `memory` சிறந்த தேர்வாகும்.

### டோக்கன் தகவலைப் படிக்கவும் {#read-token-information}

இவை டோக்கனைப் பற்றிய தகவல்களை வழங்கும் செயல்பாடுகளாகும், மொத்த விநியோகம் அல்லது கணக்கின் இருப்பு.

```solidity
    /**
     * @dev {IERC20-totalSupply}ஐப் பார்க்கவும்.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
```

`totalSupply` செயல்பாடு டோக்கன்களின் மொத்த விநியோகத்தைத் வழங்குகிறது.

&nbsp;

```solidity
    /**
     * @dev {IERC20-balanceOf}ஐப் பார்க்கவும்.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }
```

ஒரு கணக்கின் இருப்பைப் படிக்கவும். யாரும் வேறு யாருடைய கணக்கு இருப்பையும் பெற அனுமதிக்கப்படுகிறார்கள் என்பதை நினைவில் கொள்க. இந்தத் தகவலை மறைக்க முயற்சிப்பதில் எந்தப் பயனும் இல்லை, ஏனெனில் இது எப்படியும் ஒவ்வொரு முனையிலும் கிடைக்கிறது. _பிளாக்செயினில் ரகசியங்கள் இல்லை._

### டோக்கன்களை மாற்றவும் {#transfer-tokens}

```solidity
    /**
     * @dev {IERC20-transfer}ஐப் பார்க்கவும்.
     *
     * தேவைகள்:
     *
     * - `recipient` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     * - அழைப்பவர் குறைந்தபட்சம் `amount` இருப்பைக் கொண்டிருக்க வேண்டும்.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
```

அனுப்புநரின் கணக்கிலிருந்து வேறு ஒரு கணக்கிற்கு டோக்கன்களை மாற்ற `transfer` செயல்பாடு அழைக்கப்படுகிறது. இது ஒரு பூலியன் மதிப்பைத் திருப்பியளித்தாலும், அந்த மதிப்பு எப்போதும் **true** என்பதை நினைவில் கொள்க. பரிமாற்றம் தோல்வியுற்றால், ஒப்பந்தம் அழைப்பை மாற்றியமைக்கிறது.

&nbsp;

```solidity
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
```

`_transfer` செயல்பாடு உண்மையான வேலையைச் செய்கிறது. இது ஒரு தனிப்பட்ட செயல்பாடாகும், இது மற்ற ஒப்பந்த செயல்பாடுகளால் மட்டுமே அழைக்கப்பட முடியும். வழக்கமாகத் தனிப்பட்ட செயல்பாடுகள் நிலை மாறிகளைப் போலவே `_<something>` எனப் பெயரிடப்படுகின்றன.

பொதுவாக சாலிடிட்டியில் செய்தி அனுப்புநருக்கு `msg.sender` பயன்படுத்துகிறோம். இருப்பினும், அது [OpenGSN](http://opengsn.org/)ஐ உடைக்கிறது. எங்கள் டோக்கனுடன் ஈதர் இல்லாத பரிவர்த்தனைகளை அனுமதிக்க விரும்பினால், நாம் `_msgSender()`ஐப் பயன்படுத்த வேண்டும். இது சாதாரணப் பரிவர்த்தனைகளுக்கு `msg.sender`ஐத் திருப்பித் தருகிறது, ஆனால் ஈதர் இல்லாத பரிவர்த்தனைகளுக்கு அசல் கையொப்பமிட்டவரைத் திருப்பித் தருகிறது மற்றும் செய்தியை அனுப்பிய ஒப்பந்தத்தைத் தருவதில்லை.

### அனுமதி செயல்பாடுகள் {#allowance-functions}

அனுமதி செயல்பாட்டைச் செயல்படுத்தும் செயல்பாடுகள் இவை: `allowance`, `approve`, `transferFrom`, மற்றும் `_approve`. கூடுதலாக, OpenZeppelin செயலாக்கம் பாதுகாப்பை மேம்படுத்தும் சில அம்சங்களை உள்ளடக்குவதற்கு அடிப்படைத் தரத்திற்கு அப்பாற்பட்டது: `increaseAllowance`, மற்றும் `decreaseAllowance`.

#### அனுமதி செயல்பாடு {#allowance}

```solidity
    /**
     * @dev {IERC20-allowance}ஐப் பார்க்கவும்.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
```

`allowance` செயல்பாடு அனைவரும் எந்த அனுமதியையும் சரிபார்க்க அனுமதிக்கிறது.

#### அனுமதிக்கும் செயல்பாடு {#approve}

```solidity
    /**
     * @dev {IERC20-approve}ஐப் பார்க்கவும்.
     *
     * தேவைகள்:
     *
     * - `spender` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
```

ஒரு அனுமதியை உருவாக்க இந்தச் செயல்பாடு அழைக்கப்படுகிறது. இது மேலே உள்ள `transfer` செயல்பாட்டைப் போன்றது:

- செயல்பாடு உண்மையான வேலையைச் செய்யும் ஒரு உள் செயல்பாட்டை (இந்த விடயத்தில், `_approve`) அழைக்கிறது.
- செயல்பாடு `true` (வெற்றியடைந்தால்) அல்லது மாற்றியமைக்கிறது (இல்லையென்றால்).

&nbsp;

```solidity
        _approve(_msgSender(), spender, amount);
        return true;
    }
```

நிலை மாற்றங்கள் நிகழும் இடங்களின் எண்ணிக்கையைக் குறைக்க உள் செயல்பாடுகளைப் பயன்படுத்துகிறோம். நிலையை மாற்றும் _எந்தவொரு_ செயல்பாடும் பாதுகாப்பிற்காகத் தணிக்கை செய்யப்பட வேண்டிய ஒரு சாத்தியமான பாதுகாப்பு ஆபத்தாகும். இந்த வழியில் நாம் தவறாகப் பெறுவதற்கான வாய்ப்புகள் குறைவாக உள்ளன.

#### transferFrom செயல்பாடு {#transferFrom}

இது ஒரு செலவழிப்பவர் ஒரு அனுமதியைச் செலவழிக்க அழைக்கும் செயல்பாடாகும். இதற்கு இரண்டு செயல்பாடுகள் தேவை: செலவழிக்கப்படும் தொகையை மாற்றுதல் மற்றும் அந்தத் தொகையால் அனுமதியைக் குறைத்தல்.

```solidity
    /**
     * @dev {IERC20-transferFrom}ஐப் பார்க்கவும்.
     *
     * புதுப்பிக்கப்பட்ட அனுமதியைக் குறிக்கும் ஒரு {Approval} நிகழ்வை வெளியிடுகிறது. இது EIP-ஆல் தேவையில்லை. {ERC20}-இன் தொடக்கத்தில் உள்ள குறிப்பைப் பார்க்கவும்.
     *
     * தேவைகள்:
     *
     * - `sender` மற்றும் `recipient` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     * - `sender` குறைந்தபட்சம் `amount` இருப்பைக் கொண்டிருக்க வேண்டும்.
     * - அழைப்பாளர் குறைந்தபட்சம் `amount`க்கு ``sender``-இன் டோக்கன்களுக்கான அனுமதியைக் கொண்டிருக்க வேண்டும்.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual
                                                override returns (bool) {
        _transfer(sender, recipient, amount);
```

&nbsp;

`a.sub(b, "message")` செயல்பாட்டு அழைப்பு இரண்டு விஷயங்களைச் செய்கிறது. முதலில், இது `a-b`ஐக் கணக்கிடுகிறது, இது புதிய அனுமதியாகும்.
இரண்டாவதாக, இந்த முடிவு எதிர்மறையாக இல்லை என்பதை இது சரிபார்க்கிறது. இது எதிர்மறையாக இருந்தால், வழங்கப்பட்ட செய்தியுடன் அழைப்பு மாற்றியமைக்கப்படும். ஒரு அழைப்பு மாற்றியமைக்கப்படும்போது, அந்த அழைப்பின் போது முன்னர் செய்யப்பட்ட எந்தச் செயலாக்கமும் புறக்கணிக்கப்படும் என்பதை நினைவில் கொள்க, எனவே நாம் `_transfer`ஐச் செயல்தவிர்க்கத் தேவையில்லை.

```solidity
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount,
             "ERC20: பரிமாற்றத் தொகை அனுமதியை மீறுகிறது"));
        return true;
    }
```

#### OpenZeppelin பாதுகாப்புச் சேர்த்தல்கள் {#openzeppelin-safety-additions}

பூஜ்ஜியமற்ற அனுமதியை மற்றொரு பூஜ்ஜியமற்ற மதிப்புக்கு அமைப்பது ஆபத்தானது, ஏனெனில் நீங்கள் உங்கள் சொந்த பரிவர்த்தனைகளின் வரிசையை மட்டுமே கட்டுப்படுத்துகிறீர்கள், வேறு யாருடையதையும் அல்ல. உங்களிடம் இரண்டு பயனர்கள் இருப்பதாக கற்பனை செய்து பாருங்கள், அப்பாவியான ஆலிஸ் மற்றும் நேர்மையற்ற பில். ஆலிஸ் பில்லிடமிருந்து சில சேவைகளை விரும்புகிறாள், அதற்கு ஐந்து டோக்கன்கள் செலவாகும் என்று அவள் நினைக்கிறாள் - எனவே அவள் பில்லுக்கு ஐந்து டோக்கன்களுக்கு அனுமதி அளிக்கிறாள்.

பின்னர் ஏதோ மாறுகிறது மற்றும் பில்லின் விலை பத்து டோக்கன்களாக உயர்கிறது. இன்னும் சேவையை விரும்பும் ஆலிஸ், பில்லின் அனுமதியை பத்தாக அமைக்கும் ஒரு பரிவர்த்தனையை அனுப்புகிறாள். பரிவர்த்தனைத் தொகுப்பில் இந்த புதிய பரிவர்த்தனையை பில் பார்க்கும் தருணத்தில், அவர் ஆலிஸின் ஐந்து டோக்கன்களைச் செலவழிக்கும் ஒரு பரிவர்த்தனையை அனுப்புகிறார் மற்றும் அது வேகமாக மைன் செய்யப்படுவதற்காக அதிக எரிவாயு விலையைக் கொண்டுள்ளது. அந்த வழியில், பில் முதலில் ஐந்து டோக்கன்களைச் செலவழிக்கலாம், பின்னர், ஆலிஸின் புதிய அனுமதி மைன் செய்யப்பட்டவுடன், மேலும் பத்து டோக்கன்களைச் செலவழித்து, மொத்தம் பதினைந்து டோக்கன்கள் விலையாகும், இது ஆலிஸ் அங்கீகரிக்க நினைத்ததை விட அதிகம். இந்த நுட்பம் [முன்னோட்டமிடல்](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/#front-running) என்று அழைக்கப்படுகிறது

| ஆலிஸ் பரிவர்த்தனை                    | ஆலிஸ் நோன்ஸ் | பில் பரிவர்த்தனை                                 | பில் நோன்ஸ் | பில்லின் அனுமதி | ஆலிஸிடமிருந்து பில் பெற்ற மொத்த வருமானம் |
| ------------------------------------ | ------------ | ------------------------------------------------ | ----------- | --------------- | ---------------------------------------- |
| approve(Bill, 5)  | 10           |                                                  |             | 5               | 0                                        |
|                                      |              | transferFrom(Alice, Bill, 5)  | 10,123      | 0               | 5                                        |
| approve(Bill, 10) | 11           |                                                  |             | 10              | 5                                        |
|                                      |              | transferFrom(Alice, Bill, 10) | 10,124      | 0               | 15                                       |

இந்தப் பிரச்சனையைத் தவிர்க்க, இந்த இரண்டு செயல்பாடுகளும் (`increaseAllowance` மற்றும் `decreaseAllowance`) ஒரு குறிப்பிட்ட தொகையால் அனுமதியை மாற்ற உங்களை அனுமதிக்கின்றன. எனவே, பில் ஏற்கனவே ஐந்து டோக்கன்களை செலவழித்திருந்தால், அவரால் மேலும் ஐந்து டோக்கன்களை மட்டுமே செலவழிக்க முடியும். நேரத்தைப் பொறுத்து, இது இரண்டு வழிகளில் செயல்படலாம், இரண்டு வழிகளிலும் பில் பத்து டோக்கன்களை மட்டுமே பெறுகிறார்:

A:

| ஆலிஸ் பரிவர்த்தனை                             | ஆலிஸ் நோன்ஸ் | பில் பரிவர்த்தனை                                | பில் நோன்ஸ் | பில்லின் அனுமதி | ஆலிஸிடமிருந்து பில் பெற்ற மொத்த வருமானம் |
| --------------------------------------------- | -----------: | ----------------------------------------------- | ----------: | --------------: | ---------------------------------------- |
| approve(Bill, 5)           |           10 |                                                 |             |               5 | 0                                        |
|                                               |              | transferFrom(Alice, Bill, 5) |      10,123 |               0 | 5                                        |
| increaseAllowance(Bill, 5) |           11 |                                                 |             |         0+5 = 5 | 5                                        |
|                                               |              | transferFrom(Alice, Bill, 5) |      10,124 |               0 | 10                                       |

B:

| ஆலிஸ் பரிவர்த்தனை                             | ஆலிஸ் நோன்ஸ் | பில் பரிவர்த்தனை                                 | பில் நோன்ஸ் | பில்லின் அனுமதி | ஆலிஸிடமிருந்து பில் பெற்ற மொத்த வருமானம் |
| --------------------------------------------- | -----------: | ------------------------------------------------ | ----------: | --------------: | ---------------------------------------: |
| approve(Bill, 5)           |           10 |                                                  |             |               5 |                                        0 |
| increaseAllowance(Bill, 5) |           11 |                                                  |             |        5+5 = 10 |                                        0 |
|                                               |              | transferFrom(Alice, Bill, 10) |      10,124 |               0 |                                       10 |

```solidity
    /**
     * @dev அழைப்பாளர் மூலம் `spender`-க்கு வழங்கப்பட்ட அனுமதியை தானாகவே அதிகரிக்கிறது.
     *
     * இது {approve}-க்கு ஒரு மாற்றாகும், இது {IERC20-approve}-இல் விவரிக்கப்பட்டுள்ள சிக்கல்களைத் தணிக்கப் பயன்படுத்தப்படலாம்.
     *
     * மேம்படுத்தப்பட்ட அனுமதியைக் குறிக்கும் ஒரு {Approval} நிகழ்வை வெளியிடுகிறது.
     *
     * தேவைகள்:
     *
     * - `spender` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
```

`a.add(b)` செயல்பாடு ஒரு பாதுகாப்பான கூட்டல் ஆகும். சாத்தியமில்லாத ஒரு நிகழ்வாக `a`+`b`>=`2^256` என்றால், அது சாதாரண கூட்டல் போல சுற்றி வராது.

```solidity

    /**
     * @dev அழைப்பாளர் மூலம் `spender`-க்கு வழங்கப்பட்ட அனுமதியை தானாகவே குறைக்கிறது.
     *
     * இது {approve}-க்கு ஒரு மாற்றாகும், இது {IERC20-approve}-இல் விவரிக்கப்பட்டுள்ள சிக்கல்களைத் தணிக்கப் பயன்படுத்தப்படலாம்.
     *
     * மேம்படுத்தப்பட்ட அனுமதியைக் குறிக்கும் ஒரு {Approval} நிகழ்வை வெளியிடுகிறது.
     *
     * தேவைகள்:
     *
     * - `spender` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     * - `spender` அழைப்பாளருக்கு குறைந்தபட்சம் `subtractedValue`-க்கான அனுமதியைக் கொண்டிருக்க வேண்டும்.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue,
                "ERC20: decreased allowance below zero"));
        return true;
    }
```

### டோக்கன் தகவலை மாற்றும் செயல்பாடுகள் {#functions-that-modify-token-information}

இந்த நான்கு செயல்பாடுகளே உண்மையான வேலையைச் செய்கின்றன: `_transfer`, `_mint`, `_burn`, மற்றும் `_approve`.

#### _transfer செயல்பாடு {#_transfer}

```solidity
    /**
     * @dev `sender`-இடமிருந்து `recipient`-க்கு `amount` டோக்கன்களை நகர்த்துகிறது.
     *
     * இந்த உள் செயல்பாடு {transfer}-க்கு சமமானது, மேலும் தானியங்கி டோக்கன் கட்டணங்கள், ஸ்லாஷிங் வழிமுறைகள் போன்றவற்றை செயல்படுத்தப் பயன்படுத்தப்படலாம்.
     *
     * ஒரு {Transfer} நிகழ்வை வெளியிடுகிறது.
     *
     * தேவைகள்:
     *
     * - `sender` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     * - `recipient` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     * - `sender` குறைந்தபட்சம் `amount` இருப்பு வைத்திருக்க வேண்டும்.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
```

இந்தச் செயல்பாடு, `_transfer`, ஒரு கணக்கிலிருந்து மற்றொரு கணக்கிற்கு டோக்கன்களை மாற்றுகிறது. இது `transfer` (அனுப்புநரின் சொந்தக் கணக்கிலிருந்து பரிமாற்றங்களுக்கு) மற்றும் `transferFrom` (மற்றவரின் கணக்கிலிருந்து பரிமாற்றத்திற்கு அனுமதிகளைப் பயன்படுத்துவதற்கு) ஆகிய இரண்டாலும் அழைக்கப்படுகிறது.

&nbsp;

```solidity
        require(sender != address(0), "ERC20: பூஜ்ஜிய முகவரியிலிருந்து பரிமாற்றம்");
        require(recipient != address(0), "ERC20: பூஜ்ஜிய முகவரிக்கு பரிமாற்றம்");
```

எத்தேரியத்தில் பூஜ்ஜிய முகவரியை யாரும் உண்மையில் சொந்தமாகக் கொண்டிருக்கவில்லை (அதாவது, யாருக்கும் பூஜ்ஜிய முகவரிக்கு மாற்றப்பட்ட ஒரு பொது விசைக்கு பொருந்தக்கூடிய தனிப்பட்ட விசை தெரியாது). மக்கள் அந்த முகவரியைப் பயன்படுத்தும்போது, அது பொதுவாக ஒரு மென்பொருள் பிழையாக இருக்கும் - எனவே பூஜ்ஜிய முகவரி அனுப்புநராகவோ அல்லது பெறுநராகவோ பயன்படுத்தப்பட்டால் நாங்கள் தோல்வியடைகிறோம்.

&nbsp;

```solidity
        _beforeTokenTransfer(sender, recipient, amount);

```

இந்த ஒப்பந்தத்தைப் பயன்படுத்த இரண்டு வழிகள் உள்ளன:

1. உங்கள் சொந்த குறியீட்டிற்கான ஒரு வார்ப்புருவாக இதைப் பயன்படுத்தவும்
2. [அதிலிருந்து மரபுரிமையாகப் பெறவும்](https://www.bitdegree.org/learn/solidity-inheritance), மேலும் நீங்கள் மாற்ற வேண்டிய அந்த செயல்பாடுகளை மட்டுமே மேலெழுதவும்

இரண்டாவது முறை மிகவும் சிறந்தது, ஏனெனில் OpenZeppelin ERC-20 குறியீடு ஏற்கனவே தணிக்கை செய்யப்பட்டு பாதுகாப்பானது என்று நிரூபிக்கப்பட்டுள்ளது. நீங்கள் மரபுரிமையைப் பயன்படுத்தும்போது, நீங்கள் மாற்றும் செயல்பாடுகள் என்ன என்பது தெளிவாகத் தெரிகிறது, மேலும் உங்கள் ஒப்பந்தத்தை நம்புவதற்கு மக்கள் அந்த குறிப்பிட்ட செயல்பாடுகளை மட்டுமே தணிக்கை செய்தால் போதும்.

டோக்கன்கள் கை மாறும் ஒவ்வொரு முறையும் ஒரு செயல்பாட்டைச் செய்வது பெரும்பாலும் பயனுள்ளதாக இருக்கும். இருப்பினும், `_transfer` ஒரு மிக முக்கியமான செயல்பாடு, அதை பாதுகாப்பற்ற முறையில் எழுதுவது சாத்தியம் (கீழே பார்க்கவும்), எனவே அதை மேலெழுதாமல் இருப்பது நல்லது. இதற்கான தீர்வு `_beforeTokenTransfer`, ஒரு [ஹூக் செயல்பாடு](https://wikipedia.org/wiki/Hooking). நீங்கள் இந்தச் செயல்பாட்டை மேலெழுதலாம், அது ஒவ்வொரு பரிமாற்றத்திலும் அழைக்கப்படும்.

&nbsp;

```solidity
        _balances[sender] = _balances[sender].sub(amount, "ERC20: பரிமாற்றத் தொகை இருப்பை மீறுகிறது");
        _balances[recipient] = _balances[recipient].add(amount);
```

இவைதான் உண்மையில் பரிமாற்றத்தைச் செய்யும் வரிகள். அவற்றுக்கு இடையில் **எதுவும் இல்லை** என்பதையும், மாற்றப்பட்ட தொகையை பெறுநரிடம் சேர்ப்பதற்கு முன்பு அனுப்புநரிடமிருந்து நாங்கள் கழிக்கிறோம் என்பதையும் கவனத்தில் கொள்க. இது முக்கியமானது, ஏனென்றால் நடுவில் வேறு ஒப்பந்தத்திற்கு அழைப்பு இருந்திருந்தால், அது இந்த ஒப்பந்தத்தை ஏமாற்ற பயன்படுத்தப்பட்டிருக்கலாம். இந்த வழியில் பரிமாற்றம் அணுவாக உள்ளது, அதன் நடுவில் எதுவும் நடக்க முடியாது.

&nbsp;

```solidity
        emit Transfer(sender, recipient, amount);
    }
```

இறுதியாக, ஒரு `Transfer` நிகழ்வை வெளியிடுங்கள். நிகழ்வுகளை ஸ்மார்ட் ஒப்பந்தங்களால் அணுக முடியாது, ஆனால் பிளாக்செயினுக்கு வெளியே இயங்கும் குறியீடு நிகழ்வுகளைக் கேட்டு அவற்றுக்கு எதிர்வினையாற்ற முடியும். உதாரணமாக, ஒரு பணப்பை உரிமையாளர் அதிக டோக்கன்களைப் பெறும்போது அதைக் கண்காணிக்க முடியும்.

#### _mint மற்றும் _burn செயல்பாடுகள் {#_mint-and-_burn}

இந்த இரண்டு செயல்பாடுகளும் (`_mint` மற்றும் `_burn`) டோக்கன்களின் மொத்த விநியோகத்தை மாற்றுகின்றன.
அவை உள் செயல்பாடுகள், இந்த ஒப்பந்தத்தில் அவற்றை அழைக்கும் செயல்பாடு எதுவும் இல்லை, எனவே நீங்கள் ஒப்பந்தத்திலிருந்து மரபுரிமையாகப் பெற்று, புதிய டோக்கன்களை எந்த நிபந்தனைகளின் கீழ் மின்ட் செய்வது அல்லது இருக்கும் டோக்கன்களை எப்போது பர்ன் செய்வது என்பதைத் தீர்மானிக்க உங்கள் சொந்த தர்க்கத்தைச் சேர்த்தால் மட்டுமே அவை பயனுள்ளதாக இருக்கும்.

**குறிப்பு:** ஒவ்வொரு ERC-20 டோக்கனும் டோக்கன் நிர்வாகத்தை ஆணையிடும் அதன் சொந்த வணிக தர்க்கத்தைக் கொண்டுள்ளது.
உதாரணமாக, ஒரு நிலையான விநியோக ஒப்பந்தம் கன்ஸ்ட்ரக்டரில் மட்டுமே `_mint` ஐ அழைக்கலாம் மற்றும் `_burn` ஐ ஒருபோதும் அழைக்காது. டோக்கன்களை விற்கும் ஒரு ஒப்பந்தம் பணம் செலுத்தப்பட்டதும் `_mint` ஐ அழைக்கும், மேலும் கட்டுப்பாடற்ற பணவீக்கத்தைத் தவிர்க்க ஒரு கட்டத்தில் `_burn` ஐ அழைக்கும்.

```solidity
    /** @dev `amount` டோக்கன்களை உருவாக்கி அவற்றை `account`-க்கு ஒதுக்குகிறது, மொத்த விநியோகத்தை அதிகரிக்கிறது.
     *
     * `from` பூஜ்ஜிய முகவரிக்கு அமைக்கப்பட்ட ஒரு {Transfer} நிகழ்வை வெளியிடுகிறது.
     *
     * தேவைகள்:
     *
     * - `to` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: பூஜ்ஜிய முகவரிக்கு மின்ட் செய்யவும்");
        _beforeTokenTransfer(address(0), account, amount);
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
```

மொத்த டோக்கன்களின் எண்ணிக்கை மாறும்போது `_totalSupply`-ஐப் புதுப்பிக்க மறவாதீர்கள்.

&nbsp;

```solidity
    /**
     * @dev `account`-இலிருந்து `amount` டோக்கன்களை அழிக்கிறது, மொத்த விநியோகத்தைக் குறைக்கிறது.
     *
     * `to` பூஜ்ஜிய முகவரிக்கு அமைக்கப்பட்ட ஒரு {Transfer} நிகழ்வை வெளியிடுகிறது.
     *
     * தேவைகள்:
     *
     * - `account` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     * - `account` குறைந்தபட்சம் `amount` டோக்கன்களை வைத்திருக்க வேண்டும்.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: பூஜ்ஜிய முகவரியிலிருந்து பர்ன் செய்யவும்");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: பர்ன் தொகை இருப்பை மீறுகிறது");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }
```

`_burn` செயல்பாடு `_mint`-க்கு கிட்டத்தட்ட ஒத்ததாக உள்ளது, ஆனால் இது எதிர் திசையில் செல்கிறது.

#### _approve செயல்பாடு {#_approve}

இதுதான் உண்மையில் அனுமதிகளைக் குறிப்பிடும் செயல்பாடு. இது உரிமையாளரின் தற்போதைய இருப்பை விட அதிகமான அனுமதியை உரிமையாளர் குறிப்பிட அனுமதிக்கிறது என்பதைக் கவனத்தில் கொள்க. இது பரவாயில்லை, ஏனெனில் இருப்பு பரிமாற்றத்தின் போது சரிபார்க்கப்படுகிறது, அப்போது அது அனுமதி உருவாக்கப்பட்டபோது இருந்த இருப்பிலிருந்து வேறுபட்டதாக இருக்கலாம்.

```solidity
    /**
     * @dev `owner`-இன் டோக்கன்கள் மீது `spender`-இன் அனுமதியாக `amount`-ஐ அமைக்கிறது.
     *
     * இந்த உள் செயல்பாடு `approve`-க்கு சமமானது, மேலும் சில துணை அமைப்புகளுக்கு தானியங்கி அனுமதிகளை அமைக்கப் பயன்படுத்தப்படலாம்.
     *
     * ஒரு {Approval} நிகழ்வை வெளியிடுகிறது.
     *
     * தேவைகள்:
     *
     * - `owner` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     * - `spender` பூஜ்ஜிய முகவரியாக இருக்க முடியாது.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: பூஜ்ஜிய முகவரியிலிருந்து ஒப்புதல்");
        require(spender != address(0), "ERC20: பூஜ்ஜிய முகவரிக்கு ஒப்புதல்");

        _allowances[owner][spender] = amount;
```

&nbsp;

ஒரு `Approval` நிகழ்வை வெளியிடுங்கள். பயன்பாடு எவ்வாறு எழுதப்பட்டுள்ளது என்பதைப் பொறுத்து, செலவழிப்பாளர் ஒப்பந்தத்திற்கு உரிமையாளர் மூலமாகவோ அல்லது இந்த நிகழ்வுகளைக் கேட்கும் ஒரு சேவையகம் மூலமாகவோ ஒப்புதல் பற்றித் தெரிவிக்கப்படலாம்.

```solidity
        emit Approval(owner, spender, amount);
    }

```

### தசம மாறிலியை மாற்றவும் {#modify-the-decimals-variable}

```solidity


    /**
     * @dev {decimals}-ஐ இயல்புநிலை மதிப்பான 18-ஐத் தவிர வேறு ஒரு மதிப்புக்கு அமைக்கிறது.
     *
     * எச்சரிக்கை: இந்தச் செயல்பாடு கன்ஸ்ட்ரக்டரிலிருந்து மட்டுமே அழைக்கப்பட வேண்டும். டோக்கன் ஒப்பந்தங்களுடன் தொடர்பு கொள்ளும் பெரும்பாலான பயன்பாடுகள் {decimals} எப்போதாவது மாறும் என்று எதிர்பார்க்காது, அது மாறினால் தவறாகச் செயல்படலாம்.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }
```

இந்த செயல்பாடு `_decimals` மாறிலியை மாற்றுகிறது, இது பயனர் இடைமுகங்களுக்கு தொகையை எவ்வாறு விளக்குவது என்பதைக் கூறப் பயன்படுகிறது.
நீங்கள் அதை கன்ஸ்ட்ரக்டரிலிருந்து அழைக்க வேண்டும். அடுத்த எந்த கட்டத்திலும் அதை அழைப்பது நேர்மையற்றதாக இருக்கும், மேலும் பயன்பாடுகள் அதைக் கையாள வடிவமைக்கப்படவில்லை.

### ஹூக்ஸ் {#hooks}

```solidity

    /**
     * @dev டோக்கன்களின் எந்தவொரு பரிமாற்றத்திற்கும் முன்பு அழைக்கப்படும் ஹூக். இதில் மின்டிங் மற்றும் பர்னிங் அடங்கும்.
     *
     * அழைக்கும் நிபந்தனைகள்:
     *
     * - `from` மற்றும் `to` இரண்டும் பூஜ்ஜியமற்றதாக இருக்கும்போது, `from`-இன் டோக்கன்களின் `amount` `to`-க்கு மாற்றப்படும்.
     * - `from` பூஜ்ஜியமாக இருக்கும்போது, `to`-க்காக `amount` டோக்கன்கள் மின்ட் செய்யப்படும்.
     * - `to` பூஜ்ஜியமாக இருக்கும்போது, `from`-இன் டோக்கன்களின் `amount` பர்ன் செய்யப்படும்.
     * - `from` மற்றும் `to` இரண்டும் ஒருபோதும் பூஜ்ஜியமாக இருக்காது.
     *
     * ஹூக்குகள் பற்றி மேலும் அறிய, xref:ROOT:extending-contracts.adoc#using-hooks[ஹூக்குகளைப் பயன்படுத்துதல்] என்பதற்குச் செல்லவும்.
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}
```

இது பரிமாற்றங்களின் போது அழைக்கப்பட வேண்டிய ஹூக் செயல்பாடு ஆகும். இது இங்கே காலியாக உள்ளது, ஆனால் அது ஏதாவது செய்ய வேண்டும் என்றால் நீங்கள் அதை மேலெழுதலாம்.

## முடிவுரை {#conclusion}

மதிப்பாய்வுக்காக, இந்த ஒப்பந்தத்தில் உள்ள சில மிக முக்கியமான கருத்துக்கள் இங்கே (என் கருத்துப்படி, உங்களுடையது மாறுபட வாய்ப்புள்ளது):

- _பிளாக்செயினில் இரகசியங்கள் எதுவும் இல்லை_. ஒரு ஸ்மார்ட் ஒப்பந்தம் அணுகக்கூடிய எந்தவொரு தகவலும் முழு உலகிற்கும் கிடைக்கும்.
- உங்கள் சொந்த பரிவர்த்தனைகளின் வரிசையை நீங்கள் கட்டுப்படுத்தலாம், ஆனால் மற்றவர்களின் பரிவர்த்தனை எப்போது நடக்கும் என்பதைக் கட்டுப்படுத்த முடியாது. அனுமதியை மாற்றுவது ஆபத்தானது என்பதற்கான காரணம் இதுதான், ஏனெனில் இது செலவழிப்பாளர் இரண்டு அனுமதிகளின் தொகையையும் செலவழிக்க அனுமதிக்கிறது.
- `uint256` வகையின் மதிப்புகள் சுற்றி வளைகின்றன. வேறு வார்த்தைகளில் சொல்வதென்றால், _0-1=2^256-1_. அது விரும்பத்தக்க நடத்தை இல்லை என்றால், நீங்கள் அதைச் சரிபார்க்க வேண்டும் (அல்லது உங்களுக்காக அதைச் செய்யும் SafeMath நூலகத்தைப் பயன்படுத்தவும்). [Solidity 0.8.0](https://docs.soliditylang.org/en/breaking/080-breaking-changes.html)-இல் இது மாறிவிட்டது என்பதைக் கவனத்தில் கொள்க.
- ஒரு குறிப்பிட்ட வகையின் அனைத்து நிலை மாற்றங்களையும் ஒரு குறிப்பிட்ட இடத்தில் செய்யுங்கள், ஏனெனில் இது தணிக்கையை எளிதாக்குகிறது.
  உதாரணமாக, `_approve`-ஐ நாம் கொண்டிருப்பதற்கான காரணம் இதுதான், இது `approve`, `transferFrom`, `increaseAllowance`, மற்றும் `decreaseAllowance` ஆகியவற்றால் அழைக்கப்படுகிறது.
- நிலை மாற்றங்கள் அணுவாக இருக்க வேண்டும், அவற்றின் நடுவில் வேறு எந்த செயலும் இல்லாமல் (`_transfer`-இல் நீங்கள் பார்க்க முடியும்). இதற்குக் காரணம், நிலை மாற்றத்தின் போது உங்களிடம் ஒரு சீரற்ற நிலை உள்ளது. உதாரணமாக, அனுப்புநரின் இருப்பிலிருந்து நீங்கள் கழிக்கும் நேரத்திற்கும் பெறுநரின் இருப்பில் நீங்கள் சேர்க்கும் நேரத்திற்கும் இடையில் இருக்க வேண்டியதை விட குறைவான டோக்கன்கள் பயன்பாட்டில் உள்ளன. அவற்றுக்கு இடையில் செயல்பாடுகள் இருந்தால், குறிப்பாக வேறு ஒப்பந்தத்திற்கு அழைப்புகள் இருந்தால் இது தவறாகப் பயன்படுத்தப்படலாம்.

OpenZeppelin ERC-20 ஒப்பந்தம் எவ்வாறு எழுதப்பட்டுள்ளது என்பதையும், குறிப்பாக அது எவ்வாறு பாதுகாப்பானதாக்கப்பட்டுள்ளது என்பதையும் இப்போது நீங்கள் பார்த்துள்ளீர்கள், சென்று உங்கள் சொந்த பாதுகாப்பான ஒப்பந்தங்களையும் பயன்பாடுகளையும் எழுதுங்கள்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).
