---
title: "நீங்கள் கேச் செய்யக்கூடிய அனைத்தும்"
description: மலிவான ரோலப் பரிவர்த்தனைகளுக்காக ஒரு கேச்சிங் ஒப்பந்தத்தை எவ்வாறு உருவாக்குவது மற்றும் பயன்படுத்துவது என்பதைக் கற்றுக்கொள்ளுங்கள்
author: Ori Pomerantz
tags: [ "2ம் அடுக்கு", "கேச்சிங்", "சேமிப்பு" ]
skill: intermediate
published: 2022-09-15
lang: ta
---

ரோலப்களைப் பயன்படுத்தும்போது, ஒரு சேமிப்பக ஸ்லாட்டின் விலையை விட பரிவர்த்தனையில் ஒரு பைட்டின் விலை மிகவும் விலை உயர்ந்தது. எனவே, முடிந்தவரை அதிக தகவல்களை ஆன்செயினில் கேச் செய்வது அர்த்தமுள்ளதாக இருக்கிறது.

இந்தப் பதிவில், ஒரு கேச்சிங் ஒப்பந்தத்தை எவ்வாறு உருவாக்குவது மற்றும் பயன்படுத்துவது என்பதைக் கற்றுக்கொள்வீர்கள். இதன் மூலம், பலமுறை பயன்படுத்தப்படும் எந்தவொரு அளவுரு மதிப்பும் கேச் செய்யப்பட்டு, முதல் முறைக்குப் பிறகு மிகக் குறைவான பைட்களுடன் பயன்படுத்தக் கிடைக்கும். மேலும், இந்த கேச்-ஐப் பயன்படுத்தும் ஆஃப்செயின் குறியீட்டை எவ்வாறு எழுதுவது என்பதையும் கற்றுக்கொள்வீர்கள்.

நீங்கள் கட்டுரையைத் தவிர்த்து, மூலக் குறியீட்டை மட்டும் பார்க்க விரும்பினால், [அது இங்கே உள்ளது](https://github.com/qbzzt/20220915-all-you-can-cache). உருவாக்கத் தொகுப்பு [Foundry](https://getfoundry.sh/introduction/installation/) ஆகும்.

## ஒட்டுமொத்த வடிவமைப்பு {#overall-design}

எளிமைக்காக, அனைத்து பரிவர்த்தனை அளவுருக்களும் `uint256`, 32 பைட்கள் நீளமுள்ளவை என்று கருத்தில் கொள்வோம். நாம் ஒரு பரிவர்த்தனையைப் பெறும்போது, ஒவ்வொரு அளவுருவையும் இதுபோன்று அலசுவோம்:

1. முதல் பைட் `0xFF` ஆக இருந்தால், அடுத்த 32 பைட்களை ஒரு அளவுரு மதிப்பாக எடுத்து அதை கேச்-இல் எழுதுங்கள்.

2. முதல் பைட் `0xFE` ஆக இருந்தால், அடுத்த 32 பைட்களை ஒரு அளவுரு மதிப்பாக எடுத்துக் கொள்ளுங்கள், ஆனால் அதை கேச்-இல் எழுத _வேண்டாம்_.

3. வேறு எந்த மதிப்புக்கும், மேல் நான்கு பிட்களை கூடுதல் பைட்களின் எண்ணிக்கையாகவும், கீழ் நான்கு பிட்களை கேச் கீயின் மிக முக்கியமான பிட்களாகவும் எடுத்துக் கொள்ளுங்கள். இதோ சில எடுத்துக்காட்டுகள்:

   | கால்டேட்டாவில் உள்ள பைட்கள் |  கேச் கீ |
   | :-------------------------- | -------: |
   | 0x0F                        |     0x0F |
   | 0x10,0x10                   |     0x10 |
   | 0x12,0xAC                   |   0x02AC |
   | 0x2D,0xEA, 0xD6             | 0x0DEAD6 |

## கேச் கையாளுதல் {#cache-manipulation}

[`Cache.sol`](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/Cache.sol) இல் கேச் செயல்படுத்தப்பட்டுள்ளது. அதை வரி வரியாகப் பார்ப்போம்.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;


contract Cache {

    bytes1 public constant INTO_CACHE = 0xFF;
    bytes1 public constant DONT_CACHE = 0xFE;
```

நாம் அனைத்து தகவல்களையும் வழங்கி, அதை கேச்-இல் எழுத வேண்டுமா அல்லது வேண்டாமா என்பதைத் தீர்மானிக்கும் சிறப்பு நேர்வுகளைப் புரிந்துகொள்ள இந்த மாறிலிகள் பயன்படுத்தப்படுகின்றன. கேச்-இல் எழுதுவதற்கு, முன்னர் பயன்படுத்தப்படாத சேமிப்பக ஸ்லாட்டுகளில் ஒவ்வொன்றும் 22100 கேஸ் செலவில் இரண்டு [`SSTORE`](https://www.evm.codes/#55) செயல்பாடுகள் தேவைப்படுகின்றன, எனவே நாங்கள் அதை விருப்பத்திற்குரியதாக ஆக்குகிறோம்.

```solidity

    mapping(uint => uint) public val2key;
```

மதிப்புகளுக்கும் அவற்றின் கீ-களுக்கும் இடையிலான ஒரு [மேப்பிங்](https://www.geeksforgeeks.org/solidity/solidity-mappings/). நீங்கள் பரிவர்த்தனையை அனுப்புவதற்கு முன்பு மதிப்புகளை குறியாக்கம் செய்ய இந்தத் தகவல் அவசியமானது.

```solidity
    // கீ n+1க்கான மதிப்பு இடம் n-இல் உள்ளது, ஏனெனில் நாம் பாதுகாக்க வேண்டும்
    // பூஜ்ஜியத்தை "கேச்-இல் இல்லை" என.
    uint[] public key2val;
```

கீ-களிலிருந்து மதிப்புகளுக்கான மேப்பிங்கிற்கு நாம் ஒரு வரிசையைப் பயன்படுத்தலாம், ஏனெனில் நாம் கீ-களை ஒதுக்குகிறோம், மேலும் எளிமைக்காக அதை வரிசையாகச் செய்கிறோம்.

```solidity
    function cacheRead(uint _key) public view returns (uint) {
        require(_key <= key2val.length, "துவக்கப்படாத கேச் உள்ளீட்டைப் படித்தல்");
        return key2val[_key-1];
    }  // கேச் படித்தல்
```

கேச்-இலிருந்து ஒரு மதிப்பை படிக்கவும்.

```solidity
    // ஒரு மதிப்பு ஏற்கனவே இல்லை என்றால் அதை கேச்-இல் எழுதுங்கள்
    // சோதனையைச் செயல்பட வைப்பதற்காக மட்டும் பப்ளிக்
    function cacheWrite(uint _value) public returns (uint) {
        // மதிப்பு ஏற்கனவே கேச்-இல் இருந்தால், தற்போதைய கீ-ஐத் திருப்பியளிக்கவும்
        if (val2key[_value] != 0) {
            return val2key[_value];
        }
```

ஒரே மதிப்பை ஒன்றுக்கு மேற்பட்ட முறை கேச்-இல் வைப்பதில் எந்த அர்த்தமும் இல்லை. மதிப்பு ஏற்கனவே இருந்தால், ஏற்கனவே உள்ள கீயை திருப்பியளித்தால் போதும்.

```solidity
        // 0xFE ஒரு சிறப்பு நேர்வு என்பதால், கேச் வைத்திருக்கக்கூடிய மிகப்பெரிய கீ
        // 0x0D மற்றும் அதைத் தொடர்ந்து 15 0xFF-கள் ஆகும். கேச் நீளம் ஏற்கனவே அவ்வளவு
        // பெரியதாக இருந்தால், தோல்வியடையும்.
        //                              1 2 3 4 5 6 7 8 9 A B C D E F
        require(key2val.length+1 < 0x0DFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
            "கேச் ஓவர்ஃப்ளோ");
```

இவ்வளவு பெரிய கேச்-ஐ நாம் ஒருபோதும் பெற மாட்டோம் என்று நான் நினைக்கவில்லை (தோராயமாக 1.8\*10^37 உள்ளீடுகள், சேமிப்பதற்கு சுமார் 10^27 TB தேவைப்படும்). இருப்பினும், நான் ["640kB எப்போதும் போதுமானதாக இருக்கும்"](https://quoteinvestigator.com/2011/09/08/640k-enough/) என்பதை நினைவில் கொள்ளும் அளவுக்கு வயதானவன். இந்த சோதனை மிகவும் மலிவானது.

```solidity
        // அடுத்த கீ-ஐப் பயன்படுத்தி மதிப்பை எழுதுங்கள்
        val2key[_value] = key2val.length+1;
```

தலைகீழ் தேடலைச் சேர்க்கவும் (மதிப்பிலிருந்து கீ-க்கு).

```solidity
        key2val.push(_value);
```

முன்னோக்கிய தேடலைச் சேர்க்கவும் (கீ-யிலிருந்து மதிப்புக்கு). நாம் மதிப்புகளை வரிசையாக ஒதுக்குவதால், கடைசி வரிசை மதிப்புக்குப் பிறகு அதைச் சேர்க்கலாம்.

```solidity
        return key2val.length;
    }  // கேச்ரைட்
```

புதிய மதிப்பு சேமிக்கப்பட்டுள்ள கலமான `key2val`-இன் புதிய நீளத்தைத் திருப்பியளிக்கவும்.

```solidity
    function _calldataVal(uint startByte, uint length)
        private pure returns (uint)
```

இந்தச் செயல்பாடு கால்டேட்டாவிலிருந்து தன்னிச்சையான நீளமுள்ள (32 பைட்கள் வரை, வேர்டு அளவு) ஒரு மதிப்பை படிக்கிறது.

```solidity
    {
        uint _retVal;

        require(length < 0x21,
            "_calldataVal நீள வரம்பு 32 பைட்கள்");
        require(length + startByte <= msg.data.length,
            "_calldataVal, calldatasize-ஐத் தாண்டிப் படிக்க முயற்சிக்கிறது");
```

இந்தச் செயல்பாடு உள்ளகமானது, எனவே குறியீட்டின் மீதமுள்ள பகுதி சரியாக எழுதப்பட்டிருந்தால் இந்தச் சோதனைகள் தேவையில்லை. இருப்பினும், அவற்றுக்கு அதிக செலவு ஆகாது என்பதால் நாம் அவற்றை வைத்திருக்கலாம்.

```solidity
        assembly {
            _retVal := calldataload(startByte)
        }
```

இந்தக் குறியீடு [Yul](https://docs.soliditylang.org/en/v0.8.16/yul.html)-இல் உள்ளது. இது கால்டேட்டாவிலிருந்து 32 பைட் மதிப்பைப் படிக்கிறது. கால்டேட்டா `startByte+32`-க்கு முன்பு நின்றாலும் இது வேலை செய்யும், ஏனெனில் EVM-இல் துவக்கப்படாத இடம் பூஜ்ஜியமாகக் கருதப்படுகிறது.

```solidity
        _retVal = _retVal >> (256-length*8);
```

நமக்கு அவசியமாக 32 பைட் மதிப்பு தேவையில்லை. இது அதிகப்படியான பைட்களை நீக்குகிறது.

```solidity
        return _retVal;
    } // _calldataVal


    // கால்டேட்டாவிலிருந்து ஒரு அளவுருவை படிக்கவும், _fromByte இலிருந்து தொடங்குகிறது
    function _readParam(uint _fromByte) internal
        returns (uint _nextByte, uint _parameterValue)
    {
```

கால்டேட்டாவிலிருந்து ஒரு அளவுருவை படிக்கவும். நாம் படித்த மதிப்பை மட்டுமல்ல, அடுத்த பைட்டின் இருப்பிடத்தையும் திருப்பியளிக்க வேண்டும் என்பதை கவனிக்கவும், ஏனெனில் அளவுருக்கள் 1 பைட்டிலிருந்து 33 பைட்கள் வரை இருக்கலாம்.

```solidity
        // முதல் பைட் மீதமுள்ளதை எவ்வாறு விளக்குவது என்று நமக்கு சொல்கிறது
        uint8 _firstByte;

        _firstByte = uint8(_calldataVal(_fromByte, 1));
```

ஆபத்தானதாக இருக்கக்கூடிய [மறைமுக வகை மாற்றங்களைத்](https://docs.soliditylang.org/en/v0.8.16/types.html#implicit-conversions) தடை செய்வதன் மூலம், பிழைகளின் எண்ணிக்கையை Solidity குறைக்க முயற்சிக்கிறது. ஒரு தரம் குறைப்பு, எடுத்துக்காட்டாக 256 பிட்களிலிருந்து 8 பிட்களுக்கு, வெளிப்படையாக இருக்க வேண்டும்.

```solidity

        // மதிப்பை படிக்கவும், ஆனால் அதை கேச்-இல் எழுத வேண்டாம்
        if (_firstByte == uint8(DONT_CACHE))
            return(_fromByte+33, _calldataVal(_fromByte+1, 32));

        // மதிப்பை படிக்கவும், அதை கேச்-இல் எழுதவும்
        if (_firstByte == uint8(INTO_CACHE)) {
            uint _param = _calldataVal(_fromByte+1, 32);
            cacheWrite(_param);
            return(_fromByte+33, _param);
        }

        // நாம் இங்கு வந்திருந்தால், கேச்-இலிருந்து படிக்க வேண்டும் என்று அர்த்தம்

        // படிக்க வேண்டிய கூடுதல் பைட்களின் எண்ணிக்கை
        uint8 _extraBytes = _firstByte / 16;
```

கீழே உள்ள [நிப்பிளை](https://en.wikipedia.org/wiki/Nibble) எடுத்து, கேச்-இலிருந்து மதிப்பை படிக்க மற்ற பைட்களுடன் இணைக்கவும்.

```solidity
        uint _key = (uint256(_firstByte & 0x0F) << (8*_extraBytes)) +
            _calldataVal(_fromByte+1, _extraBytes);

        return (_fromByte+_extraBytes+1, cacheRead(_key));

    }  // _readParam


    // n அளவுருக்களை படிக்கவும் (செயல்பாடுகள் தங்களுக்கு எத்தனை அளவுருக்கள் எதிர்பார்க்கப்படுகின்றன என்பதை அறியும்)
    function _readParams(uint _paramNum) internal returns (uint[] memory) {
```

கால்டேட்டாவிலிருந்தே நம்மிடம் உள்ள அளவுருக்களின் எண்ணிக்கையை பெறலாம், ஆனால் நம்மை அழைக்கும் செயல்பாடுகள் தாங்கள் எத்தனை அளவுருக்களை எதிர்பார்க்கின்றன என்பதை அறியும். அவர்கள் நமக்குச் சொல்வது எளிது.

```solidity
        // நாம் படிக்கும் அளவுருக்கள்
        uint[] memory params = new uint[](_paramNum);

        // அளவுருக்கள் பைட் 4-இல் தொடங்குகின்றன, அதற்கு முன் செயல்பாட்டு கையொப்பம் உள்ளது
        uint _atByte = 4;

        for(uint i=0; i<_paramNum; i++) {
            (_atByte, params[i]) = _readParam(_atByte);
        }
```

உங்களுக்கு தேவையான எண்ணிக்கையைப் பெறும் வரை அளவுருக்களைப் படிக்கவும். நாம் கால்டேட்டாவின் முடிவைக் கடந்தால், `_readParams` அழைப்பை மாற்றும்.

```solidity

        return(params);
    }   // readParams

    // _readParams ஐச் சோதிக்க, நான்கு அளவுருக்களைப் படிக்கும் சோதனை
    function fourParam() public
        returns (uint256,uint256,uint256,uint256)
    {
        uint[] memory params;
        params = _readParams(4);
        return (params[0], params[1], params[2], params[3]);
    }    // fourParam
```

Foundry-யின் ஒரு பெரிய நன்மை என்னவென்றால், அது சோதனைகளை Solidity-இல் எழுத அனுமதிக்கிறது (கீழே உள்ள [கேச் சோதித்தல்](#testing-the-cache) பார்க்கவும்). இது யூனிட் சோதனைகளை மிகவும் எளிதாக்குகிறது. இது நான்கு அளவுருக்களைப் படித்து, சோதனை சரிபார்க்கும் வகையில் அவற்றை வழங்கும் ஒரு செயல்பாடு ஆகும்.

```solidity
    // ஒரு மதிப்பை பெறவும், அதை குறியாக்கம் செய்யும் பைட்களை திருப்பி அனுப்பவும் (முடிந்தால் கேச்-ஐப் பயன்படுத்தி)
    function encodeVal(uint _val) public view returns(bytes memory) {
```

`encodeVal` என்பது ஆஃப்செயின் குறியீடு கேச்-ஐப் பயன்படுத்தும் கால்டேட்டாவை உருவாக்க உதவும் ஒரு செயல்பாடு ஆகும். இது ஒரு மதிப்பை பெற்று, அதை குறியாக்கம் செய்யும் பைட்களை திருப்பி அனுப்புகிறது. இந்தச் செயல்பாடு ஒரு `வியூ` ஆகும், எனவே இதற்குப் பரிவர்த்தனை தேவையில்லை, மேலும் வெளிப்புறமாக அழைக்கப்படும்போது எந்தக் கேஸும் செலவாகாது.

```solidity
        uint _key = val2key[_val];

        // மதிப்பு இன்னும் கேச்-இல் இல்லை, அதைச் சேர்க்கவும்
        if (_key == 0)
            return bytes.concat(INTO_CACHE, bytes32(_val));
```

[EVM](/developers/docs/evm/)-இல் அனைத்து ஆரம்பிக்கப்படாத சேமிப்பகமும் பூஜ்ஜியங்களாகக் கருதப்படுகிறது. எனவே, இல்லாத ஒரு மதிப்புக்கான கீயை நாம் தேடினால், நமக்கு ஒரு பூஜ்ஜியம் கிடைக்கும். அந்த நிலையில், அதைக் குறியாக்கும் பைட்கள் `INTO_CACHE` (எனவே அடுத்த முறை அது கேச் செய்யப்படும்), அதைத் தொடர்ந்து உண்மையான மதிப்பு.

```solidity
        // கீ <0x10 ஆக இருந்தால், அதை ஒரு பைட்டாக திருப்பியளிக்கவும்
        if (_key < 0x10)
            return bytes.concat(bytes1(uint8(_key)));
```

ஒற்றை பைட்கள் மிக எளிதானவை. நாம் [`bytes.concat`](https://docs.soliditylang.org/en/v0.8.16/types.html#the-functions-bytes-concat-and-string-concat)-ஐ பயன்படுத்தி ஒரு `bytes<n>` வகையை எந்த நீளத்திலும் இருக்கக்கூடிய ஒரு பைட் வரிசையாக மாற்றுகிறோம். பெயரைப் பொருட்படுத்தாமல், ஒரே ஒரு தருமதிப்புடன் வழங்கப்படும்போது அது நன்றாக வேலை செய்கிறது.

```solidity
        // இரண்டு பைட் மதிப்பு, 0x1vvv ஆக குறியாக்கம் செய்யப்பட்டது
        if (_key < 0x1000)
            return bytes.concat(bytes2(uint16(_key) | 0x1000));
```

16^3 க்கும் குறைவான ஒரு கீயை நாம் கொண்டிருக்கும்போது, அதை இரண்டு பைட்களில் வெளிப்படுத்தலாம். நாம் முதலில் 256 பிட் மதிப்பைக் கொண்ட `_key` ஐ 16 பிட் மதிப்பாக மாற்றி, முதல் பைட்டிற்கு கூடுதல் பைட்களின் எண்ணிக்கையை சேர்க்க தர்க்கரீதியான அல்லது பயன்படுத்துகிறோம். பிறகு அதை `bytes2` மதிப்பாக மாற்றி, அதை `bytes` ஆக மாற்றலாம்.

```solidity
        // பின்வரும் வரிகளை ஒரு சுழற்சியாகச் செய்ய ஒரு புத்திசாலித்தனமான வழி இருக்கலாம்,
        // ஆனால் இது ஒரு வியூ செயல்பாடு, எனவே நான் புரோகிராமர் நேரம் மற்றும்
        // எளிமைக்காக மேம்படுத்துகிறேன்.

        if (_key < 16*256**2)
            return bytes.concat(bytes3(uint24(_key) | (0x2 * 16 * 256**2)));
        if (_key < 16*256**3)
            return bytes.concat(bytes4(uint32(_key) | (0x3 * 16 * 256**3)));
             .
             .
             .
        if (_key < 16*256**14)
            return bytes.concat(bytes15(uint120(_key) | (0xE * 16 * 256**14)));
        if (_key < 16*256**15)
            return bytes.concat(bytes16(uint128(_key) | (0xF * 16 * 256**15)));
```

மற்ற மதிப்புகள் (3 பைட்கள், 4 பைட்கள், முதலியன). வெவ்வேறு புலம் அளவுகளுடன் ஒரே வழியில் கையாளப்படுகின்றன.

```solidity
        // நாம் இங்கே வந்தால், ஏதோ தவறு இருக்கிறது.
        revert("encodeVal இல் பிழை, நடக்கக்கூடாது");
```

நாம் இங்கே வந்தால், 16_256^15 க்கும் குறைவான கீ கிடைக்கவில்லை என்று அர்த்தம். ஆனால் `cacheWrite` கீகளை வரம்பிடுகிறது, அதனால் நாம் 14_256^16 வரை கூட செல்ல முடியாது (அதன் முதல் பைட் 0xFE ஆக இருக்கும், எனவே அது `DONT_CACHE` போல் தோன்றும்). ஆனால் எதிர்கால புரோகிராமர் ஒரு பிழையை அறிமுகப்படுத்தினால் ஒரு சோதனையைச் சேர்ப்பதற்கு நமக்கு அதிக செலவு ஏற்படாது.

```solidity
    } // encodeVal

}  // Cache
```

### கேச்-ஐ சோதித்தல் {#testing-the-cache}

Foundry-யின் நன்மைகளில் ஒன்று, அது [Solidity-இல் சோதனைகளை எழுத உங்களை அனுமதிக்கிறது](https://getfoundry.sh/forge/tests/overview/), இது யூனிட் சோதனைகளை எழுதுவதை எளிதாக்குகிறது. `Cache` வகுப்பிற்கான சோதனைகள் [இங்கே](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/test/Cache.t.sol) உள்ளன. சோதனை குறியீடு மீண்டும் மீண்டும் செய்யப்படுவதால், சோதனைகள் அவ்வாறு இருப்பதால், இந்தக் கட்டுரை சுவாரஸ்யமான பகுதிகளை மட்டுமே விளக்குகிறது.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";


// console க்கு `forge test -vv` இயக்க வேண்டும்.
import "forge-std/console.sol";
```

இது சோதனைக் தொகுப்பு மற்றும் `console.log` ஐப் பயன்படுத்த அவசியமான ஒரு நிலையான வடிவம் மட்டுமே.

```solidity
import "src/Cache.sol";
```

நாம் சோதிக்கும் ஒப்பந்தத்தை நாம் அறிய வேண்டும்.

```solidity
contract CacheTest is Test {
    Cache cache;

    function setUp() public {
        cache = new Cache();
    }
```

ஒவ்வொரு சோதனைக்கு முன்பும் `setUp` செயல்பாடு அழைக்கப்படுகிறது. இந்த நிலையில் நாம் ஒரு புதிய கேச்-ஐ உருவாக்குகிறோம், அதனால் நமது சோதனைகள் ஒன்றையொன்று பாதிக்காது.

```solidity
    function testCaching() public {
```

சோதனைகள் என்பவை `test` என்று தொடங்கும் பெயர்களைக் கொண்ட செயல்பாடுகள். இந்தச் செயல்பாடு அடிப்படை கேச் செயல்பாட்டைச் சரிபார்க்கிறது, மதிப்புகளை எழுதுகிறது மற்றும் அவற்றை மீண்டும் படிக்கிறது.

```solidity
        for(uint i=1; i<5000; i++) {
            cache.cacheWrite(i*i);
        }

        for(uint i=1; i<5000; i++) {
            assertEq(cache.cacheRead(i), i*i);
```

[`assert...` செயல்பாடுகளைப்](https://getfoundry.sh/reference/forge-std/std-assertions/) பயன்படுத்தி உண்மையான சோதனையை இப்படித்தான் செய்கிறீர்கள். இந்த நிலையில், நாம் எழுதிய மதிப்புதான் படித்த மதிப்பு என்பதை சரிபார்க்கிறோம். கேச் கீ-கள் நேரியலாக ஒதுக்கப்படுகின்றன என்பதை அறிந்திருப்பதால், `cache.cacheWrite`-இன் முடிவை நாம் நிராகரிக்கலாம்.

```solidity
        }
    }    // testCaching


    // ஒரே மதிப்பை பலமுறை கேச் செய்யவும், கீ அப்படியே இருப்பதை
    // உறுதிசெய்யவும்
    function testRepeatCaching() public {
        for(uint i=1; i<100; i++) {
            uint _key1 = cache.cacheWrite(i);
            uint _key2 = cache.cacheWrite(i);
            assertEq(_key1, _key2);
        }
```

முதலில் ஒவ்வொரு மதிப்பையும் இரண்டு முறை கேச்-இல் எழுதி, கீ-கள் ஒரே மாதிரியாக இருப்பதை உறுதி செய்கிறோம் (அதாவது இரண்டாவது எழுத்து உண்மையில் நடக்கவில்லை).

```solidity
        for(uint i=1; i<100; i+=3) {
            uint _key = cache.cacheWrite(i);
            assertEq(_key, i);
        }
    }    // testRepeatCaching
```

கோட்பாட்டளவில், தொடர்ச்சியான கேச் எழுதல்களைப் பாதிக்காத ஒரு பிழை இருக்கலாம். எனவே இங்கே நாம் தொடர்ச்சியாக இல்லாத சில எழுதல்களைச் செய்து, மதிப்புகள் இன்னும் மீண்டும் எழுதப்படவில்லை என்பதைக் காண்கிறோம்.

```solidity
    // மெமரி பஃப்பரிலிருந்து ஒரு uint ஐப் படிக்கவும் (நாம் அனுப்பிய அளவுருக்களை
    // மீண்டும் பெறுவதை உறுதிப்படுத்த)
    function toUint256(bytes memory _bytes, uint256 _start) internal pure
        returns (uint256)
```

ஒரு `bytes memory` பஃப்பரிலிருந்து 256 பிட் வார்த்தையைப் படிக்கவும். கேச்-ஐப் பயன்படுத்தும் ஒரு செயல்பாட்டு அழைப்பை இயக்கும்போது சரியான முடிவுகளைப் பெறுகிறோமா என்பதைச் சரிபார்க்க இந்த பயன்பாட்டுச் செயல்பாடு நமக்கு உதவுகிறது.

```solidity
    {
        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
        uint256 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }
```

Yul `uint256`-ஐத் தாண்டிய தரவுக் கட்டமைப்புகளை ஆதரிக்காது, எனவே நீங்கள் மெமரி பஃப்பர் `_bytes` போன்ற ஒரு மேம்பட்ட தரவுக் கட்டமைப்பைக் குறிப்பிடும்போது, அந்த கட்டமைப்பின் முகவரியைப் பெறுவீர்கள். Solidity `bytes memory` மதிப்புகளை 32 பைட் வார்த்தையாக சேமிக்கிறது, அது நீளத்தைக் கொண்டுள்ளது, அதைத் தொடர்ந்து உண்மையான பைட்கள் உள்ளன, எனவே `_start` என்ற பைட் எண்ணைப் பெற, நாம் `_bytes+32+_start` கணக்கிட வேண்டும்.

```solidity

        return tempUint;
    }     // toUint256

    // fourParams() க்கான செயல்பாடு கையொப்பம், உபயம்
    // https://www.4byte.directory/signatures/?bytes4_signature=0x3edc1e6d
    bytes4 constant FOUR_PARAMS = 0x3edc1e6d;

    // நாம் சரியான மதிப்புகளை மீண்டும் பெறுகிறோமா என்பதைப் பார்க்க சில மாறிலி மதிப்புகள்
    uint256 constant VAL_A = 0xDEAD60A7;
    uint256 constant VAL_B =     0xBEEF;
    uint256 constant VAL_C =     0x600D;
    uint256 constant VAL_D = 0x600D60A7;
```

சோதனைக்கு நமக்குத் தேவையான சில மாறிலிகள்.

```solidity
    function testReadParam() public {
```

`readParams` ஐப் பயன்படுத்தும் ஒரு செயல்பாடான `fourParams()` ஐ அழைக்கவும், அளவுருக்களை சரியாகப் படிக்க முடியுமா என்பதைச் சோதிக்க.

```solidity
        address _cacheAddr = address(cache);
        bool _success;
        bytes memory _callInput;
        bytes memory _callOutput;
```

கேச்-ஐப் பயன்படுத்தி ஒரு செயல்பாட்டை அழைக்க சாதாரண பயன்பாடு பைனரி இடைமுகம் (இரண்டு பைனரி நிரல் தொகுதிகள் இடையே ஒரு இடைமுகம்.)-ஐப் பயன்படுத்த முடியாது, எனவே நாம் குறைந்த அளவிலான [`<address>.call()`](https://docs.soliditylang.org/en/v0.8.16/types.html#members-of-addresses) பொறிமுறையைப் பயன்படுத்த வேண்டும். அந்தப் பொறிமுறை ஒரு `bytes memory`-ஐ உள்ளீடாக எடுத்து, அதை (ஒரு பூலியன் மதிப்புடன்) வெளியீடாகத் தருகிறது.

```solidity
        // முதல் அழைப்பு, கேச் காலியாக உள்ளது
        _callInput = bytes.concat(
            FOUR_PARAMS,
```

ஒரே ஒப்பந்தம் கேச் செய்யப்பட்ட செயல்பாடுகள் (பரிவர்த்தனைகளிலிருந்து நேரடியாக அழைப்புகளுக்கு) மற்றும் கேச் செய்யப்படாத செயல்பாடுகள் (மற்ற ஸ்மார்ட் ஒப்பந்தங்களிலிருந்து அழைப்புகளுக்கு) இரண்டையும் ஆதரிப்பது பயனுள்ளதாக இருக்கும். அதைச் செய்ய, சரியான செயல்பாட்டை அழைக்க Solidity பொறிமுறையைத் தொடர்ந்து நம்பியிருக்க வேண்டும், அனைத்தையும் [ஒரு `fallback` செயல்பாட்டில்](https://docs.soliditylang.org/en/v0.8.16/contracts.html#fallback-function) வைப்பதற்குப் பதிலாக. இதைச் செய்வது தொகுத்தலை மிகவும் எளிதாக்குகிறது. ஒரு பைட் பெரும்பாலான சந்தர்ப்பங்களில் செயல்பாட்டை அடையாளம் காண போதுமானதாக இருக்கும், எனவே நாம் மூன்று பைட்களை வீணாக்குகிறோம் (16\*3=48 கேஸ்). இருப்பினும், நான் இதை எழுதும்போது அந்த 48 கேஸ் விலை 0.07 சென்ட்கள் ஆகும், இது எளிமையான, குறைவான பிழை வாய்ப்புள்ள, குறியீட்டிற்கான நியாயமான செலவு.

```solidity
            // முதல் மதிப்பு, அதை கேச்-இல் சேர்க்கவும்
            cache.INTO_CACHE(),
            bytes32(VAL_A),
```

முதல் மதிப்பு: இது கேச்-இல் எழுதப்பட வேண்டிய ஒரு முழு மதிப்பு என்று கூறும் ஒரு கொடி, அதைத் தொடர்ந்து மதிப்பின் 32 பைட்கள். `VAL_B` கேச்-இல் எழுதப்படவில்லை மற்றும் `VAL_C` மூன்றாவது அளவுரு மற்றும் நான்காவது அளவுரு ஆகிய இரண்டும் ஆகும் என்பதைத் தவிர மற்ற மூன்று மதிப்புகளும் ஒத்தவை.

```solidity
             .
             .
             .
        );
        (_success, _callOutput) = _cacheAddr.call(_callInput);
```

இங்குதான் நாம் உண்மையில் `Cache` ஒப்பந்தத்தை அழைக்கிறோம்.

```solidity
        assertEq(_success, true);
```

அழைப்பு வெற்றிகரமாக இருக்கும் என்று நாங்கள் எதிர்பார்க்கிறோம்.

```solidity
        assertEq(cache.cacheRead(1), VAL_A);
        assertEq(cache.cacheRead(2), VAL_C);
```

நாம் ஒரு வெற்று கேச் உடன் தொடங்கி, பின்னர் `VAL_A` ஐத் தொடர்ந்து `VAL_C` ஐ சேர்க்கிறோம். முதலாவது கீ 1 ஐயும், இரண்டாவது 2 ஐயும் கொண்டிருக்கும் என்று நாங்கள் எதிர்பார்ப்போம்.

```
        assertEq(toUint256(_callOutput,0), VAL_A);
        assertEq(toUint256(_callOutput,32), VAL_B);
        assertEq(toUint256(_callOutput,64), VAL_C);
        assertEq(toUint256(_callOutput,96), VAL_C);
```

வெளியீடு நான்கு அளவுருக்கள் ஆகும். இங்கே நாம் அது சரியானது என்பதை சரிபார்க்கிறோம்.

```solidity
        // இரண்டாவது அழைப்பு, நாம் கேச்-ஐப் பயன்படுத்தலாம்
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // கேச்-இல் முதல் மதிப்பு
            bytes1(0x01),
```

16 க்கும் குறைவான கேச் கீகள் ஒரு பைட் மட்டுமே.

```solidity
            // இரண்டாவது மதிப்பு, அதை கேச்-இல் சேர்க்க வேண்டாம்
            cache.DONT_CACHE(),
            bytes32(VAL_B),

            // மூன்றாவது மற்றும் நான்காவது மதிப்புகள், ஒரே மதிப்பு
            bytes1(0x02),
            bytes1(0x02)
        );
        .
        .
        .
    }   // testReadParam
```

அழைப்புக்குப் பிறகு சோதனைகள் முதல் அழைப்புக்குப் பிறகு உள்ளவற்றைப் போலவே உள்ளன.

```solidity
    function testEncodeVal() public {
```

இந்தச் செயல்பாடு `testReadParam` ஐ ஒத்தது, ஆனால் அளவுருக்களை வெளிப்படையாக எழுதுவதற்குப் பதிலாக நாம் `encodeVal()` ஐப் பயன்படுத்துகிறோம்.

```solidity
        .
        .
        .
        _callInput = bytes.concat(
            FOUR_PARAMS,
            cache.encodeVal(VAL_A),
            cache.encodeVal(VAL_B),
            cache.encodeVal(VAL_C),
            cache.encodeVal(VAL_D)
        );
        .
        .
        .
        assertEq(_callInput.length, 4+1*4);
    }   // testEncodeVal
```

`testEncodeVal()` இல் உள்ள ஒரே கூடுதல் சோதனை `_callInput` இன் நீளம் சரியானது என்பதைச் சரிபார்ப்பதுதான். முதல் அழைப்புக்கு இது 4+33_4. இரண்டாவதுக்கு, ஒவ்வொரு மதிப்பும் ஏற்கனவே கேச்-இல் இருக்கும் இடத்தில், அது 4+1_4.

```solidity
    // கீ ஒரு பைட்டை விட அதிகமாக இருக்கும்போது encodeVal ஐ சோதிக்கவும்
    // கேச்-ஐ நான்கு பைட்களுக்கு நிரப்புவது
    // அதிக நேரம் எடுப்பதால் அதிகபட்சம் மூன்று பைட்கள்.
    function testEncodeValBig() public {
        // கேச்-இல் பல மதிப்புகளை வைக்கவும்.
        // விஷயங்களை எளிமையாக வைத்திருக்க, மதிப்பு n க்கு கீ n ஐப் பயன்படுத்தவும்.
        for(uint i=1; i<0x1FFF; i++) {
            cache.cacheWrite(i);
        }
```

மேலே உள்ள `testEncodeVal` செயல்பாடு கேச்-இல் நான்கு மதிப்புகளை மட்டுமே எழுதுகிறது, எனவே [பல-பைட் மதிப்புகளைக் கையாளும் செயல்பாட்டின் பகுதி](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/Cache.sol#L144-L171) சரிபார்க்கப்படவில்லை. ஆனால் அந்த குறியீடு சிக்கலானது மற்றும் பிழைக்கு வாய்ப்புள்ளது.

இந்தச் செயல்பாட்டின் முதல் பகுதி ஒரு சுழற்சி ஆகும், இது 1 முதல் 0x1FFF வரையிலான அனைத்து மதிப்புகளையும் வரிசையாக கேச்-இல் எழுதுகிறது, எனவே நாம் அந்த மதிப்புகளை குறியாக்கம் செய்ய முடியும் மற்றும் அவை எங்கு செல்கின்றன என்பதை அறிய முடியும்.

```solidity
        .
        .
        .

        _callInput = bytes.concat(
            FOUR_PARAMS,
            cache.encodeVal(0x000F),   // ஒரு பைட்        0x0F
            cache.encodeVal(0x0010),   // இரண்டு பைட்கள்     0x1010
            cache.encodeVal(0x0100),   // இரண்டு பைட்கள்     0x1100
            cache.encodeVal(0x1000)    // மூன்று பைட்கள் 0x201000
        );
```

ஒரு பைட், இரண்டு பைட், மற்றும் மூன்று பைட் மதிப்புகளைச் சோதிக்கவும். போதுமான ஸ்டாக் உள்ளீடுகளை எழுதுவதற்கு அதிக நேரம் எடுக்கும் என்பதால், அதையும் தாண்டி நாங்கள் சோதிக்கவில்லை (குறைந்தது 0x10000000, தோராயமாக கால் பில்லியன்).

```solidity
        .
        .
        .
        .
    }    // testEncodeValBig


    // அதிகப்படியான சிறிய பஃப்பருடன் நாம் ஒரு மாற்றத்தைப் பெறுகிறோம் என்பதைச் சோதிக்கவும்
    function testShortCalldata() public {
```

போதுமான அளவுருக்கள் இல்லாத அசாதாரண நிலையில் என்ன நடக்கிறது என்பதைச் சோதிக்கவும்.

```solidity
        .
        .
        .
        (_success, _callOutput) = _cacheAddr.call(_callInput);
        assertEq(_success, false);
    }   // testShortCalldata
```

அது திரும்பும் என்பதால், நாம் பெற வேண்டிய முடிவு `false` ஆகும்.

```
    // இல்லாத கேச் கீ-களுடன் அழைக்கவும்
    function testNoCacheKey() public {
        .
        .
        .
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // முதல் மதிப்பு, அதை கேச்-இல் சேர்க்கவும்
            cache.INTO_CACHE(),
            bytes32(VAL_A),

            // இரண்டாவது மதிப்பு
            bytes1(0x0F),
            bytes2(0x1234),
            bytes11(0xA10102030405060708090A)
        );
```

இந்தச் செயல்பாடு நான்கு சரியான அளவுருக்களைப் பெறுகிறது, கேச் காலியாக இருப்பதால் படிப்பதற்கு எந்த மதிப்பும் இல்லை என்பதைத் தவிர.

```solidity
        .
        .
        .
    // அதிகப்படியான நீண்ட பஃப்பருடன் எல்லாம் வேலை செய்கிறதா என்பதைச் சோதிக்கவும்
    function testLongCalldata() public {
        address _cacheAddr = address(cache);
        bool _success;
        bytes memory _callInput;
        bytes memory _callOutput;

        // முதல் அழைப்பு, கேச் காலியாக உள்ளது
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // முதல் மதிப்பு, அதை கேச்-இல் சேர்க்கவும்
            cache.INTO_CACHE(), bytes32(VAL_A),

            // இரண்டாவது மதிப்பு, அதை கேச்-இல் சேர்க்கவும்
            cache.INTO_CACHE(), bytes32(VAL_B),

            // மூன்றாவது மதிப்பு, அதை கேச்-இல் சேர்க்கவும்
            cache.INTO_CACHE(), bytes32(VAL_C),

            // நான்காவது மதிப்பு, அதை கேச்-இல் சேர்க்கவும்
            cache.INTO_CACHE(), bytes32(VAL_D),

            // மற்றும் "நல்ல அதிர்ஷ்டத்திற்காக" மற்றொரு மதிப்பு
            bytes4(0x31112233)
        );
```

இந்தச் செயல்பாடு ஐந்து மதிப்புகளை அனுப்புகிறது. ஐந்தாவது மதிப்பு புறக்கணிக்கப்படுகிறது என்பதை நாம் அறிவோம், ஏனெனில் அது ஒரு சரியான கேச் உள்ளீடு அல்ல, அது சேர்க்கப்படாமல் இருந்திருந்தால் ஒரு மாற்றத்தை ஏற்படுத்தியிருக்கும்.

```solidity
        (_success, _callOutput) = _cacheAddr.call(_callInput);
        assertEq(_success, true);
        .
        .
        .
    }   // testLongCalldata

}        // CacheTest

```

## ஒரு மாதிரி பயன்பாடு {#a-sample-app}

Solidity-இல் சோதனைகளை எழுதுவது எல்லாம் சரிதான், ஆனால் இறுதியில் ஒரு dApp செயின்-இற்கு வெளியே இருந்து வரும் கோரிக்கைகளைச் செயல்படுத்த முடிந்தால்தான் அது பயனுள்ளதாக இருக்கும். இந்தக் கட்டுரை ஒரு dApp-இல் கேச்சிங்கை எவ்வாறு பயன்படுத்துவது என்பதை `WORM` உடன் நிரூபிக்கிறது, இது "ஒரு முறை எழுது, பல முறை படி" என்பதைக் குறிக்கிறது. ஒரு கீ இன்னும் எழுதப்படவில்லை என்றால், நீங்கள் அதில் ஒரு மதிப்பை எழுதலாம். கீ ஏற்கனவே எழுதப்பட்டிருந்தால், உங்களுக்கு ஒரு மாற்றம் கிடைக்கும்.

### ஒப்பந்தம் {#the-contract}

[இதுதான் ஒப்பந்தம்](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/WORM.sol). இது பெரும்பாலும் `Cache` மற்றும் `CacheTest` உடன் நாம் ஏற்கனவே செய்ததை மீண்டும் செய்கிறது, எனவே சுவாரஸ்யமான பகுதிகளை மட்டுமே நாம் காண்போம்.

```solidity
import "./Cache.sol";

contract WORM is Cache {
```

`Cache` ஐப் பயன்படுத்துவதற்கான எளிதான வழி, அதை நமது சொந்த ஒப்பந்தத்தில் மரபுரிமையாகப் பெறுவதாகும்.

```solidity
    function writeEntryCached() external {
        uint[] memory params = _readParams(2);
        writeEntry(params[0], params[1]);
    }    // writeEntryCached
```

இந்தச் செயல்பாடு மேலே உள்ள `CacheTest`-இல் உள்ள `fourParam`-ஐ ஒத்தது. நாம் பயன்பாடு பைனரி இடைமுகம் (இரண்டு பைனரி நிரல் தொகுதிகள் இடையே ஒரு இடைமுகம்.) விவரக்குறிப்புகளைப் பின்பற்றாததால், செயல்பாட்டிற்குள் எந்த அளவுருக்களையும் அறிவிக்காமல் இருப்பது நல்லது.

```solidity
    // நம்மை அழைப்பதை எளிதாக்குங்கள்
    // writeEntryCached() க்கான செயல்பாடு கையொப்பம், உபயம்
    // https://www.4byte.directory/signatures/?bytes4_signature=0xe4e4f2d3
    bytes4 constant public WRITE_ENTRY_CACHED = 0xe4e4f2d3;
```

`writeEntryCached` ஐ அழைக்கும் வெளிப்புறக் குறியீடு, பயன்பாடு பைனரி இடைமுகம் (இரண்டு பைனரி நிரல் தொகுதிகள் இடையே ஒரு இடைமுகம்.) விவரக்குறிப்புகளைப் பின்பற்றாததால், `worm.writeEntryCached` ஐப் பயன்படுத்துவதற்குப் பதிலாக, கால்டேட்டாவை கைமுறையாக உருவாக்க வேண்டும். இந்த மாறிலி மதிப்பைக் கொண்டிருப்பது அதை எழுதுவதை எளிதாக்குகிறது.

நாம் `WRITE_ENTRY_CACHED`-ஐ ஒரு நிலை மாறியாக வரையறுத்தாலும், அதை வெளிப்புறமாகப் படிக்க, அதற்கான கெட்டர் செயல்பாடான `worm.WRITE_ENTRY_CACHED()`-ஐப் பயன்படுத்த வேண்டும் என்பதை கவனத்தில் கொள்ளவும்.

```solidity
    function readEntry(uint key) public view
        returns (uint _value, address _writtenBy, uint _writtenAtBlock)
```

படிக்கும் செயல்பாடு ஒரு `வியூ` ஆகும், எனவே இதற்குப் பரிவர்த்தனை தேவையில்லை மற்றும் கேஸ் செலவாகாது. இதன் விளைவாக, அளவுருவிற்கு கேச்-ஐப் பயன்படுத்துவதில் எந்தப் பலனும் இல்லை. வியூ செயல்பாடுகளுடன், எளிமையான நிலையான பொறிமுறையைப் பயன்படுத்துவது நல்லது.

### சோதனைக் குறியீடு {#the-testing-code}

[இது ஒப்பந்தத்திற்கான சோதனைக் குறியீடு](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/test/WORM.t.sol). மீண்டும், சுவாரஸ்யமானவற்றை மட்டும் பார்ப்போம்.

```solidity
    function testWReadWrite() public {
        worm.writeEntry(0xDEAD, 0x60A7);

        vm.expectRevert(bytes("entry already written"));
        worm.writeEntry(0xDEAD, 0xBEEF);
```

ஒரு Foundry சோதனையில், அடுத்த அழைப்பு தோல்வியடைய வேண்டும் என்பதையும், தோல்விக்கான அறிக்கையிடப்பட்ட காரணத்தையும் நாம் குறிப்பிடும் வழி [இது (`vm.expectRevert`)](https://book.getfoundry.sh/cheatcodes/expect-revert#expectrevert) ஆகும். இது நாம் `<contract>.<function name>` தொடரியலைப் பயன்படுத்தும்போது பொருந்தும்கால்டேட்டாவை உருவாக்கி, குறைந்த அளவிலான இடைமுகத்தைப் (`<contract>.call()`, முதலியன) பயன்படுத்தி ஒப்பந்தத்தை அழைப்பதை விட ()

```solidity
    function testReadWriteCached() public {
        uint cacheGoat = worm.cacheWrite(0x60A7);
```

இங்கே நாம் `cacheWrite` கேச் கீ-ஐ திருப்பியளிக்கிறது என்ற உண்மையை பயன்படுத்துகிறோம். இது உற்பத்தியில் பயன்படுத்த நாம் எதிர்பார்க்கும் ஒன்று அல்ல, ஏனெனில் `cacheWrite` நிலையை மாற்றுகிறது, எனவே ஒரு பரிவர்த்தனையின் போது மட்டுமே அழைக்கப்பட முடியும். பரிவர்த்தனைகளுக்குத் திரும்பும் மதிப்புகள் இல்லை, அவற்றுக்கு முடிவுகள் இருந்தால், அந்த முடிவுகள் நிகழ்வுகளாக வெளியிடப்பட வேண்டும். எனவே `cacheWrite` திரும்பும் மதிப்பு ஆன்செயின் குறியீட்டிலிருந்து மட்டுமே அணுகக்கூடியது, மேலும் ஆன்செயின் குறியீட்டிற்கு அளவுரு கேச்சிங் தேவையில்லை.

```solidity
        (_success,) = address(worm).call(_callInput);
```

`<contract address>.call()` இரண்டு ரிட்டர்ன் மதிப்புகளைக் கொண்டிருந்தாலும், முதல் மதிப்பில் மட்டுமே நாங்கள் அக்கறை கொள்கிறோம் என்பதை Solidity-க்கு இப்படித்தான் சொல்கிறோம்.

```solidity
        (_success,) = address(worm).call(_callInput);
        assertEq(_success, false);
```

நாம் குறைந்த அளவிலான `<address>.call()` செயல்பாட்டைப் பயன்படுத்துவதால், `vm.expectRevert()`-ஐப் பயன்படுத்த முடியாது மற்றும் அழைப்பிலிருந்து நாம் பெறும் பூலியன் வெற்றி மதிப்பைப் பார்க்க வேண்டும்.

```solidity
    event EntryWritten(uint indexed key, uint indexed value);

        .
        .
        .

        _callInput = bytes.concat(
            worm.WRITE_ENTRY_CACHED(), worm.encodeVal(a), worm.encodeVal(b));
        vm.expectEmit(true, true, false, false);
        emit EntryWritten(a, b);
        (_success,) = address(worm).call(_callInput);
```

Foundry-இல் குறியீடு [ஒரு நிகழ்வைச் சரியாக வெளியிடுகிறதா](https://getfoundry.sh/reference/cheatcodes/expect-emit/) என்பதைச் சரிபார்க்கும் வழி இதுதான்.

### வாடிக்கையாளர் {#the-client}

Solidity சோதனைகளுடன் நீங்கள் பெறாத ஒரு விஷயம், உங்கள் சொந்த பயன்பாட்டில் நீங்கள் வெட்டி ஒட்டக்கூடிய JavaScript குறியீடு. அந்தக் குறியீட்டை எழுத, நான் WORM-ஐ [Optimism Goerli](https://community.optimism.io/docs/useful-tools/networks/#optimism-goerli), [Optimism](https://www.optimism.io/)-இன் புதிய டெஸ்ட்நெட்டில் பயன்படுத்தினேன். அது முகவரி [`0xd34335b1d818cee54e3323d3246bd31d94e6a78a`](https://goerli-optimism.etherscan.io/address/0xd34335b1d818cee54e3323d3246bd31d94e6a78a)-இல் உள்ளது.

[வாடிக்கையாளருக்கான JavaScript குறியீட்டை இங்கே காணலாம்](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/javascript/index.js). அதைப் பயன்படுத்த:

1. கிட் களஞ்சியத்தை க்ளோன் செய்யவும்:

   ```sh
   git clone https://github.com/qbzzt/20220915-all-you-can-cache.git
   ```

2. தேவையான தொகுப்புகளை நிறுவவும்:

   ```sh
   cd javascript
   yarn
   ```

3. கட்டமைப்பு கோப்பை நகலெடுக்கவும்:

   ```sh
   cp .env.example .env
   ```

4. உங்கள் உள்ளமைவுக்கு `.env` ஐத் திருத்தவும்:

   | அளவுரு                                                        | மதிப்பு                                                                                                                                                                                               |
   | ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | MNEMONIC                                                      | ஒரு பரிவர்த்தனைக்குச் செலுத்த போதுமான ETH உள்ள ஒரு கணக்கிற்கான நினைவூட்டல். [Optimism Goerli நெட்வொர்க்கிற்கு இலவச ETH-ஐ இங்கே பெறலாம்](https://optimismfaucet.xyz/). |
   | OPTIMISM_GOERLI_URL | Optimism Goerli க்கான URL. பொது இறுதிப்புள்ளி, `https://goerli.optimism.io`, விகித வரம்புக்குட்பட்டது, ஆனால் இங்கே நமக்குத் தேவையானதற்கு போதுமானது                                    |

5. `index.js`-ஐ இயக்கவும்.

   ```sh
   node index.js
   ```

   இந்த மாதிரி பயன்பாடு முதலில் WORM-க்கு ஒரு உள்ளீட்டை எழுதுகிறது, கால்டேட்டா மற்றும் Etherscan-இல் பரிவர்த்தனைக்கான இணைப்பைக் காட்டுகிறது. பின்னர் அது அந்த உள்ளீட்டை மீண்டும் படித்து, அது பயன்படுத்தும் கீ மற்றும் உள்ளீட்டில் உள்ள மதிப்புகளை (மதிப்பு, பிளாக் எண், மற்றும் ஆசிரியர்) காட்டுகிறது.

பெரும்பாலான வாடிக்கையாளர் சாதாரண dApp JavaScript ஆகும். எனவே மீண்டும் நாம் சுவாரஸ்யமான பகுதிகளை மட்டுமே பார்ப்போம்.

```javascript
.
.
.
const main = async () => {
    const func = await worm.WRITE_ENTRY_CACHED()

    // ஒவ்வொரு முறையும் ஒரு புதிய கீ தேவை
    const key = await worm.encodeVal(Number(new Date()))
```

ஒரு குறிப்பிட்ட ஸ்லாட்டில் ஒரு முறை மட்டுமே எழுத முடியும், எனவே நாம் ஸ்லாட்களை மீண்டும் பயன்படுத்தாமல் இருப்பதை உறுதிசெய்ய நேரமுத்திரையைப் பயன்படுத்துகிறோம்.

```javascript
const val = await worm.encodeVal("0x600D")

// ஒரு உள்ளீட்டை எழுதுங்கள்
const calldata = func + key.slice(2) + val.slice(2)
```

Ethers அழைப்புத் தரவு ஒரு ஹெக்ஸ் சரமாக இருக்க வேண்டும் என்று எதிர்பார்க்கிறது, `0x` அதைத் தொடர்ந்து ஒரு இரட்டைப்படை எண்ணிக்கையிலான ஹெக்ஸாடெசிமல் இலக்கங்கள். `key` மற்றும் `val` இரண்டும் `0x` உடன் தொடங்குவதால், அந்த தலைப்புகளை நாம் அகற்ற வேண்டும்.

```javascript
const tx = await worm.populateTransaction.writeEntryCached()
tx.data = calldata

sentTx = await wallet.sendTransaction(tx)
```

Solidity சோதனைக் குறியீட்டைப் போலவே, நாம் பொதுவாக ஒரு கேச் செய்யப்பட்ட செயல்பாட்டை அழைக்க முடியாது. அதற்கு பதிலாக, நாம் ஒரு கீழ் நிலை பொறிமுறையைப் பயன்படுத்த வேண்டும்.

```javascript
    .
    .
    .
    // இப்போது எழுதிய உள்ளீட்டைப் படிக்கவும்
    const realKey = '0x' + key.slice(4)  // FF கொடியை அகற்றவும்
    const entryRead = await worm.readEntry(realKey)
    .
    .
    .
```

உள்ளீடுகளைப் படிக்க நாம் சாதாரண பொறிமுறையைப் பயன்படுத்தலாம். `வியூ` செயல்பாடுகளுடன் அளவுரு கேச்சிங்கைப் பயன்படுத்த வேண்டிய அவசியமில்லை.

## முடிவுரை {#conclusion}

இந்தக் கட்டுரையில் உள்ள குறியீடு ஒரு கருத்தின் சான்று ஆகும், இதன் நோக்கம் கருத்தை எளிதாகப் புரிந்துகொள்வதாகும். உற்பத்திக்குத் தயாரான ஒரு அமைப்புக்கு நீங்கள் சில கூடுதல் செயல்பாடுகளைச் செயல்படுத்த விரும்பலாம்:

- `uint256` அல்லாத மதிப்புகளைக் கையாளவும். எடுத்துக்காட்டாக, சரங்கள்.
- ஒரு உலகளாவிய கேச்-க்கு பதிலாக, பயனர்களுக்கும் கேச்-களுக்கும் இடையே ஒரு மேப்பிங் இருக்கலாம். வெவ்வேறு பயனர்கள் வெவ்வேறு மதிப்புகளைப் பயன்படுத்துகின்றனர்.
- முகவரிகளுக்குப் பயன்படுத்தப்படும் மதிப்புகள் மற்ற நோக்கங்களுக்காகப் பயன்படுத்தப்படும் மதிப்புகளிலிருந்து வேறுபட்டவை. முகவரிகளுக்கு மட்டும் ஒரு தனி கேச் வைத்திருப்பது அர்த்தமுள்ளதாக இருக்கலாம்.
- தற்போது, கேச் கீ-கள் "முதலில் வருபவருக்கு, சிறிய கீ" என்ற வழிமுறையில் உள்ளன. முதல் பதினாறு மதிப்புகளை ஒரு பைட்டாக அனுப்பலாம். அடுத்த 4080 மதிப்புகளை இரண்டு பைட்களாக அனுப்பலாம். அடுத்த தோராயமாக மில்லியன் மதிப்புகள் மூன்று பைட்கள், முதலியன. ஒரு உற்பத்தி அமைப்பு கேச் உள்ளீடுகளில் பயன்பாட்டு எண்ணிக்கைகளை வைத்து, பதினாறு _மிகவும் பொதுவான_ மதிப்புகள் ஒரு பைட், அடுத்த 4080 மிகவும் பொதுவான மதிப்புகள் இரண்டு பைட்கள், முதலியனவாக இருக்கும்படி அவற்றை மறுசீரமைக்க வேண்டும்.

  இருப்பினும், அது ஒரு ஆபத்தான செயல்பாடு. பின்வரும் நிகழ்வுகளின் வரிசையை கற்பனை செய்து பாருங்கள்:

  1. நோவாம் நேவ் `encodeVal` ஐ அழைத்து, அவர் டோக்கன்களை அனுப்ப விரும்பும் முகவரியை குறியாக்கம் செய்கிறார். அந்த முகவரி பயன்பாட்டில் முதலில் பயன்படுத்தப்பட்டவற்றில் ஒன்றாகும், எனவே குறியாக்கம் செய்யப்பட்ட மதிப்பு 0x06. இது ஒரு `வியூ` செயல்பாடு, ஒரு பரிவர்த்தனை அல்ல, எனவே இது நோவாமிற்கும் அவர் பயன்படுத்தும் முனைக்கும் இடையில் உள்ளது, வேறு யாருக்கும் இதைப் பற்றித் தெரியாது

  2. ஓவன் ஓனர் கேச் மறுவரிசைப்படுத்தும் செயல்பாட்டை இயக்குகிறார். மிகச் சிலரே உண்மையில் அந்த முகவரியைப் பயன்படுத்துகின்றனர், எனவே அது இப்போது 0x201122 ஆக குறியாக்கம் செய்யப்பட்டுள்ளது. ஒரு வேறுபட்ட மதிப்பு, 10^18, 0x06 ஒதுக்கப்பட்டுள்ளது.

  3. நோவாம் நேவ் தனது டோக்கன்களை 0x06-க்கு அனுப்புகிறார். அவை `0x0000000000000000000000000de0b6b3a7640000` என்ற முகவரிக்குச் செல்கின்றன, மேலும் அந்த முகவரிக்கான தனிப்பட்ட கீ யாருக்கும் தெரியாததால், அவை அங்கேயே சிக்கிக் கொள்கின்றன. நோவாம் _மகிழ்ச்சியாக இல்லை_.

  இந்த சிக்கலையும், கேச் மறுசீரமைப்பின் போது மெம்பூலில் உள்ள பரிவர்த்தனைகளின் தொடர்புடைய சிக்கலையும் தீர்க்க வழிகள் உள்ளன, ஆனால் நீங்கள் அதைப் பற்றி அறிந்திருக்க வேண்டும்.

நான் ஒரு Optimism ஊழியர் மற்றும் இது எனக்கு மிகவும் தெரிந்த ரோலப் என்பதால், நான் இங்கே Optimism-உடன் கேச்சிங்கை நிரூபித்தேன். ஆனால் இது எந்த ரோலப்புடனும் வேலை செய்ய வேண்டும், இது உள் செயலாக்கத்திற்கு ஒரு குறைந்தபட்ச செலவை வசூலிக்கிறது, எனவே ஒப்பிடுகையில் பரிவர்த்தனைத் தரவை L1-இல் எழுதுவது முக்கிய செலவாகும்.

[எனது மேலும் பணிகளை இங்கே பார்க்கவும்](https://cryptodocguy.pro/).

