---
title: "ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு"
description: "பாதுகாப்பான எத்தேரியம் ஸ்மார்ட் ஒப்பந்தங்களை உருவாக்குவதற்கான வழிகாட்டுதல்களின் கண்ணோட்டம்"
lang: ta
---

ஸ்மார்ட் ஒப்பந்தங்கள் மிகவும் நெகிழ்வானவை, மேலும் அதிக அளவிலான மதிப்பு மற்றும் தரவைக் கட்டுப்படுத்தும் திறன் கொண்டவை, அதே நேரத்தில் பிளாக்செயினில் பயன்படுத்தப்பட்ட குறியீட்டின் அடிப்படையில் மாற்ற முடியாத தர்க்கத்தை இயக்குகின்றன. நம்பிக்கையற்ற மற்றும் பரவலாக்கப்பட்ட பயன்பாடுகளின் துடிப்பான சூழல் அமைப்பை இது உருவாக்கியுள்ளது. இது மரபுவழி அமைப்புகளைக் காட்டிலும் பல நன்மைகளை வழங்குகிறது. ஸ்மார்ட் ஒப்பந்தங்களில் உள்ள பாதிப்புகளைப் பயன்படுத்திக் கொண்டு லாபம் ஈட்ட விரும்பும் தாக்குபவர்களுக்கு அவை வாய்ப்புகளையும் அளிக்கின்றன.

எத்தேரியம் போன்ற பொது பிளாக்செயின்கள், ஸ்மார்ட் ஒப்பந்தங்களைப் பாதுகாக்கும் சிக்கலை மேலும் சிக்கலாக்குகின்றன. வரிசைப்படுத்தப்பட்ட ஒப்பந்தக் குறியீட்டைப் பாதுகாப்பு குறைபாடுகளை சரிசெய்ய _வழக்கமாக_ மாற்ற முடியாது, அதேசமயம் ஸ்மார்ட் ஒப்பந்தங்களிலிருந்து திருடப்பட்ட சொத்துக்களைக் கண்காணிப்பது மிகவும் கடினம் மற்றும் மாற்றமுடியாத தன்மை காரணமாக பெரும்பாலும் மீளமுடியாது.

புள்ளிவிவரங்கள் மாறுபட்டாலும், ஸ்மார்ட் ஒப்பந்தங்களில் உள்ள பாதுகாப்புக் குறைபாடுகள் காரணமாகத் திருடப்பட்ட அல்லது இழந்த மொத்த மதிப்பின் அளவு $1 பில்லியனுக்கும் அதிகமாக இருக்கும் என்று மதிப்பிடப்பட்டுள்ளது. [DAO ஹேக்](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/) (3.6M ETH திருடப்பட்டது, இன்றைய விலையில் $1B மதிப்புக்கு மேல்), [பாரிட்டி மல்டி-சிக் வாலட் ஹேக்](https://www.coindesk.com/markets/2017/07/19/30-million-ether-reported-stolen-due-to-parity-wallet-breach) (ஹேக்கர்களால் $30M இழப்பு), மற்றும் [பாரிட்டி ஃபிரோசன் வாலட் பிரச்சினை](https://www.theguardian.com/technology/2017/nov/08/cryptocurrency-300m-dollars-stolen-bug-ether) (என்றென்றைக்குமாக $300M க்கும் அதிகமான ETH முடக்கப்பட்டது) போன்ற உயர்மட்ட சம்பவங்கள் இதில் அடங்கும்.

மேற்கூறிய சிக்கல்கள், பாதுகாப்பான, வலுவான மற்றும் நெகிழக்கூடிய ஸ்மார்ட் ஒப்பந்தங்களை உருவாக்குவதில் உருவாக்குநர்கள் முயற்சி செய்வது அவசியமாகிறது. ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு ஒரு தீவிரமான வணிகமாகும், மேலும் ஒவ்வொரு உருவாக்குநரும் கற்றுக்கொள்வது நல்லது. இந்த வழிகாட்டி எத்தேரியம் உருவாக்குநர்களுக்கான பாதுகாப்புக் கருத்தாய்வுகளை உள்ளடக்கும் மற்றும் ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பை மேம்படுத்துவதற்கான வளங்களை ஆராயும்.

## முன்னேற்றக் கட்டுரை {#prerequisites}

பாதுகாப்பைக் கையாள்வதற்கு முன், [ஸ்மார்ட் ஒப்பந்த உருவாக்கத்தின் அடிப்படைகளை](/developers/docs/smart-contracts/) நீங்கள் நன்கு அறிந்திருப்பதை உறுதிப்படுத்திக் கொள்ளுங்கள்.

## பாதுகாப்பான எத்தேரியம் ஸ்மார்ட் ஒப்பந்தங்களை உருவாக்குவதற்கான வழிகாட்டுதல்கள் {#smart-contract-security-guidelines}

### 1. சரியான அணுகல் கட்டுப்பாடுகளை வடிவமைத்தல் {#design-proper-access-controls}

ஸ்மார்ட் ஒப்பந்தங்களில், `public` அல்லது `external` எனக் குறிக்கப்பட்ட செயல்பாடுகளை வெளிப்புறச் சொந்தக் கணக்குகள் (EOA-க்கள்) அல்லது ஒப்பந்தக் கணக்குகள் மூலம் அழைக்கலாம். மற்றவர்கள் உங்கள் ஒப்பந்தத்துடன் தொடர்பு கொள்ள விரும்பினால், செயல்பாடுகளுக்கு பொதுத் தெரிவுநிலையைக் குறிப்பிடுவது அவசியம். இருப்பினும், `private` எனக் குறிக்கப்பட்ட செயல்பாடுகளை ஸ்மார்ட் ஒப்பந்தத்திற்குள் உள்ள செயல்பாடுகளால் மட்டுமே அழைக்க முடியும், வெளிப்புற கணக்குகளால் அல்ல. ஒவ்வொரு நெட்வொர்க் பங்கேற்பாளருக்கும் ஒப்பந்த செயல்பாடுகளுக்கான அணுகலை வழங்குவது சிக்கல்களை ஏற்படுத்தும், குறிப்பாக யாரேனும் முக்கியமான செயல்பாடுகளைச் செய்ய முடியும் என்றால் (எ.கா., புதிய டோக்கன்களை உருவாக்குதல்).

ஸ்மார்ட் ஒப்பந்தச் செயல்பாடுகளின் அங்கீகரிக்கப்படாத பயன்பாட்டைத் தடுக்க, பாதுகாப்பான அணுகல் கட்டுப்பாடுகளைச் செயல்படுத்துவது அவசியம். அணுகல் கட்டுப்பாட்டு வழிமுறைகள், ஒப்பந்தத்தை நிர்வகிப்பதற்குக் காரணமான கணக்குகள் போன்ற அங்கீகரிக்கப்பட்ட நிறுவனங்களுக்கு ஒரு ஸ்மார்ட் ஒப்பந்தத்தில் சில செயல்பாடுகளைப் பயன்படுத்துவதற்கான திறனைக் கட்டுப்படுத்துகின்றன. ஸ்மார்ட் ஒப்பந்தங்களில் அணுகல் கட்டுப்பாட்டைச் செயல்படுத்த **சொந்தமாக்கக்கூடிய பேட்டர்ன்** மற்றும் **பங்கு அடிப்படையிலான கட்டுப்பாடு** ஆகிய இரண்டு பேட்டர்ன்கள் பயனுள்ளதாக இருக்கும்:

#### சொந்தமாக்கக்கூடிய பேட்டர்ன் {#ownable-pattern}

சொந்தமாக்கக்கூடிய பேட்டர்னில், ஒப்பந்த-உருவாக்கச் செயல்பாட்டின் போது ஒரு முகவரி ஒப்பந்தத்தின் “உரிமையாளராக” அமைக்கப்படுகிறது. பாதுகாக்கப்பட்ட செயல்பாடுகளுக்கு `OnlyOwner` மாற்றி ஒதுக்கப்பட்டுள்ளது, இது செயல்பாட்டைச் செயல்படுத்தும் முன், அழைக்கும் முகவரியின் அடையாளத்தை ஒப்பந்தம் அங்கீகரிப்பதை உறுதி செய்கிறது. ஒப்பந்த உரிமையாளரைத் தவிர மற்ற முகவரிகளிலிருந்து பாதுகாக்கப்பட்ட செயல்பாடுகளுக்கான அழைப்புகள் எப்போதும் மாற்றியமைக்கப்படும், இது தேவையற்ற அணுகலைத் தடுக்கிறது.

#### பங்கு அடிப்படையிலான அணுகல் கட்டுப்பாடு {#role-based-access-control}

ஸ்மார்ட் ஒப்பந்தத்தில் ஒரு ஒற்றை முகவரியை `உரிமையாளராக` பதிவு செய்வது மையப்படுத்தலின் அபாயத்தை அறிமுகப்படுத்துகிறது மற்றும் ஒற்றைத் தோல்விப் புள்ளியைக் குறிக்கிறது. உரிமையாளரின் கணக்குத் திறவுகோல்கள் சிதைக்கப்பட்டால், தாக்குபவர்கள் சொந்தமான ஒப்பந்தத்தைத் தாக்கலாம். இதனால்தான் பல நிர்வாகக் கணக்குகளுடன் பங்கு அடிப்படையிலான அணுகல் கட்டுப்பாட்டு பேட்டர்னைப் பயன்படுத்துவது ஒரு சிறந்த தேர்வாக இருக்கலாம்.

பங்கு அடிப்படையிலான அணுகல் கட்டுப்பாட்டில், முக்கியமான செயல்பாடுகளுக்கான அணுகல் நம்பகமான பங்கேற்பாளர்களின் தொகுப்பிற்கு இடையில் விநியோகிக்கப்படுகிறது. உதாரணமாக, ஒரு கணக்கு டோக்கன்களை உருவாக்குவதற்குப் பொறுப்பாக இருக்கலாம், மற்றொரு கணக்கு மேம்படுத்தல்களைச் செய்கிறது அல்லது ஒப்பந்தத்தை இடைநிறுத்துகிறது. இந்த வழியில் அணுகல் கட்டுப்பாட்டைப் பரவலாக்குவது தோல்வியின் ஒற்றைப் புள்ளிகளை நீக்குகிறது மற்றும் பயனர்களுக்கான நம்பிக்கை அனுமானங்களைக் குறைக்கிறது.

##### பல-கையொப்பப் பணப்பைகளைப் பயன்படுத்துதல்

பாதுகாப்பான அணுகல் கட்டுப்பாட்டைச் செயல்படுத்துவதற்கான மற்றொரு அணுகுமுறை, ஒரு ஒப்பந்தத்தை நிர்வகிக்க [பல-கையொப்பக் கணக்கைப்](/developers/docs/smart-contracts/#multisig) பயன்படுத்துவதாகும். ஒரு வழக்கமான EOA போலல்லாமல், பல-கையொப்பக் கணக்குகள் பல நிறுவனங்களுக்குச் சொந்தமானவை மற்றும் பரிவர்த்தனைகளைச் செயல்படுத்த குறைந்தபட்ச கணக்குகளின் கையொப்பங்கள் தேவை—உதாரணமாக 5-இல் 3.

இலக்கு ஒப்பந்தத்தில் செயல்களுக்கு பல தரப்பினரின் ஒப்புதல் தேவைப்படுவதால், அணுகல் கட்டுப்பாட்டிற்கு ஒரு மல்டிசிக் பயன்படுத்துவது கூடுதல் பாதுகாப்பு அடுக்கை அறிமுகப்படுத்துகிறது. சொந்தமாக்கக்கூடிய பேட்டர்னைப் பயன்படுத்துவது அவசியமானால் இது மிகவும் பயனுள்ளதாக இருக்கும், ஏனெனில் ఇది ஒரு தாக்குபவர் அல்லது முரட்டுத்தனமான உள் நபர் முக்கியமான ஒப்பந்த செயல்பாடுகளைத் தீங்கிழைக்கும் நோக்கங்களுக்காகக் கையாளுவதை மிகவும் கடினமாக்குகிறது.

### 2. ஒப்பந்தச் செயல்பாடுகளைப் பாதுகாக்க require(), assert() மற்றும் revert() அறிக்கைகளைப் பயன்படுத்தவும் {#use-require-assert-revert}

குறிப்பிட்டுள்ளபடி, உங்கள் ஸ்மார்ட் ஒப்பந்தம் பிளாக்செயினில் பயன்படுத்தப்பட்டவுடன், எவரும் பொதுச் செயல்பாடுகளை அழைக்கலாம். வெளிப்புற கணக்குகள் ஒரு ஒப்பந்தத்துடன் எவ்வாறு தொடர்பு கொள்ளும் என்பதை உங்களால் முன்கூட்டியே அறிய முடியாததால், வரிசைப்படுத்துவதற்கு முன்பு சிக்கலான செயல்பாடுகளுக்கு எதிராக உள் பாதுகாப்புகளைச் செயல்படுத்துவது சிறந்தது. செயல்படுத்தல் சில தேவைகளைப் பூர்த்தி செய்யத் தவறினால், விதிவிலக்குகளைத் தூண்டுவதற்கும் மற்றும் நிலை மாற்றங்களைத் திருப்புவதற்கும் `require()`, `assert()` மற்றும் `revert()` அறிக்கைகளைப் பயன்படுத்தி ஸ்மார்ட் ஒப்பந்தங்களில் சரியான நடத்தையை நீங்கள் செயல்படுத்தலாம்.

**`require()`**: `require` செயல்பாடுகளின் தொடக்கத்தில் வரையறுக்கப்பட்டு, அழைக்கப்பட்ட செயல்பாடு செயல்படுத்தப்படுவதற்கு முன்பு முன்வரையறுக்கப்பட்ட நிபந்தனைகள் பூர்த்தி செய்யப்படுவதை உறுதி செய்கிறது. ஒரு `require` அறிக்கை பயனர் உள்ளீடுகளைச் சரிபார்க்க, நிலை மாறிகளைச் சரிபார்க்க அல்லது ஒரு செயல்பாட்டைத் தொடர்வதற்கு முன் அழைக்கும் கணக்கின் அடையாளத்தை அங்கீகரிக்கப் பயன்படுத்தப்படலாம்.

**`assert()`**: உங்கள் குறியீட்டில் உள்ள உள் பிழைகளைக் கண்டறியவும், “மாறிகளின்” மீறல்களைச் சரிபார்க்கவும் `assert()` பயன்படுத்தப்படுகிறது. ஒரு மாறாநிலை என்பது ஒரு ஒப்பந்தத்தின் நிலையைப் பற்றிய ஒரு தர்க்கரீதியான கூற்றாகும், இது அனைத்து செயல்பாடுகளுக்கும் உண்மையாக இருக்க வேண்டும். ஒரு டோக்கன் ஒப்பந்தத்தின் அதிகபட்ச மொத்த வழங்கல் அல்லது இருப்பு ஒரு எடுத்துக்காட்டு மாறிலியாகும். `assert()` ஐப் பயன்படுத்துவது உங்கள் ஒப்பந்தம் ஒருபோதும் பாதிப்புக்குள்ளாகும் நிலையை அடையாது என்பதை உறுதிசெய்கிறது, அவ்வாறு செய்தால், நிலை மாறிகளில் செய்யப்படும் அனைத்து மாற்றங்களும் பின்வாங்கப்படும்.

**`revert()`**: தேவைப்படும் நிபந்தனை பூர்த்தி செய்யப்படாவிட்டால் விதிவிலக்கைத் தூண்டும் if-else அறிக்கையில் `revert()` பயன்படுத்தப்படலாம். கீழே உள்ள மாதிரி ஒப்பந்தம் செயல்பாடுகளைச் செயல்படுத்துவதைப் பாதுகாக்க `revert()` ஐப் பயன்படுத்துகிறது:

```
pragma solidity ^0.8.4;

contract VendingMachine {
    address owner;
    error Unauthorized();
    function buy(uint amount) public payable {
        if (amount > msg.value / 2 ether)
            revert("போதுமான ஈதர் வழங்கப்படவில்லை.");
        // கொள்முதலைச் செய்யவும்.
    }
    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}
```

### ஒரு நல்ல கதை. ஸ்மார்ட் ஒப்பந்தங்களைச் சோதித்து குறியீட்டின் சரியான தன்மையை சரிபார்க்கவும் {#test-smart-contracts-and-verify-code-correctness}

[எத்தேரியம் மெய்நிகர் இயந்திரத்தில்](/developers/docs/evm/) இயங்கும் குறியீட்டின் மாற்ற முடியாத தன்மை, ஸ்மார்ட் ஒப்பந்தங்களுக்கு மேம்பாட்டுக் கட்டத்தில் உயர் மட்ட தர மதிப்பீடு தேவை என்பதைக் குறிக்கிறது. உங்கள் ஒப்பந்தத்தை விரிவாகச் சோதித்து, எதிர்பாராத முடிவுகளுக்காக அதைக் கவனிப்பது பாதுகாப்பை வெகுவாக மேம்படுத்தும் மற்றும் நீண்ட காலத்திற்கு உங்கள் பயனர்களைப் பாதுகாக்கும்.

பயனர்களிடமிருந்து ஒப்பந்தம் பெறும் என்று எதிர்பார்க்கப்படும் போலி தரவைப் பயன்படுத்தி சிறிய யூனிட் சோதனைகளை எழுதுவதே வழக்கமான முறையாகும். [அலகு சோதனை](/developers/docs/smart-contracts/testing/#unit-testing) சில செயல்பாடுகளின் செயல்பாட்டைச் சோதிப்பதற்கும் ஸ்மார்ட் ஒப்பந்தம் எதிர்பார்த்தபடி செயல்படுவதை உறுதி செய்வதற்கும் நல்லது.

துரதிர்ஷ்டவசமாக, தனிமைப்படுத்தப்பட்டுப் பயன்படுத்தும்போது ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பை மேம்படுத்துவதற்கு அலகு சோதனை குறைந்தபட்ச செயல்திறன் கொண்டது. ஒரு அலகு சோதனை, ஒரு செயல்பாடு போலித் தரவுகளுக்குச் சரியாகச் செயல்படுகிறது என்பதை நிரூபிக்கலாம், ஆனால் எழுதப்பட்ட சோதனைகளைப் போலவே அலகு சோதனைகளும் பயனுள்ளதாக இருக்கும். இது உங்கள் ஸ்மார்ட் ஒப்பந்தத்தின் பாதுகாப்பை உடைக்கக்கூடிய விளிம்பு நிலைகளையும் பாதிப்புகளையும் கண்டறிவதை கடினமாக்குகிறது.

[நிலையான மற்றும் மாறும் பகுப்பாய்வைப்](/developers/docs/smart-contracts/testing/#static-dynamic-analysis) பயன்படுத்தி செய்யப்படும் சொத்து அடிப்படையிலான சோதனையுடன் அலகு சோதனையை இணைப்பது ஒரு சிறந்த அணுகுமுறையாகும். நிலையான பகுப்பாய்வு, அடையக்கூடிய நிரல் நிலைகள் மற்றும் செயல்பாட்டுப் பாதைகளை ஆய்வு செய்ய [கட்டுப்பாட்டு ஓட்ட வரைபடங்கள்](https://en.wikipedia.org/wiki/Control-flow_graph) மற்றும் [சுருக்க தொடரியல் மரங்கள்](https://deepsource.io/glossary/ast/) போன்ற கீழ்மட்டப் பிரதிநிதித்துவங்களைச் சார்ந்துள்ளது. இதற்கிடையில், [ஸ்மார்ட் ஒப்பந்த ஃபஸ்ஸிங்](https://www.cyfrin.io/blog/smart-contract-fuzzing-and-invariants-testing-foundry) போன்ற மாறும் பகுப்பாய்வு நுட்பங்கள், பாதுகாப்புப் பண்புகளை மீறும் செயல்பாடுகளைக் கண்டறிய சீரற்ற உள்ளீட்டு மதிப்புகளுடன் ஒப்பந்தக் குறியீட்டைச் செயல்படுத்துகின்றன.

[முறையான சரிபார்ப்பு](/developers/docs/smart-contracts/formal-verification) என்பது ஸ்மார்ட் ஒப்பந்தங்களில் பாதுகாப்புப் பண்புகளைச் சரிபார்க்கும் மற்றொரு நுட்பமாகும். சாதாரண சோதனையைப் போலல்லாமல், முறையான சரிபார்ப்பு ஒரு ஸ்மார்ட் ஒப்பந்தத்தில் பிழைகள் இல்லாததை உறுதியாக நிரூபிக்க முடியும். விரும்பிய பாதுகாப்புப் பண்புகளைப் பிடிக்கும் ஒரு முறையான விவரக்குறிப்பை உருவாக்குவதன் மூலமும், ஒப்பந்தங்களின் முறையான மாதிரி இந்த விவரக்குறிப்பைப் பின்பற்றுகிறது என்பதை நிரூபிப்பதன் மூலமும் இது அடையப்படுகிறது.

### 4. உங்கள் குறியீட்டைச் சுதந்திரமாக மதிப்பாய்வு செய்யக் கோரவும் {#get-independent-code-reviews}

உங்கள் ஒப்பந்தத்தைச் சோதித்த பிறகு, ஏதேனும் பாதுகாப்புச் சிக்கல்களுக்கு மூலக் குறியீட்டைச் சரிபார்க்க மற்றவர்களைக் கேட்பது நல்லது. சோதனையானது ஒரு ஸ்மார்ட் ஒப்பந்தத்தில் உள்ள ஒவ்வொரு குறைபாட்டையும் வெளிக்கொணராது, ஆனால் ஒரு சுதந்திரமான மதிப்பாய்வைப் பெறுவது பாதிப்புகளைக் கண்டறியும் வாய்ப்பை அதிகரிக்கிறது.

#### தணிக்கைகள் {#audits}

ஒரு ஸ்மார்ட் ஒப்பந்தத் தணிக்கையை நியமிப்பது ஒரு சுயாதீனக் குறியீடு மதிப்பாய்வை நடத்துவதற்கான ஒரு வழியாகும். ஸ்மார்ட் ஒப்பந்தங்கள் பாதுகாப்பானவை மற்றும் தரக்குறைபாடுகள் மற்றும் வடிவமைப்பு பிழைகள் இல்லாமல் இருப்பதை உறுதி செய்வதில் தணிக்கையாளர்கள் முக்கிய பங்கு வகிக்கின்றனர்.

அப்படியிருந்தும், தணிக்கைகளை ஒரு சில்வர் புல்லட்டாகக் கருதுவதை நீங்கள் தவிர்க்க வேண்டும். ஸ்மார்ட் ஒப்பந்தத் தணிக்கைகள் ஒவ்வொரு பிழையையும் பிடிக்காது, மேலும் அவை பெரும்பாலும் கூடுதல் சுற்று மதிப்பாய்வுகளை வழங்குவதற்காக வடிவமைக்கப்பட்டுள்ளன, இது ஆரம்ப மேம்பாடு மற்றும் சோதனையின் போது உருவாக்குநர்களால் தவறவிட்ட சிக்கல்களைக் கண்டறிய உதவும். குறியீட்டைச் சரியாக ஆவணப்படுத்துதல் மற்றும் இன்லைன் கருத்துகளைச் சேர்ப்பது போன்ற தணிக்கையாளர்களுடன் பணிபுரிவதற்கான சிறந்த நடைமுறைகளையும் நீங்கள் பின்பற்ற வேண்டும். இது ஒரு ஸ்மார்ட் ஒப்பந்தத் தணிக்கையின் பலனை அதிகரிக்கச் செய்யும்.

- [ஸ்மார்ட் ஒப்பந்த தணிக்கை குறிப்புகள் & தந்திரங்கள்](https://twitter.com/tinchoabbate/status/1400170232904400897) - _@tinchoabbate_
- [உங்கள் தணிக்கையிலிருந்து அதிகப் பலனைப் பெறுங்கள்](https://inference.ag/blog/2023-08-14-tips/) - _Inference_

#### பிழை சன்மானங்கள் {#bug-bounties}

ஒரு பிழை சன்மானத் திட்டத்தை அமைப்பது வெளிப்புறக் குறியீடு மதிப்பாய்வுகளைச் செயல்படுத்துவதற்கான மற்றொரு அணுகுமுறையாகும். ஒரு பிழை சன்மானம் என்பது ஒரு பயன்பாட்டில் உள்ள பாதிப்புகளைக் கண்டறியும் நபர்களுக்கு (பொதுவாக வொயிட்ஹேட் ஹேக்கர்கள்) வழங்கப்படும் நிதி வெகுமதியாகும்.

சரியாகப் பயன்படுத்தினால், பிழை சன்மானங்கள் ஹேக்கர் சமூகத்தின் உறுப்பினர்களுக்கு உங்கள் குறியீட்டில் முக்கியமான குறைபாடுகளை ஆய்வு செய்ய ஊக்கமளிக்கின்றன. எத்தேரியத்தில் இயங்கும் [அடுக்கு 2](/layer-2/) நெறிமுறையான [Optimism](https://www.optimism.io/) இல் ஒரு தாக்குபவர் வரம்பற்ற ஈதரை உருவாக்க அனுமதிக்கும் “முடிவற்ற பணப் பிழை” ஒரு நிஜ வாழ்க்கை உதாரணமாகும். அதிர்ஷ்டவசமாக, ஒரு வொயிட்ஹேட் ஹேக்கர் [குறைபாட்டைக் கண்டுபிடித்து](https://www.saurik.com/optimism.html) குழுவுக்குத் தெரிவித்தார், [இந்தச் செயல்பாட்டில் பெரும் ஊதியத்தைப் பெற்றார்](https://cryptoslate.com/critical-bug-in-ethereum-l2-optimism-2m-bounty-paid/).

பங்குகளில் உள்ள நிதிகளின் அளவிற்கு விகிதாசாரத்தில் ஒரு பிழை சன்மானத் திட்டத்தின் ஊதியத்தை அமைப்பது ஒரு பயனுள்ள உத்தியாகும். “[ஸ்கேலிங் பிழை சன்மானம்](https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7)” என விவரிக்கப்படும் இந்த அணுகுமுறை, பாதிப்புகளைச் சுரண்டுவதற்குப் பதிலாகப் பொறுப்புடன் வெளிப்படுத்த தனிநபர்களுக்கு நிதிச் சலுகைகளை வழங்குகிறது.

### Visual Direction • உள்ளடக்கம். ஸ்மார்ட் ஒப்பந்த மேம்பாட்டின் போது சிறந்த நடைமுறைகளைப் பின்பற்றவும் {#follow-smart-contract-development-best-practices}

தணிக்கைகள் மற்றும் பிழை சன்மானங்கள் இருப்பது உயர்தரக் குறியீட்டை எழுதுவதற்கான உங்கள் பொறுப்பிலிருந்து உங்களை மன்னிக்காது. நல்ல ஸ்மார்ட் ஒப்பந்த பாதுகாப்பு சரியான வடிவமைப்பு மற்றும் மேம்பாட்டு செயல்முறைகளைப் பின்பற்றுவதில் தொடங்குகிறது:

- git போன்ற பதிப்புக் கட்டுப்பாட்டு அமைப்பில் அனைத்துக் குறியீட்டையும் சேமிக்கவும்

- புல் கோரிக்கைகள் வழியாக அனைத்து குறியீடு மாற்றங்களையும் செய்யவும்

- புல் கோரிக்கைகளுக்குக் குறைந்தபட்சம் ஒரு சுயாதீன மதிப்பாய்வாளர் இருப்பதை உறுதிசெய்யவும்—நீங்கள் ஒரு திட்டத்தில் தனியாக வேலை செய்தால், மற்ற உருவாக்குநர்களைக் கண்டுபிடித்து குறியீடு மதிப்பாய்வுகளைப் பரிமாறிக்கொள்ளுங்கள்

- ஸ்மார்ட் ஒப்பந்தங்களைச் சோதித்தல், தொகுத்தல் மற்றும் வரிசைப்படுத்துதல் ஆகியவற்றிற்காக ஒரு [மேம்பாட்டுச் சூழலைப்](/developers/docs/frameworks/) பயன்படுத்தவும்

- [Cyfrin Aderyn](https://github.com/Cyfrin/aderyn), Mythril மற்றும் Slither போன்ற அடிப்படைக் குறியீடு பகுப்பாய்வுக் கருவிகள் மூலம் உங்கள் குறியீட்டை இயக்கவும். சிறப்பாக, ஒவ்வொரு புல் கோரிக்கையும் ஒன்றிணைக்கப்படுவதற்கு முன்பு இதைச் செய்து, வெளியீட்டில் உள்ள வேறுபாடுகளை ஒப்பிட வேண்டும்.

- உங்கள் குறியீடு பிழைகள் இல்லாமல் தொகுக்கப்படுவதையும், Solidity தொகுப்பி எந்த எச்சரிக்கைகளையும் வெளியிடவில்லை என்பதையும் உறுதிசெய்யவும்

- உங்கள் குறியீட்டைச் சரியாக ஆவணப்படுத்தவும் ([NatSpec](https://solidity.readthedocs.io/en/develop/natspec-format.html) ஐப் பயன்படுத்தி) மற்றும் ஒப்பந்தக் கட்டமைப்பைப் பற்றிய விவரங்களை எளிதில் புரிந்துகொள்ளக்கூடிய மொழியில் விவரிக்கவும். இது மற்றவர்கள் உங்கள் குறியீட்டைத் தணிக்கை செய்வதையும் மதிப்பாய்வு செய்வதையும் எளிதாக்கும்.

### 6. வலுவான பேரழிவு மீட்புத் திட்டங்களைச் செயல்படுத்தவும் {#implement-disaster-recovery-plans}

பாதுகாப்பான அணுகல் கட்டுப்பாடுகளை வடிவமைத்தல், செயல்பாட்டு மாற்றிகளைச் செயல்படுத்துதல் மற்றும் பிற பரிந்துரைகள் ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பை மேம்படுத்தலாம், ஆனால் அவை தீங்கிழைக்கும் சுரண்டல்களின் சாத்தியக்கூறுகளை நிராகரிக்க முடியாது. பாதுகாப்பான ஸ்மார்ட் ஒப்பந்தங்களை உருவாக்குவதற்கு “தோல்விக்குத் தயாராவது” மற்றும் தாக்குதல்களுக்கு திறம்பட பதிலளிக்க ஒரு பின்னடைவுத் திட்டம் தேவை. ஒரு சரியான பேரழிவு மீட்புத் திட்டம் பின்வரும் சில அல்லது அனைத்து கூறுகளையும் உள்ளடக்கும்:

#### ஒப்பந்த மேம்படுத்தல்கள் {#contract-upgrades}

எத்தேரியம் ஸ்மார்ட் ஒப்பந்தங்கள் இயல்பாகவே மாற்ற முடியாதவை என்றாலும், மேம்படுத்தல் பேட்டர்ன்களைப் பயன்படுத்தி சில அளவு மாற்றத்தன்மையை அடைய முடியும். ஒரு முக்கியமான குறைபாடு உங்கள் பழைய ஒப்பந்தத்தைப் பயன்படுத்த முடியாததாக மாற்றும் சந்தர்ப்பங்களில் ஒப்பந்தங்களை மேம்படுத்துவது அவசியமாகும், மேலும் புதிய தர்க்கத்தை வரிசைப்படுத்துவது மிகவும் சாத்தியமான விருப்பமாகும்.

ஒப்பந்த மேம்படுத்தல் வழிமுறைகள் வித்தியாசமாகச் செயல்படுகின்றன, ஆனால் “ப்ராக்ஸி பேட்டர்ன்” என்பது ஸ்மார்ட் ஒப்பந்தங்களை மேம்படுத்துவதற்கான மிகவும் பிரபலமான அணுகுமுறைகளில் ஒன்றாகும். [ப்ராக்ஸி பேட்டர்ன்கள்](https://www.cyfrin.io/blog/upgradeable-proxy-smart-contract-pattern) ஒரு பயன்பாட்டின் நிலை மற்றும் தர்க்கத்தை _இரண்டு_ ஒப்பந்தங்களுக்கு இடையில் பிரிக்கிறது. முதல் ஒப்பந்தம் (‘ப்ராக்ஸி ஒப்பந்தம்’ என அழைக்கப்படுகிறது) நிலை மாறிகளை (எ.கா., பயனர் இருப்பு) சேமிக்கிறது, அதேசமயம் இரண்டாவது ஒப்பந்தம் (‘லாஜிக் ஒப்பந்தம்’ என அழைக்கப்படுகிறது) ஒப்பந்தச் செயல்பாடுகளைச் செயல்படுத்தும் குறியீட்டைக் கொண்டுள்ளது.

கணக்குகள் ப்ராக்ஸி ஒப்பந்தத்துடன் தொடர்பு கொள்கின்றன, இது [`delegatecall()`](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries) குறைந்த-நிலை அழைப்பைப் பயன்படுத்தி அனைத்து செயல்பாட்டு அழைப்புகளையும் தர்க்க ஒப்பந்தத்திற்கு அனுப்புகிறது. ஒரு வழக்கமான செய்தி அழைப்பைப் போலல்லாமல், `delegatecall()` தர்க்க ஒப்பந்தத்தின் முகவரியில் இயங்கும் குறியீடு அழைக்கும் ஒப்பந்தத்தின் சூழலில் செயல்படுத்தப்படுவதை உறுதி செய்கிறது. இதன் பொருள் தர்க்க ஒப்பந்தம் எப்போதும் ப்ராக்ஸியின் சேமிப்பகத்தில் எழுதும் (அதன் சொந்த சேமிப்பகத்திற்கு பதிலாக) மற்றும் `msg.sender` மற்றும் `msg.value` இன் அசல் மதிப்புகள் பாதுகாக்கப்படும்.

தர்க்க ஒப்பந்தத்திற்கான அழைப்புகளைப் பிரதிநிதித்துவப்படுத்த, அதன் முகவரியை ப்ராக்ஸி ஒப்பந்தத்தின் சேமிப்பகத்தில் சேமிக்க வேண்டும். எனவே, ஒப்பந்தத்தின் தர்க்கத்தை மேம்படுத்துவது மற்றொரு தர்க்க ஒப்பந்தத்தை வரிசைப்படுத்தி புதிய முகவரியை ப்ராக்ஸி ஒப்பந்தத்தில் சேமிப்பதாகும். ப்ராக்ஸி ஒப்பந்தத்திற்கான அடுத்தடுத்த அழைப்புகள் தானாகவே புதிய தர்க்க ஒப்பந்தத்திற்கு அனுப்பப்படுவதால், நீங்கள் குறியீட்டை மாற்றாமல் ஒப்பந்தத்தை “மேம்படுத்தி” இருப்பீர்கள்.

[ஒப்பந்தங்களை மேம்படுத்துவது பற்றி மேலும் அறிய](/developers/docs/smart-contracts/upgrading/).

#### அவசர நிறுத்தங்கள் {#emergency-stops}

குறிப்பிட்டபடி, விரிவான தணிக்கை மற்றும் சோதனை ஒரு ஸ்மார்ட் ஒப்பந்தத்தில் உள்ள அனைத்துப் பிழைகளையும் கண்டறிய முடியாது. வரிசைப்படுத்தப்பட்ட பிறகு உங்கள் குறியீட்டில் ஒரு பாதிப்பு தோன்றினால், ஒப்பந்த முகவரியில் இயங்கும் குறியீட்டை மாற்ற முடியாததால் அதை சரிசெய்வது சாத்தியமில்லை. மேலும், மேம்படுத்தல் வழிமுறைகள் (எ.கா., ப்ராக்ஸி பேட்டர்ன்கள்) செயல்படுத்த நேரம் எடுக்கலாம் (அவை பெரும்பாலும் வெவ்வேறு தரப்பினரிடமிருந்து ஒப்புதல் தேவைப்படும்), இது தாக்குபவர்களுக்கு அதிக சேதத்தை ஏற்படுத்த அதிக நேரத்தை மட்டுமே அளிக்கிறது.

அணுசக்தி விருப்பம் என்பது ஒரு ஒப்பந்தத்தில் உள்ள பாதிப்புக்குள்ளான செயல்பாடுகளுக்கான அழைப்புகளைத் தடுக்கும் “அவசர நிறுத்த” செயல்பாட்டைச் செயல்படுத்துவதாகும். அவசர நிறுத்தங்கள் பொதுவாக பின்வரும் கூறுகளைக் கொண்டிருக்கும்:

1. ஸ்மார்ட் ஒப்பந்தம் நிறுத்தப்பட்ட நிலையில் உள்ளதா இல்லையா என்பதைக் குறிக்கும் ஒரு உலகளாவிய பூலியன் மாறி. ஒப்பந்தத்தை அமைக்கும் போது இந்த மாறி `false` என அமைக்கப்படும், ஆனால் ஒப்பந்தம் நிறுத்தப்பட்டவுடன் `true` ஆக மாறும்.

2. பூலியன் மாறியை அவற்றின் செயல்பாட்டில் குறிப்பிடும் செயல்பாடுகள். ஸ்மார்ட் ஒப்பந்தம் நிறுத்தப்படாதபோது இத்தகைய செயல்பாடுகளை அணுக முடியும், மேலும் அவசர நிறுத்த அம்சம் தூண்டப்படும்போது அணுக முடியாததாகிவிடும்.

3. பூலியன் மாறியை `true` என அமைக்கும் அவசர நிறுத்தச் செயல்பாட்டிற்கான அணுகலைக் கொண்ட ஒரு நிறுவனம். தீங்கிழைக்கும் செயல்களைத் தடுக்க, இந்தச் செயல்பாட்டிற்கான அழைப்புகளை நம்பகமான முகவரிக்கு (எ.கா., ஒப்பந்த உரிமையாளர்) கட்டுப்படுத்தலாம்.

ஒப்பந்தம் அவசர நிறுத்தத்தை செயல்படுத்தியவுடன், சில செயல்பாடுகளை அழைக்க முடியாது. உலகளாவிய மாறியைக் குறிப்பிடும் ஒரு மாற்றியில் தேர்ந்தெடுக்கப்பட்ட செயல்பாடுகளை மூடுவதன் மூலம் இது அடையப்படுகிறது. ஒப்பந்தங்களில் இந்த பேட்டர்னின் செயல்பாட்டை விவரிக்கும் [ஒரு உதாரணம்](https://github.com/fravoll/solidity-patterns/blob/master/EmergencyStop/EmergencyStop.sol) கீழே உள்ளது:

```solidity
// இந்தக் குறியீடு தொழில்ரீதியாகத் தணிக்கை செய்யப்படவில்லை மற்றும் பாதுகாப்பு அல்லது சரியானது குறித்து எந்த வாக்குறுதியும் அளிக்கவில்லை. உங்கள் சொந்த ஆபத்தில் பயன்படுத்தவும்.

contract EmergencyStop {

    bool isStopped = false;

    modifier stoppedInEmergency {
        require(!isStopped);
        _;
    }

    modifier onlyWhenStopped {
        require(isStopped);
        _;
    }

    modifier onlyAuthorized {
        // msg.sender இன் அங்கீகாரத்தை இங்கே சரிபார்க்கவும்
        _;
    }

    function stopContract() public onlyAuthorized {
        isStopped = true;
    }

    function resumeContract() public onlyAuthorized {
        isStopped = false;
    }

    function deposit() public payable stoppedInEmergency {
        // வைப்புத் தர்க்கம் இங்கே நடக்கிறது
    }

    function emergencyWithdraw() public onlyWhenStopped {
        // அவசரக்காலப் பணம் எடுத்தல் இங்கே நடக்கிறது
    }
}
```

இந்த எடுத்துக்காட்டு அவசர நிறுத்தங்களின் அடிப்படை அம்சங்களைக் காட்டுகிறது:

- `isStopped` என்பது ஒரு பூலியன் ஆகும், இது தொடக்கத்தில் `false` ஆகவும், ஒப்பந்தம் அவசர பயன்முறைக்கு நுழையும்போது `true` ஆகவும் மதிப்பிடுகிறது.

- செயல்பாட்டு மாற்றிகள் `onlyWhenStopped` மற்றும் `stoppedInEmergency` `isStopped` மாறியைச் சரிபார்க்கின்றன. ஒப்பந்தம் பாதிப்புக்குள்ளாகும் போது அணுக முடியாத செயல்பாடுகளைக் கட்டுப்படுத்த `stoppedInEmergency` பயன்படுத்தப்படுகிறது (எ.கா., `deposit()`). இந்தச் செயல்பாடுகளுக்கான அழைப்புகள் வெறுமனே மாற்றியமைக்கப்படும்.

அவசரகாலத்தில் அழைக்கப்பட வேண்டிய செயல்பாடுகளுக்கு `onlyWhenStopped` பயன்படுத்தப்படுகிறது (எ.கா., `emergencyWithdraw()`). இத்தகைய செயல்பாடுகள் நிலைமையைத் தீர்க்க உதவும், எனவே அவை “கட்டுப்படுத்தப்பட்ட செயல்பாடுகள்” பட்டியலிலிருந்து விலக்கப்பட்டுள்ளன.

ஒரு அவசர நிறுத்தச் செயல்பாட்டைப் பயன்படுத்துவது உங்கள் ஸ்மார்ட் ஒப்பந்தத்தில் உள்ள தீவிர பாதிப்புகளைச் சமாளிக்க ஒரு பயனுள்ள நிறுத்தத்தை வழங்குகிறது. இருப்பினும், சுய-சேவை காரணங்களுக்காக அதைச் செயல்படுத்த வேண்டாம் என்று உருவாக்குநர்களை நம்புவதற்கான தேவையை இது பயனர்களுக்கு அதிகரிக்கிறது. இந்த முடிவுக்கு, அவசர நிறுத்தத்தின் கட்டுப்பாட்டை ஒரு ஆன்செயின் வாக்களிப்பு பொறிமுறை, டைம்லாக் அல்லது ஒரு மல்டிசிக் வாலட்டிலிருந்து ஒப்புதலுக்கு உட்படுத்துவதன் மூலம் பரவலாக்குவது சாத்தியமான தீர்வுகளாகும்.

#### நிகழ்வு கண்காணிப்பு {#event-monitoring}

[நிகழ்வுகள்](https://docs.soliditylang.org/en/v0.8.15/contracts.html#events) ஸ்மார்ட் ஒப்பந்தச் செயல்பாடுகளுக்கான அழைப்புகளைக் கண்காணிக்கவும் மற்றும் நிலை மாறிகளில் ஏற்படும் மாற்றங்களைக் கண்காணிக்கவும் உங்களை அனுமதிக்கின்றன. ஏதேனும் ஒரு தரப்பினர் பாதுகாப்பு-முக்கியமான நடவடிக்கையை எடுக்கும் போதெல்லாம் (எ.கா., நிதிகளைத் திரும்பப் பெறுதல்) ஒரு நிகழ்வை வெளியிடுவதற்கு உங்கள் ஸ்மார்ட் ஒப்பந்தத்தை நிரலாக்குவது சிறந்தது.

நிகழ்வுகளைப் பதிவுசெய்வதும், அவற்றை ஆஃப்செயினில் கண்காணிப்பதும் ஒப்பந்தச் செயல்பாடுகள் பற்றிய நுண்ணறிவுகளை வழங்குகிறது மற்றும் தீங்கிழைக்கும் செயல்களை விரைவாகக் கண்டறிய உதவுகிறது. இதன் பொருள், உங்கள் குழு ஹேக்குகளுக்கு விரைவாக பதிலளிக்க முடியும் மற்றும் செயல்பாடுகளை இடைநிறுத்துவது அல்லது மேம்படுத்துவது போன்ற பயனர்களின் மீதான தாக்கத்தைக் குறைக்க நடவடிக்கை எடுக்க முடியும்.

யாராவது உங்கள் ஒப்பந்தங்களுடன் தொடர்பு கொள்ளும்போதெல்லாம் தானாகவே விழிப்பூட்டல்களை அனுப்பும் ஒரு ஆஃப்-தி-ஷெல்ஃப் கண்காணிப்புக் கருவியையும் நீங்கள் தேர்வு செய்யலாம். பரிவர்த்தனை அளவு, செயல்பாட்டு அழைப்புகளின் அதிர்வெண் அல்லது சம்பந்தப்பட்ட குறிப்பிட்ட செயல்பாடுகள் போன்ற வெவ்வேறு தூண்டுதல்களின் அடிப்படையில் தனிப்பயன் விழிப்பூட்டல்களை உருவாக்க இந்தக் கருவிகள் உங்களை அனுமதிக்கும். உதாரணமாக, ஒரு பரிவர்த்தனையில் திரும்பப் பெறப்பட்ட தொகை ஒரு குறிப்பிட்ட வரம்பைத் தாண்டும்போது வரும் ஒரு விழிப்பூட்டலை நீங்கள் நிரல்படுத்தலாம்.

### 7. பாதுகாப்பான ஆளுகை அமைப்புகளை வடிவமைத்தல் {#design-secure-governance-systems}

முக்கிய ஸ்மார்ட் ஒப்பந்தங்களின் கட்டுப்பாட்டை சமூக உறுப்பினர்களிடம் ஒப்படைப்பதன் மூலம் உங்கள் விண்ணப்பத்தைப் பரவலாக்க நீங்கள் விரும்பலாம். இந்த வழக்கில், ஸ்மார்ட் ஒப்பந்த அமைப்பில் ஒரு ஆளுகை தொகுதி இருக்கும்—இது ஒரு ஆன்செயின் ஆளுகை அமைப்பு மூலம் நிர்வாக நடவடிக்கைகளை அங்கீகரிக்க சமூக உறுப்பினர்களை அனுமதிக்கும் ஒரு பொறிமுறையாகும். உதாரணமாக, டோக்கன் வைத்திருப்பவர்களால் ஒரு புதிய செயலாக்கத்திற்கு ஒரு ப்ராக்ஸி ஒப்பந்தத்தை மேம்படுத்துவதற்கான முன்மொழிவுக்கு வாக்களிக்கப்படலாம்.

பரவலாக்கப்பட்ட ஆளுகை நன்மை பயக்கும், குறிப்பாக இது உருவாக்குநர்கள் மற்றும் இறுதிப் பயனர்களின் நலன்களை சீரமைப்பதால். ஆயினும்கூட, ஸ்மார்ட் ஒப்பந்த ஆளுகை வழிமுறைகள் தவறாகச் செயல்படுத்தப்பட்டால் புதிய அபாயங்களை அறிமுகப்படுத்தலாம். ஒரு தாக்குபவர் [ஃபிளாஷ் கடனைப்](/defi/#flash-loans) பெற்று, தீங்கிழைக்கும் முன்மொழிவை முன்னெடுத்துச் செல்வதன் மூலம் மிகப்பெரிய வாக்களிப்பு சக்தியைப் (கையிருப்பில் உள்ள டோக்கன்களின் எண்ணிக்கையில் அளவிடப்படுகிறது) பெறுவது ஒரு நம்பத்தகுந்த சூழ்நிலையாகும்.

ஆன்செயின் ஆளுகை தொடர்பான சிக்கல்களைத் தடுப்பதற்கான ஒரு வழி [ஒரு டைம்லாக்கைப் பயன்படுத்துவது](https://blog.openzeppelin.com/protect-your-users-with-smart-contract-timelocks/). ஒரு குறிப்பிட்ட அளவு நேரம் கடக்கும் வரை ஒரு ஸ்மார்ட் ஒப்பந்தம் சில செயல்களைச் செய்வதைத் டைம்லாக் தடுக்கிறது. ஒவ்வொரு டோக்கனுக்கும் அது எவ்வளவு காலம் பூட்டப்பட்டிருக்கிறது என்பதன் அடிப்படையில் ஒரு “வாக்களிப்பு எடையை” ஒதுக்குவது, அல்லது தற்போதைய தொகுப்புக்குப் பதிலாக ஒரு வரலாற்று காலகட்டத்தில் (உதாரணமாக, கடந்த காலத்தில் 2-3 தொகுதிகள்) ஒரு முகவரியின் வாக்களிப்பு சக்தியை அளவிடுவது ஆகியவை பிற உத்திகள் ஆகும். இரண்டு முறைகளும் ஆன்செயின் வாக்குகளை மாற்றுவதற்காக வாக்களிப்பு சக்தியை விரைவாகக் குவிக்கும் வாய்ப்பைக் குறைக்கின்றன.

பகிரப்பட்ட இணைப்புகளில் [பாதுகாப்பான ஆளுகை அமைப்புகளை வடிவமைப்பது](https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/), [DAOக்களில் வெவ்வேறு வாக்களிப்பு வழிமுறைகள்](https://hackernoon.com/governance-is-the-holy-grail-for-daos), மற்றும் [DeFi ஐப் பயன்படுத்தும் பொதுவான DAO தாக்குதல் வெக்டர்கள்](https://dacian.me/dao-governance-defi-attacks) பற்றி மேலும் அறியலாம்.

### 8. குறியீட்டில் உள்ள சிக்கலை குறைந்தபட்சமாகக் குறைக்கவும் {#reduce-code-complexity}

பாரம்பரிய மென்பொருள் உருவாக்குநர்கள் KISS (“அதை எளிமையாக வைத்திரு, முட்டாளே”) கொள்கையை நன்கு அறிந்திருக்கிறார்கள், இது மென்பொருள் வடிவமைப்பில் தேவையற்ற சிக்கலை அறிமுகப்படுத்துவதற்கு எதிராக அறிவுறுத்துகிறது. இது “சிக்கலான அமைப்புகள் சிக்கலான வழிகளில் தோல்வியடைகின்றன” மற்றும் அதிக விலையுள்ள பிழைகளுக்கு ஆளாகின்றன என்ற நீண்டகால சிந்தனையைப் பின்பற்றுகிறது.

ஸ்மார்ட் ஒப்பந்தங்கள் அதிக அளவிலான மதிப்பைக் கட்டுப்படுத்தும் திறன் கொண்டவை என்பதால், ஸ்மார்ட் ஒப்பந்தங்களை எழுதும் போது விஷயங்களை எளிமையாக வைத்திருப்பது குறிப்பிட்ட முக்கியத்துவம் வாய்ந்தது. ஸ்மார்ட் ஒப்பந்தங்களை எழுதும் போது எளிமையை அடைவதற்கான ஒரு உதவிக்குறிப்பு, முடிந்தால், [OpenZeppelin ஒப்பந்தங்கள்](https://docs.openzeppelin.com/contracts/5.x/) போன்ற ஏற்கனவே உள்ள நூலகங்களை மீண்டும் பயன்படுத்துவதாகும். இந்த நூலகங்கள் உருவாக்குநர்களால் விரிவாகத் தணிக்கை செய்யப்பட்டு சோதிக்கப்பட்டிருப்பதால், அவற்றைப் பயன்படுத்துவது புதிதாகச் செயல்பாடுகளை எழுதுவதன் மூலம் பிழைகளை அறிமுகப்படுத்தும் வாய்ப்புகளைக் குறைக்கிறது.

மற்றொரு பொதுவான அறிவுரை சிறிய செயல்பாடுகளை எழுதுவதும், பல ஒப்பந்தங்களில் வணிக தர்க்கத்தைப் பிரிப்பதன் மூலம் ஒப்பந்தங்களை மாடுலராக வைத்திருப்பதும் ஆகும். எளிமையான குறியீட்டை எழுதுவது ஒரு ஸ்மார்ட் ஒப்பந்தத்தில் தாக்குதல் பரப்பைக் குறைப்பது மட்டுமல்லாமல், ஒட்டுமொத்த அமைப்பின் சரியானது பற்றி பகுத்தறிவு செய்வதையும், சாத்தியமான வடிவமைப்புப் பிழைகளை முன்கூட்டியே கண்டறிவதையும் எளிதாக்குகிறது.

### 9. பொதுவான ஸ்மார்ட் ஒப்பந்தப் பாதிப்புகளுக்கு எதிராகப் பாதுகாக்கவும் {#mitigate-common-smart-contract-vulnerabilities}

#### மறு நுழைவு {#reentrancy}

EVM ஒருமைப்பாட்டை அனுமதிக்காது, அதாவது ஒரு செய்தி அழைப்பில் ஈடுபட்டுள்ள இரண்டு ஒப்பந்தங்கள் ஒரே நேரத்தில் இயங்க முடியாது. ஒரு வெளிப்புற அழைப்பு அழைக்கும் ஒப்பந்தத்தின் செயல்பாட்டையும் நினைவகத்தையும் அழைப்பு திரும்பும் வரை இடைநிறுத்துகிறது, அந்த நேரத்தில் செயல்பாடு சாதாரணமாகத் தொடர்கிறது. இந்த செயல்முறையை மற்றொரு ஒப்பந்தத்திற்கு [கட்டுப்பாட்டு ஓட்டத்தை](https://www.computerhope.com/jargon/c/contflow.htm) மாற்றுவது என்று முறையாக விவரிக்கலாம்.

பெரும்பாலும் பாதிப்பில்லாததாக இருந்தாலும், நம்பத்தகாத ஒப்பந்தங்களுக்குக் கட்டுப்பாட்டு ஓட்டத்தை மாற்றுவது மறு நுழைவு போன்ற சிக்கல்களை ஏற்படுத்தும். அசல் செயல்பாட்டு அழைப்பு முடிவடைவதற்கு முன்பு, ஒரு தீங்கிழைக்கும் ஒப்பந்தம் பாதிக்கப்படக்கூடிய ஒப்பந்தத்திற்கு மீண்டும் அழைக்கும் போது மறு நுழைவுத் தாக்குதல் ஏற்படுகிறது. இந்த வகை தாக்குதல் ஒரு எடுத்துக்காட்டுடன் சிறப்பாக விளக்கப்படுகிறது.

யாரும் ஈதரை டெபாசிட் செய்யவும் திரும்பப் பெறவும் அனுமதிக்கும் ஒரு எளிய ஸ்மார்ட் ஒப்பந்தத்தைக் (‘பாதிக்கப்பட்டவர்’) கவனியுங்கள்:

```solidity
// இந்த ஒப்பந்தம் பாதிக்கப்படக்கூடியது. உற்பத்தியில் பயன்படுத்த வேண்டாம்

contract Victim {
    mapping (address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

இந்த ஒப்பந்தம், பயனர்கள் ஒப்பந்தத்தில் முன்பு டெபாசிட் செய்த ETH-ஐத் திரும்பப் பெற `withdraw()` செயல்பாட்டை வெளிப்படுத்துகிறது. திரும்பப் பெறுதலைச் செயலாக்கும் போது, ஒப்பந்தம் பின்வரும் செயல்பாடுகளைச் செய்கிறது:

1. பயனரின் ETH இருப்பைச் சரிபார்க்கிறது
2. அழைக்கும் முகவரிக்கு நிதியை அனுப்புகிறது
3. பயனரிடமிருந்து கூடுதல் திரும்பப் பெறுவதைத் தடுக்க, அவர்களின் இருப்பை 0 ஆக மீட்டமைக்கிறது

`Victim` ஒப்பந்தத்தில் உள்ள `withdraw()` செயல்பாடு “சோதனைகள்-செயல்பாடுகள்-விளைவுகள்” பேட்டர்னைப் பின்பற்றுகிறது. இது பரிவர்த்தனையின் _விளைவுகளை_ (அதாவது பயனரின் இருப்பைக் குறைத்தல்) பயன்படுத்துவதற்கு முன்பு, செயல்பாட்டிற்குத் தேவையான நிபந்தனைகள் பூர்த்தி செய்யப்படுகிறதா (அதாவது, பயனருக்கு நேர்மறையான ETH இருப்பு உள்ளது) என்பதைச் _சரிபார்த்து_, அழைப்பாளரின் முகவரிக்கு ETH ஐ அனுப்புவதன் மூலம் _தொடர்பு கொள்கிறது_.

`withdraw()` வெளிப்புறமாகச் சொந்தமான கணக்கிலிருந்து (EOA) அழைக்கப்பட்டால், செயல்பாடு எதிர்பார்த்தபடி செயல்படும்: `msg.sender.call.value()` ETH-ஐ அழைப்பாளருக்கு அனுப்புகிறது. இருப்பினும், `msg.sender` ஒரு ஸ்மார்ட் ஒப்பந்தக் கணக்காக இருந்து `withdraw()`ஐ அழைத்தால், `msg.sender.call.value()` ஐப் பயன்படுத்தி நிதியை அனுப்புவது அந்த முகவரியில் சேமிக்கப்பட்ட குறியீட்டை இயக்கவும் தூண்டும்.

ஒப்பந்த முகவரியில் பயன்படுத்தப்பட்ட குறியீடு இது என்று கற்பனை செய்து பாருங்கள்:

```solidity
 contract Attacker {
    function beginAttack() external payable {
        Victim(victim_address).deposit.value(1 ether)();
        Victim(victim_address).withdraw();
    }

    function() external payable {
        if (gasleft() > 40000) {
            Victim(victim_address).withdraw();
        }
    }
}
```

இந்த ஒப்பந்தம் மூன்று விஷயங்களைச் செய்ய வடிவமைக்கப்பட்டுள்ளது:

1. மற்றொரு கணக்கிலிருந்து (தாக்குபவரின் EOA ஆக இருக்கலாம்) ஒரு வைப்புத்தொகையை ஏற்கவும்
2. பாதிக்கப்பட்ட ஒப்பந்தத்தில் 1 ETH ஐ டெபாசிட் செய்யவும்
3. ஸ்மார்ட் ஒப்பந்தத்தில் சேமிக்கப்பட்ட 1 ETH-ஐத் திரும்பப் பெறவும்

இங்கே எதுவும் தவறில்லை, `msg.sender.call.value` இலிருந்து மீதமுள்ள எரிவாயு 40,000 க்கும் அதிகமாக இருந்தால், `Attacker` `Victim` இல் மீண்டும் `withdraw()` என்று அழைக்கும் மற்றொரு செயல்பாட்டைக் கொண்டிருப்பதைத் தவிர. இது `Attacker` க்கு `Victim` ஐ மீண்டும் உள்ளிட்டு, `withdraw` இன் முதல் அழைப்பு முடிவடைவதற்கு _முன்பு_ அதிக நிதியைத் திரும்பப் பெறும் திறனை அளிக்கிறது. சுழற்சி இதுபோல் தெரிகிறது:

```solidity
- Attacker's EOA 1 ETH உடன் `Attacker.beginAttack()` ஐ அழைக்கிறது
- `Attacker.beginAttack()` `Victim` இல் 1 ETH ஐ டெபாசிட் செய்கிறது
- `Attacker` `Victim` இல் `withdraw()` ஐ அழைக்கிறது
- `Victim` `Attacker` இன் இருப்பைச் சரிபார்க்கிறது (1 ETH)
- `Victim` `Attacker` க்கு 1 ETH ஐ அனுப்புகிறது (இது இயல்புநிலை செயல்பாட்டைத் தூண்டுகிறது)
- `Attacker` மீண்டும் `Victim.withdraw()` ஐ அழைக்கிறது (முதல் திரும்பப் பெறுதலில் இருந்து `Victim` `Attacker` இன் இருப்பைக் குறைக்கவில்லை என்பதை நினைவில் கொள்ளவும்)
- `Victim` `Attacker` இன் இருப்பைச் சரிபார்க்கிறது (இது இன்னும் 1 ETH ஆகும், ஏனெனில் இது முதல் அழைப்பின் விளைவுகளைப் பயன்படுத்தவில்லை)
- `Victim` `Attacker` க்கு 1 ETH ஐ அனுப்புகிறது (இது இயல்புநிலை செயல்பாட்டைத் தூண்டுகிறது மற்றும் `Attacker` `withdraw` செயல்பாட்டை மீண்டும் உள்ளிட அனுமதிக்கிறது)
- `Attacker` இன் எரிவாயு தீரும் வரை இந்த செயல்முறை மீண்டும் மீண்டும் நிகழ்கிறது, அந்த நேரத்தில் `msg.sender.call.value` கூடுதல் திரும்பப் பெறுதல்களைத் தூண்டாமல் திரும்புகிறது
- `Victim` இறுதியாக முதல் பரிவர்த்தனையின் (மற்றும் அடுத்தடுத்தவற்றின்) முடிவுகளை அதன் நிலைக்குப் பயன்படுத்துகிறது, எனவே `Attacker` இன் இருப்பு 0 ஆக அமைக்கப்படுகிறது
```

செயல்பாடு முடிவடையும் வரை அழைப்பவரின் இருப்பு 0 ஆக அமைக்கப்படாததால், அடுத்தடுத்த அழைப்புகள் வெற்றி பெறும் மற்றும் அழைப்பாளர் தங்கள் இருப்பை பலமுறை திரும்பப் பெற அனுமதிக்கும் என்பதே சுருக்கமாகும். [2016 DAO ஹேக்கில்](https://www.coindesk.com/learn/understanding-the-dao-attack) நடந்தது போல, இந்த வகையான தாக்குதல் ஒரு ஸ்மார்ட் ஒப்பந்தத்தின் நிதியை வெளியேற்றப் பயன்படுத்தப்படலாம். [மறு நுழைவு சுரண்டல்களின் பொதுப் பட்டியல்கள்](https://github.com/pcaversaccio/reentrancy-attacks) காட்டுவது போல், மறு நுழைவுத் தாக்குதல்கள் இன்றும் ஸ்மார்ட் ஒப்பந்தங்களுக்கு ஒரு முக்கியமான பிரச்சினையாக உள்ளன.

##### மறு நுழைவுத் தாக்குதல்களைத் தடுப்பது எப்படி

மறு நுழைவைக் கையாள்வதற்கான ஒரு அணுகுமுறை [சோதனைகள்-விளைவுகள்-தொடர்புகள் பேட்டர்னைப்](https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern) பின்பற்றுவதாகும். இந்த பேட்டர்ன், செயல்பாடுகளைச் செயல்படுத்தும் வரிசையை ஒழுங்குபடுத்துகிறது, இதில் செயல்பாட்டைத் தொடர்வதற்கு முன்பு தேவையான சோதனைகளைச் செய்யும் குறியீடு முதலில் வரும், அதைத் தொடர்ந்து ஒப்பந்த நிலையை மாற்றும் குறியீடு, மற்ற ஒப்பந்தங்கள் அல்லது EOAக்களுடன் தொடர்பு கொள்ளும் குறியீடு கடைசியாக வரும்.

சோதனைகள்-விளைவு-தொடர்பு பேட்டர்ன் கீழே காட்டப்பட்டுள்ள `Victim` ஒப்பந்தத்தின் திருத்தப்பட்ட பதிப்பில் பயன்படுத்தப்படுகிறது:

```solidity
contract NoLongerAVictim {
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
    }
}
```

இந்த ஒப்பந்தம் பயனரின் இருப்பைச் _சோதனை_ செய்கிறது, `withdraw()` செயல்பாட்டின் _விளைவுகளைப்_ பயன்படுத்துகிறது (பயனரின் இருப்பை 0 ஆக மீட்டமைப்பதன் மூலம்), மற்றும் _தொடர்பு_ கொள்ளத் தொடர்கிறது (பயனரின் முகவரிக்கு ETH ஐ அனுப்புகிறது). வெளிப்புற அழைப்புக்கு முன்பு ஒப்பந்தம் அதன் சேமிப்பகத்தை புதுப்பிப்பதை இது உறுதி செய்கிறது, இது முதல் தாக்குதலைச் சாத்தியமாக்கிய மறு நுழைவு நிலையை நீக்குகிறது. `Attacker` ஒப்பந்தம் இன்னும் `NoLongerAVictim` ஐ மீண்டும் அழைக்கலாம், ஆனால் `balances[msg.sender]` 0 ஆக அமைக்கப்பட்டிருப்பதால், கூடுதல் திரும்பப் பெறுதல்கள் ஒரு பிழையை ஏற்படுத்தும்.

மற்றொரு விருப்பம், ஒரு செயல்பாட்டு அழைப்பு முடியும் வரை ஒரு ஒப்பந்தத்தின் நிலையின் ஒரு பகுதியை பூட்டி வைக்கும் பரஸ்பர விலக்கு பூட்டைப் (பொதுவாக "மியூடெக்ஸ்" என விவரிக்கப்படுகிறது) பயன்படுத்துவதாகும். செயல்பாடு செயல்படுவதற்கு முன்பு `true` ஆக அமைக்கப்பட்டு, அழைப்பு முடிந்ததும் `false` ஆக மாறும் ஒரு பூலியன் மாறியைப் பயன்படுத்தி இது செயல்படுத்தப்படுகிறது. கீழே உள்ள எடுத்துக்காட்டில் காணப்படுவது போல், ஒரு மியூடெக்ஸைப் பயன்படுத்துவது அசல் அழைப்பு இன்னும் செயலாக்கப்படும்போது ஒரு செயல்பாட்டை மறுபிரவேச அழைப்புகளிலிருந்து பாதுகாக்கிறது, இது மறு நுழைவை திறம்பட நிறுத்துகிறது.

```solidity
pragma solidity ^0.7.0;

contract MutexPattern {
    bool locked = false;
    mapping(address => uint256) public balances;

    modifier noReentrancy() {
        require(!locked, "மறு நுழைவிலிருந்து தடுக்கப்பட்டது.");
        locked = true;
        _;
        locked = false;
    }
    // இந்த செயல்பாடு ஒரு மியூடெக்ஸால் பாதுகாக்கப்படுகிறது, எனவே `msg.sender.call` இலிருந்து வரும் மறு நுழைவு அழைப்புகள் மீண்டும் `திரும்பப் பெற` அழைக்க முடியாது.
    //  `திரும்பப் பெறும்` கூற்று `உண்மை` என மதிப்பிடுகிறது ஆனால் இன்னும் மாற்றியமைப்பில் `பூட்டப்பட்டது = தவறு` என்ற கூற்றை மதிப்பிடுகிறது
    function withdraw(uint _amount) public payable noReentrancy returns(bool) {
        require(balances[msg.sender] >= _amount, "திரும்பப் பெற இருப்பு இல்லை.");

        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success);

        return true;
    }
}
```

கணக்குகளுக்கு நிதியை அனுப்பும் "புஷ் பேமெண்ட்ஸ்" முறைக்கு பதிலாக, ஸ்மார்ட் ஒப்பந்தங்களிலிருந்து பயனர்கள் நிதியைத் திரும்பப் பெற வேண்டிய [புல் பேமெண்ட்ஸ்](https://docs.openzeppelin.com/contracts/5.x/api/security#PullPayment) முறையையும் நீங்கள் பயன்படுத்தலாம். இது அறியப்படாத முகவரிகளில் தற்செயலாகக் குறியீட்டைத் தூண்டும் வாய்ப்பை நீக்குகிறது (மேலும் சில சேவை மறுப்புத் தாக்குதல்களையும் தடுக்கலாம்).

#### முழு எண் அண்டர்ஃப்ளோஸ் மற்றும் ஓவர்ஃப்ளோஸ் {#integer-underflows-and-overflows}

ஒரு எண்கணிதச் செயல்பாட்டின் முடிவுகள் ஏற்றுக்கொள்ளக்கூடிய மதிப்புகளின் வரம்பிற்கு வெளியே விழும்போது, ஒரு முழு எண் ஓவர்ஃப்ளோ ஏற்படுகிறது, இதனால் அது மிகக் குறைந்த பிரதிநிதித்துவப்படுத்தக்கூடிய மதிப்புக்கு "ரோல் ஓவர்" ஆகிறது. உதாரணமாக, ஒரு `uint8` 2^8-1=255 வரையிலான மதிப்புகளை மட்டுமே சேமிக்க முடியும். `255` ஐ விட அதிகமான மதிப்புகளுக்கு வழிவகுக்கும் எண்கணித செயல்பாடுகள் ஓவர்ஃப்ளோ ஆகி, `uint` ஐ `0` ஆக மீட்டமைக்கும், இது ஒரு காரின் ஓடோமீட்டர் அதிகபட்ச மைலேஜை (999999) அடைந்தவுடன் 0 ஆக மீட்டமைப்பதைப் போன்றது.

முழு எண் அண்டர்ஃப்ளோஸ் இதே போன்ற காரணங்களுக்காக நிகழ்கிறது: ஒரு எண்கணித செயல்பாட்டின் முடிவுகள் ஏற்றுக்கொள்ளக்கூடிய வரம்பிற்குக் கீழே விழுகின்றன. நீங்கள் ஒரு `uint8` இல் `0` ஐக் குறைக்க முயன்றால், முடிவு வெறுமனே அதிகபட்ச பிரதிநிதித்துவப்படுத்தக்கூடிய மதிப்புக்கு (`255`) உருளும்.

முழு எண் ஓவர்ஃப்ளோக்கள் மற்றும் அண்டர்ஃப்ளோக்கள் இரண்டும் ஒரு ஒப்பந்தத்தின் நிலை மாறிகளில் எதிர்பாராத மாற்றங்களுக்கு வழிவகுக்கும் மற்றும் திட்டமிடப்படாத செயல்பாட்டிற்கு வழிவகுக்கும். ஒரு தாக்குபவர் செல்லாத செயல்பாட்டைச் செய்ய ஒரு ஸ்மார்ட் ஒப்பந்தத்தில் எண்கணித ஓவர்ஃப்ளோவை எவ்வாறு பயன்படுத்தலாம் என்பதைக் காட்டும் ஒரு எடுத்துக்காட்டு கீழே உள்ளது:

```
pragma solidity ^0.7.6;

// இந்த ஒப்பந்தம் ஒரு நேரப் பெட்டகமாக செயல்பட வடிவமைக்கப்பட்டுள்ளது.
// பயனர் இந்த ஒப்பந்தத்தில் டெபாசிட் செய்யலாம் ஆனால் குறைந்தது ஒரு வாரத்திற்கு திரும்பப் பெற முடியாது.
// பயனர் 1 வார காத்திருப்பு காலத்திற்கு அப்பால் காத்திருப்பு நேரத்தை நீட்டிக்கலாம்.

/*
1. டைம்லாக்கைப் பயன்படுத்தவும்
2. டைம்லாக் முகவரியுடன் தாக்குதலைப் பயன்படுத்தவும்
3. 1 ஈதரை அனுப்பி அட்டாக்.அட்டாக் என்று அழைக்கவும். நீங்கள் உடனடியாக உங்கள் ஈதரைத்
திரும்பப் பெற முடியும்.

என்ன நடந்தது?
தாக்குதல் டைம்லாக்.லாக்டைம் ஓவர்ஃப்ளோ ஆக காரணமாகியது மற்றும் 1 வார காத்திருப்பு காலத்திற்கு முன்பு
திரும்பப் பெற முடிந்தது.
*/

contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "போதிய நிதி இல்லை");
        require(block.timestamp > lockTime[msg.sender], "பூட்டு நேரம் காலாவதியாகவில்லை");

        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "ஈதரை அனுப்பத் தவறிவிட்டது");
    }
}

contract Attack {
    TimeLock timeLock;

    constructor(TimeLock _timeLock) {
        timeLock = TimeLock(_timeLock);
    }

    fallback() external payable {}

    function attack() public payable {
        timeLock.deposit{value: msg.value}();
        /*
        if t = தற்போதைய பூட்டு நேரம் என்றால், நாம் x + t = 2**256 = 0 என்று ஒரு x ஐக் கண்டுபிடிக்க வேண்டும்
        எனவே x = -t
        2**256 = வகை(uint).max + 1
        எனவே x = வகை(uint).max + 1 - t
        */
        timeLock.increaseLockTime(
            type(uint).max + 1 - timeLock.lockTime(address(this))
        );
        timeLock.withdraw();
    }
}
```

##### முழு எண் அண்டர்ஃப்ளோஸ் மற்றும் ஓவர்ஃப்ளோக்களைத் தடுப்பது எப்படி

பதிப்பு 0.8.0 முதல், Solidity தொகுப்பி முழு எண் அண்டர்ஃப்ளோஸ் மற்றும் ஓவர்ஃப்ளோக்களுக்கு வழிவகுக்கும் குறியீட்டை நிராகரிக்கிறது. இருப்பினும், குறைந்த தொகுப்பி பதிப்புடன் தொகுக்கப்பட்ட ஒப்பந்தங்கள் எண்கணித செயல்பாடுகளை உள்ளடக்கிய செயல்பாடுகளில் சோதனைகளைச் செய்ய வேண்டும் அல்லது அண்டர்ஃப்ளோ/ஓவர்ஃப்ளோவைச் சரிபார்க்கும் ஒரு நூலகத்தைப் (எ.கா., [SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math)) பயன்படுத்த வேண்டும்.

#### ஆரக்கிள் கையாளுதல் {#oracle-manipulation}

[ஆரக்கிள்கள்](/developers/docs/oracles/) ஆஃப்செயின் தகவலைப் பெற்று, ஸ்மார்ட் ஒப்பந்தங்கள் பயன்படுத்த ஆன்செயினில் அனுப்புகின்றன. ஆரக்கிள்களுடன், மூலதனச் சந்தைகள் போன்ற ஆஃப்செயின் அமைப்புகளுடன் இயங்கக்கூடிய ஸ்மார்ட் ஒப்பந்தங்களை நீங்கள் வடிவமைக்கலாம், இது அவற்றின் பயன்பாட்டை பெரிதும் விரிவுபடுத்துகிறது.

ஆனால் ஆரக்கிள் சிதைந்து, தவறான தகவலை ஆன்செயினில் அனுப்பினால், ஸ்மார்ட் ஒப்பந்தங்கள் தவறான உள்ளீடுகளின் அடிப்படையில் செயல்படும், இது சிக்கல்களை ஏற்படுத்தும். இது “ஆரக்கிள் சிக்கலின்” அடிப்படையாகும், இது ஒரு பிளாக்செயின் ஆரக்கிளிலிருந்து வரும் தகவல் துல்லியமானது, புதுப்பித்தப்பட்டது மற்றும் சரியான நேரத்தில் இருப்பதை உறுதி செய்யும் பணியைப் பற்றியது.

ஒரு சொத்தின் உடனடி விலையைப் பெற, பரவலாக்கப்பட்ட பரிமாற்றம் போன்ற ஒரு ஆன்செயின் ஆரக்கிளைப் பயன்படுத்துவது தொடர்பான பாதுகாப்புக் கவலையாகும். [பரவலாக்கப்பட்ட நிதி (DeFi)](/defi/) துறையில் கடன் வழங்கும் தளங்கள், ஒரு பயனர் எவ்வளவு கடன் வாங்க முடியும் என்பதைத் தீர்மானிக்க, அவர்களின் பிணையத்தின் மதிப்பைத் தீர்மானிக்க இதை அடிக்கடி செய்கின்றன.

DEX விலைகள் பெரும்பாலும் துல்லியமானவை, பெரும்பாலும் சந்தைகளில் சமநிலையை மீட்டெடுக்கும் நடுவர்களால். இருப்பினும், அவை கையாளுதலுக்குத் திறந்தவை, குறிப்பாக ஆன்செயின் ஆரக்கிள் வரலாற்று வர்த்தக முறைகளின் அடிப்படையில் சொத்து விலைகளைக் கணக்கிட்டால் (வழக்கமாக இதுவே நடக்கும்).

உதாரணமாக, ஒரு தாக்குபவர் உங்கள் கடன் ஒப்பந்தத்துடன் தொடர்பு கொள்வதற்கு முன்பு, ஒரு ஃபிளாஷ் கடனை எடுத்து ஒரு சொத்தின் உடனடி விலையை செயற்கையாக உயர்த்தலாம். சொத்தின் விலைக்காக DEX-ஐ வினவினால், இயல்பை விட அதிகமான மதிப்பு திரும்பும் (தாக்குபவரின் பெரிய “வாங்க ஆணை” சொத்தின் தேவையைத் திசைதிருப்புவதால்), இது அவர்கள் வாங்க வேண்டியதை விட அதிகமாகக் கடன் வாங்க அனுமதிக்கிறது. இத்தகைய "ஃபிளாஷ் கடன் தாக்குதல்கள்" DeFi பயன்பாடுகளில் விலை ஆரக்கிள்கள் மீதான சார்புநிலையைச் சுரண்டப் பயன்படுத்தப்பட்டுள்ளன, இது நெறிமுறைகளுக்கு மில்லியன் கணக்கான நிதியை இழக்கச் செய்துள்ளது.

##### ஆரக்கிள் கையாளுதலைத் தடுப்பது எப்படி

[ஆரக்கிள் கையாளுதலைத் தவிர்க்க](https://www.cyfrin.io/blog/price-oracle-manipultion-attacks-with-examples) குறைந்தபட்சத் தேவை, பல மூலங்களிலிருந்து தகவல்களை வினவும் ஒரு பரவலாக்கப்பட்ட ஆரக்கிள் நெட்வொர்க்கைப் பயன்படுத்துவதாகும், இது தோல்வியின் ஒற்றைப் புள்ளிகளைத் தவிர்க்கும். பெரும்பாலான சந்தர்ப்பங்களில், பரவலாக்கப்பட்ட ஆரக்கிள்கள் சரியான தகவலைப் புகாரளிக்க ஆரக்கிள் முனைகளை ஊக்குவிக்க உள்ளமைக்கப்பட்ட கிரிப்டோகனாமிக் ஊக்கத்தொகைகளைக் கொண்டுள்ளன, இது அவற்றை மையப்படுத்தப்பட்ட ஆரக்கிள்களை விடப் பாதுகாப்பானதாக ஆக்குகிறது.

சொத்து விலைகளுக்காக ஒரு ஆன்செயின் ஆரக்கிளை வினவ நீங்கள் திட்டமிட்டால், நேர-எடையிடப்பட்ட சராசரி விலை (TWAP) பொறிமுறையைச் செயல்படுத்தும் ஒன்றைப் பயன்படுத்துவதைக் கவனியுங்கள். ஒரு [TWAP ஆரக்கிள்](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) ஒரு சொத்தின் விலையை இரண்டு வெவ்வேறு நேரங்களில் (நீங்கள் மாற்றியமைக்கலாம்) வினவி, பெறப்பட்ட சராசரியின் அடிப்படையில் உடனடி விலையைக் கணக்கிடுகிறது. நீண்ட காலத்தைத் தேர்ந்தெடுப்பது உங்கள் நெறிமுறையைப் விலை கையாளுதலுக்கு எதிராகப் பாதுகாக்கிறது, ஏனெனில் சமீபத்தில் செயல்படுத்தப்பட்ட பெரிய ஆர்டர்கள் சொத்து விலைகளைப் பாதிக்காது.

## உருவாக்குநர்களுக்கான ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு வளங்கள் {#smart-contract-security-resources-for-developers}

### ஸ்மார்ட் ஒப்பந்தங்களை ஆய்வு செய்வதற்கும் குறியீடு சரியானது என்பதைச் சரிபார்ப்பதற்கும் கருவிகள் {#code-analysis-tools}

- **[சோதனைக் கருவிகள் மற்றும் நூலகங்கள்](/developers/docs/smart-contracts/testing/#testing-tools-and-libraries)** - _ஸ்மார்ட் ஒப்பந்தங்களில் யூனிட் சோதனைகள், நிலையான பகுப்பாய்வு மற்றும் மாறும் பகுப்பாய்வு ஆகியவற்றைச் செய்வதற்கான தொழில்-தரமான கருவிகள் மற்றும் நூலகங்களின் தொகுப்பு._

- **[முறையான சரிபார்ப்புக் கருவிகள்](/developers/docs/smart-contracts/formal-verification/#formal-verification-tools)** - _ஸ்மார்ட் ஒப்பந்தங்களில் செயல்பாட்டுச் சரியானது என்பதைச் சரிபார்ப்பதற்கும் மாறாநிலைகளைச் சரிபார்ப்பதற்கும் கருவிகள்._

- **[ஸ்மார்ட் ஒப்பந்தத் தணிக்கை சேவைகள்](/developers/docs/smart-contracts/testing/#smart-contract-auditing-services)** - _எத்தேரியம் மேம்பாட்டுத் திட்டங்களுக்கு ஸ்மார்ட் ஒப்பந்தத் தணிக்கை சேவைகளை வழங்கும் நிறுவனங்களின் பட்டியல்._

- **[பிழை சன்மான தளங்கள்](/developers/docs/smart-contracts/testing/#bug-bounty-platforms)** - _பிழை சன்மானங்களை ஒருங்கிணைப்பதற்கும் ஸ்மார்ட் ஒப்பந்தங்களில் முக்கியமான பாதிப்புகளைப் பொறுப்புடன் வெளிப்படுத்துவதற்கும் வெகுமதி அளிப்பதற்கான தளங்கள்._

- **[Fork Checker](https://forkchecker.hashex.org/)** - _ஒரு ஃபோர்க் செய்யப்பட்ட ஒப்பந்தம் தொடர்பான அனைத்து தகவல்களையும் சரிபார்க்க ஒரு இலவச ஆன்லைன் கருவி._

- **[ABI Encoder](https://abi.hashex.org/)** - _உங்கள் Solidity ஒப்பந்தச் செயல்பாடுகள் மற்றும் கட்டமைப்பாளர் வாதங்களை குறியாக்கம் செய்வதற்கான ஒரு இலவச ஆன்லைன் சேவை._

- **[Aderyn](https://github.com/Cyfrin/aderyn)** - _Solidity நிலையான பகுப்பாய்வி, சுருக்க தொடரியல் மரங்களை (AST) கடந்து சந்தேகத்திற்கிடமான பாதிப்புகளைக் கண்டறிந்து, எளிதில் நுகரக்கூடிய மார்க் டவுன் வடிவத்தில் சிக்கல்களை அச்சிடுகிறது._

### ஸ்மார்ட் ஒப்பந்தங்களைக் கண்காணிப்பதற்கான கருவிகள் {#smart-contract-monitoring-tools}

- **[Tenderly Real-Time Alerting](https://tenderly.co/monitoring)** - _உங்கள் ஸ்மார்ட் ஒப்பந்தங்கள் அல்லது பணப்பைகளில் அசாதாரணமான அல்லது எதிர்பாராத நிகழ்வுகள் நடக்கும்போது நிகழ்நேர அறிவிப்புகளைப் பெறுவதற்கான ஒரு கருவி._

### ஸ்மார்ட் ஒப்பந்தங்களின் பாதுகாப்பான நிர்வாகத்திற்கான கருவிகள் {#smart-contract-administration-tools}

- **[Safe](https://safe.global/)** - _எத்தேரியத்தில் இயங்கும் ஸ்மார்ட் ஒப்பந்த பணப்பை, ஒரு பரிவர்த்தனை நடைபெறுவதற்கு முன்பு குறைந்தபட்சம் ஒரு குறிப்பிட்ட எண்ணிக்கையிலான நபர்கள் ஒப்புதல் அளிக்க வேண்டும் (M-of-N)._

- **[OpenZeppelin ஒப்பந்தங்கள்](https://docs.openzeppelin.com/contracts/5.x/)** - _ஒப்பந்த உரிமம், மேம்படுத்தல்கள், அணுகல் கட்டுப்பாடுகள், ஆளுகை, இடைநிறுத்தம் மற்றும் பலவற்றை உள்ளடக்கிய நிர்வாக அம்சங்களைச் செயல்படுத்துவதற்கான ஒப்பந்த நூலகங்கள்._

### ஸ்மார்ட் ஒப்பந்தத் தணிக்கை சேவைகள் {#smart-contract-auditing-services}

- **[ConsenSys Diligence](https://diligence.consensys.io/)** - _ஸ்மார்ட் ஒப்பந்தத் தணிக்கை சேவை, பிளாக்செயின் சுற்றுச்சூழல் அமைப்பு முழுவதும் உள்ள திட்டங்களுக்கு அவற்றின் நெறிமுறைகள் வெளியீட்டிற்குத் தயாராக இருப்பதையும், பயனர்களைப் பாதுகாப்பதற்காக உருவாக்கப்பட்டிருப்பதையும் உறுதிப்படுத்த உதவுகிறது._

- **[CertiK](https://www.certik.com/)** - _ஸ்மார்ட் ஒப்பந்தங்கள் மற்றும் பிளாக்செயின் நெட்வொர்க்குகளில் அதிநவீன முறையான சரிபார்ப்புத் தொழில்நுட்பத்தைப் பயன்படுத்துவதில் முன்னோடியாக இருக்கும் பிளாக்செயின் பாதுகாப்பு நிறுவனம்._

- **[Trail of Bits](https://www.trailofbits.com/)** - _சைபர் பாதுகாப்பு நிறுவனம், இடரைக் குறைப்பதற்கும் குறியீட்டை வலுப்படுத்துவதற்கும் தாக்குபவர் மனநிலையுடன் பாதுகாப்பு ஆராய்ச்சியை இணைக்கிறது._

- **[PeckShield](https://peckshield.com/)** - _முழு பிளாக்செயின் சுற்றுச்சூழல் அமைப்பின் பாதுகாப்பு, தனியுரிமை மற்றும் பயன்பாட்டிற்கான தயாரிப்புகள் மற்றும் சேவைகளை வழங்கும் பிளாக்செயின் பாதுகாப்பு நிறுவனம்._

- **[QuantStamp](https://quantstamp.com/)** - _பாதுகாப்பு மற்றும் இடர் மதிப்பீட்டுச் சேவைகள் மூலம் பிளாக்செயின் தொழில்நுட்பத்தின் பிரதான தத்தெடுப்பை எளிதாக்கும் தணிக்கை சேவை._

- **[OpenZeppelin](https://www.openzeppelin.com/security-audits)** - _பரவலாக்கப்பட்ட அமைப்புகளுக்கு பாதுகாப்புத் தணிக்கைகளை வழங்கும் ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு நிறுவனம்._

- **[Runtime Verification](https://runtimeverification.com/)** - _ஸ்மார்ட் ஒப்பந்தங்களின் முறையான மாடலிங் மற்றும் சரிபார்ப்பில் நிபுணத்துவம் பெற்ற பாதுகாப்பு நிறுவனம்._

- **[Hacken](https://hacken.io)** - _Web3 சைபர் பாதுகாப்பு தணிக்கையாளர், பிளாக்செயின் பாதுகாப்பிற்கு 360-டிகிரி அணுகுமுறையைக் கொண்டு வருகிறார்._

- **[Nethermind](https://www.nethermind.io/smart-contract-audits)** - _Solidity மற்றும் Cairo தணிக்கை சேவைகள், எத்தேரியம் மற்றும் ஸ்டார்க்நெட்டில் ஸ்மார்ட் ஒப்பந்தங்களின் ஒருமைப்பாட்டையும் பயனர்களின் பாதுகாப்பையும் உறுதி செய்கின்றன._

- **[HashEx](https://hashex.org/)** - _HashEx பிளாக்செயின் மற்றும் ஸ்மார்ட் ஒப்பந்தத் தணிக்கையில் கவனம் செலுத்துகிறது, இது கிரிப்டோகரன்சிகளின் பாதுகாப்பை உறுதி செய்கிறது, ஸ்மார்ட் ஒப்பந்த மேம்பாடு, ஊடுருவல் சோதனை, பிளாக்செயின் ஆலோசனை போன்ற சேவைகளை வழங்குகிறது._

- **[Code4rena](https://code4rena.com/)** - _போட்டித் தணிக்கைத் தளம், ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு வல்லுநர்களை பாதிப்புகளைக் கண்டறியவும், web3 ஐ மிகவும் பாதுகாப்பானதாக மாற்றவும் ஊக்குவிக்கிறது._

- **[CodeHawks](https://codehawks.com/)** - _போட்டித் தணிக்கைத் தளம், பாதுகாப்பு ஆராய்ச்சியாளர்களுக்கான ஸ்மார்ட் ஒப்பந்தத் தணிக்கைப் போட்டிகளை நடத்துகிறது._

- **[Cyfrin](https://cyfrin.io)** - _Web3 பாதுகாப்பு சக்தி மையம், தயாரிப்புகள் மற்றும் ஸ்மார்ட் ஒப்பந்தத் தணிக்கை சேவைகள் மூலம் கிரிப்டோ பாதுகாப்பை வளர்க்கிறது._

- **[ImmuneBytes](https://immunebytes.com/smart-contract-audit/)** - _அனுபவம் வாய்ந்த தணிக்கையாளர்கள் மற்றும் சிறந்த கருவிகளின் குழு மூலம் பிளாக்செயின் அமைப்புகளுக்கு பாதுகாப்புத் தணிக்கைகளை வழங்கும் Web3 பாதுகாப்பு நிறுவனம்._

- **[Oxorio](https://oxor.io/)** - _கிரிப்டோ நிறுவனங்கள் மற்றும் DeFi திட்டங்களுக்கான EVM, Solidity, ZK, கிராஸ்-செயின் தொழில்நுட்பத்தில் நிபுணத்துவத்துடன் ஸ்மார்ட் ஒப்பந்தத் தணிக்கைகள் மற்றும் பிளாக்செயின் பாதுகாப்புச் சேவைகள்._

- **[Inference](https://inference.ag/)** - _பாதுகாப்புத் தணிக்கை நிறுவனம், EVM-அடிப்படையிலான பிளாக்செயின்களுக்கான ஸ்மார்ட் ஒப்பந்தத் தணிக்கையில் நிபுணத்துவம் பெற்றது. அதன் நிபுணர் தணிக்கையாளர்களுக்கு நன்றி, அவர்கள் சாத்தியமான சிக்கல்களைக் கண்டறிந்து, வரிசைப்படுத்துவதற்கு முன்பு அவற்றைச் சரிசெய்யச் செயல்படக்கூடிய தீர்வுகளைப் பரிந்துரைக்கின்றனர்.

### பிழை சன்மான தளங்கள் {#bug-bounty-platforms}

- **[Immunefi](https://immunefi.com/)** - _ஸ்மார்ட் ஒப்பந்தங்கள் மற்றும் DeFi திட்டங்களுக்கான பிழை சன்மானத் தளம், அங்கு பாதுகாப்பு ஆராய்ச்சியாளர்கள் குறியீட்டை மதிப்பாய்வு செய்கிறார்கள், பாதிப்புகளை வெளிப்படுத்துகிறார்கள், பணம் பெறுகிறார்கள், மற்றும் கிரிப்டோவை பாதுகாப்பானதாக மாற்றுகிறார்கள்._

- **[HackerOne](https://www.hackerone.com/)** - _வணிகங்களை ஊடுருவல் சோதனையாளர்கள் மற்றும் சைபர் பாதுகாப்பு ஆராய்ச்சியாளர்களுடன் இணைக்கும் பாதிப்பு ஒருங்கிணைப்பு மற்றும் பிழை சன்மானத் தளம்._

- **[HackenProof](https://hackenproof.com/)** - _கிரிப்டோ திட்டங்களுக்கான (DeFi, ஸ்மார்ட் ஒப்பந்தங்கள், பணப்பைகள், CEX மற்றும் பல) நிபுணர் பிழை சன்மானத் தளம், அங்கு பாதுகாப்பு வல்லுநர்கள் சோதனை சேவைகளை வழங்குகிறார்கள் மற்றும் ஆராய்ச்சியாளர்கள் தொடர்புடைய, சரிபார்க்கப்பட்ட பிழை அறிக்கைகளுக்குப் பணம் பெறுகிறார்கள்._

- **[Sherlock](https://www.sherlock.xyz/)** - _Web3 இல் ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பிற்கான காப்பீட்டாளர், தணிக்கையாளர்களுக்கான கொடுப்பனவுகள் ஸ்மார்ட் ஒப்பந்தங்கள் மூலம் நிர்வகிக்கப்படுகின்றன, இது தொடர்புடைய பிழைகள் நியாயமாகச் செலுத்தப்படுவதைப் பாதுகாக்கிறது._

- **[CodeHawks](https://www.codehawks.com/)** - _போட்டி பிழை சன்மான தளம், தணிக்கையாளர்கள் பாதுகாப்புப் போட்டிகள் மற்றும் சவால்களில் பங்கேற்கிறார்கள், மற்றும் (விரைவில்) தங்கள் சொந்த தனியார் தணிக்கைகளிலும்._

### அறியப்பட்ட ஸ்மார்ட் ஒப்பந்த பாதிப்புகள் மற்றும் சுரண்டல்களின் வெளியீடுகள் {#common-smart-contract-vulnerabilities-and-exploits}

- **[ConsenSys: ஸ்மார்ட் ஒப்பந்த அறியப்பட்ட தாக்குதல்கள்](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/)** - _மிகவும் குறிப்பிடத்தக்க ஒப்பந்தப் பாதிப்புகளின் தொடக்கநிலை-நட்பு விளக்கம், பெரும்பாலான சந்தர்ப்பங்களில் மாதிரி குறியீட்டுடன்._

- **[SWC Registry](https://swcregistry.io/)** - _எத்தேரியம் ஸ்மார்ட் ஒப்பந்தங்களுக்குப் பொருந்தும் பொதுவான பலவீனம் கணக்கெடுப்பு (CWE) உருப்படிகளின் தொகுக்கப்பட்ட பட்டியல்._

- **[Rekt](https://rekt.news/)** - _உயர்மட்ட கிரிப்டோ ஹேக்குகள் மற்றும் சுரண்டல்களின் வழக்கமாகப் புதுப்பிக்கப்பட்ட வெளியீடு, விரிவான பிந்தைய மரண அறிக்கைகளுடன்._

### ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பைக் கற்றுக்கொள்வதற்கான சவால்கள் {#challenges-for-learning-smart-contract-security}

- **[Awesome BlockSec CTF](https://github.com/blockthreat/blocksec-ctfs)** - _பிளாக்செயின் பாதுகாப்பு போர்வைகள், சவால்கள் மற்றும் [Capture The Flag](https://www.webopedia.com/definitions/ctf-event/amp/) போட்டிகள் மற்றும் தீர்வு எழுத்துக்களின் தொகுக்கப்பட்ட பட்டியல்._

- **[Damn Vulnerable DeFi](https://www.damnvulnerabledefi.xyz/)** - _DeFi ஸ்மார்ட் ஒப்பந்தங்களின் தாக்குதல் பாதுகாப்பைக் கற்றுக்கொள்வதற்கும், பிழை-வேட்டை மற்றும் பாதுகாப்புத் தணிக்கையில் திறன்களை வளர்ப்பதற்கும் போர்க்களம்._

- **[Ethernaut](https://ethernaut.openzeppelin.com/)** - _Web3/Solidity-அடிப்படையிலான போர்க்களம், ஒவ்வொரு நிலையும் 'ஹேக்' செய்யப்பட வேண்டிய ஒரு ஸ்மார்ட் ஒப்பந்தமாகும்._

- **[HackenProof x HackTheBox](https://app.hackthebox.com/tracks/HackenProof-Track)** - _ஸ்மார்ட் ஒப்பந்த ஹேக்கிங் சவால், ஒரு கற்பனை சாகசத்தில் அமைக்கப்பட்டது. சவாலை வெற்றிகரமாக முடிப்பது ஒரு தனியார் பிழை சன்மானத் திட்டத்திற்கான அணுகலையும் வழங்குகிறது.

### ஸ்மார்ட் ஒப்பந்தங்களைப் பாதுகாப்பதற்கான சிறந்த நடைமுறைகள் {#smart-contract-security-best-practices}

- **[ConsenSys: எத்தேரியம் ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு சிறந்த நடைமுறைகள்](https://consensys.github.io/smart-contract-best-practices/)** - _எத்தேரியம் ஸ்மார்ட் ஒப்பந்தங்களைப் பாதுகாப்பதற்கான வழிகாட்டுதல்களின் விரிவான பட்டியல்._

- **[Nascent: எளிய பாதுகாப்பு கருவித்தொகுப்பு](https://github.com/nascentxyz/simple-security-toolkit)** - _ஸ்மார்ட் ஒப்பந்த மேம்பாட்டிற்கான நடைமுறை பாதுகாப்பு-கவனம் செலுத்தும் வழிகாட்டிகள் மற்றும் சரிபார்ப்புப் பட்டியல்களின் தொகுப்பு._

- **[Solidity Patterns](https://fravoll.github.io/solidity-patterns/)** - _ஸ்மார்ட் ஒப்பந்த நிரலாக்க மொழி Solidity க்கான பாதுகாப்பான பேட்டர்ன்கள் மற்றும் சிறந்த நடைமுறைகளின் பயனுள்ள தொகுப்பு._

- **[Solidity Docs: பாதுகாப்புக் கருத்தாய்வுகள்](https://docs.soliditylang.org/en/v0.8.16/security-considerations.html)** - _Solidity உடன் பாதுகாப்பான ஸ்மார்ட் ஒப்பந்தங்களை எழுதுவதற்கான வழிகாட்டுதல்கள்._

- **[ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு சரிபார்ப்புத் தரம்](https://github.com/securing/SCSVS)** - _உருவாக்குநர்கள், கட்டிடக் கலைஞர்கள், பாதுகாப்பு மதிப்பாய்வாளர்கள் மற்றும் விற்பனையாளர்களுக்கான ஸ்மார்ட் ஒப்பந்தங்களின் பாதுகாப்பைத் தரப்படுத்துவதற்காக உருவாக்கப்பட்ட பதினான்கு-பகுதி சரிபார்ப்புப் பட்டியல்._

- **[ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு மற்றும் தணிக்கையைக் கற்றுக்கொள்ளுங்கள்](https://updraft.cyfrin.io/courses/security)** - _இறுதி ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு மற்றும் தணிக்கை பாடநெறி, தங்கள் பாதுகாப்பு சிறந்த நடைமுறைகளை மேம்படுத்த மற்றும் பாதுகாப்பு ஆராய்ச்சியாளர்களாக மாற விரும்பும் ஸ்மார்ட் ஒப்பந்த உருவாக்குநர்களுக்காக உருவாக்கப்பட்டது._

### ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு குறித்த பயிற்சிகள் {#tutorials-on-smart-contract-security}

- [பாதுகாப்பான ஸ்மார்ட் ஒப்பந்தங்களை எழுதுவது எப்படி](/developers/tutorials/secure-development-workflow/)

- [ஸ்மார்ட் ஒப்பந்தப் பிழைகளைக் கண்டறிய Slither ஐ எவ்வாறு பயன்படுத்துவது](/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/)

- [ஸ்மார்ட் ஒப்பந்தப் பிழைகளைக் கண்டறிய Manticore ஐ எவ்வாறு பயன்படுத்துவது](/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/)

- [ஸ்மார்ட் ஒப்பந்தப் பாதுகாப்பு வழிகாட்டுதல்கள்](/developers/tutorials/smart-contract-security-guidelines/)

- [உங்கள் டோக்கன் ஒப்பந்தத்தை தன்னிச்சையான டோக்கன்களுடன் பாதுகாப்பாக ஒருங்கிணைப்பது எப்படி](/developers/tutorials/token-integration-checklist/)

- [Cyfrin Updraft - ஸ்மார்ட் ஒப்பந்தங்கள் பாதுகாப்பு மற்றும் தணிக்கை முழு பாடநெறி](https://updraft.cyfrin.io/courses/security)
