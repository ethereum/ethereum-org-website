---
title: "ஆரக்கிள்ஸ்"
description: "ஆரக்கிள்கள் எத்தேரியம் ஸ்மார்ட் கான்ட்ராக்டுகளுக்கு நிஜ-உலக தரவுகளுக்கான அணுகலை வழங்குகின்றன, மேலும் இது பயனர்களுக்கு அதிக பயன்பாட்டு-வழக்குகளையும் மற்றும் அதிக மதிப்பையும் திறக்கிறது."
lang: ta
---

ஆரக்கிள்கள் என்பவை ஸ்மார்ட் கான்ட்ராக்டுகளுக்காக ஆஃப்செயின் தரவு மூலங்களை பிளாக்செயினுக்கு கிடைக்கச் செய்யும் தரவு ஊட்டங்களை உருவாக்கும் பயன்பாடுகள் ஆகும். இதுவே தேவையானது, ஏனெனில் எத்தியரியம் அடிப்படையிலான ஸ்மார்ட் கான்ட்ராக்டுகள் பிளாக்செயினில் சேமிக்கபட்ட தகவல்களை நேரடியாக அணுக முடியாது.

ஸ்மார்ட் கான்ட்ராக்டுகளுக்கு ஆஃப்செயின் தரவைப் பயன்படுத்தி செயல்படுத்தும் திறனை வழங்குவது, பரவலாக்கப்பட்ட பயன்பாடுகளின் பயன்பாட்டையும் மதிப்பையும் விரிவுபடுத்துகிறது. உதாரணமாக, ஆன்செயின் முன்கணிப்பு சந்தைகள், பயனர் கணிப்புகளைச் சரிபார்க்கப் பயன்படுத்தும் விளைவுகள் பற்றிய தகவல்களை வழங்க ஆரக்கிள்களை நம்பியுள்ளன. உதாரணமாக, அலீஸ் 20 ETH ஐ அடுத்த அமெரிக்கா. அதிபராக யாராக இருக்கும் என்பதைப் பற்றிய பேட்டிங் செய்கிறார். எனவே, முன்னறிவிப்பு சந்தை dapp ஆற்றல் முடிவுகளை உறுதிசெய்ய ஒராக்கிள் தேவைப்படும் மற்றும் அலீஸ் கட்டணத்திற்கு தகுதியுடையவளா என்பதை தீர்மானிக்க வேண்டும்.

## முன்னேற்றக் கட்டுரை {#prerequisites}

இந்தப் பக்கம் வாசகருக்கு [முனைகள்](/developers/docs/nodes-and-clients/), [ஒருமித்த கருத்து வழிமுறைகள்](/developers/docs/consensus-mechanisms/), மற்றும் [EVM](/developers/docs/evm/) உள்ளிட்ட எத்தேரியம் அடிப்படைகள் பற்றித் தெரிந்திருக்கும் என்று கருதுகிறது. நீங்கள் [ஸ்மார்ட் கான்ட்ராக்டுகள்](/developers/docs/smart-contracts/) மற்றும் [ஸ்மார்ட் கான்ட்ராக்ட் கட்டமைப்பு](/developers/docs/smart-contracts/anatomy/), குறிப்பாக [நிகழ்வுகள்](/glossary/#events) பற்றிய நல்ல புரிதலைக் கொண்டிருக்க வேண்டும்.

## பிளாக்செயின் ஒராக்கிள் என்ன? {#what-is-a-blockchain-oracle}

ஆரக்கிள்கள் என்பவை பிளாக்செயினில் இயங்கும் ஸ்மார்ட் கான்ட்ராக்டுகளுக்கு வெளிப்புறத் தகவல்களை (அதாவது, ஆஃப்செயினில் சேமிக்கப்பட்ட தகவல்) ஆதாரமாக்கி, சரிபார்த்து, அனுப்பும் பயன்பாடுகள் ஆகும். எத்தேரியத்தில் ஆஃப்செயின் தரவை "இழுத்து" ஒளிபரப்புவதைத் தவிர, ஆரக்கிள்கள் பிளாக்செயினிலிருந்து வெளிப்புற அமைப்புகளுக்கு தகவல்களைத் "தள்ளவும்" முடியும், எ.கா., ஒரு பயனர் எத்தேரியம் பரிவர்த்தனை மூலம் கட்டணம் அனுப்பியவுடன் ஸ்மார்ட் லாக்கைத் திறப்பது.

ஒரு ஆரக்கிள் இல்லாமல், ஒரு ஸ்மார்ட் கான்ட்ராக்ட் முழுவதுமாக ஆன்செயின் தரவுகளுக்கு மட்டுமே வரையறுக்கப்பட்டிருக்கும்.

ஒராக்கிள்கள் தகவலின் மூலத்தை (ஒன்று அல்லது பல மூலங்கள்), நம்பிக்கையிலான மாடல்களை (மையமாக்கப்பட்ட அல்லது மையமற்ற), மற்றும் அமைப்புக் கட்டமைப்பை (திறந்த-வாக்குறுதி, வெளியீட்டு-சாதாரணம், மற்றும் கோரிக்கை-பதில்) அடிப்படையாகக் கொண்டு மாறுபடுகின்றன. ஆன்செயின் கான்ட்ராக்டுகளின் பயன்பாட்டிற்காக வெளிப்புறத் தரவை மீட்டெடுக்கிறதா (உள்ளீட்டு ஆரக்கிள்கள்), பிளாக்செயினிலிருந்து ஆஃப்செயின் பயன்பாடுகளுக்குத் தகவல்களை அனுப்புகிறதா (வெளியீட்டு ஆரக்கிள்கள்), அல்லது ஆஃப்செயின் கணக்கீட்டுப் பணிகளைச் செய்கிறதா (கணக்கீட்டு ஆரக்கிள்கள்) என்பதைப் பொறுத்து ஆரக்கிள்களை நாம் வேறுபடுத்தலாம்.

## ஸ்மார்ட் கான்ட்ராக்ட்களுக்கு ஒராக்கிள்கள் தேவைப்படுகிறது எதற்கு? {#why-do-smart-contracts-need-oracles}

பல வெளியாளர் பிளாக்செயினில் குறிப்பிட்ட முகவரிகளில் இயங்கும் குறியீடாக ஸ்மார்ட் கான்ட்ராக்டுகள் என்பதைக் காண்கின்றனர். இருப்பினும், [ஸ்மார்ட் கான்ட்ராக்டுகளின் ஒரு பொதுவான பார்வை](/smart-contracts/) என்னவென்றால், அவை குறிப்பிட்ட நிபந்தனைகள் பூர்த்தி செய்யப்பட்டவுடன் தரப்பினருக்கு இடையேயான ஒப்பந்தங்களைச் செயல்படுத்தும் திறன் கொண்ட சுயமாக-இயங்கும் மென்பொருள் நிரல்களாகும் - எனவே தான் "ஸ்மார்ட் கான்ட்ராக்டுகள்" என்ற சொல் பயன்படுத்தப்படுகிறது.

ஆனால் ஸ்மார்ட் கான்ட்ராக்டுகள் மூலம் நபர்களிடையே ஒப்பந்தங்களை அமல்படுத்துவது எளிதாகவே இல்லை, ஏனெனில் எத்தியரியம் தீர்மானசாதித்தன்மை கொண்டது. ஒரு [தீர்மானகரமான அமைப்பு](https://en.wikipedia.org/wiki/Deterministic_algorithm) என்பது ஒரு ஆரம்ப நிலை மற்றும் ஒரு குறிப்பிட்ட உள்ளீடு கொடுக்கப்பட்டால் எப்போதும் ஒரே முடிவுகளை உருவாக்கும் ஒன்றாகும், அதாவது உள்ளீடுகளிலிருந்து வெளியீடுகளைக் கணக்கிடும் செயல்பாட்டில் எந்தவிதமான சீரற்ற தன்மையோ அல்லது மாறுபாடோ இல்லை.

தீர்மானகரமான செயல்பாட்டை அடைய, பிளாக்செயின்கள், பிளாக்செயினிலேயே சேமிக்கப்பட்ட தரவை _மட்டும்_ பயன்படுத்தி எளிய பைனரி (சரி/தவறு) கேள்விகளில் ஒருமித்த கருத்தை எட்டுவதற்கு முனைகளை கட்டுப்படுத்துகின்றன. இத்தகைய கேள்விகளின் சில எடுத்துக்காட்டுகள்:

- “அந்தக் கணக்கு உரிமையாளர் (ஒரு பொதுத் திறவுச்சீட்டை கொண்டு அடையாளம் காணப்படும்) இந்த இடைமுகம் மூலமாக அனுப்பிய கொடுப்பனவைக் கையெழுத்திட்டாரா?”
- “இந்தக் கணக்கில் அந்தக் கொடுப்பனவை அடைப்பதற்குரிய போதுமான நிதிகள் உள்ளனவா?”
- “இந்த இடைமுகம் இந்த ஸ்மார்ட் கான்ட்ராக்ட் கான்பிக்ஸின் சூழலில் செல்லுபடியானதா?” எனப் போன்றவை.

பிளாக்செயின்கள் வெளிப்புற மூலங்களிலிருந்து (அதாவது, நிஜ உலகிலிருந்து) தகவல்களைப் பெற்றால், தீர்மானகரமான தன்மையை அடைவது சாத்தியமற்றதாகிவிடும், இது பிளாக்செயினின் நிலையின் மாற்றங்களின் செல்லுபடியாகும் தன்மையில் முனைகள் உடன்படுவதைத் தடுக்கும். உதாரணமாக, ஒரு ஸ்மார்ட் கான்ட்ராக்ட் தற்போதைய ETH-USD மாற்றுக் குறியீட்டின் அடிப்படையில் ஒரு ஒப்பந்தத்தைச் செயல்படுத்தும் எனக் கூறலாம். இந்த அடிப்படையில் பல முறை மாற்றங்களை அடையக்கூடியது (API பழமையானதாக ஆகலாம் அல்லது கையாளப்படலாம்), அதனால் ஒரே ஸ்மார்ட் கான்ட்ராக்ட் குறியீட்டைப் பயன்படுத்தும் நொட்கள் வெவ்வேறு முடிவுகளைஅடையக்கூடும்.

பொது பிளாக்செயின்களில் எண்ணிக்கையற்ற நொட்கள் உலகம் முழுவதும் பரிமாற்றங்களைச் செயல்படுத்துகின்றன, தீர்மானசாதித்தன்மை மிகவும் முக்கியமாகும். மைய அதிகாரியாகக் காணப்படக்கூடிய ஆதாரமின்றி, ஒரே நிலையை அடைய நொட்களுக்கு ஒரே மாதிரியான பரிமாற்றங்களைச் செயல்படுத்த வேண்டும். நோடு A ஒரு ஸ்மார்ட் கான்ட்ராக்ட் குறியீட்டைச் செயல்படுத்தி "3" என்ற முடிவைக் பெறுவதை, நோடு B அதே பரிமாற்றத்தை இயக்கி "7" என்ற முடிவைப் பெறுவது ஒப்புதலுக்கு உடைமையாக்கும் மற்றும் எத்தியரியம்'s மையமற்ற கணிப்பொறி தளமாகும் மதிப்பை அழிக்கும்.

இந்தச் சூழ்நிலையை வெளி மூலங்களிலிருந்து தகவல்களைப் பெறுவதற்கான பிளாக்செயின்களை வடிவமைப்பதற்கான சிக்கலைக் காட்டுகிறது. இருப்பினும், ஆரக்கிள்கள் இந்தப் சிக்கலை ஆஃப்செயின் மூலங்களிலிருந்து தகவல்களை எடுத்து, ஸ்மார்ட் கான்ட்ராக்டுகள் நுகர்வதற்காக அதை பிளாக்செயினில் சேமிப்பதன் மூலம் தீர்க்கின்றன. ஆன்செயினில் சேமிக்கப்பட்ட தகவல்கள் மாற்ற முடியாதவை மற்றும் பொதுவில் கிடைப்பதால், எத்தேரியம் முனைகள் ஒருமித்த கருத்தை மீறாமல் நிலை மாற்றங்களைக் கணக்கிட, ஆரக்கிள் இறக்குமதி செய்த ஆஃப்செயின் தரவைப் பாதுகாப்பாகப் பயன்படுத்தலாம்.

இதைச் செய்ய, ஒரு ஆரக்கிள் பொதுவாக ஆன்செயினில் இயங்கும் ஒரு ஸ்மார்ட் கான்ட்ராக்ட் மற்றும் சில ஆஃப்செயின் கூறுகளால் ஆனது. ஆன்செயின் கான்ட்ராக்ட் மற்ற ஸ்மார்ட் கான்ட்ராக்டுகளிடமிருந்து தரவுக்கான கோரிக்கைகளைப் பெறுகிறது, அதை அது ஆஃப்செயின் கூறுக்கு (ஆரக்கிள் முனை என்று அழைக்கப்படுகிறது) அனுப்புகிறது. இந்த ஒராக்கிள் நொடி தரவுக் கோரிக்கைகளை (உதாரணமாக, செயல்திறன் மென்பொருள் தொடர்புகள் (APIs) பயன்படுத்தி) கேட்டு, கோரிய தரவுகளை ஸ்மார்ட் கான்ட்ராக்ட் சேமிப்பில் சேமிக்க பரிமாற்றங்களை அனுப்பலாம்.

அவர்களில், ஒரு பிளாக்செயின் ஒராக்கிள் பிளாக்செயின் மற்றும் வெளி சூழல் இடையே தகவல்களைக் குறைய செய்கிறது, இது "மெய்யியடா ஸ்மார்ட் கான்ட்ராக்டுகள்" உருவாக்குகிறது. ஒரு கலப்பின ஸ்மார்ட் கான்ட்ராக்ட் என்பது ஆன்செயின் கான்ட்ராக்ட் குறியீடு மற்றும் ஆஃப்செயின் உள்கட்டமைப்பு ஆகியவற்றின் கலவையின் அடிப்படையில் செயல்படும் ஒன்றாகும். மையமற்ற முன்னறிவிப்பு சந்தைகள் ஒரு சிறந்த உதாரணமாகும். மற்ற உதாரணங்களில், ஒரு கட்டமைப்புக் குறியீடு வரவேற்கப்படும், இது சில ஒராக்கிள்கள் சில வானிலை நிகழ்வுகள் நிகழ்ந்தவாறு தீர்மானிக்கும்போது திரும்பக் கொடுக்கப்படும்.

## ஒராக்கிள் சிக்கல் என்ன? {#the-oracle-problem}

ஒராக்கிள்கள் ஒரு முக்கியமான சிக்கலைத் தீர்க்கும், ஆனால் சில சிக்கல்களை உருவாக்குகின்றன, உதாரணமாக.,:

- அடிப்படையிலான தகவல் சரியான மூலத்திலிருந்து பெறப்பட்டதாகவும் அல்லது மாறுபாடுகளுக்கு ஆளாகவில்லையா என்பதை எவ்வாறு உறுதி செய்வது?

- தரவு எப்போதும் கிடைக்குமாறு மற்றும் முறையாகப் புதுப்பிக்கப்படும் என்பதற்கு எவ்வாறு உறுதி செய்வது?

"ஒராக்கிள் சிக்கல்" என்பது பிளாக்செயின் ஒராக்கிள்கள் ஸ்மார்ட் கான்ட்ராக்டுகள் க்கு உள்ளீடுகளை அனுப்பும்போது வரவேற்கப்படும் சிக்கல்களை எடுத்துக்காட்டுகிறது. ஒரு ஸ்மார்ட் கான்ட்ராக்ட் முறையாகச் செயல்பட ஒராக்கிள் தரவு சரியானதாக இருக்க வேண்டும். மேலும், ஒராக்கிள் இயக்குநர்களுக்குச் சரியான தகவல்களை வழங்க நம்பிக்கை தேவைப்படுவதால் ஸ்மார்ட் கான்ட்ராக்டுகள் இன் 'நம்பிக்கையற்ற' அம்சம் குறைகிறது.

வித்தியாசமான ஒராக்கிள்கள் ஒராக்கிள் சிக்கல் க்கு மாறுபட்ட தீர்வுகளை வழங்குகின்றன, இதை நாம் பின்னர் ஆராய்வோம். ஒராக்கிள்கள் பொதுவாக இந்தச் சவால்களை எவ்வாறு கையாள்வது என்பதை அடிப்படையிலான மதிப்பீடு செய்யப்படுகிறது:

1. **சரியான தன்மை**: ஒரு ஆரக்கிள் தவறான ஆஃப்செயின் தரவின் அடிப்படையில் நிலை மாற்றங்களைத் தூண்டுவதற்கு ஸ்மார்ட் கான்ட்ராக்டுகளைக் காரணமாகக் கொண்டிருக்கக்கூடாது. ஒரு ஆரக்கிள் தரவின் _ நம்பகத்தன்மை_ மற்றும் _ஒருமைப்பாட்டிற்கு_ உத்தரவாதம் அளிக்க வேண்டும். நம்பகத்தன்மை என்பது தரவு சரியான மூலத்திலிருந்து பெறப்பட்டது என்பதாகும், அதே நேரத்தில் ஒருமைப்பாடு என்பது தரவு ஆன்செயினுக்கு அனுப்பப்படுவதற்கு முன்பு அப்படியே இருந்தது (அதாவது, மாற்றப்படவில்லை) என்பதாகும்.

2. **கிடைக்கும் தன்மை**: ஒரு ஆரக்கிள் ஸ்மார்ட் கான்ட்ராக்டுகள் செயல்களைச் செயல்படுத்துவதையும் நிலை மாற்றங்களைத் தூண்டுவதையும் தாமதப்படுத்தவோ அல்லது தடுக்கவோ கூடாது. இதன் பொருள் ஒரு ஆரக்கிளிலிருந்து வரும் தரவு, தடையின்றி _கோரிக்கையின் பேரில் கிடைக்க வேண்டும்_.

3. **ஊக்கத்தொகை இணக்கத்தன்மை**: ஒரு ஆரக்கிள், ஆஃப்செயின் தரவு வழங்குநர்களை ஸ்மார்ட் கான்ட்ராக்டுகளுக்கு சரியான தகவலைச் சமர்ப்பிக்க ஊக்குவிக்க வேண்டும். ஊக்கத்தொகை இணக்கத்தன்மை என்பது _பண்புக்கூறு_ மற்றும் _பொறுப்புக்கூறல்_ ஆகியவற்றை உள்ளடக்கியது. அடையாளக் என்பதாவது வெளிப்புற தகவல்களை அதன் வழங்குநருடன் இணைக்க அனுமதிக்கின்றது, மேலும் பதில் தரவுகளை வழங்குநர்களை வழங்கிய தகவலின் அடிப்படையில் விருது வழங்க அல்லது தண்டிக்க முடியும்.

## ஒரு பிளாக்செயின் ஒராக்கிள் சேவை எவ்வாறு செயல்படுகிறது? {#how-does-a-blockchain-oracle-service-work}

### பயனர்கள் {#users}

பயனர்கள் என்பது பிளாக்செயினுக்கு வெளிப்புற தகவல்களைத் தேவைப்படும் என்டிட்டிகள் (எ.கா., ஸ்மார்ட் கான்ட்ராக்டுகள்) ஆகும், குறிப்பிட்ட நடவடிக்கைகளை நிறைவேற்ற. ஒரு ஒராக்கிள் சேவையின் அடிப்படை பணியியல் பயனர் ஒரு தரவுக் கேட்டு ஒராக்கிள் கான்ட்ராக்டுக்கு அனுப்புவதுடன் தொடங்குகிறது. தரவுக் கேட்கல்கள் பொதுவாகப் பின்வரும் சில அல்லது அனைத்து கேள்விகளுக்கும் பதிலளிக்க வேண்டும்:

1. கோரப்பட்ட தகவலுக்காக ஆஃப்செயின் முனைகள் என்னென்ன ஆதாரங்களைக் கலந்தாலோசிக்கலாம்?

2. அறிக்கையாளர் தரவுக் மூலங்களிலிருந்து தகவல்களை எவ்வாறு செயலாக்குகிறார்கள் மற்றும் பயனுள்ள தரவுப் புள்ளிகளை எவ்வாறு அகற்றுகிறார்கள்?

3. ஒராக்கிள் நொடுகள் எத்தனை தொகுப்புகளைத் தகவல்களைப் பெறுவதில் பங்கேற்க முடியும்?

4. ஒராக்கிள் அறிக்கைகளில் முரண்பாடுகள் எவ்வாறு மேலாண்மை செய்யப்பட வேண்டும்?

5. சமர்ப்பிப்புகளை வடிகட்டுவதற்கும் மற்றும் அறிக்கைகளை ஒற்றை மதிப்பாக ஒருங்கிணைப்பதற்கான முறை எது அமலாக்கப்பட வேண்டும்?

### ஆரக்கிள் கான்ட்ராக்ட் {#oracle-contract}

ஆரக்கிள் கான்ட்ராக்ட் என்பது ஆரக்கிள் சேவைக்கான ஆன்செயின் கூறு ஆகும். இது மற்ற கான்ட்ராக்டுகளிடமிருந்து தரவுக் கேட்கல்கள் கேட்க, ஒராக்கிள் நொடுகளுக்கு தரவுக் கேட்கல்களை மாற்றி அனுப்ப மற்றும் வாடிக்கையாளர் கான்ட்ராக்டுகளுக்கு திருப்பிய தரவுகளைப் பரப்புகிறது. இந்தக் கான்ட்ராக்ட்், திரும்பப்பெற்ற தரவுப் புள்ளிகளில் சில கணக்கீடுகளைச் செய்யவும், கேட்டுக் கொண்டட கான்ட்ராக்டுக்கு அனுப்பப்படுவதாக உள்ள மொத்த மதிப்பை உருவாக்கவும் செய்யலாம்.

ஒராக்கிள் கான்ட்ராக்ட் சில செயல்பாடுகளை வெளிப்படுத்துகிறது, எங்கு வாடிக்கையாளர் கான்ட்ராக்டுகள் தரவுக் கேட்டுச் செய்யும்போது அழைக்கப்படும். ஒரு புதிய வினவலைப் பெற்றவுடன், ஸ்மார்ட் கான்ட்ராக்ட் தரவுக் கோரிக்கையின் விவரங்களுடன் ஒரு [பதிவு நிகழ்வை](/developers/docs/smart-contracts/anatomy/#events-and-logs) வெளியிடும். இது பதிவில் குழுசேர்ந்துள்ள ஆஃப்செயின் முனைகளுக்கு (பொதுவாக JSON-RPC `eth_subscribe` கட்டளை போன்ற ஒன்றைப் பயன்படுத்தி) அறிவிக்கிறது, பின்னர் அவை பதிவு நிகழ்வில் வரையறுக்கப்பட்ட தரவை மீட்டெடுக்கத் தொடங்கும்.

கீழே பெட்ரோ கோஸ்டாவின் ஒரு [எடுத்துக்காட்டு ஆரக்கிள் கான்ட்ராக்ட்](https://medium.com/@pedrodc/implementing-a-blockchain-oracle-on-ethereum-cedc7e26b49e) உள்ளது. இது ஒரு எளிய ஆரக்கிள் சேவையாகும், இது மற்ற ஸ்மார்ட் கான்ட்ராக்டுகளின் கோரிக்கையின் பேரில் ஆஃப்செயின் API-களை வினவ முடியும் மற்றும் கோரப்பட்ட தகவலை பிளாக்செயினில் சேமிக்க முடியும்:

```solidity
pragma solidity >=0.4.21 <0.6.0;

contract Oracle {
  Request[] requests; //கான்ட்ராக்ட்டுக்கு செய்யப்பட்ட கோரிக்கைகளின் பட்டியல்
  uint currentId = 0; //அதிகரிக்கும் கோரிக்கை ஐடி
  uint minQuorum = 2; //இறுதி முடிவை அறிவிக்கும் முன் பெற வேண்டிய பதில்களின் குறைந்தபட்ச எண்ணிக்கை
  uint totalOracleCount = 3; //ஹார்ட்கோட் செய்யப்பட்ட ஆரக்கிள் எண்ணிக்கை

  // ஒரு பொதுவான API கோரிக்கையை வரையறுக்கிறது
  struct Request {
    uint id;                            //கோரிக்கை ஐடி
    string urlToQuery;                  //API url
    string attributeToFetch;            //பதிலில் மீட்டெடுக்க வேண்டிய json பண்புக்கூறு (விசை)
    string agreedValue;                 //விசையிலிருந்து மதிப்பு
    mapping(uint => string) answers;     //ஆரக்கிள்களால் வழங்கப்பட்ட பதில்கள்
    mapping(address => uint) quorum;    //பதிலை வினவும் ஆரக்கிள்கள் (1=ஆரக்கிள் வாக்களிக்கவில்லை, 2=ஆரக்கிள் வாக்களித்துள்ளது)
  }

  //பிளாக்செயினுக்கு வெளியே ஆரக்கிளைத் தூண்டும் நிகழ்வு
  event NewRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch
  );

  //இறுதி முடிவில் ஒருமித்த கருத்து இருக்கும்போது தூண்டப்படுகிறது
  event UpdatedRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch,
    string agreedValue
  );

  function createRequest (
    string memory _urlToQuery,
    string memory _attributeToFetch
  )
  public
  {
    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, ""));
    Request storage r = requests[length-1];

    // ஹார்ட்கோட் செய்யப்பட்ட ஆரக்கிள்களின் முகவரி
    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;
    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;
    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;

    // பிளாக்செயினுக்கு வெளியே ஆரக்கிளால் கண்டறியப்பட ஒரு நிகழ்வைத் தொடங்கவும்
    emit NewRequest (
      currentId,
      _urlToQuery,
      _attributeToFetch
    );

    // கோரிக்கை ஐடியை அதிகரிக்கவும்
    currentId++;
  }

  //அதன் பதிலைப் பதிவு செய்ய ஆரக்கிளால் அழைக்கப்பட்டது
  function updateRequest (
    uint _id,
    string memory _valueRetrieved
  ) public {

    Request storage currRequest = requests[_id];

    //நம்பகமான ஆரக்கிள்களின் பட்டியலில் ஆரக்கிள் உள்ளதா எனச் சரிபார்க்கவும்
    //மற்றும் ஆரக்கிள் இன்னும் வாக்களிக்கவில்லை என்றால்
    if(currRequest.quorum[address(msg.sender)] == 1){

      //இந்த முகவரி வாக்களித்துள்ளது என்று குறிப்பிடுகிறது
      currRequest.quorum[msg.sender] = 2;

      //ஒரு இடம் காலியாக இருக்கும் வரை பதில்களின் "வரிசை" வழியாகச் சென்று மீட்டெடுக்கப்பட்ட மதிப்பைச் சேமிக்கவும்
      uint tmpI = 0;
      bool found = false;
      while(!found) {
        //முதல் காலி இடத்தைக் கண்டறியவும்
        if(bytes(currRequest.answers[tmpI]).length == 0){
          found = true;
          currRequest.answers[tmpI] = _valueRetrieved;
        }
        tmpI++;
      }

      uint currentQuorum = 0;

      //ஆரக்கிள் பட்டியல் வழியாகச் சென்று போதுமான ஆரக்கிள்கள் (குறைந்தபட்ச கோரம்) உள்ளதா எனச் சரிபார்க்கவும்
      //தற்போதைய பதிலையே வாக்களித்துள்ளனர்
      for(uint i = 0; i < totalOracleCount; i++){
        bytes memory a = bytes(currRequest.answers[i]);
        bytes memory b = bytes(_valueRetrieved);

        if(keccak256(a) == keccak256(b)){
          currentQuorum++;
          if(currentQuorum >= minQuorum){
            currRequest.agreedValue = _valueRetrieved;
            emit UpdatedRequest (
              currRequest.id,
              currRequest.urlToQuery,
              currRequest.attributeToFetch,
              currRequest.agreedValue
            );
          }
        }
      }
    }
  }
}
```

### ஆரக்கிள் முனைகள் {#oracle-nodes}

ஆரக்கிள் முனை என்பது ஆரக்கிள் சேவையின் ஆஃப்செயின் கூறு ஆகும். இது மூன்றாம் தரப்பு சேவையகங்களில் ஹோஸ்ட் செய்யப்பட்ட APIகள் போன்ற வெளிப்புற மூலங்களிலிருந்து தகவல்களைப் பிரித்தெடுத்து, ஸ்மார்ட் கான்ட்ராக்டுகளின் நுகர்வுக்காக ஆன்செயினில் வைக்கிறது. ஆரக்கிள் முனைகள் ஆன்செயின் ஆரக்கிள் கான்ட்ராக்டிலிருந்து வரும் நிகழ்வுகளைக் கேட்டு, பதிவில் விவரிக்கப்பட்டுள்ள பணியை முடிக்கத் தொடங்கும்.

ஆரக்கிள் முனைகளுக்கான ஒரு பொதுவான பணி என்னவென்றால், ஒரு API சேவைக்கு [HTTP GET](https://www.w3schools.com/tags/ref_httpmethods.asp) கோரிக்கையை அனுப்புவது, தொடர்புடைய தரவைப் பிரித்தெடுக்க பதிலை பாகுபடுத்துவது, அதை பிளாக்செயின்-படிக்கக்கூடிய வெளியீடாக வடிவமைப்பது, மற்றும் ஆரக்கிள் கான்ட்ராக்ட்டுக்கான ஒரு பரிவர்த்தனையில் அதைச் சேர்ப்பதன் மூலம் ஆன்செயினுக்கு அனுப்புவது ஆகும். ஒராக்கிள் நொடுகள் சமர்ப்பிக்கப்பட்ட தகவலின் சரியானது மற்றும் அசலானது என்பதை உறுதிப்படுத்தும் “அசலைத்தன்மை சான்றிதழ்கள்” வழங்க வேண்டியதையும், இதைப் பின்னர் ஆராயப் போகிறோம்.

கேஸ் செலவுகள் மற்றும் பிளாக் அளவு வரம்புகளைக் கருத்தில் கொண்டு, ஆன்செயினில் செயல்படுத்துவதற்கு நடைமுறைக்கு மாறான கணக்கீட்டுப் பணிகளைச் செய்ய, கணக்கீட்டு ஆரக்கிள்கள் ஆஃப்செயின் முனைகளை நம்பியுள்ளன. எடுத்துக்காட்டாக, ஒராக்கிள் நொடியுடன் உறுதிப்படுத்தக்கூடிய சீரான எண் (எ.கா., பிளாக்செயின் அடிப்படையிலான விளையாட்டுகளுக்கு) உருவாக்க வேண்டியதாக இருக்கலாம்.

## ஆரக்கிள் வடிவமைப்பு முறைகள் {#oracle-design-patterns}

ஆரக்கிள்கள் _உடனடி-வாசிப்பு_, _வெளியீடு-சந்தா_, மற்றும் _கோரிக்கை-பதில்_ உள்ளிட்ட பல்வேறு வகைகளில் வருகின்றன, பிந்தைய இரண்டும் எத்தேரியம் ஸ்மார்ட் கான்ட்ராக்டுகளில் மிகவும் பிரபலமானவை. இங்கு பதிப்பிப்பு-சப்ஸ்கிரைப் செய்யும் முறை மற்றும் கோரிக்கைகள்-பதில்கள் முறை மாடல்களைச் சுருக்கமாக விளக்குகிறோம்.

### வெளியீடு-சந்தா ஆரக்கிள்கள் {#publish-subscribe-oracles}

இப்பகுதி ஒராக்கிள்கள் ஒரு "தரவுப் பதிவேட்டை" வெளியிடுகின்றன, இதனைப் பிற கான்ட்ராக்டுகள் தன்னிச்சையாகப் படிக்க முடியும். இந்தக் கதவுகள் மிகுந்த மாறுதல்களை எதிர்பார்க்கின்றன, எனவே வாடிக்கையாளர் கான்ட்ராக்டுகள் ஒராக்கிளின் சேமிப்பு தரவின் புதுப்பிப்புகளை கேட்க வேண்டும். ஒரு உதாரணம் என்பது, ETH-USD விலைத் தகவல்களை வழங்கும் ஒராக்கிள் ஆகும்.

### கோரிக்கை-பதில் ஆரக்கிள்கள் {#request-response-oracles}

கோரிக்கைகள்-பதில்கள் அமைப்பு வாடிக்கையாளர் கான்ட்ராக்டுக்கு பதிப்பிப்பு-சப்ஸ்கிரைப் செய்யும் ஒராக்கிளால் வழங்கப்படும் தரவிற்கு மாற்றாக, எளிய தகவலைக் கேட்க அனுமதிக்கிறது. கோரிக்கைகள்-பதில்கள் ஒராக்கிள்கள் ஒரு ஸ்மார்ட் கான்ட்ராக்டின் சேமிப்பில் சிக்கலான தரவுத்தொகுப்புகளை சேமிக்க இயலாத நேரங்களில் மற்றும் பயனர்கள் ஒரு குறிப்பிட்ட நேரத்தில் மட்டும் ஒரு சிறிய தரவுத்தொகுப்புகளை தேவைப்படும்போது பயனமாக இருக்கும்.

பதிப்பிப்பு-சப்ஸ்கிரைப் செய்யும் மாடல்களைவிட அதிக சிக்கலானவை என்றாலும், கோரிக்கைகள்-பதில்கள் ஒராக்கிள்கள் பொதுவாக முந்தைய பகுதியில் விவரிக்கப்பட்டவை போன்றே. ஆரக்கிள் ஒரு ஆன்செயின் கூறுகளைக் கொண்டிருக்கும், அது ஒரு தரவுக் கோரிக்கையைப் பெற்று, செயலாக்கத்திற்காக அதை ஒரு ஆஃப்செயின் முனைக்கு அனுப்பும்.

தரவு வினவல்களைத் தொடங்கும் பயனர்கள் ஆஃப்செயின் மூலத்திலிருந்து தகவலை மீட்டெடுப்பதற்கான செலவை ஏற்க வேண்டும். தரவுக் கோரிக்கைகளை தொடங்கும் பயனர்கள் ஆஃப்-செயின் மூலத்திலிருந்து தகவல்களை எடுத்துக்கொள்வதற்கான செலவுகளை மூட வேண்டும்.

## மையப்படுத்தப்பட்ட மற்றும் பரவலாக்கப்பட்ட ஆரக்கிள்கள் {#types-of-oracles}

### மையப்படுத்தப்பட்ட ஆரக்கிள்கள் {#centralized-oracles}

ஒரு மையப்படுத்தப்பட்ட ஆரக்கிள் என்பது ஒரு ஒற்றை நிறுவனத்தால் கட்டுப்படுத்தப்படுகிறது, இது ஆஃப்செயின் தகவல்களைத் திரட்டுவதற்கும், கோரியபடி ஆரக்கிள் கான்ட்ராக்டின் தரவைப் புதுப்பிப்பதற்கும் பொறுப்பாகும். மையநிலை ஒராக்கிள்கள் செயல்திறன் வாய்ந்தவை, ஏனெனில் அவை ஒரு நம்பகமான மூலத்தின் மீது தான் முழுமையாகச் சார்ந்திருக்கும். சொந்த தகவல்தொகுப்புகள் நேரடியாக உரிமையாளரால் வெளியிடப்பட்டும், பரவலாக ஏற்றுக்கொள்ளப்பட்ட கையொப்பத்துடன் இருந்தால், நன்கு செயல்படும். ஆனால், இவற்றின் சில குறைபாடுகள் உள்ளன:

#### குறைந்த சரியான தன்மைக்கான உத்தரவாதங்கள் {#low-correctness-guarantees}

மையநிலை ஒராக்கிள்களின் மூலம் வழங்கப்பட்ட தகவல் சரியானதா அல்லது தவறானதா என்பதை உறுதிப்படுத்த சாத்தியமில்லை. "மிகச் சிறந்த" தரப்பினரும் தங்கள் பாதையை விட்டு மாறக்கூடும் அல்லது ஹேக் செய்யப்படலாம். ஒராக்கிள் முறைகேடாக ஆனால், ஸ்மார்ட் கான்ட்ராக்டுகள் தவறான தரவின் அடிப்படையில் செயல்படுகின்றன.

#### மோசமான கிடைக்கும் தன்மை {#poor-availability}

மையப்படுத்தப்பட்ட ஆரக்கிள்கள் எப்போதும் மற்ற ஸ்மார்ட் கான்ட்ராக்டுகளுக்கு ஆஃப்செயின் தரவை கிடைக்கச் செய்யும் என்பதற்கு உத்தரவாதம் இல்லை. வழங்குநர் சேவையை அணைக்க முடிவு செய்தால் அல்லது ஒரு ஹேக்கர் ஆரக்கிளின் ஆஃப்செயின் கூறுகளைக் கைப்பற்றினால், உங்கள் ஸ்மார்ட் கான்ட்ராக்ட் சேவை மறுப்பு (DoS) தாக்குதலுக்கு உள்ளாகும் அபாயத்தில் உள்ளது.

#### மோசமான ஊக்கத்தொகை இணக்கத்தன்மை {#poor-incentive-compatibility}

மையநிலை ஒராக்கிள்களுக்கு தரவின் அண்மை/மாற்றப்படாத தகவலை அனுப்புவதற்கான பொருத்தமான உத்தரவாதம் குறைவு அல்லது இல்லாத உத்தரவாதங்கள் உள்ளன. ஒரு ஒராக்கிளுக்கு தகவலின் உறுதி அடிப்படையில் பணம் கொடுக்கப்படுவது, அதனுடைய நேர்மையை உறுதி செய்யாது. இந்தச் சிக்கல் ஸ்மார்ட் கான்ட்ராக்டுகள் நிர்வகிக்கும் மதிப்பு அளவுகள் வளர்ந்தபொழுது மேலும் மிகுப்படைக்கின்றது.

### பரவலாக்கப்பட்ட ஆரக்கிள்கள் {#decentralized-oracles}

மையநிலை ஒராக்கிள்களின் குறைபாடுகளை நீக்க மையமற்ற ஒராக்கிள்கள் உருவாக்கப்பட்டுள்ளன, இது ஒரே ஒரு சின்னமான முடிவின் தோல்விகளை மொட்டிலேயே நீக்க வைக்கின்றன. ஒரு பரவலாக்கப்பட்ட ஆரக்கிள் சேவையானது, பியர்-டு-பியர் நெட்வொர்க்கில் உள்ள பல பங்கேற்பாளர்களை உள்ளடக்கியது, இது ஒரு ஸ்மார்ட் கான்ட்ராக்ட்டுக்கு அனுப்புவதற்கு முன்பு ஆஃப்செயின் தரவுகளில் ஒருமித்த கருத்தை உருவாக்குகிறது.

மையமற்ற ஒராக்கிள், தடை இல்லாமல், நம்பிக்கை இல்லாமல், மையநிலையிலிருந்து இயல்பாக இருக்க வேண்டும்; உண்மையில், ஒராக்கிள்களின் மையமின்மை ஒரு அளவுகோலில் உள்ளது. பாரசீல் மையமற்ற ஒராக்கிள் நெட்வொர்க்குகள் கூட இருக்கின்றன: இதில் யாரும் பங்கேற்க முடியும், ஆனால் இணையத்தை சரிபார்க்கும் வரலாற்று செயல்பாடுகளை அடிப்படையாகச் செய்யும் ஒரு "உரிமையாளர்" உள்ளார். முழுமையாக மையமற்ற ஒராக்கிள் நெட்வொர்க்குகளும் உள்ளன: இவை பொதுவாகத் தனித்த புளோக்செயின் பயனராக இயங்குகின்றன மற்றும் குறிப்பிடப்பட்ட இணக்கத்தின் முகமனைகளை நகர்த்த, முடிவுகளை மட்டுமல்ல நடக்கைகளையும் சமரசம் செய்யும் வழிமுறைகளைக் கொண்டுள்ளன.

மையமற்ற ஒராக்கிள்களை பயன்படுத்துவதன் பின்வரும் நன்மைகள் உள்ளன:

### உயர் சரியான தன்மைக்கான உத்தரவாதங்கள் {#high-correctness-guarantees}

மையமற்ற ஒராக்கிள்கள் தரவின் சரியானதனை உறுதி செய்யும் வேறுபட்ட முறைகளை உருவாக்கும். திருப்பியளிக்கப்பட்ட தகவலின் நம்பகத்தன்மை மற்றும் ஒருமைப்பாட்டைச் சான்றளிக்கும் ஆதாரங்களைப் பயன்படுத்துவது மற்றும் ஆஃப்செயின் தரவின் செல்லுபடியாகும் தன்மையில் பல நிறுவனங்கள் கூட்டாக உடன்பட வேண்டும் என்பது இதில் அடங்கும்.

#### நம்பகத்தன்மைக்கான ஆதாரங்கள் {#authenticity-proofs}

உண்மையான ஆதாரங்கள் என்பது, வெளிப்புற மூலங்களில் பெறப்பட்ட தகவலின் தனிப்பட்ட சரிபார்ப்பை செய்ய உதவும் கிரிப்டோகிராஃபிக் முறைகள் ஆகும். இந்த ஆதாரங்கள் தகவலின்மூலத்தைச் சரிபார்க்கவும், மற்றும் பெறப்பட்டதற்குப் பிறகு தகவலில் நடத்தப்பட்ட சாத்தியமானமாற்றங்களைக் கண்டுபிடிக்க முடியும்.

உண்மையான ஆதாரங்களின் எடுத்துக்காட்டுகள் கீழ்வருமாறு உள்ளன:

**போக்குவரத்து அடுக்கு பாதுகாப்பு (TLS) ஆதாரங்கள்**: ஆரக்கிள் முனைகள் பெரும்பாலும் போக்குவரத்து அடுக்கு பாதுகாப்பு (TLS) நெறிமுறையின் அடிப்படையில் பாதுகாப்பான HTTP இணைப்பைப் பயன்படுத்தி வெளிப்புற மூலங்களிலிருந்து தரவை மீட்டெடுக்கின்றன. சில மையமற்ற ஒராக்கிள்கள் TLS அமர்வுகளைச் சரிபார்க்க உண்மையான ஆதாரங்களைப் பயன்படுத்துகின்றன (அதாவது, ஒரு கணையும் குறிப்பிட்ட சர்வரின் இடையே தகவல் மாற்றத்தை உறுதி செய்வது) மற்றும் அமர்வின் உள்ளடக்கங்கள் மாற்றம் செய்யப்படவில்லை என்பதை உறுதிப்படுத்த முடியும்.

**நம்பகமான செயலாக்கச் சூழல் (TEE) சான்றளிப்புகள்**: ஒரு [நம்பகமான செயலாக்கச் சூழல்](https://en.wikipedia.org/wiki/Trusted_execution_environment) (TEE) என்பது அதன் ஹோஸ்ட் அமைப்பின் செயல்பாட்டு செயல்முறைகளிலிருந்து தனிமைப்படுத்தப்பட்ட ஒரு சாண்ட்பாக்ஸ் கணக்கீட்டு சூழலாகும். TEEs எந்தச் செயல்முறை குறியீடும் அல்லது தகவலும் செயலாக்கச் சூழலின் செயல்முறையில் சேமிக்கப்பட்ட அல்லது பயன்படுத்தப்பட்ட நம்பகத்தை உறுதி\*\* செய்கின்றன. பயனர்கள் கூடவே ஒரு அத்தாட்சியை உருவாக்க முடியும், ஒரு செயல்முறை அம்சம் நம்பகமான செயலாக்கச் சூழலின் உள்ளே இயங்குகிறது என்பதை உறுதிப்படுத்த முடியும்.

சில மையமற்ற ஒராக்கிள்கள் ஒராக்கிள் கணையாளர்களை TEE உறுதிப்படுத்தல்களை வழங்கக் கோருகின்றன. இது பயனருக்கு, ஒரு ஒராக்கிள் கணையாளர் நம்பகமான செயலாக்கச் சூழலில் ஒரு ஒராக்கிள் வாடிக்கையாளரின் அம்சத்தை இயக்கிக் கொண்டிருக்கிறார் என்பதை உறுதிப்படுத்துகிறது. TEEs, வெளிப்புற செயல்முறைகள் செயல்முறை குறியீட்டையும் தகவலையும் மாற்றுவதிலிருந்து அல்லது படிக்கத் தடுப்பதோடு, அந்த அத்தாட்சிகள், ஒராக்கிள் கணையாளர் தகவலை உறுதியாகவும் இரகசியமாகவும் வைத்திருக்கிறார் என்பதை உறுதிப்படுத்த முடிகின்றன.

#### தகவல்களின் ஒருமித்த கருத்து அடிப்படையிலான சரிபார்ப்பு {#consensus-based-validation-of-information}

மையப்படுத்தப்பட்ட ஒராக்கிள்கள் தகவலை வழங்கும்போது ஒரே மூலத்தை மெய்யான எனச் சொல்லிச் செயல்படுகின்றன, இதனால் தவறான தகவலை வெளியிட இயலும். பரவலாக்கப்பட்ட ஆரக்கிள்கள் ஆஃப்செயின் தகவல்களை வினவுவதற்கு பல ஆரக்கிள் முனைகளை நம்பி இந்த சிக்கலை தீர்க்கின்றன. பல மூலங்களிலிருந்து தரவை ஒப்பிடுவதன் மூலம், பரவலாக்கப்பட்ட ஆரக்கிள்கள் ஆன்செயின் கான்ட்ராக்டுகளுக்கு தவறான தகவல்களை அனுப்பும் அபாயத்தைக் குறைக்கின்றன.

இருப்பினும், பரவலாக்கப்பட்ட ஆரக்கிள்கள் பல ஆஃப்செயின் மூலங்களிலிருந்து மீட்டெடுக்கப்பட்ட தகவல்களில் உள்ள முரண்பாடுகளைக் கையாள வேண்டும். இந்தவேறுபாடுகளைக் குறைக்கவும்் மற்றும் ஒராக்கிள் ஒப்பந்தத்திற்கு வழங்கப்படும் தகவல் ஒராக்கிள் கணைகளின் ஒப்புகையை ஒட்டும் முறையில் இருப்பதை உறுதிப்படுத்தவும், மையமற்ற ஒராக்கிள்கள் பின்வரும்முறைகளைப் பயன்படுத்துகின்றனன:

##### தகவலின் நம்பகத்தன்மையை வாக்குப்பதிவு/சேமித்தல்

சில மையமற்ற ஒராக்கிள் பிணையங்கள் பங்கேற்பாளர்களைத் தகவல் வினவல்களுக்குச் சரியான பதில்களுக்காக வாக்குப்பதிவு செய்ய அல்லது நமது நாணயத்தைச் சேமிக்க கோருகின்றன (எ.கா., "2020 அமெரிக்கா தேர்தலில் யார் வென்றார்?") ஒரு சேர்க்கை நெறிமுறை வாக்குகளையும் சேமிப்பையும் சேர்த்து வெளியிடுகிறது. மற்றும் பெரும்பான்மையால் ஆதரிக்கப்பட்ட பதிலைச் சரியான என எடுக்கிறது.

பெரும்பான்மையிலிருந்து வேறுபட்ட பதில்களை வழங்கும் கணைகளின் நாணயங்கள் பின்பற்றாமல் சரியான மதிப்புகளைக் கொடுத்தவர்களுக்கு வழங்கப்படுகின்றன. கணைகள் தகவலை வழங்குவதற்கு முந்தின முன்பே நாணயத்தை வழங்க வைத்தல், இயல்புப் படி பிரயோஜனங்களை அதிகரிக்க காரணமாகக் கணைகள் நேர்மையான பதில்களை வழங்க ஏற்படுத்துகிறது.

ஸ்டேக்கிங்/வாக்களிப்பு, ஒருமித்த கருத்து அமைப்பை விளையாட தீங்கிழைக்கும் நடிகர்கள் பல அடையாளங்களை உருவாக்கும் [சிபில் தாக்குதல்களிலிருந்து](/glossary/#sybil-attack) பரவலாக்கப்பட்ட ஆரக்கிள்களைப் பாதுகாக்கிறது. ஆனால், சேமித்தல் "இலவச செயலாற்றுதல்" (ஒராக்கிள் கணைகள் மற்ற வழங்கிய தகவலை நகலெடுத்தல்) மற்றும் "சோம்பு சரிபார்ப்பு" (ஒராக்கிள் கணைகள் தங்களின்தகவலைச் சரிபார்க்காமல்் பெரும்பான்மையை பின்பற்றுவது) அணுகுமுறை அடிக்கவில்லை.

##### ஷெலிங் பாயிண்ட் முறைகள்

[ஷெல்லிங் புள்ளி](https://en.wikipedia.org/wiki/Focal_point_\(game_theory\)) என்பது ஒரு கேம்-தியரி கருத்தாகும், இது எந்தவொரு தகவல்தொடர்பும் இல்லாத நிலையில் ஒரு பிரச்சனைக்கு பல நிறுவனங்கள் எப்போதும் ஒரு பொதுவான தீர்விற்கு இயல்புநிலையாக இருக்கும் என்று கருதுகிறது. ஷெலிங் பாயிண்ட் முறைகள், மையமற்ற ஒராக்கிள் பிணையங்களில் தகவல் வினவல்களுக்குப் பதில்களை அடைய, கணைகளுக்கு ஒப்புகையை எட்ட பயன்படுகின்றன.

இதற்கான ஒரு ஆரம்ப யோசனை [SchellingCoin](https://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/), இது ஒரு முன்மொழியப்பட்ட தரவு ஊட்டம் ஆகும், இதில் பங்கேற்பாளர்கள் "ஸ்கேலார்" கேள்விகளுக்கு (அதன் பதில்கள் அளவால் விவரிக்கப்படும் கேள்விகள், எ.கா., "ETH இன் விலை என்ன?") பதில்களை, ஒரு டெபாசிட்டுடன் சமர்ப்பிக்கிறார்கள். 25 வது மற்றும் 75 வது [சதவீதத்திற்கு](https://en.wikipedia.org/wiki/Percentile) இடையில் மதிப்புகளை வழங்கும் பயனர்களுக்கு வெகுமதி அளிக்கப்படுகிறது, அதே நேரத்தில் சராசரி மதிப்பிலிருந்து பெரிதும் விலகும் மதிப்புகளைக் கொண்டவர்கள் தண்டிக்கப்படுகிறார்கள்.

இன்று SchellingCoin இல்லை என்றாலும், பல பரவலாக்கப்பட்ட ஆரக்கிள்கள் - குறிப்பாக [Maker Protocol’s Oracles](https://docs.makerdao.com/smart-contract-modules/oracle-module) - ஆரக்கிள் தரவின் துல்லியத்தை மேம்படுத்த ஷெல்லிங்-புள்ளி பொறிமுறையைப் பயன்படுத்துகின்றன. ஒவ்வொரு மேக்கர் ஆரக்கிளும், சந்தை விலைகளை சமர்ப்பிக்கும் ஆஃப்செயின் P2P நெட்வொர்க் முனைகள் ("ரிலேயர்கள்" மற்றும் "ஊட்டங்கள்") மற்றும் வழங்கப்பட்ட அனைத்து மதிப்புகளின் சராசரியைக் கணக்கிடும் ஒரு ஆன்செயின் "மீடியனைசர்" கான்ட்ராக்ட்டையும் கொண்டுள்ளது. குறிக்கப்பட்ட விலகல் காலம் முடிந்ததும், இந்த மீடியன் மதிப்பு தொடர்புடைய பொருளுக்கான புதிய சுட்டீயின் விலையாக வெளிவருகிறது.

ஷெல்லிங் புள்ளி பொறிமுறைகளைப் பயன்படுத்தும் ஆரக்கிள்களின் பிற எடுத்துக்காட்டுகளில் [Chainlink Offchain Reporting](https://docs.chain.link/architecture-overview/off-chain-reporting) மற்றும் [Witnet](https://witnet.io/) ஆகியவை அடங்கும். இரண்டிலும், ஒராக்கிள் கணைகள், தொகுப்பு விலைகளைச் சரியான மீடியன் மற்றும் மதிப்பு என்று நகர்த்தி, செய்திட ஒரு நகர்தல் கணிமுறை நிகழ்கிறது. கணைகள், அவர்களின் பதில்கள் மூல மதிப்புகளின் மீட்க, அதற்குப் பதிலாக, கணைகள் சரியான மதிப்புகளை வழங்கும் அவசியம் அருணம் என்பதால், அதற்கான முதன்மையான பதில்களை அதற்காக நிலைத்துவிடுகின்றன.

ஷெல்லிங் புள்ளி வழிமுறைகள் கவர்ச்சிகரமானவை, ஏனெனில் அவை பரவலாக்கத்திற்கு உத்தரவாதம் அளிக்கும் போது ஆன்செயின் தடம் (ஒரே ஒரு பரிவர்த்தனை மட்டுமே அனுப்பப்பட வேண்டும்) குறைக்கின்றன. அது மையமற்ற பிரகாசமாகும், ஏனெனில், கணைகள் அறியும்முடிந்த தொகுப்புப் பதில்களின் பட்டியலை உள்ளீடு செய்ய, அவை சரியான அம்சங்களை அடைந்துள்ளதற்கான கையொப்பத்தை வழியிடுகின்றன.

### கிடைக்கும் தன்மை {#availability}

பரவலாக்கப்பட்ட ஆரக்கிள் சேவைகள் ஸ்மார்ட் கான்ட்ராக்டுகளுக்கு ஆஃப்செயின் தரவின் உயர் கிடைக்கும் தன்மையை உறுதி செய்கின்றன. ஆஃப்செயின் தகவல்களின் மூலத்தையும், தகவல்களை ஆன்செயினுக்கு மாற்றுவதற்குப் பொறுப்பான முனைகளையும் பரவலாக்குவதன் மூலம் இது அடையப்படுகிறது.

அதனால், குறிப்பிட்ட முறையில் ஒவ்வொரு ஒராக்கிள் ஒப்பந்தம் பல கணைகளை \*\*(அவை மற்றும் பல தகவல் மூலங்களை மற்றும் நம்புகின்றன) வழங்க, அந்த வினவல்களைச் சரியான நேரத்தில் செயலாக்குகின்றன. மூலம் _மற்றும்_ முனை-ஆபரேட்டர் மட்டத்தில் பரவலாக்கம் முக்கியமானது - ஒரே மூலத்திலிருந்து பெறப்பட்ட தகவல்களை வழங்கும் ஆரக்கிள் முனைகளின் நெட்வொர்க், ஒரு மையப்படுத்தப்பட்ட ஆரக்கிள் போன்ற அதே சிக்கலை எதிர்கொள்ளும்.

தரவுக் கோரிக்கைகளுக்கு விரைவாகப் பதிலளிக்கத் தவறிய முனை ஆபரேட்டர்களை ஸ்டேக் அடிப்படையிலான ஆரக்கிள்கள் ஸ்லாஷ் செய்யவும் முடியும். இதற்காக, அந்த மையமற்ற தகவல்களை முற்றிலும் அமைக்க, அவை சரியான தகவல்களை நிறுவவும் அந்தச் செயலாக்கத்திற்குரிய முறைகளை அமைப்பதும் அதிகமாகப் பெரிய மதிப்புகளை அடைய வழிகாட்டுகின்றன.

### நல்ல ஊக்கத்தொகை இணக்கத்தன்மை {#good-incentive-compatibility}

பரவலாக்கப்பட்ட ஆரக்கிள்கள், ஆரக்கிள் முனைகளிடையே [பைசண்டைன்](https://en.wikipedia.org/wiki/Byzantine_fault) நடத்தையைத் தடுக்க பல்வேறு ஊக்கத்தொகை வடிவமைப்புகளை செயல்படுத்துகின்றன. குறிப்பாக, அவை _பண்புக்கூறு_ மற்றும் _பொறுப்புக்கூறலை_ அடைகின்றன:

1. மையமற்ற ஒராக்கிள் கணைகள் பொதுவாக, தரவுகளைப் பதிலளிக்கும் சந்தர்ப்பங்களில் தாங்கள் வழங்கும் தகவல்களைக் கையொப்பமிட வேண்டும். இந்தத் தகவல், ஒராக்கிள் கணைகளின் வரலாற்று செயல்திறனை மதிப்பீடு செய்ய உதவுகின்றது. அதனால், பயனர்கள் தங்களது தரவுக் கோரிக்கைகளைச் செய்யும்போது, நம்பமுடியாத ஒராக்கிள் கணைகளை விலக்க முடியும். Witnet இன் [அல்காரிதம் நற்பெயர் அமைப்பு](https://docs.witnet.io/intro/about/architecture#algorithmic-reputation-system) ஒரு எடுத்துக்காட்டு.

2. மையமற்ற ஒராக்கிள்கள்—முந்தைய விளக்கத்தின் படி—கணைகளை வழங்கும் நம்பிக்கையைப் பொறுத்து ஒரு பணம் முன் வைத்து இடுகாட்ட வேண்டும். இறுதியாக, இந்தப் பணம் சரியான செயல்பாட்டிற்கு மீண்டும் திரும்பியும், வெளிப்படையான அளவிற்கு இருப்பதற்கான பதக்கங்கள் உடனான வழியையும் கொடுக்கச் செய்யப்படலாம். ஆனால், தகவல் தவறாக இருந்தால், இந்தப் பணம் அவர்களது பாதகத்திற்காகக் கழிக்கப்படும், இது சில அளவுக்குப் பொறுப்புணர்வை வழங்குகின்றது.

## ஸ்மார்ட் கான்ட்ராக்டுகளில் ஆரக்கிள்களின் பயன்பாடுகள் {#applications-of-oracles-in-smart-contracts}

கீழே, எதிருமாற்று நிபந்தனைகளில் ஒராக்கிள்களுக்கான சாதாரண பயன்பாடுகள் விரிவாக விளக்கப்படுகின்றன:

### நிதித் தரவை மீட்டெடுத்தல் {#retrieving-financial-data}

[பரவலாக்கப்பட்ட நிதி](/defi/) (DeFi) பயன்பாடுகள் பியர்-டு-பியர் கடன் வழங்குதல், கடன் வாங்குதல் மற்றும் சொத்துக்களை வர்த்தகம் செய்ய அனுமதிக்கின்றன. இதற்கான தகவல்களை அடிக்கடி மாற்றம் செய்ய, விலைவிகித தகவல் (மெய்நிகர் நாணயங்கள் மற்றும் டோக்கன் விலைகளை மதிப்பீடு செய்ய அவசியமான) மற்றும் மூலதன சந்தை தகவல் (மெய்நிகர் சொத்து மதிப்பீடு செய்ய) மீட்டல் தேவையானது.

உதாரணமாக, ஒரு டீஃபை கடன் நியமம் கைபற்றும் சந்தை விலைகளைக் கேட்டு, உருவாக்கப்பட்ட மூலதன சொத்துக்களின் மதிப்பைத் தீர்மானிக்க முடியுமாறு செய்ய வேண்டும். இதன் மூலம், ஒப்பந்தம் சொத்துக்களின் மதிப்பைத் தீர்மானிக்க முடிகிறது மற்றும் தொகுதி நிலைக்கு முடியக்கூடியது.

DeFi இல் பிரபலமான "விலை ஆரக்கிள்கள்" (அவை பெரும்பாலும் அழைக்கப்படுவது போல) Chainlink விலை ஊட்டங்கள், Compound Protocol இன் [திறந்த விலை ஊட்டம்](https://compound.finance/docs/prices), Uniswap இன் [நேரம்-எடையிடப்பட்ட சராசரி விலைகள் (TWAPs)](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles), மற்றும் [Maker Oracles](https://docs.makerdao.com/smart-contract-modules/oracle-module) ஆகியவை அடங்கும்.

இந்த விலை ஒராக்கிள்களை தங்கள் திட்டத்தில் ஒப்பிணைக்க முன், பாரியமாக மதிப்பீடு செய்ய, இதில் உள்ள குறைகளைச் சிறந்த முறையில் புரிந்து கொள்ள நிபுணர்களுக்கு அவசியமானது. இந்த [கட்டுரை](https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/) குறிப்பிடப்பட்டுள்ள எந்த விலை ஆரக்கிள்களையும் பயன்படுத்த திட்டமிடும்போது என்ன கருத்தில் கொள்ள வேண்டும் என்பதற்கான விரிவான பகுப்பாய்வை வழங்குகிறது.

கீழே, ஒரு செயின்லிங்க் விலை வழங்கலைப் பயன்படுத்தி, தங்களது பொறிமுறையில் சமீபத்திய ETH விலையை மீட்ட எப்படி செய்வது என்பதற்கான ஒரு உதாரணம் கொடுக்கப்பட்டுள்ளது:

```solidity
pragma solidity ^0.6.7;

import "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Kovan
     * Aggregator: ETH/USD
     * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331
     */
    constructor() public {
        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```

### சரிபார்க்கக்கூடிய சீரற்ற தன்மையை உருவாக்குதல் {#generating-verifiable-randomness}

சில பிளாக்செயின் பயன்பாடுகள், குறிப்பாகப் பிளாக்செயின் அடிப்படையிலான விளையாட்டுகள் அல்லது லாட்டரி திட்டங்கள், பயனுள்ள செயல்பாட்டிற்காக மிகுந்த மதிப்பீட்டற்ற தன்மை மற்றும் சீரற்ற எண்ணங்களைத் தேவைப்படுத்துகின்றன. ஆனால், பிளாக்செயின் செயல்பாடுகளின் தீர்மானக செய்முறை (deterministic execution) சீரற்ற தன்மையை அகற்றுகின்றது.

அசல் அணுகுமுறை `blockhash` போன்ற சூடோராண்டம் கிரிப்டோகிராஃபிக் செயல்பாடுகளைப் பயன்படுத்துவதாகும், ஆனால் இவை [சுரங்கத் தொழிலாளர்களால் கையாளப்படலாம்](https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So%20while%20the%20miners%20can,to%20one%20of%20the%20players.) வேலைக்கான ஆதாரம் அல்காரிதத்தை தீர்க்கிறது. மேலும், எத்தேரியம் [ப்ரூஃப்-ஆஃப்-ஸ்டேக்கிற்கு மாறுவது](/roadmap/merge/) என்பது டெவலப்பர்கள் இனி ஆன்செயின் சீரற்ற தன்மைக்காக `blockhash` ஐ நம்ப முடியாது என்பதாகும். அதற்கு பதிலாக பீக்கான் செயினின் [RANDAO பொறிமுறை](https://eth2book.info/altair/part2/building_blocks/randomness) சீரற்ற தன்மைக்கான மாற்று மூலத்தை வழங்குகிறது.

சீரற்ற மதிப்பை ஆஃப்செயினில் உருவாக்கி அதை ஆன்செயினுக்கு அனுப்புவது சாத்தியம், ஆனால் அவ்வாறு செய்வது பயனர்கள் மீது அதிக நம்பிக்கை தேவைகளை விதிக்கிறது. அவர்கள் மதிப்பு உண்மையில் மதிப்பீட்டற்ற முறைகளால் உருவாக்கப்பட்டது மற்றும் போக்குவரத்து (transit) போது மாற்றப்படவில்லை என்று நம்ப வேண்டும்.

ஆஃப்செயின் கணக்கீட்டிற்காக வடிவமைக்கப்பட்ட ஆரக்கிள்கள், ஆஃப்செயினில் பாதுகாப்பாக சீரற்ற விளைவுகளை உருவாக்குவதன் மூலம் இந்த சிக்கலைத் தீர்க்கின்றன, அதை அவை செயல்பாட்டின் கணிக்க முடியாத தன்மையை சான்றளிக்கும் கிரிப்டோகிராஃபிக் ஆதாரங்களுடன் ஆன்செயினில் ஒளிபரப்புகின்றன. ஒரு எடுத்துக்காட்டு [Chainlink VRF](https://docs.chain.link/docs/chainlink-vrf/) (சரிபார்க்கக்கூடிய சீரற்ற செயல்பாடு), இது கணிக்க முடியாத விளைவுகளை நம்பியிருக்கும் பயன்பாடுகளுக்கு நம்பகமான ஸ்மார்ட் கான்ட்ராக்டுகளை உருவாக்கப் பயன்படும் ஒரு நிரூபிக்கப்பட்ட நியாயமான மற்றும் சேதப்படுத்த முடியாத சீரற்ற எண் ஜெனரேட்டர் (RNG) ஆகும்.

### நிகழ்வுகளுக்கான விளைவுகளைப் பெறுதல் {#getting-outcomes-for-events}

ஒராக்கிள்கள் மூலம், உலக நிகழ்வுகளைப் பதிலளிக்கும் ஸ்மார்ட் ஒப்பந்தங்களை உருவாக்குவது எளிது. ஆரக்கிள் சேவைகள், கான்ட்ராக்டுகளை ஆஃப்செயின் கூறுகள் மூலம் வெளிப்புற API களுடன் இணைக்க அனுமதிப்பதன் மூலமும், அந்தத் தரவு மூலங்களிலிருந்து தகவல்களை உட்கொள்வதன் மூலமும் இதை சாத்தியமாக்குகின்றன. உதாரணமாக, முன்னர் குறிப்பிட்ட முன்கணிப்பு dapp, நம்பகமான ஆஃப்செயின் மூலத்திலிருந்து (எ.கா., அசோசியேட்டட் பிரஸ்) தேர்தல் முடிவுகளைத் திருப்பித் தருமாறு ஒரு ஆரக்கிளைக் கோரலாம்.

உலக நிகழ்வுகளின் அடிப்படையில் தகவல்களைப் பெறுவதற்கான ஒராக்கிள்களைப் பயன்படுத்துவது புதிய பயன்பாடுகளுக்கான வாய்ப்புகளை வழங்குகிறது; உதாரணமாக, ஒரு வகுத்துவெளியமைக்கப்பட்ட காப்பீட்டு (decentralized insurance product) தயாரிப்பு, செயல்பட நல்ல முறையில், வானிலை, பெரும்பாதை போன்றவை பற்றிய துல்லியமான தகவல்களை தேவைப்படுத்துகிறது.

### ஸ்மார்ட் கான்ட்ராக்டுகளை தானியக்கமாக்குதல் {#automating-smart-contracts}

ஸ்மார்ட் ஒப்பந்தங்கள் தானாகவே செயல்படாது; மாறாக, ஒரு வெளிப்புற சொந்த கணக்கு (EOA) அல்லது மற்றொரு ஒப்பந்தக் கணக்கு சரியான செயல்பாடுகளை உருவாக்க வேண்டும். பெரும்பாலான சந்தர்ப்பங்களில், ஒப்பந்தத்தின் முக்கிய செயல்பாடுகள் பொது மற்றும் EOA கள் மற்றும் பிற ஒப்பந்தங்கள்மூலம் அழைக்கப்படலாம்.

ஆனால் ஒரு கான்ட்ராக்ட்டுக்குள் மற்றவர்களுக்கு அணுக முடியாத _தனியார் செயல்பாடுகளும்_ உள்ளன;, ஆனால் அவை ஒரு dapp இன் ஒட்டுமொத்த செயல்பாட்டிற்கு முக்கியமானவை. எடுத்துக்காட்டுகளில், பயனர்களுக்காக அவ்வப்போது புதிய NFT களை உருவாக்கும் ஒரு `mintERC721Token()` செயல்பாடு, ஒரு முன்கணிப்பு சந்தையில் பேஅவுட்களை வழங்குவதற்கான ஒரு செயல்பாடு, அல்லது ஒரு DEX இல் ஸ்டேக் செய்யப்பட்ட டோக்கன்களைத் திறப்பதற்கான ஒரு செயல்பாடு ஆகியவை அடங்கும்.

மேலே குறிப்பிட்ட செயல்பாடுகளை இடைவெளிகளுக்கு அடுத்தடுத்து உருவாக்கத் தேவையாகும். இது பயனுள்ள செயல்பாடுகளைத் தானாகவே செயல்படுத்துவதற்கு அதிக நேரத்தை இழக்கச் செய்யக்கூடும், அதனால் ஸ்மார்ட் ஒப்பந்தங்களின் செயல்பாட்டைத் தானாகவே இயக்குவது ஈர்க்கக்கூடியதாகிறது.

சில பரவலாக்கப்பட்ட ஆரக்கிள் நெட்வொர்க்குகள் ஆட்டோமேஷன் சேவைகளை வழங்குகின்றன, இது பயனரால் வரையறுக்கப்பட்ட அளவுருக்களின்படி ஸ்மார்ட் கான்ட்ராக்ட் செயல்பாடுகளைத் தூண்டுவதற்கு ஆஃப்செயின் ஆரக்கிள் முனைகளை அனுமதிக்கிறது. இது பொதுவாக, இலக்குப் பெறும் ஒப்பந்தத்தை ஒராக்கிள் சேவையுடன் "பதிவு செய்யல்", ஒராக்கிள் இயக்குநருக்குப் பணம் வழங்கல், மற்றும் ஒப்பந்தத்தை இயக்குவதற்கான நிபந்தனைகளை அல்லது நேரங்களைக் குறிப்பிடல் ஆகியவற்றைக் கொண்டுள்ளது.

செயின்லிங்கின் [கீப்பர் நெட்வொர்க்](https://chain.link/keepers) ஸ்மார்ட் கான்ட்ராக்டுகளுக்கு வழக்கமான பராமரிப்புப் பணிகளை நம்பிக்கை குறைக்கப்பட்ட மற்றும் பரவலாக்கப்பட்ட முறையில் அவுட்சோர்ஸ் செய்வதற்கான விருப்பங்களை வழங்குகிறது. உங்கள் கான்ட்ராக்ட்டை கீப்பர்-இணக்கமானதாக மாற்றுவது மற்றும் அப்கீப் சேவையைப் பயன்படுத்துவது பற்றிய தகவல்களுக்கு அதிகாரப்பூர்வ [கீப்பரின் ஆவணத்தை](https://docs.chain.link/docs/chainlink-keepers/introduction/)ப் படிக்கவும்.

## பிளாக்செயின் ஆரக்கிள்களை எவ்வாறு பயன்படுத்துவது {#use-blockchain-oracles}

உங்கள் ஈதேரியம் டேப் (dapp) இல் ஒராக்கிள்களை ஒருங்கிணைக்கப் பல்வேறு பயன்பாடுகள் உள்ளன:

**[Chainlink](https://chain.link/)** - _செயின்லிங்க் பரவலாக்கப்பட்ட ஆரக்கிள் நெட்வொர்க்குகள் எந்தவொரு பிளாக்செயினிலும் மேம்பட்ட ஸ்மார்ட் கான்ட்ராக்டுகளை ஆதரிக்க, சேதப்படுத்த முடியாத உள்ளீடுகள், வெளியீடுகள் மற்றும் கணக்கீடுகளை வழங்குகின்றன._

**[RedStone Oracles](https://redstone.finance/)** - _ரெட்ஸ்டோன் என்பது கேஸ்-மேம்படுத்தப்பட்ட தரவு ஊட்டங்களை வழங்கும் ஒரு பரவலாக்கப்பட்ட மாடுலர் ஆரக்கிள் ஆகும். லிக்விட் ஸ்டேக்கிங் டோக்கன்கள் (LSTகள்), லிக்விட் ரீஸ்டேக்கிங் டோக்கன்கள் (LRTகள்), மற்றும் பிட்காயின் ஸ்டேக்கிங் டெரிவேட்டிவ்கள் போன்ற வளர்ந்து வரும் சொத்துக்களுக்கான விலை ஊட்டங்களை வழங்குவதில் இது நிபுணத்துவம் பெற்றது._

**[Chronicle](https://chroniclelabs.org/)** - _உண்மையிலேயே அளவிடக்கூடிய, செலவு-திறனுள்ள, பரவலாக்கப்பட்ட மற்றும் சரிபார்க்கக்கூடிய ஆரக்கிள்களை உருவாக்குவதன் மூலம், ஆன்செயினில் தரவை மாற்றுவதற்கான தற்போதைய வரம்புகளை கிரானிக்கிள் అధిగమిస్తుంది._

**[Witnet](https://witnet.io/)** - _Witnet என்பது அனுமதியற்ற, பரவலாக்கப்பட்ட மற்றும் தணிக்கை-எதிர்ப்பு ஆரக்கிள் ஆகும், இது ஸ்மார்ட் கான்ட்ராக்டுகள் வலுவான கிரிப்டோ-பொருளாதார உத்தரவாதங்களுடன் நிஜ உலக நிகழ்வுகளுக்கு ಪ್ರತಿಕందించడానికి உதவுகிறது._

**[UMA Oracle](https://uma.xyz)** - _UMA வின் நம்பிக்கையான ஆரக்கிள், காப்பீடு, நிதி டெரிவேட்டிவ்கள் மற்றும் முன்கணிப்பு சந்தைகள் உள்ளிட்ட பல்வேறு பயன்பாடுகளுக்கு ஸ்மார்ட் கான்ட்ராக்டுகள் எந்த வகையான தரவையும் விரைவாகப் பெற அனுமதிக்கிறது._

**[Tellor](https://tellor.io/)** - _Tellor என்பது உங்கள் ஸ்மார்ட் கான்ட்ராக்ட்டுக்குத் தேவைப்படும் போதெல்லாம் எந்தத் தரவையும் எளிதாகப் பெறுவதற்கான ஒரு வெளிப்படையான மற்றும் அனுமதியற்ற ஆரக்கிள் நெறிமுறை ஆகும்._

**[Band Protocol](https://bandprotocol.com/)** - _பேண்ட் புரோட்டோகால் என்பது ஒரு குறுக்கு-செயின் தரவு ஆரக்கிள் தளமாகும், இது நிஜ-உலக தரவு மற்றும் API களை ஸ்மார்ட் கான்ட்ராக்டுகளுடன் திரட்டி இணைக்கிறது._

**[Pyth Network](https://pyth.network/)** - _பித் நெட்வொர்க் என்பது ஒரு முதல்-தரப்பு நிதி ஆரக்கிள் நெட்வொர்க் ஆகும், இது ஒரு சேதப்படுத்த-முடியாத, பரவலாக்கப்பட்ட மற்றும் சுய-தன்னிறைவு சூழலில் தொடர்ச்சியான நிஜ-உலகத் தரவை ஆன்செயினில் வெளியிடுவதற்காக வடிவமைக்கப்பட்டுள்ளது._

**[API3 DAO](https://www.api3.org/)** - _API3 DAO முதல் தரப்பு ஆரக்கிள் தீர்வுகளை வழங்குகிறது, இது ஸ்மார்ட் கான்ட்ராக்டுகளுக்கான பரவலாக்கப்பட்ட தீர்வில் அதிக மூல வெளிப்படைத்தன்மை, பாதுகாப்பு மற்றும் அளவிடுதல் ஆகியவற்றை வழங்குகிறது_

**[Supra](https://supra.com/)** - அனைத்து பிளாக்செயின்களையும், பொது (L1கள் மற்றும் L2கள்) அல்லது தனியார் (நிறுவனங்கள்) இணைக்கும் குறுக்கு-செயின் தீர்வுகளின் செங்குத்தாக ஒருங்கிணைக்கப்பட்ட கருவித்தொகுப்பு, ஆன்செயின் மற்றும் ஆஃப்செயின் பயன்பாட்டு-வழக்குகளுக்குப் பயன்படுத்தக்கூடிய பரவலாக்கப்பட்ட ஆரக்கிள் விலை ஊட்டங்களை வழங்குகிறது.

**[Gas Network](https://gas.network/)** - பிளாக்செயின் முழுவதும் நிகழ்நேர எரிவாயு விலை தரவை வழங்கும் ஒரு பரவலாக்கப்பட்ட ஆரக்கிள் தளம். முன்னணி எரிவாயு விலை தரவு வழங்குநர்களிடமிருந்து தரவை ஆன்செயினுக்குக் கொண்டு வருவதன் மூலம், எரிவாயு நெட்வொர்க் இயங்குதளத்தை இயக்க உதவுகிறது. எரிவாயு நெட்வொர்க், எத்தேரியம் மெயின்நெட் மற்றும் பல முன்னணி L2கள் உட்பட 35க்கும் மேற்பட்ட செயின்களுக்கான தரவை ஆதரிக்கிறது.

## மேலும் வாசிக்க {#further-reading}

**கட்டுரைகள்**

- [பிளாக்செயின் ஆரக்கிள் என்றால் என்ன?](https://chain.link/education/blockchain-oracles) — _செயின்லிங்க்_
- [பிளாக்செயின் ஆரக்கிள் என்றால் என்ன?](https://medium.com/better-programming/what-is-a-blockchain-oracle-f5ccab8dbd72) — _பாட்ரிக் காலின்ஸ்_
- [பரவலாக்கப்பட்ட ஆரக்கிள்கள்: ஒரு விரிவான கண்ணோட்டம்](https://medium.com/fabric-ventures/decentralised-oracles-a-comprehensive-overview-d3168b9a8841) — _ஜூலியன் தெவனார்ட்_
- [எத்தேரியத்தில் ஒரு பிளாக்செயின் ஆரக்கிளை செயல்படுத்துதல்](https://medium.com/@pedrodc/implementing-a-blockchain-oracle-on-ethereum-cedc7e26b49e) – _பெட்ரோ கோஸ்டா_
- [ஸ்மார்ட் கான்ட்ராக்டுகள் ஏன் API அழைப்புகளைச் செய்ய முடியாது?](https://ethereum.stackexchange.com/questions/301/why-cant-contracts-make-api-calls) — _StackExchange_
- [எனவே நீங்கள் ஒரு விலை ஆரக்கிளைப் பயன்படுத்த விரும்புகிறீர்கள்](https://samczsun.com/so-you-want-to-use-a-price-oracle/) — _samczsun_

**காணொளிகள்**

- [ஆரக்கிள்கள் மற்றும் பிளாக்செயின் பயன்பாட்டின் விரிவாக்கம்](https://youtu.be/BVUZpWa8vpw) — _Real Vision Finance_

**பயிற்சிகள்**

- [சொலிடிட்டியில் எத்தேரியத்தின் தற்போதைய விலையை எவ்வாறு பெறுவது](https://blog.chain.link/fetch-current-crypto-price-data-solidity/) — _செயின்லிங்க்_
- [ஆரக்கிள் தரவைப் பயன்படுத்துதல்](https://docs.chroniclelabs.org/Developers/tutorials/Remix) — _கிரானிக்கிள்_

**எடுத்துக்காட்டு திட்டங்கள்**

- [சொலிடிட்டியில் எத்தேரியத்திற்கான முழு செயின்லிங்க் தொடக்கத் திட்டம்](https://github.com/hackbg/chainlink-fullstack) — _HackBG_
