---
title: "மெர்கிள் பேட்ரிசியா டிரை"
description: "மெர்கிள் பேட்ரிசியா டிரைக்கான அறிமுகம்."
lang: ta
sidebarDepth: 2
---

எதிரியத்தின் நிலை (எல்லா கணக்குகள், இருப்புகள் மற்றும் ஸ்மார்ட் ஒப்பந்தங்களை உள்ளடக்கிய மொத்த நிலை) பொதுவாகக் கணினி அறிவியலில் மெர்கிள் மரம் எனப்படும் தரவுத் அமைப்பின் ஒரு சிறப்பு பதிப்பில் குறியாக்கமாக உள்ளது. இந்த அமைப்பு குறியாக்கவியலில் பல பயன்பாடுகளுக்கு பயனுள்ளதாக இருக்கிறது, ஏனெனில் இது மரத்தில் சிக்கியுள்ள அனைத்து தனிப்பட்ட தரவுத் துண்டுகளுக்கும் இடையில் சரிபார்க்கக்கூடிய உறவை உருவாக்குகிறது, இதன் விளைவாக தரவைப் பற்றிய விஷயங்களை நிரூபிக்கப் பயன்படுத்தக்கூடிய ஒற்றை **ரூட்** மதிப்பு கிடைக்கிறது.

எத்தீரியத்தின் தரவுக் கட்டமைப்பு ஒரு 'மாற்றியமைக்கப்பட்ட மெர்கிள்-பேட்ரிசியா டிரை' ஆகும், இது PATRICIA (Practical Algorithm To Retrieve Information Coded in Alphanumeric) என்பதன் சில அம்சங்களைப் பெறுவதால் அவ்வாறு பெயரிடப்பட்டது, மேலும் இது எத்தீரியம் நிலையை உருவாக்கும் உருப்படிகளைத் திறமையாக மீட்டெடுப்பதற்காக வடிவமைக்கப்பட்டுள்ளது.

ஒரு மெர்கிள்-பேட்ரிசியா டிரை தீர்மானகரமானது மற்றும் குறியாக்கவியல் ரீதியாக சரிபார்க்கக்கூடியது: ஒரு நிலை ரூட்டை உருவாக்குவதற்கான ஒரே வழி, நிலையின் ஒவ்வொரு தனிப்பட்ட பகுதியிலிருந்தும் அதைக் கணக்கிடுவதாகும், மேலும் ஒரே மாதிரியான இரண்டு நிலைகள் ரூட் ஹாஷ் மற்றும் அதற்கு வழிவகுத்த ஹாஷ்களை ஒப்பிடுவதன் மூலம் எளிதாக நிரூபிக்கப்படலாம் (_ஒரு மெர்க்கிள் ஆதாரம்_). மாறாக, ஒரே ரூட் ஹேஷ் உடைய இரண்டு மாறுபட்ட நிலைகளை உருவாக்க முடியாது, மேலும் மாறுபட்ட மதிப்புகளைக் கொண்ட நிலையை மாற்ற எந்த முயற்சியையும் செய்யும்போது, ஒரு மாறுபட்ட நிலை ரூட் ஹேஷ் உருவாகும். கோட்பாட்டளவில், இந்த அமைப்பு செருகல்கள், தேடல்கள் மற்றும் நீக்கல்களுக்கு `O(log(n))` செயல்திறனின் 'புனித கிண்ணத்தை' வழங்குகிறது.

சமீபத்திய எதிர்காலத்தில், எத்தீரியம் ஒரு [Verkle Tree](/roadmap/verkle-trees) அமைப்புக்கு இடம்பெயரத் திட்டமிட்டுள்ளது, இது எதிர்கால நெறிமுறை மேம்பாடுகளுக்கு பல புதிய சாத்தியங்களைத் திறக்கும்.

## முன்னேற்றக் கட்டுரை {#prerequisites}

இந்தப் பக்கத்தை நன்கு புரிந்துகொள்ள, [ஹாஷ்கள்](https://en.wikipedia.org/wiki/Hash_function), [மெர்க்கிள் மரங்கள்](https://en.wikipedia.org/wiki/Merkle_tree), [டிரைகள்](https://en.wikipedia.org/wiki/Trie) மற்றும் [வரிசைப்படுத்தல்](https://en.wikipedia.org/wiki/Serialization) பற்றிய அடிப்படை அறிவு இருப்பது உதவியாக இருக்கும். இந்தக் கட்டுரை ஒரு அடிப்படை [ரேடிக்ஸ் மரத்தின்](https://en.wikipedia.org/wiki/Radix_tree) விளக்கத்துடன் தொடங்குகிறது, பின்னர் எத்தீரியத்தின் மேம்படுத்தப்பட்ட தரவுக் கட்டமைப்பிற்குத் தேவையான மாற்றங்களை படிப்படியாக அறிமுகப்படுத்துகிறது.

## அடிப்படை ரேடிக்ஸ் டிரைகள் {#basic-radix-tries}

ஒரு அடிப்படை ரேடிக்ஸ் டிரையில், ஒவ்வொரு நொடும் பின்வருமாறு இருக்கும்:

```
    [i_0, i_1 ... i_n, value]
```

`i_0 ...` `i_n` அகரவரிசையின் குறியீடுகளைக் குறிக்கின்றன (பெரும்பாலும் பைனரி அல்லது ஹெக்ஸ்), `value` என்பது முனையில் உள்ள இறுதி மதிப்பாகும், மேலும் `i_0, i_1 ...` இல் உள்ள மதிப்புகள் `i_n` ஸ்லாட்கள் `NULL` ஆகவோ அல்லது மற்ற முனைகளுக்கான சுட்டிகளாகவோ (நம் விஷயத்தில், ஹாஷ்கள்) உள்ளன. இது ஒரு அடிப்படை `(key, value)` சேமிப்பகத்தை உருவாக்குகிறது.

நீங்கள் ஒரு ரேடிக்ஸ் மர தரவுச் அமைப்பைப் பயன்படுத்தி முக்கிய மதிப்புகள் குழுவில் ஒரு வரிசையை நிலையாகக் காக்க விரும்பினால். ட்ரையில் `dog` என்ற கீக்கு தற்போது மேப் செய்யப்பட்டுள்ள மதிப்பைக் கண்டறிய, நீங்கள் முதலில் `dog` ஐ அகரவரிசை எழுத்துக்களாக மாற்றுவீர்கள் (`64 6f 67` கொடுக்கும்), பின்னர் நீங்கள் மதிப்பைக் கண்டுபிடிக்கும் வரை அந்தப் பாதையைப் பின்பற்றி டிரையில் இறங்குவீர்கள். அதாவது, நீங்கள் முதலில் பிளாட் முக்கியம்/மதிப்பு தரவுத்தொகுப்பில் ரூட் ஹேஷை தேடுகிறீர்கள், இது டிரையின் ரூட் நொடியாகக் குறிக்கப்படுகிறது. இது மற்ற நொடிகளைப் புள்ளிகள் வகையில் உள்ள முக்கியங்களிலிருந்து அமைக்கப்படுகிறது. நீங்கள் குறியீட்டெண் `6` இல் உள்ள மதிப்பை ஒரு கீயாகப் பயன்படுத்தி, ஒரு நிலை கீழே உள்ள முனையைப் பெற, பிளாட் கீ/மதிப்பு டிபி-யில் அதைத் தேடுவீர்கள். பின்னர் அடுத்த மதிப்பைப் பார்க்க குறியீட்டெண் `4` ஐத் தேர்ந்தெடுக்கவும், பிறகு குறியீட்டெண் `6` ஐத் தேர்ந்தெடுக்கவும், இப்படியே தொடரவும், நீங்கள் பாதையைப் பின்பற்றியவுடன்: `root -> 6 -> 4 -> 6 -> 15 -> 6 -> 7`, நீங்கள் முனையின் மதிப்பைத் தேடி முடிவைத் தருவீர்கள்.

"டிரை" மற்றும் அடிப்படை பிளாட் முக்கியம்/மதிப்பு 'தரவுத்தொகுப்பில்' ஒன்றை தேடும் இடையே ஒரு வித்தியாசம் உள்ளது. இரண்டும் முக்கியம்/மதிப்பு அமைப்புகளை வரையறுக்கின்றன, ஆனால் அடிப்படை தரவுத்தொகுப்பு ஒரு பாரம்பரிய 1 படியாக முக்கியத்தை தேட முடியும். ஒரு முக்கியத்தை டிரையில் தேடுவது பின்வரும் மதிப்பை அடைய பல அடிப்படை தரவுத்தொகுப்பு தேடுதல்களை தேவைப்படும். தெளிவின்மையை நீக்க, பின்னதை ஒரு `path` என்று குறிப்பிடுவோம்.

ரேடிக்ஸ் டிரைகளுக்கான புதுப்பிப்பு மற்றும் நீக்கம் செயல்பாடுகளைப் பின்வருமாறு வரையறுக்கலாம்:

```python
    def update(node_hash, path, value):
        curnode = db.get(node_hash) if node_hash else [NULL] * 17
        newnode = curnode.copy()
        if path == "":
            newnode[-1] = value
        else:
            newindex = update(curnode[path[0]], path[1:], value)
            newnode[path[0]] = newindex
        db.put(hash(newnode), newnode)
        return hash(newnode)

    def delete(node_hash, path):
        if node_hash is NULL:
            return NULL
        else:
            curnode = db.get(node_hash)
            newnode = curnode.copy()
            if path == "":
                newnode[-1] = NULL
            else:
                newindex = delete(curnode[path[0]], path[1:])
                newnode[path[0]] = newindex

            if all(x is NULL for x in newnode):
                return NULL
            else:
                db.put(hash(newnode), newnode)
                return hash(newnode)
```

"மர்கிள்" ரேடிக்ஸ் மரம் முடிச்சுகளைத் தானாக உருவாக்கப்பட்ட கிரிப்டோகிராஃபிக் ஹாஷ் டைக்ஸ்ட் களைப் பயன்படுத்தி கட்டப்படுகிறது. இந்த உள்ளடக்க-முகவரியிடல் (கீ/மதிப்பு டிபி `key == keccak256(rlp(value))` இல்) சேமிக்கப்பட்ட தரவின் குறியாக்கவியல் ஒருமைப்பாட்டு உத்தரவாதத்தை வழங்குகிறது. ஒரு குறிப்பிட்ட டிரையின் ரூட் ஹாஷ் பொதுவாக தெரிந்தால், அதற்கான அடிப்படை கன்றிய மூலத்தை அணுகும் யார் யாரும் ஒரு குறிப்பிட்ட பாதையில் ஒரு குறிப்பிட்ட மதிப்பை அடக்கியுள்ள டிரை உள்ளதாக ஒரு சான்று உருவாக்கலாம், இது குறிப்பிட்ட மதிப்பை மரத்தின் ரூட் க்கு இணைக்கும் ஒவ்வொரு முடிச்சின் ஹாஷ்களை வழங்குவதன் மூலம் சான்றளிக்க முடியும்.

ஒரு தாக்குபவர் இல்லாத ஒரு `(path, value)` ஜோடிக்கு ஒரு ஆதாரத்தை வழங்குவது சாத்தியமற்றது, ஏனெனில் ரூட் ஹாஷ் இறுதியில் அதன் கீழே உள்ள அனைத்து ஹாஷ்களையும் அடிப்படையாகக் கொண்டது. எந்த அடிப்படை மாற்றமும் ரூட் ஹாஷைப் மாற்றும். ஹாஷ் என்பது தரவின் அமைப்பு தகவலின் அழுத்தமான பிரதிநிதியாகக் குறித்துக் கொள்ளலாம், இது ஹாஷிங் செயல்பாட்டின் முன்-சித்திரம் பாதுகாப்பால் பாதுகாக்கப்படுகிறது.

ஒரு ரேடிக்ஸ் மரத்தின் அணு அலகை (எ.கா., ஒரு ஒற்றை ஹெக்ஸ் எழுத்து, அல்லது 4 பிட் பைனரி எண்) "நிபிள்" என்று குறிப்பிடுவோம். மேலே விவரிக்கப்பட்டுள்ளபடி, ஒரு நேரத்தில் ஒரு நிபிள் என்ற கணக்கில் ஒரு பாதையில் பயணிக்கும்போது, முனைகள் அதிகபட்சமாக 16 கிளைகளைக் குறிப்பிடலாம் ஆனால் ஒரு `value` உறுப்பை உள்ளடக்கியிருக்கும். அதனால், நாம் இவற்றைப் 17 நீளக் கொண்ட முறைமையாகக் குறிப்பிடுகிறோம். இவை 17-எலெமென்ட் முறைமைகளை "உளர்வுப் முடிச்சுகள்" என்று அழைப்போம்.

## மெர்கிள் பேட்ரிசியா டிரை {#merkle-patricia-trees}

ரேடிக்ஸ் டிரைகளுக்கு ஒரு பெரிய கட்டுப்பாடு உள்ளது: அவை திகட்டிக்கொள்ளப்பட்டவை. எத்தீரியத்தில் உள்ளது போல, பாதை 64 எழுத்துகள் நீளமாக இருக்கும் ஒரு `(path, value)` பிணைப்பை நீங்கள் சேமிக்க விரும்பினால் (`bytes32` இல் உள்ள நிபிள்களின் எண்ணிக்கை), ஒரு எழுத்துக்கு ஒரு நிலை சேமிக்க ஒரு கிலோபைட்டிற்கும் அதிகமான கூடுதல் இடம் தேவைப்படும், மேலும் ஒவ்வொரு தேடலும் அல்லது நீக்கமும் முழு 64 படிகளையும் எடுக்கும். அடுத்ததாக அறிமுகம் செய்யப்படும் பத்திரிசியா டிரை இந்தச் சிக்கலைத் தீர்க்கிறது.

### மேம்படுத்தல் {#optimization}

மர்கிள் பத்திரிசியா டிரைவில் ஒரு மூடு பின்வருபவையாக இருக்கும்:

1. `NULL` (வெற்றுச் சரமாக குறிப்பிடப்படுகிறது)
2. `branch` ஒரு 17-உருப்படி முனை `[ v0 ...` `v15, vt ]`
3. `leaf` ஒரு 2-உருப்படி முனை `[ encodedPath, value ]`
4. `extension` ஒரு 2-உருப்படி முனை `[ encodedPath, key ]`

64 எழுத்துகளைக் கொண்ட பாதைகளுடன், முதல் சில அடுக்குகளைச் சுலபமாகக் கடக்கும்போது, நீங்கள் ஒரு மூட்டைச் சந்திக்க வேண்டியிருக்கும், அதில் குறைந்தபட்சமாக ஒரு பகுதிவரை வேறுபாடுகள் இல்லாமல் இருக்கும். பாதையில் 15 சிதறிய `NULL` முனைகள் வரை உருவாக்க வேண்டியிருப்பதைத் தவிர்க்க, `[ encodedPath, key ]` வடிவத்தில் ஒரு `extension` முனையை அமைப்பதன் மூலம் இறங்குவதைக் குறுக்குவழியாக்குகிறோம், இங்கு `encodedPath` என்பது முன்னோக்கிச் செல்ல வேண்டிய "பகுதிப் பாதையைக்" கொண்டுள்ளது (கீழே விவரிக்கப்பட்டுள்ள கச்சிதமான குறியாக்கத்தைப் பயன்படுத்தி), மற்றும் `key` என்பது அடுத்த டிபி தேடலுக்கானது.

ஒரு `leaf` முனைக்கு, `encodedPath`-இன் முதல் நிபிளில் ஒரு கொடியால் குறிக்கப்படலாம், பாதை முந்தைய முனையின் அனைத்து பாதை துண்டுகளையும் குறியாக்குகிறது, மேலும் நாம் நேரடியாக `value`-ஐ தேடலாம்.

மேலே குறிப்பிடப்பட்ட சரிசெய்தல், ஆனால், குழப்பத்தை உருவாக்குகிறது.

நிபிள்களில் பாதைகளைக் கடக்கும்போது, நாம் கடப்பதற்கு ஒற்றைப்படை எண்ணிக்கையிலான நிபிள்களுடன் முடிவடையலாம், ஆனால் எல்லா தரவுகளும் `bytes` வடிவத்தில் சேமிக்கப்படுகின்றன. உதாரணமாக, நிபிள் `1` மற்றும் நிபிள்கள் `01` ஆகியவற்றுக்கு இடையில் வேறுபடுத்துவது சாத்தியமில்லை (இரண்டும் `<01>` என சேமிக்கப்பட வேண்டும்). ஆடி நீளத்தை குறிப்பதற்காக, பகுதி பாதை ஒரு கொடுப்புக்குறியுடன் முன்னுருவிக்கப்பட்டது.

### விவரக்குறிப்பு: விருப்ப முனையத்துடன் கூடிய ஹெக்ஸ் வரிசையின் கச்சிதமான குறியாக்கம் {#specification}

மேலே விவரிக்கப்பட்டுள்ளபடி _ஒற்றைப்படை vs. இரட்டைப்படை மீதமுள்ள பகுதிப் பாதை நீளம்_ மற்றும் _இலை vs. நீட்டிப்பு முனை_ ஆகிய இரண்டின் கொடியிடலும் எந்தவொரு 2-உருப்படி முனையின் பகுதிப் பாதையின் முதல் நிபிளில் உள்ளது. இவை பின்வரும் விளைவுகளை அளிக்கின்றன:

| ஹெக்ஸ் எழுத்து | பிட்கள் | முனை வகை பகுதி                       | பாதை நீளம் |
| -------------- | ------- | ------------------------------------ | ---------- |
| 0              | 0000    | நீட்டிப்பு                           | இரட்டை     |
| 1              | 0001    | நீட்டிப்பு                           | ஒற்றை      |
| 2              | 0010    | முடிவடையும் (இலை) | இரட்டை     |
| 3              | 0011    | முடிவடையும் (இலை) | ஒற்றை      |

மீதமுள்ள பாதை நீளம் இரட்டைப்படையாக இருந்தால் (`0` அல்லது `2`), மற்றொரு `0` "பேடிங்" நிபிள் எப்போதும் தொடரும்.

```python
    def compact_encode(hexarray):
        term = 1 if hexarray[-1] == 16 else 0
        if term:
            hexarray = hexarray[:-1]
        oddlen = len(hexarray) % 2
        flags = 2 * term + oddlen
        if oddlen:
            hexarray = [flags] + hexarray
        else:
            hexarray = [flags] + [0] + hexarray
        # ஹெக்ஸ்அரே இப்போது ஒரு இரட்டை நீளத்தைக் கொண்டுள்ளது, அதன் முதல் நிபிள் கொடிகளாகும்.
        o = ""
        for i in range(0, len(hexarray), 2):
            o += chr(16 * hexarray[i] + hexarray[i + 1])
        return o
```

எடுத்துக்காட்டுகள்:

```python
    > [1, 2, 3, 4, 5, ...]
    '11 23 45'
    > [0, 1, 2, 3, 4, 5, ...]
    '00 01 23 45'
    > [0, f, 1, c, b, 8, 10]
    '20 0f 1c b8'
    > [f, 1, c, b, 8, 10]
    '3f 1c b8'
```

மெர்கிள் பேட்ரிசியா டிரையில் ஒரு முனையைப் பெறுவதற்கான நீட்டிக்கப்பட்ட குறியீடு இங்கே:

```python
    def get_helper(node_hash, path):
        if path == []:
            return node_hash
        if node_hash == "":
            return ""
        curnode = rlp.decode(node_hash if len(node_hash) < 32 else db.get(node_hash))
        if len(curnode) == 2:
            (k2, v2) = curnode
            k2 = compact_decode(k2)
            if k2 == path[: len(k2)]:
                return get(v2, path[len(k2) :])
            else:
                return ""
        elif len(curnode) == 17:
            return get_helper(curnode[path[0]], path[1:])

    def get(node_hash, path):
        path2 = []
        for i in range(len(path)):
            path2.push(int(ord(path[i]) / 16))
            path2.push(ord(path[i]) % 16)
        path2.push(16)
        return get_helper(node_hash, path2)
```

### எடுத்துக்காட்டு டிரை {#example-trie}

`('do', 'verb')`, `('dog', 'puppy')`, `('doge', 'coins')`, `('horse', 'stallion')` ஆகிய நான்கு பாதை/மதிப்பு ஜோடிகளைக் கொண்ட ஒரு டிரை வேண்டும் என்று வைத்துக்கொள்வோம்.

முதலில், பாதைகள் மற்றும் மதிப்புகள் இரண்டையும் `bytes` ஆக மாற்றுகிறோம். கீழே, _பாதைகளுக்கான_ உண்மையான பைட் பிரதிநிதித்துவங்கள் `<>` ஆல் குறிக்கப்படுகின்றன, இருப்பினும் _மதிப்புகள்_ இன்னும் எளிதாகப் புரிந்துகொள்வதற்காக `''` ஆல் குறிக்கப்படும் சரங்களாகக் காட்டப்படுகின்றன (அவையும் உண்மையில் `bytes` ஆக இருக்கும்):

```
    <64 6f> : 'verb'
    <64 6f 67> : 'puppy'
    <64 6f 67 65> : 'coins'
    <68 6f 72 73 65> : 'stallion'
```

இப்போ நாம உருவாக்கும் trie-க்கு underlying DB-யில் இருக்கும் key/value ஜோடிகள்:

```
    rootHash: [ <16>, hashA ]
    hashA:    [ <>, <>, <>, <>, hashB, <>, <>, <>, [ <20 6f 72 73 65>, 'stallion' ], <>, <>, <>, <>, <>, <>, <>, <> ]
    hashB:    [ <00 6f>, hashC ]
    hashC:    [ <>, <>, <>, <>, <>, <>, hashD, <>, <>, <>, <>, <>, <>, <>, <>, <>, 'verb' ]
    hashD:    [ <17>, [ <>, <>, <>, <>, <>, <>, [ <35>, 'coins' ], <>, <>, <>, <>, <>, <>, <>, <>, <>, 'puppy' ] ]
```

ஒரு முனை மற்றொரு முனைக்குள் குறிப்பிடப்படும்போது, `len(rlp.encode(node)) >= 32` ஆக இருந்தால் `keccak256(rlp.encode(node))` சேர்க்கப்படும், இல்லையெனில் `node` சேர்க்கப்படும். இங்கு `rlp.encode` என்பது [RLP](/developers/docs/data-structures-and-encoding/rlp) குறியாக்கச் செயல்பாடாகும்.

ஒரு டிரையைப் புதுப்பிக்கும்போது, புதிதாக உருவாக்கப்பட்ட முனையின் நீளம் >= 32 ஆக இருந்தால், `(keccak256(x), x)` என்ற கீ/மதிப்பு ஜோடியை ஒரு நிலையான தேடல் அட்டவணையில் சேமிக்க வேண்டும் என்பதை நினைவில் கொள்க. நீளம் < 32 இருந்தா எதுவும் சேமிக்க வேண்டியதில்லை, ஏன்னா f(x) = x reversible.

## எத்தீரியத்தில் டிரைகள் {#tries-in-ethereum}

Ethereum execution layer-ல் இருக்கும் எல்லா Merkle tries-உம் Merkle Patricia Trie (Mpt).

Block header-ல 3 roots இருக்கும்.

1. stateRoot
2. transactionsRoot
3. receiptsRoot

### நிலை டிரை {#state-trie}

Ethereum-ல் ஒரு global state trie இருக்கு. ஒவ்வொரு block process ஆனப்போ அத update ஆகும். அதில், ஒரு `path` எப்போதும்: `keccak256(ethereumAddress)` மற்றும் ஒரு `value` எப்போதும்: `rlp(ethereumAccount)`. குறிப்பாக, ஒரு எத்தீரியம் `account` என்பது `[nonce,balance,storageRoot,codeHash]` கொண்ட 4-உருப்படி வரிசையாகும். இந்த `storageRoot` மற்றொரு பேட்ரிசியா டிரையின் ரூட் என்பதை இந்த கட்டத்தில் குறிப்பிடுவது முக்கியம்:

### சேமிப்பக டிரை {#storage-trie}

சேமிப்பக டிரை என்பது _அனைத்து_ ஒப்பந்தத் தரவுகளும் இருக்கும் இடமாகும். ஒவ்வொரு கணக்கிற்கும் தனித்தனி storage trie உண்டு. ஒரு குறிப்பிட்ட முகவரியில் (address) உள்ள storage இடங்களில் உள்ள மதிப்புகளை பெற, அந்த முகவரி, அந்த storage-இல் சேமிக்கப்பட்டுள்ள தரவின் integer நிலை (position), மற்றும் block ID ஆகியவை தேவையாகும். இவை JSON-RPC ஏபிஐ-ல் வரையறுக்கப்பட்ட `eth_getStorageAt`-க்கு தருமதிப்புகளாக அனுப்பப்படலாம், எ.கா., `0x295a70b2de5e3953354a6a8344e616ed314d7251` முகவரிக்கான சேமிப்பக ஸ்லாட் 0-இல் உள்ள தரவை மீட்டெடுக்க:

```bash
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x0", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x00000000000000000000000000000000000000000000000000000000000004d2"}

```

Storage-இல் உள்ள பிற உறுப்புகளை (elements) பெற சிறிது சிக்கலாக இருக்கும், ஏனெனில் storage trie-இல் உள்ள நிலை (position) முதலில் கணக்கிடப்பட வேண்டும். முகவரி மற்றும் சேமிப்பக நிலை ஆகியவற்றின் `keccak256` ஹாஷாக நிலை கணக்கிடப்படுகிறது, இரண்டும் 32 பைட்டுகள் நீளத்திற்கு பூஜ்ஜியங்களுடன் இடது-பேட் செய்யப்படுகின்றன. உதாரணமாக, `0x391694e7e0b0cce554cb130d723a9d27458f9298` முகவரிக்கான சேமிப்பக ஸ்லாட் 1-இல் உள்ள தரவிற்கான நிலை:

```python
keccak256(decodeHex("000000000000000000000000391694e7e0b0cce554cb130d723a9d27458f9298" + "0000000000000000000000000000000000000000000000000000000000000001"))
```

Geth console-இல் இதை கணக்கிடுவது:

```
// Request
curl -X POST --data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}'
// Result
{
  "id":1,
  "jsonrpc": "2.0",
  "result": {
    startingBlock: '0x384',
    currentBlock: '0x386',
    highestBlock: '0x454'
  }
}
// Or when not syncing
{
  "id":1,
  "jsonrpc": "2.0",
  "result": false
}
```

எனவே, `path` என்பது `keccak256(<6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9>)`. இதைப் பயன்படுத்தி storage trie-இல் இருந்து தரவை பெறலாம்:

```bash
curl -X POST --data '{"jsonrpc":"2.0", "method": "eth_getStorageAt", "params": ["0x295a70b2de5e3953354a6a8344e616ed314d7251", "0x6661e9d6d8b923d5bbaab1b96e1dd51ff6ea2a93520fdc9eb75d059238b8c5e9", "latest"], "id": 1}' localhost:8545

{"jsonrpc":"2.0","id":1,"result":"0x000000000000000000000000000000000000000000000000000000000000162e"}
```

குறிப்பு: இது ஒரு ஒப்பந்தக் கணக்காக இல்லாவிட்டால், ஒரு எத்தீரியம் கணக்கிற்கான `storageRoot` இயல்பாகவே காலியாக இருக்கும்.

### பரிவர்த்தனைகள் டிரை {#transaction-trie}

ஒவ்வொரு பிளாக்கிற்கும் ஒரு தனி பரிவர்த்தனைகள் டிரை உள்ளது, மீண்டும் `(key, value)` ஜோடிகளைச் சேமிக்கிறது. இங்கு ஒரு பாதை: `rlp(transactionIndex)` இது பின்வருவனவற்றால் தீர்மானிக்கப்படும் ஒரு மதிப்புக்கு ஒத்த கீயைக் குறிக்கிறது:

```python
if legacyTx:
  value = rlp(tx)
else:
  value = TxType | encode(tx)
```

இது குறித்த கூடுதல் தகவல்களை [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718) ஆவணத்தில் காணலாம்.

### ரசீதுகள் டிரை {#receipts-trie}

ஒவ்வொரு block-க்கும் தனித்தனி Receipts trie உண்டு. இங்கு ஒரு `path`: `rlp(transactionIndex)`. `transactionIndex` என்பது அது சேர்க்கப்பட்ட பிளாக்கிற்குள் அதன் குறியீட்டெண் ஆகும். Receipts trie ஒருபோதும் update செய்யப்படாது. Transactions trie போலவே, இங்கேவும் current மற்றும் legacy receipts உள்ளன. ஒரு குறிப்பிட்ட receipt-ஐ Receipts trie-இல் இருந்து கேட்க, transaction-இன் index, receipt payload மற்றும் transaction type ஆகியவை தேவையாகும். திருப்பியளிக்கப்பட்ட ரசீது `Receipt` வகையாக இருக்கலாம், இது `TransactionType` மற்றும் `ReceiptPayload` ஆகியவற்றின் இணைப்பாக வரையறுக்கப்படுகிறது அல்லது அது `LegacyReceipt` வகையாக இருக்கலாம், இது `rlp([status, cumulativeGasUsed, logsBloom, logs])` என வரையறுக்கப்படுகிறது.

இது குறித்த கூடுதல் தகவல்களை [EIP 2718](https://eips.ethereum.org/EIPS/eip-2718) ஆவணத்தில் காணலாம்.

## மேலும் வாசிக்க {#further-reading}

- [மாற்றியமைக்கப்பட்ட மெர்கிள் பேட்ரிசியா டிரை — எத்தீரியம் ஒரு நிலையை எவ்வாறு சேமிக்கிறது](https://medium.com/codechain/modified-merkle-patricia-trie-how-ethereum-saves-a-state-e6d7555078dd)
- [எத்தீரியத்தில் மெர்கிளிங்](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)
- [எத்தீரியம் டிரையைப் புரிந்துகொள்ளுதல்](https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/)
