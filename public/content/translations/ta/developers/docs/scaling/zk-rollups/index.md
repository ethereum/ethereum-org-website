---
title: பூஜ்ஜிய-அறிவு ரோல்அப்கள்
description: பூஜ்ஜிய-அறிவு ரோல்அப்களுக்கான ஒரு அறிமுகம்—எத்தேரியம் சமூகத்தால் பயன்படுத்தப்படும் ஒரு அளவிடுதல் தீர்வு.
lang: ta
---

பூஜ்ஜிய-அறிவு ரோல்அப்கள் (ZK-ரோல்அப்கள்) என்பவை லேயர் 2 [அளவிடுதல் தீர்வுகள்](/developers/docs/scaling/) ஆகும், அவை கணினி மற்றும் நிலை-சேமிப்பகத்தை ஆஃப்செயினுக்கு நகர்த்துவதன் மூலம் எத்தேரியம் மெயின்நெட்டில் செயல்திறனை அதிகரிக்கின்றன. ZK-ரோல்அப்ஸ் ஆயிரக்கணக்கான பரிவர்த்தனைகளை ஒரு தொகுப்பில் செயலாக்கி, அதன் பிறகு சில குறைந்தபட்ச சுருக்க தரவுகளை மெய்நெட்டில் பதிவு செய்கின்றன. இந்தச் சுருக்கத் தரவு எதீரியத்தின் நிலையில் மாற்றங்களை வரையறுக்கிறது, மேலும் அந்த மாற்றங்கள் சரியாக உள்ளன என்று உறுதி செய்யும் குறியாக்கச் சான்றுகள் சிலவற்றையும் அளிக்கின்றன.

## முன்னேற்றக் கட்டுரை {#prerequisites}

[எத்தேரியம் அளவிடுதல்](/developers/docs/scaling/) மற்றும் [அடுக்கு 2](/layer-2) குறித்த எங்கள் பக்கத்தை நீங்கள் படித்துப் புரிந்துகொண்டிருக்க வேண்டும்.

## சூறு-அறிவு ரோல்அப்ஸ் என்பது என்ன? {#what-are-zk-rollups}

**பூஜ்ஜிய-அறிவு ரோல்அப்கள் (ZK-ரோல்அப்கள்)** பரிவர்த்தனைகளைத் தொகுப்புகளாகச் சேர்த்து (அல்லது 'ரோல் அப்' செய்து) ஆஃப்செயினில் செயல்படுத்துகின்றன. ஆஃப்செயின் கணக்கீடு, பிளாக்செயினில் பதியப்பட வேண்டிய தரவின் அளவைக் குறைக்கிறது. ZK-ரோல்அப்ஸ் இயக்குநர்கள் ஒவ்வொரு பரிவர்த்தனையையும் தனித்தனியாக அனுப்புவதற்குப் பதிலாக, ஒரு தொகுப்பில் உள்ள அனைத்து பரிவர்த்தனைகளையும் பிரதிநிதித்துவப்படுத்த தேவையான மாற்றங்களின் சுருக்கத்தைப் பதிவுசெய்கின்றனர். அவை தங்கள் மாற்றங்களின் சரியான தன்மையை நிரூபிக்க [செல்லுபடியாகும் தன்மைக்கான சான்றுகளையும்](/glossary/#validity-proof) உருவாக்குகின்றன.

ZK-ரோல்அப்ஸின் நிலை எதீரியம் நெட்வொர்க்கில் நிறுவப்பட்டுள்ள ஸ்மார்ட் ஒப்பந்தத்தால் பராமரிக்கப்படுகிறது. இந்த நிலையைப் புதுப்பிக்க, ZK-ரோல்அப்ஸ் நொடுகள் சரிபார்ப்புக்காக ஒரு உண்மைத்தன்மை சான்றைச் சமர்ப்பிக்க வேண்டும். மேலே கூறியவாறே, உண்மைத்தன்மை சான்று என்பது குறிப்பிட்ட தொகுப்பில் உள்ள பரிவர்த்தனைகளைச் செயலாக்குவதன் மூலம் ரோல்அப்ஸ் முன்மொழிந்த நிலை மாற்றம் உண்மையில் நடந்தது என்ற குறியாக்க உறுதி ஆகும். இதன் பொருள், [ஆப்டிமிஸ்டிக் ரோல்அப்களைப்](/developers/docs/scaling/optimistic-rollups/) போல அனைத்து பரிவர்த்தனை தரவுகளையும் ஆன்செயினில் பதிவிடுவதற்குப் பதிலாக, எத்தேரியத்தில் பரிவர்த்தனைகளை இறுதி செய்ய ZK-ரோல்அப்கள் செல்லுபடியாகும் தன்மைக்கான சான்றுகளை மட்டும் வழங்கினால் போதும்.

ZK-ரோல்அப்ஸிலிருந்து எதீரியத்திற்கு நிதி மாற்றத்தில் எவ்வித தாமதமும் இல்லை, ஏனெனில் ZK-ரோல்அப்ஸ் ஒப்பந்தம் உண்மைத்தன்மை சான்றைச் சரிபார்க்கும்போது வெளியேற்றப் பரிவர்த்தனைகள் உடனடியாகச் செயல்படுத்தப்படுகின்றன. மாறாக, ஆப்டிமிஸ்டிக் ரோல்அப்களிலிருந்து நிதியைத் திரும்பப் பெறுவது தாமதத்திற்கு உட்பட்டது, இது யாரேனும் ஒரு [மோசடிச் சான்றுடன்](/glossary/#fraud-proof) வெளியேறும் பரிவர்த்தனைக்கு சவால் விட அனுமதிக்கிறது.

ZK-ரோல்அப்கள் பரிவர்த்தனைகளை எத்தேரியத்தில் `calldata` ஆக எழுதுகின்றன. `calldata` என்பது ஸ்மார்ட் கான்ட்ராக்ட் செயல்பாடுகளுக்கான வெளிப்புற அழைப்புகளில் சேர்க்கப்படும் தரவு சேமிக்கப்படும் இடமாகும். `calldata`-வில் உள்ள தகவல்கள் பிளாக்செயினில் வெளியிடப்படுகின்றன, இது ரோல்அப்பின் நிலையை யாரேனும் தன்னிச்சையாக மீண்டும் உருவாக்க அனுமதிக்கிறது. ZK-ரோல்அப்ஸ் பரிவர்த்தனை தரவுகளைச் சுருக்க நுட்பங்களைப் பயன்படுத்துகின்றன—உதாரணமாக, கணக்குகள் முகவரியால் değil, ஒரு குறியீட்டால் பிரதிநிதித்துவப்படுத்தப்படுகின்றன, இது 28 பைட்டுகளைக் குறைக்கின்றது. ஆன்செயின் தரவு வெளியீடு ரோல்அப்களுக்கு ஒரு குறிப்பிடத்தக்க செலவாகும், எனவே தரவு சுருக்கமானது பயனர்களுக்கான கட்டணங்களைக் குறைக்கும்.

## ZK-ரோல்அப்ஸ்கள் எதீரியத்துடன் எப்படி இணைக்கின்றன? {#zk-rollups-and-ethereum}

ஒரு ZK-ரோல்அப் சங்கிலி என்பது எத்தேரியம் பிளாக்செயினின் மேல் செயல்படும் ஒரு ஆஃப்செயின் நெறிமுறையாகும், மேலும் இது ஆன்செயின் எத்தேரியம் ஸ்மார்ட் கான்ட்ராக்ட்களால் நிர்வகிக்கப்படுகிறது. ZK-ரோல்அப்கள் மெயின்நெட்டிற்கு வெளியே பரிவர்த்தனைகளைச் செயல்படுத்துகின்றன, ஆனால் சீரான இடைவெளியில் ஆஃப்செயின் பரிவர்த்தனைத் தொகுப்புகளை ஒரு ஆன்செயின் ரோல்அப் கான்ட்ராக்டிற்கு சமர்ப்பிக்கின்றன. இந்தப் பரிவர்த்தனை பதிவு மாற்றமில்லாததாகும், எதீரியம் பிளாக்செயினைப் போன்றே, மற்றும் இது ZK-ரோல்அப்ஸ் சங்கிலியை உருவாக்குகின்றது.

ZK-ரோல்அப்ஸின் மைய கட்டமைப்பு கீழ்கண்ட கூறுகளால் ஆனது:
ஆன்செயின் ஒப்பந்தங்கள்:

1. **ஆன்செயின் கான்ட்ராக்ட்கள்**: குறிப்பிட்டபடி, ZK-ரோல்அப் நெறிமுறை எத்தேரியத்தில் இயங்கும் ஸ்மார்ட் கான்ட்ராக்ட்களால் கட்டுப்படுத்தப்படுகிறது. இது ரோல்அப்ஸ் பிளாக்களைச் சேமிக்கும் முக்கிய ஒப்பந்தத்தை, டெபாசிட்களைப் பதிவுசெய்யும் மற்றும் நிலை மாற்றங்களைக் கண்காணிக்கும் ஒப்பந்தத்தை உட்கொள்கின்றது. மற்றொரு ஆன்செயின் கான்ட்ராக்ட் (சரிபார்ப்பவர் கான்ட்ராக்ட்) பிளாக் தயாரிப்பாளர்களால் சமர்ப்பிக்கப்பட்ட பூஜ்ஜிய-அறிவு சான்றுகளைச் சரிபார்க்கிறது. ஆகவே, எதீரியம் ZK-ரோல்அப்ஸ்களுக்கு அடிப்படை அடுக்கு அல்லது "அடுக்கு 1" ஆகப் பயன்படுகின்றது.

2. **ஆஃப்செயின் மெய்நிகர் இயந்திரம் (VM)**: ZK-ரோல்அப் நெறிமுறை எத்தேரியத்தில் இருந்தாலும், பரிவர்த்தனைச் செயலாக்கம் மற்றும் நிலைச் சேமிப்பு [EVM](/developers/docs/evm/)-ஐச் சாராமல் ஒரு தனி மெய்நிகர் இயந்திரத்தில் நிகழ்கின்றன. இந்த ஆஃப்செயின் VM என்பது ZK-ரோல்அப்பில் உள்ள பரிவர்த்தனைகளுக்கான செயலாக்க சூழலாகும், மேலும் ZK-ரோல்அப் நெறிமுறைக்கான இரண்டாம் நிலை லேயர் அல்லது "லேயர் 2" ஆக செயல்படுகிறது. எத்தேரியம் மெயின்நெட்டில் சரிபார்க்கப்பட்ட செல்லுபடியாகும் தன்மைக்கான சான்றுகள், ஆஃப்செயின் VM-இல் உள்ள நிலை மாற்றங்களின் சரியான தன்மையை உறுதி செய்கின்றன.

ZK-ரோல்அப்கள் "கலப்பின அளவிடுதல் தீர்வுகள்" ஆகும்—தன்னிச்சையாகச் செயல்படும் ஆஃப்செயின் நெறிமுறைகள், ஆனால் எத்தேரியத்திலிருந்து பாதுகாப்பைப் பெறுகின்றன. குறிப்பாக, எதீரியம் நெட்வொர்க் ZK-ரோல்அப்ஸில் நிலை மேம்பாடுகளின் தரக்குறிப்புகளை உறுதிசெய்கின்றது மற்றும் ரோல்அப்ஸின் நிலைக்குப் பின்னால் உள்ள தரவின் கிடைப்பை உறுதிசெய்கின்றது. இதன் விளைவாக, தங்களின் பாதுகாப்புப் பண்புகளுக்குப் பொறுப்பான [சைடுசெயின்கள்](/developers/docs/scaling/sidechains/) அல்லது செல்லுபடியாகும் தன்மைக்கான சான்றுகளுடன் எத்தேரியத்தில் பரிவர்த்தனைகளை சரிபார்த்தாலும் பரிவர்த்தனைத் தரவை வேறு எங்கேனும் சேமிக்கும் [வேலிடியம்கள்](/developers/docs/scaling/validium/) போன்ற முற்றிலும் ஆஃப்செயினில் செயல்படும் அளவிடுதல் தீர்வுகளை விட ZK-ரோல்அப்கள் கணிசமாகப் பாதுகாப்பானவை.

ZK-ரோல்அப்ஸ்கள் கீழ்கண்டவைகளை எதீரியத்தின் முக்கிய நெறிமுறையிலிருந்து நம்புகின்றன:

### தரவு கிடைத்தல் {#data-availability}

ZK-ரோல்அப்கள், ஆஃப்செயினில் செயலாக்கப்பட்ட ஒவ்வொரு பரிவர்த்தனைக்கான நிலைத் தரவையும் எத்தேரியத்திற்கு வெளியிடுகின்றன. இந்தத் தரவுடன், நபர்கள் அல்லது வணிகங்கள் rollup இன் மாநிலத்தை மீண்டும் உருவாக்கி, சங்கத்தைத் தாங்களே சரிபார்க்க முடியும். எத்தேரியம் இந்தத் தரவை நெட்வொர்க்கின் அனைத்துப் பங்கேற்பாளர்களுக்கும் `calldata` ஆகக் கிடைக்கச் செய்கிறது.

ZK-ரோல்அப்கள் அதிக பரிவர்த்தனைத் தரவை ஆன்செயினில் வெளியிடத் தேவையில்லை, ஏனெனில் செல்லுபடியாகும் தன்மைக்கான சான்றுகள் ஏற்கனவே நிலை மாற்றங்களின் நம்பகத்தன்மையைச் சரிபார்க்கின்றன. இருப்பினும், ஆன்செயினில் தரவைச் சேமிப்பது இன்னும் முக்கியமானது, ஏனெனில் இது L2 சங்கிலியின் நிலையை அனுமதியற்ற, சுயாதீனமான சரிபார்ப்புக்கு அனுமதிக்கிறது. இது யாரேனும் பரிவர்த்தனைகளின் தொகுப்புகளைச் சமர்ப்பிக்க அனுமதிப்பதன் மூலம், தீங்கிழைக்கும் ஆபரேட்டர்கள் சங்கிலியைத் தணிக்கை செய்வதையோ அல்லது முடக்குவதையோ தடுக்கிறது.

பயனர்கள் ரோல்அப்புடன் தொடர்பு கொள்ள ஆன்செயின் தேவைப்படுகிறது. மாநில தரவுக்கு அணுகலை இல்லாமல், பங்கேற்பாளர்கள் தங்களுடைய கணக்கு சமநிலையை கேள்வி செய்ய முடியாது அல்லது மாநில தகவல்களைப் பொறுத்தவரை பரிவர்த்தனைகளை (உதா: இழக்கீடுகள்) தொடங்க முடியாது.

### பரிவர்த்தனை இறுதித்தன்மை {#transaction-finality}

Ethereum ZK-rollups க்கு ஒரு நிவாரண அடுக்காகச் செயல்படுகிறது: L2 பரிவர்த்தனைகள் L1 ஒப்புதலுக்குப் பின்னர் மட்டுமே இறுதி செய்யப்படுகின்றன. இது மோசடியான இயக்குனர்கள் சங்கத்தை மாசுபடுத்துவதை (உதா: rollup நிதிகளைத் திருடுவது) தவிர்க்கிறது, ஏனெனில் ஒவ்வொரு பரிவர்த்தனையும் Mainnet இல் அனுமதிக்கப்பட வேண்டும். மேலும், Ethereum பயனர் செயல்பாடுகளை L1 இல் இறுதியாக அமைக்கப்பட்ட பிறகு திரும்ப முடியாததை உறுதிப்படுத்துகிறது.

### தணிக்கை எதிர்ப்பு {#censorship-resistance}

பல ZK-rollups "supernode" (ஒப்பியாளர்) ஐ பரிவர்த்தனைகளைச் செயலாக்க, தொகுதிகளை உருவாக்க, மற்றும் L1 க்கு திருப்ப அனுப்புவதற்காகப் பயன்படுத்துகின்றன. இது திறனாய்வு உறுதி செய்கிறது, ஆனால் சுழல் அதிகரிக்கிறது: மோசடியான ZK-rollup ஒப்பியாளர்கள் தங்களுடைய பரிவர்த்தனைகளைத் தொகுதிகளில் சேர்க்க மறுத்துப் பயனர்களைச் சுழல்கருத்துக்குப் பொறுப்பாளர்கள் கொண்டு வருகின்றனர்.

ஒரு பாதுகாப்பு நடவடிக்கையாக, ZK-rollups பயனர்கள் ஒப்பியாளர் அவர்களைச் சுழல் என நினைத்தால் நேரடியாக Mainnet இல் உள்ள rollup ஒப்பந்தத்திற்கு பரிவர்த்தனைகளைச் சமர்ப்பிக்க அனுமதிக்கின்றன. இதன் மூலம் பயனர்கள் ஒப்பியாளர் அனுமதி இல்லாமல் ZK-rollup இல் இருந்து Ethereum க்கு வெளியேறக் கூடியதாக இருக்கின்றனர்.

## ZK-rollups எவ்வாறு செயல்படுகின்றன? {#how-do-zk-rollups-work}

### பரிவர்த்தனைகள் {#transactions}

ZK-rollup இல் உள்ள பயனர்கள் பரிவர்த்தனைகளைக் கையொப்பமிடுவதுடன், அவற்றை L2 ஒப்பியாளர்களுக்கு செயலாக்க மற்றும் அடுத்த தொகுதியில் சேர்க்கச் சமர்ப்பிக்கின்றனர். சில சந்தர்ப்பங்களில், ஒப்பியாளர் மையமாகிய நிலைமையுடன் செயல்படும் Sequencer என்று அழைக்கப்படும், அவர்கள் பரிவர்த்தனைகளைச் செயலாக்கி, தொகுதிகளில் திரட்டி, L1 க்கு சமர்ப்பிக்கின்றனர். இந்த முறைமையில் Sequencer என்பது L2 பிளாக்களை உருவாக்குவதற்கும் ZK-rollup ஒப்பந்தத்தில் rollup பரிவர்த்தனைகளைச் சேர்ப்பதற்கும் ஒரே தனி அங்கீகாரம் பெற்ற சொந்த அமைப்பாகும்.

மற்ற ZK-ரோல்அப்கள் ஒரு [பங்குச் சான்று](/developers/docs/consensus-mechanisms/pos/) சரிபார்ப்பாளர் தொகுப்பைப் பயன்படுத்துவதன் மூலம் ஆபரேட்டர் பங்கை சுழற்சி முறையில் மாற்றலாம். எதிர்பார்க்கப்படும் ஒப்பியாளர்கள் rollup ஒப்பந்தத்தில் நிதிகளைச் செலுத்துவர், ஒவ்வொரு பங்கின் அளவுக்குப் பங்குதாரரின் அடுத்த rollup தொகுதியைப் உருவாக்கத் தேர்ந்தெடுக்கப்படுவதற்கான வாய்ப்புகளைப் பாதிக்கின்றது. ஒப்பியாளர் மோசடியான செயல்பாடு செய்வதாக இருந்தால் அவர்களின் பங்கு குறைக்கப்படும், இது அவர்கள் செல்லுபடியாகும் பிளாக்களை வெளியிடும்படி தூண்டுகிறது.

#### ZK-ரோல்அப்கள் எத்தேரியத்தில் பரிவர்த்தனைத் தரவை எப்படி வெளியிடுகின்றன {#how-zk-rollups-publish-transaction-data-on-ethereum}

விளக்கியபடி, பரிவர்த்தனைத் தரவு எத்தேரியத்தில் `calldata` ஆக வெளியிடப்படுகிறது. `calldata` என்பது ஒரு ஸ்மார்ட் கான்ட்ராக்டில் உள்ள ஒரு தரவுப் பகுதியாகும், இது ஒரு செயல்பாட்டிற்கு வாதங்களை அனுப்பப் பயன்படுகிறது மற்றும் [நினைவகத்தைப்](/developers/docs/smart-contracts/anatomy/#memory) போலவே செயல்படுகிறது. `calldata` எத்தேரியத்தின் நிலையின் ஒரு பகுதியாகச் சேமிக்கப்படவில்லை என்றாலும், அது எத்தேரியம் சங்கிலியின் [வரலாற்றுப் பதிவுகளின்](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html?highlight=memory#logs) ஒரு பகுதியாக ஆன்செயினில் நீடிக்கிறது. `calldata` எத்தேரியத்தின் நிலையைப் பாதிக்காது, இது ஆன்செயினில் தரவைச் சேமிப்பதற்கான ஒரு மலிவான வழியாகும்.

`calldata` என்ற முக்கியச்சொல் பெரும்பாலும் ஒரு பரிவர்த்தனையால் அழைக்கப்படும் ஸ்மார்ட் கான்ட்ராக்ட் முறையை அடையாளம் காட்டுகிறது, மேலும் முறைக்கான உள்ளீடுகளை ஒரு தன்னிச்சையான பைட் வரிசையின் வடிவத்தில் வைத்திருக்கிறது. ZK-ரோல்அப்கள் சுருக்கப்பட்ட பரிவர்த்தனைத் தரவை ஆன்செயினில் வெளியிட `calldata`-வைப் பயன்படுத்துகின்றன; ரோல்அப் ஆபரேட்டர் ரோல்அப் கான்ட்ராக்டில் தேவையான செயல்பாட்டை அழைப்பதன் மூலம் ஒரு புதிய தொகுப்பை எளிமையாகச் சேர்க்கிறார், மற்றும் சுருக்கப்பட்ட தரவை செயல்பாட்டு வாதங்களாக அனுப்புகிறார். இது பயனர்களுக்கான செலவுகளைக் குறைக்க உதவுகிறது, ஏனெனில் ரோல்அப் கட்டணங்களின் பெரும்பகுதி ஆன்செயினில் பரிவர்த்தனைத் தரவைச் சேமிக்கச் செல்கிறது.

### நிலை அர்ப்பணிப்புகள் {#state-commitments}

L2 கணக்குகள் மற்றும் இருப்புகளை உள்ளடக்கிய ZK-ரோல்அப்பின் நிலை, ஒரு [மெர்க்கல் மரமாக](/whitepaper/#merkle-trees) குறிப்பிடப்படுகிறது. மெர்க்கல் மரத்தின் மூலத்தின் (மெர்க்கல் ரூட்) ஒரு குறியாக்க ஹேஷ் ஆன்செயின் கான்ட்ராக்டில் சேமிக்கப்படுகிறது, இது ரோல்அப் நெறிமுறையை ZK-ரோல்அப்பின் நிலையில் ஏற்படும் மாற்றங்களைக் கண்காணிக்க அனுமதிக்கிறது.

புதிய பரிவர்த்தனை தொகுப்பு செயலாக்கப்பட்ட பிறகு rollup ஒரு புதிய நிலைக்கு மாறுகிறது. நிலை மாற்றத்தைத் தொடங்கிய ஆபரேட்டர், ஒரு புதிய நிலை மூலத்தைக் கணக்கிட்டு அதை ஆன்செயின் கான்ட்ராக்டில் சமர்ப்பிக்க வேண்டும். தொகுப்புடன் தொடர்புடைய சரியான அடையாளம் (validity proof) உறுதிப்படுத்தப்பட்டால், புதிய மெர்கிள் ரூட் ZK-rollup இன் அதிகாரப்பூர்வ நிலை ரூட்டாக மாறுகிறது.

நிலை ரூட்டுகளை கணக்கீடு செய்வதற்காக, ZK-rollup இயக்குபவர் ஒரு தொகுப்பு ரூட்டையும் (batch root)—அதாவது, ஒரு தொகுப்பில் உள்ள அனைத்து பரிவர்த்தனைகளையும் அடங்கிய ஒரு மெர்கிள் மரத்தின் ரூட்டை உருவாக்குகிறார். புதிய தொகுப்பு சமர்ப்பிக்கப்பட்டபோது, rollup ஒப்பந்தம் தொகுப்பு ரூட்டைச் சேமிக்கிறது, இதனால் பயனாளர்கள் ஒரு பரிவர்த்தனை (உதாரணமாக, ஒரு பெறுமதி எடுப்பு கோரிக்கை) தொகுப்பில் சேர்க்கப்பட்டதை நிரூபிக்க முடியும். பயனர்கள் பரிவர்த்தனை விவரங்கள், தொகுப்பு மூலம், மற்றும் உள்ளடக்கப் பாதையைக் காட்டும் ஒரு [மெர்க்கல் சான்றையும்](/developers/tutorials/merkle-proofs-for-offline-data-integrity/) வழங்க வேண்டும்.

### செல்லுபடியாகும் தன்மைக்கான சான்றுகள் {#validity-proofs}

ZK-rollup இயக்குபவர் L1 ஒப்பந்தத்திற்கு சமர்ப்பிக்கும் புதிய நிலை ரூட், rollup இன் நிலையின் புதுப்பிப்புகளின் விளைவாகும். உதாரணமாக, அலீஸ் பாபுக்கு 10 டோக்கன்களை அனுப்பினால், இயக்குபவர் அலீஸ் இன் இருப்பை 10 ஆகக் குறைத்துக் கொண்டு, பாபின் இருப்பை 10 ஆக அதிகரிக்கிறார். பின்னர் ஆபரேட்டர் புதுப்பிக்கப்பட்ட கணக்குத் தரவை ஹேஷ் செய்து, ரோல்அப்பின் மெர்க்கல் மரத்தை மீண்டும் உருவாக்கி, புதிய மெர்க்கல் மூலத்தை ஆன்செயின் கான்ட்ராக்டிற்கு சமர்ப்பிக்கிறார்.

ஆனால், rollup ஒப்பந்தம், இயக்குபவர், rollup இன் நிலைக்குச் செய்யப்பட்ட சரியான புதுப்பிப்புகளின் விளைவாகப் புதிய மெர்கிள் ரூட் உருவாகியதாக நிரூபிக்கும் வரை, பரிந்துரைக்கப்பட்ட நிலை உறுதிப்பாட்டை தானாகவே ஏற்காது. ZK-rollup இயக்குபவர் இதைச் செய்யும்போது ஒரு validity proof உருவாக்குகிறார், இது குழுவாக்கப்பட்ட பரிவர்த்தனைகளின் சரிவர்த்தனத்தை (correctness) சரிபார்க்கும் சுருக்கமான குறியாக்க உறுதிப்பாடாகும்.

Validity proofs என்பது ஒரு கூற்றின் சரிவர்த்தனத்தை, கூற்றை வெளியிடாமல் நிரூபிக்க அனுமதிக்கின்றன—அதனால், இவற்றை "zero-knowledge proofs" என்றும் அழைக்கிறார்கள். ZK-ரோல்அப்கள், எத்தேரியத்தில் பரிவர்த்தனைகளை மீண்டும் செயல்படுத்தத் தேவையில்லாமல், ஆஃப்செயின் நிலை மாற்றங்களின் சரியான தன்மையை உறுதிப்படுத்த செல்லுபடியாகும் தன்மைக்கான சான்றுகளைப் பயன்படுத்துகின்றன. இந்தச் சான்றுகள் [ZK-SNARK](https://arxiv.org/abs/2202.06877) (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) அல்லது [ZK-STARK](https://eprint.iacr.org/2018/046) (Zero-Knowledge Scalable Transparent Argument of Knowledge) வடிவத்தில் வரலாம்.

SNARK-கள் மற்றும் STARK-கள் இரண்டும் ZK-ரோல்அப்களில் ஆஃப்செயின் கணக்கீட்டின் ஒருமைப்பாட்டைச் சான்றளிக்க உதவுகின்றன, இருப்பினும் ஒவ்வொரு சான்று வகைக்கும் தனித்துவமான அம்சங்கள் உள்ளன.

**ZK-SNARK-கள்**

ZK-SNARK நெறிமுறையானது செயல்பட, பொதுவான குறிப்புக் கோவை (Common Reference String - CRS) உருவாக்குவது அவசியம்: CRS, validity proofs ஐ நிரூபிப்பதற்கும் சரிபார்ப்பதற்கும் பொது அளவுருக்களை (public parameters) வழங்குகிறது. நிரூபிக்கும் முறையின் பாதுகாப்பு, CRS அமைப்பின் மீது வழங்குகிறது; பொது அளவுருக்களை உருவாக்கப் பயன்படுத்தப்படும் தகவல் தீயநோக்குடையவர்களின் கையில் விழுந்தால், அவர்கள் தவறான validity proofs ஐ உருவாக்க முடியும்.

சில ZK-ரோல்அப்கள், ZK-SNARK சுற்றுக்கான பொது அளவுருக்களை உருவாக்க, நம்பகமான நபர்களை உள்ளடக்கிய ஒரு [பல-தரப்பு கணக்கீட்டு விழாவை (MPC)](https://zkproof.org/2021/06/30/setup-ceremonies/amp/) பயன்படுத்துவதன் மூலம் இந்தப் பிரச்சனையைத் தீர்க்க முயற்சிக்கின்றன. ஒவ்வொரு தரப்பும் சில சீரற்ற தன்மையை (randomness) (இதை "toxic waste" என்று அழைக்கின்றனர்) உருவாக்கியபின்னர் அதை உடனடியாக அழிக்க வேண்டும்.

நம்பகமான அமைப்புகள் (Trusted setups) பயன்படுத்தப்படுகின்றன, ஏனெனில் அவை CRS அமைப்பின் பாதுகாப்பை அதிகரிக்கின்றன. ஒரே ஒரு நேர்மையான பங்கேற்பாளர் கூடத் தனது உள்ளீட்டை அழித்தால், ZK-SNARK முறையின் பாதுகாப்பு உறுதியாகும். இருப்பினும், இந்த அணுகுமுறை, அமைப்பின் பாதுகாப்பு உறுதிப்பாடுகளைப் பாதிக்காமல் அவர்கள் எடுத்த சீரற்ற தன்மையை அழிப்பதாக நம்புவதற்கு தேவையானது.

நம்பிக்கை சார்ந்த முன்னெண்ணங்களைத் தாண்டி, ZK-SNARKs, சின்ன proof அளவுகள் மற்றும் மாறாத நேர சரிபார்ப்பிற்காகப் பிரபலமாக உள்ளன. L1 இல் proof சரிபார்ப்பு, ZK-rollup செயல்பாட்டின் பெரிய செலவாக அமையுமதால், L2 கள், Mainnet இல் proof களை விரைவாகவும் மலிவாகவும் சரிபார்க்க ZK-SNARKs ஐப் பயன்படுத்துகின்றன.

**ZK-STARK-கள்**

ZK-SNARK-களைப் போலவே, ZK-STARK-களும் உள்ளீடுகளை வெளிப்படுத்தாமல் ஆஃப்செயின் கணக்கீட்டின் செல்லுபடியாகும் தன்மையை நிரூபிக்கின்றன. ஆனால், ZK-STARKs, ZK-SNARKs க்கு மேம்படுத்தப்பட்டதாகக் கருதப்படுகின்றன, ஏனெனில் அவற்றின் பரந்த அளவிலும் தெளிவான அமைப்பிலும் (scalability and transparency) இருக்கும்.

ZK-STARKs, 'தெளிவானவை' (transparent) எனக் கருதப்படுகின்றன, ஏனெனில் அவை பொதுவான குறிப்புக் கோவை (CRS) என்ற நம்பகமான அமைப்பைத் தேவை இல்லாமல் செயல்பட முடியும். இதற்குப் பதிலாக, ZK-STARKs, பொது சான்றளிக்கக்கூடிய சீரற்ற தன்மையை (publicly verifiable randomness) நம்பி, proof களை உருவாக்கவும் சரிபார்க்கவும் தேவையான அளவுருக்களை அமைக்கின்றன.

ZK-STARK-கள் அதிக அளவிடும் தன்மையையும் வழங்குகின்றன, ஏனெனில் செல்லுபடியாகும் தன்மைக்கான சான்றுகளை நிரூபிக்கவும் சரிபார்க்கவும் தேவைப்படும் நேரம், அடிப்படை கணக்கீட்டின் சிக்கலுடன் தொடர்புடையதாக _குவாசிலீனியராக_ அதிகரிக்கிறது. ZK-SNARK-களுடன், நிரூபித்தல் மற்றும் சரிபார்ப்பு நேரங்கள் அடிப்படை கணக்கீட்டின் அளவிற்கு ஏற்ப _நேரியல் ரீதியாக_ அளவிடப்படுகின்றன. இதன் பொருளாக, பெரிய தரவுத்தொகுப்புகள் அடங்கியபோது, ZK-STARKs, நிரூபிக்கவும் சரிபார்க்கவும் ZK-SNARKs க்கு விடக் குறைவான நேரத்தைப் பயன்படுத்துகின்றன, இதனால் அவை அதிகபரிமாண பயன்பாடுகளுக்கு (high-volume applications) பயன்படுகின்றன.

ZK-STARKs, quantum கணினிகளுக்கு எதிராகவும் பாதுகாப்பாக உள்ளன, அன்றைய ZK-SNARKs இல் பயன்படுத்தப்படும் Elliptic Curve Cryptography (ECC) இது quantum கணினி தாக்குதல்களுக்குப் பாதிக்கப்படும் என்று பரவலாக நம்பப்படுகிறது. ZK-STARKs இன் குறைபாடு என்னவெனில், அவை மிகப்பெரிய proof அளவுகளை உருவாக்குகின்றன, இதனால் Ethereum இல் அவற்றைச் சரிபார்க்க அதிக செலவாகின்றது.

#### Validity Proofs எப்படி ZK-rollups இல் செயல்படுகின்றன? {#validity-proofs-in-zk-rollups}

##### சான்று உருவாக்கம்

பரிவர்த்தனைகளை ஏற்கும் முன், operator வழக்கமான சரிபார்ப்புகளைச் செய்ய வேண்டும். இதில் அடங்குவது:

- அனுப்புநர் மற்றும் பெறுநர் கணக்குகள் நிலைமரத்தின் (state tree) ஒரு பகுதியாக இருக்கின்றனவா என்பதை உறுதிசெய்வது.
- அனுப்புநரின் கணக்கில் பரிவர்த்தனை செய்யப் போதுமான நிதி உள்ளது என்பதை உறுதிசெய்வது.
- பரிவர்த்தனை சரியானது, மற்றும் அந்தப் பரிவர்த்தனை rollup இல் அனுப்புநரின் பொது விசையுடன் பொருந்துகிறது என்பதை உறுதிசெய்வது.
- அனுப்புநரின் nonce சரியானது, இவை போன்றவை.

ZK-rollup node க்கு போதுமான பரிவர்த்தனைகள் கிடைத்த பிறகு, அவை அனைத்தையும் ஒரு தொகுப்பாக (batch) சேர்த்து, proving circuit க்கு தேவையான உள்ளீடுகளைச் (inputs) சேர்த்துவிடுகிறது, இது ஒரு சுருக்கமான ZK-proof ஆகச் சுருக்கப்படும். இதில் அடங்குவது:

- அந்த batch இல் உள்ள அனைத்து பரிவர்த்தனைகளையும் அடங்கும் Merkle tree root.
- அந்த batch இல் உள்ள பரிவர்த்தனைகளைச் சரிபார்க்கவும், அவற்றின் சேர்க்கையை (inclusion) நிரூபிக்கவும் Merkle proofs.
- பரிவர்த்தனைகளில் உள்ள அனுப்புநர்-பெறுநர் ஜோடிகளுக்கு (sender-receiver pair) Merkle proofs, அவை rollup இன் நிலைமரத்தின் (state tree) பகுதியாக உள்ளதை நிரூபிக்க.
- இடைநிலை நிலைமூலங்களை (intermediate state roots) சேர்த்து, ஒவ்வொரு பரிவர்த்தனைக்கு state updates ஐச் (உதாரணமாக, அனுப்புநர் கணக்குகளைக் குறைத்தல் மற்றும் பெறுநர் கணக்குகளை அதிகரித்தல்) செயல்படுத்திய பிறகு state root இல் ஏற்பட்ட மாற்றங்களை உறுதி செய்தல்.

Proving circuit ஒவ்வொரு பரிவர்த்தனையையும் "loop" செய்து validity proof ஐ கணக்கிடும், இது operator பரிவர்த்தனையைச் செயல்படுத்துவதற்கு முன் முடித்த அனைத்து சரிபார்ப்புகளையும் திரும்பச் செய்யும். முதலில், கொடுக்கப்பட்ட Merkle proof பயன்படுத்தி அனுப்புநரின் கணக்கு நிலைமூலத்தின் (state root) ஒரு பகுதியாக உள்ளதா என்பதைக் உறுதிசெய்யும். பின்னர், அனுப்புநரின் நிலுவையை (balance) குறைத்து, அவர்களின் nonce ஐ அதிகரித்து, புதுப்பிக்கப்பட்ட கணக்குத் தரவுகளை (account data) ஹாஷ் செய்து, Merkle proof உடன் இணைத்துப் புதிய Merkle root ஐ உருவாக்கும்.

இந்த Merkle root, ZK-rollup இல் நிகழ்ந்த ஒரே மாற்றத்தைப் பிரதிபலிக்கிறது: அனுப்புநரின் நிலுவையும் nonce இலும் ஏற்பட்ட மாற்றம். கணக்கின் இருப்பு (existence) நிரூபிக்கப் பயன்படுத்தப்படும் Merkle proof ஐப் பயன்படுத்தி புதிய state root ஐ பெறுவதால் இது சாத்தியமாகிறது.

Proving circuit இதே செயல்முறையைப் பெறுநரின் கணக்கிலும் செய்யும். Intermediate state root கீழ் பெறுநரின் கணக்கு இருக்கிறதா என்று Merkle proof ஐப் பயன்படுத்தி சரிபார்த்து, அவர்களின் நிலுவையை அதிகரித்து, கணக்குத் தரவுகளை மீண்டும் ஹாஷ் செய்து, Merkle proof உடன் இணைத்துப் புதிய state root ஐ உருவாக்கும்.

இந்தச் செயல்முறை ஒவ்வொரு பரிவர்த்தனைக்கும் மீண்டும் மீண்டும் நடைபெறும்; ஒவ்வொரு "loop" இலும் அனுப்புநரின் கணக்கைப் புதுப்பிப்பதன் மூலம் ஒரு புதிய state root உருவாகின்றது, பின்னர் பெறுநரின் கணக்கைப் புதுப்பிப்பதன் மூலம் மற்றொரு புதிய root உருவாகின்றது. இது Zk-rollup இன் state tree இல் ஒரு பகுதியை மாற்றுவது போன்று ஒவ்வொரு state root update ஐயும் பிரதிபலிக்கிறது.

ZK-proving circuit, பரிவர்த்தனை தொகுப்பின் (transaction batch) முழுவதையும் பின்தொடர்ந்து, இறுதியாக அமைக்கப்பட்ட state root க்கு பிறகு நிகழும் state root மாற்றங்களின் தொடரைப் (sequence) சரிபார்க்கின்றது. இறுதியாகக் கணக்கிடப்படும் Merkle root ZK-rollup இன் புதிய canonical state root ஆக மாறும்.

##### சான்று சரிபார்ப்பு

State updates சரியாக உள்ளதா என்பதை proving circuit சரிபார்த்த பின், L2 operator கணக்கிட்ட validity proof ஐ L1 இல் உள்ள verifier contract க்கு சமர்ப்பிக்கின்றது. Contract இன் verification circuit proof ஐ சரிபார்த்து, proof இல் உள்ள public inputs ஐயும் சரிபார்க்கின்றது:

- **முன்-நிலை மூலம்**: ZK-ரோல்அப்பின் பழைய நிலை மூலம் (அதாவது, தொகுக்கப்பட்ட பரிவர்த்தனைகள் செயல்படுத்தப்படுவதற்கு முன்பு), இது L2 சங்கிலியின் கடைசியாக அறியப்பட்ட செல்லுபடியாகும் நிலையைப் பிரதிபலிக்கிறது.

- **பின்-நிலை மூலம்**: ZK-ரோல்அப்பின் புதிய நிலை மூலம் (அதாவது, தொகுக்கப்பட்ட பரிவர்த்தனைகள் செயல்படுத்தப்பட்ட பிறகு), இது L2 சங்கிலியின் புதிய நிலையைப் பிரதிபலிக்கிறது. Proving circuit இல் state updates ஐச் செயல்படுத்திய பிறகு பெறப்பட்ட இறுதி root தான் இந்த post-state root ஆகும்.

- **தொகுப்பு மூலம்**: தொகுப்பில் உள்ள பரிவர்த்தனைகளை _மெர்க்கலைஸ்_ செய்து மரத்தின் மூலத்தை ஹேஷ் செய்வதன் மூலம் பெறப்பட்ட தொகுப்பின் மெர்க்கல் மூலம்.

- **பரிவர்த்தனை உள்ளீடுகள்**: சமர்ப்பிக்கப்பட்ட தொகுப்பின் ஒரு பகுதியாக செயல்படுத்தப்பட்ட பரிவர்த்தனைகளுடன் தொடர்புடைய தரவு.

Proof circuit ஐ திருப்திப்படுத்தினால் (அதாவது, இது சரியாக இருந்தால்), அது rollup ஐ பழைய நிலைமற்றை (pre-state root மூலம் cryptographically குறியாக்கப்பட்ட) முதல் புதிய நிலைமற்றை (post-state root மூலம் cryptographically குறியாக்கப்பட்ட) நோக்கி மாறும் சரியான பரிவர்த்தனைகளின் தொடரைக் குறிக்கின்றது. Pre-state root rollup contract இல் சேமிக்கப்பட்ட root உடன் பொருந்தினால், மற்றும் proof சரியாக இருந்தால், rollup contract proof இல் உள்ள post-state root ஐ எடுத்துக்கொண்டு அதன் state tree ஐ புதுப்பித்து rollup இன் மாற்றப்பட்ட நிலையைப் பிரதிபலிக்கின்றது.

### உள்ளீடுகள் மற்றும் வெளியேற்றங்கள் {#entries-and-exits}

பயனர்கள் ZK-rollup இல் நுழைவதற்காக L1 தொடரில் நிறுவப்பட்ட rollup contract இல் டோக்கன்களை வைப்பு செய்கின்றனர். இந்தப் பரிவர்த்தனைை குவியப்படுகின்றது, ஏனெனில் செயற்பாட்டாளர்களே rollup contract க்கு பரிவர்த்தனைகளைச் சமர்ப்பிக்க முடியும்.

என்றால், தாமதமாக்கப்பட்ட வைப்பு வரிசை நிரம்பத் தொடங்கினால், ZK-rollup செயற்பாட்டாளர் வைப்பு பரிவர்த்தனைகளை எடுத்துக்கொண்டு rollup contract க்கு சமர்ப்பிக்கும். பயனர் இன் நிதிகள் rollup இல் உள்ளவுடன், அவர்கள் செயற்பாட்டாளருக்கு பரிவர்த்தனைகளை அனுப்புவதன் மூலம் பரிவர்த்தனை செய்யத் தொடங்கலாம். பயனர்கள் தங்கள் கணக்குத் தரவுகளை ஹாஷ் செய்து, ஹாஷை rollup contract க்கு அனுப்பி, தற்போதைய நிலைமற்றை எதிர்க்க Merkle proof ஐ வழங்கி rollup இல் இருப்புகளை சரிபார்க்கலாம்.

ZK-rollup இல் இருந்து L1 க்கு விலகுதல். பயனர் வெளியீட்டு பரிவர்த்தனையைத் தங்கள் rollup ஆஸ்திகளை ஒரு குறிப்பிட்ட கணக்குக்கு எரிக்க அனுப்புவதன் மூலம் ஆரம்பிக்கிறார். ஆபரேட்டர் அடுத்த தொகுப்பில் பரிவர்த்தனையைச் சேர்த்தால், பயனர் ஆன்செயின் கான்ட்ராக்டிற்கு திரும்பப் பெறும் கோரிக்கையைச் சமர்ப்பிக்கலாம். இந்த விலகல் கோரிக்கை பின்வரும் அம்சங்களை உள்ளடக்குகிறது:

- பயனர் பரிவர்த்தனையை எரிக்கும் கணக்கில் சேர்க்கப்பட்டதை ஆதாரமாகக் கூறும் Merkle proof

- பரிவர்த்தனை தரவுகள்

- Batch root

- வைப்பு செய்யப்பட்ட நிதிகளைப் பெறுவதற்கான L1 முகவரி

Rollup contract பரிவர்த்தனை தரவுகளை ஹாஷ் செய்கிறது, batch root உள்ளதா என்பதை சரிபார்க்கிறது, மற்றும் Merkle proof ஐப் பயன்படுத்தி பரிவர்த்தனை ஹாஷ் batch root இல் உள்ளதா என்பதை சரிபார்க்கிறது. அதன் பிறகு, contract வெளியீட்டு பரிவர்த்தனையைச் செய்கிறது மற்றும் பயனரின் தேர்ந்த முகவரிக்கு L1 இல் நிதிகளை அனுப்புகிறது.

## ZK-ரோல்அப்களும் EVM இணக்கத்தன்மையும் {#zk-rollups-and-evm-compatibility}

ஆப்டிமிஸ்டிக் ரோல்அப்களைப் போலல்லாமல், ZK-ரோல்அப்கள் [எத்தேரியம் மெய்நிகர் இயந்திரத்துடன் (EVM)](/developers/docs/evm/) உடனடியாகப் பொருந்தக்கூடியவை அல்ல. பொதுவாக EVM கணிப்புகளை circuit கள் மூலம் நிலைமையாக்குவது, எளிய கணிப்புகளை (முன்பு விவரிக்கப்பட்ட டோக்கன் பரிமாற்றம் போன்றவை) நிலைமையாக்குவதற்கும் ஒப்பிடும்போது கடினமாகவும் வளங்களைப் பயன்படுத்துவதற்குமானதாகும்.

இருப்பினும், [பூஜ்ஜிய-அறிவு தொழில்நுட்பத்தில் ஏற்பட்டுள்ள முன்னேற்றங்கள்](https://hackmd.io/@yezhang/S1_KMMbGt#Why-possible-now) EVM கணக்கீட்டைப் பூஜ்ஜிய-அறிவு சான்றுகளில் பொதிவதில் புதுப்பிக்கப்பட்ட ஆர்வத்தைத் தூண்டுகின்றன. இந்த முயற்சிகள், நிரலின் செயல்திறனைச் சரிபார்க்கும் திறனுடன் ஒரு நான்கு அறிவு EVM (zkEVM) செயல்பாட்டை உருவாக்க முக்கையாக உள்ளன. ஒரு zkEVM, செயல்திறனைச் சரிபார்க்க circuit களில் EVM opcode களை மீண்டும் உருவாக்குகிறது, இது அறிவு ஒழுங்குகளை நிரல் சாணாக்குகளைச் செயல்படுத்த அனுமதிக்கிறது.

EVM போல, zkEVM கணிப்புகள் எஞ்சிய உள்ளீடுகளைச் செயல்படுத்திய பிறகு நிலைகளை மாறுகிறது. வேறுபாடு என்னவென்றால், zkEVM, நிரல் செயல்திறனில் ஒவ்வொரு படியையும் சரிபார்க்க நான்கு அறிவு ஆதாரங்களை உருவாக்குகிறது. நிலைமையாக்கப்பட்ட ஆதாரங்கள் VM இன் நிலையை (நினைவகம், ஸ்டாக், சேமிப்பு) மற்றும் கணிப்பு (எனவே, செயல்பாடு சரியான opcode களை அழைத்ததா மற்றும் அவற்றைப் பொறுத்து செயல்படுத்தினா?) சரிபார்க்க முடியும்.

EVM-இற்கு பொருந்தக்கூடிய ZK-rollups அறிமுகம், நான்கு அறிவு ஆதாரங்களின் அளவீட்டு மற்றும் பாதுகாப்பு உத்திகளைப் பயன்படுத்த நிபுணர்களுக்கு உதவ இருக்கும் என்று எதிர்பார்க்கப்படுகிறது. முக்கியமாக, மைய எதரியம் கட்டமைப்புடன் பொருந்துவதால், டெவலப்பர்கள் பழக்கமான (மற்றும் போராடிய) கருவிகள் மற்றும் மொழிகளைப் பயன்படுத்தி ZK-friendly dapps ஐ உருவாக்க முடியும்.

## ZK-rollup கட்டணங்கள் எவ்வாறு வேலை செய்கின்றன? {#how-do-zk-rollup-fees-work}

ZK-rollups இல் பயனர்கள் நிகழ்வுகளைச் செய்ய எவ்வளவு கட்டணத்தைச் செலுத்துகிறார்கள் என்பது எதரியம் Mainnet போலவே, கட்டணத்திற்கு சார்ந்தது. ஆனால், L2 இல் கட்டணங்கள் மாறுபட்ட முறையில் செயல்படுகின்றன மற்றும் கீழ்காணும் செலவுகளைப் பொறுத்தவை:

1. **நிலை எழுதுதல்**: எத்தேரியத்தின் நிலைக்கு எழுதுவதற்கு ஒரு நிலையான செலவு உள்ளது (அதாவது, எத்தேரியம் பிளாக்செயினில் ஒரு பரிவர்த்தனையைச் சமர்ப்பித்தல்). ZK-rollups இந்தச் செலவைக் குறைப்பதற்காக நிகழ்வுகளைக் குழுவாகச் சேர்க்கின்றன மற்றும் நிலையான செலவுகளைப் பல பயனர்களிடையே பகிர்ந்தளிக்கின்றன.

2. **தரவு வெளியீடு**: ZK-ரோல்அப்கள் ஒவ்வொரு பரிவர்த்தனைக்குமான நிலைத் தரவை எத்தேரியத்தில் `calldata` ஆக வெளியிடுகின்றன. `calldata` செலவுகள் தற்போது [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) ஆல் நிர்வகிக்கப்படுகின்றன, இது `calldata`-இன் பூஜ்ஜியம் அல்லாத பைட்டுகளுக்கு 16 கேஸ் செலவையும் பூஜ்ஜிய பைட்டுகளுக்கு 4 கேஸ் செலவையும் முறையே குறிப்பிடுகிறது. ஒவ்வொரு பரிவர்த்தனைக்கும் செலுத்தப்படும் செலவானது, அதற்காக எவ்வளவு `calldata` ஆன்செயினில் பதியப்பட வேண்டும் என்பதைப் பொறுத்தது.

3. **L2 ஆபரேட்டர் கட்டணங்கள்**: இது, பரிவர்த்தனைகளைச் செயலாக்குவதில் ஏற்படும் கணக்கீட்டுச் செலவுகளுக்கான இழப்பீடாக ரோல்அப் ஆபரேட்டருக்கு செலுத்தப்படும் தொகையாகும், இது எத்தேரியம் மெயின்நெட்டில் உள்ள [பரிவர்த்தனை "முன்னுரிமைக் கட்டணங்கள் (டிப்ஸ்)"](/developers/docs/gas/#how-are-gas-fees-calculated) போலவே ஆகும்.

4. **சான்று உருவாக்கம் மற்றும் சரிபார்ப்பு**: ZK-ரோல்அப் ஆபரேட்டர்கள் பரிவர்த்தனைத் தொகுப்புகளுக்கு செல்லுபடியாகும் தன்மைக்கான சான்றுகளை உருவாக்க வேண்டும், இது வளம்-செறிவு மிக்கதாகும். Mainnet இல் நான்கு அறிவு ஆதாரங்களைச் சரிபார்க்கவும் gas (~ 500,000 gas) செலவாகும்.

நிகழ்வுகளைக் குழுவாகச் சேர்ப்பதைத் தவிர, ZK-rollups பயனர்களுக்கான கட்டணங்களைச் சுருக்கம் செய்யும். எத்தேரியம் ZK-ரோல்அப்களைப் பயன்படுத்துவதற்கு எவ்வளவு செலவாகிறது என்பதன் [நிகழ்நேர மேலோட்டத்தை](https://l2fees.info/) நீங்கள் காணலாம்.

## ZK-rollups எதரியத்தை எவ்வாறு அளவீடு செய்கின்றன? {#scaling-ethereum-with-zk-rollups}

### பரிவர்த்தனைத் தரவு சுருக்கம் {#transaction-data-compression}

ZK-ரோல்அப்கள் கணக்கீட்டை ஆஃப்செயினுக்கு எடுத்துச் செல்வதன் மூலம் எத்தேரியத்தின் அடிப்படைக் லேயரில் செயல்திறனை நீட்டிக்கின்றன, ஆனால் அளவிடுவதற்கான உண்மையான ஊக்கம் பரிவர்த்தனைத் தரவைச் சுருக்குவதிலிருந்து வருகிறது. எத்தேரியத்தின் [பிளாக் அளவு](/developers/docs/blocks/#block-size) ஒவ்வொரு பிளாக்கும் வைத்திருக்கக்கூடிய தரவைக் கட்டுப்படுத்துகிறது, மேலும், அதன் நீட்சியாக, ஒரு பிளாக்கிற்குச் செயலாக்கப்படும் பரிவர்த்தனைகளின் எண்ணிக்கையையும் கட்டுப்படுத்துகிறது. நிகழ்வு சார்ந்த தரவுகளைச் சுருக்குவதன் மூலம், ZK-rollups ஒவ்வொரு பிளாக்கிலும் செயல்படுத்தப்படும் நிகழ்வுகளின் எண்ணிக்கையைப் பெரிதும் அதிகரிக்கின்றன.

ZK-rollups, எதரியத்தைச் சாத்தியமாக்கும் அளவிற்கு மிகவும் மேம்பட்டதாக இருக்கின்றன, ஏனெனில் அவற்றுக்கு ஒவ்வொரு நிகழ்வைச் சரிபார்க்க தேவையான அனைத்து தரவுகளையும் வெளியிட வேண்டிய அவசியமில்லை. அவை rollup-இல் கணக்குகள் மற்றும் நிலைகளை மீட்டமைக்க தேவையான குறைந்தபட்ச தரவுகளை மட்டுமே வெளியிட வேண்டும்.

### தொடர்ச்சியான சான்றுகள் {#recursive-proofs}

சிறந்த அறிவியல் ஆதாரங்களின் மூலம் மற்ற ஆதாரங்களைச் சரிபார்க்க முடியும் என்பது ஒரு நன்மை. எடுத்துக்காட்டாக, ஒரு சிங்கிள் ZK-SNARK மற்ற ZK-SNARKs-ஐ சரிபார்க்க முடியும். இப்படி "ஆதாரங்களின் ஆதாரங்கள்" என்று அழைக்கப்படும் மறுமொழி ஆதாரங்கள், ZK-rollups-இல் throughput-ஐ எதிரொலிக்கிறது.

தற்காலத்தில், நிலைத்தன்மை ஆதாரங்கள் பிளாக்குக்கு பிளாக்காக உருவாக்கப்படுகின்றன மற்றும் L1 ஒப்புதல் தொகுதிக்குச் சமர்ப்பிக்கப்படுகின்றன. ஆனால், ஒற்றை பிளாக்கின் ஆதாரங்களைச் சரிபார்க்கும்போது ZK-rollups அளவீட்டின் அளவுகளை வரையறுக்கிறது, ஏனெனில் ஒரே ஒரு பிளாக் மட்டுமே இறுதி செய்யப்படுகிறது.

மாறாக, மறுமொழி ஆதாரங்கள் ஒரே நிலைத்தன்மை ஆதாரத்துடன் பல பிளாக்குகளை இறுதி செய்யச் சாத்தியமாக்குகின்றன. இது proving circuit பல பிளாக்குகளின் ஆதாரங்களை மறுமொழியாகச் சேர்க்கும்போது, ஒரு இறுதி ஆதாரம் உருவாகும். L2 செயல்பாட்டாளர் இந்த மறுமொழி ஆதாரத்தைச் சமர்ப்பிக்கின்றார், மற்றும் ஒப்புதலுக்கு உட்பட்டால், அனைத்து சம்பந்தப்பட்ட பிளாக்குகளும் உடனடியாக இறுதி செய்யப்படும். மறுமொழி ஆதாரங்களுடன், எதரியத்தில் ஒப்புதலான ZK-rollup நிகழ்வுகளின் எண்ணிக்கையை அதிகரிக்கலாம்.

### ZK-ரோல்அப்களின் நன்மைகள் மற்றும் தீமைகள் {#zk-rollups-pros-and-cons}

| நிறைகள்                                                                                                                                                                                                                                              | குறைகள்                                                                                                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| செல்லுபடியாகும் தன்மைக்கான சான்றுகள் ஆஃப்செயின் பரிவர்த்தனைகளின் சரியான தன்மையை உறுதி செய்கின்றன, மற்றும் ஆபரேட்டர்கள் தவறான நிலை மாற்றங்களைச் செயல்படுத்துவதைத் தடுக்கின்றன.                                                        | செல்லுபடியாகும் தன்மைக்கான சான்றுகளைக் கணக்கிடுவது மற்றும் சரிபார்ப்பதுடன் தொடர்புடைய செலவு கணிசமானது, மேலும் இது ரோல்அப் பயனர்களுக்கான கட்டணங்களை அதிகரிக்கக்கூடும்.                                                           |
| L1 இல் செல்லுபடியாகும் தன்மைக்கான சான்றுகள் சரிபார்க்கப்பட்டவுடன் நிலை புதுப்பிப்புகள் அங்கீகரிக்கப்படுவதால், இது வேகமான பரிவர்த்தனை இறுதித்தன்மையை வழங்குகிறது.                                                                     | பூஜ்ஜிய-அறிவு தொழில்நுட்பத்தின் சிக்கலான தன்மை காரணமாக EVM-இணக்கமான ZK-ரோல்அப்களை உருவாக்குவது கடினம்.                                                                                                                          |
| [ஆப்டிமிஸ்டிக் ரோல்அப்களைப்](/developers/docs/scaling/optimistic-rollups/#optimistic-pros-and-cons) போல ஊக்கப்படுத்தப்பட்ட பங்கேற்பாளர்களின் நேர்மையைச் சாராமல், பாதுகாப்பிற்காக நம்பிக்கையற்ற குறியாக்க வழிமுறைகளைச் சார்ந்துள்ளது. | செல்லுபடியாகும் தன்மைக்கான சான்றுகளை உருவாக்குவதற்கு சிறப்பு வன்பொருள் தேவைப்படுகிறது, இது சில தரப்பினரால் சங்கிலியின் மையப்படுத்தப்பட்ட கட்டுப்பாட்டை ஊக்குவிக்கக்கூடும்.                                                      |
| L1 இல் ஆஃப்செயின் நிலையை மீட்டெடுக்கத் தேவையான தரவைச் சேமிக்கிறது, இது பாதுகாப்பு, தணிக்கை-எதிர்ப்பு மற்றும் பரவலாக்கத்திற்கு உத்தரவாதம் அளிக்கிறது.                                                                                 | மையப்படுத்தப்பட்ட ஆபரேட்டர்கள் (சீக்வென்சர்கள்) பரிவர்த்தனைகளின் வரிசையை பாதிக்கலாம்.                                                                                                                        |
| பயனர்கள் அதிக மூலதனத் திறனிலிருந்து பயனடைகிறார்கள், மற்றும் தாமதமின்றி L2 இலிருந்து நிதியைத் திரும்பப் பெறலாம்.                                                                                                                      | வன்பொருள் தேவைகள், சங்கிலியை முன்னேறச் செய்யக்கூடிய பங்கேற்பாளர்களின் எண்ணிக்கையைக் குறைக்கலாம், இது தீங்கிழைக்கும் ஆபரேட்டர்கள் ரோல்அப்பின் நிலையை முடக்குவது மற்றும் பயனர்களைத் தணிக்கை செய்வது போன்ற அபாயத்தை அதிகரிக்கிறது. |
| லைவ்நெஸ் அனுமானங்களைச் சார்ந்திருக்கவில்லை, மேலும் பயனர்கள் தங்கள் நிதியைப் பாதுகாக்க சங்கிலியைச் சரிபார்க்க வேண்டியதில்லை.                                                                                                          | சில நிரூபிக்கும் அமைப்புகளுக்கு (எ.கா., ZK-SNARK) ஒரு நம்பகமான அமைப்பு தேவைப்படுகிறது, அது தவறாகக் கையாளப்பட்டால், ஒரு ZK-ரோல்அப்பின் பாதுகாப்பு மாதிரியைப் பாதிக்கக்கூடும். |
| சிறந்த தரவு சுருக்கம் எத்தேரியத்தில் `calldata` வெளியிடுவதற்கான செலவுகளைக் குறைக்கவும், பயனர்களுக்கான ரோல்அப் கட்டணங்களைக் குறைக்கவும் உதவும்.                                                                                       |                                                                                                                                                                                                                                                 |

### ZK-ரோல்அப்களின் ஒரு காட்சி விளக்கம் {#zk-video}

Finematics, ZK-ரோல்அப்களை விளக்குவதைப் பாருங்கள்:

<YouTube id="7pWxCklcNsU" start="406" />

## யார் ஒரு zkEVM-இல் வேலை செய்கிறார்கள்? {#zkevm-projects}

zkEVM-களில் வேலை செய்யும் திட்டங்கள் பின்வருமாறு:

- **[zkEVM](https://github.com/privacy-scaling-explorations/zkevm-specs)** - _zkEVM என்பது EVM-இணக்கமான ZK-ரோல்அப்பையும், எத்தேரியம் பிளாக்குகளுக்கான செல்லுபடியாகும் தன்மைக்கான சான்றுகளை உருவாக்குவதற்கான ஒரு வழிமுறையையும் உருவாக்க எத்தேரியம் அறக்கட்டளையால் நிதியளிக்கப்பட்ட ஒரு திட்டமாகும்._

- **[Polygon zkEVM](https://polygon.technology/solutions/polygon-zkevm)** - _என்பது எத்தேரியம் மெயின்நெட்டில் உள்ள ஒரு பரவலாக்கப்பட்ட ZK ரோல்அப் ஆகும், இது ஒரு பூஜ்ஜிய-அறிவு எத்தேரியம் மெய்நிகர் இயந்திரத்தில் (zkEVM) வேலை செய்கிறது, இது பூஜ்ஜிய-அறிவு-சான்று சரிபார்ப்புகளுடன் ஸ்மார்ட் கான்ட்ராக்ட்கள் உட்பட எத்தேரியம் பரிவர்த்தனைகளை வெளிப்படையான முறையில் செயல்படுத்துகிறது._

- **[Scroll](https://scroll.io/blog/zkEVM)** - _Scroll என்பது எத்தேரியத்திற்கான ஒரு நேட்டிவ் zkEVM லேயர் 2 தீர்வை உருவாக்குவதில் பணியாற்றும் ஒரு தொழில்நுட்பத்தை மையமாகக் கொண்ட நிறுவனமாகும்._

- **[Taiko](https://taiko.xyz)** - _Taiko ஒரு பரவலாக்கப்பட்ட, எத்தேரியம்-சமமான ZK-ரோல்அப் (ஒரு [வகை 1 ZK-EVM](https://vitalik.eth.limo/general/2022/08/04/zkevm.html)) ஆகும்._

- **[ZKsync](https://docs.zksync.io/)** - _ZKsync Era என்பது Matter Labs ஆல் உருவாக்கப்பட்ட, அதன் சொந்த zkEVM ஆல் இயக்கப்படும் ஒரு EVM-இணக்கமான ZK ரோல்அப் ஆகும்._

- **[Starknet](https://starkware.co/starknet/)** - _StarkNet என்பது StarkWare ஆல் உருவாக்கப்பட்ட ஒரு EVM-இணக்கமான லேயர் 2 அளவிடுதல் தீர்வாகும்._

- **[Morph](https://www.morphl2.io/)** - _Morph என்பது லேயர் 2 நிலை சவால் சிக்கலைத் தீர்க்க zk-சான்றைப் பயன்படுத்தும் ஒரு கலப்பின ரோல்அப் அளவிடுதல் தீர்வு ஆகும்._

- **[Linea](https://linea.build)** - _Linea என்பது Consensys ஆல் உருவாக்கப்பட்ட ஒரு எத்தேரியம்-சமமான zkEVM லேயர் 2 ஆகும், இது எத்தேரியம் சூழலமைப்புடன் முழுமையாகப் பொருந்தியுள்ளது._

## ZK-ரோல்அப்கள் பற்றிய மேலதிக வாசிப்பு {#further-reading-on-zk-rollups}

- [பூஜ்ஜிய-அறிவு ரோல்அப்கள் என்றால் என்ன?](https://coinmarketcap.com/alexandria/glossary/zero-knowledge-rollups)
- [பூஜ்ஜிய-அறிவு ரோல்அப்கள் என்றால் என்ன?](https://alchemy.com/blog/zero-knowledge-rollups)
- [எத்தேரியம் ரோலப்ஸிற்கான நடைமுறை வழிகாட்டி](https://web.archive.org/web/20241108192208/https://research.2077.xyz/the-practical-guide-to-ethereum-rollups)
- [STARK-களும் SNARK-களும்](https://consensys.net/blog/blockchain-explained/zero-knowledge-proofs-starks-vs-snarks/)
- [zkEVM என்றால் என்ன?](https://www.alchemy.com/overviews/zkevm)
- [ZK-EVM வகைகள்: எத்தேரியம்-சமம், EVM-சமம், வகை 1, வகை 4, மற்றும் பிற மறைகுறியீட்டுச் சொற்கள்](https://taiko.mirror.xyz/j6KgY8zbGTlTnHRFGW6ZLVPuT0IV0_KmgowgStpA0K4)
- [zkEVM-க்கான அறிமுகம்](https://hackmd.io/@yezhang/S1_KMMbGt)
- [ZK-EVM L2-கள் என்றால் என்ன?](https://linea.mirror.xyz/qD18IaQ4BROn_Y40EBMTUTdJHYghUtdECscSWyMvm8M)
- [அற்புதமான-zkEVM வளங்கள்](https://github.com/LuozhuZhang/awesome-zkevm)
- [ZK-SNARKS-களின் உள்செயல்பாடு](https://vitalik.eth.limo/general/2017/02/01/zk_snarks.html)
- [SNARK-கள் எப்படி சாத்தியமாகின்றன?](https://vitalik.eth.limo/general/2021/01/26/snarks.html)
