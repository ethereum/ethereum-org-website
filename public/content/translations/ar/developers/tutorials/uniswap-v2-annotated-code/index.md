---
title: "جولة تفصيلية في عقد Uniswap-v2"
description: "كيف يعمل عقد Uniswap-v2؟ لماذا كُتب بهذه الطريقة؟"
author: Ori Pomerantz
tags: [ "الصلابة" ]
skill: intermediate
published: 2021-05-01
lang: ar
---

## مقدمة {#مقدمة}

يمكن لـ [Uniswap v2](https://app.uniswap.org/whitepaper.pdf) إنشاء سوق تداول بين أي رمزين من رموز ERC-20. في هذه المقالة، سنتناول النص البرمجي للعقود التي تنفذ هذا البروتوكول ونرى سبب كتابتها بهذه الطريقة.

### ماذا يفعل Uniswap؟ {#what-does-uniswap-do}

بشكل أساسي، هناك نوعان من المستخدمين: مزودو السيولة والمتداولون.

يقدم _مزودو السيولة_ للمجمع الرمزين اللذين يمكن تداولهما (سنطلق عليهما **Token0** و**Token1**). في المقابل، يتلقون رمزًا ثالثًا يمثل ملكية جزئية للمجمع يسمى _رمز السيولة_.

يرسل _المتداولون_ نوعًا واحدًا من الرموز إلى المجمع ويتلقون النوع الآخر (على سبيل المثال، إرسال **Token0** وتلقي **Token1**) من المجمع الذي يوفره مزودو السيولة. يتم تحديد سعر التداول من خلال العدد النسبي لـ **Token0** و**Token1** الموجود في المجمع. بالإضافة إلى ذلك، يأخذ المجمع نسبة مئوية صغيرة كمكافأة لمجمع السيولة.

عندما يرغب مزودو السيولة في استعادة أصولهم، يمكنهم حرق رموز المجمع واستلام رموزهم مرة أخرى، بما في ذلك حصتهم من المكافآت.

[انقر هنا للحصول على وصف أكمل](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/swaps/).

### لماذا الإصدار الثاني v2؟ لماذا ليس الإصدار الثالث v3؟ {#why-v2}

[Uniswap v3](https://app.uniswap.org/whitepaper-v3.pdf) هو تطوير أكثر تعقيدًا بكثير من الإصدار v2. من الأسهل تعلم الإصدار v2 أولاً ثم الانتقال إلى الإصدار v3.

### العقود الأساسية مقابل العقود الطرفية {#contract-types}

ينقسم Uniswap v2 إلى مكونين، أساسي وطرفي. يسمح هذا التقسيم بأن تكون العقود الأساسية، التي تحتفظ بالأصول وبالتالي _يجب_ أن تكون آمنة، أبسط وأسهل في التدقيق. يمكن بعد ذلك توفير جميع الوظائف الإضافية التي يطلبها المتداولون من خلال العقود الطرفية.

## تدفقات البيانات والتحكم {#flows}

هذا هو تدفق البيانات والتحكم الذي يحدث عند تنفيذ الإجراءات الرئيسية الثلاثة لـ Uniswap:

1. المبادلة بين الرموز المختلفة
2. إضافة السيولة إلى السوق والحصول على مكافأة برموز سيولة ERC-20 لتداول الأزواج
3. حرق رموز سيولة ERC-20 واستعادة رموز ERC-20 التي يسمح تداول الأزواج للمتداولين بتداولها

### المبادلة {#swap-flow}

هذا هو التدفق الأكثر شيوعًا، الذي يستخدمه المتداولون:

#### المتصل {#caller}

1. تزويد الحساب الطرفي ببدل بالمبلغ المراد مبادلته.
2. استدعاء إحدى وظائف المبادلة العديدة للعقد الطرفي (يعتمد أي منها على ما إذا كان ETH متضمنًا أم لا، وما إذا كان المتداول يحدد مقدار الرموز التي سيتم إيداعها أو مقدار الرموز التي سيتم استردادها، وما إلى ذلك).
   تقبل كل وظيفة مبادلة `مسارًا`، وهو عبارة عن مجموعة من منصات التداول التي يجب المرور بها.

#### في العقد الطرفي (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02-sol}

3. تحديد المبالغ التي يجب تداولها في كل منصة تداول على طول المسار.
4. تكرار المسار. لكل منصة تداول على طول الطريق، يرسل رمز الإدخال ثم يستدعي وظيفة `المبادلة` الخاصة بمنصة التداول.
   في معظم الحالات، يكون عنوان الوجهة للرموز هو منصة تداول الزوج التالي في المسار. في التداول النهائي، هو العنوان الذي يقدمه المتداول.

#### في العقد الأساسي (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

5. التحقق من عدم خداع العقد الأساسي وإمكانية الحفاظ على سيولة كافية بعد المبادلة.
6. معرفة عدد الرموز الإضافية التي لدينا بالإضافة إلى الاحتياطيات المعروفة. هذا المبلغ هو عدد رموز الإدخال التي تلقيناها للتداول.
7. إرسال رموز الإخراج إلى الوجهة.
8. استدعاء `_update` لتحديث مبالغ الاحتياطي

#### العودة إلى العقد الطرفي (UniswapV2Router02.sol) {#back-in-the-periphery-contract-uniswapv2router02-sol}

9. إجراء أي تنظيف ضروري (على سبيل المثال، حرق رموز WETH لاستعادة ETH لإرسالها إلى المتداول)

### إضافة سيولة {#add-liquidity-flow}

#### المتصل {#caller-2}

1. تزويد الحساب الطرفي ببدل بالمبالغ التي ستتم إضافتها إلى مجمع السيولة.
2. استدعاء إحدى وظائف `addLiquidity` في العقد الطرفي.

#### في العقد الطرفي (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-2}

3. إنشاء تداول زوجي جديد إذا لزم الأمر
4. إذا كان هناك تداول زوجي حالي، فاحسب عدد الرموز التي ستتم إضافتها. من المفترض أن تكون هذه قيمة متطابقة لكلا الرمزين، وبالتالي نفس نسبة الرموز الجديدة إلى الرموز الحالية.
5. التحقق مما إذا كانت المبالغ مقبولة (يمكن للمتصلين تحديد الحد الأدنى للمبلغ الذي يفضلون عدم إضافة سيولة دونه)
6. استدعاء العقد الأساسي.

#### في العقد الأساسي (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

7. سك رموز السيولة وإرسالها إلى المتصل
8. استدعاء `_update` لتحديث مبالغ الاحتياطي

### إزالة السيولة {#remove-liquidity-flow}

#### المتصل {#caller-3}

1. تزويد الحساب الطرفي ببدل من رموز السيولة ليتم حرقها مقابل الرموز الأساسية.
2. استدعاء إحدى وظائف `removeLiquidity` في العقد الطرفي.

#### في العقد الطرفي (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-3}

3. إرسال رموز السيولة إلى تداول الزوج

#### في العقد الأساسي (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-3}

4. إرسال الرموز الأساسية إلى عنوان الوجهة بما يتناسب مع الرموز المحروقة. على سبيل المثال، إذا كان هناك 1000 رمز A في المجمع، و500 رمز B، و90 رمز سيولة، وتلقينا 9 رموز لحرقها، فإننا نحرق 10% من رموز السيولة، لذا نعيد للمستخدم 100 رمز A و50 رمز B.
5. حرق رموز السيولة
6. استدعاء `_update` لتحديث مبالغ الاحتياطي

## العقود الأساسية {#core-contracts}

هذه هي العقود الآمنة التي تحتفظ بالسيولة.

### UniswapV2Pair.sol {#UniswapV2Pair}

ينفذ [هذا العقد](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol) المجمع الفعلي الذي يتداول الرموز. إنها الوظيفة الأساسية لـ Uniswap.

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';
```

هذه هي جميع الواجهات التي يحتاج العقد إلى معرفتها، إما لأن العقد ينفذها (`IUniswapV2Pair` و `UniswapV2ERC20`) أو لأنه يستدعي عقودًا تنفذها.

```solidity
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
```

يرث هذا العقد من `UniswapV2ERC20`، الذي يوفر وظائف ERC-20 لرموز السيولة.

```solidity
    using SafeMath  for uint;
```

تُستخدم [مكتبة SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math) لتجنب تجاوزات السعة وتدفقاتها الدنيا. هذا مهم لأنه بخلاف ذلك قد ينتهي بنا الأمر إلى موقف يجب أن تكون فيه القيمة `-1`، ولكنها بدلاً من ذلك `2^256-1`.

```solidity
    using UQ112x112 for uint224;
```

تتطلب الكثير من الحسابات في عقد المجمع كسورًا. ومع ذلك، لا تدعم آلة إيثريوم الافتراضية (EVM) الكسور.
الحل الذي وجده Uniswap هو استخدام قيم 224 بت، مع 112 بت للجزء الصحيح، و112 بت للجزء الكسري. لذا، يتم تمثيل `1.0` كـ `2^112`، ويتم تمثيل `1.5` كـ `2^112 + 2^111`، وهكذا.

تتوفر المزيد من التفاصيل حول هذه المكتبة [لاحقًا في المستند](#FixedPoint).

#### المتغيرات {#pair-vars}

```solidity
    uint public constant MINIMUM_LIQUIDITY = 10**3;
```

لتجنب حالات القسمة على صفر، هناك حد أدنى من رموز السيولة التي توجد دائمًا (ولكنها مملوكة للحساب صفر). هذا الرقم هو **MINIMUM_LIQUIDITY**، أي ألف.

```solidity
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
```

هذا هو محدد واجهة التطبيق الثنائية (ABI) لوظيفة النقل الخاصة بـ ERC-20. يُستخدم لنقل رموز ERC-20 في حسابي الرمزين.

```solidity
    address public factory;
```

هذا هو عقد المصنع الذي أنشأ هذا المجمع. كل مجمع هو عبارة عن تداول بين رمزين من رموز ERC-20، والمصنع هو نقطة مركزية تربط بين كل هذه المجمعات.

```solidity
    address public token0;
    address public token1;
```

هذه هي عناوين عقود نوعي رموز ERC-20 التي يمكن تداولها بواسطة هذا المجمع.

```solidity
    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
```

الاحتياطيات التي يمتلكها المجمع لكل نوع من أنواع الرموز. نفترض أن الاثنين يمثلان نفس مقدار القيمة، وبالتالي فإن كل token0 يساوي reserve1/reserve0 من token1.

```solidity
    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves
```

الختم الزمني لآخر كتلة حدث فيها تداول، ويستخدم لتتبع أسعار التداول عبر الزمن.

أحد أكبر نفقات الغاز في عقود إيثريوم هو التخزين، والذي يستمر من استدعاء لآخر للعقد. طول كل خلية تخزين هو 256 بت. لذا، يتم تخصيص ثلاثة متغيرات، `reserve0`، `reserve1`، و `blockTimestampLast`، بطريقة يمكن لقيمة تخزين واحدة أن تتضمن جميعها (112+112+32=256).

```solidity
    uint public price0CumulativeLast;
    uint public price1CumulativeLast;
```

تحتوي هذه المتغيرات على التكاليف التراكمية لكل رمز (كل منها بدلالة الآخر). يمكن استخدامها لحساب متوسط سعر التداول على مدى فترة من الزمن.

```solidity
    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
```

الطريقة التي يقرر بها تداول الزوج سعر التداول بين token0 وtoken1 هي الحفاظ على مضاعف الاحتياطيين ثابتًا أثناء عمليات التجارة. `kLast` هي هذه القيمة. يتغير عندما يقوم مزود السيولة بإيداع أو سحب الرموز، ويزداد قليلاً بسبب رسوم السوق البالغة 0.3%.

إليك مثال بسيط. لاحظ أنه من أجل البساطة، يحتوي الجدول على ثلاثة أرقام فقط بعد الفاصلة العشرية، ونتجاهل رسوم التداول البالغة 0.3% لذا فإن الأرقام ليست دقيقة.

| الحدث                                                           |                  reserve0 |                  reserve1 | reserve0 \* reserve1 | متوسط سعر التداول (token1 / token0) |
| --------------------------------------------------------------- | ------------------------: | ------------------------: | -------------------: | ------------------------------------------------------ |
| الإعداد الأولي                                                  | 1,000.000 | 1,000.000 |            1,000,000 |                                                        |
| المتداول A يبادل 50 token0 مقابل 47.619 token1  | 1,050.000 |   952.381 |            1,000,000 | 0.952                                  |
| المتداول B يبادل 10 token0 مقابل 8.984 token1   | 1,060.000 |   943.396 |            1,000,000 | 0.898                                  |
| المتداول C يبادل 40 token0 مقابل 34.305 token1  | 1,100.000 |   909.090 |            1,000,000 | 0.858                                  |
| المتداول D يبادل 100 token1 مقابل 109.01 token0 |   990.990 | 1,009.090 |            1,000,000 | 0.917                                  |
| المتداول E يبادل 10 token0 مقابل 10.079 token1  | 1,000.990 |   999.010 |            1,000,000 | 1.008                                  |

كلما قدم المتداولون المزيد من token0، زادت القيمة النسبية لـ token1، والعكس صحيح، بناءً على العرض والطلب.

#### القفل {#pair-lock}

```solidity
    uint private unlocked = 1;
```

هناك فئة من الثغرات الأمنية تعتمد على [إساءة استخدام إعادة الدخول (reentrancy abuse)](https://medium.com/coinmonks/ethernaut-lvl-10-re-entrancy-walkthrough-how-to-abuse-execution-ordering-and-reproduce-the-dao-7ec88b912c14). يحتاج Uniswap إلى نقل رموز ERC-20 عشوائية، مما يعني استدعاء عقود ERC-20 التي قد تحاول إساءة استخدام سوق Uniswap الذي يستدعيها.
من خلال وجود متغير `unlocked` كجزء من العقد، يمكننا منع استدعاء الوظائف أثناء تشغيلها (ضمن نفس المعاملة).

```solidity
    modifier lock() {
```

هذه الوظيفة هي [معدِّل](https://docs.soliditylang.org/en/v0.8.3/contracts.html#function-modifiers)، وهي وظيفة تلتف حول وظيفة عادية لتغيير سلوكها بطريقة ما.

```solidity
        require(unlocked == 1, 'UniswapV2: LOCKED');
        unlocked = 0;
```

إذا كان `unlocked` يساوي واحدًا، فاجعله صفرًا. إذا كان صفرًا بالفعل، فاعكس الاستدعاء واجعله يفشل.

```solidity
        _;
```

في المُعدِّل، `_;` هو استدعاء الدالة الأصلي (بكل المعلمات). هذا يعني أن استدعاء الدالة يحدث فقط إذا كانت قيمة `unlocked` واحدًا عند استدعائها، وبينما يتم تشغيلها تكون قيمة `unlocked` صفرًا.

```solidity
        unlocked = 1;
    }
```

بعد عودة الدالة الرئيسية، قم بتحرير القفل.

#### متفرقات الدوال {#pair-misc}

```solidity
    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }
```

توفر هذه الدالة للمستدعين الحالة الحالية للتبادل. لاحظ أن دوال سوليديتي [يمكنها إرجاع قيم متعددة](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values).

```solidity
    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
```

تقوم هذه الدالة الداخلية بتحويل مبلغ من رموز ERC20 من التبادل إلى شخص آخر. `SELECTOR` يحدد أن الدالة التي نستدعيها هي `transfer(address,uint)` (انظر التعريف أعلاه).

لتجنب الاضطرار إلى استيراد واجهة لدالة الرمز، نقوم "يدويًا" بإنشاء الاستدعاء باستخدام إحدى [دوال واجهة التطبيق الثنائية](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions).

```solidity
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }
```

هناك طريقتان يمكن من خلالهما الإبلاغ عن فشل استدعاء تحويل ERC-20:

1. إلغاء. إذا تم إلغاء استدعاء عقد خارجي، فإن قيمة الإرجاع المنطقية تكون `false`
2. الانتهاء بشكل طبيعي مع الإبلاغ عن فشل. في هذه الحالة، يكون للمخزن المؤقت لقيمة الإرجاع طول غير صفري، وعند فك تشفيره كقيمة منطقية يكون `false`

في حال تحقق أي من هذين الشرطين، يتم الإلغاء.

#### الأحداث {#pair-events}

```solidity
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
```

يتم إصدار هذين الحدثين عندما يقوم مزود السيولة بإيداع السيولة (`Mint`) أو سحبها (`Burn`). في كلتا الحالتين، تكون كميات token0 و token1 المودعة أو المسحوبة جزءًا من الحدث، بالإضافة إلى هوية الحساب الذي استدعانا (`sender`). في حالة السحب، يتضمن الحدث أيضًا الهدف الذي استلم الرموز (`to`)، والذي قد لا يكون هو نفسه المرسل.

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

يتم إصدار هذا الحدث عندما يقوم المتداول بمبادلة رمز بآخر. مرة أخرى، قد لا يكون المرسل والوجهة متطابقين.
يمكن إرسال كل رمز إلى التبادل أو استلامه منه.

```solidity
    event Sync(uint112 reserve0, uint112 reserve1);
```

أخيرًا، يتم إصدار `Sync` في كل مرة تتم فيها إضافة الرموز أو سحبها، بغض النظر عن السبب، لتوفير أحدث معلومات الاحتياطي (وبالتالي سعر الصرف).

#### دوال الإعداد {#pair-setup}

من المفترض أن يتم استدعاء هذه الدوال مرة واحدة عند إعداد تبادل الزوج الجديد.

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

يتأكد المنشئ من أننا سنتتبع عنوان المصنع الذي أنشأ الزوج. هذه المعلومات مطلوبة لدالة `initialize` ولرسوم المصنع (إن وجدت).

```solidity
    // يتم استدعاؤها مرة واحدة من قبل المصنع في وقت النشر
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // فحص واحد كافٍ
        token0 = _token0;
        token1 = _token1;
    }
```

تسمح هذه الدالة للمصنع (وفقط المصنع) بتحديد رمزي ERC-20 اللذين سيقوم هذا الزوج بتبادلهما.

#### دوال التحديث الداخلية {#pair-update-internal}

##### \_update

```solidity
    // تحديث الاحتياطيات، وفي أول استدعاء لكل كتلة، يتم تحديث مجمعات الأسعار
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

يتم استدعاء هذه الدالة في كل مرة يتم فيها إيداع الرموز أو سحبها.

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

إذا كان أي من balance0 أو balance1 (uint256) أعلى من uint112(-1) (=2^112-1) (لذا يحدث تجاوز ويتراجع إلى 0 عند تحويله إلى uint112)، يتم رفض متابعة \_update لمنع التجاوزات. بالنسبة لرمز عادي يمكن تقسيمه إلى 10^18 وحدة، هذا يعني أن كل تبادل محدود بحوالي 5.1\*10^15 من كل رمز. حتى الآن لم يمثل ذلك مشكلة.

```solidity
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // التجاوز مقصود
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
```

إذا كان الوقت المنقضي لا يساوي صفرًا، فهذا يعني أننا أول معاملة تبادل في هذه الكتلة. في هذه الحالة، نحتاج إلى تحديث مجمّعات التكلفة.

```solidity
            // * لا يحدث تجاوز أبداً، و + التجاوز مقصود
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
```

يتم تحديث كل مجمّع تكلفة بأحدث تكلفة (احتياطي الرمز الآخر/احتياطي هذا الرمز) مضروبًا في الوقت المنقضي بالثواني. للحصول على متوسط السعر، تقرأ السعر التراكمي في نقطتين زمنيتين وتقسمه على الفارق الزمني بينهما. على سبيل المثال، افترض تسلسل الأحداث التالي:

| الحدث                                                                                |                  reserve0 |                  reserve1 | الختم الزمني | سعر الصرف الهامشي (reserve1 / reserve0) |                                                       price0CumulativeLast |
| ------------------------------------------------------------------------------------ | ------------------------: | ------------------------: | ------------ | ---------------------------------------------------------: | -------------------------------------------------------------------------: |
| الإعداد الأولي                                                                       | 1,000.000 | 1,000.000 | 5,000        |                                      1.000 |                                                                          0 |
| المتداول (أ) يودع 50 token0 ويسترد 47.619 token1  | 1,050.000 |   952.381 | 5,020        |                                      0.907 |                                                                         20 |
| المتداول (ب) يودع 10 token0 ويسترد 8.984 token1   | 1,060.000 |   943.396 | 5,030        |                                      0.890 |                       20+10\*0.907 = 29.07 |
| المتداول (ج) يودع 40 token0 ويسترد 34.305 token1  | 1,100.000 |   909.090 | 5,100        |                                      0.826 |    29.07+70\*0.890 = 91.37 |
| المتداول (د) يودع 100 token1 ويسترد 109.01 token0 |   990.990 | 1,009.090 | 5,110        |                                      1.018 |    91.37+10\*0.826 = 99.63 |
| المتداول (هـ) يودع 10 token0 ويسترد 10.079 token1 | 1,000.990 |   999.010 | 5,150        |                                      0.998 | 99.63+40\*1.1018 = 143.702 |

لنفترض أننا نريد حساب متوسط سعر **Token0** بين الختمين الزمنيين 5,030 و 5,150. الفرق في قيمة `price0Cumulative` هو 143.702 - 29.07 = 114.632. هذا هو المتوسط على مدار دقيقتين (120 ثانية). إذًا متوسط السعر هو 114.632 / 120 = 0.955.

هذا الحساب للسعر هو السبب وراء حاجتنا لمعرفة أحجام الاحتياطي القديمة.

```solidity
في المعدِّل، `_;` هو استدعاء الوظيفة الأصلي (مع كل المعلمات).
```

هذا يعني أن استدعاء الوظيفة يحدث فقط إذا كان `unlocked` واحدًا عند استدعائه، وأثناء تشغيله تكون قيمة `unlocked` صفرًا.

##### ```

    unlocked = 1;
}
```

```solidity
بعد عودة الوظيفة الرئيسية، حرر القفل.
```

متفرقات وظائف {#pair-misc}     function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
_reserve0 = reserve0;
_reserve1 = reserve1;
_blockTimestampLast = blockTimestampLast;
}

توفر هذه الوظيفة للمتصلين الحالة الحالية للتداول.

```solidity
لاحظ أن وظائف Solidity [يمكن أن تعيد قيمًا متعددة](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values).
```

```
function _safeTransfer(address token, address to, uint value) private {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); تنقل هذه الوظيفة الداخلية كمية من رموز ERC20 من منصة التداول إلى شخص آخر.
```

```solidity
يحدد `SELECTOR` أن الوظيفة التي نستدعيها هي `transfer(address,uint)` (انظر التعريف أعلاه).
```

لتجنب الحاجة إلى استيراد واجهة لوظيفة الرمز، نقوم بإنشاء الاستدعاء "يدويًا" باستخدام إحدى [وظائف واجهة التطبيق الثنائية (ABI)](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions).
require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
}

```solidity
هناك طريقتان يمكن من خلالهما الإبلاغ عن فشل استدعاء نقل ERC-20:
```

العكس. إذا تم عكس استدعاء عقد خارجي، فإن القيمة البوليانية المعادة تكون `false`

```solidity
الانتهاء بشكل طبيعي ولكن الإبلاغ عن فشل.
```

في هذه الحالة، يكون للمخزن المؤقت للقيمة المعادة طول غير صفري، وعند فك ترميزه كقيمة بوليانية يكون `false` إذا حدث أي من هذين الشرطين، فسيتم العكس.

```solidity
الأحداث {#pair-events}
```

```
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); يتم إصدار هذين الحدثين عندما يقوم مزود السيولة بإيداع السيولة (`Mint`) أو سحبها (`Burn`).
```

```solidity
في كلتا الحالتين، تكون كميات token0 وtoken1 التي يتم إيداعها أو سحبها جزءًا من الحدث، بالإضافة إلى هوية الحساب الذي استدعانا (`المرسل`).
```

في حالة السحب، يتضمن الحدث أيضًا الهدف الذي تلقى الرموز (`إلى`)، والذي قد لا يكون هو نفسه المرسل.

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

يُصدر هذا الحدث عندما يبادل متداول رمزًا بآخر. مرة أخرى، قد لا يكون المرسل والوجهة متطابقين.
يمكن إرسال كل رمز إلى منصة التداول، أو استلامه منها.

#### ```

event Sync(uint112 reserve0, uint112 reserve1);
```

أخيرًا، يتم إصدار `Sync` في كل مرة يتم فيها إضافة أو سحب الرموز، بغض النظر عن السبب، لتوفير أحدث معلومات الاحتياطي (وبالتالي سعر التداول). وظائف الإعداد {#pair-setup}

##### من المفترض أن يتم استدعاء هذه الوظائف مرة واحدة عند إعداد تداول الزوج الجديد.

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

يتأكد المنشئ من أننا سنتتبع عنوان المصنع الذي أنشأ الزوج. هذه المعلومات مطلوبة لـ `initialize` ولرسوم المصنع (إن وجدت)     // called once by the factory at time of deployment
function initialize(address _token0, address _token1) external {
require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
token0 = _token0;
token1 = _token1;
}

```solidity
تسمح هذه الوظيفة للمصنع (وفقط للمصنع) بتحديد رمزي ERC-20 اللذين سيتداولهما هذا الزوج.
```

وظائف التحديث الداخلية {#pair-update-internal} \_update

```solidity
    // update reserves and, on the first call per block, price accumulators
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

يتم استدعاء هذه الوظيفة في كل مرة يتم فيها إيداع أو سحب الرموز.

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

إذا كان balance0 أو balance1 (uint256) أعلى من uint112(-1) (=2^112-1) (لذلك يتجاوز ويتم التفافه مرة أخرى إلى 0 عند تحويله إلى uint112)، رفض متابعة \_update لمنع التجاوز. مع الرمز العادي الذي يمكن تقسيمه إلى 10^18 وحدة، هذا يعني أن كل تداول يقتصر على حوالي 5.1\*10^15 من كل رمز.

```solidity
حتى الآن لم تكن هذه مشكلة.
```

```
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { إذا كان الوقت المنقضي لا يساوي صفرًا، فهذا يعني أننا أول معاملة تداول في هذه الكتلة. في هذه الحالة، نحتاج إلى تحديث تراكمات التكلفة.             // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
```

يتم تحديث كل مجمع تكلفة بأحدث تكلفة (احتياطي الرمز الآخر/احتياطي هذا الرمز) مضروبة في الوقت المنقضي بالثواني.

للحصول على متوسط السعر، تقرأ السعر التراكمي في نقطتين زمنيتين وتقسمه على الفارق الزمني بينهما.
على سبيل المثال، افترض هذا التسلسل من الأحداث: يمكن للمتداول استغلال حقيقة أن تبادل الزوج يعتقد أن **Token0** أكثر قيمة لاستخراج قيمة منه.

| الحدث                                                 | reserve0 | reserve1 | reserve0 \* reserve1 | price0CumulativeLast |
| ----------------------------------------------------- | -------: | -------: | -------------------: | -------------------: |
| الإعداد الأولي                                        |        8 |       32 |                5,000 |                   40 |
| المتداول يودع 8 رموز **Token0**، ويسترد 16 **Token1** |       16 |       16 |                5,000 |                   32 |

0.907

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
```

المتداول B يودع 10 token0 ويسترد 8.984 token1 إذا لم يفعلوا ذلك، فإننا نعطيهم رموز السيولة بناءً على القيمة الأقل التي قدموها كعقوبة.

سواء كان الإيداع الأولي أو إيداعًا لاحقًا، فإن عدد رموز السيولة التي نقدمها يساوي الجذر التربيعي للتغير في `reserve0*reserve1` وقيمة رمز السيولة لا تتغير (ما لم نحصل على إيداع ليس له قيم متساوية من كلا النوعين، وفي هذه الحالة يتم توزيع "الغرامة"). 5,030

| الحدث                                                                                                                                                                |                                                                                                                                                  reserve0 |                                                                                                                                                  reserve1 |                                                       reserve0 \* reserve1 |                                                                                                                        قيمة المجمع (reserve0 + reserve1) | 5,100 | 0.826 |                                                                                                                                                                                                                                                                      29.07+70\*0.890 = 91.37 |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------: | -------------------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ----: | --------------------: | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| الإعداد الأولي                                                                                                                                                       |                                                                                                                                     8.000 |                                                                                                                                     8.000 |                                                                         64 |                                                                                                                                                       1.018 |     8 |                     8 |                                                                                                                                                                                                                                                                                                                        2.000 |
| إيداع أربعة من كل نوع                                                                                                                                                |                                                                                                                                                     5,150 |                                                                                                                                                     5,150 | 99.63+40\*1.1018 = 143.702 |                                                                               لنفترض أننا نريد حساب متوسط سعر **Token0** بين الأختام الزمنية 5,030 و 5,150. |     4 |                    12 |                                                                                                                                                                                                                                                                                                                        2.000 |
| هذا الحساب للسعر هو السبب في حاجتنا إلى معرفة أحجام الاحتياطي القديمة.                                                                               | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` |                                            \_mintFee | ```
// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
``` |     2 |                    14 |                                                                                                                                                                                                                                                                                                                        2.000 |
| لتقليل الحسابات (وبالتالي تكاليف الغاز)، يتم حساب هذه الرسوم فقط عند إضافة السيولة إلى المجمع أو إزالتها منه، بدلاً من كل معاملة. |                                                          ```
    address feeTo = IUniswapV2Factory(factory).feeTo();
    feeOn = feeTo != address(0);
``` | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` |   إذا كانت صفرًا، فلا توجد رسوم بروتوكول ولا حاجة لحسابها. |                                                                                                                             ```
    uint _kLast = kLast; // gas savings
``` |     0 |                    14 |                                                                                                                                                                                                                                                                                          ```
    if (feeOn) {
        if (_kLast != 0) {
``` |
| يحصل مزودو السيولة على حصتهم ببساطة عن طريق تقدير رموز السيولة الخاصة بهم.                                                                           |                                                                ولكن رسوم البروتوكول تتطلب سك رموز سيولة جديدة وتوفيرها إلى عنوان `feeTo`. |                                                                ولكن رسوم البروتوكول تتطلب سك رموز سيولة جديدة وتوفيرها إلى عنوان `feeTo`. |   إذا كانت صفرًا، فلا توجد رسوم بروتوكول ولا حاجة لحسابها. |                                                                                                               يمكنك رؤية دالة الجذر التربيعي [لاحقًا في هذه المقالة](#Math) |     0 |                    14 | نحن نعلم أنه بين وقت حساب `kLast` والحاضر، لم تتم إضافة أو إزالة أي سيولة (لأننا نجري هذا الحساب في كل مرة تتم فيها إضافة أو إزالة السيولة، قبل أن يتغير بالفعل)، لذا فإن أي تغيير في `reserve0 * reserve1` يجب أن يأتي من رسوم المعاملات (بدونها سنبقي `reserve0 * reserve1` ثابتًا). |

```solidity
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
```

استخدم وظيفة `UniswapV2ERC20._mint` لإنشاء رموز السيولة الإضافية وتعيينها إلى `feeTo` بالفعل.

```solidity
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }
```

إذا لم يتم تعيين رسوم، فاجعل `kLast` صفرًا (إذا لم يكن كذلك بالفعل).

##### عندما كُتب هذا العقد، كانت هناك [ميزة استرداد الغاز](https://eips.ethereum.org/EIPS/eip-3298) التي شجعت العقود على تقليل الحجم الإجمالي لحالة إيثريوم عن طريق تصفير مساحة التخزين التي لا تحتاجها.

```solidity
يحصل هذا النص البرمجي على هذا الاسترداد عندما يكون ذلك ممكنًا.
```

الوظائف التي يمكن الوصول إليها خارجيًا {#pair-external}
لاحظ أنه على الرغم من أن أي معاملة أو عقد _يمكنه_ استدعاء هذه الوظائف، إلا أنها مصممة ليتم استدعاؤها من العقد الطرفي.

```solidity
إذا قمت باستدعائها مباشرة، فلن تتمكن من خداع تداول الزوج، ولكنك قد تخسر قيمة بسبب خطأ ما.
```

mint     // this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint liquidity) {

```solidity
يتم استدعاء هذه الوظيفة عندما يضيف مزود السيولة سيولة إلى المجمع.
```

يقوم بسك رموز سيولة إضافية كمكافأة. يجب استدعاؤها من [عقد طرفي](#UniswapV2Router02) يستدعيها بعد إضافة السيولة في نفس المعاملة (حتى لا يتمكن أي شخص آخر من تقديم معاملة تطالب بالسيولة الجديدة قبل المالك الشرعي).

```solidity
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
```

هذه هي طريقة قراءة نتائج دالة Solidity التي تعيد قيمًا متعددة.

##### نتجاهل القيم المعادة الأخيرة، أي الختم الزمني للكتلة، لأننا لا نحتاجها.

```solidity
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0.sub(_reserve0);
        uint amount1 = balance1.sub(_reserve1);
```

احصل على الأرصدة الحالية وشاهد مقدار ما تمت إضافته من كل نوع من أنواع الرموز.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
```

احسب رسوم البروتوكول التي سيتم تحصيلها، إن وجدت، وقم بسك رموز السيولة وفقًا لذلك.
نظرًا لأن معلمات `_mintFee` هي قيم الاحتياطي القديمة، يتم حساب الرسوم بدقة بناءً على تغييرات المجمع الناتجة عن الرسوم فقط.         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
if (_totalSupply == 0) {
liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
_mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

```solidity
إذا كان هذا هو الإيداع الأول، فأنشئ رموز `MINIMUM_LIQUIDITY` وأرسلها إلى العنوان صفر لقفلها.
```

لا يمكن استردادها أبدًا، مما يعني أن المجمع لن يتم إفراغه بالكامل أبدًا (وهذا ينقذنا من القسمة على صفر في بعض الأماكن). قيمة `MINIMUM_LIQUIDITY` هي ألف، والتي بالنظر إلى أن معظم ERC-20 مقسمة إلى وحدات من 10^-18 من الرمز، كما أن ETH مقسمة إلى wei، هي 10^-15 من قيمة الرمز الواحد.

```solidity
ليست تكلفة عالية.
```

في وقت الإيداع الأول، لا نعرف القيمة النسبية للرمزين، لذلك نضرب المبالغ فقط ونأخذ الجذر التربيعي، على افتراض أن الإيداع يزودنا بقيمة متساوية في كلا الرمزين.

```solidity
يمكننا الوثوق بهذا لأنه من مصلحة المودع توفير قيمة متساوية، لتجنب فقدان القيمة بسبب المراجحة.
```

لنفترض أن قيمة الرمزين متطابقة، ولكن أودع المودع أربعة أضعاف عدد **Token1** من **Token0**. يمكن للمتداول استخدام حقيقة أن تداول الزوج يعتقد أن **Token0** أكثر قيمة لاستخراج القيمة منه. هذا يسهل على العقد التحقق من أنه لا يتعرض للغش، وهو فحص _يجب_ أن يحدث في العقد الأساسي (لأنه يمكن استدعاؤنا من قبل كيانات أخرى غير عقدنا المحيطي).

```solidity
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // نطاق لـ reserve{0,1}Adjusted، لتجنب أخطاء المكدس العميق جدًا
            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
```

هذا فحص سلامة للتأكد من أننا لا نخسر من المبادلة. لا يوجد أي ظرف يجب أن تؤدي فيه المبادلة إلى تقليل `reserve0*reserve1`. قيمة المجمع (reserve0 + reserve1)

```solidity
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }
```

تحديث `reserve0` و `reserve1`، وإذا لزم الأمر، مجمّعات الأسعار والختم الزمني وإصدار حدث.

##### Sync أو Skim

256
لا توجد طريقة لسحب الرموز دون موافقة العقد، ولكن الإيداعات أمر مختلف. المتداول يودع 8 رموز **Token0**، ويسترد 16 **Token1**

في هذه الحالة يوجد حلان:

- `sync`، تحديث الاحتياطيات إلى الأرصدة الحالية
- `skim`، سحب المبلغ الإضافي. لاحظ أنه يُسمح لأي حساب باستدعاء `skim` لأننا لا نعرف من الذي أودع الرموز. كما ترى، كسب المتداول 8 رموز إضافية، والتي تأتي من انخفاض قيمة المجمع، مما يضر بالمودع الذي يملكه.

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
```

### مع كل إيداع لاحق، نعرف بالفعل سعر التداول بين الأصلين، ونتوقع من مزودي السيولة توفير قيمة متساوية في كليهما.

إذا لم يفعلوا ذلك، فإننا نعطيهم رموز سيولة على أساس القيمة الأقل التي قدموها كعقاب.

```solidity
سواء كان الإيداع الأولي أو اللاحق، فإن عدد رموز السيولة التي نقدمها يساوي الجذر التربيعي للتغيير في `reserve0*reserve1` وقيمة رمز السيولة لا تتغير (ما لم نحصل على إيداع لا يحتوي على قيم متساوية من كلا النوعين، وفي هذه الحالة يتم توزيع "الغرامة").
```

إليك مثال آخر مع رمزين لهما نفس القيمة، مع ثلاثة إيداعات جيدة وواحد سيء (إيداع نوع واحد فقط من الرموز، لذلك لا ينتج أي رموز سيولة).
يجمع عنوان `feeTo` رموز السيولة لرسوم البروتوكول، و `feeToSetter` هو العنوان المسموح له بتغيير `feeTo` إلى عنوان مختلف.

```solidity
    mapping(address => mapping(address => address)) public getPair;
    address[] public allPairs;
```

تتتبع هذه المتغيرات الأزواج، أي عمليات التبادل بين نوعين من الرموز.

الأول، `getPair`، هو تخطيط يحدد عقد تبادل الزوج بناءً على رمزي ERC-20 اللذين يتبادلهما. قيمة المجمع (reserve0 + reserve1) رموز السيولة المسكوكة لهذا الإيداع

إجمالي رموز السيولة قيمة كل رمز سيولة

ملاحظة: السبب في عدم إمكانية التكرار على جميع مفاتيح التخطيط هو أن تخزين بيانات العقد _مكلف_، لذا كلما قل استخدامه كان أفضل، وكلما قل تغييره كان أفضل. 8.000 في معظم التطبيقات لا تحتاج إلى ذلك.

```solidity
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

16.000 يتضمن عناوين الرموز، وعنوان تبادل الزوج، والعدد الإجمالي لعمليات التبادل التي يديرها المصنع.

```solidity
    constructor(address _feeToSetter) public {
        feeToSetter = _feeToSetter;
    }
```

2.000 إيداع أربعة من كل نوع

```solidity
12.000
```

تُرجع هذه الدالة عدد أزواج التبادل.

```solidity
144
```

24.000 لاحظ أنه يمكن لأي شخص استدعاء هذه الدالة. لا تحتاج إلى إذن من Uniswap لإنشاء تبادل زوج جديد.

```solidity
        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
```

إيداع اثنين من كل نوع
14.000

```solidity
        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // فحص واحد كافٍ
```

196 28.000 إذا كان هناك تبادل موجود بالفعل، فلا داعي لإنشاء تبادل آخر لنفس الزوج.

```solidity
        bytes memory bytecode = type(UniswapV2Pair).creationCode;
```

لإنشاء عقد جديد، نحتاج إلى الرمز البرمجي الذي ينشئه (كل من دالة المنشئ والرمز البرمجي الذي يكتب الرمز الثانوي لآلة إيثريوم الافتراضية للعقد الفعلي إلى الذاكرة). إيداع قيمة غير متساوية
18.000 لم تعد هذه مشكلة، لأن [سوليديتي تدعم الآن CREATE2](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2).

```solidity
252
```

32.000

```solidity
        IUniswapV2Pair(pair).initialize(token0, token1);
```

استدعِ دالة `initialize` لإخبار التبادل الجديد بالرمزين اللذين يتبادلهما.

```solidity
~2.286
```

بعد المراجحة

```solidity
~15.874
```

تسمح هاتان الدالتان لـ `feeSetter` بالتحكم في مستلم الرسوم (إن وجد)، وتغيير `feeSetter` إلى عنوان جديد.

### UniswapV2ERC20.sol {#UniswapV2ERC20}

~31.748 إنه مشابه لـ [عقد ERC-20 الخاص بـ OpenZeppelin](/developers/tutorials/erc20-annotated-code)، لذا سأشرح فقط الجزء المختلف، وهو وظيفة `permit`.

تكلف المعاملات على إيثريوم عملة إيثر (ETH)، وهو ما يعادل المال الحقيقي. ~2.267         }
require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
_mint(to, liquidity);
استخدم وظيفة `UniswapV2ERC20._mint` لإنشاء رموز السيولة الإضافية وإعطائها للحساب الصحيح.
_update(balance0, balance1, _reserve0, _reserve1);
if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
emit Mint(msg.sender, amount0, amount1);
}

```solidity
حدّث متغيرات الحالة (`reserve0`، `reserve1`، وإذا لزم الأمر `kLast`) وأصدر الحدث المناسب.
```

burn     // this low-level function should be called from a contract which performs important safety checks
function burn(address to) external lock returns (uint amount0, uint amount1) {

```solidity
يتم استدعاء هذه الوظيفة عند سحب السيولة وحاجة إلى حرق رموز السيولة المناسبة.
```

يجب أيضًا استدعاؤها [من حساب طرفي](#UniswapV2Router02).         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
address _token0 = token0;                                // gas savings
address _token1 = token1;                                // gas savings
uint balance0 = IERC20(_token0).balanceOf(address(this));
uint balance1 = IERC20(_token1).balanceOf(address(this));
uint liquidity = balanceOf[address(this)]; نقل العقد الطرفي السيولة ليتم حرقها إلى هذا العقد قبل الاستدعاء. بهذه الطريقة نعرف مقدار السيولة التي يجب حرقها، ويمكننا التأكد من حرقها.

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
```

يتلقى مزود السيولة قيمة متساوية من كلا الرمزين. بهذه الطريقة لا نغير سعر التداول.         _burn(address(this), liquidity);
_safeTransfer(_token0, to, amount0);
_safeTransfer(_token1, to, amount1);
balance0 = IERC20(_token0).balanceOf(address(this));
balance1 = IERC20(_token1).balanceOf(address(this));```
    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
```

```solidity
بقية وظيفة `الحرق` هي صورة طبق الأصل من وظيفة `السك` أعلاه.
```

مبادلة

```solidity
    // this low-level function should be called from a contract which performs important safety checks
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
```

من المفترض أيضًا استدعاء هذه الوظيفة من [عقد طرفي](#UniswapV2Router02).         require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');```
    uint balance0;
    uint balance1;
    { // scope for _token{0,1}, avoids stack too deep errors
```

```solidity
يمكن تخزين المتغيرات المحلية إما في الذاكرة أو، إذا لم يكن هناك الكثير منها، مباشرة على المكدس.
```

إذا تمكنا من تحديد العدد لاستخدام المكدس، فإننا نستخدم غازًا أقل.

```solidity
لمزيد من التفاصيل، راجع [الورقة الصفراء، المواصفات الرسمية لإيثريوم](https://ethereum.github.io/yellowpaper/paper.pdf)، ص. 26، المعادلة 298.
```

```
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens هذا النقل متفائل، لأننا ننقل قبل أن نتأكد من استيفاء جميع الشروط.
```

لا بأس بذلك في إيثريوم لأنه إذا لم يتم استيفاء الشروط لاحقًا في الاستدعاء، فإننا نعود منه ومن أي تغييرات أنشأها.

```solidity
            if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
```

أبلغ المستلم بالمبادلة إذا طُلب ذلك.

```solidity
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
```

احصل على الأرصدة الحالية.

## يرسل العقد الطرفي الرموز إلينا قبل استدعائنا للمبادلة.

هذا يسهل على العقد التحقق من عدم خداعه، وهو فحص _يجب_ أن يحدث في العقد الأساسي (لأننا يمكن أن نستدعي من قبل كيانات أخرى غير عقدنا الطرفي).         uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
{ // scope for reserve{0,1}Adjusted, avoids stack too deep errors
uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000\*\*2), 'UniswapV2: K'); هذا فحص سلامة للتأكد من أننا لا نخسر من المبادلة. لا يوجد ظرف يجب أن تقلل فيه المبادلة من `reserve0*reserve1`. هذا هو المكان الذي نضمن فيه أيضًا إرسال رسوم بنسبة 0.3% عند المبادلة؛ قبل فحص قيمة K، نضرب كلا الرصيدين في 1000 مطروحًا منه المبالغ مضروبة في 3، وهذا يعني خصم 0.3% (3/1000 = 0.003 = 0.3%) من الرصيد قبل مقارنة قيمة K الخاصة به بقيمة K للاحتياطيات الحالية.

### ```

    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

حدّث `reserve0` و `reserve1`، وإذا لزم الأمر، مجمعات الأسعار والختم الزمني وأصدر حدثًا. المزامنة أو القشط

### من الممكن أن تخرج الأرصدة الحقيقية عن التزامن مع الاحتياطيات التي يعتقد تداول الزوج أنه يمتلكها.

لا توجد طريقة لسحب الرموز دون موافقة العقد، لكن الإيداعات مسألة مختلفة.
يمكن للحساب نقل الرموز إلى منصة التداول دون استدعاء `mint` أو `swap`.

```solidity
في هذه الحالة يوجد حلان:
```

`sync`، تحديث الاحتياطيات إلى الأرصدة الحالية `skim`، اسحب المبلغ الإضافي. لاحظ أنه يسمح لأي حساب باستدعاء `skim` لأننا لا نعرف من أودع الرموز. يتم إصدار هذه المعلومات في حدث، ولكن لا يمكن الوصول إلى الأحداث من البلوكتشين.     // force balances to match reserves
function skim(address to) external lock {
address _token0 = token0; // gas savings
address _token1 = token1; // gas savings
_safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
_safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
}```
// force reserves to match balances
function sync() external lock {
    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
}
```} UniswapV2Factory.sol {#UniswapV2Factory} يقوم [هذا العقد](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol) بإنشاء منصات تداول الأزواج.

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Factory.sol';
import './UniswapV2Pair.sol';

contract UniswapV2Factory is IUniswapV2Factory {
    address public feeTo;
    address public feeToSetter;
```

متغيرات الحالة هذه ضرورية لتنفيذ رسوم البروتوكول (انظر [دليل الاستخدام](https://app.uniswap.org/whitepaper.pdf)، ص 5). يجمع عنوان `feeTo` رموز السيولة لرسوم البروتوكول، و `feeToSetter` هو العنوان المسموح له بتغيير `feeTo` إلى عنوان مختلف.     mapping(address => mapping(address => address)) public getPair;
address[] public allPairs;

```solidity
تتتبع هذه المتغيرات الأزواج، وهي منصات التداول بين نوعي الرموز.
```

الأول، `getPair`، هو تخطيط يحدد عقد تداول الزوج بناءً على رمزي ERC-20 اللذين يتداولهما.

```solidity
يتم تحديد رموز ERC-20 من خلال عناوين العقود التي تنفذها، لذلك تكون المفاتيح والقيمة كلها عناوين.
```

للحصول على عنوان تداول الزوج الذي يتيح لك التحويل من `tokenA` إلى `tokenB`، يمكنك استخدام `getPair[<عنوان tokenA>][<عنوان tokenB>]` (أو العكس).

```solidity
المتغير الثاني، `allPairs`، هو مصفوفة تتضمن جميع عناوين منصات تداول الأزواج التي أنشأها هذا المصنع.
```

في إيثريوم، لا يمكنك التكرار على محتوى التخطيط، أو الحصول على قائمة بجميع المفاتيح، لذلك هذا المتغير هو الطريقة الوحيدة لمعرفة منصات التداول التي يديرها هذا المصنع. ملاحظة: السبب الذي يجعلك لا تستطيع التكرار على جميع مفاتيح التخطيط هو أن تخزين بيانات العقد _مكلف_، لذلك كلما قل استخدامه كان ذلك أفضل، وكلما قل تغييره كان ذلك أفضل.

#### يمكنك إنشاء [تخطيطات تدعم التكرار](https://github.com/ethereum/dapp-bin/library/iterable_mapping.sol)، ولكنها تتطلب تخزينًا إضافيًا لقائمة من المفاتيح.

في معظم التطبيقات لا تحتاج إلى ذلك.

```solidity
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

يُصدر هذا الحدث عند إنشاء تداول زوجي جديد.

```solidity
يتضمن عناوين الرموز، وعنوان تداول الزوج، والعدد الإجمالي لمنصات التداول التي يديرها المصنع.
```

```
constructor(address _feeToSetter) public {
    feeToSetter = _feeToSetter;
}
```

```solidity
الشيء الوحيد الذي يقوم به المنشئ هو تحديد `feeToSetter`.
```

تبدأ المصانع بدون رسوم، ولا يمكن إلا لـ `feeSetter` تغيير ذلك.     function allPairsLength() external view returns (uint) {
return allPairs.length;
}

```solidity
تعيد هذه الوظيفة عدد أزواج التداول.
```

```
function createPair(address tokenA, address tokenB) external returns (address pair) { هذه هي الوظيفة الرئيسية للمصنع، وهي إنشاء تداول زوجي بين رمزين من رموز ERC-20. لاحظ أنه يمكن لأي شخص استدعاء هذه الوظيفة.
```

لا تحتاج إلى إذن من Uniswap لإنشاء تداول زوجي جديد.         require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
(address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);

نريد أن يكون عنوان منصة التداول الجديدة حتميًا، بحيث يمكن حسابه مسبقًا خارج السلسلة (يمكن أن يكون هذا مفيدًا [لمعاملات الطبقة الثانية](/developers/docs/scaling/)).

| Parameter                                                                                                                                                                   |                                                                                                                                                                                                                                                      Value |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| مجمعات السيولة الكبيرة أفضل من الصغيرة، لأن أسعارها أكثر استقرارًا.                                                                                         |                                                                                                                                                                           لا نريد أن يكون لدينا أكثر من مجمع سيولة واحد لكل زوج من الرموز. |
| إذا كان هناك بالفعل تداول، فلا داعي لإنشاء تداول آخر لنفس الزوج.                                                                                            |                                                                                                                                                                           لا نريد أن يكون لدينا أكثر من مجمع سيولة واحد لكل زوج من الرموز. |
| لإنشاء عقد جديد، نحتاج إلى النص البرمجي الذي ينشئه (كل من وظيفة المنشئ والنص البرمجي الذي يكتب إلى الذاكرة رمز البايت EVM للعقد الفعلي). | عادةً في Solidity، نستخدم فقط `addr = new <name of contract>(<constructor parameters>)` ويتولى المترجم كل شيء نيابة عنا، ولكن للحصول على عنوان عقد حتمي، نحتاج إلى استخدام [رمز التشغيل CREATE2](https://eips.ethereum.org/EIPS/eip-1014). |
| عندما كتب هذا النص البرمجي، لم يكن رمز التشغيل هذا مدعومًا بعد من قبل Solidity، لذلك كان من الضروري الحصول على النص البرمجي يدويًا.                         |                                                                                     لم تعد هذه مشكلة، لأن [Solidity الآن يدعم CREATE2](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2). |

```
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    } عندما لا يدعم Solidity رمز تشغيل بعد، يمكننا استدعاؤه باستخدام [التجميع المضمّن](https://docs.soliditylang.org/en/v0.8.3/assembly.html).
```

```
    IUniswapV2Pair(pair).initialize(token0, token1); استدعِ وظيفة `initialize` لإخبار منصة التداول الجديدة بالرمزين اللذين تتداولهما.
```

```solidity
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair; // populate mapping in the reverse direction
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }
```

احفظ معلومات الزوج الجديدة في متغيرات الحالة وأصدر حدثًا لإعلام العالم بتداول الزوج الجديد.

```solidity
    function setFeeTo(address _feeTo) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeTo = _feeTo;
    }

    function setFeeToSetter(address _feeToSetter) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeToSetter = _feeToSetter;
    }
}
```

تسمح هاتان الوظيفتان لـ `feeSetter` بالتحكم في مستلم الرسوم (إن وجد)، وتغيير `feeSetter` إلى عنوان جديد.

```solidity
UniswapV2ERC20.sol {#UniswapV2ERC20}
```

ينفذ [هذا العقد](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol) رمز السيولة ERC-20.

```solidity
إنه مشابه [لعقد ERC-20 الخاص بـ OpenZeppelin](/developers/tutorials/erc20-annotated-code)، لذا سأشرح فقط الجزء المختلف، وهو وظيفة `permit`.
```

تكلف المعاملات على إيثريوم عملة الإيثر (ETH)، وهو ما يعادل النقود الحقيقية. إذا كان لديك رموز ERC-20 ولكن ليس لديك ETH، فلا يمكنك إرسال معاملات، لذلك لا يمكنك فعل أي شيء بها.

```solidity
أحد الحلول لتجنب هذه المشكلة هو [المعاملات الوصفية](https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/supporting-meta-transactions).
```

يوقع مالك الرموز معاملة تسمح لشخص آخر بسحب الرموز خارج السلسلة وإرسالها باستخدام الإنترنت إلى المستلم. يقوم المستلم، الذي يمتلك ETH، بتقديم التصريح نيابة عن المالك.

```solidity
    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
```

هذه التجزئة (هاش) هي [معرّف نوع المعاملة](https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash).

```solidity
الوحيد الذي ندعمه هنا هو `Permit` بهذه المعلمات.
```

```
mapping(address => uint) public nonces; ليس من الممكن للمستلم تزييف توقيع رقمي. ومع ذلك، من السهل إرسال نفس المعاملة مرتين (وهذا شكل من أشكال [هجوم إعادة التشغيل](https://wikipedia.org/wiki/Replay_attack)).
```

لمنع ذلك، نستخدم [nonce](https://wikipedia.org/wiki/Cryptographic_nonce). إذا لم يكن nonce `Permit` الجديد أكبر بواحد من الأخير المستخدم، فإننا نفترضه غير صالح.     constructor() public {
uint chainId;
assembly {
chainId := chainid
} هذا هو النص البرمجي لاسترداد [معرّف السلسلة](https://chainid.network/). يستخدم لهجة تجميع EVM تسمى [Yul](https://docs.soliditylang.org/en/v0.8.4/yul.html). لاحظ أنه في الإصدار الحالي من Yul، يجب عليك استخدام `chainid()`، وليس `chainid`.

```
    DOMAIN_SEPARATOR = keccak256(
        abi.encode(
            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
            keccak256(bytes(name)),
            keccak256(bytes('1')),
            chainId,
            address(this)
        )
    );
}
```

حساب [فاصل النطاق](https://eips.ethereum.org/EIPS/eip-712#rationale-for-domainseparator) لـ EIP-712.     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {

```solidity
هذه هي الوظيفة التي تنفذ الأذونات.
```

تتلقى كمعلمات الحقول ذات الصلة، والقيم العددية الثلاث [للتوقيع](https://yos.io/2018/11/16/ethereum-signatures/) (v، r، وs).         require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');

.         bytes32 digest = keccak256(
abi.encodePacked(
'\x19\x01',
DOMAIN_SEPARATOR,
keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
)
); `abi.encodePacked(...)` هي الرسالة التي نتوقع الحصول عليها.

```solidity
نحن نعرف ما يجب أن يكون عليه nonce، لذلك لا داعي للحصول عليه كمعامل.
```

تتوقع خوارزمية توقيع إيثريوم الحصول على 256 بت للتوقيع، لذلك نستخدم دالة التجزئة `keccak256`.         address recoveredAddress = ecrecover(digest, v, r, s);

```solidity
من الملخص والتوقيع، يمكننا الحصول على العنوان الذي وقع عليه باستخدام [ecrecover](https://coders-errand.com/ecrecover-signature-verification-ethereum/).
```

```
    require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
    _approve(owner, spender, value);
}
```

```solidity
إذا كان كل شيء على ما يرام، فتعامل مع هذا على أنه [موافقة ERC-20](https://eips.ethereum.org/EIPS/eip-20#approve).
```

العقود الطرفية {#periphery-contracts} العقود الطرفية هي واجهة برمجة التطبيقات (API) لـ Uniswap.

```solidity
وهي متاحة للاستدعاءات الخارجية، إما من عقود أخرى أو تطبيقات لامركزية.
```

يمكنك استدعاء العقود الأساسية مباشرة، لكن ذلك أكثر تعقيدًا وقد تخسر قيمة إذا ارتكبت خطأ. تحتوي العقود الأساسية فقط على اختبارات للتأكد من عدم خداعها، وليس فحوصات سلامة لأي شخص آخر. تلك موجودة في الطرفية بحيث يمكن تحديثها حسب الحاجة.

```solidity
UniswapV2Router01.sol {#UniswapV2Router01}
```

يحتوي [هذا العقد](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol) على مشاكل، و[يجب عدم استخدامه بعد الآن](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01). لحسن الحظ، العقود الطرفية عديمة الحالة ولا تحتفظ بأي أصول، لذلك من السهل إهمالها واقتراح استخدام البديل، `UniswapV2Router02`، بدلاً من ذلك. UniswapV2Router02.sol {#UniswapV2Router02}

```solidity
في معظم الحالات، ستستخدم Uniswap من خلال [هذا العقد](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol).
```

يمكنك أن ترى كيفية استخدامه [هنا](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02).

#### pragma solidity =0.6.6;import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';&#xA;import '@uniswap/lib/contracts/libraries/TransferHelper.sol';import './interfaces/IUniswapV2Router02.sol';&#xA;import './libraries/UniswapV2Library.sol';&#xA;import './libraries/SafeMath.sol';&#xA;import './interfaces/IERC20.sol';&#xA;import './interfaces/IWETH.sol';

معظم هذه الأشياء إما واجهناها من قبل، أو أنها واضحة إلى حد ما.

```solidity
الاستثناء الوحيد هو `IWETH.sol`.
```

يسمح Uniswap v2 بالتبادلات لأي زوج من رموز ERC-20، لكن الإيثر (ETH) نفسه ليس رمز ERC-20. إنه يسبق المعيار ويتم نقله بآليات فريدة.

```solidity
لتمكين استخدام ETH في العقود التي تنطبق على رموز ERC-20، توصل الناس إلى عقد [الإيثر المغلف (WETH)](https://weth.tkn.eth.limo/).
```

ترسل إلى هذا العقد ETH، وهو يسك لك كمية معادلة من WETH.

```solidity
أو يمكنك حرق WETH، واستعادة ETH.
```

contract UniswapV2Router02 is IUniswapV2Router02 {
using SafeMath for uint;```
address public immutable override factory;
address public immutable override WETH; يحتاج الموجه إلى معرفة أي مصنع يجب استخدامه، وللمعاملات التي تتطلب WETH، أي عقد WETH يجب استخدامه.
```

```solidity
هذه القيم [غير قابلة للتغيير](https://docs.soliditylang.org/en/v0.8.3/contracts.html#constant-and-immutable-state-variables)، مما يعني أنه لا يمكن تعيينها إلا في المنشئ.
```

هذا يمنح المستخدمين الثقة في أنه لن يتمكن أي شخص من تغييرها لتوجيهها إلى عقود أقل صدقًا.

```solidity
    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }
```

يتأكد هذا المعدِّل من أن المعاملات المحددة بوقت ("افعل X قبل الوقت Y إذا استطعت") لا تحدث بعد انتهاء مدتها.

```solidity
    constructor(address _factory, address _WETH) public {
        factory = _factory;
        WETH = _WETH;
    }
```

يقوم المنشئ فقط بتعيين متغيرات الحالة غير القابلة للتغيير.

```solidity
    receive() external payable {
        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
    }
```

يتم استدعاء هذه الوظيفة عندما نسترد الرموز من عقد WETH مرة أخرى إلى ETH.

```solidity
فقط عقد WETH الذي نستخدمه هو المصرح له بذلك.
```

إضافة السيولة {#add-liquidity} تضيف هذه الوظائف رموزًا إلى تداول الزوج، مما يزيد من مجمع السيولة.

```solidity

    // **** ADD LIQUIDITY ****
    function _addLiquidity(,
```

الدالة النهائية تجمع بين رسوم التخزين والمعاملات الوصفية.

#### التداول {#trade}

```solidity
    // **** مبادلة ****
    // يتطلب أن يكون المبلغ الأولي قد أُرسل بالفعل إلى الزوج الأول
    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {
```

تنفذ هذه الدالة المعالجة الداخلية المطلوبة للدوال التي يتم عرضها للمتداولين.

```solidity
        for (uint i; i < path.length - 1; i++) {
```

بينما أكتب هذا، هناك [388,160 من رموز ERC-20](https://eth.blockscout.com/tokens). إذا كان هناك تبادل أزواج لكل زوج من الرموز، فسيكون هناك أكثر من 150 مليار تبادل أزواج. السلسلة بأكملها، في الوقت الحالي، [لديها فقط 0.1% من هذا العدد من الحسابات](https://eth.blockscout.com/stats/accountsGrowth). بدلاً من ذلك، تدعم دوال المبادلة مفهوم المسار. يمكن للمتداول تبادل A مقابل B، و B مقابل C، و C مقابل D، لذلك ليست هناك حاجة لتبادل أزواج مباشر من A-D.

تميل الأسعار في هذه الأسواق إلى أن تكون متزامنة، لأنه عندما تكون غير متزامنة، فإنها تخلق فرصة للمراجحة. تخيل، على سبيل المثال، ثلاثة رموز، A و B و C. هناك ثلاثة تبادلات أزواج، واحد لكل زوج.

1. الوضع الأولي
2. يبيع المتداول 24.695 من رموز A ويحصل على 25.305 من رموز B.
3. يبيع المتداول 24.695 من رموز B مقابل 25.305 من رموز C، محتفظًا بما يقرب من 0.61 من رموز B كربح.
4. ثم يبيع المتداول 24.695 من رموز C مقابل 25.305 من رموز A، محتفظًا بما يقرب من 0.61 من رموز C كربح. لدى المتداول أيضًا 0.61 من رموز A إضافية (الـ 25.305 التي ينتهي بها المتداول، مطروحًا منها الاستثمار الأصلي البالغ 24.695).

| الخطوة | تبادل A-B                                                                                   | تبادل B-C                                                                                   | تبادل A-C                                                                                   |
| ------ | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| ١      | A:1000 B:1050 A/B=1.05                      | B:1000 C:1050 B/C=1.05                      | A:1050 C:1000 C/A=1.05                      |
| 2      | A:1024.695 B:1024.695 A/B=1 | B:1000 C:1050 B/C=1.05                      | A:1050 C:1000 C/A=1.05                      |
| 3      | A:1024.695 B:1024.695 A/B=1 | B:1024.695 C:1024.695 B/C=1 | A:1050 C:1000 C/A=1.05                      |
| 4      | A:1024.695 B:1024.695 A/B=1 | B:1024.695 C:1024.695 B/C=1 | A:1024.695 C:1024.695 C/A=1 |

```solidity
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            uint amountOut = amounts[i + 1];
```

احصل على الزوج الذي نتعامل معه حاليًا، ورتبه (لاستخدامه مع الزوج) واحصل على مبلغ الخرج المتوقع.

```solidity
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
```

احصل على مبالغ الخرج المتوقعة، مرتبة بالطريقة التي يتوقعها تبادل الأزواج.

```solidity
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
```

هل هذا هو التبادل الأخير؟ إذا كان الأمر كذلك، أرسل الرموز التي تم استلامها مقابل التداول إلى الوجهة. إذا لم يكن كذلك، أرسلها إلى تبادل الأزواج التالي.

```solidity

            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
                amount0Out, amount1Out, to, new bytes(0)
            );
        }
    }
```

استدعاء تبادل الأزواج فعليًا لمبادلة الرموز. لا نحتاج إلى رد نداء لإعلامنا بالتبادل، لذلك لا نرسل أي بايت في هذا الحقل.

```solidity
    function swapExactTokensForTokens(
```

يستخدم المتداولون هذه الدالة مباشرة لمبادلة رمز برمز آخر.

```solidity
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
```

يحتوي هذا المعامل على عناوين عقود ERC-20. كما هو موضح أعلاه، هذه مصفوفة لأنه قد تحتاج إلى المرور عبر عدة تبادلات أزواج للانتقال من الأصل الذي لديك إلى الأصل الذي تريده.

يمكن تخزين معامل الدالة في لغة Solidity إما في `memory` أو `calldata`. إذا كانت الدالة نقطة دخول إلى العقد، يتم استدعاؤها مباشرة من مستخدم (باستخدام معاملة) أو من عقد مختلف، فيمكن أخذ قيمة المعامل مباشرة من بيانات الاستدعاء. إذا تم استدعاء الدالة داخليًا، مثل `_swap` أعلاه، فيجب تخزين المعاملات في `memory`. من منظور العقد المستدعى، فإن `calldata` للقراءة فقط.

مع الأنواع العددية مثل `uint` أو `address`، يتعامل المترجم مع اختيار التخزين لنا، ولكن مع المصفوفات، التي تكون أطول وأكثر تكلفة، نحدد نوع التخزين الذي سيتم استخدامه.

```solidity
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
```

يتم دائمًا إرجاع القيم المرتجعة في الذاكرة.

```solidity
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
```

احسب المبلغ الذي سيتم شراؤه في كل مبادلة. إذا كانت النتيجة أقل من الحد الأدنى الذي يرغب المتداول في قبوله، فقم بإلغاء المعاملة.

```solidity
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

أخيرًا، انقل رمز ERC-20 الأولي إلى حساب أول تبادل أزواج واستدعِ `_swap`. يحدث كل هذا في نفس المعاملة، لذلك يعرف تبادل الأزواج أن أي رموز غير متوقعة هي جزء من هذا التحويل.

```solidity
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
```

الدالة السابقة, `swapTokensForTokens`، تسمح للمتداول بتحديد عدد دقيق من رموز الإدخال التي يرغب في إعطائها والحد الأدنى من رموز الإخراج التي يرغب في الحصول عليها في المقابل. تقوم هذه الدالة بالمبادلة العكسية، فهي تتيح للمتداول تحديد عدد رموز الإخراج التي يريدها، والحد الأقصى لعدد رموز الإدخال التي يرغب في دفعها مقابلها.

في كلتا الحالتين، يجب على المتداول أن يمنح هذا العقد المحيطي أولاً سماحية للسماح له بنقلها.

```solidity
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
    }


    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }



    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }


    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        virtual
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
        // استرداد أي أثر من عملة الإيثريوم، إن وجد
        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);
    }
```

تتضمن هذه الأنواع الأربعة جميعها التداول بين ETH والرموز. الفرق الوحيد هو أننا إما نتلقى ETH من المتداول ونستخدمه لسك WETH، أو نتلقى WETH من التبادل الأخير في المسار ونحرقه، ونعيد إلى المتداول عملة ETH الناتجة.

```solidity
    // **** مبادلة (دعم الرموز التي تفرض رسومًا عند التحويل) ****
    // يتطلب أن يكون المبلغ الأولي قد أُرسل بالفعل إلى الزوج الأول
    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {
```

هذه هي الدالة الداخلية لمبادلة الرموز التي لها رسوم نقل أو تخزين لحل ([هذه المشكلة](https://github.com/Uniswap/uniswap-interface/issues/835)).

```solidity
        for (uint i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));
            uint amountInput;
            uint amountOutput;
            { // نطاق لتجنب أخطاء "مكدس عميق جدًا"
            (uint reserve0, uint reserve1,) = pair.getReserves();
            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
```

بسبب رسوم التحويل، لا يمكننا الاعتماد على دالة `getAmountsOut` لإخبارنا بالمبلغ الذي نحصل عليه من كل تحويل (بالطريقة التي نتبعها قبل استدعاء `_swap` الأصلية). بدلاً من ذلك، يتعين علينا التحويل أولاً ثم رؤية عدد الرموز التي استردناها.

ملاحظة: من الناحية النظرية، يمكننا فقط استخدام هذه الدالة بدلاً من `_swap`، ولكن في حالات معينة (على سبيل المثال، إذا انتهى الأمر بإلغاء التحويل لعدم وجود ما يكفي في النهاية لتلبية الحد الأدنى المطلوب) سينتهي الأمر بتكلفة غاز أعلى. رموز رسوم التحويل نادرة جدًا، لذلك بينما نحتاج إلى استيعابها، ليست هناك حاجة لجميع المبادلات لتفترض أنها تمر عبر واحدة منها على الأقل.

```solidity
            }
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
            pair.swap(amount0Out, amount1Out, to, new bytes(0));
        }
    }


    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) {
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        payable
        ensure(deadline)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        uint amountIn = msg.value;
        IWETH(WETH).deposit{value: amountIn}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));
        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
        _swapSupportingFeeOnTransferTokens(path, to);
        require(
            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'
        );
    }


    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    )
        external
        virtual
        override
        ensure(deadline)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
        );
        _swapSupportingFeeOnTransferTokens(path, address(this));
        uint amountOut = IERC20(WETH).balanceOf(address(this));
        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).withdraw(amountOut);
        TransferHelper.safeTransferETH(to, amountOut);
    }
```

هذه هي نفس المتغيرات المستخدمة للرموز العادية، لكنها تستدعي `_swapSupportingFeeOnTransferTokens` بدلاً من ذلك.

```solidity
    // **** دوال المكتبة ****
    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {
        return UniswapV2Library.quote(amountA, reserveA, reserveB);
    }

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountOut)
    {
        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
    }

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)
        public
        pure
        virtual
        override
        returns (uint amountIn)
    {
        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);
    }

    function getAmountsOut(uint amountIn, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsOut(factory, amountIn, path);
    }

    function getAmountsIn(uint amountOut, address[] memory path)
        public
        view
        virtual
        override
        returns (uint[] memory amounts)
    {
        return UniswapV2Library.getAmountsIn(factory, amountOut, path);
    }
}
```

هذه الدوال هي مجرد وكلاء يستدعون [دوال UniswapV2Library](#uniswapV2library).

### UniswapV2Migrator.sol {#UniswapV2Migrator}

تم استخدام هذا العقد لترحيل التبادلات من الإصدار القديم v1 إلى v2. الآن بعد أن تم ترحيلها، لم تعد ذات صلة.

## المكتبات {#libraries}

[مكتبة SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math) موثقة جيدًا، لذلك لا داعي لتوثيقها هنا.

### الرياضيات {#Math}

تحتوي هذه المكتبة على بعض دوال الرياضيات التي لا تكون ضرورية عادةً في كود Solidity، لذلك فهي ليست جزءًا من اللغة.

```solidity
pragma solidity =0.5.16;

// مكتبة لإجراء عمليات رياضية متنوعة

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // الطريقة البابلية (https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
```

ابدأ بـ x كتقدير أعلى من الجذر التربيعي (وهذا هو السبب في أننا بحاجة إلى معاملة 1-3 كحالات خاصة).

```solidity
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
```

احصل على تقدير أقرب، وهو متوسط التقدير السابق والعدد الذي نحاول إيجاد جذره التربيعي مقسومًا على التقدير السابق. كرر حتى لا يكون التقدير الجديد أقل من التقدير الحالي. لمزيد من التفاصيل، [انظر هنا](https://wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).

```solidity
            }
        } else if (y != 0) {
            z = 1;
```

لا يجب أن نحتاج أبدًا إلى الجذر التربيعي للصفر. الجذور التربيعية للواحد والاثنين والثلاثة هي واحد تقريبًا (نستخدم أعدادًا صحيحة، لذلك نتجاهل الكسر).

```solidity
        }
    }
}
```

### كسور النقطة الثابتة (UQ112x112) {#FixedPoint}

تتعامل هذه المكتبة مع الكسور، التي لا تكون عادةً جزءًا من حسابات إيثريوم. يقوم بذلك عن طريق ترميز الرقم _x_ كـ _x\*2^112_. هذا يتيح لنا استخدام أكواد التشغيل الأصلية للجمع والطرح دون تغيير.

```solidity
pragma solidity =0.5.16;

// مكتبة للتعامل مع أرقام النقطة الثابتة الثنائية (https://wikipedia.org/wiki/Q_(number_format))

// النطاق: [0, 2**112 - 1]
// الدقة: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;
```

`Q112` هو ترميز الرقم واحد.

```solidity
    // ترميز uint112 كـ UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // لا يتجاوز أبدًا
    }
```

نظرًا لأن y هو `uint112`، فإن أقصى ما يمكن أن يكون عليه هو 2^112-1. لا يزال من الممكن ترميز هذا الرقم كـ `UQ112x112`.

```solidity
    // قسمة UQ112x112 على uint112، مع إرجاع UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}
```

إذا قسمنا قيمتين `UQ112x112`، فلن تعد النتيجة مضروبة في 2^112. لذلك بدلاً من ذلك نأخذ عددًا صحيحًا للمقام. كنا سنحتاج إلى استخدام خدعة مماثلة للقيام بالضرب، لكننا لا نحتاج إلى ضرب قيم `UQ112x112`.

### UniswapV2Library {#uniswapV2library}

تُستخدم هذه المكتبة فقط من قبل العقود المحيطية

```solidity
pragma solidity >=0.5.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import "./SafeMath.sol";

library UniswapV2Library {
    using SafeMath for uint;

    // إرجاع عناوين الرموز المرتبة، وتُستخدم للتعامل مع القيم المرتجعة من الأزواج المرتبة بهذا الترتيب
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }
```

رتب الرمزين حسب العنوان، حتى نتمكن من الحصول على عنوان تبادل الأزواج الخاص بهما. هذا ضروري لأنه بخلاف ذلك سيكون لدينا احتمالان، أحدهما للمعاملات A,B والآخر للمعاملات B,A، مما يؤدي إلى تبادلين بدلاً من واحد.

```solidity
    // يحسب عنوان CREATE2 لزوج دون إجراء أي استدعاءات خارجية
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // تجزئة كود التهيئة
            ))));
    }
```

تحسب هذه الدالة عنوان تبادل الأزواج للرمزين. تم إنشاء هذا العقد باستخدام [كود التشغيل CREATE2](https://eips.ethereum.org/EIPS/eip-1014)، لذا يمكننا حساب العنوان باستخدام نفس الخوارزمية إذا كنا نعرف المعاملات التي يستخدمها. هذا أرخص بكثير من سؤال المصنع، و

```solidity
    // يجلب ويرتب احتياطيات الزوج
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
```

تُرجع هذه الدالة احتياطيات الرمزين التي يمتلكها تبادل الأزواج. لاحظ أنه يمكنها استقبال الرموز بأي ترتيب، وترتبها للاستخدام الداخلي.

```solidity
    // بالنظر إلى كمية معينة من أصل واحتياطيات الزوج، تُرجع كمية مكافئة من الأصل الآخر
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }
```

تمنحك هذه الدالة مقدار الرمز B الذي ستحصل عليه مقابل الرمز A إذا لم تكن هناك رسوم. يأخذ هذا الحساب في الاعتبار أن التحويل يغير سعر الصرف.

```solidity
    // بالنظر إلى كمية إدخال لأصل واحتياطيات زوج، تُرجع أقصى كمية إخراج للأصل الآخر
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
```

تعمل دالة `quote` أعلاه بشكل رائع إذا لم تكن هناك رسوم لاستخدام تبادل الأزواج. ومع ذلك، إذا كانت هناك رسوم صرف بنسبة 0.3%، فإن المبلغ الذي تحصل عليه بالفعل يكون أقل. تحسب هذه الدالة المبلغ بعد رسوم الصرف.

```solidity

        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
```

لا تتعامل Solidity مع الكسور بشكل أصلي، لذلك لا يمكننا فقط ضرب المبلغ الناتج في 0.997. بدلاً من ذلك، نضرب البسط في 997 والمقام في 1000، لتحقيق نفس التأثير.

```solidity
    // بالنظر إلى كمية إخراج لأصل واحتياطيات زوج، تُرجع كمية الإدخال المطلوبة من الأصل الآخر
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }
```

تقوم هذه الدالة بنفس الشيء تقريبًا، لكنها تحصل على مبلغ الإخراج وتوفر الإدخال.

```solidity

    // ينفذ حسابات getAmountOut متسلسلة على أي عدد من الأزواج
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // ينفذ حسابات getAmountIn متسلسلة على أي عدد من الأزواج
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}
```

تتعامل هاتان الدالتان مع تحديد القيم عندما يكون من الضروري المرور عبر عدة تبادلات للأزواج.

### مساعد التحويل {#transfer-helper}

[هذه المكتبة](https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol) تضيف عمليات تحقق من النجاح حول تحويلات ERC-20 وEthereum لمعاملة الإلغاء وإرجاع القيمة `false` بنفس الطريقة.

```solidity
// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity >=0.6.0;

// دوال مساعدة للتفاعل مع رموز ERC20 وإرسال ETH التي لا تُرجع دائمًا true/false
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));

```

يمكننا استدعاء عقد مختلف بإحدى طريقتين:

- استخدام تعريف واجهة لإنشاء استدعاء دالة
- استخدام [واجهة التطبيق الثنائية (ABI)](https://docs.soliditylang.org/en/v0.8.3/abi-spec.html) "يدويًا" لإنشاء الاستدعاء. هذا ما قرر مؤلف الكود أن يفعله.

```solidity
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }
```

من أجل التوافق مع الإصدارات السابقة للرموز التي تم إنشاؤها قبل معيار ERC-20، يمكن أن يفشل استدعاء ERC-20 إما عن طريق الإلغاء (وفي هذه الحالة يكون `success` هو `false`) أو عن طريق النجاح وإرجاع القيمة `false` (وفي هذه الحالة توجد بيانات مخرجة، وإذا قمت بفك ترميزها كقيمة منطقية، فستحصل على `false`).

```solidity


    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }
```

تنفذ هذه الدالة [وظيفة النقل الخاصة بـ ERC-20](https://eips.ethereum.org/EIPS/eip-20#transfer)، والتي تسمح لحساب بإنفاق السماحية التي يوفرها حساب مختلف.

```solidity

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }
```

تنفذ هذه الدالة [وظيفة transferFrom الخاصة بـ ERC-20](https://eips.ethereum.org/EIPS/eip-20#transferfrom)، والتي تسمح لحساب بإنفاق السماحية التي يوفرها حساب مختلف.

```solidity

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}
```

تنقل هذه الدالة الإيثر إلى حساب. أي استدعاء لعقد مختلف يمكن أن يحاول إرسال الإيثر. لأننا لا نحتاج إلى استدعاء أي دالة بالفعل، فإننا لا نرسل أي بيانات مع الاستدعاء.

## الخلاصة {#conclusion}

هذا مقال طويل يبلغ حوالي 50 صفحة. إذا وصلت إلى هنا، تهانينا! نأمل أن تكون قد فهمت الآن الاعتبارات في كتابة تطبيق واقعي (على عكس البرامج النموذجية القصيرة) وأنك أصبحت أكثر قدرة على كتابة عقود لحالات الاستخدام الخاصة بك.

الآن اذهب واكتب شيئًا مفيدًا وأذهلنا.

[انظر هنا لمزيد من أعمالي](https://cryptodocguy.pro/).
