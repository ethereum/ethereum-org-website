---
title: "جولة تفصيلية لعقد ERC-20"
description: ماذا يوجد في عقد OpenZeppelin ERC-20 ولماذا هو موجود؟
author: Ori Pomerantz
lang: ar
tags: [ "الصلابة", "erc-20" ]
skill: beginner
published: 2021-03-09
---

## مقدمة {#مقدمة}

أحد الاستخدامات الشائعة ليثريان هو أن تقوم مجموعة بإنشاء رمز قابل للتداول، بمعنى آخر العملة الخاصة بهم. عادةً ما تتبع هذه الرموز معيارًا،
[ERC-20](/developers/docs/standards/tokens/erc-20/). يجعل هذا المعيار من الممكن كتابة أدوات، مثل مجمعات السيولة والمحافظ، والتي تعمل مع جميع رموز
ERC-20. في هذا المقال سنحلل
[تطبيق OpenZeppelin Solidity ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)، بالإضافة إلى
[تعريف الواجهة](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol).

هذا كود مصدري مشروح. إذا كنت ترغب في تطبيق ERC-20،
[اقرأ هذا البرنامج التعليمي](https://docs.openzeppelin.com/contracts/2.x/erc20-supply).

## الواجهة {#the-interface}

الغرض من معيار مثل ERC-20 هو السماح بتطبيقات رموز متعددة قابلة للتشغيل البيني عبر التطبيقات، مثل المحافظ ومنصات التبادل اللامركزية. لتحقيق ذلك، نقوم بإنشاء
[واجهة](https://www.geeksforgeeks.org/solidity/solidity-basics-of-interface/). يمكن لأي كود يحتاج إلى استخدام عقد الرمز
استخدام نفس التعريفات في الواجهة ويكون متوافقًا مع جميع عقود الرموز التي تستخدمه، سواء كان محفظة مثل
MetaMask، أو تطبيقًا لامركزيًا مثل etherscan.io، أو عقدًا مختلفًا مثل مجمع السيولة.

![توضيح لواجهة ERC-20](erc20_interface.png)

إذا كنت مبرمجًا ذا خبرة، فربما تتذكر رؤية بنيات مماثلة في [Java](https://www.w3schools.com/java/java_interface.asp)
أو حتى في [ملفات ترويسة لغة C](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html).

هذا هو تعريف [واجهة ERC-20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol)
من OpenZeppelin. إنها ترجمة [للمعيار القابل للقراءة البشرية](https://eips.ethereum.org/EIPS/eip-20) إلى كود Solidity. بالطبع، الواجهة
نفسها لا تحدد _كيفية_ فعل أي شيء. هذا مشروح في الكود المصدري للعقد أدناه.

&nbsp;

```solidity
// SPDX-License-Identifier: MIT
```

من المفترض أن تتضمن ملفات Solidity مُعرِّف ترخيص. [يمكنك رؤية قائمة التراخيص هنا](https://spdx.org/licenses/). إذا كنت بحاجة إلى ترخيص
مختلف، فقط وضحه في التعليقات.

&nbsp;

```solidity
pragma solidity >=0.6.0 <0.8.0;
```

لا تزال لغة Solidity تتطور بسرعة، وقد لا تكون الإصدارات الجديدة متوافقة مع الكود القديم
([انظر هنا](https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html)). لذلك، من الجيد تحديد ليس فقط الحد الأدنى
لإصدار اللغة، ولكن أيضًا الحد الأقصى للإصدار، وهو أحدث إصدار اختبرت الكود به.

&nbsp;

```solidity
/**
 * @dev واجهة معيار ERC20 كما هو محدد في EIP.
 */
```

إن `@dev` في التعليق هو جزء من [تنسيق NatSpec](https://docs.soliditylang.org/en/develop/natspec-format.html)، ويُستخدم لإنتاج
التوثيق من الكود المصدري.

&nbsp;

```solidity
interface IERC20 {
```

وفقًا للعرف، تبدأ أسماء الواجهات بـ `I`.

&nbsp;

```solidity
    /**
     * @dev تُرجع كمية الرموز الموجودة.
     */
    function totalSupply() external view returns (uint256);
```

هذه الدالة `external`، مما يعني أنه [لا يمكن استدعاؤها إلا من خارج العقد](https://docs.soliditylang.org/en/v0.7.0/cheatsheet.html#index-2).
تُرجع إجمالي المعروض من الرموز في العقد. تُرجع هذه القيمة باستخدام النوع الأكثر شيوعًا في Ethereum، وهو 256 بت غير مُوقَّعة (256 بت هو
حجم الكلمة الأصلي لـ EVM). هذه الدالة هي أيضًا `view`، مما يعني أنها لا تغير الحالة، لذا يمكن تنفيذها على عقدة واحدة بدلاً من أن
تُشغلها كل عقدة في البلوك تشين. هذا النوع من الدوال لا يُنشئ معاملة ولا يكلف [غازًا](/developers/docs/gas/).

**ملاحظة:** نظريًا، قد يبدو أن منشئ العقد يمكنه الغش عن طريق إرجاع إجمالي معروض أصغر من القيمة الحقيقية، مما يجعل كل رمز يبدو
أكثر قيمة مما هو عليه في الواقع. ومع ذلك، فإن هذا الخوف يتجاهل الطبيعة الحقيقية للبلوك تشين. يمكن التحقق من كل ما يحدث على البلوك تشين من قبل
كل عقدة. لتحقيق ذلك، يتوفر كود لغة الآلة والتخزين الخاص بكل عقد على كل عقدة. على الرغم من أنك لست مطالبًا بنشر كود
Solidity لعقدك، فلن يأخذك أحد على محمل الجد ما لم تنشر الكود المصدري وإصدار Solidity الذي تم تجميعه به، حتى يمكن
التحقق منه مقابل كود لغة الآلة الذي قدمته.
على سبيل المثال، انظر [هذا العقد](https://eth.blockscout.com/address/0xa530F85085C6FE2f866E7FdB716849714a89f4CD?tab=contract).

&nbsp;

```solidity
    /**
     * @dev تُرجع كمية الرموز التي يملكها `account`.
     */
    function balanceOf(address account) external view returns (uint256);
```

كما يوحي الاسم، تُرجع `balanceOf` رصيد حساب ما. يتم تحديد حسابات Ethereum في Solidity باستخدام نوع `address`، الذي يحمل 160 بت.
هي أيضًا `external` و`view`.

&nbsp;

```solidity
    /**
     * @dev تنقل `amount` من الرموز من حساب المتصل إلى `recipient`.
     *
     * تُرجع قيمة منطقية تشير إلى نجاح العملية.
     *
     * تُصدر حدث {Transfer}.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
```

تنقل دالة `transfer` الرموز من المتصل إلى عنوان مختلف. هذا يتضمن تغييرًا في الحالة، لذا فهي ليست `view`.
عندما يستدعي مستخدم هذه الدالة، فإنها تنشئ معاملة وتكلف غازًا. كما أنها تُصدر حدثًا، `Transfer`، لإبلاغ الجميع على
البلوك تشين بالحدث.

للدالة نوعان من المخرجات لنوعين مختلفين من المتصلين:

- المستخدمون الذين يستدعون الدالة مباشرة من واجهة المستخدم. عادةً ما يرسل المستخدم معاملة
  ولا ينتظر استجابة، والتي قد تستغرق وقتًا غير محدد. يمكن للمستخدم أن يرى ما حدث
  من خلال البحث عن إيصال المعاملة (الذي يتم تحديده بواسطة تجزئة (هاش) المعاملة) أو بالبحث عن
  حدث `Transfer`.
- العقود الأخرى التي تستدعي الدالة كجزء من معاملة شاملة. تحصل تلك العقود على النتيجة فورًا،
  لأنها تعمل في نفس المعاملة، لذا يمكنها استخدام القيمة المرجعة للدالة.

يتم إنشاء نفس نوع المخرجات بواسطة الدوال الأخرى التي تغير حالة العقد.

&nbsp;

تسمح المخصصات لحساب بإنفاق بعض الرموز التي تخص مالكًا مختلفًا.
هذا مفيد، على سبيل المثال، للعقود التي تعمل كبائعين. لا يمكن للعقود
مراقبة الأحداث، لذلك إذا قام مشترٍ بتحويل الرموز إلى عقد البائع
مباشرة، فلن يعرف ذلك العقد أنه تم الدفع له. بدلاً من ذلك، يسمح المشتري لعقد
البائع بإنفاق مبلغ معين، ويقوم البائع بتحويل هذا المبلغ.
يتم ذلك من خلال دالة يستدعيها عقد البائع، بحيث يمكن لعقد البائع
معرفة ما إذا كانت العملية ناجحة.

```solidity
    /**
     * @dev تُرجع العدد المتبقي من الرموز التي سيُسمح لـ `spender` بإنفاقها نيابة عن `owner` من خلال {transferFrom}. هذه القيمة
     * صفر افتراضيًا.
     *
     * تتغير هذه القيمة عند استدعاء {approve} أو {transferFrom}.
     */
    function allowance(address owner, address spender) external view returns (uint256);
```

تسمح دالة `allowance` لأي شخص بالاستعلام لمعرفة المخصص الذي يسمح به عنوان
(`owner`) لعنوان آخر (`spender`) بإنفاقه.

&nbsp;

```solidity
    /**
     * @dev تحدد `amount` كمخصص لـ `spender` على رموز المتصل.
     *
     * تُرجع قيمة منطقية تشير إلى نجاح العملية.
     *
     * هام: احذر من أن تغيير المخصص بهذه الطريقة يحمل خطر
     * أن يستخدم شخص ما المخصص القديم والجديد معًا بسبب ترتيب معاملات غير موفق. أحد الحلول الممكنة للتخفيف من حالة السباق
     * هذه هو تقليل مخصص المنفق إلى 0 أولاً وتعيين
     * القيمة المطلوبة بعد ذلك:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * تُصدر حدث {Approval}.
     */
    function approve(address spender, uint256 amount) external returns (bool);
```

تنشئ دالة `approve` مخصصًا. تأكد من قراءة الرسالة حول
كيفية إساءة استخدامه. في Ethereum، يمكنك التحكم في ترتيب معاملاتك الخاصة،
لكنك لا تستطيع التحكم في الترتيب الذي سيتم به تنفيذ معاملات الآخرين،
إلا إذا لم تقدم معاملتك حتى ترى أن معاملة الطرف الآخر قد حدثت.

&nbsp;

```solidity
    /**
     * @dev تنقل `amount` من الرموز من `sender` إلى `recipient` باستخدام
     * آلية المخصص. يتم بعد ذلك خصم `amount` من مخصص المتصل
     *.
     *
     * تُرجع قيمة منطقية تشير إلى نجاح العملية.
     *
     * تُصدر حدث {Transfer}.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```

أخيرًا، تُستخدم `transferFrom` من قبل المنفق لإنفاق المخصص بالفعل.

&nbsp;

```solidity

    /**
     * @dev يُصدر عندما يتم نقل رموز `value` من حساب (`from`) إلى
     * آخر (`to`).
     *
     * لاحظ أن `value` قد تكون صفرًا.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev يُصدر عندما يتم تعيين مخصص `spender` لـ `owner` من خلال
     * استدعاء {approve}. `value` هو المخصص الجديد.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```

تُصدر هذه الأحداث عندما تتغير حالة عقد ERC-20.

## العقد الفعلي {#the-actual-contract}

هذا هو العقد الفعلي الذي يطبق معيار ERC-20،
[مأخوذ من هنا](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol).
لا يُقصد استخدامه كما هو، ولكن يمكنك
[الوراثة](https://www.tutorialspoint.com/solidity/solidity_inheritance.htm) منه لتوسيعه إلى شيء قابل للاستخدام.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;
```

&nbsp;

### عبارات الاستيراد {#import-statements}

بالإضافة إلى تعريفات الواجهة أعلاه، يستورد تعريف العقد ملفين آخرين:

```solidity

import "../../GSN/Context.sol";
import "./IERC20.sol";
import "../../math/SafeMath.sol";
```

- `GSN/Context.sol` هو التعريفات المطلوبة لاستخدام [OpenGSN](https://www.opengsn.org/)، وهو نظام يسمح للمستخدمين الذين ليس لديهم إيثر
  باستخدام البلوك تشين. لاحظ أن هذا إصدار قديم، إذا كنت ترغب في التكامل مع OpenGSN،
  [استخدم هذا البرنامج التعليمي](https://docs.opengsn.org/javascript-client/tutorial.html).
- [مكتبة SafeMath](https://ethereumdev.io/using-safe-math-library-to-prevent-from-overflows/)، التي تمنع
  تجاوزات/تدفقات حسابية لإصدارات Solidity **<0.8.0**. في Solidity ≥0.8.0، تعود العمليات الحسابية تلقائيًا
  عند التجاوز/التدفق، مما يجعل SafeMath غير ضروري. يستخدم هذا العقد SafeMath للتوافق مع الإصدارات الأقدم من
  المجمع.

&nbsp;

يوضح هذا التعليق الغرض من العقد.

```solidity
/**
 * @dev تطبيق واجهة {IERC20}.
 *
 * هذا التطبيق لا يعتمد على طريقة إنشاء الرموز. هذا يعني
 * أنه يجب إضافة آلية توريد في عقد مشتق باستخدام {_mint}.
 * لآلية عامة، انظر {ERC20PresetMinterPauser}.
 *
 * نصيحة: للحصول على شرح مفصل، راجع دليلنا
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[كيفية
 * تطبيق آليات التوريد].
 *
 * لقد اتبعنا إرشادات OpenZeppelin العامة: تعود الدوال بدلاً
 * من إرجاع `false` عند الفشل. هذا السلوك تقليدي
 * ولا يتعارض مع توقعات تطبيقات ERC20.
 *
 * بالإضافة إلى ذلك، يتم إصدار حدث {Approval} عند استدعاء {transferFrom}.
 * يسمح هذا للتطبيقات بإعادة بناء المخصص لجميع الحسابات فقط
 * من خلال الاستماع إلى الأحداث المذكورة. قد لا تصدر التطبيقات الأخرى لـ EIP
 * هذه الأحداث، حيث إنها غير مطلوبة في المواصفات.
 *
 * أخيرًا، تمت إضافة الدالتين غير القياسيتين {decreaseAllowance} و {increaseAllowance}
 * للتخفيف من المشكلات المعروفة حول تعيين
 * المخصصات. انظر {IERC20-approve}.
 */

```

### تعريف العقد {#contract-definition}

```solidity
contract ERC20 is Context, IERC20 {
```

يحدد هذا السطر الوراثة، في هذه الحالة من `IERC20` أعلاه و `Context`، لـ OpenGSN.

&nbsp;

```solidity

    using SafeMath for uint256;

```

يربط هذا السطر مكتبة `SafeMath` بنوع `uint256`. يمكنك العثور على هذه المكتبة
[هنا](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol).

### تعريفات المتغيرات {#variable-definitions}

تحدد هذه التعريفات متغيرات حالة العقد. يتم الإعلان عن هذه المتغيرات بأنها `خاصة`، ولكن
هذا يعني فقط أن العقود الأخرى على البلوك تشين لا يمكنها قراءتها. _لا توجد
أسرار على البلوك تشين_، فالبرنامج الموجود على كل عقدة لديه حالة كل عقد
عند كل كتلة. وفقًا للعرف، تتم تسمية متغيرات الحالة `_<شيء ما>`.

المتغيران الأولان هما [تعيينات](https://www.tutorialspoint.com/solidity/solidity_mappings.htm)،
مما يعني أنهما يتصرفان تقريبًا بنفس طريقة [المصفوفات الترابطية](https://wikipedia.org/wiki/Associative_array)،
باستثناء أن المفاتيح هي قيم رقمية. يتم تخصيص التخزين فقط للإدخالات التي لها قيم مختلفة
عن القيمة الافتراضية (صفر).

```solidity
    mapping (address => uint256) private _balances;
```

التعيين الأول، `_balances`، هو العناوين وأرصدتها الخاصة بهذا الرمز. للوصول
إلى الرصيد، استخدم هذا الصيغة: `_balances[<address>]`.

&nbsp;

```solidity
    mapping (address => mapping (address => uint256)) private _allowances;
```

يخزن هذا المتغير، `_allowances`، المخصصات التي تم شرحها سابقًا. الفهرس الأول هو مالك
الرموز، والثاني هو العقد الذي لديه المخصص. للوصول إلى المبلغ الذي يمكن للعنوان A
إنفاقه من حساب العنوان B، استخدم `_allowances[B][A]`.

&nbsp;

```solidity
    uint256 private _totalSupply;
```

كما يوحي الاسم، يتتبع هذا المتغير إجمالي المعروض من الرموز.

&nbsp;

```solidity
    string private _name;
    string private _symbol;
    uint8 private _decimals;
```

تُستخدم هذه المتغيرات الثلاثة لتحسين قابلية القراءة. المتغيران الأولان واضحان، لكن `_decimals`
ليس كذلك.

من ناحية، لا تحتوي Ethereum على متغيرات ذات فاصلة عائمة أو كسرية. من ناحية أخرى،
يحب البشر القدرة على تقسيم الرموز. أحد أسباب استقرار الناس على الذهب كعملة هو أنه
كان من الصعب إجراء تغيير عندما أراد شخص ما شراء ما يعادل قيمة بطة من بقرة.

الحل هو تتبع الأعداد الصحيحة، ولكن بدلاً من الرمز الحقيقي، يتم حساب رمز كسري
يكاد يكون عديم القيمة. في حالة الإيثر، يُطلق على الرمز الكسري اسم wei، و 10^18 wei تساوي واحد
ETH. عند الكتابة، 10,000,000,000,000 wei تساوي تقريبًا سنتًا أمريكيًا أو أوروبيًا واحدًا.

تحتاج التطبيقات إلى معرفة كيفية عرض رصيد الرمز. إذا كان لدى مستخدم 3,141,000,000,000,000,000 wei، فهل هذا
3.14 ETH؟ 31.41 ETH؟ 3,141 ETH؟ في حالة الإيثر، تم تعريف 10^18 wei إلى ETH، ولكن بالنسبة
لرمزك، يمكنك تحديد قيمة مختلفة. إذا كان تقسيم الرمز غير منطقي، فيمكنك استخدام
قيمة `_decimals` صفرية. إذا كنت ترغب في استخدام نفس المعيار مثل ETH، فاستخدم القيمة **18**.

### المنشئ {#the-constructor}

```solidity
    /**
     * @dev يضبط القيم لـ {name} و {symbol}، ويبدأ {decimals} بقيمة
     * افتراضية 18.
     *
     * لتحديد قيمة مختلفة لـ {decimals}، استخدم {_setupDecimals}.
     *
     * كل هذه القيم الثلاث غير قابلة للتغيير: لا يمكن ضبطها إلا مرة واحدة أثناء
     * الإنشاء.
     */
    constructor (string memory name_, string memory symbol_) public {
        // في Solidity ≥0.7.0، `public` ضمني ويمكن حذفه.

        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
```

يتم استدعاء المنشئ عند إنشاء العقد لأول مرة. وفقًا للعرف، تتم تسمية معلمات الدالة `<شيء ما>_`.

### دوال واجهة المستخدم {#user-interface-functions}

```solidity
    /**
     * @dev تُرجع اسم الرمز.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev تُرجع رمز الرمز، وعادة ما يكون نسخة أقصر من الاسم.
     *
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev تُرجع عدد الكسور العشرية المستخدمة للحصول على تمثيله للمستخدم.
     * على سبيل المثال، إذا كانت `decimals` تساوي `2`، يجب عرض رصيد `505` من الرموز
     * للمستخدم كـ `5,05` (`505 / 10 ** 2`).
     *
     * عادة ما تختار الرموز قيمة 18، محاكاة للعلاقة بين
     * الإيثر والـ wei. هذه هي القيمة التي يستخدمها {ERC20}، ما لم يتم استدعاء {_setupDecimals}
     *.
     *
     * ملاحظة: تُستخدم هذه المعلومات لأغراض _العرض_ فقط: فهي لا تؤثر
     * بأي شكل من الأشكال على أي من حسابات العقد، بما في ذلك
     * {IERC20-balanceOf} و {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
```

تساعد هذه الدوال، `name`، و`symbol`، و`decimals`، واجهات المستخدم على معرفة عقدك حتى تتمكن من عرضه بشكل صحيح.

نوع الإرجاع هو `string memory`، مما يعني إرجاع سلسلة مخزنة في الذاكرة. يمكن تخزين المتغيرات، مثل
السلاسل، في ثلاثة مواقع:

|          | العمر الافتراضي | الوصول إلى العقد | تكلفة الغاز                                            |
| -------- | --------------- | ---------------- | ------------------------------------------------------ |
| الذاكرة  | استدعاء دالة    | قراءة/كتابة      | عشرات أو مئات (أعلى للمواقع الأعلى) |
| Calldata | استدعاء دالة    | قراءة فقط        | لا يمكن استخدامه كنوع إرجاع، فقط كنوع معلمة دالة       |
| التخزين  | حتى يتم تغييره  | قراءة/كتابة      | مرتفع (800 للقراءة، 20 ألف للكتابة) |

في هذه الحالة، `memory` هي الخيار الأفضل.

### قراءة معلومات الرمز {#read-token-information}

هذه دوال توفر معلومات حول الرمز، إما إجمالي المعروض أو رصيد
الحساب.

```solidity
    /**
     * @dev انظر {IERC20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
```

تعيد دالة `totalSupply` إجمالي المعروض من الرموز.

&nbsp;

```solidity
    /**
     * @dev انظر {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }
```

قراءة رصيد الحساب. لاحظ أنه يُسمح لأي شخص بالحصول على رصيد حساب
أي شخص آخر. لا فائدة من محاولة إخفاء هذه المعلومات، لأنها متوفرة على كل
عقدة على أي حال. _لا توجد أسرار على البلوك تشين._

### نقل الرموز {#transfer-tokens}

```solidity
    /**
     * @dev انظر {IERC20-transfer}.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `recipient` هو العنوان الصفري.
     * - يجب أن يكون لدى المتصل رصيد لا يقل عن `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
```

يتم استدعاء دالة `transfer` لنقل الرموز من حساب المرسل إلى حساب مختلف. لاحظ أنه
على الرغم من أنها تعيد قيمة منطقية، إلا أن هذه القيمة دائمًا **صحيحة**. إذا فشل النقل،
يعود العقد عن الاستدعاء.

&nbsp;

```solidity
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
```

تقوم دالة `_transfer` بالعمل الفعلي. إنها دالة خاصة لا يمكن استدعاؤها إلا من قبل
دوال العقد الأخرى. وفقًا للعرف، تتم تسمية الدوال الخاصة `_<شيء ما>`، مثل متغيرات
الحالة.

عادة في Solidity نستخدم `msg.sender` لمرسل الرسالة. ومع ذلك، فإن هذا يعطل
[OpenGSN](http://opengsn.org/). إذا أردنا السماح بالمعاملات بدون إيثر باستخدام رمزنا، فنحن
بحاجة إلى استخدام `_msgSender()`. تعيد `msg.sender` للمعاملات العادية، ولكن بالنسبة للمعاملات بدون إيثر،
تعيد الموقع الأصلي وليس العقد الذي نقل الرسالة.

### دوال المخصصات {#allowance-functions}

هذه هي الدوال التي تطبق وظيفة المخصصات: `allowance`، و`approve`، و`transferFrom`،
و`_approve`. بالإضافة إلى ذلك، يتجاوز تطبيق OpenZeppelin المعيار الأساسي ليشمل بعض الميزات التي تحسن
الأمان: `increaseAllowance`، و`decreaseAllowance`.

#### دالة المخصص {#allowance}

```solidity
    /**
     * @dev انظر {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
```

تسمح دالة `allowance` للجميع بالتحقق من أي مخصص.

#### دالة الموافقة {#approve}

```solidity
    /**
     * @dev انظر {IERC20-approve}.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `spender` هو العنوان الصفري.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
```

يتم استدعاء هذه الدالة لإنشاء مخصص. إنها مشابهة لدالة `transfer` أعلاه:

- تستدعي الدالة فقط دالة داخلية (في هذه الحالة، `_approve`) تقوم بالعمل الحقيقي.
- تعيد الدالة إما `صحيح` (إذا نجحت) أو تعود (إذا لم تنجح).

&nbsp;

```solidity
        _approve(_msgSender(), spender, amount);
        return true;
    }
```

نستخدم الدوال الداخلية لتقليل عدد الأماكن التي تحدث فيها تغييرات في الحالة. _أي_ دالة تغير
الحالة هي خطر أمني محتمل يحتاج إلى تدقيق للأمان. بهذه الطريقة لدينا فرص أقل للخطأ.

#### دالة transferFrom {#transferFrom}

هذه هي الدالة التي يستدعيها المنفق لإنفاق مخصص. يتطلب هذا عمليتين: نقل المبلغ
الذي يتم إنفاقه وتقليل المخصص بهذا المبلغ.

```solidity
    /**
     * @dev انظر {IERC20-transferFrom}.
     *
     * يصدر حدث {Approval} يشير إلى المخصص المحدث. هذا غير
     * مطلوب من قبل EIP. انظر الملاحظة في بداية {ERC20}.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `sender` و `recipient` هما العنوان الصفري.
     * - يجب أن يكون لدى `sender` رصيد لا يقل عن `amount`.
     * - يجب أن يكون لدى المتصل مخصص لرموز `sender` لا يقل عن
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual
                                                override returns (bool) {
        _transfer(sender, recipient, amount);
```

&nbsp;

يقوم استدعاء الدالة a.sub(b, "message") بشيئين. أولاً، يحسب `a-b`، وهو المخصص الجديد.
ثانيًا، يتحقق من أن هذه النتيجة ليست سلبية. إذا كانت سلبية، يعود الاستدعاء مع الرسالة المقدمة. لاحظ أنه عندما يعود الاستدعاء، يتم تجاهل أي معالجة تم إجراؤها مسبقًا أثناء هذا الاستدعاء، لذلك لا نحتاج إلى
التراجع عن `_transfer`.

```solidity
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount,
             "ERC20: transfer amount exceeds allowance"));
        return true;
    }
```

#### إضافات السلامة من OpenZeppelin {#openzeppelin-safety-additions}

من الخطورة تعيين مخصص غير صفري إلى قيمة أخرى غير صفرية،
لأنك تتحكم فقط في ترتيب معاملاتك الخاصة، وليس معاملات أي شخص آخر. تخيل أن لديك
مستخدمين، أليس التي هي ساذجة وبيل الذي هو غير أمين. تريد أليس بعض الخدمات من
بيل، والتي تعتقد أنها تكلف خمسة رموز - لذلك تمنح بيل مخصصًا بخمسة رموز.

ثم يتغير شيء ما ويرتفع سعر بيل إلى عشرة رموز. أليس، التي لا تزال تريد الخدمة،
ترسل معاملة تحدد مخصص بيل بعشرة. في اللحظة التي يرى فيها بيل هذه المعاملة الجديدة
في مجمع المعاملات، يرسل معاملة تنفق رموز أليس الخمسة ولها سعر
غاز أعلى بكثير بحيث يتم تعدينها بشكل أسرع. بهذه الطريقة يمكن لبيل أن ينفق أولاً خمسة رموز ثم،
بمجرد تعدين مخصص أليس الجديد، ينفق عشرة أخرى بسعر إجمالي قدره خمسة عشر رمزًا، أي أكثر مما
كانت أليس تنوي تفويضه. تسمى هذه التقنية
[التشغيل الأمامي](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/#front-running)

| معاملة أليس                          | نونس أليس | معاملة بيل                                       | نونس بيل | مخصص بيل | إجمالي دخل بيل من أليس |
| ------------------------------------ | --------- | ------------------------------------------------ | -------- | -------- | ---------------------- |
| approve(Bill, 5)  | 10        |                                                  |          | 5        | 0                      |
|                                      |           | transferFrom(Alice, Bill, 5)  | 10,123   | 0        | 5                      |
| approve(Bill, 10) | 11        |                                                  |          | 10       | 5                      |
|                                      |           | transferFrom(Alice, Bill, 10) | 10,124   | 0        | 15                     |

لتجنب هذه المشكلة، تسمح لك هاتان الدالتان (`increaseAllowance` و `decreaseAllowance`)
بتعديل المخصص بمقدار معين. لذا، إذا كان بيل قد أنفق بالفعل خمسة رموز، فسيتمكن فقط
من إنفاق خمسة أخرى. اعتمادًا على التوقيت، هناك طريقتان يمكن أن يعمل بهما هذا، وكلاهما
ينتهي بحصول بيل على عشرة رموز فقط:

أ:

| معاملة أليس                                   | نونس أليس | معاملة بيل                                      | نونس بيل | مخصص بيل | إجمالي دخل بيل من أليس |
| --------------------------------------------- | --------: | ----------------------------------------------- | -------: | -------: | ---------------------- |
| approve(Bill, 5)           |        10 |                                                 |          |        5 | 0                      |
|                                               |           | transferFrom(Alice, Bill, 5) |   10,123 |        0 | 5                      |
| increaseAllowance(Bill, 5) |        11 |                                                 |          |  0+5 = 5 | 5                      |
|                                               |           | transferFrom(Alice, Bill, 5) |   10,124 |        0 | 10                     |

ب:

| معاملة أليس                                   | نونس أليس | معاملة بيل                                       | نونس بيل | مخصص بيل | إجمالي دخل بيل من أليس |
| --------------------------------------------- | --------: | ------------------------------------------------ | -------: | -------: | ---------------------: |
| approve(Bill, 5)           |        10 |                                                  |          |        5 |                      0 |
| increaseAllowance(Bill, 5) |        11 |                                                  |          | 5+5 = 10 |                      0 |
|                                               |           | transferFrom(Alice, Bill, 10) |   10,124 |        0 |                     10 |

```solidity
    /**
     * @dev يزيد ذريًا المخصص الممنوح لـ `spender` من قبل المتصل.
     *
     * هذا بديل لـ {approve} يمكن استخدامه للتخفيف من
     * المشكلات الموصوفة في {IERC20-approve}.
     *
     * يصدر حدث {Approval} يشير إلى المخصص المحدث.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `spender` هو العنوان الصفري.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
```

الدالة `a.add(b)` هي إضافة آمنة. في الحالة غير المحتملة التي يكون فيها `a`+`b`>=`2^256`، لا تلتف
حول الطريقة التي تعمل بها الإضافة العادية.

```solidity

    /**
     * @dev يقلل ذريًا المخصص الممنوح لـ `spender` من قبل المتصل.
     *
     * هذا بديل لـ {approve} يمكن استخدامه للتخفيف من
     * المشكلات الموصوفة في {IERC20-approve}.
     *
     * يصدر حدث {Approval} يشير إلى المخصص المحدث.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `spender` هو العنوان الصفري.
     * - يجب أن يكون لدى `spender` مخصص للمتصل لا يقل عن
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue,
                "ERC20: decreased allowance below zero"));
        return true;
    }
```

### الدوال التي تعدل معلومات الرمز {#functions-that-modify-token-information}

هذه هي الدوال الأربع التي تقوم بالعمل الفعلي: `_transfer`، و`_mint`، و`_burn`، و`_approve`.

#### الدالة _transfer {#_transfer}

```solidity
    /**
     * @dev تنقل رموز `amount` من `sender` إلى `recipient`.
     *
     * هذه الدالة الداخلية تعادل {transfer}، ويمكن استخدامها
     * على سبيل المثال، لتنفيذ رسوم الرموز التلقائية، وآليات الشطب، إلخ.
     *
     * تصدر حدث {Transfer}.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `sender` هو العنوان الصفري.
     * - لا يمكن أن يكون `recipient` هو العنوان الصفري.
     * - يجب أن يكون لدى `sender` رصيد لا يقل عن `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
```

هذه الدالة، `_transfer`، تنقل الرموز من حساب إلى آخر. يتم استدعاؤها من قبل كل من
`transfer` (للتحويلات من حساب المرسل الخاص) و`transferFrom` (لاستخدام المخصصات
للتحويل من حساب شخص آخر).

&nbsp;

```solidity
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
```

لا أحد يمتلك فعليًا العنوان الصفري في Ethereum (أي لا أحد يعرف مفتاحًا خاصًا يتم تحويل المفتاح العام المطابق له إلى العنوان الصفري). عندما يستخدم الناس هذا العنوان، فإنه عادة ما يكون خطأ برمجيًا - لذلك
نفشل إذا تم استخدام العنوان الصفري كمرسل أو مستلم.

&nbsp;

```solidity
        _beforeTokenTransfer(sender, recipient, amount);

```

هناك طريقتان لاستخدام هذا العقد:

1. استخدمه كقالب للكود الخاص بك
2. [الوراثة منه](https://www.bitdegree.org/learn/solidity-inheritance)، وتجاوز تلك الدوال التي تحتاج إلى تعديلها فقط

الطريقة الثانية أفضل بكثير لأن كود OpenZeppelin ERC-20 قد تم تدقيقه بالفعل وتبين أنه آمن. عندما تستخدم الوراثة،
يكون من الواضح ما هي الدوال التي تعدلها، ولكي يثق الناس في عقدك، يحتاجون فقط إلى تدقيق تلك الدوال المحددة.

غالبًا ما يكون من المفيد أداء دالة في كل مرة تنتقل فيها الرموز. ومع ذلك، فإن `_transfer` هي دالة مهمة جدًا ومن
الممكن كتابتها بشكل غير آمن (انظر أدناه)، لذلك من الأفضل عدم تجاوزها. الحل هو `_beforeTokenTransfer`، وهي
[دالة ربط (hook)](https://wikipedia.org/wiki/Hooking). يمكنك تجاوز هذه الدالة، وسيتم استدعاؤها في كل عملية نقل.

&nbsp;

```solidity
        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
```

هذه هي الأسطر التي تقوم بالفعل بالنقل. لاحظ أنه لا يوجد **شيء** بينهما، وأننا نطرح
المبلغ المنقول من المرسل قبل إضافته إلى المستلم. هذا مهم لأنه إذا كان هناك
استدعاء لعقد مختلف في المنتصف، فقد يتم استخدامه لخداع هذا العقد. بهذه الطريقة يكون النقل
ذريًا، لا يمكن أن يحدث شيء في منتصفه.

&nbsp;

```solidity
        emit Transfer(sender, recipient, amount);
    }
```

أخيرًا، أصدر حدث `Transfer`. لا يمكن الوصول إلى الأحداث من قبل العقود الذكية، ولكن الكود الذي يعمل خارج البلوك تشين
يمكنه الاستماع إلى الأحداث والتفاعل معها. على سبيل المثال، يمكن للمحفظة تتبع متى يحصل المالك على المزيد من الرموز.

#### الدالتان _mint و _burn {#_mint-and-_burn}

هاتان الدالتان (`_mint` و `_burn`) تعدلان إجمالي المعروض من الرموز.
إنهما داخليتان ولا توجد دالة تستدعيهما في هذا العقد،
لذا فهما مفيدتان فقط إذا ورثت من العقد وأضفت منطقك الخاص
لتحديد الظروف التي يتم فيها سك رموز جديدة أو حرق الرموز
الحالية.

**ملاحظة:** لكل رمز ERC-20 منطقه التجاري الخاص الذي يملي إدارة الرمز.
على سبيل المثال، قد يستدعي عقد ذو معروض ثابت `_mint` فقط
في المنشئ ولا يستدعي `_burn` أبدًا. العقد الذي يبيع الرموز
سيستدعي `_mint` عند الدفع له، ومن المفترض أن يستدعي `_burn` في مرحلة ما
لتجنب التضخم الجامح.

```solidity
    /** @dev تنشئ `amount` من الرموز وتخصصها لـ `account`، مما يزيد
     * من إجمالي المعروض.
     *
     * تصدر حدث {Transfer} مع تعيين `from` إلى العنوان الصفري.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `to` هو العنوان الصفري.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");
        _beforeTokenTransfer(address(0), account, amount);
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
```

تأكد من تحديث `_totalSupply` عند تغير العدد الإجمالي للرموز.

&nbsp;

```solidity
    /**
     * @dev تدمر `amount` من الرموز من `account`، مما يقلل من
     * إجمالي المعروض.
     *
     * تصدر حدث {Transfer} مع تعيين `to` إلى العنوان الصفري.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `account` هو العنوان الصفري.
     * - يجب أن يكون لدى `account` على الأقل `amount` من الرموز.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }
```

دالة `_burn` متطابقة تقريبًا مع `_mint`، إلا أنها تعمل في الاتجاه الآخر.

#### الدالة _approve {#_approve}

هذه هي الدالة التي تحدد المخصصات بالفعل. لاحظ أنها تسمح للمالك بتحديد
مخصص أعلى من رصيد المالك الحالي. هذا مقبول لأن الرصيد يتم
التحقق منه في وقت التحويل، حيث يمكن أن يكون مختلفًا عن الرصيد عند إنشاء
المخصص.

```solidity
    /**
     * @dev تحدد `amount` كمخصص لـ `spender` على رموز `owner`.
     *
     * هذه الدالة الداخلية تعادل `approve`، ويمكن استخدامها
     * على سبيل المثال، لتعيين مخصصات تلقائية لبعض النظم الفرعية، إلخ.
     *
     * تصدر حدث {Approval}.
     *
     * المتطلبات:
     *
     * - لا يمكن أن يكون `owner` هو العنوان الصفري.
     * - لا يمكن أن يكون `spender` هو العنوان الصفري.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
```

&nbsp;

أصدر حدث `Approval`. اعتمادًا على كيفية كتابة التطبيق، يمكن إبلاغ عقد المنفق بالموافقة
إما من قبل المالك أو من قبل خادم يستمع إلى هذه الأحداث.

```solidity
        emit Approval(owner, spender, amount);
    }

```

### تعديل متغير الكسور العشرية {#modify-the-decimals-variable}

```solidity


    /**
     * @dev يضبط {decimals} على قيمة أخرى غير القيمة الافتراضية 18.
     *
     * تحذير: يجب استدعاء هذه الدالة فقط من المنشئ. معظم
     * التطبيقات التي تتفاعل مع عقود الرموز لن تتوقع
     * أن يتغير {decimals} أبدًا، وقد تعمل بشكل غير صحيح إذا حدث ذلك.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }
```

تعدل هذه الدالة متغير `_decimals` الذي يستخدم لإخبار واجهات المستخدم بكيفية تفسير المبلغ.
يجب أن تستدعيها من المنشئ. سيكون من غير الأمين استدعاؤها في أي وقت لاحق، والتطبيقات
غير مصممة للتعامل مع ذلك.

### خطافات{#hooks}

```solidity

    /**
     * @dev خطاف يتم استدعاؤه قبل أي نقل للرموز. وهذا يشمل
     * السك والحرق.
     *
     * شروط الاستدعاء:
     *
     * - عندما يكون `from` و `to` كلاهما غير صفريين، سيتم نقل `amount` من رموز `from`
     * إلى `to`.
     * - عندما يكون `from` صفرًا، سيتم سك `amount` من الرموز لـ `to`.
     * - عندما يكون `to` صفرًا، سيتم حرق `amount` من رموز `from`.
     * - لا يكون `from` و `to` كلاهما صفرًا أبدًا.
     *
     * لمعرفة المزيد عن الخطافات، انتقل إلى xref:ROOT:extending-contracts.adoc#using-hooks[استخدام الخطافات].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}
```

هذه هي دالة الخطاف التي سيتم استدعاؤها أثناء عمليات النقل. إنها فارغة هنا، ولكن إذا كنت بحاجة
إليها للقيام بشيء ما، فما عليك سوى تجاوزها.

## الخلاصة {#conclusion}

للمراجعة، إليك بعض أهم الأفكار في هذا العقد (في رأيي، من المحتمل أن يختلف رأيك):

- _There are no secrets on the blockchain_. أي معلومات يمكن لعقد ذكي الوصول إليها
  متاحة للعالم بأسره.
- يمكنك التحكم في ترتيب معاملاتك الخاصة، ولكن ليس متى تحدث معاملات الآخرين.
  هذا هو السبب في أن تغيير المخصص يمكن أن يكون خطيرًا، لأنه يتيح
  للمنفق إنفاق مجموع المخصصين.
- القيم من نوع `uint256` تلتف. بمعنى آخر، _0-1=2^256-1_. إذا لم يكن هذا هو السلوك
  المرغوب، فيجب عليك التحقق منه (أو استخدام مكتبة SafeMath التي تقوم بذلك نيابة عنك). لاحظ أن هذا تغير في
  [Solidity 0.8.0](https://docs.soliditylang.org/en/breaking/080-breaking-changes.html).
- قم بجميع تغييرات الحالة من نوع معين في مكان معين، لأن ذلك يجعل التدقيق أسهل.
  هذا هو السبب في أن لدينا، على سبيل المثال، `_approve`، الذي يتم استدعاؤه من قبل `approve`، و`transferFrom`،
  و`increaseAllowance`، و`decreaseAllowance`
- يجب أن تكون تغييرات الحالة ذرية، دون أي إجراء آخر في منتصفها (كما يمكنك أن ترى
  في `_transfer`). هذا لأنه أثناء تغيير الحالة لديك حالة غير متسقة. على سبيل المثال،
  بين وقت الخصم من رصيد المرسل ووقت الإضافة إلى رصيد
  المستلم، يوجد عدد أقل من الرموز مما ينبغي. يمكن أن يساء استخدام هذا
  إذا كانت هناك عمليات بينهما، خاصة استدعاءات لعقد مختلف.

الآن بعد أن رأيت كيف تمت كتابة عقد OpenZeppelin ERC-20، وخاصة كيف تم
جعله أكثر أمانًا، اذهب واكتب عقودك وتطبيقاتك الآمنة.

[انظر هنا لمزيد من أعمالي](https://cryptodocguy.pro/).
