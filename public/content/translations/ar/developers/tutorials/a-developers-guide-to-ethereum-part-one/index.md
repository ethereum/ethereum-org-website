---
title: مقدمة لمبرمجي Python حول Ethereum، الجزء الأول
description: مقدمة لتطوير Ethereum، وهي مفيدة بشكل خاص لمن لديهم معرفة بلغة برمجة Python
author: مارك جيرو
lang: ar
tags: [ "python", "web3.py" ]
skill: beginner
published: 2020-09-08
source: Snake charmers
sourceUrl: https://snakecharmers.ethereum.org/a-developers-guide-to-ethereum-pt-1/
---

إذن، هل سمعت عن Ethereum هذا ومستعد للمغامرة في المجهول؟ سيغطي هذا المنشور بسرعة بعض أساسيات البلوكتشين، ثم يجعلك تتفاعل مع عقدة إيثريوم تمت محاكاتها – قراءة بيانات الكتل، والتحقق من أرصدة الحسابات، وإرسال المعاملات. على طول الطريق، سنسلط الضوء على الاختلافات بين الطرق التقليدية لبناء التطبيقات وهذا النموذج اللامركزي الجديد.

## المتطلبات الأساسية (غير الإلزامية) {#soft-prerequisites}

يطمح هذا المنشور إلى أن يكون في متناول مجموعة واسعة من المبرمجين. سيتم إشراك [أدوات Python](/developers/docs/programming-languages/python/)، لكنها مجرد وسيلة للأفكار – لا توجد مشكلة إذا لم تكن مبرمج Python. لكنني سأضع بعض الافتراضات حول ما تعرفه بالفعل، حتى نتمكن من الانتقال بسرعة إلى التفاصيل الخاصة بـ Ethereum.

الافتراضات:

- يمكنك التعامل مع الوحدة الطرفية،
- لقد كتبت بضعة أسطر من نص Python البرمجي،
- أن يكون إصدار Python 3.6 أو أحدث مثبتًا على جهازك (يُنصح بشدة باستخدام [بيئة افتراضية](https://realpython.com/effective-python-environment/#virtual-environments))، و
- أنك استخدمت `pip`، وهو مثبت حزم Python.
  مرة أخرى، إذا كان أي من هذا غير صحيح، أو كنت لا تخطط لإعادة إنتاج النص البرمجي في هذه المقالة، فمن المحتمل أنه لا يزال بإمكانك المتابعة على ما يرام.

## البلوكتشين، باختصار {#blockchains-briefly}

هناك طرق عديدة لوصف Ethereum، لكن في جوهره يوجد بلوكتشين. تتكون سلاسل البلوكتشين من سلسلة من الكتل، لذا دعنا نبدأ من هناك. بأبسط العبارات، كل كتلة على بلوكتشين Ethereum هي مجرد بعض البيانات الوصفية وقائمة من المعاملات. بتنسيق JSON، يبدو الأمر كالتالي:

```json
{
   "number": 1234567,
   "hash": "0xabc123...",
   "parentHash": "0xdef456...",
   ...,
   "transactions": [...]
}
```

تحتوي كل [كتلة](/developers/docs/blocks/) على مرجع للكتلة التي سبقتها؛ `parentHash` هي ببساطة التجزئة (هاش) للكتلة السابقة.

<FeaturedText>ملاحظة: تستخدم Ethereum بانتظام <a href="https://wikipedia.org/wiki/Hash_function">دوال التجزئة (الهاش)</a> لإنتاج قيم ثابتة الحجم ("تجزئات" أو "هاشات"). تلعب التجزئات (الهاشات) دورًا مهمًا في Ethereum، ولكن يمكنك اعتبارها معرفات فريدة في الوقت الحالي.</FeaturedText>

![رسم بياني يصور البلوكتشين بما في ذلك البيانات داخل كل كتلة](./blockchain-diagram.png)

_البلوكتشين هي في الأساس قائمة مرتبطة؛ كل كتلة لديها إشارة إلى الكتلة السابقة._

هيكل البيانات هذا ليس جديدًا، ولكن القواعد (أي بروتوكولات نظير إلى نظير) التي تحكم الشبكة هي الجديدة. لا توجد سلطة مركزية؛ يجب على شبكة النظراء التعاون للحفاظ على الشبكة، والتنافس لتحديد المعاملات التي سيتم تضمينها في الكتلة التالية. لذا، عندما ترغب في إرسال بعض الأموال إلى صديق، ستحتاج إلى بث تلك المعاملة إلى الشبكة، ثم الانتظار حتى يتم تضمينها في كتلة قادمة.

الطريقة الوحيدة للتحقق من أن الأموال قد أُرسلت بالفعل من مستخدم إلى آخر في البلوكتشين هي استخدام عملة أصلية خاصة بتلك البلوكتشين (أي تم إنشاؤها وتحكمها من قبلها). في Ethereum، تسمى هذه العملة إيثر، وتحتوي بلوكتشين Ethereum على السجل الرسمي الوحيد لأرصدة الحسابات.

## نموذج جديد {#a-new-paradigm}

لقد أدى هذا المكدس التكنولوجي اللامركزي الجديد إلى ظهور أدوات جديدة للمبرمجين. توجد مثل هذه الأدوات في العديد من لغات البرمجة، لكننا سننظر من خلال عدسة Python. للتكرار: حتى لو لم تكن Python هي لغتك المفضلة، فلن يكون من الصعب عليك المتابعة.

من المرجح أن يلجأ مبرمجو Python الذين يرغبون في التفاعل مع Ethereum إلى [Web3.py](https://web3py.readthedocs.io/). Web3.py هي مكتبة تبسط إلى حد كبير طريقة اتصالك بعقدة Ethereum، ثم إرسال البيانات واستلامها منها.

<FeaturedText>ملاحظة: يتم استخدام "عقدة Ethereum" و"عميل Ethereum" بالتبادل. في كلتا الحالتين، يشير إلى البرنامج الذي يقوم بتشغيله أحد المشاركين في شبكة Ethereum. يمكن لهذا البرنامج قراءة بيانات الكتلة، وتلقي التحديثات عند إضافة كتل جديدة إلى السلسلة، وبث معاملات جديدة، والمزيد. من الناحية الفنية، العميل هو البرنامج، والعقدة هي الكمبيوتر الذي يشغل البرنامج.</FeaturedText>

يمكن تكوين [عملاء Ethereum](/developers/docs/nodes-and-clients/) ليكونوا قابلين للوصول عن طريق [IPC](https://wikipedia.org/wiki/Inter-process_communication)، أو HTTP، أو Websockets، لذلك ستحتاج Web3.py إلى محاكاة هذا التكوين. تشير Web3.py إلى خيارات الاتصال هذه باسم **الموفرين**. ستحتاج إلى اختيار أحد الموفرين الثلاثة لربط مثيل Web3.py بعقدتك.

![رسم تخطيطي يوضح كيفية استخدام web3.py لـ IPC لتوصيل تطبيقك بعقدة Ethereum](./web3py-and-nodes.png)

_قم بتكوين عقدة Ethereum وWeb3.py للتواصل عبر نفس البروتوكول، على سبيل المثال، IPC في هذا الرسم التخطيطي._

بمجرد تكوين Web3.py بشكل صحيح، يمكنك البدء في التفاعل مع البلوكتشين. إليك بعض أمثلة استخدام Web3.py كمعاينة لما هو قادم:

```python
# قراءة بيانات الكتلة:
w3.eth.get_block('latest')

# إرسال معاملة:
w3.eth.send_transaction({'from': ..., 'to': ..., 'value': ...})
```

## التثبيت {#installation}

في هذا الشرح التفصيلي، سنعمل فقط داخل مترجم Python. لن ننشئ أي أدلة أو ملفات أو فئات أو وظائف.

<FeaturedText>ملاحظة: في الأمثلة أدناه، يُقصد تشغيل الأوامر التي تبدأ بـ `$` في الوحدة الطرفية. (لا تكتب `$`، فهي تشير فقط إلى بداية السطر.)</FeaturedText>

أولًا، قم بتثبيت [IPython](https://ipython.org/) للحصول على بيئة سهلة الاستخدام للاستكشاف. يوفر IPython الإكمال التلقائي بعلامة التبويب، من بين ميزات أخرى، مما يسهل كثيرًا رؤية ما هو ممكن داخل Web3.py.

```bash
pip install ipython
```

يتم نشر Web3.py تحت اسم `web3`. قم بتثبيته على النحو التالي:

```bash
pip install web3
```

شيء آخر – سنقوم بمحاكاة البلوكتشين لاحقًا، الأمر الذي يتطلب بعض التبعيات الإضافية. يمكنك تثبيتها عبر:

```bash
pip install 'web3[tester]'
```

أنت الآن جاهز للانطلاق!

ملاحظة: تعمل حزمة `web3[tester]` حتى Python 3.10.xx

## تجهيز بيئة اختبارية {#spin-up-a-sandbox}

افتح بيئة Python جديدة عن طريق تشغيل `ipython` في الوحدة الطرفية الخاصة بك. هذا مشابه لتشغيل `python`، لكنه يأتي مع المزيد من الميزات الإضافية.

```bash
ipython
```

سيؤدي هذا إلى طباعة بعض المعلومات حول إصدارات Python وIPython التي تقوم بتشغيلها، ثم يجب أن ترى مطالبة تنتظر الإدخال:

```python
In [1]:
```

أنت الآن تنظر إلى واجهة Python التفاعلية. بشكل أساسي، إنها بيئة اختبارية للعب بها. إذا وصلت إلى هذا الحد، فقد حان الوقت لاستيراد Web3.py:

```python
In [1]: from web3 import Web3
```

## تقديم وحدة Web3 {#introducing-the-web3-module}

إلى جانب كونها بوابة إلى Ethereum، توفر وحدة [Web3](https://web3py.readthedocs.io/en/stable/overview.html#base-api) بعض الوظائف المساعدة. دعنا نستكشف بعضها.

في تطبيق Ethereum، ستحتاج عادةً إلى تحويل فئات العملات. توفر وحدة Web3 طريقتين مساعدتين لهذا الغرض فقط: [from_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.from_wei) و[to_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.to_wei).

<FeaturedText>
ملاحظة: تشتهر أجهزة الكمبيوتر بسوء تعاملها مع العمليات الحسابية العشرية. للتغلب على هذا، غالبًا ما يقوم المبرمجون بتخزين مبالغ الدولار بالسنت. على سبيل المثال، قد يتم تخزين عنصر بسعر 5.99 دولارًا في قاعدة البيانات على أنه 599.

يتم استخدام نمط مماثل عند التعامل مع المعاملات بـ<b>الإيثر</b>. ومع ذلك، بدلًا من خانتين عشريتين، يحتوي الإيثر على 18! تُسمى أصغر فئة من الإيثر <b>wei</b>، لذا هذه هي القيمة المحددة عند إرسال المعاملات.

1 إيثر = 1000000000000000000 wei

1 wei = 0.000000000000000001 إيثر

</FeaturedText>

حاول تحويل بعض القيم من وإلى wei. لاحظ أن [هناك أسماء للعديد من الفئات](https://web3py.readthedocs.io/en/stable/troubleshooting.html#how-do-i-convert-currency-denominations) بين الإيثر وwei. من أشهرها **غوي** (gwei)، حيث إنها الطريقة التي يتم بها تمثيل رسوم المعاملات غالبًا.

```python
In [2]: Web3.to_wei(1, 'ether')
Out[2]: 1000000000000000000

In [3]: Web3.from_wei(500000000, 'gwei')
Out[3]: Decimal('0.5')
```

تشمل الطرق المساعدة الأخرى في وحدة Web3 محولات تنسيق البيانات (على سبيل المثال، [`toHex`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.toHex))، ومساعدات العناوين (على سبيل المثال، [`isAddress`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.isAddress))، ودوال التجزئة (الهاش) (على سبيل المثال، [`keccak`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.keccak)). سيتم تغطية العديد من هذه في وقت لاحق في السلسلة. لعرض جميع الطرق والخصائص المتاحة، استخدم الإكمال التلقائي لـ IPython عن طريق كتابة `Web3`. والضغط على مفتاح tab مرتين بعد النقطة.

## تحدث إلى السلسلة {#talk-to-the-chain}

الطرق المساعدة رائعة، لكن دعنا ننتقل إلى البلوكتشين. الخطوة التالية هي تكوين Web3.py للتواصل مع عقدة Ethereum. لدينا هنا خيار استخدام موفري IPC أو HTTP أو Websocket.

لن نسلك هذا المسار، ولكن مثالًا لسير عمل كامل باستخدام موفر HTTP قد يبدو كالتالي:

- تنزيل عقدة Ethereum، على سبيل المثال، [Geth](https://geth.ethereum.org/).
- ابدأ تشغيل Geth في نافذة طرفية واحدة وانتظر حتى تتم مزامنة الشبكة. منفذ HTTP الافتراضي هو `8545`، لكنه قابل للتكوين.
- أخبر Web3.py بالاتصال بالعقدة عبر HTTP، على `localhost:8545`.
  `w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))`
- استخدم مثيل `w3` للتفاعل مع العقدة.

في حين أن هذه طريقة "حقيقية" واحدة للقيام بذلك، فإن عملية المزامنة تستغرق ساعات وهي غير ضرورية إذا كنت تريد فقط بيئة تطوير. تعرض Web3.py موفرًا رابعًا لهذا الغرض، وهو **EthereumTesterProvider**. يرتبط هذا الموفر التجريبي بعقدة Ethereum تمت محاكاتها مع أذونات مخففة وعملة مزيفة للعب بها.

![رسم تخطيطي يوضح EthereumTesterProvider وهو يربط تطبيق web3.py الخاص بك بعقدة Ethereum تمت محاكاتها](./ethereumtesterprovider.png)

_يتصل EthereumTesterProvider بعقدة تمت محاكاتها وهو مفيد لبيئات التطوير السريعة._

تسمى تلك العقدة التي تمت محاكاتها [eth-tester](https://github.com/ethereum/eth-tester) وقمنا بتثبيتها كجزء من أمر `pip install web3[tester]`. تكوين Web3.py لاستخدام هذا الموفر التجريبي بسيط مثل:

```python
In [4]: w3 = Web3(Web3.EthereumTesterProvider())
```

الآن أنت مستعد لتصفح السلسلة! هذا ليس تعبيرًا شائعًا. لقد اختلقته للتو. دعنا نأخذ جولة سريعة.

## الجولة السريعة {#the-quick-tour}

أولًا وقبل كل شيء، فحص سريع للتأكد من السلامة:

```python
In [5]: w3.is_connected()
Out[5]: True
```

نظرًا لأننا نستخدم الموفر التجريبي، فإن هذا ليس اختبارًا ذا قيمة كبيرة، ولكن إذا فشل، فمن المحتمل أنك كتبت شيئًا خاطئًا عند إنشاء متغير `w3`. تأكد مرة أخرى من أنك قمت بتضمين الأقواس الداخلية، أي `Web3.EthereumTesterProvider()`.

## المحطة الأولى في الجولة: [الحسابات](/developers/docs/accounts/) {#tour-stop-1-accounts}

للتسهيل، أنشأ الموفر التجريبي بعض الحسابات وقام بتحميلها مسبقًا بإيثر اختباري.

أولًا، دعنا نرى قائمة بتلك الحسابات:

```python
In [6]: w3.eth.accounts
Out[6]: ['0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
 '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
 '0x6813Eb9362372EEF6200f3b1dbC3f819671cBA69', ...]
```

إذا قمت بتشغيل هذا الأمر، يجب أن ترى قائمة من عشر سلاسل نصية تبدأ بـ `0x`. كل منها **عنوان عام** وهو، في بعض النواحي، مماثل لرقم الحساب في حساب جارٍ. ستقدم هذا العنوان لشخص يريد أن يرسل لك الإيثر.

كما ذكرنا، قام الموفر التجريبي بتحميل كل من هذه الحسابات مسبقًا ببعض الإيثر الاختباري. دعنا نكتشف المبلغ الموجود في الحساب الأول:

```python
In [7]: w3.eth.get_balance(w3.eth.accounts[0])
Out[7]: 1000000000000000000000000
```

هذا عدد كبير من الأصفار! قبل أن تذهب ضاحكًا إلى البنك المزيف، تذكر ذلك الدرس حول فئات العملات من قبل. يتم تمثيل قيم الإيثر بأصغر فئة، وهي wei. حول ذلك إلى إيثر:

```python
In [8]: w3.from_wei(1000000000000000000000000, 'ether')
Out[8]: Decimal('1000000')
```

مليون إيثر اختباري - لا يزال ليس سيئًا للغاية.

## المحطة الثانية في الجولة: بيانات الكتلة {#tour-stop-2-block-data}

دعنا نلقي نظرة خاطفة على حالة هذا البلوكتشين الذي تمت محاكاته:

```python
In [9]: w3.eth.get_block('latest')
Out[9]: AttributeDict({
   'number': 0,
   'hash': HexBytes('0x9469878...'),
   'parentHash': HexBytes('0x0000000...'),
   ...
   'transactions': []
})
```

يتم إرجاع الكثير من المعلومات حول الكتلة، ولكن هناك شيئان فقط يجب الإشارة إليهما هنا:

- رقم الكتلة هو صفر - بغض النظر عن المدة التي قمت فيها بتكوين الموفر التجريبي. على عكس شبكة Ethereum الحقيقية، التي تضيف كتلة جديدة كل 12 ثانية، ستنتظر هذه المحاكاة حتى تعطيها بعض العمل للقيام به.
- `transactions` هي قائمة فارغة، لنفس السبب: لم نفعل أي شيء بعد. هذه الكتلة الأولى هي **كتلة فارغة**، فقط لبدء السلسلة.
- لاحظ أن `parentHash` هو مجرد مجموعة من البايتات الفارغة. هذا يدل على أنها الكتلة الأولى في السلسلة، والمعروفة أيضًا باسم **الكتلة التكوينية (genesis block)**.

## المحطة الثالثة في الجولة: [المعاملات](/developers/docs/transactions/) {#tour-stop-3-transactions}

نحن عالقون في الكتلة صفر حتى تكون هناك معاملة معلقة، لذا دعنا نعطها واحدة. أرسل بعض الإيثر الاختباري من حساب إلى آخر:

```python
In [10]: tx_hash = w3.eth.send_transaction({
   'from': w3.eth.accounts[0],
   'to': w3.eth.accounts[1],
   'value': w3.to_wei(3, 'ether'),
   'gas': 21000
})
```

هذه هي النقطة التي تنتظر فيها عادةً عدة ثوانٍ حتى يتم تضمين معاملتك في كتلة جديدة. العملية الكاملة تسير على النحو التالي:

1. أرسل معاملة واحتفظ بتجزئة (هاش) المعاملة. حتى يتم إنشاء الكتلة التي تحتوي على المعاملة وبثها، تكون المعاملة "معلقة".
   `tx_hash = w3.eth.send_transaction({ … })`
2. انتظر حتى يتم تضمين المعاملة في كتلة:
   `w3.eth.wait_for_transaction_receipt(tx_hash)`
3. تابع منطق التطبيق. لعرض المعاملة الناجحة:
   `w3.eth.get_transaction(tx_hash)`

ستضيف بيئتنا التي تمت محاكاتها المعاملة في كتلة جديدة على الفور، لذا يمكننا عرض المعاملة على الفور:

```python
In [11]: w3.eth.get_transaction(tx_hash)
Out[11]: AttributeDict({
   'hash': HexBytes('0x15e9fb95dc39...'),
   'blockNumber': 1,
   'transactionIndex': 0,
   'from': '0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
   'to': '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
   'value': 3000000000000000000,
   ...
})
```

سترى بعض التفاصيل المألوفة هنا: يجب أن تتطابق حقول `from` و`to` و`value` مع مدخلات استدعاء `send_transaction` الخاص بنا. الشيء المطمئن الآخر هو أن هذه المعاملة تم تضمينها كأول معاملة (`'transactionIndex': 0`) ضمن الكتلة رقم 1.

يمكننا أيضًا التحقق بسهولة من نجاح هذه المعاملة عن طريق التحقق من أرصدة الحسابين المعنيين. يجب أن يكون قد تم نقل ثلاثة إيثر من أحدهما إلى الآخر.

```python
In [12]: w3.eth.get_balance(w3.eth.accounts[0])
Out[12]: 999996999979000000000000

In [13]: w3.eth.get_balance(w3.eth.accounts[1])
Out[13]: 1000003000000000000000000
```

الأخير يبدو جيدًا! انتقل الرصيد من 1,000,000 إلى 1,000,003 إيثر. ولكن ماذا حدث للحساب الأول؟ يبدو أنه فقد أكثر من ثلاثة إيثر بقليل. للأسف، لا شيء في الحياة مجاني، واستخدام شبكة Ethereum العامة يتطلب منك تعويض أقرانك عن دورهم الداعم. تم خصم رسوم معاملات صغيرة من الحساب الذي أرسل المعاملة - هذه الرسوم هي كمية الغاز المحترقة (21000 وحدة من الغاز لتحويل ETH) مضروبة في الرسوم الأساسية التي تختلف وفقًا لنشاط الشبكة بالإضافة إلى إكرامية تذهب إلى برنامج المدقق الذي يدرج المعاملة في كتلة.

المزيد عن [الغاز](/developers/docs/gas/#post-london)

<FeaturedText>ملاحظة: على الشبكة العامة، تكون رسوم المعاملات متغيرة بناءً على طلب الشبكة ومدى سرعة رغبتك في معالجة المعاملة. إذا كنت مهتمًا بتفصيل كيفية حساب الرسوم، فراجع منشوري السابق حول <a href="https://medium.com/ethereum-grid/ethereum-101-how-are-transactions-included-in-a-block-9ae5f491853f">كيفية تضمين المعاملات في كتلة</a>.</FeaturedText>

## والآن استرح {#and-breathe}

لقد أمضينا وقتًا طويلًا في هذا، لذا يبدو هذا مكانًا جيدًا لأخذ قسط من الراحة. تستمر المغامرة، وسنواصل الاستكشاف في الجزء الثاني من هذه السلسلة. بعض المفاهيم القادمة: الاتصال بعقدة حقيقية، والعقود الذكية، والرموز. هل لديك أسئلة للمتابعة؟ أعلمني! ستؤثر ملاحظاتك على وجهتنا التالية. نرحب بالطلبات عبر [تويتر](https://twitter.com/wolovim).
