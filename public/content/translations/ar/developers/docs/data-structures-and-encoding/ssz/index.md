---
title: "تسلسل بسيط"
description: "شرح تنسيق SSZ الخاص بـ Ethereum."
lang: ar
sidebarDepth: 2
---

**التسلسل البسيط (SSZ)** هو أسلوب التسلسل المستخدم في سلسلة المنارة. إنه يحل محل التسلسل RLP المستخدم في طبقة التنفيذ في كل مكان عبر طبقة الإجماع باستثناء بروتوكول اكتشاف الأقران. لمعرفة المزيد حول تسلسل RLP، راجع [بادئة الطول العودي (RLP)](/developers/docs/data-structures-and-encoding/rlp/). تم تصميم SSZ ليكون حتميًا وأيضًا لـ Merkleize بكفاءة. يمكن اعتبار SSZ على أنه يتكون من عنصرين: مخطط تسلسل ومخطط Merkleization المصمم للعمل بكفاءة مع بنية البيانات التسلسلية.

## كيف يعمل SSZ؟ {#how-does-ssz-work}

### تسلسل {#serialization}

SSZ عبارة عن مخطط تسلسل لا يصف نفسه بنفسه - بل يعتمد على مخطط يجب معرفته مسبقًا. الهدف من تسلسل SSZ هو تمثيل الكائنات ذات التعقيد التعسفي كسلاسل من البايتات. هذه عملية بسيطة جدًا بالنسبة لـ "الأنواع الأساسية". يتم تحويل العنصر ببساطة إلى بايتات سداسية عشرية. الأنواع الأساسية تشمل:

- أعداد صحيحة غير موقعة
- القيم المنطقية

بالنسبة للأنواع "المركبة" المعقدة، يكون التسلسل أكثر تعقيدًا لأن النوع المركب يحتوي على عناصر متعددة قد يكون لها أنواع أو أحجام مختلفة، أو كليهما. حيثما يكون لكل هذه الكائنات أطوال ثابتة (أي أن حجم العناصر سيكون ثابتًا دائمًا بغض النظر عن قيمها الفعلية)، فإن التسلسل هو ببساطة تحويل لكل عنصر في النوع المركب مرتبًا في سلاسل بايتات little-endian. تم ربط سلاسل البايتات هذه معًا. يحتوي الكائن التسلسلي على تمثيل بايتلي للعناصر ذات الطول الثابت بنفس الترتيب الذي تظهر به في الكائن غير التسلسلي.

بالنسبة للأنواع ذات الأطوال المتغيرة، يتم استبدال البيانات الفعلية بقيمة "الإزاحة" في موضع هذا العنصر في الكائن التسلسلي. يتم إضافة البيانات الفعلية إلى كومة في نهاية الكائن التسلسلي. قيمة الإزاحة هي المؤشر لبداية البيانات الفعلية في الكومة، وتعمل كمؤشر للبايتات ذات الصلة.

يوضح المثال أدناه كيفية عمل الإزاحة للحاوية التي تحتوي على عناصر ذات طول ثابت ومتغير:

```Rust

    struct Dummy {

        number1: u64,
        number2: u64,
        vector: Vec<u8>,
        number3: u64
    }

    dummy = Dummy{

        number1: 37,
        number2: 55,
        vector: vec![1,2,3,4],
        number3: 22,
    }

    serialized = ssz.serialize(dummy)

```

سيكون لـ `serialized` البنية التالية (مبطنة إلى 4 بتات فقط هنا، ومبطنة إلى 32 بتًا في الواقع، مع الحفاظ على تمثيل `int` للوضوح):

```
[37, 0, 0, 0, 55, 0, 0, 0, 16, 0, 0, 0, 22, 0, 0, 0, 1, 2, 3, 4]
------------  -----------  -----------  -----------  ----------
      |             |            |           |            |
   number1       number2    إزاحة لـ    number 3      قيمة لـ
                              vector                   vector

```

مقسمة على خطوط من أجل الوضوح:

```
[
  37, 0, 0, 0,  # ترميز little-endian لـ `number1`.
  55, 0, 0, 0,  # ترميز little-endian لـ `number2`.
  16, 0, 0, 0,  # الـ "إزاحة" التي تشير إلى مكان بدء قيمة `vector` (little-endian 16).
  22, 0, 0, 0,  # ترميز little-endian لـ `number3`.
  1, 2, 3, 4,   # القيم الفعلية في `vector`.
]
```

لا يزال هذا مجرد تبسيط - سيتم تخزين الأعداد الصحيحة والأصفار في المخططات أعلاه في الواقع كقوائم بايتلية، مثل هذا:

```
[
  10100101000000000000000000000000  # ترميز little-endian لـ `number1`
  10110111000000000000000000000000  # ترميز little-endian لـ `number2`.
  10010000000000000000000000000000  # الـ "إزاحة" التي تشير إلى مكان بدء قيمة `vector` (little-endian 16).
  10010110000000000000000000000000  # ترميز little-endian لـ `number3`.
  10000001100000101000001110000100   # القيمة الفعلية لحقل `bytes`.
]
```

وبالتالي، يتم تخزين القيم الفعلية لأنواع الطول المتغير في كومة في نهاية الكائن التسلسلي مع تخزين إزاحاتها في مواضعها الصحيحة في القائمة المرتبة من الحقول.

هناك أيضًا بعض الحالات الخاصة التي تتطلب معالجة محددة، مثل نوع `BitList` الذي يتطلب إضافة حد أقصى للطول أثناء التسلسل وإزالته أثناء إلغاء التسلسل. التفاصيل الكاملة متاحة في [مواصفات SSZ](https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md).

### إلغاء التسلسل {#deserialization}

يتطلب إلغاء تسلسل هذا الكائن <b>المخطط</b>. يعرف المخطط التخطيط الدقيق للبيانات التسلسلية بحيث يمكن إلغاء تسلسل كل عنصر محدد من كتلة من البايتات إلى بعض الكائنات ذات المعنى مع وجود العناصر بالنوع والقيمة والحجم والموضع الصحيح. إنه المخطط الذي يخبر برنامج إلغاء التسلسل ما هي القيم التي هي قيم فعلية وأيها هي إزاحات. تختفي جميع أسماء الحقول عند تسلسل الكائن، ولكن يتم إعادة إنشائها عند إلغاء التسلسل وفقًا للمخطط.

راجع [ssz.dev](https://www.ssz.dev/overview) للحصول على شرح تفاعلي حول هذا الموضوع.

## المركلة {#merkleization}

يمكن بعد ذلك تحويل هذا الكائن التسلسلي SSZ إلى Merkleized - أي تحويله إلى تمثيل شجرة Merkle لنفس البيانات. أولاً، يتم تحديد عدد الأجزاء المكونة من 32 بايت في الكائن التسلسلي. هذه هي "أوراق" الشجرة. يجب أن يكون العدد الإجمالي للأوراق قوة للرقم 2 حتى يؤدي تجميع الأوراق معًا في النهاية إلى إنتاج جذر شجرة تجزئة واحد. إذا لم يكن هذا هو الحال بشكل طبيعي، تتم إضافة أوراق إضافية تحتوي على 32 بايتًا من الأصفار. تخطيطيا:

```
        جذر شجرة الهاش
            /     \
           /       \
          /         \
         /           \
   هاش الأوراق  هاش الأوراق
     1 و 2         3 و 4
      /   \            /  \
     /     \          /    \
    /       \        /      \
 leaf1     leaf2  leaf3     leaf4
```

هناك أيضًا حالات لا تتوزع فيها أوراق الشجرة بشكل طبيعي بالتساوي بالطريقة التي حدثت في المثال أعلاه. على سبيل المثال، يمكن أن تكون الورقة 4 عبارة عن حاوية تحتوي على عناصر متعددة تتطلب إضافة "عمق" إضافي إلى شجرة Merkle، مما يؤدي إلى إنشاء شجرة غير مستوية.

بدلاً من الإشارة إلى عناصر الشجرة هذه على أنها ورقة X أو عقدة X وما إلى ذلك، يمكننا أن نعطيها مؤشرات معممة، بدءًا من الجذر = 1 والعد من اليسار إلى اليمين على طول كل مستوى. هذا هو المؤشر المعمم الذي تم شرحه أعلاه. يحتوي كل عنصر في القائمة المتسلسلة على فهرس معمَّم يساوي `2**depth + idx` حيث idx هو موضعه المفهرس بالصفر في الكائن المتسلسل، والعمق هو عدد المستويات في شجرة ميركل، والذي يمكن تحديده على أنه اللوغاريتم ذو الأساس اثنين لعدد العناصر (الأوراق).

## الفهارس المعمَّمة {#generalized-indices}

الفهرس المعمَّم هو عدد صحيح يمثل عقدة في شجرة ميركل الثنائية حيث يكون لكل عقدة فهرس معمَّم `2 ** depth + index in row`.

```
        1           --العمق = 0  2**0 + 0 = 1
    2       3       --العمق = 1  2**1 + 0 = 2, 2**1+1 = 3
  4   5   6   7     --العمق = 2  2**2 + 0 = 4, 2**2 + 1 = 5...

```

يؤدي هذا التمثيل إلى إنشاء فهرس عقدة لكل قطعة بيانات في شجرة Merkle.

## البراهين المتعددة {#multiproofs}

إن توفير قائمة المؤشرات المعممة التي تمثل عنصرًا محددًا يسمح لنا بالتحقق منه مقابل جذر شجرة التجزئة. هذا الجذر هو نسختنا المقبولة من الواقع. يمكن التحقق من أي بيانات يتم تقديمها لنا مقابل هذا الواقع عن طريق إدخالها في المكان الصحيح في شجرة ميركل (التي يتم تحديدها من خلال مؤشرها المعمم) وملاحظة أن الجذر يظل ثابتًا. توجد دوال في المواصفات [هنا](https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs) توضح كيفية حساب المجموعة الدنيا من العقد المطلوبة للتحقق من محتويات مجموعة معينة من الفهارس المعمَّمة.

على سبيل المثال، للتحقق من البيانات في الفهرس 9 في الشجرة أدناه، نحتاج إلى تجزئة البيانات في الفهارس 8، 9، 5، 3، 1.
يجب أن يساوي تجزئة (8،9) تجزئة (4)، والتي تجزئ مع 5 لإنتاج 2، والتي تجزئ مع 3 لإنتاج جذر الشجرة 1. إذا تم تقديم بيانات غير صحيحة لـ 9، فسيتغير الجذر - سنكتشف ذلك ونفشل في التحقق من الفرع.

```
* = البيانات المطلوبة لإنشاء البرهان

                    1*
          2                      3*
    4          5*          6          7
8*     9*   10    11   12    13    14    15

```

## قراءة إضافية{#further-reading}

- [ترقية إيثريوم: SSZ](https://eth2book.info/altair/part2/building_blocks/ssz)
- [ترقية إيثريوم: المركلة](https://eth2book.info/altair/part2/building_blocks/merkleization)
- [تطبيقات SSZ](https://github.com/ethereum/consensus-specs/issues/2138)
- [حاسبة SSZ](https://simpleserialize.com/)
- [SSZ.dev](https://www.ssz.dev/)
