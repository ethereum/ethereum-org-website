---
title: "మీరు కాష్ చేయగలవన్నీ"
description: "తక్కువ ధర రోల్అప్ లావాదేవీల కోసం కాషింగ్ కాంట్రాక్ట్‌ను ఎలా సృష్టించాలో మరియు ఉపయోగించాలో తెలుసుకోండి"
author: "ఓరి పోమెరాంట్జ్"
tags: [ "లేయర్ 2", "కాషింగ్", "స్టోరేజ్" ]
skill: "మధ్యస్థ"
published: 2022-09-15
lang: te
---

రోల్అప్స్ ఉపయోగిస్తున్నప్పుడు, లావాదేవీలో ఒక బైట్ ఖర్చు నిల్వ స్లాట్ ఖర్చు కంటే చాలా ఎక్కువ. అందువల్ల, వీలైనంత ఎక్కువ సమాచారాన్ని ఆన్‌చెయిన్‌లో కాష్ చేయడం అర్ధవంతంగా ఉంటుంది.

ఈ వ్యాసంలో మీరు కాషింగ్ కాంట్రాక్ట్‌ను సృష్టించడం మరియు ఉపయోగించడం ఎలాగో నేర్చుకుంటారు. దీని ద్వారా చాలాసార్లు ఉపయోగించబడే ఏవైనా పారామీటర్ విలువ కాష్ చేయబడుతుంది మరియు (మొదటిసారి తర్వాత) చాలా తక్కువ సంఖ్యలో బైట్లతో ఉపయోగం కోసం అందుబాటులో ఉంటుంది. అలాగే ఈ కాష్‌ను ఉపయోగించే ఆఫ్‌చెయిన్ కోడ్‌ను ఎలా రాయాలో కూడా నేర్చుకుంటారు.

మీరు వ్యాసాన్ని దాటవేసి, సోర్స్ కోడ్‌ను చూడాలనుకుంటే, [అది ఇక్కడ ఉంది](https://github.com/qbzzt/20220915-all-you-can-cache). డెవలప్‌మెంట్ స్టాక్ [Foundry](https://getfoundry.sh/introduction/installation/).

## మొత్తం రూపకల్పన {#overall-design}

సరళత కోసం అన్ని లావాదేవీ పారామితులు `uint256`, 32 బైట్స్ పొడవు ఉంటాయని మేము ఊహిస్తాము. మేము ఒక లావాదేవీని స్వీకరించినప్పుడు, ప్రతి పారామీటర్‌ను ఇలా పార్స్ చేస్తాము:

1. మొదటి బైట్ `0xFF` అయితే, తదుపరి 32 బైట్స్‌ను పారామీటర్ విలువగా తీసుకొని కాష్‌లో రాయండి.

2. మొదటి బైట్ `0xFE` అయితే, తదుపరి 32 బైట్స్‌ను పారామీటర్ విలువగా తీసుకోండి, కానీ దానిని కాష్‌లో రాయవద్దు.

3. ఏదైనా ఇతర విలువ కోసం, అదనపు బైట్ల సంఖ్యగా మొదటి నాలుగు బిట్‌లను, మరియు కాష్ కీ యొక్క అత్యంత ముఖ్యమైన బిట్‌లుగా చివరి నాలుగు బిట్‌లను తీసుకోండి. ఇక్కడ కొన్ని ఉదాహరణలు ఉన్నాయి:

   | కాల్‌డేటాలో బైట్స్ |  కాష్ కీ |
   | :----------------- | -------: |
   | 0x0F               |     0x0F |
   | 0x10,0x10          |     0x10 |
   | 0x12,0xAC          |   0x02AC |
   | 0x2D,0xEA, 0xD6    | 0x0DEAD6 |

## కాష్ మార్పు {#cache-manipulation}

కాష్ [`Cache.sol`](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/Cache.sol)లో అమలు చేయబడింది. దాన్ని లైన్ వారీగా చూద్దాం.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;


contract Cache {

    bytes1 public constant INTO_CACHE = 0xFF;
    bytes1 public constant DONT_CACHE = 0xFE;
```

మేము మొత్తం సమాచారాన్ని అందించిన ప్రత్యేక సందర్భాలను అర్థం చేసుకోవడానికి ఈ స్థిరాంకాలు ఉపయోగించబడతాయి మరియు దానిని కాష్‌లో వ్రాయాలనుకుంటున్నామా లేదా అనేది తెలియజేయడానికి. కాష్ లోకి రాయడానికి ఇంతకుముందు ఉపయోగించని నిల్వ స్లాట్‌లలోకి రెండు [`SSTORE`](https://www.evm.codes/#55) ఆపరేషన్లు అవసరం, ఒక్కొక్క దానికి 22100 గ్యాస్ ఖర్చు అవుతుంది, కనుక మేము దీన్ని ఐచ్ఛికం చేసాము.

```solidity

    mapping(uint => uint) public val2key;
```

విలువలు మరియు వాటి కీలకు మధ్య ఒక [మ్యాపింగ్](https://www.geeksforgeeks.org/solidity/solidity-mappings/). మీరు లావాదేవీని పంపే ముందు విలువలను ఎన్కోడ్ చేయడానికి ఈ సమాచారం అవసరం.

```solidity
    // స్థానం n కి కీ n+1 కోసం విలువ ఉంటుంది, ఎందుకంటే మనం సున్నాను
    // "కాష్‌లో లేదు" అని భద్రపరచాలి.
    uint[] public key2val;
```

కీల నుండి విలువలకు మ్యాపింగ్ కోసం మేము ఒక శ్రేణిని ఉపయోగించవచ్చు, ఎందుకంటే మేము కీలను కేటాయిస్తాము మరియు సరళత కోసం మేము దానిని వరుసగా చేస్తాము.

```solidity
    function cacheRead(uint _key) public view returns (uint) {
        require(_key <= key2val.length, "ప్రారంభించని కాష్ ఎంట్రీని చదువుతోంది");
        return key2val[_key-1];
    }  // cacheRead
```

కాష్ నుండి ఒక విలువను చదవండి.

```solidity
    // ఒక విలువ ఇప్పటికే కాష్‌లో లేకపోతే దాన్ని రాయండి
    // పరీక్ష పని చేయడానికి మాత్రమే పబ్లిక్
    function cacheWrite(uint _value) public returns (uint) {
        // విలువ ఇప్పటికే కాష్‌లో ఉంటే, ప్రస్తుత కీని తిరిగి ఇవ్వండి
        if (val2key[_value] != 0) {
            return val2key[_value];
        }
```

ఒకే విలువను కాష్‌లో ఒకటి కంటే ఎక్కువసార్లు ఉంచడంలో అర్థం లేదు. విలువ ఇప్పటికే అక్కడ ఉంటే, ఇప్పటికే ఉన్న కీని తిరిగి ఇవ్వండి.

```solidity
        // 0xFE ఒక ప్రత్యేక సందర్భం కాబట్టి, కాష్ పట్టుకోగల అతిపెద్ద కీ
        // 0x0D తర్వాత 15 0xFFలు ఉంటాయి. కాష్ పొడవు ఇప్పటికే అంత
        // పెద్దగా ఉంటే, విఫలమవుతుంది.
        //                              1 2 3 4 5 6 7 8 9 A B C D E F
        require(key2val.length+1 < 0x0DFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
            "కాష్ ఓవర్‌ఫ్లో");
```

అంత పెద్ద కాష్ మనకు ఎప్పటికీ లభిస్తుందని నేను అనుకోను (సుమారు 1.8\*10<sup>37</sup> ఎంట్రీలు, దీనికి నిల్వ చేయడానికి సుమారు 10<sup>27</sup> TB అవసరం). అయితే, ["640kB ఎల్లప్పుడూ సరిపోతుంది"](https://quoteinvestigator.com/2011/09/08/640k-enough/) అని గుర్తుంచుకోవడానికి నేను తగినంత పెద్దవాడిని. ఈ పరీక్ష చాలా చౌక.

```solidity
        // తదుపరి కీని ఉపయోగించి విలువను రాయండి
        val2key[_value] = key2val.length+1;
```

రివర్స్ లుకప్‌ను జోడించండి (విలువ నుండి కీకి).

```solidity
        key2val.push(_value);
```

ఫార్వర్డ్ లుకప్‌ను జోడించండి (కీ నుండి విలువకి). మేము విలువలను వరుసగా కేటాయిస్తాము కాబట్టి, మేము దానిని చివరి శ్రేణి విలువ తర్వాత జోడించవచ్చు.

```solidity
        return key2val.length;
    }  // cacheWrite
```

`key2val` యొక్క కొత్త పొడవును తిరిగి ఇవ్వండి, ఇది కొత్త విలువ నిల్వ చేయబడిన సెల్.

```solidity
    function _calldataVal(uint startByte, uint length)
        private pure returns (uint)
```

ఈ ఫంక్షన్ ఏకపక్ష పొడవు (32 బైట్ల వరకు, వర్డ్ సైజు) యొక్క కాల్‌డేటా నుండి ఒక విలువను చదువుతుంది.

```solidity
    {
        uint _retVal;

        require(length < 0x21,
            "_calldataVal పొడవు పరిమితి 32 బైట్లు");
        require(length + startByte <= msg.data.length,
            "_calldataVal కాల్‌డేటాసైజ్ దాటి చదవడానికి ప్రయత్నిస్తోంది");
```

ఈ ఫంక్షన్ అంతర్గతమైనది, కాబట్టి మిగిలిన కోడ్ సరిగ్గా వ్రాయబడితే ఈ పరీక్షలు అవసరం లేదు. అయితే, వాటికి ఎక్కువ ఖర్చు కాదు కాబట్టి మనం వాటిని కలిగి ఉండవచ్చు.

```solidity
        assembly {
            _retVal := calldataload(startByte)
        }
```

ఈ కోడ్ [Yul](https://docs.soliditylang.org/en/v0.8.16/yul.html) లో ఉంది. ఇది కాల్‌డేటా నుండి 32 బైట్ విలువను చదువుతుంది. EVMలో ప్రారంభించని ఖాళీ సున్నాగా పరిగణించబడుతుంది కాబట్టి, కాల్‌డేటా `startByte+32` కి ముందు ఆగిపోయినా ఇది పనిచేస్తుంది.

```solidity
        _retVal = _retVal >> (256-length*8);
```

మాకు తప్పనిసరిగా 32 బైట్ విలువ అవసరం లేదు. ఇది అదనపు బైట్లను తొలగిస్తుంది.

```solidity
        return _retVal;
    } // _calldataVal


    // _fromByte నుండి ప్రారంభించి, కాల్‌డేటా నుండి ఒకే పారామీటర్‌ను చదవండి
    function _readParam(uint _fromByte) internal
        returns (uint _nextByte, uint _parameterValue)
    {
```

కాల్‌డేటా నుండి ఒకే పారామీటర్‌ను చదవండి. గమనించండి, మనం చదివిన విలువను మాత్రమే కాకుండా, తదుపరి బైట్ యొక్క స్థానాన్ని కూడా తిరిగి ఇవ్వాలి, ఎందుకంటే పారామితులు 1 బైట్ నుండి 33 బైట్ల వరకు ఉండవచ్చు.

```solidity
        // మొదటి బైట్ మిగిలిన వాటిని ఎలా అర్థం చేసుకోవాలో చెబుతుంది
        uint8 _firstByte;

        _firstByte = uint8(_calldataVal(_fromByte, 1));
```

Solidity సంభావ్య ప్రమాదకరమైన [అంతర్లీన రకం మార్పిడులను](https://docs.soliditylang.org/en/v0.8.16/types.html#implicit-conversions) నిషేధించడం ద్వారా బగ్‌ల సంఖ్యను తగ్గించడానికి ప్రయత్నిస్తుంది. ఉదాహరణకు 256 బిట్స్ నుండి 8 బిట్స్ కి డౌన్‌గ్రేడ్ చేయడం స్పష్టంగా ఉండాలి.

```solidity

        // విలువను చదవండి, కానీ దాన్ని కాష్‌లో రాయవద్దు
        if (_firstByte == uint8(DONT_CACHE))
            return(_fromByte+33, _calldataVal(_fromByte+1, 32));

        // విలువను చదవండి, మరియు దాన్ని కాష్‌లో రాయండి
        if (_firstByte == uint8(INTO_CACHE)) {
            uint _param = _calldataVal(_fromByte+1, 32);
            cacheWrite(_param);
            return(_fromByte+33, _param);
        }

        // మనం ఇక్కడకు వచ్చామంటే మనం కాష్ నుండి చదవాలి

        // చదవడానికి అదనపు బైట్ల సంఖ్య
        uint8 _extraBytes = _firstByte / 16;
```

తక్కువ [నిబుల్](https://en.wikipedia.org/wiki/Nibble) తీసుకొని, కాష్ నుండి విలువను చదవడానికి ఇతర బైట్లతో కలపండి.

```solidity
        uint _key = (uint256(_firstByte & 0x0F) << (8*_extraBytes)) +
            _calldataVal(_fromByte+1, _extraBytes);

        return (_fromByte+_extraBytes+1, cacheRead(_key));

    }  // _readParam


    // n పారామీటర్లను చదవండి (ఫంక్షన్లు తమకు ఎన్ని పారామీటర్లు కావాలో తెలుసుకుంటాయి)
    function _readParams(uint _paramNum) internal returns (uint[] memory) {
```

మేము కాల్‌డేటా నుండే మనకు ఉన్న పారామితుల సంఖ్యను పొందవచ్చు, కానీ మాకు కాల్ చేసే ఫంక్షన్లకు వారు ఎన్ని పారామితులను ఆశిస్తున్నారో తెలుసు. వారు మాకు చెప్పనివ్వడం సులభం.

```solidity
        // మనం చదివే పారామీటర్లు
        uint[] memory params = new uint[](_paramNum);

        // పారామీటర్లు బైట్ 4 వద్ద ప్రారంభమవుతాయి, దానికి ముందు ఫంక్షన్ సిగ్నేచర్ ఉంటుంది
        uint _atByte = 4;

        for(uint i=0; i<_paramNum; i++) {
            (_atByte, params[i]) = _readParam(_atByte);
        }
```

మీకు అవసరమైన సంఖ్య వచ్చేవరకు పారామీటర్లను చదవండి. మనం కాల్‌డేటా చివరికి వెళితే, `_readParams` కాల్‌ను రద్దు చేస్తుంది.

```solidity

        return(params);
    }   // readParams

    // _readParams ను పరీక్షించడానికి, నాలుగు పారామీటర్లను చదవడం పరీక్షించండి
    function fourParam() public
        returns (uint256,uint256,uint256,uint256)
    {
        uint[] memory params;
        params = _readParams(4);
        return (params[0], params[1], params[2], params[3]);
    }    // fourParam
```

ఫౌండ్రీ యొక్క ఒక పెద్ద ప్రయోజనం ఏమిటంటే, ఇది సాలిడిటీలో పరీక్షలను వ్రాయడానికి అనుమతిస్తుంది ([క్రింద కాష్‌ని పరీక్షించడం చూడండి](#testing-the-cache)). ఇది యూనిట్ పరీక్షలను చాలా సులభం చేస్తుంది. ఇది నాలుగు పారామీటర్లను చదివి, వాటిని తిరిగి ఇచ్చే ఒక ఫంక్షన్, తద్వారా పరీక్ష వాటిని సరిగ్గా ఉన్నాయని ధృవీకరించగలదు.

```solidity
    // ఒక విలువను పొందండి, దానిని ఎన్కోడ్ చేసే బైట్లను తిరిగి ఇవ్వండి (సాధ్యమైతే కాష్ ఉపయోగించి)
    function encodeVal(uint _val) public view returns(bytes memory) {
```

`encodeVal` అనేది కాష్‌ను ఉపయోగించే కాల్‌డేటాను సృష్టించడానికి సహాయపడటానికి ఆఫ్‌చెయిన్ కోడ్ కాల్ చేసే ఒక ఫంక్షన్. ఇది ఒకే విలువను స్వీకరించి, దానిని ఎన్కోడ్ చేసే బైట్లను తిరిగి ఇస్తుంది. ఈ ఫంక్షన్ ఒక `view`, కాబట్టి దీనికి లావాదేవీ అవసరం లేదు మరియు బాహ్యంగా కాల్ చేసినప్పుడు ఏ గ్యాస్ ఖర్చు కాదు.

```solidity
        uint _key = val2key[_val];

        // విలువ ఇంకా కాష్‌లో లేదు, దాన్ని జోడించండి
        if (_key == 0)
            return bytes.concat(INTO_CACHE, bytes32(_val));
```

[EVM](/developers/docs/evm/)లో ప్రారంభించని నిల్వ అంతా సున్నాలుగా భావించబడుతుంది. కాబట్టి, అక్కడ లేని విలువ కోసం కీని చూస్తే, మనకు సున్నా వస్తుంది. ఆ సందర్భంలో, దానిని ఎన్కోడ్ చేసే బైట్లు `INTO_CACHE` (కాబట్టి అది తదుపరిసారి కాష్ చేయబడుతుంది), ఆ తర్వాత వాస్తవ విలువ ఉంటుంది.

```solidity
        // కీ <0x10 అయితే, దానిని ఒకే బైట్‌గా తిరిగి ఇవ్వండి
        if (_key < 0x10)
            return bytes.concat(bytes1(uint8(_key)));
```

ఒకే బైట్లు చాలా సులభం. మేము [`bytes.concat`](https://docs.soliditylang.org/en/v0.8.16/types.html#the-functions-bytes-concat-and-string-concat) ను `bytes<n>` రకాన్ని ఏ పొడవునైనా ఉండే బైట్ శ్రేణిగా మార్చడానికి ఉపయోగిస్తాము. పేరు ఉన్నప్పటికీ, కేవలం ఒక ఆర్గ్యుమెంట్‌తో అందించినప్పుడు ఇది బాగా పనిచేస్తుంది.

```solidity
        // రెండు బైట్ల విలువ, 0x1vvv గా ఎన్కోడ్ చేయబడింది
        if (_key < 0x1000)
            return bytes.concat(bytes2(uint16(_key) | 0x1000));
```

మనకు 16<sup>3</sup> కన్నా తక్కువ ఉన్న కీ ఉన్నప్పుడు, దానిని రెండు బైట్లలో వ్యక్తీకరించవచ్చు. మేము మొదట 256 బిట్ విలువ అయిన `_key` ను 16 బిట్ విలువకు మార్చి, మొదటి బైట్‌కు అదనపు బైట్ల సంఖ్యను జోడించడానికి లాజికల్ ఆర్ ని ఉపయోగిస్తాము. అప్పుడు మనం దానిని `bytes2` విలువలోకి మారుస్తాము, దానిని `bytes` గా మార్చవచ్చు.

```solidity
        // కింది లైన్లను లూప్‌గా చేయడానికి బహుశా ఒక తెలివైన మార్గం ఉంది,
        // కానీ ఇది ఒక వీక్షణ ఫంక్షన్ కాబట్టి నేను ప్రోగ్రామర్ సమయం మరియు
        // సరళత కోసం ఆప్టిమైజ్ చేస్తున్నాను.

        if (_key < 16*256**2)
            return bytes.concat(bytes3(uint24(_key) | (0x2 * 16 * 256**2)));
        if (_key < 16*256**3)
            return bytes.concat(bytes4(uint32(_key) | (0x3 * 16 * 256**3)));
             .
             .
             .
        if (_key < 16*256**14)
            return bytes.concat(bytes15(uint120(_key) | (0xE * 16 * 256**14)));
        if (_key < 16*256**15)
            return bytes.concat(bytes16(uint128(_key) | (0xF * 16 * 256**15)));
```

ఇతర విలువలు (3 బైట్లు, 4 బైట్లు, మొదలైనవి) వివిధ ఫీల్డ్ పరిమాణాలతో ఒకే విధంగా నిర్వహించబడతాయి.

```solidity
        // మనం ఇక్కడకు వస్తే, ఏదో తప్పు జరిగింది.
        revert("encodeValలో లోపం, జరగకూడదు");
```

మనం ఇక్కడకు వస్తే, మనకు 16\*256<sup>15</sup> కన్నా తక్కువ కాని కీ వచ్చింది అని అర్థం. కానీ `cacheWrite` కీలను పరిమితం చేస్తుంది కాబట్టి మనం 14\*256<sup>16</sup> వరకు కూడా పొందలేము (దీనికి మొదటి బైట్ 0xFE ఉంటుంది, కాబట్టి ఇది `DONT_CACHE` లాగా కనిపిస్తుంది). కానీ భవిష్యత్ ప్రోగ్రామర్ ఒక బగ్‌ను ప్రవేశపెట్టిన సందర్భంలో ఒక పరీక్షను జోడించడానికి మాకు ఎక్కువ ఖర్చు కాదు.

```solidity
    } // encodeVal

}  // Cache
```

### కాష్‌ని పరీక్షించడం {#testing-the-cache}

ఫౌండ్రీ యొక్క ప్రయోజనాలలో ఒకటి ఏమిటంటే, [ఇది సాలిడిటీలో పరీక్షలను వ్రాయడానికి మిమ్మల్ని అనుమతిస్తుంది](https://getfoundry.sh/forge/tests/overview/), ఇది యూనిట్ పరీక్షలను వ్రాయడాన్ని సులభం చేస్తుంది. `Cache` తరగతికి సంబంధించిన పరీక్షలు [ఇక్కడ](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/test/Cache.t.sol) ఉన్నాయి. పరీక్షా కోడ్ పునరావృతమవుతుంది కాబట్టి, ఈ వ్యాసం కేవలం ఆసక్తికరమైన భాగాలను మాత్రమే వివరిస్తుంది.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";


// కన్సోల్ కోసం `forge test -vv` ను అమలు చేయాలి.
import "forge-std/console.sol";
```

ఇది కేవలం పరీక్షా ప్యాకేజీని మరియు `console.log` ను ఉపయోగించడానికి అవసరమైన బాయిలర్‌ప్లేట్.

```solidity
import "src/Cache.sol";
```

మేము పరీక్షిస్తున్న కాంట్రాక్టు గురించి తెలుసుకోవాలి.

```solidity
contract CacheTest is Test {
    Cache cache;

    function setUp() public {
        cache = new Cache();
    }
```

`setUp` ఫంక్షన్ ప్రతి పరీక్షకు ముందు కాల్ చేయబడుతుంది. ఈ సందర్భంలో మేము కేవలం ఒక కొత్త కాష్‌ను సృష్టిస్తాము, తద్వారా మా పరీక్షలు ఒకదానిపై ఒకటి ప్రభావం చూపవు.

```solidity
    function testCaching() public {
```

పరీక్షలు అనేవి `test` తో మొదలయ్యే ఫంక్షన్లు. ఈ ఫంక్షన్ ప్రాథమిక కాష్ కార్యాచరణను, విలువలను వ్రాసి వాటిని మళ్ళీ చదవడాన్ని తనిఖీ చేస్తుంది.

```solidity
        for(uint i=1; i<5000; i++) {
            cache.cacheWrite(i*i);
        }

        for(uint i=1; i<5000; i++) {
            assertEq(cache.cacheRead(i), i*i);
```

[`assert...` ఫంక్షన్లను](https://getfoundry.sh/reference/forge-std/std-assertions/) ఉపయోగించి మీరు అసలు పరీక్షను ఎలా చేస్తారో ఇది చూపిస్తుంది. ఈ సందర్భంలో, మేము వ్రాసిన విలువ చదివిన విలువతో సమానంగా ఉందని తనిఖీ చేస్తాము. కాష్ కీలు సరళంగా కేటాయించబడతాయని మాకు తెలుసు కాబట్టి `cache.cacheWrite` ఫలితాన్ని మనం విస్మరించవచ్చు.

```solidity
        }
    }    // testCaching


    // ఒకే విలువను చాలాసార్లు కాష్ చేయండి, కీ అలాగే ఉండేలా చూసుకోండి
    //
    function testRepeatCaching() public {
        for(uint i=1; i<100; i++) {
            uint _key1 = cache.cacheWrite(i);
            uint _key2 = cache.cacheWrite(i);
            assertEq(_key1, _key2);
        }
```

మొదట మనం ప్రతి విలువను కాష్‌లోకి రెండుసార్లు రాసి, కీలు ఒకేలా ఉన్నాయని నిర్ధారించుకుంటాము (అంటే రెండవ రైట్ నిజంగా జరగలేదు).

```solidity
        for(uint i=1; i<100; i+=3) {
            uint _key = cache.cacheWrite(i);
            assertEq(_key, i);
        }
    }    // testRepeatCaching
```

సిద్ధాంతపరంగా, వరుసగా కాష్ రైట్‌లను ప్రభావితం చేయని బగ్ ఉండవచ్చు. కాబట్టి ఇక్కడ మనం వరుసగా లేని కొన్ని రైట్‌లను చేస్తాము మరియు విలువలు ఇప్పటికీ తిరిగి వ్రాయబడలేదని చూస్తాము.

```solidity
    // మెమరీ బఫర్ నుండి ఒక uint ను చదవండి (మనం పంపిన పారామీటర్లను తిరిగి పొందుతున్నామని నిర్ధారించుకోవడానికి
    //)
    function toUint256(bytes memory _bytes, uint256 _start) internal pure
        returns (uint256)
```

ఒక `bytes memory` బఫర్ నుండి 256 బిట్ వర్డ్‌ను చదవండి. ఈ యుటిలిటీ ఫంక్షన్ కాష్‌ను ఉపయోగించే ఫంక్షన్ కాల్‌ను రన్ చేసినప్పుడు సరైన ఫలితాలను స్వీకరిస్తున్నామని ధృవీకరించడానికి మాకు సహాయపడుతుంది.

```solidity
    {
        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
        uint256 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }
```

Yul `uint256` కు మించిన డేటా స్ట్రక్చర్లకు మద్దతు ఇవ్వదు, కాబట్టి మీరు మెమరీ బఫర్ `_bytes` వంటి మరింత అధునాతన డేటా స్ట్రక్చర్‌ను సూచించినప్పుడు, మీరు ఆ స్ట్రక్చర్ యొక్క చిరునామాను పొందుతారు. Solidity పొడవును కలిగి ఉన్న 32 బైట్ల పదం తర్వాత అసలు బైట్లుగా `bytes memory` విలువలను నిల్వ చేస్తుంది, కాబట్టి `_start` బైట్ నంబర్ పొందడానికి మనం `_bytes+32+_start` ను లెక్కించాలి.

```solidity

        return tempUint;
    }     // toUint256

    // fourParams() కోసం ఫంక్షన్ సిగ్నేచర్, సౌజన్యంతో
    // https://www.4byte.directory/signatures/?bytes4_signature=0x3edc1e6d
    bytes4 constant FOUR_PARAMS = 0x3edc1e6d;

    // మనం సరైన విలువలను తిరిగి పొందుతున్నామని చూడటానికి కేవలం కొన్ని స్థిరమైన విలువలు
    uint256 constant VAL_A = 0xDEAD60A7;
    uint256 constant VAL_B =     0xBEEF;
    uint256 constant VAL_C =     0x600D;
    uint256 constant VAL_D = 0x600D60A7;
```

పరీక్ష కోసం మాకు కొన్ని స్థిరాంకాలు అవసరం.

```solidity
    function testReadParam() public {
```

పారామీటర్లను సరిగ్గా చదవగలమని పరీక్షించడానికి `readParams` ని ఉపయోగించే `fourParams()` ఫంక్షన్‌ను కాల్ చేయండి.

```solidity
        address _cacheAddr = address(cache);
        bool _success;
        bytes memory _callInput;
        bytes memory _callOutput;
```

కాష్ ఉపయోగించి ఫంక్షన్‌ను కాల్ చేయడానికి మనం సాధారణ ABI మెకానిజంను ఉపయోగించలేము, కాబట్టి మనం తక్కువ స్థాయి [`<address>.call()`](https://docs.soliditylang.org/en/v0.8.16/types.html#members-of-addresses) మెకానిజంను ఉపయోగించాలి. ఆ మెకానిజం ఇన్‌పుట్‌గా `bytes memory` తీసుకుంటుంది, మరియు దానిని (అలాగే ఒక బూలియన్ విలువను) అవుట్‌పుట్‌గా తిరిగి ఇస్తుంది.

```solidity
        // మొదటి కాల్, కాష్ ఖాళీగా ఉంది
        _callInput = bytes.concat(
            FOUR_PARAMS,
```

ఒకే కాంట్రాక్ట్ కాష్ చేసిన ఫంక్షన్‌లకు (లావాదేవీల నుండి నేరుగా కాల్‌ల కోసం) మరియు నాన్-కాష్ చేసిన ఫంక్షన్‌లకు (ఇతర స్మార్ట్ కాంట్రాక్ట్‌ల నుండి కాల్‌ల కోసం) మద్దతు ఇవ్వడం ఉపయోగకరం. అది చేయడానికి మనం ప్రతిదీ [ఒక `fallback` ఫంక్షన్‌లో](https://docs.soliditylang.org/en/v0.8.16/contracts.html#fallback-function) ఉంచడానికి బదులుగా, సరైన ఫంక్షన్‌ను కాల్ చేయడానికి సాలిడిటీ మెకానిజంపై ఆధారపడాలి. దీన్ని చేయడం వల్ల కంపోజబిలిటీ చాలా సులభం అవుతుంది. చాలా సందర్భాలలో ఫంక్షన్‌ను గుర్తించడానికి ఒకే బైట్ సరిపోతుంది, కాబట్టి మనం మూడు బైట్లను వృధా చేస్తున్నాము (16\*3=48 గ్యాస్). అయితే, నేను ఇది రాస్తున్నప్పుడు ఆ 48 గ్యాస్ 0.07 సెంట్లు ఖర్చవుతుంది, ఇది సరళమైన, తక్కువ బగ్ ప్రూన్ కోడ్ యొక్క సరైన ఖర్చు.

```solidity
            // మొదటి విలువ, దాన్ని కాష్‌లోకి జోడించండి
            cache.INTO_CACHE(),
            bytes32(VAL_A),
```

మొదటి విలువ: ఇది కాష్‌లోకి వ్రాయవలసిన పూర్తి విలువ అని చెప్పే ఒక ఫ్లాగ్, ఆ తర్వాత విలువ యొక్క 32 బైట్లు. ఇతర మూడు విలువలు కూడా ఇలాంటివే, అయితే `VAL_B` కాష్‌లోకి వ్రాయబడదు మరియు `VAL_C` మూడవ మరియు నాల్గవ పారామీటర్ రెండూ.

```solidity
             .
             .
             .
        );
        (_success, _callOutput) = _cacheAddr.call(_callInput);
```

ఇక్కడే మనం అసలు `Cache` కాంట్రాక్ట్‌ను కాల్ చేస్తాము.

```solidity
        assertEq(_success, true);
```

కాల్ విజయవంతం అవుతుందని మేము ఆశిస్తున్నాము.

```solidity
        assertEq(cache.cacheRead(1), VAL_A);
        assertEq(cache.cacheRead(2), VAL_C);
```

మనం ఖాళీ కాష్‌తో ప్రారంభించి, ఆ తర్వాత `VAL_A` తర్వాత `VAL_C` ని జోడిస్తాము. మొదటిదానికి కీ 1, మరియు రెండవదానికి 2 ఉంటుందని మేము ఆశిస్తాము.

```
        assertEq(toUint256(_callOutput,0), VAL_A);
        assertEq(toUint256(_callOutput,32), VAL_B);
        assertEq(toUint256(_callOutput,64), VAL_C);
        assertEq(toUint256(_callOutput,96), VAL_C);
```

అవుట్‌పుట్ నాలుగు పారామీటర్లు. ఇక్కడ అది సరైనదని మేము ధృవీకరిస్తాము.

```solidity
        // రెండవ కాల్, మనం కాష్‌ను ఉపయోగించవచ్చు
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // కాష్‌లో మొదటి విలువ
            bytes1(0x01),
```

16 కంటే తక్కువ ఉన్న కాష్ కీలు కేవలం ఒక బైట్.

```solidity
            // రెండవ విలువ, దాన్ని కాష్‌లోకి జోడించవద్దు
            cache.DONT_CACHE(),
            bytes32(VAL_B),

            // మూడవ మరియు నాల్గవ విలువలు, ఒకే విలువ
            bytes1(0x02),
            bytes1(0x02)
        );
        .
        .
        .
    }   // testReadParam
```

కాల్ తర్వాత పరీక్షలు మొదటి కాల్ తర్వాత పరీక్షలతో సమానంగా ఉంటాయి.

```solidity
    function testEncodeVal() public {
```

ఈ ఫంక్షన్ `testReadParam` కు సమానమైనది, అయితే పారామీటర్లను స్పష్టంగా వ్రాయడానికి బదులుగా మనం `encodeVal()` ని ఉపయోగిస్తాము.

```solidity
        .
        .
        .
        _callInput = bytes.concat(
            FOUR_PARAMS,
            cache.encodeVal(VAL_A),
            cache.encodeVal(VAL_B),
            cache.encodeVal(VAL_C),
            cache.encodeVal(VAL_D)
        );
        .
        .
        .
        assertEq(_callInput.length, 4+1*4);
    }   // testEncodeVal
```

`testEncodeVal()` లో ఏకైక అదనపు పరీక్ష `_callInput` పొడవు సరైనదని ధృవీకరించడం. మొదటి కాల్ కోసం ఇది 4+33_4. రెండవది, ప్రతి విలువ ఇప్పటికే కాష్‌లో ఉంది, ఇది 4+1_4.

```solidity
    // కీ ఒకటి కంటే ఎక్కువ బైట్లు ఉన్నప్పుడు encodeVal ను పరీక్షించండి
    // గరిష్టంగా మూడు బైట్లు ఎందుకంటే కాష్‌ను నాలుగు బైట్లకు నింపడానికి
    // చాలా సమయం పడుతుంది.
    function testEncodeValBig() public {
        // కాష్‌లో కొన్ని విలువలను ఉంచండి.
        // విషయాలను సరళంగా ఉంచడానికి, n విలువ కోసం కీ n ను ఉపయోగించండి.
        for(uint i=1; i<0x1FFF; i++) {
            cache.cacheWrite(i);
        }
```

పై `testEncodeVal` ఫంక్షన్ కాష్‌లోకి నాలుగు విలువలను మాత్రమే రాస్తుంది, కాబట్టి [మల్టీ-బైట్ విలువలతో వ్యవహరించే ఫంక్షన్ భాగం](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/Cache.sol#L144-L171) తనిఖీ చేయబడదు. కానీ ఆ కోడ్ సంక్లిష్టంగా మరియు లోపాలతో కూడుకున్నది.

ఈ ఫంక్షన్ యొక్క మొదటి భాగం 1 నుండి 0x1FFF వరకు ఉన్న అన్ని విలువలను వరుసగా కాష్‌లోకి రాసే లూప్, కాబట్టి మనం ఆ విలువలను ఎన్కోడ్ చేయగలము మరియు అవి ఎక్కడికి వెళ్తున్నాయో తెలుసుకోగలము.

```solidity
        .
        .
        .

        _callInput = bytes.concat(
            FOUR_PARAMS,
            cache.encodeVal(0x000F),   // ఒక బైట్        0x0F
            cache.encodeVal(0x0010),   // రెండు బైట్లు     0x1010
            cache.encodeVal(0x0100),   // రెండు బైట్లు     0x1100
            cache.encodeVal(0x1000)    // మూడు బైట్లు 0x201000
        );
```

ఒక బైట్, రెండు బైట్, మరియు మూడు బైట్ విలువలను పరీక్షించండి. దానికంటే మించి మనం పరీక్షించము ఎందుకంటే తగినంత స్టాక్ ఎంట్రీలు (కనీసం 0x10000000, సుమారు పావు బిలియన్) రాయడానికి చాలా సమయం పడుతుంది.

```solidity
        .
        .
        .
        .
    }    // testEncodeValBig


    // చాలా చిన్న బఫర్‌తో మనం ఒక తిరస్కరణ పొందుతామని పరీక్షించండి
    function testShortCalldata() public {
```

తగినన్ని పారామీటర్లు లేని అసాధారణ సందర్భంలో ఏమి జరుగుతుందో పరీక్షించండి.

```solidity
        .
        .
        .
        (_success, _callOutput) = _cacheAddr.call(_callInput);
        assertEq(_success, false);
    }   // testShortCalldata
```

ఇది తిరస్కరిస్తుంది కాబట్టి, మనం పొందవలసిన ఫలితం `false`.

```
    // అక్కడ లేని కాష్ కీలతో కాల్ చేయండి
    function testNoCacheKey() public {
        .
        .
        .
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // మొదటి విలువ, దాన్ని కాష్‌లోకి జోడించండి
            cache.INTO_CACHE(),
            bytes32(VAL_A),

            // రెండవ విలువ
            bytes1(0x0F),
            bytes2(0x1234),
            bytes11(0xA10102030405060708090A)
        );
```

ఈ ఫంక్షన్ నాలుగు పూర్తిగా సరైన పారామీటర్లను పొందుతుంది, అయితే కాష్ ఖాళీగా ఉంది కాబట్టి అక్కడ చదవడానికి విలువలు లేవు.

```solidity
        .
        .
        .
    // చాలా పొడవైన బఫర్‌తో ప్రతిదీ ఫైల్ పనిచేస్తుందని పరీక్షించండి
    function testLongCalldata() public {
        address _cacheAddr = address(cache);
        bool _success;
        bytes memory _callInput;
        bytes memory _callOutput;

        // మొదటి కాల్, కాష్ ఖాళీగా ఉంది
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // మొదటి విలువ, దాన్ని కాష్‌లోకి జోడించండి
            cache.INTO_CACHE(), bytes32(VAL_A),

            // రెండవ విలువ, దాన్ని కాష్‌లోకి జోడించండి
            cache.INTO_CACHE(), bytes32(VAL_B),

            // మూడవ విలువ, దాన్ని కాష్‌లోకి జోడించండి
            cache.INTO_CACHE(), bytes32(VAL_C),

            // నాల్గవ విలువ, దాన్ని కాష్‌లోకి జోడించండి
            cache.INTO_CACHE(), bytes32(VAL_D),

            // మరియు "మంచి అదృష్టం" కోసం మరొక విలువ
            bytes4(0x31112233)
        );
```

ఈ ఫంక్షన్ ఐదు విలువలను పంపుతుంది. ఐదవ విలువ విస్మరించబడుతుందని మాకు తెలుసు ఎందుకంటే ఇది చెల్లుబాటు అయ్యే కాష్ ఎంట్రీ కాదు, ఇది చేర్చబడకపోతే ఒక తిరస్కరణకు కారణమయ్యేది.

```solidity
        (_success, _callOutput) = _cacheAddr.call(_callInput);
        assertEq(_success, true);
        .
        .
        .
    }   // testLongCalldata

}        // CacheTest

```

## ఒక నమూనా యాప్ {#a-sample-app}

సాలిడిటీలో పరీక్షలు రాయడం చాలా మంచిది, కానీ చివరికి ఒక డాప్ ఉపయోగకరంగా ఉండటానికి చైన్ వెలుపల నుండి అభ్యర్థనలను ప్రాసెస్ చేయగలగాలి. ఈ వ్యాసం `WORM` తో ఒక డాప్‌లో కాషింగ్ ఎలా ఉపయోగించాలో ప్రదర్శిస్తుంది, ఇది "ఒకసారి రాయండి, చాలాసార్లు చదవండి" అని సూచిస్తుంది. ఒక కీ ఇంకా వ్రాయబడకపోతే, మీరు దానికి ఒక విలువను వ్రాయవచ్చు. కీ ఇప్పటికే వ్రాయబడితే, మీకు ఒక తిరస్కరణ లభిస్తుంది.

### ఒప్పందం {#the-contract}

[ఇది కాంట్రాక్ట్](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/WORM.sol). ఇది ఎక్కువగా `Cache` మరియు `CacheTest` తో మనం ఇప్పటికే చేసిన దానిని పునరావృతం చేస్తుంది, కాబట్టి మేము ఆసక్తికరమైన భాగాలను మాత్రమే కవర్ చేస్తాము.

```solidity
import "./Cache.sol";

contract WORM is Cache {
```

`Cache` ను ఉపయోగించడానికి సులభమైన మార్గం దానిని మన స్వంత కాంట్రాక్ట్‌లో వారసత్వంగా పొందడం.

```solidity
    function writeEntryCached() external {
        uint[] memory params = _readParams(2);
        writeEntry(params[0], params[1]);
    }    // writeEntryCached
```

ఈ ఫంక్షన్ పై `CacheTest` లోని `fourParam` కు సమానమైనది. మేము ABI స్పెసిఫికేషన్లను అనుసరించడం లేదు కాబట్టి, ఫంక్షన్‌లో ఏ పారామీటర్లను ప్రకటించకపోవడం ఉత్తమం.

```solidity
    // మమ్మల్ని కాల్ చేయడం సులభం చేయండి
    // writeEntryCached() కోసం ఫంక్షన్ సిగ్నేచర్, సౌజన్యంతో
    // https://www.4byte.directory/signatures/?bytes4_signature=0xe4e4f2d3
    bytes4 constant public WRITE_ENTRY_CACHED = 0xe4e4f2d3;
```

`writeEntryCached` ని కాల్ చేసే బాహ్య కోడ్ మాన్యువల్‌గా కాల్‌డేటాను నిర్మించవలసి ఉంటుంది, `worm.writeEntryCached` ని ఉపయోగించడానికి బదులుగా, ఎందుకంటే మేము ABI స్పెసిఫికేషన్లను అనుసరించడం లేదు. ఈ స్థిరమైన విలువను కలిగి ఉండటం దానిని వ్రాయడాన్ని సులభం చేస్తుంది.

మనం `WRITE_ENTRY_CACHED` ను స్టేట్ వేరియబుల్‌గా నిర్వచించినప్పటికీ, దానిని బాహ్యంగా చదవడానికి దాని గెట్టర్ ఫంక్షన్, `worm.WRITE_ENTRY_CACHED()` ను ఉపయోగించడం అవసరం.

```solidity
    function readEntry(uint key) public view
        returns (uint _value, address _writtenBy, uint _writtenAtBlock)
```

రీడ్ ఫంక్షన్ ఒక `view`, కాబట్టి దీనికి లావాదేవీ అవసరం లేదు మరియు గ్యాస్ ఖర్చు కాదు. ఫలితంగా, పారామీటర్ కోసం కాష్‌ను ఉపయోగించడం వల్ల ఎటువంటి ప్రయోజనం లేదు. వీక్షణ ఫంక్షన్లతో సరళమైన ప్రామాణిక మెకానిజంను ఉపయోగించడం ఉత్తమం.

### పరీక్షా కోడ్ {#the-testing-code}

[ఇది కాంట్రాక్ట్ కోసం పరీక్షా కోడ్](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/test/WORM.t.sol). మళ్ళీ, ఆసక్తికరంగా ఉన్నదాన్ని మాత్రమే చూద్దాం.

```solidity
    function testWReadWrite() public {
        worm.writeEntry(0xDEAD, 0x60A7);

        vm.expectRevert(bytes("entry already written"));
        worm.writeEntry(0xDEAD, 0xBEEF);
```

[ఇది (`vm.expectRevert`)](https://book.getfoundry.sh/cheatcodes/expect-revert#expectrevert) మనం ఒక ఫౌండ్రీ పరీక్షలో తదుపరి కాల్ విఫలం కావాలని, మరియు విఫలం కావడానికి నివేదించబడిన కారణాన్ని ఎలా పేర్కొంటామో చూపిస్తుంది. ఇది మనం సింటాక్స్ `<contract>.<function name>` ను ఉపయోగించినప్పుడు వర్తిస్తుంది.()` కాల్‌డేటాను నిర్మించి, తక్కువ స్థాయి ఇంటర్‌ఫేస్ (`<contract>.call()`, మొదలైనవి) ఉపయోగించి కాంట్రాక్ట్‌ను కాల్ చేయడానికి బదులుగా.

```solidity
    function testReadWriteCached() public {
        uint cacheGoat = worm.cacheWrite(0x60A7);
```

ఇక్కడ మనం `cacheWrite` కాష్ కీని తిరిగి ఇస్తుందనే వాస్తవాన్ని ఉపయోగిస్తాము. ఇది మనం ఉత్పత్తిలో ఉపయోగించాలని ఆశించే విషయం కాదు, ఎందుకంటే `cacheWrite` స్థితిని మారుస్తుంది, మరియు అందువల్ల కేవలం ఒక లావాదేవీ సమయంలో మాత్రమే కాల్ చేయబడుతుంది. లావాదేవీలకు రిటర్న్ విలువలు ఉండవు, వాటికి ఫలితాలు ఉంటే ఆ ఫలితాలు ఈవెంట్‌లుగా విడుదల చేయబడతాయి. కాబట్టి `cacheWrite` రిటర్న్ విలువ కేవలం ఆన్‌చెయిన్ కోడ్ నుండి మాత్రమే అందుబాటులో ఉంటుంది, మరియు ఆన్‌చెయిన్ కోడ్‌కు పారామీటర్ కాషింగ్ అవసరం లేదు.

```solidity
        (_success,) = address(worm).call(_callInput);
```

ఇది `<contract address>.call()` కు రెండు రిటర్న్ విలువలు ఉన్నప్పటికీ, మనం కేవలం మొదటిదానిపై మాత్రమే శ్రద్ధ వహిస్తున్నామని Solidity కి ఎలా చెబుతామో చూపిస్తుంది.

```solidity
        (_success,) = address(worm).call(_callInput);
        assertEq(_success, false);
```

మనం తక్కువ స్థాయి `<address>.call()` ఫంక్షన్‌ను ఉపయోగిస్తున్నాము కాబట్టి, మనం `vm.expectRevert()` ను ఉపయోగించలేము మరియు కాల్ నుండి మనం పొందే బూలియన్ సక్సెస్ విలువను చూడాలి.

```solidity
    event EntryWritten(uint indexed key, uint indexed value);

        .
        .
        .

        _callInput = bytes.concat(
            worm.WRITE_ENTRY_CACHED(), worm.encodeVal(a), worm.encodeVal(b));
        vm.expectEmit(true, true, false, false);
        emit EntryWritten(a, b);
        (_success,) = address(worm).call(_callInput);
```

ఫౌండ్రీలో కోడ్ [ఒక ఈవెంట్‌ను సరిగ్గా విడుదల చేస్తుందని](https://getfoundry.sh/reference/cheatcodes/expect-emit/) మనం ధృవీకరించే మార్గం ఇది.

### క్లయింట్ {#the-client}

Solidity పరీక్షలతో మీరు పొందలేని ఒక విషయం ఏమిటంటే, మీరు మీ స్వంత అప్లికేషన్‌లో కట్ చేసి పేస్ట్ చేయగల జావాస్క్రిప్ట్ కోడ్. ఆ కోడ్ వ్రాయడానికి నేను WORM ను [Optimism Goerli](https://community.optimism.io/docs/useful-tools/networks/#optimism-goerli), [Optimism's](https://www.optimism.io/) కొత్త టెస్టునెట్‌కు triển khai చేసాను. ఇది చిరునామా [`0xd34335b1d818cee54e3323d3246bd31d94e6a78a`](https://goerli-optimism.etherscan.io/address/0xd34335b1d818cee54e3323d3246bd31d94e6a78a) వద్ద ఉంది.

[మీరు ఇక్కడ ఖాతాదారుల కోసం జావాస్క్రిప్ట్ కోడ్ చూడవచ్చు](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/javascript/index.js). దీన్ని ఉపయోగించడానికి:

1. git రిపోజిటరీని క్లోన్ చేయండి:

   ```sh
   git clone https://github.com/qbzzt/20220915-all-you-can-cache.git
   ```

2. అవసరమైన ప్యాకేజీలను ఇన్‌స్టాల్ చేయండి:

   ```sh
   cd javascript
   yarn
   ```

3. కాన్ఫిగరేషన్ ఫైల్‌ను కాపీ చేయండి:

   ```sh
   cp .env.example .env
   ```

4. మీ కాన్ఫిగరేషన్ కోసం `.env` ని సవరించండి:

   | పరామితి                                                       | విలువ                                                                                                                                                                                               |
   | ------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | MNEMONIC                                                      | లావాదేవీ కోసం చెల్లించడానికి తగినంత ETH ఉన్న ఖాతా కోసం మ్నెమోనిక్. [మీరు Optimism Goerli నెట్‌వర్క్ కోసం ఉచిత ETH ను ఇక్కడ పొందవచ్చు](https://optimismfaucet.xyz/). |
   | OPTIMISM_GOERLI_URL | Optimism Goerli కు URL. పబ్లిక్ ఎండ్‌పాయింట్, `https://goerli.optimism.io`, రేట్ లిమిటెడ్ కానీ ఇక్కడ మనకు అవసరమైన దానికి సరిపోతుంది                                                 |

5. `index.js` ను అమలు చేయండి.

   ```sh
   node index.js
   ```

   ఈ నమూనా అప్లికేషన్ మొదట WORM కి ఒక ఎంట్రీని వ్రాస్తుంది, కాల్‌డేటా మరియు Etherscan పై లావాదేవీకి ఒక లింక్‌ను ప్రదర్శిస్తుంది. అప్పుడు అది ఆ ఎంట్రీని తిరిగి చదువుతుంది, మరియు అది ఉపయోగించే కీ మరియు ఎంట్రీలోని విలువలను (విలువ, బ్లాక్ నంబర్, మరియు రచయిత) ప్రదర్శిస్తుంది.

ఖాతాదారుల చాలా వరకు సాధారణ డాప్ జావాస్క్రిప్ట్. కాబట్టి మళ్ళీ మనం కేవలం ఆసక్తికరమైన భాగాలను మాత్రమే చూస్తాము.

```javascript
.
.
.
const main = async () => {
    const func = await worm.WRITE_ENTRY_CACHED()

    // ప్రతిసారీ కొత్త కీ అవసరం
    const key = await worm.encodeVal(Number(new Date()))
```

ఒక ఇచ్చిన స్లాట్‌లో ఒకసారి మాత్రమే వ్రాయవచ్చు, కాబట్టి మనం స్లాట్‌లను పునఃఉపయోగించకుండా చూసుకోవడానికి టైమ్‌స్టాంప్‌ను ఉపయోగిస్తాము.

```javascript
const val = await worm.encodeVal("0x600D")

// ఒక ఎంట్రీని వ్రాయండి
const calldata = func + key.slice(2) + val.slice(2)
```

Ethers కాల్ డేటా ఒక హెక్స్ స్ట్రింగ్, `0x` తర్వాత ఒక సరి సంఖ్యలో హెక్సాడెసిమల్ అంకెలు ఉండాలని ఆశిస్తుంది. `key` మరియు `val` రెండూ `0x` తో మొదలవుతాయి కాబట్టి, మనం ఆ హెడర్‌లను తొలగించాలి.

```javascript
const tx = await worm.populateTransaction.writeEntryCached()
tx.data = calldata

sentTx = await wallet.sendTransaction(tx)
```

Solidity పరీక్షా కోడ్‌తో లాగే, మనం ఒక కాష్ చేసిన ఫంక్షన్‌ను సాధారణంగా కాల్ చేయలేము. బదులుగా, మనం తక్కువ స్థాయి మెకానిజంను ఉపయోగించాలి.

```javascript
    .
    .
    .
    // ఇప్పుడే వ్రాసిన ఎంట్రీని చదవండి
    const realKey = '0x' + key.slice(4)  // FF ఫ్లాగ్‌ను తొలగించండి
    const entryRead = await worm.readEntry(realKey)
    .
    .
    .
```

ఎంట్రీలను చదవడానికి మనం సాధారణ మెకానిజంను ఉపయోగించవచ్చు. `view` ఫంక్షన్లతో పారామీటర్ కాషింగ్ ఉపయోగించాల్సిన అవసరం లేదు.

## ముగింపు {#conclusion}

ఈ వ్యాసంలోని కోడ్ ఒక భావన యొక్క రుజువు, ఉద్దేశ్యం ఆలోచనను సులభంగా అర్థం చేసుకోవడం. ఉత్పత్తికి సిద్ధంగా ఉన్న సిస్టమ్ కోసం మీరు కొన్ని అదనపు కార్యాచరణలను అమలు చేయాలనుకోవచ్చు:

- `uint256` కాని విలువలను నిర్వహించండి. ఉదాహరణకు, స్ట్రింగ్‌లు.
- గ్లోబల్ కాష్‌కు బదులుగా, బహుశా వినియోగదారులు మరియు కాష్‌ల మధ్య ఒక మ్యాపింగ్ ఉండవచ్చు. వివిధ వినియోగదారులు వివిధ విలువలను ఉపయోగిస్తారు.
- చిరునామాల కోసం ఉపయోగించే విలువలు ఇతర ప్రయోజనాల కోసం ఉపయోగించే వాటి నుండి విభిన్నంగా ఉంటాయి. కేవలం చిరునామాల కోసం ప్రత్యేక కాష్ కలిగి ఉండటం అర్ధవంతంగా ఉండవచ్చు.
- ప్రస్తుతం, కాష్ కీలు "మొదట వచ్చిన వారికి, చిన్న కీ" అల్గారిథమ్‌పై ఉన్నాయి. మొదటి పదహారు విలువలను ఒకే బైట్‌గా పంపవచ్చు. తదుపరి 4080 విలువలను రెండు బైట్లుగా పంపవచ్చు. తదుపరి సుమారు మిలియన్ విలువలు మూడు బైట్లు, మొదలైనవి. ఒక ప్రొడక్షన్ సిస్టమ్ కాష్ ఎంట్రీలపై వినియోగ కౌంటర్లను ఉంచుకోవాలి మరియు వాటిని పునర్వ్యవస్థీకరించాలి, తద్వారా పదహారు అత్యంత సాధారణ విలువలు ఒక బైట్, తదుపరి 4080 అత్యంత సాధారణ విలువలు రెండు బైట్లు, మొదలైనవి ఉంటాయి.

  అయితే, అది సంభావ్యంగా ప్రమాదకరమైన ఆపరేషన్. కింది సంఘటనల క్రమాన్ని ఊహించండి:

  1. నోమ్ అమాయకుడు తన టోకెన్లను పంపాలనుకుంటున్న చిరునామాను ఎన్కోడ్ చేయడానికి `encodeVal` ను కాల్ చేస్తాడు. ఆ చిరునామా అప్లికేషన్‌లో మొదట ఉపయోగించిన వాటిలో ఒకటి, కాబట్టి ఎన్కోడ్ చేయబడిన విలువ 0x06. ఇది ఒక లావాదేవీ కాదు, ఒక `view` ఫంక్షన్, కాబట్టి ఇది నోమ్ మరియు అతను ఉపయోగించే నోడ్ మధ్య ఉంటుంది, మరియు దాని గురించి ఎవరికీ తెలియదు

  2. ఓవెన్ ఓనర్ కాష్ రీఆర్డరింగ్ ఆపరేషన్‌ను రన్ చేస్తాడు. చాలా తక్కువ మంది ప్రజలు ఆ చిరునామాను ఉపయోగిస్తారు, కాబట్టి ఇది ఇప్పుడు 0x201122 గా ఎన్కోడ్ చేయబడింది. ఒక విభిన్న విలువ, 10<sup>18</sup>, కు 0x06 కేటాయించబడింది.

  3. నోమ్ అమాయకుడు తన టోకెన్లను 0x06 కు పంపుతాడు. అవి చిరునామా `0x0000000000000000000000000de0b6b3a7640000` కు వెళ్తాయి, మరియు ఆ చిరునామా కోసం ప్రైవేట్ కీ ఎవరికీ తెలియదు కాబట్టి, అవి అక్కడే చిక్కుకుపోతాయి. నోమ్ సంతోషంగా లేడు.

  ఈ సమస్యను పరిష్కరించడానికి మార్గాలు ఉన్నాయి, మరియు కాష్ రీఆర్డర్ సమయంలో మెమ్‌పూల్‌లో ఉన్న లావాదేవీల సంబంధిత సమస్య, కానీ మీరు దాని గురించి తెలుసుకోవాలి.

నేను ఇక్కడ ఆప్టిమిజంతో కాషింగ్‌ను ప్రదర్శించాను, ఎందుకంటే నేను ఆప్టిమిజం ఉద్యోగిని మరియు ఇది నాకు బాగా తెలిసిన రోల్అప్. కానీ ఇది అంతర్గత ప్రాసెసింగ్ కోసం కనీస ఖర్చును వసూలు చేసే ఏ రోల్అప్‌తోనైనా పని చేయాలి, తద్వారా పోల్చి చూస్తే లావాదేవీ డేటాను L1 కి వ్రాయడం ప్రధాన ఖర్చు.

[నా మరిన్ని పనుల కోసం ఇక్కడ చూడండి](https://cryptodocguy.pro/).

