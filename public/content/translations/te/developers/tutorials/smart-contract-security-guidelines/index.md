---
title: స్మార్ట్ కాంట్రాక్ట్ భద్రతా మార్గదర్శకాలు
description: మీ డాప్‌ని నిర్మించేటప్పుడు పరిగణించవలసిన భద్రతా మార్గదర్శకాల తనిఖీ జాబితా
author: "Trailofbits"
tags: [ "దృఢత్వం", "స్మార్ట్ కాంట్రాక్టులు", "భద్రత" ]
skill: మధ్యస్థ
lang: te
published: 2020-09-06
source: సురక్షితమైన కాంట్రాక్టులను నిర్మించడం
sourceUrl: https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/guidelines.md
---

మరింత సురక్షితమైన స్మార్ట్ కాంట్రాక్ట్లను నిర్మించడానికి ఈ ఉన్నత-స్థాయి సిఫార్సులను అనుసరించండి.

## డిజైన్ మార్గదర్శకాలు {#design-guidelines}

ఏ ఒక్క లైను కోడ్ రాయడానికి ముందు, కాంట్రాక్ట్ డిజైన్‌ను ముందుగానే చర్చించాలి.

### డాక్యుమెంటేషన్ మరియు స్పెసిఫికేషన్లు {#documentation-and-specifications}

డాక్యుమెంటేషన్‌ను వివిధ స్థాయిలలో వ్రాయవచ్చు మరియు కాంట్రాక్టులను అమలు చేస్తున్నప్పుడు నవీకరించాలి:

- **సిస్టమ్ యొక్క సాదా ఆంగ్ల వివరణ**, కాంట్రాక్టులు ఏమి చేస్తాయో మరియు కోడ్‌బేస్‌పై ఏవైనా అంచనాలను వివరిస్తుంది.
- **స్కీమా మరియు నిర్మాణ రేఖాచిత్రాలు**, కాంట్రాక్ట్ పరస్పర చర్యలు మరియు సిస్టమ్ యొక్క స్టేట్ మెషీన్‌తో సహా. [Slither ప్రింటర్లు](https://github.com/crytic/slither/wiki/Printer-documentation) ఈ స్కీమాలను రూపొందించడంలో సహాయపడతాయి.
- **సమగ్రమైన కోడ్ డాక్యుమెంటేషన్**, Solidity కోసం [Natspec ఫార్మాట్](https://docs.soliditylang.org/en/develop/natspec-format.html) ను ఉపయోగించవచ్చు.

### ఆన్‌చైన్ వర్సెస్ ఆఫ్‌చైన్ కంప్యూటేషన్ {#onchain-vs-offchain-computation}

- **మీరు వీలైనంత ఎక్కువ కోడ్‌ను ఆఫ్‌చైన్‌లో ఉంచండి.** ఆన్‌చైన్ లేయర్‌ను చిన్నదిగా ఉంచండి. ఆన్‌చైన్‌లో ధృవీకరణ సరళంగా ఉండే విధంగా ఆఫ్‌చైన్ కోడ్‌తో డేటాను ముందుగా ప్రాసెస్ చేయండి. మీకు క్రమబద్ధమైన జాబితా అవసరమా? జాబితాను ఆఫ్‌చైన్‌లో క్రమబద్ధీకరించండి, తర్వాత దాని క్రమాన్ని ఆన్‌చైన్‌లో మాత్రమే తనిఖీ చేయండి.

### అప్‌గ్రేడబిలిటీ {#upgradeability}

మేము మా [బ్లాగ్‌పోస్ట్‌లో](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/) విభిన్న అప్‌గ్రేడబిలిటీ పరిష్కారాలను చర్చించాము. ఏదైనా కోడ్ రాయడానికి ముందు అప్‌గ్రేడబిలిటీకి మద్దతు ఇవ్వాలా వద్దా అనే దానిపై ఉద్దేశపూర్వక ఎంపిక చేసుకోండి. ఈ నిర్ణయం మీరు మీ కోడ్‌ను ఎలా నిర్మిస్తారనే దానిని ప్రభావితం చేస్తుంది. సాధారణంగా, మేము సిఫార్సు చేస్తున్నాము:

- **అప్‌గ్రేడబిలిటీ కంటే [కాంట్రాక్ట్ మైగ్రేషన్‌కు](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) ప్రాధాన్యత ఇవ్వడం.** మైగ్రేషన్ సిస్టమ్‌లు వాటి ప్రతికూలతలు లేకుండా, అప్‌గ్రేడబుల్ వాటికి ఉన్న అనేక ప్రయోజనాలను కలిగి ఉంటాయి.
- **delegatecallproxy దానిపై డేటా సెపరేషన్ ప్యాట్రన్‌ను ఉపయోగించడం.** మీ ప్రాజెక్ట్‌కు స్పష్టమైన అబ్స్ట్రాక్షన్ సెపరేషన్ ఉన్నట్లయితే, డేటా సెపరేషన్‌ని ఉపయోగించి అప్‌గ్రేడ్ చేయడానికి కొన్ని సర్దుబాట్లు మాత్రమే అవసరం. delegatecallproxyకి EVM నైపుణ్యం అవసరం మరియు ఇది చాలా దోషపూరితమైనది.
- **విస్తరణకు ముందు మైగ్రేషన్/అప్‌గ్రేడ్ విధానాన్ని డాక్యుమెంట్ చేయండి.** ఎలాంటి మార్గదర్శకాలు లేకుండా ఒత్తిడిలో మీరు స్పందించవలసి వస్తే, మీరు తప్పులు చేస్తారు. అనుసరించాల్సిన విధానాన్ని ముందుగానే వ్రాయండి. అందులో ఇవి ఉండాలి:
  - కొత్త కాంట్రాక్టులను ప్రారంభించే కాల్స్
  - కీలు ఎక్కడ నిల్వ చేయబడ్డాయి మరియు వాటిని ఎలా యాక్సెస్ చేయాలి
  - విస్తరణను ఎలా తనిఖీ చేయాలి! పోస్ట్-డిప్లాయ్‌మెంట్ స్క్రిప్ట్‌ను డెవలప్ చేసి, పరీక్షించండి.

## అమలు మార్గదర్శకాలు {#implementation-guidelines}

**సరళత కోసం ప్రయత్నించండి.** మీ ప్రయోజనానికి సరిపోయే సరళమైన పరిష్కారాన్ని ఎల్లప్పుడూ ఉపయోగించండి. మీ బృందంలోని ఏ సభ్యుడైనా మీ పరిష్కారాన్ని అర్థం చేసుకోగలగాలి.

### ఫంక్షన్ కంపోజిషన్ {#function-composition}

మీ కోడ్‌బేస్ యొక్క నిర్మాణం మీ కోడ్‌ను సమీక్షించడానికి సులభతరం చేయాలి. దాని ఖచ్చితత్వం గురించి వాదించే సామర్థ్యాన్ని తగ్గించే నిర్మాణ ఎంపికలను నివారించండి.

- **మీ సిస్టమ్ యొక్క లాజిక్‌ను విభజించండి**, బహుళ కాంట్రాక్టుల ద్వారా లేదా సారూప్యమైన ఫంక్షన్‌లను (ఉదాహరణకు, ప్రమాణీకరణ, అంకగణితం, ...) సమూహపరచడం ద్వారా.
- **స్పష్టమైన ప్రయోజనంతో చిన్న ఫంక్షన్‌లను వ్రాయండి.** ఇది సులభమైన సమీక్షను సులభతరం చేస్తుంది మరియు వ్యక్తిగత భాగాలను పరీక్షించడానికి అనుమతిస్తుంది.

### ఇన్హెరిటెన్స్ {#inheritance}

- **వారసత్వాన్ని నిర్వహించదగినదిగా ఉంచండి.** తర్కాన్ని విభజించడానికి వారసత్వాన్ని ఉపయోగించాలి, అయితే, మీ ప్రాజెక్ట్ వారసత్వ వృక్షం యొక్క లోతు మరియు వెడల్పును తగ్గించాలని లక్ష్యంగా పెట్టుకోవాలి.
- **కాంట్రాక్టుల సోపానక్రమాన్ని తనిఖీ చేయడానికి Slither యొక్క [ఇన్హెరిటెన్స్ ప్రింటర్‌ను](https://github.com/crytic/slither/wiki/Printer-documentation#inheritance-graph) ఉపయోగించండి.** ఇన్హెరిటెన్స్ ప్రింటర్ సోపానక్రమం యొక్క పరిమాణాన్ని సమీక్షించడంలో మీకు సహాయం చేస్తుంది.

### ఈవెంట్‌లు {#events}

- **అన్ని కీలకమైన కార్యకలాపాలను లాగ్ చేయండి.** ఈవెంట్‌లు అభివృద్ధి సమయంలో కాంట్రాక్ట్‌ను డీబగ్ చేయడానికి మరియు విస్తరణ తర్వాత దానిని పర్యవేక్షించడానికి సహాయపడతాయి.

### తెలిసిన ఆపదలను నివారించండి {#avoid-known-pitfalls}

- **అత్యంత సాధారణ భద్రతా సమస్యల గురించి తెలుసుకోండి.** [Ethernaut CTF](https://ethernaut.openzeppelin.com/), [Capture the Ether](https://capturetheether.com/), లేదా [Not so smart contracts](https://github.com/crytic/not-so-smart-contracts/) వంటి సాధారణ సమస్యల గురించి తెలుసుకోవడానికి అనేక ఆన్‌లైన్ వనరులు ఉన్నాయి.
- **[Solidity డాక్యుమెంటేషన్‌లోని](https://docs.soliditylang.org/en/latest/) హెచ్చరికల విభాగాల గురించి తెలుసుకోండి.** హెచ్చరికల విభాగాలు భాష యొక్క స్పష్టంగా కనిపించని ప్రవర్తన గురించి మీకు తెలియజేస్తాయి.

### డిపెండెన్సీలు {#dependencies}

- **బాగా పరీక్షించబడిన లైబ్రరీలను ఉపయోగించండి.** బాగా పరీక్షించబడిన లైబ్రరీల నుండి కోడ్‌ను దిగుమతి చేసుకోవడం వలన మీరు బగ్గీ కోడ్‌ను వ్రాసే సంభావ్యతను తగ్గిస్తుంది. మీరు ERC20 కాంట్రాక్ట్‌ను వ్రాయాలనుకుంటే, [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) ని ఉపయోగించండి.
- **డిపెండెన్సీ మేనేజర్‌ను ఉపయోగించండి; కోడ్‌ను కాపీ-పేస్ట్ చేయడాన్ని నివారించండి.** మీరు బాహ్య సోర్స్‌పై ఆధారపడి ఉంటే, మీరు దానిని అసలు సోర్స్‌తో అప్‌డేట్‌గా ఉంచాలి.

### పరీక్ష మరియు ధృవీకరణ {#testing-and-verification}

- **సమగ్రమైన యూనిట్-టెస్టులు వ్రాయండి.** అధిక-నాణ్యత సాఫ్ట్‌వేర్‌ను రూపొందించడానికి విస్తృతమైన టెస్ట్ సూట్ చాలా ముఖ్యం.
- **[Slither](https://github.com/crytic/slither), [Echidna](https://github.com/crytic/echidna) మరియు [Manticore](https://github.com/trailofbits/manticore) కస్టమ్ చెక్స్ మరియు ప్రాపర్టీలను వ్రాయండి.** ఆటోమేటెడ్ టూల్స్ మీ కాంట్రాక్ట్ సురక్షితంగా ఉందని నిర్ధారించడంలో సహాయపడతాయి. సమర్థవంతమైన తనిఖీలు మరియు లక్షణాలను ఎలా వ్రాయాలో తెలుసుకోవడానికి ఈ గైడ్‌లోని మిగిలిన వాటిని సమీక్షించండి.
- **[crytic.io](https://crytic.io/)ని ఉపయోగించండి.** Crytic GitHubతో కలిసిపోతుంది, ప్రైవేట్ Slither డిటెక్టర్లకు యాక్సెస్ అందిస్తుంది మరియు Echidna నుండి కస్టమ్ ప్రాపర్టీ తనిఖీలను నడుపుతుంది.

### సాలిడిటీ {#solidity}

- **0.4 మరియు 0.6 కంటే Solidity 0.5కి ప్రాధాన్యత ఇవ్వండి.** మా అభిప్రాయం ప్రకారం, Solidity 0.5 మరింత సురక్షితమైనది మరియు 0.4 కంటే మెరుగైన అంతర్నిర్మిత పద్ధతులను కలిగి ఉంది. Solidity 0.6 ఉత్పత్తికి చాలా అస్థిరంగా ఉందని నిరూపించబడింది మరియు పరిపక్వం చెందడానికి సమయం కావాలి.
- **కంపైల్ చేయడానికి స్థిరమైన విడుదలను ఉపయోగించండి; హెచ్చరికల కోసం తాజా విడుదలను ఉపయోగించండి.** తాజా కంపైలర్ వెర్షన్‌తో మీ కోడ్‌లో నివేదించబడిన సమస్యలు ఏవీ లేవని తనిఖీ చేయండి. అయినప్పటికీ, Solidity వేగవంతమైన విడుదల చక్రాన్ని కలిగి ఉంది మరియు కంపైలర్ బగ్‌ల చరిత్రను కలిగి ఉంది, కాబట్టి మేము విస్తరణ కోసం తాజా వెర్షన్‌ను సిఫార్సు చేయము (Slither's [solc వెర్షన్ సిఫార్సును](https://github.com/crytic/slither/wiki/Detector-Documentation#recommendation-33) చూడండి).
- **ఇన్‌లైన్ అసెంబ్లీని ఉపయోగించవద్దు.** అసెంబ్లీకి EVM నైపుణ్యం అవసరం. మీరు యెల్లో పేపర్‌పై _పట్టు_ సాధించకపోతే EVM కోడ్ రాయవద్దు.

## విస్తరణ మార్గదర్శకాలు {#deployment-guidelines}

కాంట్రాక్ట్ అభివృద్ధి చేయబడి, విస్తరించబడిన తర్వాత:

- **మీ కాంట్రాక్టులను పర్యవేక్షించండి.** లాగ్‌లను గమనిస్తూ ఉండండి మరియు కాంట్రాక్ట్ లేదా వాలెట్ రాజీపడినప్పుడు ప్రతిస్పందించడానికి సిద్ధంగా ఉండండి.
- **[blockchain-security-contacts](https://github.com/crytic/blockchain-security-contacts)కి మీ సంప్రదింపు సమాచారాన్ని జోడించండి.** భద్రతా లోపం కనుగొనబడితే మూడవ పక్షాలు మిమ్మల్ని సంప్రదించడానికి ఈ జాబితా సహాయపడుతుంది.
- **విశేష వినియోగదారుల వాలెట్‌లను భద్రపరచండి.** మీరు హార్డ్‌వేర్ వాలెట్లలో కీలను నిల్వ చేస్తే మా [ఉత్తమ పద్ధతులను](https://blog.trailofbits.com/2018/11/27/10-rules-for-the-secure-use-of-cryptocurrency-hardware-wallets/) అనుసరించండి.
- **సంఘటన ప్రతిస్పందన ప్రణాళికను కలిగి ఉండండి.** మీ స్మార్ట్ కాంట్రాక్టులు రాజీపడవచ్చని పరిగణించండి. మీ కాంట్రాక్టులు బగ్‌లు లేకుండా ఉన్నప్పటికీ, దాడి చేసేవాడు కాంట్రాక్ట్ యజమాని కీలను నియంత్రణలోకి తీసుకోవచ్చు.
