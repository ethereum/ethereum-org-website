---
title: "ఎల్లో పేపర్ యొక్క EVM స్పెసిఫికేషన్లను అర్థం చేసుకోవడం"
description: "ఇతీరియము కోసం అధికారిక స్పెసిఫికేషన్‌లు అయిన ఎల్లో పేపర్‌లోని, ఇతీరియము వర్చువల్ మెషీన్ (EVM)ను వివరించే భాగాన్ని అర్థం చేసుకోవడం."
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: te
published: 2022-05-15
---

[ఎల్లో పేపర్](https://ethereum.github.io/yellowpaper/paper.pdf) అనేది ఇతీరియము కోసం అధికారిక స్పెసిఫికేషన్. [EIP ప్రక్రియ](/eips/) ద్వారా సవరించబడిన చోట తప్ప, ప్రతిదీ ఎలా పనిచేస్తుందో దాని యొక్క ఖచ్చితమైన వివరణను ఇది కలిగి ఉంటుంది. ఇది ఒక గణిత పేపర్‌గా వ్రాయబడింది, ఇందులో ప్రోగ్రామర్‌లకు సుపరిచితం కాని పరిభాష ఉంటుంది. ఈ పేపర్‌లో మీరు దానిని ఎలా చదవాలో నేర్చుకుంటారు, మరియు తద్వారా ఇతర సంబంధిత గణిత పత్రాలను కూడా.

## ఏ ఎల్లో పేపర్? {#which-yellow-paper}

ఇతీరియములోని దాదాపు అన్ని ఇతర విషయాల వలె, ఎల్లో పేపర్ కూడా కాలక్రమేణా అభివృద్ధి చెందుతుంది. ఒక నిర్దిష్ట వెర్షన్‌ను సూచించగలగడానికి, నేను [వ్రాసే సమయంలో ఉన్న ప్రస్తుత వెర్షన్‌ను](yellow-paper-berlin.pdf) అప్‌లోడ్ చేసాను. నేను ఉపయోగించే విభాగం, పేజీ మరియు సమీకరణ సంఖ్యలు ఆ వెర్షన్‌ను సూచిస్తాయి. ఈ పత్రాన్ని చదివేటప్పుడు దానిని వేరొక విండోలో తెరిచి ఉంచడం మంచిది.

### EVM ఎందుకు? {#why-the-evm}

అసలైన ఎల్లో పేపర్ ఇతీరియము అభివృద్ధి ప్రారంభంలోనే వ్రాయబడింది. నెట్‌వర్క్‌ను భద్రపరచడానికి వాస్తవానికి ఉపయోగించిన అసలు ప్రూఫ్-ఆఫ్-వర్క్ ఆధారిత ఏకాభిప్రాయ యంత్రాంగాన్ని ఇది వివరిస్తుంది. అయితే, ఇతీరియము ప్రూఫ్-ఆఫ్-వర్క్‌ను నిలిపివేసి, సెప్టెంబర్ 2022లో ప్రూఫ్-ఆఫ్-స్టేక్ ఆధారిత ఏకాభిప్రాయాన్ని ఉపయోగించడం ప్రారంభించింది. ఈ ట్యుటోరియల్ ఎథేరియం వర్చువల్ మషీన్‌ను నిర్వచించే ఎల్లో పేపర్ భాగాలపై దృష్టి సారిస్తుంది. ప్రూఫ్-ఆఫ్-స్టేక్‌కు మారడం వల్ల EVM మారలేదు (DIFFICULTY ఆప్‌కోడ్ యొక్క రిటర్న్ విలువ మినహా).

## 9 ఎగ్జిక్యూషన్ మోడల్ {#9-execution-model}

ఈ విభాగం (p. 12-14) EVM యొక్క చాలా నిర్వచనాన్ని కలిగి ఉంటుంది.

_సిస్టమ్ స్థితి_ అనే పదంలో సిస్టమ్‌ను అమలు చేయడానికి దాని గురించి మీరు తెలుసుకోవలసిన ప్రతిదీ ఉంటుంది. ఒక సాధారణ కంప్యూటర్‌లో, దీని అర్థం మెమరీ, రిజిస్టర్‌ల కంటెంట్, మొదలైనవి.

[ట్యూరింగ్ మెషీన్](https://en.wikipedia.org/wiki/Turing_machine) అనేది గణన నమూనా. ముఖ్యంగా, ఇది కంప్యూటర్ యొక్క సరళీకృత వెర్షన్, ఇది సాధారణ కంప్యూటర్ చేయగల గణనలను అమలు చేసే సామర్థ్యాన్ని కలిగి ఉందని నిరూపించబడింది (కంప్యూటర్ లెక్కించగల ప్రతిదీ ట్యూరింగ్ మెషీన్ లెక్కించగలదు మరియు దీనికి విరుద్ధంగా కూడా). ఈ మోడల్ గణన సాధ్యమయ్యేవి మరియు కానివి అనే దాని గురించి వివిధ సిద్ధాంతాలను నిరూపించడాన్ని సులభతరం చేస్తుంది.

[ట్యూరింగ్-కంప్లీట్](https://en.wikipedia.org/wiki/Turing_completeness) అనే పదం ట్యూరింగ్ మెషీన్ వలె అదే గణనలను అమలు చేయగల కంప్యూటర్‌ను సూచిస్తుంది. ట్యూరింగ్ మెషీన్లు అనంత లూప్‌లలోకి వెళ్ళగలవు, మరియు EVM వెళ్ళలేదు ఎందుకంటే దానికి గ్యాస్ అయిపోతుంది, కాబట్టి ఇది కేవలం పాక్షిక-ట్యూరింగ్-కంప్లీట్.

## 9.1 ప్రాథమిక అంశాలు {#91-basics}

ఈ విభాగం EVM యొక్క ప్రాథమిక అంశాలను మరియు ఇది ఇతర గణన నమూనాలతో ఎలా పోలుస్తుందో వివరిస్తుంది.

[స్టాక్ మెషీన్](https://en.wikipedia.org/wiki/Stack_machine) అనేది ఒక కంప్యూటర్, ఇది మధ్యంతర డేటాను రిజిస్టర్లలో కాకుండా, ఒక [**స్టాక్**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\))లో నిల్వ చేస్తుంది. వర్చువల్ మెషీన్‌లకు ఇది ప్రాధాన్యత కలిగిన ఆర్కిటెక్చర్, ఎందుకంటే దీనిని అమలు చేయడం సులభం, అంటే బగ్‌లు మరియు భద్రతా బలహీనతలు చాలా తక్కువగా ఉంటాయి. స్టాక్‌లోని మెమరీ 256-బిట్ పదాలుగా విభజించబడింది. ఇది ఇతీరియము యొక్క కోర్ క్రిప్టోగ్రాఫిక్ ఆపరేషన్‌లైన కీకాక్-256 హాషింగ్ మరియు ఎలిప్టిక్ కర్వ్ గణనలకు సౌకర్యవంతంగా ఉండటం వల్ల ఎంచుకోబడింది. స్టాక్ యొక్క గరిష్ట పరిమాణం 1024 అంశాలు (1024 x 256 బిట్స్). ఆప్‌కోడ్‌లను అమలు చేసినప్పుడు, అవి సాధారణంగా స్టాక్ నుండి వాటి పారామీటర్‌లను పొందుతాయి. స్టాక్‌లోని మూలకాలను పునఃసంఘటించడానికి ప్రత్యేకంగా ఆప్‌కోడ్‌లు ఉన్నాయి, అవి `POP` (స్టాక్ పై నుండి అంశాన్ని తొలగిస్తుంది), `DUP_N` (స్టాక్‌లోని N'వ అంశాన్ని డూప్లికేట్ చేస్తుంది), మొదలైనవి.

EVMలో **మెమరీ** అని పిలువబడే ఒక అస్థిర స్థలం కూడా ఉంది, ఇది అమలు సమయంలో డేటాను నిల్వ చేయడానికి ఉపయోగించబడుతుంది. ఈ మెమరీ 32-బైట్ పదాలుగా నిర్వహించబడింది. అన్ని మెమరీ స్థానాలు సున్నాకు ప్రారంభించబడ్డాయి. మెమరీకి ఒక పదాన్ని జోడించడానికి మీరు ఈ [Yul](https://docs.soliditylang.org/en/latest/yul.html) కోడ్‌ను అమలు చేస్తే, అది పదంలోని ఖాళీ స్థలాన్ని సున్నాలతో పూరించడం ద్వారా 32 బైట్ల మెమరీని నింపుతుంది, అనగా, ఇది ఒక పదాన్ని సృష్టిస్తుంది - 0-29 స్థానాల్లో సున్నాలు, 30వ స్థానంలో 0x60, మరియు 31వ స్థానంలో 0xA7తో.

```yul
mstore(0, 0x60A7)
```

`mstore` అనేది మెమరీతో ఇంటరాక్ట్ అవ్వడానికి EVM అందించే మూడు ఆప్‌కోడ్‌లలో ఒకటి - ఇది మెమరీలోకి ఒక పదాన్ని లోడ్ చేస్తుంది. మిగతా రెండు `mstore8`, ఇది ఒకే బైట్‌ను మెమరీలోకి లోడ్ చేస్తుంది, మరియు `mload` ఇది మెమరీ నుండి స్టాక్‌కు ఒక పదాన్ని తరలిస్తుంది.

EVMలో ఒక ప్రత్యేకమైన అస్థిరత లేని **నిల్వ** మోడల్ కూడా ఉంది, ఇది సిస్టమ్ స్థితిలో భాగంగా నిర్వహించబడుతుంది - ఈ మెమరీ వర్డ్ అర్రేలలో నిర్వహించబడుతుంది (స్టాక్‌లోని వర్డ్-అడ్రెస్సబుల్ బైట్ అర్రేలకు విరుద్ధంగా). ఈ నిల్వ స్థలంలో కాంట్రాక్టులు శాశ్వత డేటాను ఉంచుతాయి - ఒక కాంట్రాక్టు దాని స్వంత నిల్వతో మాత్రమే పరస్పర చర్య చేయగలదు. నిల్వ కీ-విలువ మ్యాపింగ్‌లలో నిర్వహించబడుతుంది.

ఎల్లో పేపర్ యొక్క ఈ విభాగంలో పేర్కొననప్పటికీ, నాల్గవ రకం మెమరీ ఉందని కూడా తెలుసుకోవడం ఉపయోగకరంగా ఉంటుంది. **కాల్‌డేటా** అనేది బైట్-అడ్రెస్ చేయగల రీడ్-ఓన్లీ మెమరీ, ఇది లావాదేవీ యొక్క `డేటా` పారామీటర్‌తో పంపిన విలువను నిల్వ చేయడానికి ఉపయోగించబడుతుంది. EVMలో `calldata`ను నిర్వహించడానికి ప్రత్యేక ఆప్‌కోడ్‌లు ఉన్నాయి. `calldatasize` డేటా పరిమాణాన్ని తిరిగి ఇస్తుంది. `calldataload` డేటాను స్టాక్‌లోకి లోడ్ చేస్తుంది. `calldatacopy` డేటాను మెమరీలోకి కాపీ చేస్తుంది.

ప్రామాణిక [వాన్ న్యూమాన్ ఆర్కిటెక్చర్](https://en.wikipedia.org/wiki/Von_Neumann_architecture) సంకేత భాష మరియు డేటాను ఒకే మెమరీలో నిల్వ చేస్తుంది. భద్రతా కారణాల వల్ల EVM ఈ ప్రమాణాన్ని పాటించదు - అస్థిర మెమరీని పంచుకోవడం ప్రోగ్రామ్ సంకేత భాషను మార్చడానికి వీలు కల్పిస్తుంది. బదులుగా, సంకేత భాష నిల్వలో సేవ్ చేయబడుతుంది.

మెమరీ నుండి సంకేత భాష అమలు చేయబడే రెండు సందర్భాలు మాత్రమే ఉన్నాయి:

- ఒక కాంట్రాక్టు మరొక కాంట్రాక్టును సృష్టించినప్పుడు ([`CREATE`](https://www.evm.codes/#f0) లేదా [`CREATE2`](https://www.evm.codes/#f5) ఉపయోగించి), కాంట్రాక్ట్ కన్స్ట్రక్టర్ కోసం సంకేత భాష మెమరీ నుండి వస్తుంది.
- ఏదైనా కాంట్రాక్టు సృష్టించే సమయంలో, కన్స్ట్రక్టర్ సంకేత భాష రన్ అయి, ఆ తర్వాత అసలు కాంట్రాక్ట్ యొక్క సంకేత భాషతో, మెమరీ నుండే తిరిగి వస్తుంది.

అసాధారణమైన అమలు అనే పదం ప్రస్తుత కాంట్రాక్టు అమలును నిలిపివేయడానికి కారణమయ్యే ఒక మినహాయింపును సూచిస్తుంది.

## 9.2 ఫీజుల అవలోకనం {#92-fees-overview}

ఈ విభాగం గ్యాస్ ఫీజులు ఎలా లెక్కించబడతాయో వివరిస్తుంది. మూడు ఖర్చులు ఉన్నాయి:

### ఆప్‌కోడ్ ఖర్చు {#opcode-cost}

నిర్దిష్ట ఆప్‌కోడ్ యొక్క స్వాభావిక ఖర్చు. ఈ విలువను పొందడానికి, అపెండిక్స్ H (p. 28, సమీకరణం (327) కింద)లో ఆప్‌కోడ్ యొక్క కాస్ట్ గ్రూప్‌ను కనుగొని, సమీకరణం (324)లో కాస్ట్ గ్రూప్‌ను కనుగొనండి. ఇది మీకు కాస్ట్ ఫంక్షన్‌ను ఇస్తుంది, ఇది చాలా సందర్భాలలో అపెండిక్స్ G (p. 27) నుండి పారామీటర్‌లను ఉపయోగిస్తుంది.

ఉదాహరణకు, [`CALLDATACOPY`](https://www.evm.codes/#37) అనే ఆప్‌కోడ్ _W<sub>copy</sub>_ గ్రూప్ సభ్యుడు. ఆ గ్రూప్ కొరకు ఆప్‌కోడ్ ఖర్చు _G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_. అపెండిక్స్ G ని చూస్తే, రెండు స్థిరాంకాలు 3 అని మనం చూస్తాము, ఇది మనకు _3+3×⌈μ<sub>s</sub>[2]÷32⌉_ ఇస్తుంది.

మనం ఇప్పటికీ _⌈μ<sub>s</sub>[2]÷32⌉_ అనే వ్యక్తీకరణను అర్థం చేసుకోవాలి. వెలుపలి భాగం, _⌈ \<value\> ⌉_ అనేది సీలింగ్ ఫంక్షన్, ఇది ఒక విలువను ఇచ్చినప్పుడు, ఆ విలువ కంటే తక్కువ కాని అతి చిన్న పూర్ణాంకాన్ని తిరిగి ఇస్తుంది. ఉదాహరణకు, _⌈2.5⌉ = ⌈3⌉ = 3_. లోపలి భాగం _μ<sub>s</sub>[2]÷32_. p. 3లోని సెక్షన్ 3 (సంప్రదాయాలు)ని చూస్తే, _μ_ అనేది మెషీన్ స్థితి. మెషీన్ స్థితి p. 13లోని సెక్షన్ 9.4.1లో నిర్వచించబడింది. ఆ విభాగం ప్రకారం, మెషీన్ స్థితి పారామితులలో ఒకటి స్టాక్ కొరకు _s_. అన్నిటినీ కలిపి చూస్తే, _μ<sub>s</sub>[2]_ అనేది స్టాక్‌లోని #2 స్థానం అని అనిపిస్తుంది. [ఆప్‌కోడ్](https://www.evm.codes/#37)ను చూస్తే, స్టాక్‌లోని #2 స్థానం బైట్లలోని డేటా పరిమాణం. W<sub>copy</sub> గ్రూపులోని ఇతర ఆప్‌కోడ్‌లు, [`CODECOPY`](https://www.evm.codes/#39) మరియు [`RETURNDATACOPY`](https://www.evm.codes/#3e)లను చూస్తే, వాటికి కూడా అదే స్థానంలో డేటా పరిమాణం ఉంటుంది. కాబట్టి _⌈μ<sub>s</sub>[2]÷32⌉_ అనేది కాపీ చేయబడుతున్న డేటాను నిల్వ చేయడానికి అవసరమైన 32 బైట్ పదాల సంఖ్య. అన్నింటినీ కలిపి చూస్తే, [`CALLDATACOPY`](https://www.evm.codes/#37) యొక్క అంతర్లీన వ్యయం 3 గ్యాస్ మరియు కాపీ చేయబడుతున్న డేటా యొక్క ప్రతి పదానికి 3.

### రన్నింగ్ ఖర్చు {#running-cost}

మనం కాల్ చేస్తున్న సంకేత భాషను రన్ చేసే ఖర్చు.

- [`CREATE`](https://www.evm.codes/#f0) మరియు [`CREATE2`](https://www.evm.codes/#f5) విషయంలో, కొత్త కాంట్రాక్ట్ కొరకు కన్స్ట్రక్టర్.
- [`CALL`](https://www.evm.codes/#f1), [`CALLCODE`](https://www.evm.codes/#f2), [`STATICCALL`](https://www.evm.codes/#fa), లేదా [`DELEGATECALL`](https://www.evm.codes/#f4) విషయంలో, మనం కాల్ చేసే కాంట్రాక్ట్.

### మెమరీ ఖర్చును విస్తరించడం {#expanding-memory-cost}

మెమరీని విస్తరించే ఖర్చు (అవసరమైతే).

సమీకరణం 324లో, ఈ విలువ _C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_గా వ్రాయబడింది. సెక్షన్ 9.4.1ని మళ్ళీ చూస్తే, _μ<sub>i</sub>_ అనేది మెమరీలోని పదాల సంఖ్య అని మనం చూస్తాము. కాబట్టి _μ<sub>i</sub>_ అనేది ఆప్‌కోడ్‌కు ముందు మెమరీలోని పదాల సంఖ్య మరియు _μ<sub>i</sub>'_ అనేది ఆప్‌కోడ్‌కు తర్వాత మెమరీలోని పదాల సంఖ్య.

_C<sub>mem</sub>_ ఫంక్షన్ సమీకరణం 326లో నిర్వచించబడింది: _C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_. _⌊x⌋_ అనేది ఫ్లోర్ ఫంక్షన్, ఇది ఒక విలువను ఇచ్చినప్పుడు, ఆ విలువ కంటే పెద్దది కాని అతి పెద్ద పూర్ణాంకాన్ని తిరిగి ఇస్తుంది. ఉదాహరణకు, _⌊2.5⌋ = ⌊2⌋ = 2._ _a < √512_ అయినప్పుడు, _a<sup>2</sup> < 512_, మరియు ఫ్లోర్ ఫంక్షన్ ఫలితం సున్నా. కాబట్టి మొదటి 22 పదాలకు (704 బైట్లు), ఖర్చు అవసరమైన మెమరీ పదాల సంఖ్యతో సరళంగా పెరుగుతుంది. ఆ స్థానం దాటి _⌊a<sup>2</sup> ÷ 512⌋_ ధనాత్మకంగా ఉంటుంది. అవసరమైన మెమరీ తగినంత ఎక్కువగా ఉన్నప్పుడు గ్యాస్ ఖర్చు మెమరీ మొత్తానికి వర్గానికి అనుపాతంలో ఉంటుంది.

**గమనిక**: ఈ కారకాలు _అంతర్లీన_ గ్యాస్ వ్యయాన్ని మాత్రమే ప్రభావితం చేస్తాయి - తుది వినియోగదారుడు ఎంత చెల్లించాలో నిర్ణయించే ఫీజు మార్కెట్ లేదా వాలిడేటర్‌లకు ఇచ్చే చిట్కాలను ఇది పరిగణనలోకి తీసుకోదు - ఇది కేవలం EVMలో ఒక నిర్దిష్ట ఆపరేషన్‌ను అమలు చేయడానికి అయ్యే అసలు వ్యయం మాత్రమే.

[గ్యాస్ గురించి మరింత చదవండి](/developers/docs/gas/).

## 9.3 ఎగ్జిక్యూషన్ ఎన్విరాన్మెంట్ {#93-execution-env}

ఎగ్జిక్యూషన్ ఎన్విరాన్మెంట్ అనేది ఒక టపుల్, _I_, ఇది బ్లాక్‌చైన్ స్థితిలో లేదా EVMలో భాగం కాని సమాచారాన్ని కలిగి ఉంటుంది.

| పరామితి         | డేటాను యాక్సెస్ చేయడానికి ఆప్‌కోడ్                                                                                   | డేటాను యాక్సెస్ చేయడానికి సాలిడిటీ సంకేత భాష                  |
| --------------- | -------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                                               | `address(this)`                                               |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                                                | `tx.origin`                                                   |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                                              | `tx.gasprice`                                                 |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35), మొదలైనవి.                                               | `msg.data`                                                    |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                                                | `msg.sender`                                                  |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                                             | `msg.value`                                                   |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                                              | `address(this).code`                                          |
| _I<sub>H</sub>_ | బ్లాక్ హెడర్ ఫీల్డ్‌లు, [`NUMBER`](https://www.evm.codes/#43) మరియు [`DIFFICULTY`](https://www.evm.codes/#44) వంటివి | `block.number`, `block.difficulty`, మొదలైనవి. |
| _I<sub>e</sub>_ | కాంట్రాక్ట్‌ల మధ్య కాల్స్ (కాంట్రాక్ట్ క్రియేషన్‌తో సహా) కోసం కాల్ స్టాక్ యొక్క లోతు              |                                                               |
| _I<sub>w</sub>_ | EVM స్థితిని మార్చడానికి అనుమతించబడిందా, లేదా అది స్టాటిక్‌గా రన్ అవుతుందా                                           |                                                               |

సెక్షన్ 9లోని మిగిలిన భాగాన్ని అర్థం చేసుకోవడానికి మరికొన్ని పారామితులు అవసరం:

| పరామితి | సెక్షన్‌లో నిర్వచించబడింది                                     | అర్థం                                                                                                                                                                                                                                                              |
| ------- | -------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| _σ_     | 2 (p. 2, సమీకరణం 1)         | బ్లాక్‌చైన్ యొక్క స్థితి                                                                                                                                                                                                                                           |
| _g_     | 9.3 (p. 13) | మిగిలిన గ్యాస్                                                                                                                                                                                                                                                     |
| _A_     | 6.1 (p. 8)  | సంచిత ఉపస్థితి (లావాదేవీ ముగిసినప్పుడు షెడ్యూల్ చేయబడిన మార్పులు)                                                                                                                                                                               |
| _o_     | 9.3 (p. 13) | అంతర్గత లావాదేవీ (ఒక కాంట్రాక్టు మరొకటిని కాల్ చేసినప్పుడు) మరియు వ్యూ ఫంక్షన్‌లకు కాల్స్ (మీరు కేవలం సమాచారం కోసం అడుగుతున్నప్పుడు, కాబట్టి లావాదేవీ కోసం వేచి ఉండాల్సిన అవసరం లేదు) విషయంలో తిరిగి వచ్చే ఫలితం - అవుట్పుట్ |

## 9.4 ఎగ్జిక్యూషన్ అవలోకనం {#94-execution-overview}

ఇప్పుడు అన్ని ప్రాథమిక అంశాలు ఉన్నాయి, మనం చివరకు EVM ఎలా పనిచేస్తుందో పని చేయడం ప్రారంభించవచ్చు.

సమీకరణాలు 137-142 EVMను అమలు చేయడానికి ప్రారంభ పరిస్థితులను మనకు ఇస్తాయి:

| చిహ్నం           | ప్రారంభ విలువ                                                                    | అర్థం                                                                                                                                                                                                                                                                                                            |
| ---------------- | -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | మిగిలిన గ్యాస్                                                                                                                                                                                                                                                                                                   |
| _μ<sub>pc</sub>_ | _0_                                                                              | ప్రోగ్రామ్ కౌంటర్, అమలు చేయడానికి తదుపరి ఇన్స్ట్రక్షన్ యొక్క చిరునామా                                                                                                                                                                                                                                            |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | మెమరీ, అన్ని సున్నాలకు ప్రారంభించబడింది                                                                                                                                                                                                                                                                          |
| _μ<sub>i</sub>_  | _0_                                                                              | అత్యధిక మెమరీ స్థానం ఉపయోగించబడింది                                                                                                                                                                                                                                                                              |
| _μ<sub>s</sub>_  | _()_                                                          | స్టాక్, ప్రారంభంలో ఖాళీగా ఉంటుంది                                                                                                                                                                                                                                                                                |
| _μ<sub>o</sub>_  | _∅_                                                                              | అవుట్పుట్, మనం రిటర్న్ డేటాతో ([`RETURN`](https://www.evm.codes/#f3) లేదా [`REVERT`](https://www.evm.codes/#fd)) లేదా అది లేకుండా ([`STOP`](https://www.evm.codes/#00) లేదా [`SELFDESTRUCT`](https://www.evm.codes/#ff)) ఆపే వరకు మరియు ఆపకపోతే ఖాళీ సెట్. |

సమీకరణం 143 మనకు అమలు సమయంలో ప్రతి సమయంలో నాలుగు సాధ్యమయ్యే పరిస్థితులు ఉన్నాయని, మరియు వాటితో ఏమి చేయాలో చెబుతుంది:

1. `Z(σ,μ,A,I)`. Z అనేది ఒక ఆపరేషన్ చెల్లని స్థితి మార్పును సృష్టిస్తుందా లేదా అని పరీక్షించే ఒక ఫంక్షన్‌ను సూచిస్తుంది (చూడండి [అసాధారణమైన ఆపివేయడం](#942-exceptional-halting)). ఇది True అని మూల్యాంకనం చేస్తే, కొత్త స్థితి పాత దానితో సమానంగా ఉంటుంది (గ్యాస్ బర్న్ అవడం మినహా) ఎందుకంటే మార్పులు అమలు చేయబడలేదు.
2. అమలు చేయబడుతున్న ఆప్‌కోడ్ [`REVERT`](https://www.evm.codes/#fd) అయితే, కొత్త స్థితి పాత స్థితి వలెనే ఉంటుంది, కొంత గ్యాస్ కోల్పోబడుతుంది.
3. ఆపరేషన్ల క్రమం ముగిసినట్లయితే, [`RETURN`](https://www.evm.codes/#f3)) ద్వారా సూచించబడినట్లుగా, స్థితి కొత్త స్థితికి నవీకరించబడుతుంది.
4. మనం 1-3 ముగింపు షరతులలో ఒకదానిలో లేకపోతే, రన్ చేయడం కొనసాగించండి.

## 9.4.1 మెషీన్ స్థితి {#941-machine-state}

ఈ విభాగం మెషీన్ స్థితిని మరింత వివరంగా వివరిస్తుంది. ఇది _w_ ప్రస్తుత ఆప్‌కోడ్ అని నిర్దేశిస్తుంది. _μ<sub>pc</sub>_ అనేది _||I<sub>b</sub>||_ కంటే తక్కువగా ఉంటే, అంటే సంకేత భాష యొక్క పొడవు కంటే, ఆ బైట్ (_I<sub>b</sub>[μ<sub>pc</sub>]_) ఆప్‌కోడ్. లేకపోతే, ఆప్‌కోడ్ [`STOP`](https://www.evm.codes/#00)గా నిర్వచించబడింది.

ఇది ఒక [స్టాక్ మెషీన్](https://en.wikipedia.org/wiki/Stack_machine) కాబట్టి, ప్రతి ఆప్‌కోడ్ ద్వారా పాప్ చేయబడిన (_δ_) మరియు పుష్ చేయబడిన (_α_) అంశాల సంఖ్యను మనం ట్రాక్ చేయాలి.

## 9.4.2 అసాధారణమైన నిలిపివేత {#942-exceptional-halt}

ఈ విభాగం _Z_ ఫంక్షన్‌ను నిర్వచిస్తుంది, ఇది మనకు అసాధారణమైన ముగింపు ఎప్పుడు ఉంటుందో నిర్దేశిస్తుంది. ఇది ఒక [బూలియన్](https://en.wikipedia.org/wiki/Boolean_data_type) ఫంక్షన్, కాబట్టి ఇది [లాజికల్ ఆర్ కోసం _∨_](https://en.wikipedia.org/wiki/Logical_disjunction) మరియు [లాజికల్ అండ్ కోసం _∧_](https://en.wikipedia.org/wiki/Logical_conjunction) ఉపయోగిస్తుంది.

ఈ షరతులలో ఏది నిజమైనా మనకు అసాధారణమైన నిలుపుదల ఉంటుంది:

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  సెక్షన్ 9.2లో మనం చూసినట్లుగా, _C_ అనేది గ్యాస్ ఖర్చును నిర్దేశించే ఫంక్షన్. తదుపరి ఆప్‌కోడ్‌ను కవర్ చేయడానికి తగినంత గ్యాస్ మిగిలి లేదు.

- **_δ<sub>w</sub>=∅_**
  ఒక ఆప్‌కోడ్ కోసం పాప్ చేయబడిన ఐటెమ్‌ల సంఖ్య నిర్వచించబడకపోతే, అప్పుడు ఆ ఆప్‌కోడ్ కూడా నిర్వచించబడదు.

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  స్టాక్ అండర్‌ఫ్లో, ప్రస్తుత ఆప్‌కోడ్ కోసం స్టాక్‌లో తగినన్ని ఐటెమ్‌లు లేవు.

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  ఆప్‌కోడ్ [`JUMP`](https://www.evm.codes/#56) మరియు చిరునామా [`JUMPDEST`](https://www.evm.codes/#5b) కాదు. గమ్యం [`JUMPDEST`](https://www.evm.codes/#5b) అయినప్పుడు మాత్రమే జంప్‌లు చెల్లుబాటు అవుతాయి.

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  ఆప్‌కోడ్ [`JUMPI`](https://www.evm.codes/#57), షరతు నిజం (సున్నా కానిది) కాబట్టి జంప్ జరగాలి, మరియు చిరునామా [`JUMPDEST`](https://www.evm.codes/#5b) కాదు. గమ్యం [`JUMPDEST`](https://www.evm.codes/#5b) అయినప్పుడు మాత్రమే జంప్‌లు చెల్లుబాటు అవుతాయి.

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  ఆప్‌కోడ్ [`RETURNDATACOPY`](https://www.evm.codes/#3e). ఈ ఆప్‌కోడ్ స్టాక్ మూలకం _μ<sub>s</sub>[1]_ అనేది రిటర్న్ డేటా బఫర్‌లో చదవడానికి ఆఫ్‌సెట్, మరియు స్టాక్ మూలకం _μ<sub>s</sub>[2]_ అనేది డేటా పొడవు. మీరు రిటర్న్ డేటా బఫర్ ముగింపును దాటి చదవడానికి ప్రయత్నించినప్పుడు ఈ పరిస్థితి ఏర్పడుతుంది. కాల్‌డేటా లేదా సంకేత భాషకే అలాంటి షరతు లేదని గమనించండి. మీరు ఆ బఫర్‌ల ముగింపును దాటి చదవడానికి ప్రయత్నించినప్పుడు మీకు కేవలం సున్నాలు మాత్రమే వస్తాయి.

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  స్టాక్ పొంగి పొర్లు. ఆప్‌కోడ్‌ను అమలు చేయడం వల్ల 1024 కంటే ఎక్కువ ఐటెమ్‌లతో కూడిన స్టాక్ ఏర్పడితే, ఆపండి.

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  మనం స్టాటిక్‌గా రన్ చేస్తున్నామా ([¬ అనేది నిరాకరణ](https://en.wikipedia.org/wiki/Negation) మరియు మనం బ్లాక్‌చైన్ స్థితిని మార్చడానికి అనుమతించబడినప్పుడు _I<sub>w</sub>_ నిజం)?  అలా అయితే, మరియు మనం స్థితిని మార్చే ఆపరేషన్‌ను ప్రయత్నిస్తుంటే, అది జరగదు.

  _W(w,μ)_ ఫంక్షన్ తరువాత సమీకరణం 150లో నిర్వచించబడింది. ఈ షరతులలో ఒకటి నిజమైతే _W(w,μ)_ నిజం:

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    ఈ ఆప్‌కోడ్‌లు కొత్త కాంట్రాక్ట్‌ను సృష్టించడం, విలువను నిల్వ చేయడం లేదా ప్రస్తుత కాంట్రాక్ట్‌ను నాశనం చేయడం ద్వారా స్థితిని మారుస్తాయి.

  - **_LOG0≤w ∧ w≤LOG4_**
    మమ్మల్ని స్టాటిక్‌గా పిలిస్తే, మేము లాగ్ ఎంట్రీలను విడుదల చేయలేము.
    లాగ్ ఆప్‌కోడ్‌లు అన్నీ [`LOG0` (A0)](https://www.evm.codes/#a0) మరియు [`LOG4` (A4)](https://www.evm.codes/#a4) మధ్య పరిధిలో ఉన్నాయి.
    లాగ్ ఆప్‌కోడ్ తర్వాత ఉన్న సంఖ్య లాగ్ ఎంట్రీలో ఎన్ని టాపిక్‌లు ఉన్నాయో నిర్దేశిస్తుంది.

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    మీరు స్టాటిక్‌గా ఉన్నప్పుడు మరొక కాంట్రాక్ట్‌ను పిలవవచ్చు, కానీ అలా చేస్తే మీరు దానికి ETH బదిలీ చేయలేరు.

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  మీకు G<sub>callstipend</sub> (అపెండిక్స్ Gలో 2300గా నిర్వచించబడింది) కంటే ఎక్కువ గ్యాస్ ఉంటే తప్ప మీరు [`SSTORE`](https://www.evm.codes/#55)ను అమలు చేయలేరు.

## 9.4.3 జంప్ డెస్టినేషన్ చెల్లుబాటు {#943-jump-dest-valid}

ఇక్కడ మనం [`JUMPDEST`](https://www.evm.codes/#5b) ఆప్‌కోడ్‌లు ఏమిటో అధికారికంగా నిర్వచిస్తాము. మనం కేవలం 0x5B అనే బైట్ విలువను చూడలేము, ఎందుకంటే అది PUSH లోపల ఉండవచ్చు (మరియు అందువల్ల డేటా కానీ ఆప్‌కోడ్ కాదు).

సమీకరణం (153)లో మనం _N(i,w)_ అనే ఫంక్షన్‌ను నిర్వచిస్తాము. మొదటి పారామీటర్, _i_, ఆప్‌కోడ్ యొక్క స్థానం. రెండవది, _w_, ఆప్‌కోడ్. w∈[PUSH1, PUSH32] అయితే, ఆప్‌కోడ్ ఒక PUSH అని అర్థం (చతురస్రాకార బ్రాకెట్‌లు ముగింపు బిందువులను కలిగి ఉన్న పరిధిని నిర్వచిస్తాయి). ఆ సందర్భంలో తదుపరి ఆప్‌కోడ్ _i+2+(w−PUSH1)_ వద్ద ఉంటుంది. [`PUSH1`](https://www.evm.codes/#60) కోసం మనం రెండు బైట్లు ముందుకు వెళ్ళాలి (PUSH స్వయంగా మరియు ఒక బైట్ విలువ), [`PUSH2`](https://www.evm.codes/#61) కోసం మనం మూడు బైట్లు ముందుకు వెళ్ళాలి ఎందుకంటే ఇది రెండు బైట్ల విలువ, మొదలైనవి. అన్ని ఇతర EVM ఆప్‌కోడ్‌లు కేవలం ఒక బైట్ పొడవు ఉంటాయి, కాబట్టి అన్ని ఇతర సందర్భాలలో _N(i,w)=i+1_.

ఈ ఫంక్షన్ సమీకరణం (152)లో _D<sub>J</sub>(c,i)_ని నిర్వచించడానికి ఉపయోగించబడుతుంది, ఇది సంకేత భాష _c_లో, ఆప్‌కోడ్ స్థానం _i_తో ప్రారంభమయ్యే అన్ని చెల్లుబాటు అయ్యే జంప్ గమ్యస్థానాల [సెట్](https://en.wikipedia.org/wiki/Set_\(mathematics\)). ఈ ఫంక్షన్ పునరావృతంగా నిర్వచించబడింది. i≥||c||_ అయితే, అంటే మనం సంకేత భాష చివరిలో లేదా దాని తర్వాత ఉన్నాము. మనం ఇకపై జంప్ గమ్యస్థానాలను కనుగొనలేము, కాబట్టి ఖాళీ సెట్‌ను తిరిగి ఇవ్వండి.

అన్ని ఇతర సందర్భాల్లో మనం తదుపరి ఆప్‌కోడ్‌కు వెళ్లి దాని నుండి ప్రారంభమయ్యే సెట్‌ను పొందడం ద్వారా సంకేత భాష యొక్క మిగిలిన భాగాన్ని చూస్తాము. _c[i]_ అనేది ప్రస్తుత ఆప్‌కోడ్, కాబట్టి _N(i,c[i])_ అనేది తదుపరి ఆప్‌కోడ్ యొక్క స్థానం. _D<sub>J</sub>(c,N(i,c[i]))_ అనేది తదుపరి ఆప్‌కోడ్ వద్ద ప్రారంభమయ్యే చెల్లుబాటు అయ్యే జంప్ గమ్యస్థానాల సెట్. ప్రస్తుత ఆప్‌కోడ్ `JUMPDEST` కాకపోతే, ఆ సెట్‌ను తిరిగి ఇవ్వండి. అది `JUMPDEST` అయితే, దానిని ఫలిత సెట్‌లో చేర్చి, దానిని తిరిగి ఇవ్వండి.

## 9.4.4 సాధారణ నిలిపివేత {#944-normal-halt}

నిలిపివేసే ఫంక్షన్ _H_, మూడు రకాల విలువలను తిరిగి ఇవ్వగలదు.

- మనం హాల్ట్ ఆప్‌కోడ్‌లో లేకపోతే, _∅_, ఖాళీ సెట్‌ను తిరిగి ఇవ్వండి. సంప్రదాయం ప్రకారం, ఈ విలువ బూలియన్ ఫాల్స్‌గా అన్వయించబడుతుంది.
- మనం అవుట్‌పుట్‌ను ఉత్పత్తి చేయని హాల్ట్ ఆప్‌కోడ్‌ను కలిగి ఉంటే ([`STOP`](https://www.evm.codes/#00) లేదా [`SELFDESTRUCT`](https://www.evm.codes/#ff)), రిటర్న్ విలువగా సున్నా పరిమాణం గల బైట్‌ల క్రమాన్ని తిరిగి ఇవ్వండి. ఇది ఖాళీ సెట్‌కు చాలా భిన్నమైనదని గమనించండి. ఈ విలువ అంటే EVM నిజంగా ఆగిపోయింది, కానీ చదవడానికి రిటర్న్ డేటా లేదు.
- మనం అవుట్‌పుట్‌ను ఉత్పత్తి చేసే హాల్ట్ ఆప్‌కోడ్‌ను కలిగి ఉంటే ([`RETURN`](https://www.evm.codes/#f3) లేదా [`REVERT`](https://www.evm.codes/#fd)), ఆ ఆప్‌కోడ్ ద్వారా నిర్దేశించబడిన బైట్‌ల క్రమాన్ని తిరిగి ఇవ్వండి. ఈ క్రమం మెమరీ నుండి తీసుకోబడింది, స్టాక్ పైభాగంలో ఉన్న విలువ (_μ<sub>s</sub>[0]_) మొదటి బైట్, మరియు దాని తర్వాత ఉన్న విలువ (_μ<sub>s</sub>[1]_) పొడవు.

## H.2 ఇన్స్ట్రక్షన్ సెట్ {#h2-instruction-set}

మనం EVM యొక్క చివరి ఉపవిభాగం 9.5కు వెళ్లే ముందు, ఇన్స్ట్రక్షన్‌లనే చూద్దాం. అవి p. 29లో ప్రారంభమయ్యే అపెండిక్స్ H.2లో నిర్వచించబడ్డాయి. ఆ నిర్దిష్ట ఆప్‌కోడ్‌తో మారుతున్నట్లుగా పేర్కొనబడని ఏదైనా అదే విధంగా ఉంటుందని ఆశించబడుతుంది. మారే వేరియబుల్స్ \<something\>′గా పేర్కొనబడ్డాయి.

ఉదాహరణకు, [`ADD`](https://www.evm.codes/#01) ఆప్‌కోడ్‌ను చూద్దాం.

| విలువ | సంకేత నామం | δ | α | వివరణ                                                                                                                                                                                                                 |
| ----: | ---------- | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x01 | ADD        | 2 | 1 | సంకలన ఆపరేషన్.                                                                                                                                                                                        |
|       |            |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_ అనేది మనం స్టాక్ నుండి పాప్ చేసే విలువల సంఖ్య. ఈ సందర్భంలో రెండు, ఎందుకంటే మనం పై రెండు విలువలను కలుపుతున్నాము.

_α_ అనేది మనం తిరిగి పుష్ చేసే విలువల సంఖ్య. ఈ సందర్భంలో ఒకటి, మొత్తం.

కాబట్టి కొత్త స్టాక్ టాప్ (_μ′<sub>s</sub>[0]_) పాత స్టాక్ టాప్ (_μ<sub>s</sub>[0]_) మరియు దాని కింద ఉన్న పాత విలువ (_μ<sub>s</sub>[1]_) యొక్క మొత్తం.

"కళ్ళు తిరిగే జాబితా"తో అన్ని ఆప్‌కోడ్‌లను పరిశీలించే బదులు, ఈ కథనం కొత్తది ఏదైనా పరిచయం చేసే ఆ ఆప్‌కోడ్‌లను మాత్రమే వివరిస్తుంది.

| విలువ | సంకేత నామం | δ | α | వివరణ                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ----: | ---------- | - | - | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x20 | KECCAK256  | 2 | 1 | కీకాక్-256 హాష్‌ను లెక్కించండి.                                                                                                                                                                                                                                                                                                                                                                                                                      |
|       |            |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] . . . (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|       |            |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                                                     |

మెమరీని యాక్సెస్ చేసే మొదటి ఆప్‌కోడ్ ఇది (ఈ సందర్భంలో, రీడ్ ఓన్లీ). అయినప్పటికీ, ఇది మెమరీ యొక్క ప్రస్తుత పరిమితులకు మించి విస్తరించవచ్చు, కాబట్టి మనం _μ<sub>i</sub>_ ని నవీకరించాలి._ మనం దీనిని p. 29లోని సమీకరణం 328లో నిర్వచించబడిన _M_ ఫంక్షన్‌ను ఉపయోగించి చేస్తాము.

| విలువ | సంకేత నామం | δ | α | వివరణ                                                    |
| ----: | ---------- | - | - | -------------------------------------------------------- |
|  0x31 | BALANCE    | 1 | 1 | ఇచ్చిన ఖాతా యొక్క బ్యాలెన్స్‌ను పొందండి. |
|       |            |   |   | ...      |

మనం బ్యాలెన్స్ కనుగొనవలసిన చిరునామా _μ<sub>s</sub>[0] mod 2<sup>160</sup>_. స్టాక్ పైన ఉన్నది చిరునామా, కానీ చిరునామాలు కేవలం 160 బిట్‌లు మాత్రమే కాబట్టి, మనం విలువను [మాడ్యులో](https://en.wikipedia.org/wiki/Modulo_operation) 2<sup>160</sup> లెక్కిస్తాము.

σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_ అయితే, ఈ చిరునామా గురించి సమాచారం ఉందని అర్థం. ఆ సందర్భంలో, _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_ ఆ చిరునామా యొక్క బ్యాలెన్స్. σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_ అయితే, ఈ చిరునామా ప్రారంభించబడలేదని మరియు బ్యాలెన్స్ సున్నా అని అర్థం. మీరు p. 4లోని సెక్షన్ 4.1లో ఖాతా సమాచార ఫీల్డ్‌ల జాబితాను చూడవచ్చు.

రెండవ సమీకరణం, _A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_, వెచ్చని నిల్వ (ఇటీవల యాక్సెస్ చేయబడిన మరియు కాష్ చేయబడే అవకాశం ఉన్న నిల్వ) మరియు చల్లని నిల్వ (యాక్సెస్ చేయబడని మరియు తిరిగి పొందడానికి ఎక్కువ ఖరీదైన నెమ్మదిగా ఉన్న నిల్వలో ఉండే అవకాశం ఉన్న నిల్వ) మధ్య ఖర్చు వ్యత్యాసానికి సంబంధించినది. _A<sub>a</sub>_ అనేది లావాదేవీ ద్వారా గతంలో యాక్సెస్ చేయబడిన చిరునామా జాబితా, ఇది యాక్సెస్ చేయడానికి చౌకగా ఉండాలి, p. 8లోని సెక్షన్ 6.1లో నిర్వచించబడినట్లుగా. మీరు ఈ విషయం గురించి [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)లో మరింత చదవవచ్చు.

| విలువ | సంకేత నామం | δ  | α  | వివరణ                                                                                                                                           |
| ----: | ---------- | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
|  0x8F | DUP16      | 16 | 17 | 16వ స్టాక్ ఐటెమ్‌ను డూప్లికేట్ చేయండి.                                                                                          |
|       |            |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

ఏదైనా స్టాక్ ఐటెమ్‌ను ఉపయోగించడానికి, మనం దానిని పాప్ చేయాలని గమనించండి, అంటే మనం దాని పైన ఉన్న అన్ని స్టాక్ ఐటెమ్‌లను కూడా పాప్ చేయాలి. [`DUP<n>`](https://www.evm.codes/#8f) మరియు [`SWAP<n>`](https://www.evm.codes/#9f) విషయంలో, దీని అర్థం పదహారు విలువల వరకు పాప్ చేసి, ఆపై పుష్ చేయవలసి ఉంటుంది.

## 9.5 ఎగ్జిక్యూషన్ సైకిల్ {#95-exec-cycle}

ఇప్పుడు మనకు అన్ని భాగాలు ఉన్నాయి, మనం చివరకు EVM యొక్క ఎగ్జిక్యూషన్ సైకిల్ ఎలా డాక్యుమెంట్ చేయబడిందో అర్థం చేసుకోవచ్చు.

సమీకరణం (155) స్థితిని బట్టి ఇలా చెబుతుంది:

- _σ_ (గ్లోబల్ బ్లాక్‌చైన్ స్థితి)
- _μ_ (EVM స్థితి)
- _A_ (ఉపస్థితి, లావాదేవీ ముగిసినప్పుడు జరిగే మార్పులు)
- _I_ (ఎగ్జిక్యూషన్ ఎన్విరాన్మెంట్)

కొత్త స్థితి _(σ', μ', A', I')_.

సమీకరణాలు (156)-(158) స్టాక్‌ను మరియు ఒక ఆప్‌కోడ్ (_μ<sub>s</sub>_) కారణంగా అందులో జరిగే మార్పును నిర్వచిస్తాయి. సమీకరణం (159) అనేది గ్యాస్‌లో మార్పు (_μ<sub>g</sub>_). సమీకరణం (160) ప్రోగ్రామ్ కౌంటర్ (_μ<sub>pc</sub>_)లో మార్పు. చివరగా, సమీకరణాలు (161)-(164) ఇతర పారామీటర్లు ఆప్‌కోడ్ ద్వారా స్పష్టంగా మార్చబడకపోతే అవే విధంగా ఉంటాయని నిర్దేశిస్తాయి.

దీనితో EVM పూర్తిగా నిర్వచించబడింది.

## ముగింపు {#conclusion}

గణిత సంజ్ఞామానం కచ్చితమైనది మరియు ఎల్లో పేపర్ ఇతీరియము యొక్క ప్రతి వివరాలను పేర్కొనడానికి అనుమతించింది. అయినప్పటికీ, దీనికి కొన్ని ప్రతికూలతలు ఉన్నాయి:

- ఇది మానవులకు మాత్రమే అర్థమవుతుంది, అంటే [కంప్లయన్స్ టెస్టులు](https://github.com/ethereum/tests) మాన్యువల్‌గా వ్రాయబడాలి.
- ప్రోగ్రామర్లు కంప్యూటర్ సంకేత భాషను అర్థం చేసుకుంటారు.
  వారు గణిత సంజ్ఞామానాన్ని అర్థం చేసుకోవచ్చు లేదా చేసుకోకపోవచ్చు.

బహుశా ఈ కారణాల వల్ల, కొత్త [ఏకాభిప్రాయం లేయర్ స్పెక్స్](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md) పైథాన్‌లో వ్రాయబడ్డాయి. [పైథాన్‌లో ఎగ్జిక్యూషన్ లేయర్ స్పెక్స్](https://ethereum.github.io/execution-specs) ఉన్నాయి, కానీ అవి పూర్తి కాలేదు. మొత్తం ఎల్లో పేపర్‌ను పైథాన్ లేదా అలాంటి భాషలోకి అనువదించే వరకు మరియు అనువదించనంత వరకు, ఎల్లో పేపర్ సేవలో కొనసాగుతుంది, మరియు దానిని చదవగలగడం సహాయకరంగా ఉంటుంది.
