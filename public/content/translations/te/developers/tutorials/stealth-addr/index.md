---
title: "స్టెల్త్ చిరునామాలను ఉపయోగించడం"
description: "స్టెల్త్ చిరునామాలు వినియోగదారులను అనామకంగా ఆస్తులను బదిలీ చేయడానికి అనుమతిస్తాయి. ఈ కథనాన్ని చదివిన తర్వాత, మీరు వీటిని చేయగలరు: స్టెల్త్ చిరునామాలు అంటే ఏమిటి మరియు అవి ఎలా పనిచేస్తాయో వివరించడం, అనామకతను కాపాడే విధంగా స్టెల్త్ చిరునామాలను ఎలా ఉపయోగించాలో అర్థం చేసుకోవడం, మరియు స్టెల్త్ చిరునామాలను ఉపయోగించే వెబ్-ఆధారిత అప్లికేషన్‌ను వ్రాయడం."
author: "ఓరి పోమెరాంట్జ్"
tags:
  [
    "స్టెల్త్ చిరునామా",
    "గోప్యత",
    "క్రిప్టోగ్రఫీ",
    "రస్ట్",
    "wasm"
  ]
skill: "మధ్యస్థ"
published: 2025-11-30
lang: te
sidebarDepth: 3
---

మీరు బిల్. మేము వివరించని కొన్ని కారణాల వల్ల, మీరు "అలీస్ ఫర్ క్వీన్ ఆఫ్ ది వరల్డ్" ప్రచారానికి విరాళం ఇవ్వాలనుకుంటున్నారు మరియు మీరు విరాళం ఇచ్చారని అలీస్‌కు తెలియజేయాలనుకుంటున్నారు, తద్వారా ఆమె గెలిస్తే మీకు బహుమతి ఇస్తుంది. దురదృష్టవశాత్తు, ఆమె విజయం హామీ ఇవ్వబడదు. పోటీగా ఒక ప్రచారం ఉంది, "కరోల్ ఫర్ ఎంప్రెస్ ఆఫ్ ది సోలార్ సిస్టం". ఒకవేళ కరోల్ గెలిచి, మీరు అలీస్‌కు విరాళం ఇచ్చారని ఆమెకు తెలిస్తే, మీరు చిక్కుల్లో పడతారు. కాబట్టి మీరు మీ ఖాతా నుండి అలీస్ ఖాతాకు 200 ETH బదిలీ చేయలేరు.

[ERC-5564](https://eips.ethereum.org/EIPS/eip-5564)కి పరిష్కారం ఉంది. అనామక బదిలీల కోసం [స్టెల్త్ చిరునామాలను](https://nerolation.github.io/stealth-utils) ఎలా ఉపయోగించాలో ఈ ERC వివరిస్తుంది.

**హెచ్చరిక**: మాకు తెలిసినంతవరకు, స్టెల్త్ చిరునామాల వెనుక ఉన్న క్రిప్టోగ్రఫీ సురక్షితమైనది. అయితే, సైడ్-ఛానల్ దాడులకు అవకాశం ఉంది. ఈ ప్రమాదాన్ని తగ్గించడానికి మీరు ఏమి చేయగలరో [క్రింద](#go-wrong) మీరు చూస్తారు.

## స్టెల్త్ చిరునామాలు ఎలా పనిచేస్తాయి {#how}

ఈ వ్యాసం రెండు విధాలుగా స్టెల్త్ చిరునామాలను వివరించడానికి ప్రయత్నిస్తుంది. మొదటిది [వాటిని ఎలా ఉపయోగించాలి](#how-use). ఈ భాగం వ్యాసంలోని మిగిలిన భాగాన్ని అర్థం చేసుకోవడానికి సరిపోతుంది. ఆ తర్వాత, దాని వెనుక ఉన్న గణితం యొక్క [వివరణ](#how-math) ఉంది. మీకు క్రిప్టోగ్రఫీపై ఆసక్తి ఉంటే, ఈ భాగాన్ని కూడా చదవండి.

### సాధారణ వెర్షన్ (స్టెల్త్ చిరునామాలను ఎలా ఉపయోగించాలి) {#how-use}

అలీస్ రెండు ప్రైవేట్ కీలను సృష్టిస్తుంది మరియు దానికి సంబంధించిన పబ్లిక్ కీలను ప్రచురిస్తుంది (వీటిని ఒకే డబుల్-లెంగ్త్ మెటా-చిరునామాలో కలపవచ్చు). బిల్ కూడా ఒక ప్రైవేట్ కీని సృష్టించి, దానికి సంబంధించిన పబ్లిక్ కీని ప్రచురిస్తాడు.

ఒకరి పబ్లిక్ కీని మరియు మరొకరి ప్రైవేట్ కీని ఉపయోగించి, మీరు అలీస్ మరియు బిల్‌కు మాత్రమే తెలిసిన భాగస్వామ్య రహస్యాన్ని పొందవచ్చు (దీనిని కేవలం పబ్లిక్ కీల నుండి మాత్రమే పొందలేరు). ఈ భాగస్వామ్య రహస్యాన్ని ఉపయోగించి, బిల్ స్టెల్త్ చిరునామాను పొందుతాడు మరియు దానికి ఆస్తులను పంపగలడు.

అలీస్ కూడా భాగస్వామ్య రహస్యం నుండి చిరునామాను పొందుతుంది, కానీ ఆమె ప్రచురించిన పబ్లిక్ కీలకు సంబంధించిన ప్రైవేట్ కీలు ఆమెకు తెలుసు కాబట్టి, ఆ చిరునామా నుండి విత్‌డ్రా చేయడానికి వీలు కల్పించే ప్రైవేట్ కీని కూడా ఆమె పొందగలదు.

### గణితం (స్టెల్త్ చిరునామాలు ఇలా ఎందుకు పని చేస్తాయి) {#how-math}

ప్రామాణిక స్టెల్త్ చిరునామాలు [ఎలిప్టిక్-కర్వ్ క్రిప్టోగ్రఫీ (ECC)](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/#elliptic-curves-building-blocks-of-a-better-trapdoor)ని ఉపయోగించి తక్కువ కీ బిట్‌లతో మెరుగైన పనితీరును పొందుతాయి, అదే సమయంలో భద్రతా స్థాయిని అలాగే ఉంచుతాయి. కానీ చాలా వరకు మనం దానిని పట్టించుకోకుండా, సాధారణ అంకగణితాన్ని ఉపయోగిస్తున్నామని నటించవచ్చు.

అందరికీ తెలిసిన ఒక సంఖ్య ఉంది, _G_. మీరు _G_తో గుణించవచ్చు. కానీ ECC స్వభావం కారణంగా, _G_తో భాగించడం ఆచరణాత్మకంగా అసాధ్యం. సాధారణంగా ఇతీరియములో పబ్లిక్ కీ క్రిప్టోగ్రఫీ పనిచేసే విధానం ఏమిటంటే, మీరు ఒక ప్రైవేట్ కీ, \*P<sub>priv</sub>\*ని ఉపయోగించి లావాదేవీలపై సంతకం చేయవచ్చు, అవి తర్వాత ఒక పబ్లిక్ కీ, _P<sub>pub</sub> = GP<sub>priv</sub>_ ద్వారా ధృవీకరించబడతాయి.

అలీస్ రెండు ప్రైవేట్ కీలను సృష్టిస్తుంది, _K<sub>priv</sub>_ మరియు _V<sub>priv</sub>_. _K<sub>priv</sub>_ స్టెల్త్ చిరునామా నుండి డబ్బు ఖర్చు చేయడానికి ఉపయోగించబడుతుంది, మరియు _V<sub>priv</sub>_ అలీస్‌కు చెందిన చిరునామాలను వీక్షించడానికి ఉపయోగించబడుతుంది. ఆ తర్వాత అలీస్ పబ్లిక్ కీలను ప్రచురిస్తుంది: _K<sub>pub</sub> = GK<sub>priv</sub>_ మరియు _V<sub>pub</sub> = GV<sub>priv</sub>_

బిల్ మూడవ ప్రైవేట్ కీ, \*R<sub>priv</sub>\*ని సృష్టిస్తాడు మరియు \*R<sub>pub</sub> = GR<sub>priv</sub>\*ని ఒక కేంద్ర రిజిస్ట్రీకి ప్రచురిస్తాడు (బిల్ దానిని అలీస్‌కు కూడా పంపించి ఉండవచ్చు, కానీ కరోల్ వింటున్నదని మేము ఊహించుకుంటాము).

బిల్ \*R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>\*ను లెక్కిస్తాడు, ఇది అలీస్‌కు కూడా తెలుస్తుందని అతను ఆశిస్తాడు (క్రింద వివరించబడింది). ఈ విలువను _S_, భాగస్వామ్య రహస్యం అని పిలుస్తారు. ఇది బిల్‌కు ఒక పబ్లిక్ కీ, \*P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)\*ను ఇస్తుంది. ఈ పబ్లిక్ కీ నుండి, అతను ఒక చిరునామాను లెక్కించగలడు మరియు అతనికి కావలసిన వనరులను దానికి పంపగలడు. భవిష్యత్తులో, ఒకవేళ అలీస్ గెలిస్తే, ఆ వనరులు తన నుండే వచ్చాయని నిరూపించడానికి బిల్ ఆమెకు \*R<sub>priv</sub>\*ను చెప్పగలడు.

అలీస్ \*R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>\*ను లెక్కిస్తుంది. ఇది ఆమెకు అదే భాగస్వామ్య రహస్యం, _S_ని ఇస్తుంది. ఆమెకు ప్రైవేట్ కీ, _K<sub>priv</sub>_ తెలుసు కాబట్టి, ఆమె \*P<sub>priv</sub> = K<sub>priv</sub>+hash(S)\*ను లెక్కించగలదు. ఈ కీ ఆమెకు _P<sub>pub</sub> = GP<sub>priv</sub> = GK<sub>priv</sub>+G\*hash(S) = K<sub>pub</sub>+G\*hash(S)_ నుండి వచ్చే చిరునామాలో ఉన్న ఆస్తులను యాక్సెస్ చేయడానికి అనుమతిస్తుంది.

అలీస్ డేవ్ ప్రపంచ ఆధిపత్య ప్రచార సేవలకు సబ్‌కాంట్రాక్ట్ ఇవ్వడానికి వీలుగా మేము ఒక ప్రత్యేక వీక్షణ కీని కలిగి ఉన్నాము. అలీస్ పబ్లిక్ చిరునామాలను డేవ్‌కు తెలియజేయడానికి మరియు మరింత డబ్బు అందుబాటులోకి వచ్చినప్పుడు తనకు తెలియజేయడానికి సిద్ధంగా ఉంది, కానీ అతను తన ప్రచార డబ్బును ఖర్చు చేయకూడదని ఆమె కోరుకుంటుంది.

వీక్షించడం మరియు ఖర్చు చేయడం వేర్వేరు కీలను ఉపయోగిస్తాయి కాబట్టి, అలీస్ డేవ్‌కు _V<sub>priv</sub>_ ఇవ్వగలదు. అప్పుడు డేవ్ \*S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>\*ను లెక్కించగలడు మరియు ఆ విధంగా పబ్లిక్ కీలను (_P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_) పొందగలడు. కానీ _K<sub>priv</sub>_ లేకుండా డేవ్ ప్రైవేట్ కీని పొందలేడు.

సారాంశంలో, ఇవి వివిధ పాల్గొనేవారికి తెలిసిన విలువలు.

| అలీస్                                                                     | ప్రచురించబడింది   | బిల్                                                                      | డేవ్                                                                        |                                                  |
| ------------------------------------------------------------------------- | ----------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------ |
| G                                                                         | G                 | G                                                                         | G                                                                           |                                                  |
| _K<sub>priv</sub>_                                                        | —                 | —                                                                         | —                                                                           |                                                  |
| _V<sub>priv</sub>_                                                        | —                 | —                                                                         | _V<sub>priv</sub>_                                                          |                                                  |
| _K<sub>pub</sub> = GK<sub>priv</sub>_                                     | _K<sub>pub</sub>_ | _K<sub>pub</sub>_                                                         | _K<sub>pub</sub>_                                                           |                                                  |
| _V<sub>pub</sub> = GV<sub>priv</sub>_                                     | _V<sub>pub</sub>_ | _V<sub>pub</sub>_                                                         | _V<sub>pub</sub>_                                                           |                                                  |
| —                                                                         | —                 | _R<sub>priv</sub>_                                                        | —                                                                           |                                                  |
| _R<sub>pub</sub>_                                                         | _R<sub>pub</sub>_ | _R<sub>pub</sub> = GR<sub>priv</sub>_                                     | _R<sub>pub</sub>_                                                           |                                                  |
| _S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | —                 | _S = R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | _S = _R<sub>pub</sub>V<sub>priv</sub>_ = GR<sub>priv</sub>V<sub>priv</sub>_ |                                                  |
| _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | —                 | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_           |                                                  |
| _చిరునామా=f(P<sub>pub</sub>)_                          | —                 | _చిరునామా=f(P<sub>pub</sub>)_                          | _చిరునామా=f(P<sub>pub</sub>)_                            | _చిరునామా=f(P<sub>pub</sub>)_ |
| _P<sub>priv</sub> = K<sub>priv</sub>+hash(S)_          | —                 | —                                                                         | —                                                                           |                                                  |

## స్టెల్త్ చిరునామాలు తప్పుగా వెళ్ళినప్పుడు {#go-wrong}

_బ్లాక్ చైనులో రహస్యాలు ఉండవు_. స్టెల్త్ చిరునామాలు మీకు గోప్యతను అందించగలిగినప్పటికీ, ఆ గోప్యత ట్రాఫిక్ విశ్లేషణకు లోబడి ఉంటుంది. ఒక చిన్న ఉదాహరణ చెప్పాలంటే, బిల్ ఒక చిరునామాకు నిధులు సమకూర్చి, వెంటనే _R<sub>pub</sub>_ విలువను ప్రచురించడానికి ఒక లావాదేవీని పంపుతాడని ఊహించుకోండి. అలీస్ యొక్క _V<sub>priv</sub>_ లేకుండా, ఇది ఒక స్టెల్త్ చిరునామా అని మనం ఖచ్చితంగా చెప్పలేము, కానీ ఆ విధంగా పందెం వేయవచ్చు. ఆ తర్వాత, ఆ చిరునామా నుండి మొత్తం ETHని అలీస్ ప్రచార నిధి చిరునామాకు బదిలీ చేసే మరో లావాదేవీని మనం చూస్తాము. మనం దానిని నిరూపించలేకపోవచ్చు, కానీ బిల్ అలీస్ ప్రచారానికి విరాళం ఇచ్చి ఉండవచ్చు. కరోల్ ఖచ్చితంగా అలాగే అనుకుంటుంది.

బిల్ _R<sub>pub</sub>_ ప్రచురణను స్టెల్త్ చిరునామాకు నిధులు సమకూర్చడం నుండి వేరు చేయడం సులభం (వివిధ సమయాల్లో, వివిధ చిరునామాల నుండి వాటిని చేయండి). అయితే, అది సరిపోదు. కరోల్ వెతికే నమూనా ఏమిటంటే, బిల్ ఒక చిరునామాకు నిధులు సమకూర్చడం, ఆ తర్వాత అలీస్ ప్రచార నిధి దాని నుండి విత్‌డ్రా చేసుకోవడం.

ఒక పరిష్కారం ఏమిటంటే, అలీస్ ప్రచారం డబ్బును నేరుగా విత్‌డ్రా చేసుకోకుండా, దానిని మూడవ పక్షానికి చెల్లించడానికి ఉపయోగించడం. ఒకవేళ అలీస్ ప్రచారం 10 ETHని డేవ్ ప్రపంచ ఆధిపత్య ప్రచార సేవలకు పంపితే, బిల్ డేవ్ కస్టమర్లలో ఒకరికి విరాళం ఇచ్చాడని కరోల్‌కు మాత్రమే తెలుస్తుంది. డేవ్‌కు తగినంత కస్టమర్లు ఉంటే, బిల్ తనతో పోటీపడే అలీస్‌కు విరాళం ఇచ్చాడా, లేదా కరోల్ పట్టించుకోని ఆడం, ఆల్బర్ట్, లేదా అబిగైల్‌కు ఇచ్చాడా అని కరోల్ తెలుసుకోలేదు. అలీస్ చెల్లింపుతో ఒక హాష్ విలువను చేర్చవచ్చు, ఆ తర్వాత డేవ్‌కు ప్రిఇమేజ్ అందించవచ్చు, అది తన విరాళం అని నిరూపించడానికి. ప్రత్యామ్నాయంగా, పైన పేర్కొన్నట్లుగా, అలీస్ డేవ్‌కు తన \*V<sub>priv</sub>\*ని ఇస్తే, ఆ చెల్లింపు ఎవరి నుండి వచ్చిందో అతనికి ఇప్పటికే తెలుసు.

ఈ పరిష్కారంతో ప్రధాన సమస్య ఏమిటంటే, ఆ రహస్యం బిల్‌కు ప్రయోజనం చేకూర్చినప్పుడు అలీస్ దాని గురించి పట్టించుకోవాలి. బిల్ స్నేహితుడు బాబ్ కూడా తనకు విరాళం ఇస్తాడని అలీస్ తన ప్రతిష్టను కాపాడుకోవాలనుకోవచ్చు. కానీ ఆమె బిల్‌ను బయటపెట్టడానికి కూడా వెనుకాడకపోవచ్చు, ఎందుకంటే అప్పుడు అతను కరోల్ గెలిస్తే ఏమి జరుగుతుందో అని భయపడతాడు. బిల్ చివరికి అలీస్‌కు మరింత మద్దతు అందించవచ్చు.

### బహుళ స్టెల్త్ లేయర్‌లను ఉపయోగించడం {#multi-layer}

బిల్ గోప్యతను కాపాడటానికి అలీస్‌పై ఆధారపడటానికి బదులుగా, బిల్ దానిని స్వయంగా చేయగలడు. అతను కల్పిత వ్యక్తులు, బాబ్ మరియు బెల్లా కోసం బహుళ మెటా-చిరునామాలను సృష్టించగలడు. బిల్ అప్పుడు బాబ్‌కు ETH పంపుతాడు, మరియు "బాబ్" (వాస్తవానికి బిల్) దానిని బెల్లాకు పంపుతాడు. "బెల్లా" (కూడా బిల్) దానిని అలీస్‌కు పంపుతుంది.

కరోల్ ఇప్పటికీ ట్రాఫిక్ విశ్లేషణ చేసి బిల్-టు-బాబ్-టు-బెల్లా-టు-అలీస్ పైప్‌లైన్‌ను చూడగలదు. అయితే, "బాబ్" మరియు "బెల్లా" కూడా ఇతర ప్రయోజనాల కోసం ETHని ఉపయోగిస్తే, బిల్ అలీస్‌కు ఏమీ బదిలీ చేసినట్లు కనిపించదు, అలీస్ వెంటనే స్టెల్త్ చిరునామా నుండి తన తెలిసిన ప్రచార చిరునామాకు విత్‌డ్రా చేసుకున్నప్పటికీ.

## స్టెల్త్-చిరునామా అప్లికేషన్‌ను వ్రాయడం {#write-app}

ఈ వ్యాసం [GitHubలో అందుబాటులో ఉన్న](https://github.com/qbzzt/251022-stealth-addresses.git) ఒక స్టెల్త్-చిరునామా అప్లికేషన్‌ను వివరిస్తుంది.

### ఉపకరణాలు {#tools}

మనం ఉపయోగించగల [ఒక టైప్‌స్క్రిప్ట్ స్టెల్త్ చిరునామా లైబ్రరీ](https://github.com/ScopeLift/stealth-address-sdk) ఉంది. అయితే, క్రిప్టోగ్రాఫిక్ కార్యకలాపాలు CPU-ఇంటెన్సివ్ కావచ్చు. నేను వాటిని [రస్ట్](https://rust-lang.org/) వంటి సంకలనం చేయబడిన భాషలో అమలు చేయడానికి ఇష్టపడతాను, మరియు బ్రౌజర్‌లో సంకేత భాషను అమలు చేయడానికి [WASM](https://webassembly.org/)ని ఉపయోగిస్తాను.

మేము [Vite](https://vite.dev/) మరియు [React](https://react.dev/)ని ఉపయోగించబోతున్నాము. ఇవి పరిశ్రమ-ప్రామాణిక ఉపకరణాలు; మీకు వాటితో పరిచయం లేకపోతే, మీరు [ఈ ట్యుటోరియల్](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/)ను ఉపయోగించవచ్చు. Viteని ఉపయోగించడానికి, మాకు Node అవసరం.

### కార్యకలాపంలో స్టెల్త్ చిరునామాలను చూడండి {#in-action}

1. అవసరమైన ఉపకరణాలను ఇన్‌స్టాల్ చేయండి: [రస్ట్](https://rust-lang.org/tools/install/) మరియు [Node](https://nodejs.org/en/download).

2. GitHub రిపోజిటరీని క్లోన్ చేయండి.

   ```sh
   git clone https://github.com/qbzzt/251022-stealth-addresses.git
   cd 251022-stealth-addresses
   ```

3. అవసరమైన వాటిని ఇన్‌స్టాల్ చేయండి మరియు రస్ట్ సంకేత భాషను సంకలనం చేయండి.

   ```sh
   cd src/rust-wasm
   rustup target add wasm32-unknown-unknown   
   cargo install wasm-pack   
   wasm-pack build --target web
   ```

4. వెబ్ సర్వర్‌ను ప్రారంభించండి.

   ```sh
   cd ../..
   npm install
   npm run dev
   ```

5. [అప్లికేషన్‌కు](http://localhost:5173/) బ్రౌజ్ చేయండి. ఈ అప్లికేషన్ పేజీకి రెండు ఫ్రేమ్‌లు ఉన్నాయి: ఒకటి అలీస్ వినియోగదారు ఇంటర్‌ఫేస్ కోసం మరియు మరొకటి బిల్ కోసం. రెండు ఫ్రేమ్‌లు కమ్యూనికేట్ చేయవు; అవి సౌలభ్యం కోసం మాత్రమే ఒకే పేజీలో ఉన్నాయి.

6. అలీస్‌గా, **ఒక స్టెల్త్ మెటా-చిరునామాను సృష్టించు** క్లిక్ చేయండి. ఇది కొత్త స్టెల్త్ చిరునామాను మరియు దానికి సంబంధించిన ప్రైవేట్ కీలను ప్రదర్శిస్తుంది. స్టెల్త్ మెటా-చిరునామాను క్లిప్‌బోర్డ్‌కు కాపీ చేయండి.

7. బిల్‌గా, కొత్త స్టెల్త్ మెటా-చిరునామాను పేస్ట్ చేసి, **ఒక చిరునామాను సృష్టించు** క్లిక్ చేయండి. ఇది మీకు అలీస్ కోసం నిధులు సమకూర్చడానికి చిరునామాను ఇస్తుంది.

8. చిరునామా మరియు బిల్ పబ్లిక్ కీని కాపీ చేసి, వాటిని అలీస్ వినియోగదారు ఇంటర్‌ఫేస్‌లోని "బిల్ ద్వారా సృష్టించబడిన చిరునామా కోసం ప్రైవేట్ కీ" ప్రాంతంలో పేస్ట్ చేయండి. ఆ ఫీల్డ్‌లను పూరించిన తర్వాత, మీరు ఆ చిరునామాలోని ఆస్తులను యాక్సెస్ చేయడానికి ప్రైవేట్ కీని చూస్తారు.

9. ప్రైవేట్ కీ చిరునామాకు అనుగుణంగా ఉందని నిర్ధారించుకోవడానికి మీరు [ఒక ఆన్‌లైన్ కాలిక్యులేటర్‌ను](https://iancoleman.net/ethereum-private-key-to-address/) ఉపయోగించవచ్చు.

### ప్రోగ్రామ్ ఎలా పని చేస్తుంది {#how-the-program-works}

#### WASM కాంపోనెంట్ {#wasm}

WASMలోకి సంకలనం చేయబడిన మూల సంకేత భాష [రస్ట్](https://rust-lang.org/)లో వ్రాయబడింది. మీరు దానిని [`src/rust_wasm/src/lib.rs`](https://github.com/qbzzt/251022-stealth-addresses/blob/main/src/rust-wasm/src/lib.rs)లో చూడవచ్చు. ఈ సంకేత భాష ప్రాథమికంగా జావాస్క్రిప్ట్ సంకేత భాష మరియు [`eth-stealth-addresses` లైబ్రరీ](https://github.com/kassandraoftroy/eth-stealth-addresses) మధ్య ఒక ఇంటర్‌ఫేస్.

**`Cargo.toml`**

రస్ట్‌లో [`Cargo.toml`](https://doc.rust-lang.org/cargo/reference/manifest.html) జావాస్క్రిప్ట్‌లో [`package.json`](https://docs.npmjs.com/cli/v9/configuring-npm/package-json)కి సమానమైనది. ఇది ప్యాకేజీ సమాచారం, ఆధారపడటం ప్రకటనలు మొదలైనవాటిని కలిగి ఉంటుంది.

```toml
[package]
name = "rust-wasm"
version = "0.1.0"
edition = "2024"

[dependencies]
eth-stealth-addresses = "0.1.0"
hex = "0.4.3"
wasm-bindgen = "0.2.104"
getrandom = { version = "0.2", features = ["js"] }
```

[`getrandom`](https://docs.rs/getrandom/latest/getrandom/) ప్యాకేజీ యాదృచ్ఛిక విలువలను ఉత్పత్తి చేయాలి. అది కేవలం అల్గారిథమిక్ పద్ధతుల ద్వారా చేయబడదు; దీనికి ఎంట్రోపీ యొక్క మూలంగా భౌతిక ప్రక్రియకు యాక్సెస్ అవసరం. ఈ నిర్వచనం మనం నడుపుతున్న బ్రౌజర్‌ను అడగడం ద్వారా ఆ ఎంట్రోపీని పొందుతామని నిర్దేశిస్తుంది.

```toml
console_error_panic_hook = "0.1.7"
```

[ఈ లైబ్రరీ](https://docs.rs/console_error_panic_hook/latest/console_error_panic_hook/) WASM సంకేత భాష పానిక్ అయినప్పుడు మరియు కొనసాగించలేనప్పుడు మనకు మరింత అర్థవంతమైన దోష సందేశాలను ఇస్తుంది.

```toml
[lib]
crate-type = ["cdylib", "rlib"]
```

WASM సంకేత భాషను ఉత్పత్తి చేయడానికి అవసరమైన అవుట్‌పుట్ రకం.

**`lib.rs`**

ఇది అసలు రస్ట్ సంకేత భాష.

```rust
use wasm_bindgen::prelude::*;
```

రస్ట్ నుండి WASM ప్యాకేజీని సృష్టించడానికి నిర్వచనాలు. అవి [ఇక్కడ](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/index.html) డాక్యుమెంట్ చేయబడ్డాయి.

```rust
use eth_stealth_addresses::{
    generate_stealth_meta_address,
    generate_stealth_address,
    compute_stealth_key
};
```

మాకు [`eth-stealth-addresses` లైబ్రరీ](https://github.com/kassandraoftroy/eth-stealth-addresses) నుండి అవసరమైన ఫంక్షన్లు.

```rust
use hex::{decode,encode};
```

రస్ట్ సాధారణంగా విలువల కోసం బైట్ [అరేలను](https://doc.rust-lang.org/std/primitive.array.html) (`[u8; <size>]`) ఉపయోగిస్తుంది. కానీ జావాస్క్రిప్ట్‌లో, మనం సాధారణంగా హెక్సాడెసిమల్ స్ట్రింగ్‌లను ఉపయోగిస్తాము. [`hex` లైబ్రరీ](https://docs.rs/hex/latest/hex/) ఒక ప్రాతినిధ్యం నుండి మరొక దానికి మన కోసం అనువదిస్తుంది.

```rust
#[wasm_bindgen]
```

ఈ ఫంక్షన్‌ను జావాస్క్రిప్ట్ నుండి పిలవడానికి WASM బైండింగ్‌లను సృష్టించండి.

```rust
pub fn wasm_generate_stealth_meta_address() -> String {
```

బహుళ ఫీల్డ్‌లతో ఒక ఆబ్జెక్ట్‌ను తిరిగి ఇవ్వడానికి సులభమైన మార్గం JSON స్ట్రింగ్‌ను తిరిగి ఇవ్వడం.

```rust
    let (address, spend_private_key, view_private_key) = 
        generate_stealth_meta_address();
```

[`generate_stealth_meta_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_meta_address.html) మూడు ఫీల్డ్‌లను తిరిగి ఇస్తుంది:

- మెటా-చిరునామా (_K<sub>pub</sub>_ మరియు _V<sub>pub</sub>_)
- వీక్షణ ప్రైవేట్ కీ (_V<sub>priv</sub>_)
- ఖర్చు ప్రైవేట్ కీ (_K<sub>priv</sub>_)

[టపుల్](https://doc.rust-lang.org/std/primitive.tuple.html) వాక్యనిర్మాణం ఆ విలువలను మళ్లీ వేరు చేయడానికి అనుమతిస్తుంది.

```rust
    format!("{{\"address\":\"{}\",\"view_private_key\":\"{}\",\"spend_private_key\":\"{}\"}}",
        encode(address),
        encode(view_private_key),
        encode(spend_private_key)
    )
}
```

JSON-ఎన్‌కోడ్ చేయబడిన స్ట్రింగ్‌ను సృష్టించడానికి [`format!`](https://doc.rust-lang.org/std/fmt/index.html) మాక్రోని ఉపయోగించండి. అరేలను హెక్స్ స్ట్రింగ్‌లకు మార్చడానికి [`hex::encode`](https://docs.rs/hex/latest/hex/fn.encode.html)ని ఉపయోగించండి.

```rust
fn str_to_array<const N: usize>(s: &str) -> Option<[u8; N]> {
```

ఈ ఫంక్షన్ (జావాస్క్రిప్ట్ ద్వారా అందించబడిన) హెక్స్ స్ట్రింగ్‌ను బైట్ అర్రేగా మారుస్తుంది. జావాస్క్రిప్ట్ సంకేత భాష ద్వారా అందించబడిన విలువలను పార్స్ చేయడానికి మనం దానిని ఉపయోగిస్తాము. రస్ట్ అరేలు మరియు వెక్టర్లను ఎలా నిర్వహిస్తుందో దాని కారణంగా ఈ ఫంక్షన్ సంక్లిష్టంగా ఉంటుంది.

`<const N: usize>` వ్యక్తీకరణను [జెనరిక్](https://doc.rust-lang.org/book/ch10-01-syntax.html) అంటారు. `N` అనేది తిరిగి ఇవ్వబడిన అరే యొక్క పొడవును నియంత్రించే ఒక పారామీటర్. ఈ ఫంక్షన్‌ను వాస్తవానికి `str_to_array::<n>` అని పిలుస్తారు, ఇక్కడ `n` అనేది అరే పొడవు.

తిరిగి ఇవ్వబడిన విలువ `Option<[u8; N]>`, అంటే తిరిగి ఇవ్వబడిన అరే [ఆప్షనల్](https://doc.rust-lang.org/std/option/) అని అర్థం. ఇది విఫలం కాగల ఫంక్షన్ల కోసం రస్ట్‌లో ఒక సాధారణ నమూనా.

ఉదాహరణకు, మనం `str_to_array::10("bad060a7")` అని పిలిస్తే, ఫంక్షన్ పది-విలువల అరేను తిరిగి ఇవ్వాలి, కానీ ఇన్‌పుట్ కేవలం నాలుగు బైట్లు మాత్రమే. ఫంక్షన్ విఫలం కావాలి, మరియు అది `None`ను తిరిగి ఇవ్వడం ద్వారా అలా చేస్తుంది. `str_to_array::4("bad060a7")` కోసం తిరిగి ఇవ్వబడిన విలువ `Some<[0xba, 0xd0, 0x60, 0xa7]>` అవుతుంది.

```rust
    // డీకోడ్ Result<Vec<u8>, _>ను తిరిగి ఇస్తుంది
    let vec = decode(s).ok()?;
```

[`hex::decode`](https://docs.rs/hex/latest/hex/fn.decode.html) ఫంక్షన్ `Result<Vec<u8>, FromHexError>`ను తిరిగి ఇస్తుంది. [`Result`](https://doc.rust-lang.org/std/result/) రకం విజయవంతమైన ఫలితం (`Ok(value)`) లేదా దోషం (`Err(error)`) కలిగి ఉండవచ్చు.

`.ok()` పద్ధతి `Result`ను `Option`గా మారుస్తుంది, దీని విలువ విజయవంతమైతే `Ok()` విలువ లేదా కాకపోతే `None` అవుతుంది. చివరగా, [ప్రశ్నార్థక గుర్తు ఆపరేటర్](https://doc.rust-lang.org/std/option/#the-question-mark-operator-) ప్రస్తుత ఫంక్షన్లను రద్దు చేసి, `Option` ఖాళీగా ఉంటే `None`ను తిరిగి ఇస్తుంది. లేకపోతే, ఇది విలువను అన్‌వ్రాప్ చేసి, దానిని తిరిగి ఇస్తుంది (ఈ సందర్భంలో, `vec`కు ఒక విలువను కేటాయించడానికి).

ఇది దోషాలను నిర్వహించడానికి ఒక వింత సంక్లిష్టమైన పద్ధతిలా కనిపిస్తుంది, కానీ `Result` మరియు `Option` అన్ని దోషాలు ఒక విధంగా లేదా మరొక విధంగా నిర్వహించబడుతున్నాయని నిర్ధారిస్తాయి.

```rust
    if vec.len() != N { return None; }
```

బైట్ల సంఖ్య తప్పుగా ఉంటే, అది ఒక వైఫల్యం, మరియు మనం `None`ను తిరిగి ఇస్తాము.

```rust
    // try_into vecను వినియోగించి [u8; N] చేయడానికి ప్రయత్నిస్తుంది
    let array: [u8; N] = vec.try_into().ok()?;
```

రస్ట్‌లో రెండు అరే రకాలు ఉన్నాయి. [అరేలకు](https://doc.rust-lang.org/std/primitive.array.html) ఒక స్థిర పరిమాణం ఉంటుంది. [వెక్టర్లు](https://doc.rust-lang.org/std/vec/index.html) పెరగవచ్చు మరియు తగ్గవచ్చు. `hex::decode` ఒక వెక్టర్‌ను తిరిగి ఇస్తుంది, కానీ `eth_stealth_addresses` లైబ్రరీ అరేలను స్వీకరించాలనుకుంటుంది. [`.try_into()`](https://doc.rust-lang.org/std/convert/trait.TryInto.html#required-methods) ఒక విలువను మరొక రకంలోకి మారుస్తుంది, ఉదాహరణకు, ఒక వెక్టర్‌ను ఒక అరేలోకి.

```rust
    Some(array)
}
```

రస్ట్ ఫంక్షన్ చివరిలో ఒక విలువను తిరిగి ఇచ్చేటప్పుడు [`return`](https://doc.rust-lang.org/std/keyword.return.html) కీవర్డ్‌ను ఉపయోగించమని అవసరం లేదు.

```rust
#[wasm_bindgen]
pub fn wasm_generate_stealth_address(stealth_address: &str) -> Option<String> {
```

ఈ ఫంక్షన్ ఒక పబ్లిక్ మెటా-చిరునామాను స్వీకరిస్తుంది, ఇందులో _V<sub>pub</sub>_ మరియు _K<sub>pub</sub>_ రెండూ ఉంటాయి. ఇది స్టెల్త్ చిరునామా, ప్రచురించడానికి పబ్లిక్ కీ (_R<sub>pub</sub>_), మరియు అలీస్‌కు చెందిన ప్రచురిత చిరునామాలను గుర్తించడాన్ని వేగవంతం చేసే ఒక-బైట్ స్కాన్ విలువను తిరిగి ఇస్తుంది.

స్కాన్ విలువ భాగస్వామ్య రహస్యం (_S = GR<sub>priv</sub>V<sub>priv</sub>_)లో ఒక భాగం. ఈ విలువ అలీస్‌కు అందుబాటులో ఉంటుంది, మరియు _f(K<sub>pub</sub>+G\*hash(S))_ ప్రచురిత చిరునామాకు సమానమా కాదా అని తనిఖీ చేయడం కంటే దీనిని తనిఖీ చేయడం చాలా వేగవంతమైనది.

```rust
    let (address, r_pub, scan) = 
        generate_stealth_address(&str_to_array::<66>(stealth_address)?);
```

మేము లైబ్రరీ యొక్క [`generate_stealth_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_address.html)ని ఉపయోగిస్తాము.

```rust
    format!("{{\"address\":\"{}\",\"rPub\":\"{}\",\"scan\":\"{}\"}}",
        encode(address),
        encode(r_pub),
        encode(&[scan])
    ).into()
}
```

JSON-ఎన్‌కోడ్ చేయబడిన అవుట్‌పుట్ స్ట్రింగ్‌ను సిద్ధం చేయండి.

```rust
#[wasm_bindgen]
pub fn wasm_compute_stealth_key(
    address: &str, 
    bill_pub_key: &str, 
    view_private_key: &str,
    spend_private_key: &str    
) -> Option<String> {
    .
    .
    .
}
```

ఈ ఫంక్షన్ లైబ్రరీ యొక్క [`compute_stealth_key`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.compute_stealth_key.html)ని ఉపయోగించి చిరునామా (_R<sub>priv</sub>_) నుండి విత్‌డ్రా చేయడానికి ప్రైవేట్ కీని లెక్కిస్తుంది. ఈ గణనకు ఈ విలువలు అవసరం:

- చిరునామా (_చిరునామా=f(P<sub>pub</sub>)_)
- బిల్ ద్వారా సృష్టించబడిన పబ్లిక్ కీ (_R<sub>pub</sub>_)
- వీక్షణ ప్రైవేట్ కీ (_V<sub>priv</sub>_)
- ఖర్చు ప్రైవేట్ కీ (_K<sub>priv</sub>_)

```rust
#[wasm_bindgen(start)]
```

[`#[wasm_bindgen(start)]`](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html) WASM సంకేత భాష ప్రారంభించబడినప్పుడు ఫంక్షన్ అమలు చేయబడుతుందని నిర్దేశిస్తుంది.

```rust
pub fn main() {
    console_error_panic_hook::set_once();
}
```

ఈ సంకేత భాష పానిక్ అవుట్‌పుట్‌ను జావాస్క్రిప్ట్ కన్సోల్‌కు పంపమని నిర్దేశిస్తుంది. దీనిని ఆచరణలో చూడటానికి, అప్లికేషన్‌ను ఉపయోగించి బిల్‌కు చెల్లని మెటా-చిరునామా ఇవ్వండి (కేవలం ఒక హెక్సాడెసిమల్ అంకెను మార్చండి). మీరు జావాస్క్రిప్ట్ కన్సోల్‌లో ఈ దోషాన్ని చూస్తారు:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs:701:9:
assertion `left == right` failed
  left: 0
 right: 1
```

ఆ తర్వాత స్టాక్ ట్రేస్ ఉంటుంది. అప్పుడు బిల్‌కు చెల్లుబాటు అయ్యే మెటా-చిరునామా ఇవ్వండి, మరియు అలీస్‌కు చెల్లని చిరునామా లేదా చెల్లని పబ్లిక్ కీ ఇవ్వండి. మీరు ఈ దోషాన్ని చూస్తారు:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/eth-stealth-addresses-0.1.0/src/lib.rs:78:9:
keys do not generate stealth address
```

మళ్లీ, ఆ తర్వాత స్టాక్ ట్రేస్ ఉంటుంది.

#### వినియోగదారు ఇంటర్‌ఫేస్ {#ui}

వినియోగదారు ఇంటర్‌ఫేస్ [React](https://react.dev/) ఉపయోగించి వ్రాయబడింది మరియు [Vite](https://vite.dev/) ద్వారా అందించబడుతుంది. మీరు [ఈ ట్యుటోరియల్](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/) ఉపయోగించి వాటి గురించి తెలుసుకోవచ్చు. ఇక్కడ [WAGMI](https://wagmi.sh/) అవసరం లేదు ఎందుకంటే మనం బ్లాక్ చైను లేదా వాలెట్‌తో నేరుగా సంభాషించము.

వినియోగదారు ఇంటర్‌ఫేస్‌లో స్పష్టంగా లేని ఏకైక భాగం WASM కనెక్టివిటీ. ఇది ఎలా పనిచేస్తుందో ఇక్కడ ఉంది.

**`vite.config.js`**

ఈ ఫైల్ [Vite కాన్ఫిగరేషన్‌ను](https://vite.dev/config/) కలిగి ఉంది.

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import wasm from "vite-plugin-wasm";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), wasm()],
})
```

మాకు రెండు Vite ప్లగిన్‌లు అవసరం: [react](https://www.npmjs.com/package/@vitejs/plugin-react) మరియు [wasm](https://github.com/Menci/vite-plugin-wasm#readme).

**`App.jsx`**

ఈ ఫైల్ అప్లికేషన్ యొక్క ప్రధాన భాగం. ఇది రెండు భాగాలను కలిగి ఉన్న ఒక కంటైనర్: `Alice` మరియు `Bill`, ఆ వినియోగదారుల కోసం వినియోగదారు ఇంటర్‌ఫేస్‌లు. WASM కోసం సంబంధించిన భాగం ప్రారంభ సంకేత భాష.

```jsx
import init from './rust-wasm/pkg/rust_wasm.js'
```

మనం [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/)ని ఉపయోగించినప్పుడు, అది ఇక్కడ మనం ఉపయోగించే రెండు ఫైళ్ళను సృష్టిస్తుంది: అసలు సంకేత భాషతో ఒక wasm ఫైల్ (ఇక్కడ, `src/rust-wasm/pkg/rust_wasm_bg.wasm`) మరియు దానిని ఉపయోగించడానికి నిర్వచనాలతో ఒక జావాస్క్రిప్ట్ ఫైల్ (ఇక్కడ, `src/rust_wasm/pkg/rust_wasm.js`). ఆ జావాస్క్రిప్ట్ ఫైల్ యొక్క డిఫాల్ట్ ఎగుమతి WASMను ప్రారంభించడానికి అమలు చేయవలసిన సంకేత భాష.

```jsx
function App() {
    .
    .
    .
  useEffect(() => {
    const loadWasm = async () => {
      try {
        await init();
        setWasmReady(true)
      } catch (err) {
        console.error('Error loading wasm:', err)
        alert("Wasm error: " + err)
      }
    }

    loadWasm()
    }, []
  )
```

[`useEffect` హుక్](https://react.dev/reference/react/useEffect) మీకు స్టేట్ వేరియబుల్స్ మారినప్పుడు అమలు చేయబడే ఫంక్షన్‌ను నిర్దేశించడానికి అనుమతిస్తుంది. ఇక్కడ, స్టేట్ వేరియబుల్స్ జాబితా ఖాళీగా ఉంది (`[]`), కాబట్టి ఈ ఫంక్షన్ పేజీ లోడ్ అయినప్పుడు ఒకసారి మాత్రమే అమలు చేయబడుతుంది.

ప్రభావ ఫంక్షన్ వెంటనే తిరిగి రావాలి. అసమకాలిక సంకేత భాషను ఉపయోగించడానికి, ఉదాహరణకు WASM `init` (ఇది `.wasm` ఫైల్‌ను లోడ్ చేయాలి మరియు అందువల్ల సమయం పడుతుంది) మనం అంతర్గత [`async`](https://en.wikipedia.org/wiki/Async/await) ఫంక్షన్‌ను నిర్వచించి, దానిని `await` లేకుండా అమలు చేస్తాము.

**`Bill.jsx`**

ఇది బిల్ కోసం వినియోగదారు ఇంటర్‌ఫేస్. అలీస్ అందించిన స్టెల్త్ మెటా-చిరునామా ఆధారంగా ఒక చిరునామాను సృష్టించడం దీనికి ఒకే ఒక చర్య.

```jsx
import { wasm_generate_stealth_address } from './rust-wasm/pkg/rust_wasm.js'
```

డిఫాల్ట్ ఎగుమతితో పాటు, `wasm-pack` ద్వారా సృష్టించబడిన జావాస్క్రిప్ట్ సంకేత భాష WASM సంకేత భాషలోని ప్రతి ఫంక్షన్ కోసం ఒక ఫంక్షన్‌ను ఎగుమతి చేస్తుంది.

```jsx
            <button onClick={() => {
              setPublicAddress(JSON.parse(wasm_generate_stealth_address(stealthMetaAddress)))
            }}>
```

WASM ఫంక్షన్లను పిలవడానికి, మనం `wasm-pack` ద్వారా సృష్టించబడిన జావాస్క్రిప్ట్ ఫైల్ ద్వారా ఎగుమతి చేయబడిన ఫంక్షన్‌ను పిలిస్తే సరిపోతుంది.

**`Alice.jsx`**

`Alice.jsx`లోని సంకేత భాష సమానమైనది, కానీ అలీస్‌కు రెండు చర్యలు ఉన్నాయి:

- ఒక మెటా-చిరునామాను సృష్టించడం
- బిల్ ప్రచురించిన ఒక చిరునామా కోసం ప్రైవేట్ కీని పొందడం

## ముగింపు {#conclusion}

స్టెల్త్ చిరునామాలు సర్వరోగనివారిణి కాదు; వాటిని [సరిగ్గా ఉపయోగించాలి](#go-wrong). కానీ సరిగ్గా ఉపయోగించినప్పుడు, అవి ఒక పబ్లిక్ బ్లాక్ చైనులో గోప్యతను ప్రారంభించగలవు.

[నా మరిన్ని పనుల కోసం ఇక్కడ చూడండి](https://cryptodocguy.pro/).