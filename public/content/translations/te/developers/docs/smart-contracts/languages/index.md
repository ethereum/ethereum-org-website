---
title: స్మార్ట్ కాంట్రాక్ట్ భాషలు
description: రెండు ప్రధాన స్మార్ట్ కాంట్రాక్ట్ భాషల - సాలిడిటీ మరియు వైపర్ - యొక్క అవలోకనం మరియు పోలిక.
lang: te
---

ఎథేరియం గురించిన ఒక గొప్ప విషయం ఏమిటంటే, స్మార్ట్ కాంట్రాక్టులను సాపేక్షంగా డెవలపర్-స్నేహపూర్వక భాషలను ఉపయోగించి ప్రోగ్రామ్ చేయవచ్చు. మీకు పైథాన్ లేదా ఏదైనా [కర్లీ-బ్రాకెట్ భాష](https://wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages)తో అనుభవం ఉంటే, మీరు పరిచితమైన సింటాక్స్‌తో కూడిన భాషను కనుగొనవచ్చు.

అత్యంత చురుకైన మరియు నిర్వహించబడుతున్న రెండు భాషలు:

- Solidity
- Vyper

రీమిక్స్ IDE సాలిడిటీ మరియు వైపర్ రెండింటిలోనూ కాంట్రాక్టులను సృష్టించడానికి మరియు పరీక్షించడానికి ఒక సమగ్ర అభివృద్ధి వాతావరణాన్ని అందిస్తుంది. కోడింగ్ ప్రారంభించడానికి [ఇన్-బ్రౌజర్ రీమిక్స్ IDEని ప్రయత్నించండి](https://remix.ethereum.org).

మరింత అనుభవం ఉన్న డెవలపర్లు [ఎథేరియం వర్చువల్ మెషీన్](/developers/docs/evm/) కోసం ఒక మధ్యంతర భాష అయిన Yul, లేదా Yul కు పొడిగింపు అయిన Yul+ ను కూడా ఉపయోగించాలనుకోవచ్చు.

మీకు ఆసక్తి ఉండి, ఇంకా భారీ అభివృద్ధిలో ఉన్న కొత్త భాషలను పరీక్షించడానికి సహాయం చేయాలనుకుంటే, ప్రస్తుతం ఇంకా శైశవ దశలో ఉన్న ఒక అభివృద్ధి చెందుతున్న స్మార్ట్ కాంట్రాక్ట్ భాష అయిన Fe తో మీరు ప్రయోగాలు చేయవచ్చు.

## అవసరాలు {#prerequisites}

ప్రోగ్రామింగ్ భాషల, ముఖ్యంగా జావాస్క్రిప్ట్ లేదా పైథాన్ యొక్క మునుపటి జ్ఞానం, స్మార్ట్ కాంట్రాక్ట్ భాషలలోని తేడాలను అర్థం చేసుకోవడంలో మీకు సహాయపడుతుంది. భాషా పోలికలలోకి చాలా లోతుగా వెళ్లే ముందు మీరు స్మార్ట్ కాంట్రాక్టులను ఒక భావనగా అర్థం చేసుకోవాలని కూడా మేము సిఫార్సు చేస్తున్నాము. [స్మార్ట్ కాంట్రాక్టులకు పరిచయం](/developers/docs/smart-contracts/).

## సాలిడిటీ {#solidity}

- స్మార్ట్ కాంట్రాక్టులను అమలు చేయడం కోసం ఆబ్జెక్ట్-ఓరియెంటెడ్, ఉన్నత-స్థాయి భాష.
- C++ ద్వారా అత్యంత గాఢంగా ప్రభావితమైన కర్లీ-బ్రాకెట్ భాష.
- స్టాటిక్‌గా టైప్ చేయబడింది (ఒక వేరియబుల్ రకం కంపైల్ సమయంలో తెలుస్తుంది).
- మద్దతు ఇస్తుంది:
  - ఇన్హెరిటెన్స్ (మీరు ఇతర కాంట్రాక్టులను విస్తరించవచ్చు).
  - లైబ్రరీలు (మీరు పునర్వినియోగ కోడ్‌ను సృష్టించవచ్చు, దానిని మీరు ఇతర ఆబ్జెక్ట్ ఓరియెంటెడ్ ప్రోగ్రామింగ్ భాషలలో ఒక స్టాటిక్ క్లాస్‌లోని స్టాటిక్ ఫంక్షన్ల వలె వివిధ కాంట్రాక్టుల నుండి కాల్ చేయవచ్చు).
  - సంక్లిష్టమైన యూజర్-డిఫైన్డ్ రకాలు.

### ముఖ్యమైన లింకులు {#important-links}

- [డాక్యుమెంటేషన్](https://docs.soliditylang.org/en/latest/)
- [సాలిడిటీ లాంగ్వేజ్ పోర్టల్](https://soliditylang.org/)
- [ఉదాహరణకు సాలిడిటీ](https://docs.soliditylang.org/en/latest/solidity-by-example.html)
- [GitHub](https://github.com/ethereum/solidity/)
- [సాలిడిటీ గిట్టర్ చాట్‌రూమ్](https://gitter.im/ethereum/solidity) [సాలిడిటీ మ్యాట్రిక్స్ చాట్‌రూమ్](https://matrix.to/#/#ethereum_solidity:gitter.im)కి బ్రిడ్జ్ చేయబడింది
- [చీట్ షీట్](https://reference.auditless.com/cheatsheet)
- [సాలిడిటీ బ్లాగ్](https://blog.soliditylang.org/)
- [సాలిడిటీ ట్విట్టర్](https://twitter.com/solidity_lang)

### ఉదాహరణ కాంట్రాక్ట్ {#example-contract}

```solidity
// SPDX-లైసెన్స్-ఐడెంటిఫైయర్: GPL-3.0
pragma solidity >= 0.7.0;

contract Coin {
    // "పబ్లిక్" అనే కీవర్డ్ వేరియబుల్స్‌ను చేస్తుంది
    // ఇతర కాంట్రాక్టుల నుండి యాక్సెస్ చేయగలవు
    address public minter;
    mapping (address => uint) public balances;

    // ఈవెంట్‌లు నిర్దిష్టమైన వాటికి ప్రతిస్పందించడానికి క్లయింట్‌లను అనుమతిస్తాయి
    // మీరు ప్రకటించే కాంట్రాక్ట్ మార్పులు
    event Sent(address from, address to, uint amount);

    // కాంట్రాక్ట్ ఉన్నప్పుడు మాత్రమే కన్స్ట్రక్టర్ కోడ్ అమలు చేయబడుతుంది
    // సృష్టించబడింది
    constructor() {
        minter = msg.sender;
    }

    // కొత్తగా సృష్టించబడిన నాణేల మొత్తాన్ని ఒక చిరునామాకు పంపుతుంది
    // కాంట్రాక్ట్ సృష్టికర్త ద్వారా మాత్రమే పిలువబడుతుంది
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter);
        require(amount < 1e60);
        balances[receiver] += amount;
    }

    // ఉన్న నాణేల మొత్తాన్ని పంపుతుంది
    // ఏ కాలర్ నుండి అయినా ఒక చిరునామాకు
    function send(address receiver, uint amount) public {
        require(amount <= balances[msg.sender], "Insufficient balance.");
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}
```

ఈ ఉదాహరణ సాలిడిటీ కాంట్రాక్ట్ సింటాక్స్ ఎలా ఉంటుందో మీకు ఒక అవగాహన ఇవ్వాలి. ఫంక్షన్లు మరియు వేరియబుల్స్ యొక్క మరింత వివరణాత్మక వర్ణన కోసం, [డాక్స్‌ని చూడండి](https://docs.soliditylang.org/en/latest/contracts.html).

## వైపర్ {#vyper}

- పైథానిక్ ప్రోగ్రామింగ్ భాష
- బలమైన టైపింగ్
- చిన్న మరియు అర్థమయ్యే కంపైలర్ కోడ్
- సమర్థవంతమైన బైట్‌కోడ్ ఉత్పత్తి
- కాంట్రాక్టులను మరింత సురక్షితంగా మరియు ఆడిట్ చేయడానికి సులభతరం చేసే లక్ష్యంతో సాలిడిటీ కంటే ఉద్దేశపూర్వకంగా తక్కువ ఫీచర్లను కలిగి ఉంది. వైపర్ వీటికి మద్దతు ఇవ్వదు:
  - మాడిఫైయర్‌లు
  - ఇన్హెరిటెన్స్
  - ఇన్‌లైన్ అసెంబ్లీ
  - ఫంక్షన్ ఓవర్‌లోడింగ్
  - ఆపరేటర్ ఓవర్‌లోడింగ్
  - రికర్సివ్ కాలింగ్
  - అనంత-నిడివి లూప్‌లు
  - బైనరీ ఫిక్స్‌డ్ పాయింట్లు

మరింత సమాచారం కోసం, [వైపర్ హేతుబద్ధతను చదవండి](https://vyper.readthedocs.io/en/latest/index.html).

### ముఖ్యమైన లింకులు {#important-links-1}

- [డాక్యుమెంటేషన్](https://vyper.readthedocs.io)
- [ఉదాహరణకు వైపర్](https://vyper.readthedocs.io/en/latest/vyper-by-example.html)
- [ఉదాహరణకు మరిన్ని వైపర్](https://vyper-by-example.org/)
- [GitHub](https://github.com/vyperlang/vyper)
- [వైపర్ కమ్యూనిటీ డిస్కార్డ్ చాట్](https://discord.gg/SdvKC79cJk)
- [చీట్ షీట్](https://reference.auditless.com/cheatsheet)
- [వైపర్ కోసం స్మార్ట్ కాంట్రాక్ట్ డెవలప్‌మెంట్ ఫ్రేమ్‌వర్క్‌లు మరియు టూల్స్](/developers/docs/programming-languages/python/)
- [VyperPunk - వైపర్ స్మార్ట్ కాంట్రాక్టులను సురక్షితం చేయడం మరియు హ్యాక్ చేయడం నేర్చుకోండి](https://github.com/SupremacyTeam/VyperPunk)
- [అభివృద్ధి కోసం వైపర్ హబ్](https://github.com/zcor/vyper-dev)
- [వైపర్ గ్రేటెస్ట్ హిట్స్ స్మార్ట్ కాంట్రాక్ట్ ఉదాహరణలు](https://github.com/pynchmeister/vyper-greatest-hits/tree/main/contracts)
- [అద్భుతమైన వైపర్ క్యూరేటెడ్ వనరులు](https://github.com/spadebuilders/awesome-vyper)

### ఉదాహరణ {#example}

```python
# ఓపెన్ వేలం

# వేలం పారామీటర్లు
# లబ్ధిదారుడు అత్యధిక బిడ్డర్ నుండి డబ్బును అందుకుంటారు
beneficiary: public(address)
auctionStart: public(uint256)
auctionEnd: public(uint256)

# వేలం ప్రస్తుత స్థితి
highestBidder: public(address)
highestBid: public(uint256)

# చివరిలో నిజం అని సెట్ చేయబడింది, ఏదైనా మార్పును అనుమతించదు
ended: public(bool)

# వాపసు చేయబడిన బిడ్‌లను ట్రాక్ చేయండి, తద్వారా మేము ఉపసంహరణ నమూనాను అనుసరించవచ్చు
pendingReturns: public(HashMap[address, uint256])

# `_bidding_time` తో ఒక సాధారణ వేలం సృష్టించండి
# సెకన్ల బిడ్డింగ్ సమయం
# లబ్ధిదారుడి చిరునామా `_beneficiary`.
@external
def __init__(_beneficiary: address, _bidding_time: uint256):
    self.beneficiary = _beneficiary
    self.auctionStart = block.timestamp
    self.auctionEnd = self.auctionStart + _bidding_time

# పంపిన విలువతో వేలంలో బిడ్ చేయండి
# ఈ లావాదేవీతో పాటు.
# ఒకవేళ మాత్రమే విలువ వాపసు చేయబడుతుంది
# వేలం గెలవలేదు.
@external
@payable
def bid():
    # బిడ్డింగ్ వ్యవధి ముగిసిందో లేదో తనిఖీ చేయండి.
    assert block.timestamp < self.auctionEnd
    # బిడ్ తగినంత ఎక్కువగా ఉందో లేదో తనిఖీ చేయండి
    assert msg.value > self.highestBid
    # మునుపటి అధిక బిడ్డర్ కోసం వాపసును ట్రాక్ చేయండి
    self.pendingReturns[self.highestBidder] += self.highestBid
    # కొత్త అధిక బిడ్‌ను ట్రాక్ చేయండి
    self.highestBidder = msg.sender
    self.highestBid = msg.value

# గతంలో వాపసు చేయబడిన బిడ్‌ను ఉపసంహరించుకోండి. ఉపసంహరణ నమూనా
# భద్రతా సమస్యను నివారించడానికి ఇక్కడ ఉపయోగించబడింది. వాపసులు నేరుగా ఉంటే
# బిడ్()లో భాగంగా పంపబడితే, ఒక హానికరమైన బిడ్డింగ్ కాంట్రాక్ట్ బ్లాక్ చేయగలదు
# ఆ వాపసులను మరియు తద్వారా కొత్త అధిక బిడ్‌లు రాకుండా నిరోధించవచ్చు.
@external
def withdraw():
    pending_amount: uint256 = self.pendingReturns[msg.sender]
    self.pendingReturns[msg.sender] = 0
    send(msg.sender, pending_amount)

# వేలం ముగించి, అత్యధిక బిడ్‌ను పంపండి
# లబ్ధిదారుడికి.
@external
def endAuction():
    # ఇది ఇంటరాక్ట్ చేసే ఫంక్షన్లను రూపొందించడానికి ఒక మంచి మార్గదర్శకం
    # ఇతర కాంట్రాక్టులతో (అంటే, వారు ఫంక్షన్లను కాల్ చేస్తారు లేదా ఈథర్ పంపుతారు)
    # మూడు దశలుగా:
    # 1. షరతులను తనిఖీ చేయడం
    # 2. చర్యలను నిర్వహించడం (సంభావ్యంగా షరతులను మార్చడం)
    # 3. ఇతర కాంట్రాక్టులతో ఇంటరాక్ట్ అవ్వడం
    # ఈ దశలు గందరగోళానికి గురైతే, ఇతర కాంట్రాక్ట్ కాల్ చేయగలదు
    # ప్రస్తుత కాంట్రాక్ట్‌లోకి తిరిగి వచ్చి స్థితిని సవరించండి లేదా కారణం కావచ్చు
    # ప్రభావాలు (ఈథర్ చెల్లింపు) చాలాసార్లు నిర్వహించబడతాయి.
    # అంతర్గతంగా పిలిచే ఫంక్షన్లు బాహ్యతో ఇంటరాక్షన్‌ను కలిగి ఉంటే
    # కాంట్రాక్టులు, వాటిని కూడా ఇంటరాక్షన్‌గా పరిగణించాలి
    # బాహ్య కాంట్రాక్టులు.

    # 1. షరతులు
    # వేలం ముగింపు సమయం చేరుకుందో లేదో తనిఖీ చేయండి
    assert block.timestamp >= self.auctionEnd
    # ఈ ఫంక్షన్ ఇప్పటికే పిలవబడిందో లేదో తనిఖీ చేయండి
    assert not self.ended

    # 2. ప్రభావాలు
    self.ended = True

    # 3. ఇంటరాక్షన్
    send(self.beneficiary, self.highestBid)
```

ఈ ఉదాహరణ వైపర్ కాంట్రాక్ట్ సింటాక్స్ ఎలా ఉంటుందో మీకు ఒక అవగాహన ఇవ్వాలి. ఫంక్షన్లు మరియు వేరియబుల్స్ యొక్క మరింత వివరణాత్మక వర్ణన కోసం, [డాక్స్‌ని చూడండి](https://vyper.readthedocs.io/en/latest/vyper-by-example.html#simple-open-auction).

## Yul మరియు Yul+ {#yul}

మీరు ఎథేరియంకి కొత్త అయితే మరియు ఇంకా స్మార్ట్ కాంట్రాక్ట్ భాషలతో ఎలాంటి కోడింగ్ చేయకపోతే, సాలిడిటీ లేదా వైపర్‌తో ప్రారంభించమని మేము సిఫార్సు చేస్తున్నాము. మీకు స్మార్ట్ కాంట్రాక్ట్ భద్రతా ఉత్తమ అభ్యాసాలు మరియు EVMతో పని చేసే ప్రత్యేకతలతో పరిచయం ఉన్న తర్వాత మాత్రమే Yul లేదా Yul+ గురించి చూడండి.

**Yul**

- ఎథేరియం కోసం మధ్యంతర భాష.
- [EVM](/developers/docs/evm) మరియు [Ewasm](https://github.com/ewasm), ఒక ఎథేరియం ఫ్లేవర్డ్ వెబ్అసెంబ్లీకి మద్దతు ఇస్తుంది మరియు రెండు ప్లాట్‌ఫారమ్‌లకు ఉపయోగపడే సాధారణ హారంగా రూపొందించబడింది.
- EVM మరియు Ewasm ప్లాట్‌ఫారమ్‌లకు సమానంగా ప్రయోజనం చేకూర్చగల ఉన్నత-స్థాయి ఆప్టిమైజేషన్ దశలకు మంచి లక్ష్యం.

**Yul+**

- Yul కు ఒక తక్కువ-స్థాయి, అత్యంత సమర్థవంతమైన పొడిగింపు.
- ప్రారంభంలో ఒక [ఆప్టిమిస్టిక్ రోలప్](/developers/docs/scaling/optimistic-rollups/) కాంట్రాక్ట్ కోసం రూపొందించబడింది.
- Yul+ ను Yul కు ఒక ప్రయోగాత్మక అప్‌గ్రేడ్ ప్రతిపాదనగా చూడవచ్చు, దీనికి కొత్త ఫీచర్లను జోడించవచ్చు.

### ముఖ్యమైన లింకులు {#important-links-2}

- [Yul డాక్యుమెంటేషన్](https://docs.soliditylang.org/en/latest/yul.html)
- [Yul+ డాక్యుమెంటేషన్](https://github.com/fuellabs/yulp)
- [Yul+ పరిచయ పోస్ట్](https://medium.com/@fuellabs/introducing-yul-a-new-low-level-language-for-ethereum-aa64ce89512f)

### ఉదాహరణ కాంట్రాక్ట్ {#example-contract-2}

కింది సాధారణ ఉదాహరణ పవర్ ఫంక్షన్‌ను అమలు చేస్తుంది. `solc --strict-assembly --bin input.yul` ఉపయోగించి దీనిని కంపైల్ చేయవచ్చు. ఉదాహరణ
input.yul ఫైల్‌లో నిల్వ చేయబడాలి.

```
{
    function power(base, exponent) -> result
    {
        switch exponent
        case 0 { result := 1 }
        case 1 { result := base }
        default
        {
            result := power(mul(base, base), div(exponent, 2))
            if mod(exponent, 2) { result := mul(base, result) }
        }
    }
    let res := power(calldataload(0), calldataload(32))
    mstore(0, res)
    return(0, 32)
}
```

మీకు ఇప్పటికే స్మార్ట్ కాంట్రాక్టులతో మంచి అనుభవం ఉంటే, Yulలో పూర్తి ERC20 అమలును [ఇక్కడ](https://solidity.readthedocs.io/en/latest/yul.html#complete-erc20-example) కనుగొనవచ్చు.

## Fe {#fe}

- ఎథేరియం వర్చువల్ మెషీన్ (EVM) కోసం స్టాటిక్‌గా టైప్ చేయబడిన భాష.
- పైథాన్ మరియు రస్ట్ ద్వారా ప్రేరణ పొందింది.
- ఎథేరియం పర్యావరణ వ్యవస్థకు కొత్తవారైన డెవలపర్‌లకు కూడా నేర్చుకోవడానికి సులభంగా ఉండేలా లక్ష్యంగా పెట్టుకుంది.
- Fe అభివృద్ధి ఇంకా ప్రారంభ దశలోనే ఉంది, ఈ భాష జనవరి 2021లో దాని ఆల్ఫా విడుదలను కలిగి ఉంది.

### ముఖ్యమైన లింకులు {#important-links-3}

- [GitHub](https://github.com/ethereum/fe)
- [Fe ప్రకటన](https://snakecharmers.ethereum.org/fe-a-new-language-for-the-ethereum-ecosystem/)
- [Fe 2021 రోడ్‌మ్యాప్](https://notes.ethereum.org/LVhaTF30SJOpkbG1iVw1jg)
- [Fe డిస్కార్డ్ చాట్](https://discord.com/invite/ywpkAXFjZH)
- [Fe ట్విట్టర్](https://twitter.com/official_fe)

### ఉదాహరణ కాంట్రాక్ట్ {#example-contract-3}

కిందిది Feలో అమలు చేయబడిన ఒక సాధారణ కాంట్రాక్ట్.

```
type BookMsg = bytes[100]

contract GuestBook:
    pub guest_book: map<address, BookMsg>

    event Signed:
        book_msg: BookMsg

    pub def sign(book_msg: BookMsg):
        self.guest_book[msg.sender] = book_msg

        emit Signed(book_msg=book_msg)

    pub def get_msg(addr: address) -> BookMsg:
        return self.guest_book[addr].to_mem()

```

## ఎలా ఎంచుకోవాలి {#how-to-choose}

ఏదైనా ఇతర ప్రోగ్రామింగ్ భాషతో పాటు, ఇది ఎక్కువగా సరైన పనికి సరైన సాధనాన్ని ఎంచుకోవడం మరియు వ్యక్తిగత ప్రాధాన్యతలకు సంబంధించినది.

మీరు ఇంకా ఏ భాషలను ప్రయత్నించకపోతే పరిగణించవలసిన కొన్ని విషయాలు ఇక్కడ ఉన్నాయి:

### సాలిడిటీ గురించి గొప్ప విషయం ఏమిటి? {#solidity-advantages}

- మీరు ఒక ప్రారంభకుడు అయితే, అక్కడ చాలా ట్యుటోరియల్స్ మరియు నేర్చుకునే సాధనాలు ఉన్నాయి. [కోడింగ్ ద్వారా నేర్చుకోండి](/developers/learning-tools/) విభాగంలో దాని గురించి మరింత చూడండి.
- మంచి డెవలపర్ టూలింగ్ అందుబాటులో ఉంది.
- సాలిడిటీకి ఒక పెద్ద డెవలపర్ కమ్యూనిటీ ఉంది, అంటే మీరు మీ ప్రశ్నలకు చాలా త్వరగా సమాధానాలు కనుగొనే అవకాశం ఉంది.

### వైపర్ గురించి గొప్ప విషయం ఏమిటి? {#vyper-advatages}

- స్మార్ట్ కాంట్రాక్టులు రాయాలనుకునే పైథాన్ డెవ్‌లు ప్రారంభించడానికి గొప్ప మార్గం.
- వైపర్‌లో తక్కువ సంఖ్యలో ఫీచర్లు ఉన్నాయి, ఇది ఆలోచనల శీఘ్ర ప్రోటోటైపింగ్ కోసం గొప్పగా చేస్తుంది.
- వైపర్ ఆడిట్ చేయడానికి సులభంగా మరియు గరిష్టంగా మానవ-చదవగలిగేలా ఉండాలని లక్ష్యంగా పెట్టుకుంది.

### Yul మరియు Yul+ గురించి గొప్ప విషయం ఏమిటి? {#yul-advantages}

- సరళమైన మరియు ఫంక్షనల్ తక్కువ-స్థాయి భాష.
- రా EVMకి చాలా దగ్గరగా వెళ్లడానికి అనుమతిస్తుంది, ఇది మీ కాంట్రాక్టుల గ్యాస్ వినియోగాన్ని ఆప్టిమైజ్ చేయడానికి సహాయపడుతుంది.

## భాషా పోలికలు {#language-comparisons}

ప్రాథమిక సింటాక్స్, కాంట్రాక్ట్ జీవనచక్రం, ఇంటర్‌ఫేస్‌లు, ఆపరేటర్లు, డేటా స్ట్రక్చర్లు, ఫంక్షన్లు, కంట్రోల్ ఫ్లో మరియు మరిన్ని పోలికల కోసం ఈ [ఆడిట్‌లెస్ ద్వారా చీట్‌షీట్‌ను](https://reference.auditless.com/cheatsheet/) చూడండి

## మరింత సమాచారం {#further-reading}

- [ఓపెన్‌జెప్పెలిన్ ద్వారా సాలిడిటీ కాంట్రాక్టుల లైబ్రరీ](https://docs.openzeppelin.com/contracts/5.x/)
- [ఉదాహరణకు సాలిడిటీ](https://solidity-by-example.org)
