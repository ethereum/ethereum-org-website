---
title: స్మార్ట్ కాంట్రాక్ట్ భద్రత
description: సురక్షితమైన ఇతీరియము స్మార్ట్ కాంట్రాక్ట్‌లను రూపొందించడానికి మార్గదర్శకాల యొక్క అవలోకనం
lang: te
---

స్మార్ట్ కాంట్రాక్ట్‌లు చాలా సరళంగా ఉంటాయి, మరియు బ్లాక్‌చైన్‌లో అమలు చేయబడిన కోడ్ ఆధారంగా మార్పులేని తర్కాన్ని అమలు చేస్తున్నప్పుడు, పెద్ద మొత్తంలో విలువ మరియు డేటాను నియంత్రించగలవు. ఇది విశ్వసనీయత లేని మరియు వికేంద్రీకృత అప్లికేషన్‌ల యొక్క శక్తివంతమైన పర్యావరణ వ్యవస్థను సృష్టించింది, ఇది లెగసీ సిస్టమ్‌ల కంటే అనేక ప్రయోజనాలను అందిస్తుంది. స్మార్ట్ కాంట్రాక్ట్‌లలోని బలహీనతలను ఉపయోగించుకుని లాభం పొందాలనుకునే దాడి చేసేవారికి కూడా ఇవి అవకాశాలను అందిస్తాయి.

ఇతీరియము వంటి పబ్లిక్ బ్లాక్‌చైన్‌లు, స్మార్ట్ కాంట్రాక్ట్‌లను సురక్షితంగా ఉంచే సమస్యను మరింత క్లిష్టతరం చేస్తాయి. అమలు చేయబడిన కాంట్రాక్ట్ కోడ్‌ను _సాధారణంగా_ భద్రతా లోపాలను సరిచేయడానికి మార్చలేము, అయితే స్మార్ట్ కాంట్రాక్ట్‌ల నుండి దొంగిలించబడిన ఆస్తులను ట్రాక్ చేయడం చాలా కష్టం మరియు మార్పులేని కారణంగా చాలావరకు తిరిగి పొందలేము.

గణాంకాలు మారినప్పటికీ, స్మార్ట్ కాంట్రాక్ట్‌లలోని భద్రతా లోపాల కారణంగా దొంగిలించబడిన లేదా కోల్పోయిన మొత్తం విలువ సులభంగా $1 బిలియన్ కంటే ఎక్కువగా ఉంటుందని అంచనా. [DAO హ్యాక్](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/) (3.6M ETH దొంగిలించబడింది, నేటి ధరలలో $1B కంటే ఎక్కువ విలువ), [ప్యారిటీ మల్టీ-సిగ్ వాలెట్ హ్యాక్](https://www.coindesk.com/markets/2017/07/19/30-million-ether-reported-stolen-due-to-parity-wallet-breach) (హ్యాకర్లకు $30M నష్టం), మరియు [ప్యారిటీ ఫ్రోజెన్ వాలెట్ సమస్య](https://www.theguardian.com/technology/2017/nov/08/cryptocurrency-300m-dollars-stolen-bug-ether) (ETH లో $300M కంటే ఎక్కువ శాశ్వతంగా లాక్ చేయబడింది) వంటి ఉన్నత స్థాయి సంఘటనలు ఇందులో ఉన్నాయి.

పైన పేర్కొన్న సమస్యల కారణంగా, డెవలపర్లు సురక్షితమైన, దృఢమైన, మరియు స్థితిస్థాపకమైన స్మార్ట్ కాంట్రాక్ట్‌లను రూపొందించడంలో కృషి చేయడం అత్యవసరం. స్మార్ట్ కాంట్రాక్ట్ భద్రత అనేది ఒక గంభీరమైన విషయం, మరియు ప్రతి డెవలపర్ దీనిని నేర్చుకోవడం మంచిది. ఈ గైడ్ ఇతీరియము డెవలపర్‌ల కోసం భద్రతా పరిగణనలను చర్చిస్తుంది మరియు స్మార్ట్ కాంట్రాక్ట్ భద్రతను మెరుగుపరచడానికి వనరులను అన్వేషిస్తుంది.

## అవసరాలు {#prerequisites}

భద్రతను పరిష్కరించే ముందు మీరు [స్మార్ట్ కాంట్రాక్ట్ అభివృద్ధి యొక్క ప్రాథమిక అంశాలతో](/developers/docs/smart-contracts/) సుపరిచితులని నిర్ధారించుకోండి.

## సురక్షితమైన ఇతీరియము స్మార్ట్ కాంట్రాక్ట్‌లను రూపొందించడానికి మార్గదర్శకాలు {#smart-contract-security-guidelines}

### 1. సరైన యాక్సెస్ నియంత్రణలను రూపొందించండి {#design-proper-access-controls}

స్మార్ట్ కాంట్రాక్ట్‌లలో, `public` లేదా `external`గా గుర్తించబడిన ఫంక్షన్‌లను ఏదైనా బాహ్య యాజమాన్యంలోని ఖాతాలు (EOAలు) లేదా కాంట్రాక్ట్ ఖాతాలు పిలవవచ్చు. మీ కాంట్రాక్ట్‌తో ఇతరులు సంభాషించాలని మీరు కోరుకుంటే, ఫంక్షన్‌ల కోసం పబ్లిక్ విజిబిలిటీని పేర్కొనడం అవసరం. అయితే, `private`గా గుర్తించబడిన ఫంక్షన్‌లను స్మార్ట్ కాంట్రాక్ట్‌లోని ఫంక్షన్‌లు మాత్రమే పిలవగలవు, బాహ్య ఖాతాలు పిలవలేవు. ప్రతి నెట్‌వర్క్ పార్టిసిపెంట్‌కు కాంట్రాక్ట్ ఫంక్షన్‌లకు యాక్సెస్ ఇవ్వడం సమస్యలను కలిగిస్తుంది, ముఖ్యంగా ఎవరైనా సున్నితమైన కార్యకలాపాలను (ఉదా., కొత్త టోకెన్‌లను ముద్రించడం) నిర్వహించగలిగితే.

స్మార్ట్ కాంట్రాక్ట్ ఫంక్షన్‌ల అనధికార వినియోగాన్ని నివారించడానికి, సురక్షితమైన యాక్సెస్ నియంత్రణలను అమలు చేయడం అవసరం. యాక్సెస్ నియంత్రణ యంత్రాంగాలు స్మార్ట్ కాంట్రాక్ట్‌లోని కొన్ని ఫంక్షన్‌లను ఉపయోగించే సామర్థ్యాన్ని, కాంట్రాక్ట్‌ను నిర్వహించడానికి బాధ్యత వహించే ఖాతాలు వంటి ఆమోదించబడిన సంస్థలకు పరిమితం చేస్తాయి. స్మార్ట్ కాంట్రాక్ట్‌లలో యాక్సెస్ నియంత్రణను అమలు చేయడానికి **ఓనబుల్ ప్యాటర్న్** మరియు **రోల్-బేస్డ్ కంట్రోల్** అనేవి రెండు ఉపయోగకరమైన ప్యాటర్న్‌లు:

#### ఓనబుల్ ప్యాటర్న్ {#ownable-pattern}

ఓనబుల్ ప్యాటర్న్‌లో, కాంట్రాక్ట్-సృష్టి ప్రక్రియలో ఒక చిరునామా కాంట్రాక్ట్ యొక్క “యజమాని”గా సెట్ చేయబడుతుంది. రక్షిత ఫంక్షన్‌లకు `OnlyOwner` మాడిఫైయర్ కేటాయించబడుతుంది, ఇది ఫంక్షన్‌ను అమలు చేయడానికి ముందు కాంట్రాక్ట్ కాల్ చేసే చిరునామా యొక్క గుర్తింపును ప్రామాణీకరించేలా చేస్తుంది. కాంట్రాక్ట్ యజమాని కాకుండా ఇతర చిరునామాల నుండి రక్షిత ఫంక్షన్‌లకు చేసే కాల్‌లు ఎల్లప్పుడూ వెనక్కి వెళ్తాయి, అవాంఛిత యాక్సెస్‌ను నివారిస్తాయి.

#### రోల్-ఆధారిత యాక్సెస్ నియంత్రణ {#role-based-access-control}

ఒక స్మార్ట్ కాంట్రాక్ట్‌లో ఒకే చిరునామాను `Owner`గా నమోదు చేయడం కేంద్రీకరణ ప్రమాదాన్ని పరిచయం చేస్తుంది మరియు సింగిల్ పాయింట్-ఆఫ్-ఫెయిల్యూర్‌ను సూచిస్తుంది. యజమాని ఖాతా కీలు రాజీపడితే, దాడి చేసేవారు యాజమాన్యంలోని కాంట్రాక్ట్‌పై దాడి చేయవచ్చు. అందుకే బహుళ పరిపాలనా ఖాతాలతో రోల్-ఆధారిత యాక్సెస్ నియంత్రణ ప్యాటర్న్‌ను ఉపయోగించడం మంచి ఎంపిక కావచ్చు.

రోల్-ఆధారిత యాక్సెస్ నియంత్రణలో, సున్నితమైన ఫంక్షన్‌లకు యాక్సెస్ విశ్వసనీయ భాగస్వాముల సమితి మధ్య పంపిణీ చేయబడుతుంది. ఉదాహరణకు, ఒక ఖాతా టోకెన్‌లను ముద్రించడానికి బాధ్యత వహించవచ్చు, మరొక ఖాతా అప్‌గ్రేడ్‌లను నిర్వహిస్తుంది లేదా కాంట్రాక్ట్‌ను పాజ్ చేస్తుంది. ఈ విధంగా యాక్సెస్ నియంత్రణను వికేంద్రీకరించడం వైఫల్యానికి దారితీసే ఏకైక కేంద్రాలను తొలగిస్తుంది మరియు వినియోగదారుల కోసం విశ్వసనీయ అంచనాలను తగ్గిస్తుంది.

##### బహుళ-సంతకాల వాలెట్‌లను ఉపయోగించడం

సురక్షితమైన యాక్సెస్ నియంత్రణను అమలు చేయడానికి మరొక విధానం కాంట్రాక్ట్‌ను నిర్వహించడానికి [బహుళ-సంతకాల ఖాతాను](/developers/docs/smart-contracts/#multisig) ఉపయోగించడం. సాధారణ EOA లా కాకుండా, బహుళ-సంతకాల ఖాతాలు బహుళ సంస్థల యాజమాన్యంలో ఉంటాయి మరియు లావాదేవీలను అమలు చేయడానికి కనీస సంఖ్యలో ఖాతాల నుండి సంతకాలు అవసరం—ఉదాహరణకు 5-లో-3.

యాక్సెస్ నియంత్రణ కోసం మల్టీసిగ్‌ను ఉపయోగించడం భద్రత యొక్క అదనపు పొరను పరిచయం చేస్తుంది, ఎందుకంటే టార్గెట్ కాంట్రాక్ట్‌పై చర్యలకు బహుళ పార్టీల నుండి సమ్మతి అవసరం. ఓనబుల్ ప్యాటర్న్‌ను ఉపయోగించడం అవసరమైతే ఇది ప్రత్యేకంగా ఉపయోగపడుతుంది, ఎందుకంటే ఇది ఒక దాడి చేసేవాడు లేదా మోసపూరిత అంతర్గత వ్యక్తి దురుద్దేశపూర్వక ప్రయోజనాల కోసం సున్నితమైన కాంట్రాక్ట్ ఫంక్షన్‌లను తారుమారు చేయడాన్ని కష్టతరం చేస్తుంది.

### 2. కాంట్రాక్ట్ కార్యకలాపాలను రక్షించడానికి require(), assert(), మరియు revert() స్టేట్‌మెంట్‌లను ఉపయోగించండి {#use-require-assert-revert}

చెప్పినట్లుగా, మీ స్మార్ట్ కాంట్రాక్ట్ బ్లాక్‌చైన్‌లో అమలు చేయబడిన తర్వాత ఎవరైనా దానిలోని పబ్లిక్ ఫంక్షన్‌లను పిలవవచ్చు. బాహ్య ఖాతాలు కాంట్రాక్ట్‌తో ఎలా సంభాషిస్తాయో మీరు ముందుగా తెలుసుకోలేరు కాబట్టి, అమలు చేయడానికి ముందు సమస్యాత్మక కార్యకలాపాలకు వ్యతిరేకంగా అంతర్గత భద్రతా చర్యలను అమలు చేయడం ఉత్తమం. నిర్దిష్ట అవసరాలను సంతృప్తిపరచడంలో అమలు విఫలమైతే, మినహాయింపులను ట్రిగ్గర్ చేయడానికి మరియు స్టేట్ మార్పులను వెనక్కి తీసుకోవడానికి `require()`, `assert()`, మరియు `revert()` స్టేట్‌మెంట్‌లను ఉపయోగించడం ద్వారా మీరు స్మార్ట్ కాంట్రాక్ట్‌లలో సరైన ప్రవర్తనను అమలు చేయవచ్చు.

**`require()`**: `require` అనేది ఫంక్షన్‌ల ప్రారంభంలో నిర్వచించబడింది మరియు పిలవబడిన ఫంక్షన్ అమలు చేయబడటానికి ముందుగా నిర్వచించబడిన షరతులు నెరవేరాయని నిర్ధారిస్తుంది. ఒక `require` స్టేట్‌మెంట్‌ను వినియోగదారు ఇన్‌పుట్‌లను ధృవీకరించడానికి, స్టేట్ వేరియబుల్స్‌ను తనిఖీ చేయడానికి, లేదా ఒక ఫంక్షన్‌తో ముందుకు సాగే ముందు కాల్ చేసే ఖాతా యొక్క గుర్తింపును ప్రామాణీకరించడానికి ఉపయోగించవచ్చు.

**`assert()`**: `assert()` అంతర్గత లోపాలను గుర్తించడానికి మరియు మీ కోడ్‌లోని “ఇన్వేరియంట్‌ల” ఉల్లంఘనలను తనిఖీ చేయడానికి ఉపయోగించబడుతుంది. ఒక ఇన్వేరియంట్ అనేది కాంట్రాక్ట్ యొక్క స్టేట్ గురించి ఒక తార్కిక వాదన, ఇది అన్ని ఫంక్షన్ అమలులకు నిజంగా ఉండాలి. ఒక ఉదాహరణ ఇన్వేరియంట్ ఒక టోకెన్ కాంట్రాక్ట్ యొక్క గరిష్ట మొత్తం సరఫరా లేదా బ్యాలెన్స్. `assert()`ని ఉపయోగించడం వలన మీ కాంట్రాక్ట్ ఎప్పుడూ బలహీనమైన స్థితికి చేరదని నిర్ధారిస్తుంది, మరియు అలా జరిగితే, స్టేట్ వేరియబుల్స్‌కు చేసిన అన్ని మార్పులు వెనక్కి తీసుకోబడతాయి.

**`revert()`**: `revert()`ని ఒక if-else స్టేట్‌మెంట్‌లో ఉపయోగించవచ్చు, ఇది అవసరమైన షరతు సంతృప్తి చెందకపోతే మినహాయింపును ట్రిగ్గర్ చేస్తుంది. కింది నమూనా కాంట్రాక్ట్ ఫంక్షన్‌ల అమలును రక్షించడానికి `revert()`ని ఉపయోగిస్తుంది:

```
pragma solidity ^0.8.4;

contract VendingMachine {
    address owner;
    error Unauthorized();
    function buy(uint amount) public payable {
        if (amount > msg.value / 2 ether)
            revert("Not enough Ether provided.");
        // కొనుగోలు చేయండి.
    }
    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}
```

### 3. స్మార్ట్ కాంట్రాక్ట్‌లను పరీక్షించండి మరియు కోడ్ సరిగ్గా ఉందో లేదో ధృవీకరించండి {#test-smart-contracts-and-verify-code-correctness}

[ఇతీరియము వర్చువల్ మషీన్](/developers/docs/evm/)లో నడుస్తున్న కోడ్ యొక్క మార్పులేనితత్వం అంటే స్మార్ట్ కాంట్రాక్ట్‌లు అభివృద్ధి దశలో ఉన్నత స్థాయి నాణ్యత అంచనాను కోరుతాయి. మీ కాంట్రాక్ట్‌ను విస్తృతంగా పరీక్షించడం మరియు ఏదైనా అనూహ్య ఫలితాల కోసం దానిని గమనించడం భద్రతను చాలా మెరుగుపరుస్తుంది మరియు దీర్ఘకాలంలో మీ వినియోగదారులను రక్షిస్తుంది.

సాధారణ పద్ధతి, కాంట్రాక్ట్ వినియోగదారుల నుండి స్వీకరించే అవకాశం ఉన్న మాక్ డేటాను ఉపయోగించి చిన్న యూనిట్ పరీక్షలు వ్రాయడం. [యూనిట్ టెస్టింగ్](/developers/docs/smart-contracts/testing/#unit-testing) కొన్ని ఫంక్షన్‌ల యొక్క కార్యాచరణను పరీక్షించడానికి మరియు స్మార్ట్ కాంట్రాక్ట్ ఆశించిన విధంగా పనిచేస్తుందని నిర్ధారించుకోవడానికి మంచిది.

దురదృష్టవశాత్తు, ఒంటరిగా ఉపయోగించినప్పుడు స్మార్ట్ కాంట్రాక్ట్ భద్రతను మెరుగుపరచడంలో యూనిట్ టెస్టింగ్ కనీస ప్రభావవంతంగా ఉంటుంది. ఒక యూనిట్ పరీక్ష మాక్ డేటా కోసం ఒక ఫంక్షన్ సరిగ్గా అమలు అవుతుందని నిరూపించవచ్చు, కానీ యూనిట్ పరీక్షలు వ్రాయబడిన పరీక్షల వలె మాత్రమే ప్రభావవంతంగా ఉంటాయి. ఇది మీ స్మార్ట్ కాంట్రాక్ట్ భద్రతను దెబ్బతీసే తప్పిపోయిన ఎడ్జ్ కేసులు మరియు బలహీనతలను గుర్తించడాన్ని కష్టతరం చేస్తుంది.

మెరుగైన విధానం యూనిట్ టెస్టింగ్‌ను [స్టాటిక్ మరియు డైనమిక్ ఎనాలిసిస్](/developers/docs/smart-contracts/testing/#static-dynamic-analysis) ఉపయోగించి నిర్వహించే ప్రాపర్టీ-బేస్డ్ టెస్టింగ్‌తో కలపడం. స్టాటిక్ ఎనాలిసిస్, చేరుకోగల ప్రోగ్రామ్ స్టేట్‌లు మరియు ఎగ్జిక్యూషన్ మార్గాలను విశ్లేషించడానికి [కంట్రోల్ ఫ్లో గ్రాఫ్‌లు](https://en.wikipedia.org/wiki/Control-flow_graph) మరియు [అబ్‌స్ట్రాక్ట్ సింటాక్స్ ట్రీలు](https://deepsource.io/glossary/ast/) వంటి తక్కువ-స్థాయి ప్రాతినిధ్యాలపై ఆధారపడుతుంది. ఇంతలో, [స్మార్ట్ కాంట్రాక్ట్ ఫజింగ్](https://www.cyfrin.io/blog/smart-contract-fuzzing-and-invariants-testing-foundry) వంటి డైనమిక్ విశ్లేషణ పద్ధతులు, భద్రతా లక్షణాలను ఉల్లంఘించే కార్యకలాపాలను గుర్తించడానికి యాదృచ్ఛిక ఇన్‌పుట్ విలువలతో కాంట్రాక్ట్ కోడ్‌ను అమలు చేస్తాయి.

[ఫార్మల్ వెరిఫికేషన్](/developers/docs/smart-contracts/formal-verification) అనేది స్మార్ట్ కాంట్రాక్ట్‌లలో భద్రతా లక్షణాలను ధృవీకరించడానికి మరొక పద్ధతి. సాధారణ టెస్టింగ్ లా కాకుండా, ఫార్మల్ వెరిఫికేషన్ ఒక స్మార్ట్ కాంట్రాక్ట్‌లో లోపాలు లేవని నిశ్చయంగా నిరూపించగలదు. ఇది కావలసిన భద్రతా లక్షణాలను సంగ్రహించే ఒక ఫార్మల్ స్పెసిఫికేషన్‌ను సృష్టించడం మరియు కాంట్రాక్ట్‌ల యొక్క ఫార్మల్ మోడల్ ఈ స్పెసిఫికేషన్‌కు కట్టుబడి ఉందని నిరూపించడం ద్వారా సాధించబడుతుంది.

### 4. మీ కోడ్ యొక్క స్వతంత్ర సమీక్ష కోసం అడగండి {#get-independent-code-reviews}

మీ కాంట్రాక్ట్‌ను పరీక్షించిన తర్వాత, ఏవైనా భద్రతా సమస్యల కోసం సోర్స్ కోడ్‌ను తనిఖీ చేయమని ఇతరులను అడగడం మంచిది. టెస్టింగ్ ఒక స్మార్ట్ కాంట్రాక్ట్‌లోని ప్రతి లోపాన్ని వెలికితీయదు, కానీ స్వతంత్ర సమీక్ష పొందడం బలహీనతలను గుర్తించే అవకాశాన్ని పెంచుతుంది.

#### ఆడిట్లు {#audits}

ఒక స్మార్ట్ కాంట్రాక్ట్ ఆడిట్‌ను ప్రారంభించడం అనేది స్వతంత్ర కోడ్ సమీక్షను నిర్వహించడానికి ఒక మార్గం. ఆడిటర్లు స్మార్ట్ కాంట్రాక్ట్‌లు సురక్షితంగా ఉన్నాయని మరియు నాణ్యత లోపాలు మరియు డిజైన్ లోపాల నుండి విముక్తంగా ఉన్నాయని నిర్ధారించడంలో ముఖ్యమైన పాత్ర పోషిస్తారు.

అయినప్పటికీ, మీరు ఆడిట్‌లను ఒక సర్వరోగనివారిణిగా పరిగణించకుండా ఉండాలి. స్మార్ట్ కాంట్రాక్ట్ ఆడిట్లు ప్రతి బగ్‌ను పట్టుకోలేవు మరియు చాలావరకు సమీక్షల యొక్క అదనపు రౌండ్‌ను అందించడానికి రూపొందించబడ్డాయి, ఇది ప్రారంభ అభివృద్ధి మరియు టెస్టింగ్ సమయంలో డెవలపర్లు తప్పిపోయిన సమస్యలను గుర్తించడంలో సహాయపడుతుంది. స్మార్ట్ కాంట్రాక్ట్ ఆడిట్ యొక్క ప్రయోజనాన్ని గరిష్టీకరించడానికి, ఆడిటర్‌లతో పనిచేయడానికి ఉత్తమ పద్ధతులను కూడా మీరు అనుసరించాలి, ఉదాహరణకు కోడ్‌ను సరిగ్గా డాక్యుమెంట్ చేయడం మరియు ఇన్‌లైన్ వ్యాఖ్యలను జోడించడం.

- [స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్ చిట్కాలు & ట్రిక్స్](https://twitter.com/tinchoabbate/status/1400170232904400897) - _@tinchoabbate_
- [మీ ఆడిట్ నుండి గరిష్ట ప్రయోజనం పొందండి](https://inference.ag/blog/2023-08-14-tips/) - _Inference_

#### బగ్ బౌంటీలు {#bug-bounties}

బగ్ బౌంటీ ప్రోగ్రామ్‌ను ఏర్పాటు చేయడం బాహ్య కోడ్ సమీక్షలను అమలు చేయడానికి మరొక విధానం. బగ్ బౌంటీ అనేది ఒక అప్లికేషన్‌లో బలహీనతలను కనుగొన్న వ్యక్తులకు (సాధారణంగా వైట్‌హ్యాట్ హ్యాకర్లు) ఇవ్వబడిన ఆర్థిక బహుమతి.

సరిగ్గా ఉపయోగించినప్పుడు, బగ్ బౌంటీలు హ్యాకర్ కమ్యూనిటీ సభ్యులకు మీ కోడ్‌ను క్లిష్టమైన లోపాల కోసం తనిఖీ చేయడానికి ప్రోత్సాహాన్ని ఇస్తాయి. ఒక నిజ జీవిత ఉదాహరణ “అనంతమైన డబ్బు బగ్”, ఇది ఇతీరియము పై నడుస్తున్న [లేయర్ 2](/layer-2/) ప్రోటోకాల్ అయిన [ఆప్టిమిజం](https://www.optimism.io/) పై ఒక దాడి చేసేవాడు అపరిమిత మొత్తంలో ఈథర్‌ను సృష్టించడానికి అనుమతించేది. అదృష్టవశాత్తు, ఒక వైట్‌హ్యాట్ హ్యాకర్ [ఆ లోపాన్ని కనుగొని](https://www.saurik.com/optimism.html) బృందానికి తెలియజేశాడు, [ఈ ప్రక్రియలో పెద్ద చెల్లింపును సంపాదించాడు](https://cryptoslate.com/critical-bug-in-ethereum-l2-optimism-2m-bounty-paid/).

ఒక ఉపయోగకరమైన వ్యూహం, బగ్ బౌంటీ ప్రోగ్రామ్ యొక్క చెల్లింపును వాటాలో ఉన్న నిధుల మొత్తానికి అనులోమానుపాతంలో సెట్ చేయడం. “[స్కేలింగ్ బగ్ బౌంటీ](https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7)”గా వర్ణించబడిన ఈ విధానం, వ్యక్తులకు బలహీనతలను ఉపయోగించుకునే బదులు బాధ్యతాయుతంగా బహిర్గతం చేయడానికి ఆర్థిక ప్రోత్సాహకాలను అందిస్తుంది.

### 5. స్మార్ట్ కాంట్రాక్ట్ అభివృద్ధి సమయంలో ఉత్తమ పద్ధతులను అనుసరించండి {#follow-smart-contract-development-best-practices}

ఆడిట్లు మరియు బగ్ బౌంటీలు ఉన్నంత మాత్రాన, అధిక-నాణ్యత కోడ్ వ్రాయవలసిన మీ బాధ్యత నుండి మీకు మినహాయింపు లభించదు. మంచి స్మార్ట్ కాంట్రాక్ట్ భద్రత సరైన డిజైన్ మరియు అభివృద్ధి ప్రక్రియలను అనుసరించడంతో ప్రారంభమవుతుంది:

- మొత్తం కోడ్‌ను git వంటి వెర్షన్ కంట్రోల్ సిస్టమ్‌లో నిల్వ చేయండి

- అన్ని కోడ్ మార్పులను పుల్ రిక్వెస్ట్‌ల ద్వారా చేయండి

- పుల్ రిక్వెస్ట్‌లకు కనీసం ఒక స్వతంత్ర సమీక్షకుడు ఉండేలా చూసుకోండి—మీరు ఒక ప్రాజెక్ట్‌పై ఒంటరిగా పనిచేస్తుంటే, ఇతర డెవలపర్‌లను కనుగొని కోడ్ సమీక్షలను మార్చుకోవడాన్ని పరిగణించండి

- స్మార్ట్ కాంట్రాక్ట్‌లను పరీక్షించడం, కంపైల్ చేయడం, అమలు చేయడం కోసం [డెవలప్‌మెంట్ ఎన్విరాన్‌మెంట్‌ను](/developers/docs/frameworks/) ఉపయోగించండి

- మీ కోడ్‌ను [సైఫ్రిన్ అడెరిన్](https://github.com/Cyfrin/aderyn), మిథ్రిల్ మరియు స్లిథర్ వంటి ప్రాథమిక కోడ్ విశ్లేషణ సాధనాల ద్వారా అమలు చేయండి. ఆదర్శంగా, మీరు ప్రతి పుల్ రిక్వెస్ట్ విలీనం చేయబడటానికి ముందు దీనిని చేయాలి మరియు అవుట్‌పుట్‌లోని తేడాలను పోల్చాలి

- మీ కోడ్ లోపాలు లేకుండా కంపైల్ అవుతుందని మరియు Solidity కంపైలర్ ఎలాంటి హెచ్చరికలను విడుదల చేయదని నిర్ధారించుకోండి

- మీ కోడ్‌ను సరిగ్గా డాక్యుమెంట్ చేయండి ([NatSpec](https://solidity.readthedocs.io/en/develop/natspec-format.html) ఉపయోగించి) మరియు కాంట్రాక్ట్ ఆర్కిటెక్చర్ గురించిన వివరాలను సులభంగా అర్థమయ్యే భాషలో వివరించండి. ఇది ఇతరులు మీ కోడ్‌ను ఆడిట్ చేయడానికి మరియు సమీక్షించడానికి సులభతరం చేస్తుంది.

### 6. దృఢమైన విపత్తు పునరుద్ధరణ ప్రణాళికలను అమలు చేయండి {#implement-disaster-recovery-plans}

సురక్షితమైన యాక్సెస్ నియంత్రణలను రూపొందించడం, ఫంక్షన్ మాడిఫైయర్‌లను అమలు చేయడం మరియు ఇతర సూచనలు స్మార్ట్ కాంట్రాక్ట్ భద్రతను మెరుగుపరచగలవు, కానీ అవి హానికరమైన దోపిడీల అవకాశాన్ని తోసిపుచ్చలేవు. సురక్షితమైన స్మార్ట్ కాంట్రాక్ట్‌లను నిర్మించడానికి “వైఫల్యానికి సిద్ధపడటం” మరియు దాడులకు సమర్థవంతంగా ప్రతిస్పందించడానికి ఒక ఫాల్‌బ్యాక్ ప్రణాళికను కలిగి ఉండటం అవసరం. సరైన విపత్తు పునరుద్ధరణ ప్రణాళిక కింది భాగాలలో కొన్నింటిని లేదా అన్నింటినీ కలిగి ఉంటుంది:

#### కాంట్రాక్ట్ అప్‌గ్రేడ్‌లు {#contract-upgrades}

ఇతీరియము స్మార్ట్ కాంట్రాక్ట్‌లు డిఫాల్ట్‌గా మార్పులేనివి అయినప్పటికీ, అప్‌గ్రేడ్ ప్యాటర్న్‌లను ఉపయోగించడం ద్వారా కొంతవరకు మార్పుచేర్పులను సాధించడం సాధ్యమవుతుంది. ఒక క్లిష్టమైన లోపం మీ పాత కాంట్రాక్ట్‌ను నిరుపయోగంగా మార్చినప్పుడు మరియు కొత్త లాజిక్‌ను అమలు చేయడం అత్యంత ఆచరణీయమైన ఎంపిక అయిన సందర్భాలలో కాంట్రాక్ట్‌లను అప్‌గ్రేడ్ చేయడం అవసరం.

కాంట్రాక్ట్ అప్‌గ్రేడ్ యంత్రాంగాలు విభిన్నంగా పనిచేస్తాయి, కానీ స్మార్ట్ కాంట్రాక్ట్‌లను అప్‌గ్రేడ్ చేయడానికి “ప్రాక్సీ ప్యాటర్న్” అనేది మరింత ప్రజాదరణ పొందిన విధానాలలో ఒకటి. [ప్రాక్సీ ప్యాటర్న్‌లు](https://www.cyfrin.io/blog/upgradeable-proxy-smart-contract-pattern) ఒక అప్లికేషన్ యొక్క స్టేట్ మరియు లాజిక్‌ను _రెండు_ కాంట్రాక్ట్‌ల మధ్య విభజిస్తాయి. మొదటి కాంట్రాక్ట్ (ఒక ‘ప్రాక్సీ కాంట్రాక్ట్’ అని పిలుస్తారు) స్టేట్ వేరియబుల్స్‌ను (ఉదా., వినియోగదారు బ్యాలెన్స్‌లు) నిల్వ చేస్తుంది, అయితే రెండవ కాంట్రాక్ట్ (ఒక ‘లాజిక్ కాంట్రాక్ట్’ అని పిలుస్తారు) కాంట్రాక్ట్ ఫంక్షన్‌లను అమలు చేయడానికి కోడ్‌ను కలిగి ఉంటుంది.

ఖాతాలు ప్రాక్సీ కాంట్రాక్ట్‌తో సంభాషిస్తాయి, ఇది [`delegatecall()`](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries) తక్కువ-స్థాయి కాల్‌ను ఉపయోగించి అన్ని ఫంక్షన్ కాల్‌లను లాజిక్ కాంట్రాక్ట్‌కు పంపుతుంది. సాధారణ మెసేజ్ కాల్ లా కాకుండా, `delegatecall()` లాజిక్ కాంట్రాక్ట్ చిరునామాలో నడుస్తున్న కోడ్ కాలింగ్ కాంట్రాక్ట్ సందర్భంలో అమలు చేయబడుతుందని నిర్ధారిస్తుంది. అంటే లాజిక్ కాంట్రాక్ట్ ఎల్లప్పుడూ ప్రాక్సీ స్టోరేజ్‌కు (దాని స్వంత స్టోరేజ్‌కు బదులుగా) వ్రాస్తుంది మరియు `msg.sender` మరియు `msg.value` యొక్క అసలు విలువలు భద్రపరచబడతాయి.

లాజిక్ కాంట్రాక్ట్‌కు కాల్‌లను డెలిగేట్ చేయడానికి ప్రాక్సీ కాంట్రాక్ట్ యొక్క స్టోరేజ్‌లో దాని చిరునామాను నిల్వ చేయడం అవసరం. అందువల్ల, కాంట్రాక్ట్ యొక్క లాజిక్‌ను అప్‌గ్రేడ్ చేయడం అనేది మరొక లాజిక్ కాంట్రాక్ట్‌ను అమలు చేసి, కొత్త చిరునామాను ప్రాక్సీ కాంట్రాక్ట్‌లో నిల్వ చేయడం మాత్రమే. ప్రాక్సీ కాంట్రాక్ట్‌కు తదుపరి కాల్‌లు స్వయంచాలకంగా కొత్త లాజిక్ కాంట్రాక్ట్‌కు మళ్ళించబడతాయి కాబట్టి, మీరు వాస్తవానికి కోడ్‌ను మార్చకుండానే కాంట్రాక్ట్‌ను “అప్‌గ్రేడ్” చేసినట్లు అవుతుంది.

[కాంట్రాక్ట్‌లను అప్‌గ్రేడ్ చేయడం గురించి మరింత](/developers/docs/smart-contracts/upgrading/).

#### అత్యవసర నిలుపుదలలు {#emergency-stops}

చెప్పినట్లుగా, విస్తృతమైన ఆడిటింగ్ మరియు టెస్టింగ్ ఒక స్మార్ట్ కాంట్రాక్ట్‌లోని అన్ని బగ్‌లను కనుగొనలేవు. అమలు తర్వాత మీ కోడ్‌లో ఒక బలహీనత కనిపిస్తే, కాంట్రాక్ట్ చిరునామాలో నడుస్తున్న కోడ్‌ను మీరు మార్చలేరు కాబట్టి దానిని ప్యాచ్ చేయడం అసాధ్యం. అలాగే, అప్‌గ్రేడ్ యంత్రాంగాలు (ఉదా., ప్రాక్సీ ప్యాటర్న్‌లు) అమలు చేయడానికి సమయం పట్టవచ్చు (వాటికి తరచుగా వివిధ పార్టీల నుండి ఆమోదం అవసరం), ఇది దాడి చేసేవారికి మరింత నష్టం కలిగించడానికి ఎక్కువ సమయం ఇస్తుంది.

అణు ఎంపిక అనేది ఒక “అత్యవసర నిలుపుదల” ఫంక్షన్‌ను అమలు చేయడం, ఇది ఒక కాంట్రాక్ట్‌లోని బలహీనమైన ఫంక్షన్‌లకు కాల్‌లను బ్లాక్ చేస్తుంది. అత్యవసర నిలుపుదలలు సాధారణంగా కింది భాగాలను కలిగి ఉంటాయి:

1. స్మార్ట్ కాంట్రాక్ట్ నిలిపివేయబడిన స్థితిలో ఉందో లేదో సూచించే ఒక గ్లోబల్ బూలియన్ వేరియబుల్. ఈ వేరియబుల్ కాంట్రాక్ట్‌ను సెటప్ చేసేటప్పుడు `false`గా సెట్ చేయబడుతుంది, కానీ కాంట్రాక్ట్ నిలిపివేయబడిన తర్వాత `true`కు తిరిగి వస్తుంది.

2. వాటి అమలులో బూలియన్ వేరియబుల్‌ను సూచించే ఫంక్షన్‌లు. అటువంటి ఫంక్షన్‌లు స్మార్ట్ కాంట్రాక్ట్ నిలిపివేయబడనప్పుడు యాక్సెస్ చేయబడతాయి మరియు అత్యవసర నిలుపుదల ఫీచర్ ట్రిగ్గర్ చేయబడినప్పుడు యాక్సెస్ చేయలేకుండా పోతాయి.

3. అత్యవసర నిలుపుదల ఫంక్షన్‌కు యాక్సెస్ ఉన్న ఒక సంస్థ, ఇది బూలియన్ వేరియబుల్‌ను `true`గా సెట్ చేస్తుంది. హానికరమైన చర్యలను నివారించడానికి, ఈ ఫంక్షన్‌కు కాల్‌లను విశ్వసనీయ చిరునామాకు (ఉదా., కాంట్రాక్ట్ యజమాని) పరిమితం చేయవచ్చు.

కాంట్రాక్ట్ అత్యవసర నిలుపుదలను సక్రియం చేసిన తర్వాత, కొన్ని ఫంక్షన్‌లను పిలవలేము. గ్లోబల్ వేరియబుల్‌ను సూచించే ఒక మాడిఫైయర్‌లో ఎంచుకున్న ఫంక్షన్‌లను చుట్టడం ద్వారా ఇది సాధించబడుతుంది. కింద ఈ ప్యాటర్న్ యొక్క అమలును కాంట్రాక్ట్‌లలో వివరించే [ఒక ఉదాహరణ](https://github.com/fravoll/solidity-patterns/blob/master/EmergencyStop/EmergencyStop.sol) ఉంది:

```solidity
// ఈ కోడ్ వృత్తిపరంగా ఆడిట్ చేయబడలేదు మరియు భద్రత లేదా ఖచ్చితత్వం గురించి ఎటువంటి వాగ్దానాలు చేయదు. మీ స్వంత పూచీతో ఉపయోగించండి.

contract EmergencyStop {

    bool isStopped = false;

    modifier stoppedInEmergency {
        require(!isStopped);
        _;
    }

    modifier onlyWhenStopped {
        require(isStopped);
        _;
    }

    modifier onlyAuthorized {
        // ఇక్కడ msg.sender అధికారం కోసం తనిఖీ చేయండి
        _;
    }

    function stopContract() public onlyAuthorized {
        isStopped = true;
    }

    function resumeContract() public onlyAuthorized {
        isStopped = false;
    }

    function deposit() public payable stoppedInEmergency {
        // డిపాజిట్ లాజిక్ ఇక్కడ జరుగుతోంది
    }

    function emergencyWithdraw() public onlyWhenStopped {
        // అత్యవసర ఉపసంహరణ ఇక్కడ జరుగుతోంది
    }
}
```

ఈ ఉదాహరణ అత్యవసర నిలుపుదలల యొక్క ప్రాథమిక లక్షణాలను చూపుతుంది:

- `isStopped` అనేది ఒక బూలియన్, ఇది ప్రారంభంలో `false`గా మరియు కాంట్రాక్ట్ అత్యవసర మోడ్‌లోకి ప్రవేశించినప్పుడు `true`గా మూల్యాంకనం చేస్తుంది.

- ఫంక్షన్ మాడిఫైయర్‌లు `onlyWhenStopped` మరియు `stoppedInEmergency` `isStopped` వేరియబుల్‌ను తనిఖీ చేస్తాయి. `stoppedInEmergency` అనేది కాంట్రాక్ట్ బలహీనంగా ఉన్నప్పుడు యాక్సెస్ చేయలేని ఫంక్షన్‌లను (ఉదా., `deposit()`) నియంత్రించడానికి ఉపయోగించబడుతుంది. ఈ ఫంక్షన్‌లకు చేసే కాల్‌లు కేవలం వెనక్కి వెళ్తాయి.

`onlyWhenStopped` అత్యవసర పరిస్థితుల్లో పిలవగల ఫంక్షన్‌ల కోసం ఉపయోగించబడుతుంది (ఉదా., `emergencyWithdraw()`). అటువంటి ఫంక్షన్‌లు పరిస్థితిని పరిష్కరించడంలో సహాయపడగలవు, అందుకే వాటిని “నిరోధిత ఫంక్షన్‌ల” జాబితా నుండి మినహాయించారు.

అత్యవసర నిలుపుదల కార్యాచరణను ఉపయోగించడం మీ స్మార్ట్ కాంట్రాక్ట్‌లోని తీవ్రమైన బలహీనతలతో వ్యవహరించడానికి ఒక సమర్థవంతమైన తాత్కాలిక పరిష్కారాన్ని అందిస్తుంది. అయితే, డెవలపర్లు స్వార్థ ప్రయోజనాల కోసం దానిని సక్రియం చేయరని వినియోగదారులు విశ్వసించాల్సిన అవసరాన్ని ఇది పెంచుతుంది. ఈ దిశగా, ఆన్‌చైన్ ఓటింగ్ మెకానిజం, టైమ్‌లాక్ లేదా మల్టీసిగ్ వాలెట్ నుండి ఆమోదానికి లోబడి అత్యవసర నిలుపుదల నియంత్రణను వికేంద్రీకరించడం సాధ్యమయ్యే పరిష్కారాలు.

#### ఈవెంట్ పర్యవేక్షణ {#event-monitoring}

[ఈవెంట్‌లు](https://docs.soliditylang.org/en/v0.8.15/contracts.html#events) స్మార్ట్ కాంట్రాక్ట్ ఫంక్షన్‌లకు కాల్‌లను ట్రాక్ చేయడానికి మరియు స్టేట్ వేరియబుల్స్‌లోని మార్పులను పర్యవేక్షించడానికి మిమ్మల్ని అనుమతిస్తాయి. ఏదైనా పార్టీ భద్రతా-క్లిష్టమైన చర్యను (ఉదా., నిధులను ఉపసంహరించుకోవడం) తీసుకున్నప్పుడల్లా ఒక ఈవెంట్‌ను విడుదల చేయడానికి మీ స్మార్ట్ కాంట్రాక్ట్‌ను ప్రోగ్రామ్ చేయడం ఉత్తమం.

ఈవెంట్‌లను లాగింగ్ చేయడం మరియు వాటిని ఆఫ్‌చైన్‌లో పర్యవేక్షించడం కాంట్రాక్ట్ కార్యకలాపాలపై అంతర్దృష్టులను అందిస్తుంది మరియు హానికరమైన చర్యలను వేగంగా కనుగొనడంలో సహాయపడుతుంది. అంటే మీ బృందం హ్యాక్‌లకు వేగంగా ప్రతిస్పందించగలదు మరియు ఫంక్షన్‌లను పాజ్ చేయడం లేదా అప్‌గ్రేడ్ చేయడం వంటి వినియోగదారులపై ప్రభావాన్ని తగ్గించడానికి చర్యలు తీసుకోగలదు.

మీరు మీ కాంట్రాక్ట్‌లతో ఎవరైనా సంభాషించినప్పుడల్లా స్వయంచాలకంగా హెచ్చరికలను ఫార్వార్డ్ చేసే ఆఫ్-ది-షెల్ఫ్ పర్యవేక్షణ సాధనాన్ని కూడా ఎంచుకోవచ్చు. ఈ సాధనాలు లావాదేవీల పరిమాణం, ఫంక్షన్ కాల్‌ల ఫ్రీక్వెన్సీ లేదా పాల్గొన్న నిర్దిష్ట ఫంక్షన్‌లు వంటి విభిన్న ట్రిగ్గర్‌ల ఆధారంగా అనుకూల హెచ్చరికలను సృష్టించడానికి మిమ్మల్ని అనుమతిస్తాయి. ఉదాహరణకు, ఒకే లావాదేవీలో ఉపసంహరించుకున్న మొత్తం ఒక నిర్దిష్ట పరిమితిని దాటినప్పుడు వచ్చే హెచ్చరికను మీరు ప్రోగ్రామ్ చేయవచ్చు.

### 7. సురక్షితమైన పాలన వ్యవస్థలను రూపొందించండి {#design-secure-governance-systems}

మీరు కోర్ స్మార్ట్ కాంట్రాక్ట్‌ల నియంత్రణను కమ్యూనిటీ సభ్యులకు అప్పగించడం ద్వారా మీ అప్లికేషన్‌ను వికేంద్రీకరించాలనుకోవచ్చు. ఈ సందర్భంలో, స్మార్ట్ కాంట్రాక్ట్ సిస్టమ్‌లో ఒక పాలన మాడ్యూల్ ఉంటుంది—ఇది ఆన్‌చైన్ పాలన వ్యవస్థ ద్వారా పరిపాలనా చర్యలను ఆమోదించడానికి కమ్యూనిటీ సభ్యులను అనుమతించే ఒక యంత్రాంగం. ఉదాహరణకు, ఒక ప్రాక్సీ కాంట్రాక్ట్‌ను కొత్త అమలుకు అప్‌గ్రేడ్ చేయాలనే ప్రతిపాదనపై టోకెన్-హోల్డర్‌లు ఓటు వేయవచ్చు.

వికేంద్రీకృత పాలన ప్రయోజనకరంగా ఉంటుంది, ముఖ్యంగా ఇది డెవలపర్లు మరియు తుది-వినియోగదారుల ప్రయోజనాలను ఒకే రేఖపైకి తెస్తుంది. అయినప్పటికీ, స్మార్ట్ కాంట్రాక్ట్ పాలన యంత్రాంగాలు తప్పుగా అమలు చేయబడితే కొత్త ప్రమాదాలను పరిచయం చేయవచ్చు. ఒక సంభావ్య దృశ్యం ఏమిటంటే, ఒక దాడి చేసేవాడు [ఫ్లాష్ లోన్](/defi/#flash-loans) తీసుకోవడం ద్వారా అపారమైన ఓటింగ్ శక్తిని (నిర్వహించిన టోకెన్ల సంఖ్యలో కొలుస్తారు) సంపాదించి, ఒక హానికరమైన ప్రతిపాదనను ముందుకు తెస్తాడు.

ఆన్‌చైన్ పాలనకు సంబంధించిన సమస్యలను నివారించడానికి ఒక మార్గం [టైమ్‌లాక్‌ను ఉపయోగించడం](https://blog.openzeppelin.com/protect-your-users-with-smart-contract-timelocks/). ఒక టైమ్‌లాక్ ఒక స్మార్ట్ కాంట్రాక్ట్‌ను నిర్దిష్ట సమయం గడిచే వరకు కొన్ని చర్యలను అమలు చేయకుండా నిరోధిస్తుంది. ఇతర వ్యూహాలలో ప్రతి టోకెన్‌కు అది ఎంతకాలం లాక్ చేయబడి ఉందో దాని ఆధారంగా “ఓటింగ్ వెయిట్” కేటాయించడం, లేదా ప్రస్తుత బ్లాక్‌కు బదులుగా చారిత్రక కాలంలో (ఉదాహరణకు, గతంలో 2-3 బ్లాక్‌లు) ఒక చిరునామా యొక్క ఓటింగ్ శక్తిని కొలవడం ఉన్నాయి. రెండు పద్ధతులు ఆన్‌చైన్ ఓట్లను ప్రభావితం చేయడానికి వేగంగా ఓటింగ్ శక్తిని కూడగట్టే అవకాశాన్ని తగ్గిస్తాయి.

షేర్ చేయబడిన లింక్‌లలో [సురక్షితమైన పాలన వ్యవస్థలను రూపొందించడం](https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/), [DAOలలో విభిన్న ఓటింగ్ యంత్రాంగాలు](https://hackernoon.com/governance-is-the-holy-grail-for-daos), మరియు [DeFiని ఉపయోగించుకునే సాధారణ DAO దాడి వెక్టర్‌లు](https://dacian.me/dao-governance-defi-attacks) గురించి మరింత సమాచారం.

### 8. కోడ్‌లో సంక్లిష్టతను కనిష్ట స్థాయికి తగ్గించండి {#reduce-code-complexity}

సాంప్రదాయ సాఫ్ట్‌వేర్ డెవలపర్‌లకు KISS (“keep it simple, stupid”) సూత్రం గురించి తెలుసు, ఇది సాఫ్ట్‌వేర్ డిజైన్‌లో అనవసరమైన సంక్లిష్టతను ప్రవేశపెట్టవద్దని సలహా ఇస్తుంది. “సంక్లిష్ట వ్యవస్థలు సంక్లిష్ట మార్గాల్లో విఫలమవుతాయి” మరియు ఖరీదైన లోపాలకు ఎక్కువ అవకాశం ఉందని దీర్ఘకాలంగా ఉన్న ఆలోచనను ఇది అనుసరిస్తుంది.

స్మార్ట్ కాంట్రాక్ట్‌లు వ్రాసేటప్పుడు విషయాలను సరళంగా ఉంచడం చాలా ముఖ్యం, ఎందుకంటే స్మార్ట్ కాంట్రాక్ట్‌లు పెద్ద మొత్తంలో విలువను నియంత్రించే అవకాశం ఉంది. స్మార్ట్ కాంట్రాక్ట్‌లు వ్రాసేటప్పుడు సరళతను సాధించడానికి ఒక చిట్కా, సాధ్యమైన చోట, [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/) వంటి ఇప్పటికే ఉన్న లైబ్రరీలను తిరిగి ఉపయోగించడం. ఈ లైబ్రరీలు డెవలపర్‌లచే విస్తృతంగా ఆడిట్ చేయబడి మరియు పరీక్షించబడినందున, వాటిని ఉపయోగించడం కొత్త కార్యాచరణను మొదటి నుండి వ్రాయడం ద్వారా బగ్‌లను ప్రవేశపెట్టే అవకాశాలను తగ్గిస్తుంది.

మరొక సాధారణ సలహా ఏమిటంటే, చిన్న ఫంక్షన్‌లను వ్రాయడం మరియు బహుళ కాంట్రాక్ట్‌ల మధ్య వ్యాపార తర్కాన్ని విభజించడం ద్వారా కాంట్రాక్ట్‌లను మాడ్యులర్‌గా ఉంచడం. సరళమైన కోడ్ వ్రాయడం స్మార్ట్ కాంట్రాక్ట్‌లో దాడి ఉపరితలాన్ని తగ్గించడమే కాకుండా, మొత్తం సిస్టమ్ యొక్క ఖచ్చితత్వం గురించి తర్కించడం మరియు సాధ్యమయ్యే డిజైన్ లోపాలను ముందుగానే గుర్తించడం కూడా సులభతరం చేస్తుంది.

### 9. సాధారణ స్మార్ట్ కాంట్రాక్ట్ బలహీనతలకు వ్యతిరేకంగా రక్షించుకోండి {#mitigate-common-smart-contract-vulnerabilities}

#### పునఃప్రవేశం {#reentrancy}

EVM ఏకకాలీనతను అనుమతించదు, అంటే ఒక మెసేజ్ కాల్‌లో పాల్గొన్న రెండు కాంట్రాక్ట్‌లు ఏకకాలంలో అమలు కాలేవు. ఒక బాహ్య కాల్, కాల్ తిరిగి వచ్చే వరకు కాలింగ్ కాంట్రాక్ట్ యొక్క అమలు మరియు మెమరీని పాజ్ చేస్తుంది, ఆ సమయంలో అమలు సాధారణంగా కొనసాగుతుంది. ఈ ప్రక్రియను అధికారికంగా మరొక కాంట్రాక్ట్‌కు [నియంత్రణ ప్రవాహాన్ని](https://www.computerhope.com/jargon/c/contflow.htm) బదిలీ చేయడం అని వర్ణించవచ్చు.

ఎక్కువగా హానిచేయకపోయినప్పటికీ, విశ్వసనీయత లేని కాంట్రాక్ట్‌లకు నియంత్రణ ప్రవాహాన్ని బదిలీ చేయడం పునఃప్రవేశం వంటి సమస్యలను కలిగిస్తుంది. ఒక హానికరమైన కాంట్రాక్ట్, అసలు ఫంక్షన్ ఆహ్వానం పూర్తికాకముందే ఒక బలహీనమైన కాంట్రాక్ట్‌లోకి తిరిగి పిలిచినప్పుడు పునఃప్రవేశ దాడి జరుగుతుంది. ఈ రకమైన దాడిని ఒక ఉదాహరణతో ఉత్తమంగా వివరించవచ్చు.

ఎవరైనా ఈథర్‌ను డిపాజిట్ చేయడానికి మరియు ఉపసంహరించుకోవడానికి అనుమతించే ఒక సాధారణ స్మార్ట్ కాంట్రాక్ట్‌ను (‘బాధితుడు’) పరిగణించండి:

```solidity
// ఈ కాంట్రాక్ట్ బలహీనంగా ఉంది. ఉత్పత్తిలో ఉపయోగించవద్దు

contract Victim {
    mapping (address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

ఈ కాంట్రాక్ట్ వినియోగదారులు కాంట్రాక్ట్‌లో గతంలో డిపాజిట్ చేసిన ETHని ఉపసంహరించుకోవడానికి `withdraw()` ఫంక్షన్‌ను బహిర్గతం చేస్తుంది. ఉపసంహరణను ప్రాసెస్ చేస్తున్నప్పుడు, కాంట్రాక్ట్ కింది కార్యకలాపాలను నిర్వహిస్తుంది:

1. వినియోగదారుని ETH బ్యాలెన్స్‌ను తనిఖీ చేస్తుంది
2. పిలుస్తున్న చిరునామాకు నిధులను పంపుతుంది
3. వారి బ్యాలెన్స్‌ను 0కి రీసెట్ చేస్తుంది, వినియోగదారు నుండి అదనపు ఉపసంహరణలను నివారిస్తుంది

`విక్టిమ్` కాంట్రాక్ట్‌లోని `withdraw()` ఫంక్షన్ “చెక్స్-ఇంటరాక్షన్స్-ఎఫెక్ట్స్” ప్యాటర్న్‌ను అనుసరిస్తుంది. ఇది అమలుకు అవసరమైన షరతులు సంతృప్తి చెందాయో లేదో _తనిఖీ చేస్తుంది_ (అంటే, వినియోగదారుకు సానుకూల ETH బ్యాలెన్స్ ఉంది) మరియు లావాదేవీ యొక్క _ప్రభావాలను_ వర్తింపజేయడానికి ముందు (అంటే, వినియోగదారు బ్యాలెన్స్‌ను తగ్గించడం), కాలర్ యొక్క చిరునామాకు ETH పంపడం ద్వారా _సంభాషణను_ నిర్వహిస్తుంది.

ఒక బాహ్య యాజమాన్య ఖాతా (EOA) నుండి `withdraw()` పిలువబడితే, ఫంక్షన్ ఆశించిన విధంగా అమలు అవుతుంది: `msg.sender.call.value()` కాలర్‌కు ETH పంపుతుంది. అయితే, `msg.sender` ఒక స్మార్ట్ కాంట్రాక్ట్ ఖాతా అయి `withdraw()`ను పిలిస్తే, `msg.sender.call.value()` ఉపయోగించి నిధులు పంపడం ఆ చిరునామాలో నిల్వ చేయబడిన కోడ్‌ను కూడా అమలు చేయడానికి ట్రిగ్గర్ చేస్తుంది.

కాంట్రాక్ట్ చిరునామాలో అమలు చేయబడిన కోడ్ ఇది అని ఊహించుకోండి:

```solidity
 contract Attacker {
    function beginAttack() external payable {
        Victim(victim_address).deposit.value(1 ether)();
        Victim(victim_address).withdraw();
    }

    function() external payable {
        if (gasleft() > 40000) {
            Victim(victim_address).withdraw();
        }
    }
}
```

ఈ కాంట్రాక్ట్ మూడు పనులు చేయడానికి రూపొందించబడింది:

1. మరొక ఖాతా నుండి డిపాజిట్ అంగీకరించండి (బహుశా దాడి చేసేవారి EOA)
2. విక్టిమ్ కాంట్రాక్ట్‌లో 1 ETH డిపాజిట్ చేయండి
3. స్మార్ట్ కాంట్రాక్ట్‌లో నిల్వ చేసిన 1 ETHని ఉపసంహరించుకోండి

`Attacker` లో మరో ఫంక్షన్ ఉంది, అది ఇన్‌కమింగ్ `msg.sender.call.value` నుండి మిగిలి ఉన్న గ్యాస్ 40,000 కంటే ఎక్కువగా ఉంటే, `Victim` లో `withdraw()` ను మళ్ళీ పిలుస్తుంది, ఇది తప్ప ఇక్కడ తప్పు ఏమీ లేదు. `withdraw` యొక్క మొదటి ఆహ్వానం పూర్తికాకముందే `Attacker`కు `Victim`లోకి తిరిగి ప్రవేశించి, మరిన్ని నిధులను ఉపసంహరించుకునే సామర్థ్యాన్ని ఇది ఇస్తుంది. చక్రం ఇలా కనిపిస్తుంది:

```solidity
- దాడి చేసేవారి EOA 1 ETHతో `Attacker.beginAttack()`ను పిలుస్తుంది
- `Attacker.beginAttack()` `విక్టిమ్`లో 1 ETH డిపాజిట్ చేస్తుంది
- `Attacker` `విక్టిమ్`లో `withdraw() ను పిలుస్తుంది`
- `విక్టిమ్` `Attacker` బ్యాలెన్స్‌ను తనిఖీ చేస్తుంది (1 ETH)
- `విక్టిమ్` 1 ETHని `Attacker`కు పంపుతుంది (ఇది డిఫాల్ట్ ఫంక్షన్‌ను ట్రిగ్గర్ చేస్తుంది)
- `Attacker` మళ్ళీ `Victim.withdraw()`ను పిలుస్తుంది (మొదటి ఉపసంహరణ నుండి `విక్టిమ్` `Attacker` బ్యాలెన్స్‌ను తగ్గించలేదని గమనించండి)
- `విక్టిమ్` `Attacker` బ్యాలెన్స్‌ను తనిఖీ చేస్తుంది (ఇది ఇప్పటికీ 1 ETH ఎందుకంటే ఇది మొదటి కాల్ యొక్క ప్రభావాలను వర్తింపజేయలేదు)
- `విక్టిమ్` 1 ETHని `Attacker`కు పంపుతుంది (ఇది డిఫాల్ట్ ఫంక్షన్‌ను ట్రిగ్గర్ చేస్తుంది మరియు `Attacker`ను `withdraw` ఫంక్షన్‌లోకి తిరిగి ప్రవేశించడానికి అనుమతిస్తుంది)
- `Attacker` గ్యాస్ అయిపోయే వరకు ఈ ప్రక్రియ పునరావృతమవుతుంది, ఆ సమయంలో `msg.sender.call.value` అదనపు ఉపసంహరణలను ట్రిగ్గర్ చేయకుండా తిరిగి వస్తుంది
- `విక్టిమ్` చివరిగా మొదటి లావాదేవీ (మరియు తదుపరివి) ఫలితాలను దాని స్టేట్‌కు వర్తింపజేస్తుంది, కాబట్టి `Attacker` బ్యాలెన్స్ 0కు సెట్ చేయబడుతుంది
```

సారాంశం ఏమిటంటే, ఫంక్షన్ అమలు పూర్తయ్యే వరకు కాలర్ బ్యాలెన్స్ 0కి సెట్ చేయబడనందున, తదుపరి ఆహ్వానాలు విజయవంతమవుతాయి మరియు కాలర్ వారి బ్యాలెన్స్‌ను పలుమార్లు ఉపసంహరించుకోవడానికి అనుమతిస్తాయి. ఈ రకమైన దాడి [2016 DAO హ్యాక్](https://www.coindesk.com/learn/understanding-the-dao-attack)లో జరిగినట్లుగా, ఒక స్మార్ట్ కాంట్రాక్ట్ నిధులను ఖాళీ చేయడానికి ఉపయోగించబడుతుంది. [పునఃప్రవేశ దోపిడీల పబ్లిక్ జాబితాలు](https://github.com/pcaversaccio/reentrancy-attacks) చూపిస్తున్నట్లుగా, పునఃప్రవేశ దాడులు నేటికీ స్మార్ట్ కాంట్రాక్ట్‌లకు ఒక క్లిష్టమైన సమస్యగా ఉన్నాయి.

##### పునఃప్రవేశ దాడులను ఎలా నివారించాలి

పునఃప్రవేశంతో వ్యవహరించడానికి ఒక విధానం [చెక్స్-ఎఫెక్ట్స్-ఇంటరాక్షన్స్ ప్యాటర్న్](https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern)ను అనుసరించడం. ఈ ప్యాటర్న్ ఫంక్షన్‌ల అమలును ఒక క్రమంలో పెడుతుంది, దీనిలో అమలుతో ముందుకు సాగే ముందు అవసరమైన తనిఖీలను చేసే కోడ్ మొదట వస్తుంది, దాని తర్వాత కాంట్రాక్ట్ స్టేట్‌ను మార్చే కోడ్, మరియు చివరిగా ఇతర కాంట్రాక్ట్‌లు లేదా EOAలతో సంభాషించే కోడ్ వస్తుంది.

చెక్స్-ఎఫెక్ట్-ఇంటరాక్షన్ ప్యాటర్న్ కింది చూపబడిన `విక్టిమ్` కాంట్రాక్ట్ యొక్క సవరించిన వెర్షన్‌లో ఉపయోగించబడింది:

```solidity
contract NoLongerAVictim {
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
    }
}
```

ఈ కాంట్రాక్ట్ వినియోగదారు బ్యాలెన్స్‌పై ఒక _తనిఖీ_ చేస్తుంది, `withdraw()` ఫంక్షన్ యొక్క _ప్రభావాలను_ వర్తింపజేస్తుంది (వినియోగదారు బ్యాలెన్స్‌ను 0కి రీసెట్ చేయడం ద్వారా), మరియు _సంభాషణను_ చేయడానికి ముందుకు సాగుతుంది (వినియోగదారు చిరునామాకు ETH పంపడం). ఇది బాహ్య కాల్‌కు ముందు కాంట్రాక్ట్ దాని స్టోరేజ్‌ను అప్‌డేట్ చేస్తుందని నిర్ధారిస్తుంది, మొదటి దాడిని ప్రారంభించిన పునఃప్రవేశ పరిస్థితిని తొలగిస్తుంది. `Attacker` కాంట్రాక్ట్ ఇప్పటికీ `NoLongerAVictim`లోకి తిరిగి కాల్ చేయగలదు, కానీ `balances[msg.sender]` 0కి సెట్ చేయబడినందున, అదనపు ఉపసంహరణలు ఒక ఎర్రర్‌ను విసురుతాయి.

మరొక ఎంపిక మ్యూచువల్ ఎక్స్‌క్లూజన్ లాక్‌ను (సాధారణంగా “మ్యూటెక్స్”గా వర్ణించబడుతుంది) ఉపయోగించడం, ఇది ఒక ఫంక్షన్ ఆహ్వానం పూర్తయ్యే వరకు కాంట్రాక్ట్ యొక్క స్టేట్ యొక్క ఒక భాగాన్ని లాక్ చేస్తుంది. ఇది ఒక బూలియన్ వేరియబుల్‌ను ఉపయోగించి అమలు చేయబడుతుంది, ఇది ఫంక్షన్ అమలు కావడానికి ముందు `true`గా సెట్ చేయబడుతుంది మరియు ఆహ్వానం పూర్తయిన తర్వాత `false`కు తిరిగి వస్తుంది. కింది ఉదాహరణలో చూసినట్లుగా, మ్యూటెక్స్‌ను ఉపయోగించడం అసలు ఆహ్వానం ఇంకా ప్రాసెసింగ్‌లో ఉన్నప్పుడు పునరావృత కాల్స్‌కు వ్యతిరేకంగా ఒక ఫంక్షన్‌ను రక్షిస్తుంది, పునఃప్రవేశాన్ని సమర్థవంతంగా ఆపుతుంది.

```solidity
pragma solidity ^0.7.0;

contract MutexPattern {
    bool locked = false;
    mapping(address => uint256) public balances;

    modifier noReentrancy() {
        require(!locked, "పునఃప్రవేశం నుండి బ్లాక్ చేయబడింది.");
        locked = true;
        _;
        locked = false;
    }
    // ఈ ఫంక్షన్ ఒక మ్యూటెక్స్ ద్వారా రక్షించబడింది, కాబట్టి `msg.sender.call` లోపల నుండి పునఃప్రవేశ కాల్‌లు `withdraw`ను మళ్ళీ పిలవలేవు.
    // `return` స్టేట్‌మెంట్ `true`గా మూల్యాంకనం చేస్తుంది కానీ ఇప్పటికీ మాడిఫైయర్‌లోని `locked = false` స్టేట్‌మెంట్‌ను మూల్యాంకనం చేస్తుంది
    function withdraw(uint _amount) public payable noReentrancy returns(bool) {
        require(balances[msg.sender] >= _amount, "ఉపసంహరించుకోవడానికి బ్యాలెన్స్ లేదు.");

        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success);

        return true;
    }
}
```

మీరు ఖాతాలకు నిధులను పంపే “పుష్ పేమెంట్స్” సిస్టమ్‌కు బదులుగా, వినియోగదారులను స్మార్ట్ కాంట్రాక్ట్‌ల నుండి నిధులను ఉపసంహరించుకోవాలని కోరే [పుల్ పేమెంట్స్](https://docs.openzeppelin.com/contracts/5.x/api/security#PullPayment) సిస్టమ్‌ను కూడా ఉపయోగించవచ్చు. ఇది తెలియని చిరునామాలలో అనుకోకుండా కోడ్‌ను ట్రిగ్గర్ చేసే అవకాశాన్ని తొలగిస్తుంది (మరియు కొన్ని డినయల్-ఆఫ్-సర్వీస్ దాడులను కూడా నివారించగలదు).

#### ఇంటిజర్ అండర్‌ఫ్లోలు మరియు ఓవర్‌ఫ్లోలు {#integer-underflows-and-overflows}

ఒక అంకగణిత ఆపరేషన్ ఫలితాలు ఆమోదయోగ్యమైన విలువల పరిధికి వెలుపల పడిపోయినప్పుడు ఒక ఇంటిజర్ ఓవర్‌ఫ్లో సంభవిస్తుంది, ఇది దానిని అత్యల్ప ప్రాతినిధ్య విలువకు “తిరిగి వెళ్లడానికి” కారణమవుతుంది. ఉదాహరణకు, ఒక `uint8` 2^8-1=255 వరకు మాత్రమే విలువలను నిల్వ చేయగలదు. `255` కంటే ఎక్కువ విలువలకు దారితీసే అంకగణిత కార్యకలాపాలు పొంగిపొర్లుతాయి మరియు `uint`ని `0`కు రీసెట్ చేస్తాయి, కారులోని ఓడోమీటర్ గరిష్ట మైలేజీకి (999999) చేరుకున్న తర్వాత 0కి రీసెట్ అయినట్లే.

ఇంటిజర్ అండర్‌ఫ్లోలు ఇలాంటి కారణాల వల్ల జరుగుతాయి: ఒక అంకగణిత ఆపరేషన్ ఫలితాలు ఆమోదయోగ్యమైన పరిధి కంటే తక్కువగా పడిపోతాయి. మీరు ఒక `uint8`లో `0`ని తగ్గించడానికి ప్రయత్నించారని అనుకుందాం, ఫలితం గరిష్ట ప్రాతినిధ్య విలువకు (`255`) తిరిగి వెళ్తుంది.

ఇంటిజర్ ఓవర్‌ఫ్లోలు మరియు అండర్‌ఫ్లోలు రెండూ ఒక కాంట్రాక్ట్ యొక్క స్టేట్ వేరియబుల్స్‌కు అనూహ్య మార్పులకు దారితీయవచ్చు మరియు ప్రణాళిక లేని అమలుకు దారితీయవచ్చు. ఒక దాడి చేసేవాడు స్మార్ట్ కాంట్రాక్ట్‌లో అంకగణిత ఓవర్‌ఫ్లోను ఉపయోగించుకుని ఒక చెల్లని ఆపరేషన్‌ను ఎలా నిర్వహించవచ్చో చూపే ఒక ఉదాహరణ కింద ఉంది:

```
pragma solidity ^0.7.6;

// ఈ కాంట్రాక్ట్ టైమ్ వాల్ట్‌గా పనిచేయడానికి రూపొందించబడింది.
// వినియోగదారుడు ఈ కాంట్రాక్ట్‌లో డిపాజిట్ చేయవచ్చు కానీ కనీసం ఒక వారం పాటు ఉపసంహరించుకోలేరు.
// వినియోగదారుడు 1 వారం నిరీక్షణ వ్యవధికి మించి నిరీక్షణ సమయాన్ని కూడా పొడిగించవచ్చు.

/*
1. టైమ్‌లాక్‌ను అమలు చేయండి
2. టైమ్‌లాక్ చిరునామాతో అటాక్‌ను అమలు చేయండి
3. 1 ఈథర్‌ను పంపి, Attack.attackను పిలవండి. మీరు వెంటనే మీ ఈథర్‌ను ఉపసంహరించుకోగలరు.

ఏమి జరిగింది?
అటాక్ టైమ్‌లాక్.లాక్‌టైమ్ పొంగిపొర్లడానికి కారణమైంది మరియు 1 వారం నిరీక్షణ వ్యవధికి ముందే ఉపసంహరించుకోగలిగింది.
*/

contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "నిధులు సరిపోవు");
        require(block.timestamp > lockTime[msg.sender], "లాక్ సమయం గడువు ముగియలేదు");

        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "ఈథర్ పంపడంలో విఫలమైంది");
    }
}

contract Attack {
    TimeLock timeLock;

    constructor(TimeLock _timeLock) {
        timeLock = TimeLock(_timeLock);
    }

    fallback() external payable {}

    function attack() public payable {
        timeLock.deposit{value: msg.value}();
        /*
        t = ప్రస్తుత లాక్ సమయం అయితే, మనం x ను కనుగొనాలి
        x + t = 2**256 = 0
        కాబట్టి x = -t
        2**256 = type(uint).max + 1
        కాబట్టి x = type(uint).max + 1 - t
        */
        timeLock.increaseLockTime(
            type(uint).max + 1 - timeLock.lockTime(address(this))
        );
        timeLock.withdraw();
    }
}
```

##### ఇంటిజర్ అండర్‌ఫ్లోలు మరియు ఓవర్‌ఫ్లోలను ఎలా నివారించాలి

వెర్షన్ 0.8.0 నుండి, Solidity కంపైలర్ ఇంటిజర్ అండర్‌ఫ్లోలు మరియు ఓవర్‌ఫ్లోలకు దారితీసే కోడ్‌ను తిరస్కరిస్తుంది. అయితే, తక్కువ కంపైలర్ వెర్షన్‌తో కంపైల్ చేయబడిన కాంట్రాక్ట్‌లు అంకగణిత కార్యకలాపాలు ఉన్న ఫంక్షన్‌లపై తనిఖీలను నిర్వహించాలి లేదా అండర్‌ఫ్లో/ఓవర్‌ఫ్లో కోసం తనిఖీ చేసే లైబ్రరీని (ఉదా., [సేఫ్‌మ్యాత్](https://docs.openzeppelin.com/contracts/2.x/api/math)) ఉపయోగించాలి.

#### ఒరాకిల్ మానిప్యులేషన్ {#oracle-manipulation}

[ఒరాకిల్స్](/developers/docs/oracles/) ఆఫ్‌చైన్ సమాచారాన్ని సోర్స్ చేసి, దానిని స్మార్ట్ కాంట్రాక్ట్‌లు ఉపయోగించడానికి ఆన్‌చైన్‌కు పంపుతాయి. ఒరాకిల్స్‌తో, మీరు క్యాపిటల్ మార్కెట్‌ల వంటి ఆఫ్‌చైన్ సిస్టమ్‌లతో పరస్పరం పనిచేసే స్మార్ట్ కాంట్రాక్ట్‌లను రూపొందించవచ్చు, వాటి అప్లికేషన్‌ను బాగా విస్తరించవచ్చు.

కానీ ఒరాకిల్ పాడైపోయి, తప్పు సమాచారాన్ని ఆన్‌చైన్‌కు పంపితే, స్మార్ట్ కాంట్రాక్ట్‌లు తప్పుడు ఇన్‌పుట్‌ల ఆధారంగా అమలు అవుతాయి, ఇది సమస్యలను కలిగిస్తుంది. ఇది “ఒరాకిల్ సమస్య” యొక్క ఆధారం, ఇది ఒక బ్లాక్‌చైన్ ఒరాకిల్ నుండి వచ్చే సమాచారం ఖచ్చితమైనదని, తాజాదని, మరియు సకాలంలో ఉందని నిర్ధారించుకునే పనికి సంబంధించినది.

ఒక ఆస్తి యొక్క స్పాట్ ధరను పొందడానికి, వికేంద్రీకృత మార్పిడి వంటి ఆన్‌చైన్ ఒరాకిల్‌ను ఉపయోగించడం ఒక సంబంధిత భద్రతా ఆందోళన. [వికేంద్రీకృత ఫైనాన్స్ (DeFi)](/defi/) పరిశ్రమలోని రుణ ప్లాట్‌ఫారమ్‌లు ఒక వినియోగదారు యొక్క కొలేటరల్ విలువను నిర్ణయించడానికి మరియు వారు ఎంత రుణం తీసుకోగలరో నిర్ధారించడానికి తరచుగా దీనిని చేస్తాయి.

DEX ధరలు తరచుగా ఖచ్చితమైనవి, మార్కెట్లలో సమానత్వాన్ని పునరుద్ధరించే ఆర్బిట్రేజర్‌ల కారణంగా ఇది చాలావరకు జరుగుతుంది. అయితే, అవి మానిప్యులేషన్‌కు తెరిచి ఉన్నాయి, ప్రత్యేకించి ఆన్‌చైన్ ఒరాకిల్ చారిత్రక ట్రేడింగ్ ప్యాటర్న్‌ల ఆధారంగా ఆస్తి ధరలను లెక్కిస్తే (సాధారణంగా జరిగేదే).

ఉదాహరణకు, ఒక దాడి చేసేవాడు మీ రుణ కాంట్రాక్ట్‌తో సంభాషించడానికి ముందు ఫ్లాష్ లోన్ తీసుకోవడం ద్వారా ఒక ఆస్తి యొక్క స్పాట్ ధరను కృత్రిమంగా పెంచవచ్చు. ఆస్తి ధర కోసం DEXని ప్రశ్నించడం సాధారణం కంటే ఎక్కువ విలువను తిరిగి ఇస్తుంది (దాడి చేసేవారి పెద్ద “కొనుగోలు ఆర్డర్” ఆస్తికి డిమాండ్‌ను వక్రీకరించడం వలన), ఇది వారికి ఉండాల్సిన దానికంటే ఎక్కువ రుణం తీసుకోవడానికి అనుమతిస్తుంది. అటువంటి “ఫ్లాష్ లోన్ దాడులు” DeFi అప్లికేషన్‌లలో ధర ఒరాకిల్స్‌పై ఆధారపడటాన్ని దోపిడీ చేయడానికి ఉపయోగించబడ్డాయి, ప్రోటోకాల్స్‌కు మిలియన్ల కొద్దీ నిధులు నష్టపోయాయి.

##### ఒరాకిల్ మానిప్యులేషన్‌ను ఎలా నివారించాలి

[ఒరాకిల్ మానిప్యులేషన్‌ను నివారించడానికి](https://www.cyfrin.io/blog/price-oracle-manipultion-attacks-with-examples) కనీస అవసరం, సింగిల్ పాయింట్స్ ఆఫ్ ఫెయిల్యూర్‌ను నివారించడానికి బహుళ మూలాల నుండి సమాచారాన్ని ప్రశ్నించే వికేంద్రీకృత ఒరాకిల్ నెట్‌వర్క్‌ను ఉపయోగించడం. చాలా సందర్భాలలో, వికేంద్రీకృత ఒరాకిల్స్‌కు ఒరాకిల్ నోడ్స్ సరైన సమాచారాన్ని నివేదించడానికి ప్రోత్సహించడానికి అంతర్నిర్మిత క్రిప్టోఎకనామిక్ ప్రోత్సాహకాలు ఉన్నాయి, ఇది వాటిని కేంద్రీకృత ఒరాకిల్స్ కంటే సురక్షితంగా చేస్తుంది.

మీరు ఆస్తి ధరల కోసం ఆన్‌చైన్ ఒరాకిల్‌ను ప్రశ్నించాలని ప్లాన్ చేస్తే, టైమ్-వెయిటెడ్ యావరేజ్ ప్రైస్ (TWAP) మెకానిజంను అమలు చేసే దానిని ఉపయోగించడాన్ని పరిగణించండి. ఒక [TWAP ఒరాకిల్](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) రెండు విభిన్న సమయ బిందువుల వద్ద ఒక ఆస్తి ధరను ప్రశ్నిస్తుంది (దీనిని మీరు సవరించవచ్చు) మరియు పొందిన సగటు ఆధారంగా స్పాట్ ధరను లెక్కిస్తుంది. దీర్ఘకాలిక సమయ వ్యవధులను ఎంచుకోవడం మీ ప్రోటోకాల్‌ను ధరల మానిప్యులేషన్‌కు వ్యతిరేకంగా రక్షిస్తుంది, ఎందుకంటే ఇటీవల అమలు చేయబడిన పెద్ద ఆర్డర్‌లు ఆస్తి ధరలను ప్రభావితం చేయలేవు.

## డెవలపర్‌ల కోసం స్మార్ట్ కాంట్రాక్ట్ భద్రతా వనరులు {#smart-contract-security-resources-for-developers}

### స్మార్ట్ కాంట్రాక్ట్‌లను విశ్లేషించడానికి మరియు కోడ్ సరిగ్గా ఉందో లేదో ధృవీకరించడానికి ఉపకరణాలు {#code-analysis-tools}

- **[పరీక్షా సాధనాలు మరియు లైబ్రరీలు](/developers/docs/smart-contracts/testing/#testing-tools-and-libraries)** - _స్మార్ట్ కాంట్రాక్ట్‌లపై యూనిట్ పరీక్షలు, స్టాటిక్ విశ్లేషణ మరియు డైనమిక్ విశ్లేషణలను నిర్వహించడానికి పరిశ్రమ-ప్రామాణిక సాధనాలు మరియు లైబ్రరీల సేకరణ._

- **[ఫార్మల్ వెరిఫికేషన్ సాధనాలు](/developers/docs/smart-contracts/formal-verification/#formal-verification-tools)** - _స్మార్ట్ కాంట్రాక్ట్‌లలో ఫంక్షనల్ ఖచ్చితత్వాన్ని ధృవీకరించడానికి మరియు ఇన్వేరియంట్‌లను తనిఖీ చేయడానికి సాధనాలు._

- **[స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్ సేవలు](/developers/docs/smart-contracts/testing/#smart-contract-auditing-services)** - _ఇతీరియము అభివృద్ధి ప్రాజెక్ట్‌ల కోసం స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్ సేవలను అందించే సంస్థల జాబితా._

- **[బగ్ బౌంటీ ప్లాట్‌ఫారమ్‌లు](/developers/docs/smart-contracts/testing/#bug-bounty-platforms)** - _బగ్ బౌంటీలను సమన్వయం చేయడానికి మరియు స్మార్ట్ కాంట్రాక్ట్‌లలో క్లిష్టమైన బలహీనతల యొక్క బాధ్యతాయుతమైన బహిర్గతం కోసం బహుమతి ఇవ్వడానికి ప్లాట్‌ఫారమ్‌లు._

- **[ఫోర్క్ చెకర్](https://forkchecker.hashex.org/)** - _ఒక ఫోర్క్డ్ కాంట్రాక్ట్‌కు సంబంధించి అందుబాటులో ఉన్న మొత్తం సమాచారాన్ని తనిఖీ చేయడానికి ఒక ఉచిత ఆన్‌లైన్ సాధనం._

- **[ABI ఎన్‌కోడర్](https://abi.hashex.org/)** - _మీ Solidity కాంట్రాక్ట్ ఫంక్షన్‌లు మరియు కన్‌స్ట్రక్టర్ ఆర్గ్యుమెంట్‌లను ఎన్‌కోడ్ చేయడానికి ఒక ఉచిత ఆన్‌లైన్ సేవ._

- **[అడెరిన్](https://github.com/Cyfrin/aderyn)** - _Solidity స్టాటిక్ అనలైజర్, అనుమానిత బలహీనతలను గుర్తించడానికి అబ్‌స్ట్రాక్ట్ సింటాక్స్ ట్రీస్ (AST)ను దాటుతుంది మరియు సులభంగా వినియోగించే మార్క్‌డౌన్ ఫార్మాట్‌లో సమస్యలను ప్రింట్ చేస్తుంది._

### స్మార్ట్ కాంట్రాక్ట్‌లను పర్యవేక్షించడానికి ఉపకరణాలు {#smart-contract-monitoring-tools}

- **[టెండర్లీ రియల్-టైమ్ అలర్టింగ్](https://tenderly.co/monitoring)** - _మీ స్మార్ట్ కాంట్రాక్ట్‌లు లేదా వాలెట్‌లలో అసాధారణ లేదా ఊహించని సంఘటనలు జరిగినప్పుడు నిజ-సమయ నోటిఫికేషన్‌లను పొందడానికి ఒక సాధనం._

### స్మార్ట్ కాంట్రాక్ట్‌ల సురక్షిత పరిపాలన కోసం సాధనాలు {#smart-contract-administration-tools}

- **[సేఫ్](https://safe.global/)** - _ఇతీరియములో నడుస్తున్న స్మార్ట్ కాంట్రాక్ట్ వాలెట్, ఇది ఒక లావాదేవీ జరగడానికి ముందు కనీస సంఖ్యలో వ్యక్తులు ఆమోదించాల్సిన అవసరం ఉంది (M-ఆఫ్-N)._

- **[OpenZeppelin కాంట్రాక్ట్‌లు](https://docs.openzeppelin.com/contracts/5.x/)** - _కాంట్రాక్ట్ యాజమాన్యం, అప్‌గ్రేడ్‌లు, యాక్సెస్ నియంత్రణలు, పాలన, పాజ్ చేయగల సామర్థ్యం మరియు మరిన్నింటితో సహా పరిపాలనా లక్షణాలను అమలు చేయడానికి కాంట్రాక్ట్ లైబ్రరీలు._

### స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్ సేవలు {#smart-contract-auditing-services}

- **[ConsenSys డిలిజెన్స్](https://diligence.consensys.io/)** - _బ్లాక్‌చైన్ పర్యావరణ వ్యవస్థ అంతటా ప్రాజెక్ట్‌లకు సహాయపడే స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్ సేవ, వారి ప్రోటోకాల్‌లు ప్రారంభానికి సిద్ధంగా ఉన్నాయని మరియు వినియోగదారులను రక్షించడానికి నిర్మించబడ్డాయని నిర్ధారించడానికి._

- **[CertiK](https://www.certik.com/)** - _స్మార్ట్ కాంట్రాక్ట్‌లు మరియు బ్లాక్‌చైన్ నెట్‌వర్క్‌లపై అత్యాధునిక ఫార్మల్ వెరిఫికేషన్ టెక్నాలజీని ఉపయోగించడంలో అగ్రగామిగా ఉన్న బ్లాక్‌చైన్ సెక్యూరిటీ సంస్థ._

- **[ట్రెయిల్ ఆఫ్ బిట్స్](https://www.trailofbits.com/)** - _రిస్క్‌ను తగ్గించడానికి మరియు కోడ్‌ను బలోపేతం చేయడానికి దాడి చేసేవారి మనస్తత్వంతో భద్రతా పరిశోధనను కలిపే సైబర్‌ సెక్యూరిటీ కంపెనీ._

- **[పెక్ షీల్డ్](https://peckshield.com/)** - _మొత్తం బ్లాక్‌చైన్ పర్యావరణ వ్యవస్థ యొక్క భద్రత, గోప్యత మరియు వినియోగానికి ఉత్పత్తులు మరియు సేవలను అందించే బ్లాక్‌చైన్ సెక్యూరిటీ కంపెనీ._

- **[క్వాంట్‌స్టాంప్](https://quantstamp.com/)** - _భద్రత మరియు రిస్క్ అసెస్‌మెంట్ సేవల ద్వారా బ్లాక్‌చైన్ టెక్నాలజీ యొక్క ప్రధాన స్రవంతి స్వీకరణను సులభతరం చేసే ఆడిటింగ్ సేవ._

- **[OpenZeppelin](https://www.openzeppelin.com/security-audits)** - _పంపిణీ చేయబడిన సిస్టమ్‌ల కోసం భద్రతా ఆడిట్‌లను అందించే స్మార్ట్ కాంట్రాక్ట్ సెక్యూరిటీ కంపెనీ._

- **[రన్‌టైమ్ వెరిఫికేషన్](https://runtimeverification.com/)** - _స్మార్ట్ కాంట్రాక్ట్‌ల యొక్క ఫార్మల్ మోడలింగ్ మరియు వెరిఫికేషన్‌లో ప్రత్యేకత కలిగిన సెక్యూరిటీ కంపెనీ._

- **[Hacken](https://hacken.io)** - _బ్లాక్‌చైన్ భద్రతకు 360-డిగ్రీల విధానాన్ని తీసుకువస్తున్న Web3 సైబర్‌ సెక్యూరిటీ ఆడిటర్._

- **[Nethermind](https://www.nethermind.io/smart-contract-audits)** - _Solidity మరియు కైరో ఆడిటింగ్ సేవలు, ఇతీరియము మరియు స్టార్క్‌నెట్ అంతటా స్మార్ట్ కాంట్రాక్ట్‌ల సమగ్రతను మరియు వినియోగదారుల భద్రతను నిర్ధారిస్తాయి._

- **[HashEx](https://hashex.org/)** - _క్రిప్టోకరెన్సీల భద్రతను నిర్ధారించడానికి హాష్‌ఎక్స్ బ్లాక్‌చైన్ మరియు స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్‌పై దృష్టి పెడుతుంది, స్మార్ట్ కాంట్రాక్ట్ డెవలప్‌మెంట్, పెనెట్రేషన్ టెస్టింగ్, బ్లాక్‌చైన్ కన్సల్టింగ్ వంటి సేవలను అందిస్తుంది._

- **[Code4rena](https://code4rena.com/)** - _పోటీతత్వ ఆడిట్ ప్లాట్‌ఫారమ్, ఇది స్మార్ట్ కాంట్రాక్ట్ భద్రతా నిపుణులను బలహీనతలను కనుగొనడానికి ప్రోత్సహిస్తుంది మరియు వెబ్3ను మరింత సురక్షితంగా చేయడానికి సహాయపడుతుంది._

- **[CodeHawks](https://codehawks.com/)** - _భద్రతా పరిశోధకుల కోసం స్మార్ట్ కాంట్రాక్ట్స్ ఆడిటింగ్ పోటీలను నిర్వహించే పోటీ ఆడిట్స్ ప్లాట్‌ఫారమ్._

- **[Cyfrin](https://cyfrin.io)** - _Web3 సెక్యూరిటీ పవర్‌హౌస్, ఉత్పత్తులు మరియు స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్ సేవల ద్వారా క్రిప్టో భద్రతను ఇంక్యుబేట్ చేస్తుంది._

- **[ImmuneBytes](https://immunebytes.com/smart-contract-audit/)** - _అనుభవజ్ఞులైన ఆడిటర్లు మరియు ఉత్తమ-తరగతి సాధనాల బృందం ద్వారా బ్లాక్‌చైన్ సిస్టమ్‌ల కోసం భద్రతా ఆడిట్‌లను అందించే Web3 సెక్యూరిటీ సంస్థ._

- **[Oxorio](https://oxor.io/)** - _EVM, Solidity, ZK, క్రాస్-చైన్ టెక్నాలజీలో నిపుణులైన స్మార్ట్ కాంట్రాక్ట్ ఆడిట్‌లు మరియు బ్లాక్‌చైన్ భద్రతా సేవలు, క్రిప్టో సంస్థలు మరియు DeFi ప్రాజెక్ట్‌ల కోసం._

- **[Inference](https://inference.ag/)** - _భద్రతా ఆడిటింగ్ కంపెనీ, EVM-ఆధారిత బ్లాక్‌చైన్‌ల కోసం స్మార్ట్ కాంట్రాక్ట్ ఆడిటింగ్‌లో ప్రత్యేకత కలిగి ఉంది. దాని నిపుణులైన ఆడిటర్లకు ధన్యవాదాలు, వారు సంభావ్య సమస్యలను గుర్తించి, వాటిని అమలు చేయడానికి ముందు పరిష్కరించడానికి కార్యాచరణ పరిష్కారాలను సూచిస్తారు._

### బగ్ బౌంటీ ప్లాట్‌ఫారమ్‌లు {#bug-bounty-platforms}

- **[Immunefi](https://immunefi.com/)** - _స్మార్ట్ కాంట్రాక్ట్‌లు మరియు DeFi ప్రాజెక్ట్‌ల కోసం బగ్ బౌంటీ ప్లాట్‌ఫారమ్, ఇక్కడ భద్రతా పరిశోధకులు కోడ్‌ను సమీక్షించి, బలహీనతలను బహిర్గతం చేసి, డబ్బు సంపాదించి, క్రిప్టోను మరింత సురక్షితంగా చేస్తారు._

- **[HackerOne](https://www.hackerone.com/)** - _వ్యాపారాలను పెనెట్రేషన్ టెస్టర్లు మరియు సైబర్‌ సెక్యూరిటీ పరిశోధకులతో కనెక్ట్ చేసే బలహీనత సమన్వయం మరియు బగ్ బౌంటీ ప్లాట్‌ఫారమ్._

- **[HackenProof](https://hackenproof.com/)** - _క్రిప్టో ప్రాజెక్ట్‌ల (DeFi, స్మార్ట్ కాంట్రాక్ట్స్, వాలెట్స్, CEX మరియు మరిన్ని) కోసం నిపుణులైన బగ్ బౌంటీ ప్లాట్‌ఫారమ్, ఇక్కడ భద్రతా నిపుణులు ట్రైయేజ్ సేవలను అందిస్తారు మరియు పరిశోధకులు సంబంధిత, ధృవీకరించబడిన బగ్ నివేదికల కోసం చెల్లించబడతారు._

- **[Sherlock](https://www.sherlock.xyz/)** - _స్మార్ట్ కాంట్రాక్ట్ భద్రత కోసం వెబ్3లో అండర్‌రైటర్, సంబంధిత బగ్‌లు న్యాయంగా చెల్లించబడతాయని భద్రపరచడానికి స్మార్ట్ కాంట్రాక్ట్‌ల ద్వారా నిర్వహించబడే ఆడిటర్ల కోసం చెల్లింపులతో._

- **[CodeHawks](https://www.codehawks.com/)** - _పోటీతత్వ బగ్ బౌంటీ ప్లాట్‌ఫారమ్, ఇక్కడ ఆడిటర్లు భద్రతా పోటీలు మరియు సవాళ్లలో పాల్గొంటారు మరియు (త్వరలో) వారి స్వంత ప్రైవేట్ ఆడిట్‌లలో పాల్గొంటారు._

### తెలిసిన స్మార్ట్ కాంట్రాక్ట్ బలహీనతలు మరియు దోపిడీల ప్రచురణలు {#common-smart-contract-vulnerabilities-and-exploits}

- **[ConsenSys: స్మార్ట్ కాంట్రాక్ట్ తెలిసిన దాడులు](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/)** - _చాలా సందర్భాలలో నమూనా కోడ్‌తో, అత్యంత ముఖ్యమైన కాంట్రాక్ట్ బలహీనతల యొక్క ప్రారంభ-స్నేహపూర్వక వివరణ._

- **[SWC రిజిస్ట్రీ](https://swcregistry.io/)** - _ఇతీరియము స్మార్ట్ కాంట్రాక్ట్‌లకు వర్తించే కామన్ వీక్‌నెస్ ఎన్యూమరేషన్ (CWE) ఐటమ్‌ల క్యూరేటెడ్ జాబితా._

- **[Rekt](https://rekt.news/)** - _వివరణాత్మక పోస్ట్-మార్టం నివేదికలతో పాటు, ఉన్నత-స్థాయి క్రిప్టో హ్యాక్‌లు మరియు దోపిడీల యొక్క క్రమం తప్పకుండా నవీకరించబడిన ప్రచురణ._

### స్మార్ట్ కాంట్రాక్ట్ భద్రతను నేర్చుకోవడానికి సవాళ్లు {#challenges-for-learning-smart-contract-security}

- **[అద్భుతమైన బ్లాక్‌సెక్ CTF](https://github.com/blockthreat/blocksec-ctfs)** - _బ్లాక్‌చైన్ భద్రతా యుద్ధ క్రీడలు, సవాళ్లు, మరియు [క్యాప్చర్ ది ఫ్లాగ్](https://www.webopedia.com/definitions/ctf-event/amp/) పోటీలు మరియు పరిష్కారాల రైటప్‌ల క్యూరేటెడ్ జాబితా._

- **[డామ్న్ వల్నరబుల్ DeFi](https://www.damnvulnerabledefi.xyz/)** - _DeFi స్మార్ట్ కాంట్రాక్ట్‌ల ఆఫెన్సివ్ సెక్యూరిటీని నేర్చుకోవడానికి మరియు బగ్-హంటింగ్ మరియు సెక్యూరిటీ ఆడిటింగ్‌లో నైపుణ్యాలను పెంపొందించుకోవడానికి వార్‌గేమ్._

- **[Ethernaut](https://ethernaut.openzeppelin.com/)** - _Web3/Solidity-ఆధారిత వార్‌గేమ్, ఇక్కడ ప్రతి స్థాయి ఒక స్మార్ట్ కాంట్రాక్ట్, దానిని 'హ్యాక్' చేయాలి._

- **[HackenProof x HackTheBox](https://app.hackthebox.com/tracks/HackenProof-Track)** - _ఒక ఫాంటసీ అడ్వెంచర్‌లో సెట్ చేయబడిన స్మార్ట్ కాంట్రాక్ట్ హ్యాకింగ్ ఛాలెంజ్. ఛాలెంజ్‌ను విజయవంతంగా పూర్తి చేయడం ప్రైవేట్ బగ్ బౌంటీ ప్రోగ్రామ్‌కు యాక్సెస్‌ను కూడా ఇస్తుంది._

### స్మార్ట్ కాంట్రాక్ట్‌లను సురక్షితంగా ఉంచడానికి ఉత్తమ పద్ధతులు {#smart-contract-security-best-practices}

- **[ConsenSys: ఇతీరియము స్మార్ట్ కాంట్రాక్ట్ భద్రత ఉత్తమ పద్ధతులు](https://consensys.github.io/smart-contract-best-practices/)** - _ఇతీరియము స్మార్ట్ కాంట్రాక్ట్‌లను సురక్షితంగా ఉంచడానికి మార్గదర్శకాల యొక్క సమగ్ర జాబితా._

- **[నాసెంట్: సింపుల్ సెక్యూరిటీ టూల్‌కిట్](https://github.com/nascentxyz/simple-security-toolkit)** - _స్మార్ట్ కాంట్రాక్ట్ అభివృద్ధి కోసం ఆచరణాత్మక భద్రత-కేంద్రీకృత గైడ్‌లు మరియు చెక్‌లిస్ట్‌ల సేకరణ._

- **[Solidity ప్యాటర్న్‌లు](https://fravoll.github.io/solidity-patterns/)** - _స్మార్ట్ కాంట్రాక్ట్ ప్రోగ్రామింగ్ భాష Solidity కోసం సురక్షితమైన ప్యాటర్న్‌లు మరియు ఉత్తమ పద్ధతుల యొక్క ఉపయోగకరమైన సంకలనం._

- **[Solidity డాక్స్: భద్రతా పరిగణనలు](https://docs.soliditylang.org/en/v0.8.16/security-considerations.html)** - _Solidity తో సురక్షితమైన స్మార్ట్ కాంట్రాక్ట్‌లను వ్రాయడానికి మార్గదర్శకాలు._

- **[స్మార్ట్ కాంట్రాక్ట్ సెక్యూరిటీ వెరిఫికేషన్ స్టాండర్డ్](https://github.com/securing/SCSVS)** - _డెవలపర్లు, ఆర్కిటెక్ట్‌లు, భద్రతా సమీక్షకులు మరియు విక్రేతల కోసం స్మార్ట్ కాంట్రాక్ట్‌ల భద్రతను ప్రామాణీకరించడానికి సృష్టించబడిన పద్నాలుగు-భాగాల చెక్‌లిస్ట్._

- **[స్మార్ట్ కాంట్రాక్ట్ సెక్యూరిటీ మరియు ఆడిటింగ్‌ను నేర్చుకోండి](https://updraft.cyfrin.io/courses/security)** - _అల్టిమేట్ స్మార్ట్ కాంట్రాక్ట్ సెక్యూరిటీ మరియు ఆడిటింగ్ కోర్సు, వారి భద్రతా ఉత్తమ పద్ధతులను మెరుగుపరచడానికి మరియు భద్రతా పరిశోధకులుగా మారడానికి చూస్తున్న స్మార్ట్ కాంట్రాక్ట్ డెవలపర్‌ల కోసం సృష్టించబడింది._

### స్మార్ట్ కాంట్రాక్ట్ భద్రతపై ట్యుటోరియల్స్ {#tutorials-on-smart-contract-security}

- [సురక్షిత స్మార్ట్ కాంట్రాక్ట్‌లను ఎలా వ్రాయాలి](/developers/tutorials/secure-development-workflow/)

- [స్మార్ట్ కాంట్రాక్ట్ బగ్‌లను కనుగొనడానికి స్లిథర్‌ను ఎలా ఉపయోగించాలి](/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/)

- [స్మార్ట్ కాంట్రాక్ట్ బగ్‌లను కనుగొనడానికి మాంటికోర్‌ను ఎలా ఉపయోగించాలి](/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/)

- [స్మార్ట్ కాంట్రాక్ట్ భద్రతా మార్గదర్శకాలు](/developers/tutorials/smart-contract-security-guidelines/)

- [మీ టోకెన్ కాంట్రాక్ట్‌ను ఏకపక్ష టోకెన్‌లతో సురక్షితంగా ఎలా ఏకీకృతం చేయాలి](/developers/tutorials/token-integration-checklist/)

- [సైఫ్రిన్ అప్‌డ్రాఫ్ట్ - స్మార్ట్ కాంట్రాక్ట్స్ సెక్యూరిటీ మరియు ఆడిటింగ్ పూర్తి కోర్సు](https://updraft.cyfrin.io/courses/security)
