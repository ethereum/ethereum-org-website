---
title: "రికర్సివ్-లెంగ్త్ ప్రిఫిక్స్ (RLP) సీరియలైజేషన్"
description: "Ethereum యొక్క ఎగ్జిక్యూషన్ లేయర్‌లో rlp ఎన్‌కోడింగ్ యొక్క నిర్వచనం."
lang: te
sidebarDepth: 2
---

Ethereum యొక్క ఎగ్జిక్యూషన్ క్లయింట్‌లలో రికర్సివ్ లెంగ్త్ ప్రిఫిక్స్ (RLP) సీరియలైజేషన్ విస్తృతంగా ఉపయోగించబడుతుంది. RLP స్పేస్-ఎఫెక్టివ్ ఫార్మాట్‌లో నోడ్‌ల మధ్య డేటా బదిలీని ప్రామాణికం చేస్తుంది. RLP యొక్క ఉద్దేశ్యం బైనరీ డేటా యొక్క ఏకపక్ష సమూహ శ్రేణులను ఎన్కోడ్ చేయడం మరియు Ethereum యొక్క ఎగ్జిక్యూషన్ లేయర్‌లోని వస్తువులను సీరియలైజ్ చేయడానికి ఉపయోగించే ప్రాథమిక ఎన్‌కోడింగ్ పద్ధతి RLP. RLP యొక్క ముఖ్య ఉద్దేశ్యం నిర్మాణాన్ని ఎన్కోడ్ చేయడం; ధనాత్మక పూర్ణాంకాల మినహా, RLP నిర్దిష్ట డేటా రకాలను (ఉదా., స్ట్రింగ్‌లు, ఫ్లోట్‌లు) ఎన్‌కోడింగ్ చేయడాన్ని ఉన్నత-శ్రేణి ప్రోటోకాల్స్‌కు అప్పగిస్తుంది. ధనాత్మక పూర్ణాంకాలు తప్పనిసరిగా పెద్ద-ఎండియన్ బైనరీ రూపంలో ప్రముఖ సున్నాలు లేకుండా సూచించబడాలి (అందువల్ల పూర్ణాంకం విలువ సున్నాని ఖాళీ బైట్ శ్రేణికి సమానం చేస్తుంది). RLPని ఉపయోగించి ఏదైనా అధిక-ఆర్డర్ ప్రోటోకాల్ ద్వారా లీడింగ్ జీరోలతో డీసీరియలైజ్డ్ పాజిటివ్ పూర్ణాంకాలు తప్పనిసరిగా చెల్లనివిగా పరిగణించబడతాయి.

[ఇతీరియము యెల్లో పేపర్ (అనుబంధం B)](https://ethereum.github.io/yellowpaper/paper.pdf#page=19)లో మరింత సమాచారం.

నిఘంటువును ఎన్‌కోడ్ చేయడానికి RLPని ఉపయోగించడానికి, సూచించబడిన రెండు నియమానుగుణ రూపాలు:

- లెక్సికోగ్రాఫిక్ క్రమంలో కీలతో `[[k1,v1],[k2,v2]...]`ని ఉపయోగించండి
- ethereum వలె ఉన్నత-స్థాయి ప్యాట్రిసియా ట్రీ ఎన్‌కోడింగ్‌ను ఉపయోగించండి

## నిర్వచనం {#definition}

RLP ఎన్‌కోడింగ్ ఫంక్షన్ ఒక అంశాన్ని తీసుకుంటుంది. ఒక అంశం క్రింది విధంగా నిర్వచించబడింది：

- ఒక స్ట్రింగ్ (అంటే, బైట్ శ్రేణి) ఒక ఐటెమ్
- వస్తువుల జాబితా ఒక అంశం
- ధన పూర్ణాంకం అనేది ఒక అంశం

ఉదాహరణకు, కిందివన్నీ అంశాలు:

- ఒక ఖాళీ స్ట్రింగ్;
- "పిల్లి" అనే పదాన్ని కలిగి ఉన్న స్ట్రింగ్;
- స్ట్రింగ్‌ల సంఖ్యను కలిగి ఉన్న జాబితా;
- మరియు `["పిల్లి", ["కుక్కపిల్ల", "ఆవు"], "గుర్రం", [[]], "పంది", [""], "గొర్రెలు"]` వంటి మరింత సంక్లిష్టమైన డేటా నిర్మాణాలు.
- సంఖ్య `100`

Note that in the context of the rest of this page, 'string' means "a certain number of bytes of binary data"; no special encodings are used, and no knowledge about the content of the strings is implied (except as required by the rule against non-minimal positive integers).

RLP ఎన్‌కోడింగ్ క్రింది విధంగా నిర్వచించబడింది:

- ధనాత్మక పూర్ణాంకం కోసం, ఇది పూర్ణాంకం అయిన పెద్ద-ఎండియన్ ఇంటర్‌ప్రెటేషన్‌తో కూడిన చిన్న బైట్ శ్రేణికి మార్చబడుతుంది మరియు దిగువ నిబంధనల ప్రకారం స్ట్రింగ్‌గా ఎన్‌కోడ్ చేయబడుతుంది.
- ఒక బైట్ విలువ `[0x00, 0x7f]` (దశాంశ `[0, 127]`) పరిధిలో ఉంటే, ఆ బైట్ దాని స్వంత RLP ఎన్‌కోడింగ్.
- లేకపోతే, ఒక స్ట్రింగ్ 0-55 బైట్ల పొడవు ఉంటే, RLP ఎన్‌కోడింగ్ అనేది **0x80** (dec. 128) విలువతో ఒకే బైట్‌ను కలిగి ఉంటుంది, దాని తర్వాత స్ట్రింగ్ యొక్క పొడవు, ఆ తర్వాత స్ట్రింగ్ ఉంటాయి. అందువల్ల మొదటి బైట్ యొక్క పరిధి `[0x80, 0xb7]` (dec. `[128, 183]`).
- ఒకవేళ స్ట్రింగ్ 55 బైట్‌ల కంటే ఎక్కువ పొడవు ఉంటే, RLP ఎన్‌కోడింగ్ ఒకే బైట్‌ను **0xb7** (dec. 183) విలువతో కలిగి ఉంటుంది, దాని తర్వాత బైనరీ రూపంలో స్ట్రింగ్ పొడవు యొక్క బైట్‌లలో పొడవు, దాని తర్వాత స్ట్రింగ్ పొడవు, చివరకు స్ట్రింగ్ ఉంటాయి. ఉదాహరణకు, 1024 బైట్ల పొడవున్న స్ట్రింగ్ `\xb9\x04\x00` (dec. `185, 4, 0`) గా ఎన్కోడ్ చేయబడి, దాని తర్వాత స్ట్రింగ్ ఉంటుంది. ఇక్కడ, మొదటి బైట్‌గా `0xb9` (183 + 2 = 185), దాని తర్వాత వాస్తవ స్ట్రింగ్ యొక్క పొడవును సూచించే 2 బైట్లు `0x0400` (dec. 1024) ఉంటాయి. అందువల్ల మొదటి బైట్ యొక్క పరిధి `[0xb8, 0xbf]` (dec. `[184, 191]`).
- ఒక బైట్ విలువ <0>[0x00, 0x7f]</0> (దశాంశ <0>[0, 127]</0>) పరిధిలో ఉంటే, ఆ బైట్ దాని స్వంత RLP ఎన్‌కోడింగ్.
- ఒక జాబితా యొక్క మొత్తం పేలోడ్ (అంటే, RLP ఎన్‌కోడ్ చేయబడుతున్న దాని అన్ని ఐటెమ్‌ల యొక్క కలిపిన పొడవు) 0-55 బైట్ల పొడవు ఉంటే, RLP ఎన్‌కోడింగ్ **0xc0** విలువతో కూడిన ఒకే బైట్, దాని తర్వాత పేలోడ్ పొడవు, చివరకు ఐటెమ్‌ల RLP ఎన్‌కోడింగ్‌ల కలయిక ఉంటాయి. అందువల్ల మొదటి బైట్ యొక్క పరిధి `[0xc0, 0xf7]` (dec. `[192, 247]`).
- ఒక జాబితా యొక్క మొత్తం పేలోడ్ 55 బైట్‌ల కంటే ఎక్కువ పొడవు ఉంటే, RLP ఎన్‌కోడింగ్ ఒకే బైట్‌ను **0xf7** విలువతో కలిగి ఉంటుంది, దాని తర్వాత బైనరీ రూపంలో పేలోడ్ పొడవు యొక్క బైట్‌లలో పొడవు, దాని తర్వాత పేలోడ్ పొడవు, చివరకు ఐటెమ్‌ల RLP ఎన్‌కోడింగ్‌ల కలయిక ఉంటాయి. అందువల్ల మొదటి బైట్ యొక్క పరిధి `[0xf8, 0xff]` (dec. `[248, 255]`).

కోడ్‌లో, ఇది:

```python
def rlp_encode(input):
    if isinstance(input,str):
        if len(input) == 1 and ord(input) < 0x80:
            return input
        return encode_length(len(input), 0x80) + input
    elif isinstance(input, list):
        output = ''
        for item in input:
            output += rlp_encode(item)
        return encode_length(len(output), 0xc0) + output

def encode_length(L, offset):
    if L < 56:
         return chr(L + offset)
    elif L < 256**8:
         BL = to_binary(L)
         return chr(len(BL) + offset + 55) + BL
    raise Exception("ఇన్‌పుట్ చాలా పొడవుగా ఉంది")

def to_binary(x):
    if x == 0:
        return ''
    return to_binary(int(x / 256)) + chr(x % 256)
```

## ఉదాహరణలు {#examples}

- స్ట్రింగ్ "కుక్క" = [0x83, 'd', 'o', 'g' ]
- జాబితా [ "పిల్లి", "కుక్క" ] = `[ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]`
- ఖాళీ స్ట్రింగ్ ('null') = `[ 0x80 ]`
- ఖాళీ జాబితా = `[ 0xc0 ]`
- పూర్ణాంకం 0 = `[ 0x80 ]`
- బైట్ '\\x00' = `[ 0x00 ]`
- బైట్ '\\x0f' = `[ 0x0f ]`
- బైట్లు '\\x04\\x00' = `[ 0x82, 0x04, 0x00 ]`
- మూడింటి [సెట్ సైద్ధాంతిక ప్రాతినిధ్యం](http://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers), `[ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]`
- స్ట్రింగ్ "Lorem ipsum dolor sit amet, consectetur adipisicing elit" = `[ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ...` , 'e', 'l', 'i', 't' ]`

## RLP డీకోడింగ్ {#rlp-decoding}

RLP ఎన్‌కోడింగ్ నియమాలు మరియు ప్రక్రియ ప్రకారం, RLP డీకోడ్ ఇన్‌పుట్ బైనరీ డేటా యొక్క శ్రేణిగా పరిగణించబడుతుంది. RLP డీకోడింగ్ ప్రక్రియ క్రింది విధంగా ఉంది:

1. ఇన్‌పుట్ డేటా యొక్క మొదటి బైట్ (అనగా ఉపసర్గ) ప్రకారం మరియు డేటా రకాన్ని డీకోడింగ్ చేయడం, వాస్తవ డేటా మరియు ఆఫ్‌సెట్ యొక్క పొడవు;

2. డేటా రకం మరియు ఆఫ్‌సెట్ ప్రకారం, సానుకూల పూర్ణాంకాల కోసం కనీస ఎన్‌కోడింగ్ నియమాన్ని గౌరవిస్తూ, డేటాను సంబంధితంగా డీకోడ్ చేయండి;

3. మిగిలిన ఇన్‌పుట్‌ను డీకోడ్ చేయడం కొనసాగించండి;

వాటిలో, డీకోడింగ్ డేటా రకాలు మరియు ఆఫ్‌సెట్ యొక్క నియమాలు క్రింది విధంగా ఉన్నాయి:

1. మొదటి బైట్ (అనగా, ఉపసర్గ) యొక్క పరిధి [0x00, 0x7f] అయితే డేటా ఒక స్ట్రింగ్ అవుతుంది, మరియు ఆ స్ట్రింగ్ ఖచ్చితంగా మొదటి బైట్ అవుతుంది;

2. మొదటి బైట్ పరిధి [0x80, 0xb7] అయితే డేటా స్ట్రింగ్ అవుతుంది మరియు మొదటి బైట్ మైనస్ 0x80కి సమానమైన స్ట్రింగ్ మొదటి బైట్‌ను అనుసరిస్తుంది;

3. మొదటి బైట్ పరిధి [0xb8, 0xbf] అయితే డేటా స్ట్రింగ్‌గా ఉంటుంది మరియు మొదటి బైట్‌కి సమానమైన బైట్‌ల పొడవు మైనస్ 0xb7 మొదటి బైట్‌కు సమానం మరియు స్ట్రింగ్ పొడవును అనుసరిస్తుంది తీగ;

4. మొదటి బైట్ పరిధి [0xc0, 0xf7] అయితే డేటా జాబితాగా ఉంటుంది మరియు మొత్తం పేలోడ్ మొదటి బైట్ మైనస్ 0xc0కి సమానమైన జాబితాలోని అన్ని అంశాల RLP ఎన్‌కోడింగ్‌ల కలయిక మొదటి బైట్‌ను అనుసరిస్తుంది;

5. మొదటి బైట్ పరిధి [0xf8, 0xff] అయితే డేటా జాబితాగా ఉంటుంది మరియు మొదటి బైట్ మైనస్ 0xf7కి సమానమైన లిస్ట్ యొక్క మొత్తం పేలోడ్ మొదటి బైట్‌ను అనుసరిస్తుంది మరియు అన్నింటి యొక్క RLP ఎన్‌కోడింగ్‌ల కలయిక జాబితా యొక్క అంశాలు జాబితా యొక్క మొత్తం పేలోడ్‌ను అనుసరిస్తాయి;

కోడ్‌లో, ఇది:

```python
def rlp_decode(input):
    if len(input) == 0:
        return
    output = ''
    (offset, dataLen, type) = decode_length(input)
    if type is str:
        output = instantiate_str(substr(input, offset, dataLen))
    elif type is list:
        output = instantiate_list(substr(input, offset, dataLen))
    output += rlp_decode(substr(input, offset + dataLen))
    return output

def decode_length(input):
    length = len(input)
    if length == 0:
        raise Exception("ఇన్‌పుట్ శూన్యం")
    prefix = ord(input[0])
    if prefix <= 0x7f:
        return (0, 1, str)
    elif prefix <= 0xb7 and length > prefix - 0x80:
        strLen = prefix - 0x80
        return (1, strLen, str)
    elif prefix <= 0xbf and length > prefix - 0xb7 and length > prefix - 0xb7 + to_integer(substr(input, 1, prefix - 0xb7)):
        lenOfStrLen = prefix - 0xb7
        strLen = to_integer(substr(input, 1, lenOfStrLen))
        return (1 + lenOfStrLen, strLen, str)
    elif prefix <= 0xf7 and length > prefix - 0xc0:
        listLen = prefix - 0xc0;
        return (1, listLen, list)
    elif prefix <= 0xff and length > prefix - 0xf7 and length > prefix - 0xf7 + to_integer(substr(input, 1, prefix - 0xf7)):
        lenOfListLen = prefix - 0xf7
        listLen = to_integer(substr(input, 1, lenOfListLen))
        return (1 + lenOfListLen, listLen, list)
    raise Exception("ఇన్‌పుట్ RLP ఎన్‌కోడింగ్ ఫారమ్‌కు అనుగుణంగా లేదు")

def to_integer(b):
    length = len(b)
    if length == 0:
        raise Exception("ఇన్‌పుట్ శూన్యం")
    elif length == 1:
        return ord(b[0])
    return ord(substr(b, -1)) + to_integer(substr(b, 0, -1)) * 256
```

## మరింత సమాచారం {#further-reading}

- [ఇతీరియములో RLP](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)
- [ఇతీరియము అండర్ ది హుడ్: RLP](https://medium.com/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58)
- [కోగ్లియో, ఎ. (2020). ACL2లో Ethereum యొక్క పునరావృత పొడవు ఉపసర్గ. arXiv ప్రీప్రింట్ arXiv:2009.13769.](https://arxiv.org/abs/2009.13769)

## సంబంధిత అంశాలు {#related-topics}

- [ప్యాట్రిసియా మెర్కిల్ ట్రై](/developers/docs/data-structures-and-encoding/patricia-merkle-trie)
