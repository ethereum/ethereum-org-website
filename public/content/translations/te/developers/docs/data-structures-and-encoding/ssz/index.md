---
title: "సాధారణ సీరియల్"
description: "Ethereum యొక్క SSZ ఫార్మాట్ యొక్క వివరణ."
lang: te
sidebarDepth: 2
---

**సింపుల్ సీరియలైజ్ (SSZ)** అనేది బీకాన్ చైన్‌లో ఉపయోగించే సీరియలైజేషన్ పద్ధతి. ఇది పీర్ డిస్కవరీ ప్రోటోకాల్ మినహా ఏకాభిప్రాయ పొర అంతటా ఎగ్జిక్యూషన్ లేయర్‌లో ఉపయోగించిన RLP సీరియలైజేషన్‌ను భర్తీ చేస్తుంది. RLP సీరియలైజేషన్ గురించి మరింత తెలుసుకోవడానికి, [రికర్సివ్-లెంగ్త్ ప్రిఫిక్స్ (RLP)](/developers/docs/data-structures-and-encoding/rlp/) చూడండి. SSZ నిర్ణయాత్మకంగా మరియు సమర్ధవంతంగా మెర్క్‌లైజ్ చేయడానికి రూపొందించబడింది. SSZ రెండు భాగాలను కలిగి ఉన్నట్లు భావించవచ్చు: సీరియలైజేషన్ స్కీమ్ మరియు సీరియలైజ్డ్ డేటా స్ట్రక్చర్‌తో సమర్థవంతంగా పని చేయడానికి రూపొందించబడిన మెర్క్‌లైజేషన్ స్కీమ్.

## SSZ ఎలా పని చేస్తుంది? {#how-does-ssz-work}

### సీరియలైజేషన్ {#serialization}

SSZ అనేది సీరియలైజేషన్ స్కీమ్, ఇది స్వీయ-వర్ణన కాదు - ఇది ముందుగా తెలుసుకోవలసిన స్కీమాపై ఆధారపడి ఉంటుంది. SSZ సీరియలైజేషన్ యొక్క లక్ష్యం ఏకపక్ష సంక్లిష్టత యొక్క వస్తువులను బైట్‌ల స్ట్రింగ్‌లుగా సూచించడం. ఇది "ప్రాథమిక రకాలు" కోసం చాలా సులభమైన ప్రక్రియ. మూలకం కేవలం హెక్సాడెసిమల్ బైట్‌లుగా మార్చబడుతుంది. ప్రాథమిక రకాలు ఉన్నాయి:

- సంతకం చేయని పూర్ణాంకాలు
- బూలియన్లు

సంక్లిష్టమైన "సమ్మిళిత" రకాల కోసం, సీరియలైజేషన్ మరింత క్లిష్టంగా ఉంటుంది, ఎందుకంటే మిశ్రమ రకం వివిధ రకాల లేదా విభిన్న పరిమాణాలు లేదా రెండింటినీ కలిగి ఉండే బహుళ మూలకాలను కలిగి ఉంటుంది. ఈ ఆబ్జెక్ట్‌లన్నింటికీ స్థిరమైన పొడవులు ఉన్నప్పుడు (అనగా, మూలకాల పరిమాణం వాటి వాస్తవ విలువలతో సంబంధం లేకుండా ఎల్లప్పుడూ స్థిరంగా ఉంటుంది), సీరియలైజేషన్ అనేది మిశ్రమ రకంలోని ప్రతి మూలకాన్ని లిటిల్-ఎండియన్ బైట్‌స్ట్రింగ్‌లుగా ఆర్డర్ చేసే ఒక సాధారణ మార్పిడి. ఈ బైటెస్ట్రింగ్‌లు కలిసి ఉంటాయి. సీరియలైజ్ చేయబడిన ఆబ్జెక్ట్‌లో స్థిర-పొడవు మూలకాల యొక్క బైటెలిస్ట్ ప్రాతినిధ్యాన్ని అవి డీరియలైజ్డ్ ఆబ్జెక్ట్‌లో కనిపించే క్రమంలోనే కలిగి ఉంటాయి.

వేరియబుల్ లెంగ్త్‌లతో ఉన్న రకాల కోసం, సీరియలైజ్డ్ ఆబ్జెక్ట్‌లో ఆ ఎలిమెంట్ స్థానంలో ఉన్న "ఆఫ్‌సెట్" విలువతో వాస్తవ డేటా భర్తీ చేయబడుతుంది. అసలు డేటా సీరియలైజ్ చేయబడిన ఆబ్జెక్ట్ చివరిలో కుప్పకు జోడించబడుతుంది. ఆఫ్‌సెట్ విలువ అనేది హీప్‌లోని వాస్తవ డేటా ప్రారంభానికి సూచిక, సంబంధిత బైట్‌లకు పాయింటర్‌గా పనిచేస్తుంది.

దిగువ ఉదాహరణ స్థిర మరియు వేరియబుల్-పొడవు అంశాలతో కూడిన కంటైనర్ కోసం ఆఫ్‌సెట్టింగ్ ఎలా పని చేస్తుందో వివరిస్తుంది:

```Rust

    struct Dummy {

        number1: u64,
        number2: u64,
        vector: Vec<u8>,
        number3: u64
    }

    dummy = Dummy{

        number1: 37,
        number2: 55,
        vector: vec![1,2,3,4],
        number3: 22,
    }

    serialized = ssz.serialize(dummy)

```

`సీరియలైజ్డ్` కింది నిర్మాణాన్ని కలిగి ఉంటుంది (ఇక్కడ 4 బిట్‌లకు మాత్రమే ప్యాడ్ చేయబడింది, వాస్తవానికి 32 బిట్‌లకు ప్యాడ్ చేయబడింది మరియు స్పష్టత కోసం `int` ప్రాతినిధ్యాన్ని ఉంచుతుంది):

```
[37, 0, 0, 0, 55, 0, 0, 0, 16, 0, 0, 0, 22, 0, 0, 0, 1, 2, 3, 4]
------------  -----------  -----------  -----------  ----------
      |             |            |           |            |
   number1       number2     వెక్టర్     number 3      వెక్టర్
                             ఆఫ్‌సెట్                    విలువ

```

స్పష్టత కోసం పంక్తుల ద్వారా విభజించబడింది:

```
[
  37, 0, 0, 0,  # `number1` యొక్క లిటిల్-ఎండియన్ ఎన్‌కోడింగ్.
  55, 0, 0, 0,  # `number2` యొక్క లిటిల్-ఎండియన్ ఎన్‌కోడింగ్.
  16, 0, 0, 0,  # `vector` యొక్క విలువ ఎక్కడ మొదలవుతుందో సూచించే "ఆఫ్‌సెట్" (లిటిల్-ఎండియన్ 16).
  22, 0, 0, 0,  # `number3` యొక్క లిటిల్-ఎండియన్ ఎన్‌కోడింగ్.
  1, 2, 3, 4,   # `vector` లోని వాస్తవ విలువలు.
]
```

ఇది ఇప్పటికీ ఒక సరళీకరణ - పైన ఉన్న స్కీమాటిక్స్‌లోని పూర్ణాంకాలు మరియు సున్నాలు వాస్తవానికి బైటెలిస్ట్‌లు ఇలా నిల్వ చేయబడతాయి:

```
[
  10100101000000000000000000000000  # `number1` యొక్క లిటిల్-ఎండియన్ ఎన్‌కోడింగ్
  10110111000000000000000000000000  # `number2` యొక్క లిటిల్-ఎండియన్ ఎన్‌కోడింగ్.
  10010000000000000000000000000000  # `vector` యొక్క విలువ ఎక్కడ మొదలవుతుందో సూచించే "ఆఫ్‌సెట్" (లిటిల్-ఎండియన్ 16).
  10010110000000000000000000000000  # `number3` యొక్క లిటిల్-ఎండియన్ ఎన్‌కోడింగ్.
  10000001100000101000001110000100   # `bytes` ఫీల్డ్ యొక్క వాస్తవ విలువ.
]
```

కాబట్టి వేరియబుల్-పొడవు రకాల కోసం వాస్తవ విలువలు సీరియలైజ్ చేయబడిన ఆబ్జెక్ట్ చివరిలో ఒక కుప్పలో నిల్వ చేయబడతాయి, వాటి ఆఫ్‌సెట్‌లు ఆర్డర్ చేసిన ఫీల్డ్‌ల జాబితాలో వాటి సరైన స్థానాల్లో నిల్వ చేయబడతాయి.

నిర్దిష్ట చికిత్స అవసరమయ్యే `BitList` రకం వంటి కొన్ని ప్రత్యేక సందర్భాలు కూడా ఉన్నాయి, సీరియలైజేషన్ సమయంలో పొడవు పరిమితిని జోడించి, డీరియలైజేషన్ సమయంలో తీసివేయాలి. పూర్తి వివరాలు [SSZ స్పెక్](https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md)లో అందుబాటులో ఉన్నాయి.

### డీసీరియలైజేషన్ {#deserialization}

ఈ వస్తువును డీరియలైజ్ చేయడానికి <b>స్కీమా</b> అవసరం. స్కీమా ధారావాహిక డేటా యొక్క ఖచ్చితమైన లేఅవుట్‌ను నిర్వచిస్తుంది, తద్వారా ప్రతి నిర్దిష్ట మూలకం సరైన రకం, విలువ, పరిమాణం మరియు స్థానం కలిగిన మూలకాలతో కొన్ని అర్ధవంతమైన వస్తువుగా బైట్‌ల బొట్టు నుండి డీరియలైజ్ చేయబడుతుంది. ఏ విలువలు వాస్తవ విలువలు మరియు ఏవి ఆఫ్‌సెట్‌లు అని డీరియలైజర్‌కు చెప్పే స్కీమా ఇది. ఆబ్జెక్ట్ సీరియలైజ్ చేయబడినప్పుడు అన్ని ఫీల్డ్ పేర్లు అదృశ్యమవుతాయి, కానీ స్కీమా ప్రకారం డీరియలైజేషన్‌లో పునరుద్ధరిస్తారు.

దీనిపై ఇంటరాక్టివ్ వివరణ కోసం [ssz.dev](https://www.ssz.dev/overview)ని చూడండి.

## మెర్కలైజేషన్ {#merkleization}

ఈ SSZ సీరియలైజ్డ్ ఆబ్జెక్ట్ అప్పుడు మెర్క్‌లైజ్ చేయబడుతుంది - అదే డేటా యొక్క మెర్కిల్-ట్రీ రిప్రజెంటేషన్‌గా రూపాంతరం చెందుతుంది. మొదట, సీరియలైజ్డ్ ఆబ్జెక్ట్‌లోని 32-బైట్ భాగాల సంఖ్య నిర్ణయించబడుతుంది. ఇవి చెట్టు యొక్క "ఆకులు". మొత్తం ఆకుల సంఖ్య తప్పనిసరిగా 2 పవర్ అయి ఉండాలి, తద్వారా ఆకులను కలిపి హ్యాష్ చేయడం వల్ల చివరికి ఒకే హ్యాష్-ట్రీ-రూట్ వస్తుంది. ఇది సహజంగా కాకపోతే, 32 బైట్‌ల సున్నాలను కలిగి ఉన్న అదనపు ఆకులు జోడించబడతాయి. రేఖాచిత్రంగా:

```
        హాష్ ట్రీ రూట్
            /     \
           /       \
          /         \
         /           \
   1, 2 ఆకుల హాష్  3, 4 ఆకుల హాష్
      /   \            /  \
     /     \          /    \
    /       \        /      \
 ఆకు1      ఆకు2    ఆకు3     ఆకు4
```

చెట్టు యొక్క ఆకులు పై ఉదాహరణలో చేసిన విధంగా సహజంగా సమానంగా పంపిణీ చేయని సందర్భాలు కూడా ఉన్నాయి. ఉదాహరణకు, లీఫ్ 4 అనేది మెర్కిల్ చెట్టుకు అదనపు "లోతు" జోడించాల్సిన బహుళ మూలకాలతో కూడిన కంటైనర్ కావచ్చు, ఇది అసమాన చెట్టును సృష్టిస్తుంది.

ఈ ట్రీ ఎలిమెంట్‌లను లీఫ్ X, నోడ్ X మొదలైనవిగా సూచించడానికి బదులుగా, మేము వాటికి రూట్ = 1తో ప్రారంభించి, ప్రతి స్థాయిలో ఎడమ నుండి కుడికి లెక్కించే సాధారణ సూచికలను ఇవ్వవచ్చు. ఇది పైన వివరించిన సాధారణ సూచిక. సీరియలైజ్ చేయబడిన జాబితాలోని ప్రతి మూలకం `2**depth + idx`కి సమానమైన సాధారణీకరించిన సూచికను కలిగి ఉంటుంది, ఇక్కడ idx అనేది సీరియలైజ్ చేయబడిన వస్తువులో దాని సున్నా-సూచిక స్థానం మరియు లోతు (depth) అనేది మెర్కిల్ ట్రీలోని స్థాయిల సంఖ్య, దీనిని మూలకాల సంఖ్య (ఆకులు) యొక్క బేస్-టూ సంవర్గమానంగా నిర్ణయించవచ్చు.

## సాధారణీకరించిన సూచికలు {#generalized-indices}

సాధారణీకరించిన సూచిక అనేది బైనరీ మెర్కిల్ ట్రీలోని ఒక నోడ్‌ను సూచించే పూర్ణాంకం, ఇక్కడ ప్రతి నోడ్ ఒక సాధారణీకరించిన సూచిక `2 ** depth + index in row`ను కలిగి ఉంటుంది.

```
        1           --లోతు (depth) = 0  2**0 + 0 = 1
    2       3       --లోతు (depth) = 1  2**1 + 0 = 2, 2**1+1 = 3
  4   5   6   7     --లోతు (depth) = 2  2**2 + 0 = 4, 2**2 + 1 = 5...

```

ఈ ప్రాతినిధ్యం మెర్కిల్ ట్రీలోని ప్రతి డేటా భాగానికి నోడ్ సూచికను అందిస్తుంది.

## మల్టీప్రూఫ్‌లు {#multiproofs}

నిర్దిష్ట మూలకాన్ని సూచించే సాధారణీకరించిన సూచికల జాబితాను అందించడం వలన హాష్-ట్రీ-రూట్‌కు వ్యతిరేకంగా దాన్ని ధృవీకరించడానికి మాకు అనుమతి లభిస్తుంది. ఈ రూట్ వాస్తవికత యొక్క మా అంగీకరించబడిన సంస్కరణ. మేము అందించిన ఏదైనా డేటా మెర్కిల్ ట్రీలో (దాని సాధారణీకరించిన సూచిక ద్వారా నిర్ణయించబడుతుంది) సరైన స్థలంలోకి చొప్పించడం ద్వారా మరియు రూట్ స్థిరంగా ఉందని గమనించడం ద్వారా ఆ వాస్తవికతకు వ్యతిరేకంగా ధృవీకరించబడుతుంది. ఒక నిర్దిష్ట సాధారణీకరించిన సూచికల సెట్ యొక్క కంటెంట్‌లను ధృవీకరించడానికి అవసరమైన నోడ్‌ల కనిష్ట సెట్‌ను ఎలా గణించాలో చూపించే ఫంక్షన్‌లు [ఇక్కడ](https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs) స్పెక్ లో ఉన్నాయి.

ఉదాహరణకు, దిగువ చెట్టులోని సూచిక 9లోని డేటాను ధృవీకరించడానికి, మాకు 8, 9, 5, 3, 1 సూచికల వద్ద డేటా యొక్క హాష్ అవసరం.
(8,9) యొక్క హాష్ హాష్ (4) కి సమానంగా ఉండాలి, ఇది 5తో 2ని ఉత్పత్తి చేయడానికి, 3తో హ్యాష్ చేస్తే ట్రీ రూట్ 1ని ఉత్పత్తి చేస్తుంది. 9 కోసం తప్పు డేటా అందించబడితే, రూట్ మారుతుంది - మేము దీన్ని గుర్తించి, బ్రాంచ్‌ని ధృవీకరించడంలో విఫలమవుతాము.

```
* = ప్రూఫ్ ఉత్పత్తి చేయడానికి అవసరమైన డేటా

                    1*
          2                      3*
    4          5*          6          7
8*     9*   10    11   12    13    14    15

```

## మరింత సమాచారం {#further-reading}

- [అప్‌గ్రేడింగ్ ఇతీరియము: SSZ](https://eth2book.info/altair/part2/building_blocks/ssz)
- [అప్‌గ్రేడింగ్ ఇతీరియము: మెర్కలైజేషన్](https://eth2book.info/altair/part2/building_blocks/merkleization)
- [SSZ ఇంప్లిమెంటేషన్‌లు](https://github.com/ethereum/consensus-specs/issues/2138)
- [SSZ కాలిక్యులేటర్](https://simpleserialize.com/)
- [SSZ.dev](https://www.ssz.dev/)
