---
title: Web3 రహస్య నిల్వ నిర్వచనం
description: Web3 రహస్య నిల్వ కోసం అధికారిక నిర్వచనం
lang: te
sidebarDepth: 2
---

Ethereumలో మీ యాప్ పని చేయడానికి, మీరు web3.js లైబ్రరీ అందించిన web3 ఆబ్జెక్ట్‌ని ఉపయోగించవచ్చు. హుడ్ కింద ఇది RPC కాల్‌ల ద్వారా లోకల్ నోడ్‌కి కమ్యూనికేట్ చేస్తుంది. [web3](https://github.com/ethereum/web3.js/) అనేది RPC లేయర్‌ను బహిర్గతం చేసే ఏదైనా ఎథేరియం నోడ్‌తో పని చేస్తుంది.

`web3`లో `eth` ఆబ్జెక్ట్ ఉంటుంది - web3.eth.

```js
var fs = require("fs")
var recognizer = require("ethereum-keyfile-recognizer")

fs.readFile("keyfile.json", (err, data) => {
  var json = JSON.parse(data)
  var result = recognizer(json)
})

/** ఫలితం
 *               [ 'web3', 3 ]   web3 (v3) కీఫైల్
 *  [ 'ethersale', undefined ]   ఈథర్‌సేల్ కీఫైల్
 *                        null     చెల్లని కీఫైల్
 */
```

ఈ పత్రంలో Web3 రహస్య నిల్వ నిర్వచనం యొక్క **వెర్షన్ 3** వివరించబడింది.

## నిర్వచనం {#definition}

క్రిప్టో అల్గోరిథం ఇకపై AES-128-CBC (AES-128-CTR అనేది ఇప్పుడు కనీస అవసరం) కి స్థిరంగా ఉండదు తప్ప, ఫైల్ యొక్క వాస్తవ ఎన్‌కోడింగ్ మరియు డీకోడింగ్ వెర్షన్ 1 నుండి చాలా వరకు మారదు. `mac` మినహా, చాలా అర్థాలు/అల్గారిథం వెర్షన్ 1ని పోలి ఉంటాయి. `mac` అనేది, ఉత్పన్నమైన కీ యొక్క ఎడమవైపు నుంచి రెండవ 16 బైట్‌లను పూర్తి `ciphertext`తో కలిపినప్పుడు వచ్చే కలయికకు SHA3 (keccak-256)గా ఇవ్వబడింది.

రహస్య కీ ఫైల్‌లు నేరుగా `~/.web3/keystore` (యూనిక్స్-లాంటి సిస్టమ్‌ల కోసం) మరియు `~/AppData/Web3/keystore` (విండోస్ కోసం)లో నిల్వ చేయబడతాయి. వాటికి ఏ పేరైనా పెట్టవచ్చు, కానీ `<uuid>.json` అనేది ఒక మంచి పద్ధతి, ఇక్కడ `<uuid>` అనేది రహస్య కీకి ఇవ్వబడిన 128-బిట్ UUID (రహస్య కీ చిరునామా కొరకు గోప్యతను కాపాడే ఒక ప్రాక్సీ).

అటువంటి అన్ని ఫైల్‌లు అనుబంధిత పాస్‌వర్డ్‌ను కలిగి ఉంటాయి. ఇవ్వబడిన `.json` ఫైల్ యొక్క రహస్య కీని పొందేందుకు, ముందుగా ఫైల్ యొక్క ఎన్‌క్రిప్షన్ కీని పొందాలి; `kdf` కీ ద్వారా వివరించిన విధంగా, ఫైల్ పాస్‌వర్డ్‌ను తీసుకొని దానిని కీ డెరివేషన్ ఫంక్షన్ ద్వారా పంపడం ద్వారా ఇది జరుగుతుంది. KDF ఫంక్షన్‌కు అవసరమైన KDF-ఆధారిత స్టాటిక్, డైనమిక్ పారామీటర్‌లు `kdfparams` కీలో వివరించబడ్డాయి.

PBKDF2కి అన్ని కనిష్ట-కంప్లైంట్ ఇంప్లిమెంటేషన్‌లు తప్పక మద్దతివ్వాలి, అయితే సూచిస్తారు:

- `kdf`: `pbkdf2`

PBKDF2 కోసం, kdfparams ఉన్నాయి:

- `prf`: తప్పనిసరిగా `hmac-sha256` అయి ఉండాలి (భవిష్యత్తులో పొడిగించవచ్చు);
- `c`: పునరావృతాల సంఖ్య;
- `salt`: PBKDFకు పంపిన సాల్ట్;
- `dklen`: ఉత్పన్నమైన కీ కోసం పొడవు. తప్పనిసరిగా >= 32 అయి ఉండాలి.

ఫైల్ యొక్క కీని పొందిన తర్వాత, అది MAC యొక్క ఉత్పన్నం ద్వారా ధృవీకరించబడాలి. `ciphertext` కీ యొక్క కంటెంట్‌లతో ఉత్పన్నమైన కీ యొక్క ఎడమవైపు నుండి రెండవ 16 బైట్‌లను అనుసంధానం చేయగా ఏర్పడిన బైట్ అర్రే యొక్క SHA3 (keccak-256) హాష్‌గా MACని లెక్కించాలి, అనగా:

```js
KECCAK(DK[16..31] ++ <ciphertext>)
```

(ఇక్కడ `++` అనేది అనుసంధాన ఆపరేటర్)

ఈ విలువను `mac` కీ యొక్క కంటెంట్‌లతో పోల్చాలి; అవి భిన్నంగా ఉంటే, ప్రత్యామ్నాయ పాస్‌వర్డ్‌ను అభ్యర్థించాలి (లేదా ఆపరేషన్‌ను రద్దు చేయాలి).

ఫైల్ కీని ధృవీకరించిన తర్వాత, సైఫర్ టెక్స్ట్‌ను (ఫైల్‌లోని `ciphertext` కీ) డీక్రిప్ట్ చేయవచ్చు. దీనికోసం `cipher` కీ ద్వారా పేర్కొనబడిన మరియు `cipherparams` కీ ద్వారా పారామీటరైజ్ చేయబడిన సిమెట్రిక్ ఎన్‌క్రిప్షన్ అల్గారిథం ఉపయోగించబడుతుంది. ఉత్పన్నమైన కీ పరిమాణం మరియు అల్గోరిథం యొక్క కీ పరిమాణం సరిపోలకపోతే, సున్నా ప్యాడ్ చేయబడిన, ఉత్పన్నమైన కీ యొక్క కుడివైపు బైట్‌లను అల్గారిథమ్‌కి కీగా ఉపయోగించాలి.

అన్ని కనిష్టంగా-అనుకూలమైన అమలులు తప్పనిసరిగా AES-128-CTR అల్గారిథమ్‌కు మద్దతు ఇవ్వాలి, దీని ద్వారా సూచించబడతాయి:

- `cipher: aes-128-ctr`

ఈ సాంకేతికలిపి కింది పారామితులను తీసుకుంటుంది, సైఫర్‌పారమ్స్ కీకి కీలుగా ఇవ్వబడింది:

- `iv`: సైఫర్ కోసం 128-బిట్ ఇనిషియలైజేషన్ వెక్టర్.

సైఫర్ కోసం కీ అనేది ఉత్పన్నమైన కీ యొక్క ఎడమవైపున ఉన్న 16 బైట్‌లు, అనగా `DK[0..15]`

రహస్య కీ యొక్క సృష్టి/ఎన్‌క్రిప్షన్ తప్పనిసరిగా ఈ సూచనలకు విరుద్ధంగా ఉండాలి. `uuid`, `salt` మరియు `iv` వాస్తవానికి యాదృచ్ఛికంగా ఉన్నాయని నిర్ధారించుకోండి.

`version` ఫీల్డ్‌తో పాటు, ఇది వెర్షన్ యొక్క "హార్డ్" ఐడెంటిఫైయర్‌గా పనిచేయాలి, ఫార్మాట్‌లోని చిన్న, నాన్-బ్రేకింగ్ మార్పులను ట్రాక్ చేయడానికి ఇంప్లిమెంటేషన్‌లు `minorversion`ను కూడా ఉపయోగించవచ్చు.

## టెస్ట్ వెక్టార్‌లు {#test-vectors}

వివరాలు:

- `Address`: `008aeeda4d805471df9b2a5b0f38a0c3bcba786b`
- `ICAP`: `XE542A5PZHH8PYIZUBEJEO0MFWRAPPIL67`
- `UUID`: `3198bc9c-6672-5ab3-d9954942343ae5b6`
- `Password`: `testpassword`
- `Secret`: `7a28b5ba57c53603b0b07b56bba752f7784bf506fa95edc395f5cf6c7514fe9d`

### PBKDF2-SHA-256 {#PBKDF2-SHA-256}

`AES-128-CTR` మరియు `PBKDF2-SHA-256` ఉపయోగించే టెస్ట్ వెక్టార్:

`~/.web3/keystore/3198bc9c-6672-5ab3-d9954942343ae5b6.json` ఫైల్ కంటెంట్‌లు:

```json
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "6087dab2f9fdbbfaddc31a909735c1e6"
    },
    "ciphertext": "5318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46",
    "kdf": "pbkdf2",
    "kdfparams": {
      "c": 262144,
      "dklen": 32,
      "prf": "hmac-sha256",
      "salt": "ae3cd4e7013836a3df6bd7241b12db061dbe2c6785853cce422d148a624ce0bd"
    },
    "mac": "517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2"
  },
  "id": "3198bc9c-6672-5ab3-d995-4942343ae5b6",
  "version": 3
}
```

**మధ్యంతర విలువలు**:

`ఉత్పన్న కీ`: `f06d69cdc7da0faffb1008270bca38f5e31891a3a773950e6d0fea48a7188551`
`MAC బాడీ`: `e31891a3a773950e6d0fea48a71885515318b4d5bcd28de64ee5559e671353e16f075ecae9f99c7a79a38af5f869aa46`
`MAC`: `517ead924a9d0dc3124507e3393d175ce3ff7c1e96529c6c555ce9e51205e9b2`
`సైఫర్ కీ`: `f06d69cdc7da0faffb1008270bca38f5`

### Scrypt {#scrypt}

AES-128-CTR మరియు స్క్రిప్ట్ ఉపయోగించి వెక్టార్‌ని పరీక్షించండి:

```json
{
  "crypto": {
    "cipher": "aes-128-ctr",
    "cipherparams": {
      "iv": "740770fce12ce862af21264dab25f1da"
    },
    "ciphertext": "dd8a1132cf57db67c038c6763afe2cbe6ea1949a86abc5843f8ca656ebbb1ea2",
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 1,
      "r": 8,
      "salt": "25710c2ccd7c610b24d068af83b959b7a0e5f40641f0c82daeb1345766191034"
    },
    "mac": "337aeb86505d2d0bb620effe57f18381377d67d76dac1090626aa5cd20886a7c"
  },
  "id": "3198bc9c-6672-5ab3-d995-4942343ae5b6",
  "version": 3
}
```

**మధ్యంతర విలువలు**:

`ఉత్పన్న కీ`: `7446f59ecc301d2d79bc3302650d8a5cedc185ccbb4bf3ca1ebd2c163eaa6c2d`
`MAC బాడీ`: `edc185ccbb4bf3ca1ebd2c163eaa6c2ddd8a1132cf57db67c038c6763afe2cbe6ea1949a86abc5843f8ca656ebbb1ea2`
`MAC`: `337aeb86505d2d0bb620effe57f18381377d67d76dac1090626aa5cd20886a7c`
`సైఫర్ కీ`: `7446f59ecc301d2d79bc3302650d8a5c`

## వెర్షన్ 1 నుండి మార్పులు {#alterations-from-v2}

ఈ వెర్షన్, [ఇక్కడ](https://github.com/ethereum/homestead-guide/blob/master/old-docs-for-reference/go-ethereum-wiki.rst/Passphrase-protected-key-store-spec.rst) ప్రచురించిన వెర్షన్ 1తో ఉన్న అనేక అస్థిరతలను సరిచేస్తుంది. క్లుప్తంగా ఇవి:

- క్యాపిటలైజేషన్ అన్యాయమైనది మరియు అస్థిరమైనది (స్క్రిప్ట్ చిన్న అక్షరం, Kdf మిశ్రమ-కేస్, MAC పెద్ద అక్షరం).
- అనవసరమైన చిరునామా మరియు గోప్యతను రాజీ చేస్తుంది.
- `Salt` అనేది అంతర్గతంగా కీ డెరివేషన్ ఫంక్షన్ యొక్క పరామితి, కాబట్టి దానితోనే అనుబంధించబడాలి కానీ సాధారణంగా క్రిప్టోతో కాదు.
- _SaltLen_ అనవసరం (దానిని Salt నుండి ఉత్పాదించండి).
- కీ డెరివేషన్ ఫంక్షన్ ఇవ్వబడింది, అయినప్పటికీ క్రిప్టో అల్గోరిథం గట్టిగా పేర్కొనబడింది.
- `Version` అంతర్గతంగా సంఖ్యాపరమైనది అయినప్పటికీ అది ఒక స్ట్రింగ్ (స్ట్రింగ్‌తో స్ట్రక్చర్డ్ వెర్షనింగ్ సాధ్యమే, కానీ అరుదుగా మారే కాన్ఫిగరేషన్ ఫైల్ ఫార్మాట్ విషయంలో దీనిని పరిధికి వెలుపల ఉన్నట్లుగా పరిగణించవచ్చు).
- `KDF` మరియు `cipher` భావనాత్మకంగా ఒకే రకమైన భావనలు అయినప్పటికీ, అవి విభిన్నంగా నిర్వహించబడ్డాయి.
- `MAC` అనేది వైట్‌స్పేస్‌తో సంబంధంలేని డేటా ముక్క నుండి లెక్కించబడుతుంది(!)

కింది ఫైల్‌ను అందించడానికి ఫార్మాట్‌లో మార్పులు చేయబడ్డాయి, ఇది మునుపు లింక్ చేసిన పేజీలో ఇచ్చిన ఉదాహరణకి క్రియాత్మకంగా సమానం:

```json
{
  "crypto": {
    "cipher": "aes-128-cbc",
    "ciphertext": "07533e172414bfa50e99dba4a0ce603f654ebfa1ff46277c3e0c577fdc87f6bb4e4fe16c5a94ce6ce14cfa069821ef9b",
    "cipherparams": {
      "iv": "16d67ba0ce5a339ff2f07951253e6ba8"
    },
    "kdf": "scrypt",
    "kdfparams": {
      "dklen": 32,
      "n": 262144,
      "p": 1,
      "r": 8,
      "salt": "06870e5e6a24e183a5c807bd1c43afd86d573f7db303ff4853d135cd0fd3fe91"
    },
    "mac": "8ccded24da2e99a11d48cda146f9cc8213eb423e2ea0d8427f41c3be414424dd",
    "version": 1
  },
  "id": "0498f19a-59db-4d54-ac95-33901b4f1870",
  "version": 2
}
```

## వెర్షన్ 2 నుండి మార్పులు {#alterations-from-v2}

సంస్కరణ 2 అనేక బగ్‌లతో ప్రారంభ C++ అమలు. అన్ని అవసరమైన వస్తువులు దాని నుండి మారవు.
