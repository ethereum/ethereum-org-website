---
title: 버클 트리
description: Verkle 트리에 대한 개괄적인 설명과 이더리움 업그레이드에 Verkle 트리가 어떻게 사용될지에 대한 설명
lang: ko
summaryPoints:
  - Verkle 트리가 무엇인지 알아보기
  - Verkle 트리가 이더리움에 유용한 업그레이드인 이유 알아보기
---

# Verkle 트리 {#verkle-trees}

Verkle 트리("벡터 커밋먼트"와 "머클 트리"의 혼성어)는 이더리움 노드를 업그레이드하여 블록 검증 기능을 유지하면서도 대량의 상태 데이터를 저장하지 않도록 하는 데 사용할 수 있는 데이터 구조입니다.

## 무상태성 {#statelessness}

Verkle 트리는 무상태 이더리움 클라이언트로 나아가는 데 중요한 단계입니다. 무상태 클라이언트는 수신 블록을 검증하기 위해 전체 상태 데이터베이스를 저장할 필요가 없는 클라이언트입니다. 무상태 클라이언트는 이더리움 상태의 로컬 사본을 사용해 블록을 검증하는 대신 블록과 함께 도착하는 상태 데이터에 대한 "위트니스"를 사용합니다. 위트니스는 특정 트랜잭션 세트를 실행하는 데 필요한 개별 상태 데이터 조각의 모음이며, 위트니스가 실제로 전체 데이터의 일부라는 암호화 증명입니다. 위트니스는 상태 데이터베이스 _대신_ 사용됩니다. 이것이 작동하려면 위트니스가 매우 작아야 검증자가 12초 슬롯 내에 안전하게 처리할 수 있도록 네트워크를 통해 제때 브로드캐스트될 수 있습니다. 현재 상태 데이터 구조는 위트니스가 너무 커서 적합하지 않습니다. Verkle 트리는 작은 위트니스를 가능하게 하여 이 문제를 해결하고, 무상태 클라이언트로 나아가는 데 있어 주요 장벽 중 하나를 제거합니다.

<ExpandableCard title="Why do we want stateless clients?" eventCategory="/roadmap/verkle-trees" eventName="clicked why do we want stateless clients?">

이더리움 클라이언트는 현재 상태 데이터를 저장하기 위해 패트리샤 머클 트라이로 알려진 데이터 구조를 사용합니다. 개별 계정에 대한 정보는 트라이의 리프(leaf)로 저장되며, 단일 해시가 남을 때까지 리프 쌍이 반복적으로 해시 처리됩니다. 이 최종 해시는 "루트"라고 합니다. 블록을 검증하기 위해 이더리움 클라이언트는 블록의 모든 트랜잭션을 실행하고 로컬 상태 트라이를 업데이트합니다. 로컬 트리의 루트가 블록 제안자가 제공한 루트와 동일한 경우 블록은 유효한 것으로 간주됩니다. 블록 제안자와 검증 노드가 수행한 계산에 차이가 있으면 루트 해시가 완전히 달라지기 때문입니다. 이 문제점은 블록체인을 검증하려면 각 클라이언트가 헤드 블록과 여러 과거 블록(Geth의 기본값은 헤드에서 128개 블록 뒤의 상태 데이터를 유지하는 것)에 대한 전체 상태 트라이를 저장해야 한다는 것입니다. 이로 인해 클라이언트는 많은 양의 디스크 공간에 액세스해야 하며, 이는 저렴한 저전력 하드웨어에서 풀노드를 실행하는 데 장벽이 됩니다. 이에 대한 해결책은 전체 상태 데이터 대신 공유할 수 있는 데이터에 대한 작은 "위트니스"를 사용하여 요약할 수 있는 보다 효율적인 구조(Verkle 트리)로 상태 트라이를 업데이트하는 것입니다. 상태 데이터를 Verkle 트리로 재구성하는 것은 무상태 클라이언트로 이동하기 위한 디딤돌입니다.

</ExpandableCard>

## 위트니스란 무엇이며 왜 필요한가요? {#what-is-a-witness}

블록을 검증한다는 것은 블록에 포함된 트랜잭션을 다시 실행하고, 변경 사항을 이더리움의 상태 트라이에 적용하며, 새로운 루트 해시를 계산하는 것을 의미합니다. 검증된 블록은 계산된 상태 루트 해시가 블록과 함께 제공된 것과 동일한 블록입니다(블록 제안자가 자신이 했다고 말한 계산을 실제로 수행했음을 의미하기 때문입니다). 오늘날의 이더리움 클라이언트에서 상태를 업데이트하려면 로컬에 저장해야 하는 대규모 데이터 구조인 전체 상태 트라이에 액세스해야 합니다. 위트니스는 블록의 트랜잭션을 실행하는 데 필요한 상태 데이터의 조각만 포함합니다. 그런 다음 검증자는 해당 조각만 사용하여 블록 제안자가 블록 트랜잭션을 실행하고 상태를 올바르게 업데이트했는지 확인할 수 있습니다. 그러나 이는 위트니스가 이더리움 네트워크의 피어 간에 각 노드가 12초 슬롯 내에서 안전하게 수신하고 처리할 수 있을 만큼 충분히 빠르게 전송되어야 함을 의미합니다. 위트니스가 너무 크면 일부 노드에서 이를 다운로드하고 체인을 따라잡는 데 너무 오랜 시간이 걸릴 수 있습니다. 이는 빠른 인터넷 연결을 가진 노드만 블록 검증에 참여할 수 있음을 의미하기 때문에 중앙 집중화 요인으로 작용합니다. Verkle 트리를 사용하면 상태를 하드 드라이브에 저장할 필요가 없습니다. 블록을 검증하는 데 필요한 _모든 것_이 블록 자체에 포함되어 있습니다. 안타깝게도 머클 트라이에서 생성할 수 있는 위트니스는 너무 커서 무상태 클라이언트를 지원할 수 없습니다.

## Verkle 트리는 어떻게 더 작은 위트니스를 가능하게 할까요? {#why-do-verkle-trees-enable-smaller-witnesses}

머클 트라이의 구조는 위트니스 크기를 매우 크게 만듭니다. 12초 슬롯 내에서 피어 간에 안전하게 브로드캐스트하기에는 너무 큽니다. 이는 위트니스가 리프에 보관된 데이터를 루트 해시에 연결하는 경로이기 때문입니다. 데이터를 확인하려면 각 리프를 루트에 연결하는 모든 중간 해시뿐만 아니라 모든 "형제" 노드도 있어야 합니다. 증명의 각 노드에는 트라이 위로 다음 해시를 만들기 위해 함께 해시되는 형제가 있습니다. 이는 많은 양의 데이터입니다. Verkle 트리는 트리의 리프와 루트 사이의 거리를 단축하고 루트 해시를 확인하기 위해 형제 노드를 제공할 필요를 없앰으로써 위트니스 크기를 줄입니다. 해시 스타일 벡터 커밋먼트 대신 강력한 다항식 커밋먼트 방식을 사용하면 공간 효율성을 더욱 높일 수 있습니다. 다항식 커밋먼트를 사용하면 위트니스가 증명하는 리프 수에 관계없이 고정된 크기를 가질 수 있습니다.

다항식 커밋먼트 방식에서 위트니스는 P2P 네트워크에서 쉽게 전송할 수 있는 관리 가능한 크기를 갖습니다. 이를 통해 클라이언트는 최소한의 데이터로 각 블록의 상태 변경을 확인할 수 있습니다.

<ExpandableCard title="Exactly how much can Verkle trees reduce witness size?" eventCategory="/roadmap/verkle-trees" eventName="clicked exactly how much can Verkle trees reduce witness size?">

위트니스 크기는 포함하는 리프 수에 따라 다릅니다. 위트니스가 1000개의 리프를 포함한다고 가정하면 머클 트라이에 대한 위트니스는 약 3.5MB가 됩니다(트라이에 7개의 레벨이 있다고 가정). Verkle 트리의 동일한 데이터에 대한 위트니스(트리에 4개의 레벨이 있다고 가정)는 약 150 kB가 되어 **약 23배 더 작습니다**. 이렇게 위트니스 크기가 줄어들면 무상태 클라이언트 위트니스를 허용 가능한 수준으로 작게 만들 수 있습니다. 다항식 위트니스는 어떤 특정 다항식 커밋먼트가 사용되는지에 따라 0.128 -1 kB입니다.

</ExpandableCard>

## Verkle 트리의 구조는 무엇인가요? {#what-is-the-structure-of-a-verkle-tree}

Verkle 트리는 `(키, 값)` 쌍으로, 키는 31바이트 _스템_과 단일 바이트 _서픽스_로 구성된 32바이트 요소입니다. 이러한 키는 _확장_ 노드와 _내부_ 노드로 구성됩니다. 확장 노드는 다른 서픽스를 가진 256개의 자식에 대한 단일 스템을 나타냅니다. 내부 노드에도 256개의 자식이 있지만 다른 확장 노드가 될 수 있습니다. Verkle 트리와 머클 트리 구조의 주요 차이점은 Verkle 트리가 훨씬 더 평평하다는 것입니다. 즉, 리프를 루트에 연결하는 중간 노드가 더 적어 증명을 생성하는 데 필요한 데이터가 더 적다는 의미입니다.

![](./verkle.png)

[Verkle 트리 구조에 대해 자세히 알아보기](https://blog.ethereum.org/2021/12/02/verkle-tree-structure)

## 현재 진행 상황 {#current-progress}

Verkle 트리 테스트넷은 이미 가동 중이지만, Verkle 트리를 지원하는 데 필요한 클라이언트에 대한 상당한 미처리 업데이트가 아직 남아 있습니다. 테스트넷에 계약을 배포하거나 테스트넷 클라이언트를 실행하여 진행 속도를 높이는 데 도움을 줄 수 있습니다.

[Guillaume Ballet의 Condrieu Verkle 테스트넷 설명 보기](https://www.youtube.com/watch?v=cPLHFBeC0Vg) (Condrieu 테스트넷은 작업증명 방식이었으며 현재 Verkle Gen Devnet 6 테스트넷으로 대체되었습니다).

## 더 읽어보기 {#further-reading}

- [무상태성을 위한 Verkle 트리](https://verkle.info/)
- [PEEPanEIP에서 Verkle 트리를 설명하는 Dankrad Feist](https://www.youtube.com/watch?v=RGJOQHzg3UQ)
- [우리가 알아야 할 Verkle 트리](https://web.archive.org/web/20250124132255/https://research.2077.xyz/verkle-trees)
- [Verkle 증명 해부](https://ihagopian.com/posts/anatomy-of-a-verkle-proof)
- [ETHGlobal에서 Verkle 트리를 설명하는 Guillaume Ballet](https://www.youtube.com/watch?v=f7bEtX3Z57o)
- [Devcon 6에서 Guillaume Ballet 발표: "Verkle 트리가 이더리움을 어떻게 가볍고 효율적으로 만드는가"](https://www.youtube.com/watch?v=Q7rStTKwuYs)
- [ETHDenver 2020에서 Piper Merriam이 말하는 무상태 클라이언트](https://www.youtube.com/watch?v=0yiZJNciIJ4)
- [Zero Knowledge 팟캐스트에서 Verkle 트리와 무상태성을 설명하는 Dankrad Fiest](https://zeroknowledge.fm/podcast/202/)
- [Verkle 트리에 대한 Vitalik Buterin의 글](https://vitalik.eth.limo/general/2021/06/18/verkle.html)
- [Verkle 트리에 대한 Dankrad Feist의 글](https://dankradfeist.de/ethereum/2021/06/18/verkle-trie-for-eth1.html)
- [Verkle 트리 EIP 문서](https://notes.ethereum.org/@vbuterin/verkle_tree_eip#Illustration)
