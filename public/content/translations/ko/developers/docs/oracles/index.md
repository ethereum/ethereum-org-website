---
title: 오라클
description: 오라클은 이더리움 스마트 계약에 실제 세계 데이터에 대한 액세스를 제공하여 사용자에게 더 많은 사용 사례와 더 큰 가치를 제공합니다.
lang: ko
---

오라클은 스마트 계약을 위해 오프체인 데이터 소스를 블록체인에서 사용할 수 있도록 하는 데이터 피드를 생성하는 애플리케이션입니다. 이는 이더리움 기반 스마트 계약이 기본적으로 블록체인 네트워크 외부에 저장된 정보에 액세스할 수 없기 때문에 필요합니다.

스마트 계약에 오프체인 데이터를 사용하여 실행할 수 있는 기능을 제공하면 탈중앙화 애플리케이션의 유용성과 가치가 확장됩니다. 예를 들어, 온체인 예측 시장은 오라클에 의존하여 사용자 예측을 검증하는 데 사용하는 결과에 대한 정보를 제공합니다. Alice가 차기 미국 대통령이 될 사람에게 20 ETH를 걸었다고 가정해 보겠습니다. 대통령. 이 경우 예측 시장 탈중앙화앱은 선거 결과를 확인하고 Alice가 지불금을 받을 자격이 있는지 판단하기 위해 오라클이 필요합니다.

## 필수 구성 요소 {#prerequisites}

이 페이지에서는 독자가 [노드](/developers/docs/nodes-and-clients/), [합의 메커니즘](/developers/docs/consensus-mechanisms/), [EVM](/developers/docs/evm/)을 비롯한 이더리움의 기본 사항에 익숙하다고 가정합니다. [스마트 계약](/developers/docs/smart-contracts/) 및 [스마트 계약 구조](/developers/docs/smart-contracts/anatomy/), 특히 [이벤트](/glossary/#events)에 대해서도 잘 이해하고 있어야 합니다.

## 블록체인 오라클이란 무엇인가요? {#what-is-a-blockchain-oracle}

오라클은 외부 정보(즉, 오프체인에 저장된 정보)를 소싱, 확인 및 블록체인에서 실행되는 스마트 계약으로 전송하는 애플리케이션입니다. 오라클은 오프체인 데이터를 '가져와' 이더리움에 브로드캐스팅하는 것 외에도, 블록체인에서 외부 시스템으로 정보를 '푸시'할 수도 있습니다(예: 사용자가 이더리움 트랜잭션을 통해 수수료를 보내면 스마트 잠금을 해제하는 경우).

오라클이 없다면 스마트 계약은 전적으로 온체인 데이터에만 국한될 것입니다.

오라클은 데이터 소스(단일 또는 다중 소스), 신뢰 모델(중앙화 또는 탈중앙화), 시스템 아키텍처(즉시 읽기, 게시-구독 및 요청-응답)에 따라 다릅니다. 또한 오라클이 온체인 계약에서 사용할 외부 데이터를 검색하는지(입력 오라클), 블록체인에서 오프체인 애플리케이션으로 정보를 보내는지(출력 오라클), 오프체인에서 계산 작업을 수행하는지(계산 오라클)에 따라 오라클을 구별할 수도 있습니다.

## 스마트 계약에 오라클이 필요한 이유는 무엇인가요? {#why-do-smart-contracts-need-oracles}

많은 개발자는 스마트 계약을 블록체인의 특정 주소에서 실행되는 코드로 봅니다. 그러나 [스마트 계약에 대한 보다 일반적인 견해](/smart-contracts/)는 특정 조건이 충족되면 당사자 간의 계약을 시행할 수 있는 자체 실행 소프트웨어 프로그램이라는 것입니다. 따라서 '스마트 계약'이라는 용어가 사용됩니다.

그러나 이더리움이 결정적이라는 점을 감안할 때 사람들 간의 계약을 시행하기 위해 스마트 계약을 사용하는 것은 간단하지 않습니다. [결정론적 시스템](https://en.wikipedia.org/wiki/Deterministic_algorithm)은 초기 상태와 특정 입력이 주어지면 항상 동일한 결과를 생성하는 시스템으로, 입력에서 출력을 계산하는 과정에 무작위성이나 변이가 없음을 의미합니다.

결정론적 실행을 달성하기 위해 블록체인은 노드가 블록체인 자체에 저장된 데이터_만_을 사용하여 간단한 이진(참/거짓) 질문에 대한 합의에 도달하도록 제한합니다. 이러한 질문의 예는 다음과 같습니다.

- “계정 소유자(공개 키로 식별)가 페어링된 개인 키로 이 트랜잭션에 서명했나요?”
- “이 계정에 트랜잭션을 처리할 충분한 자금이 있나요?”
- “이 트랜잭션은 이 스마트 계약의 맥락에서 유효한가요?” 등.

블록체인이 외부 소스(즉, 현실 세계)로부터 정보를 받는다면 결정론을 달성하는 것이 불가능해져 노드가 블록체인 상태 변경의 유효성에 대해 합의하는 것을 막게 됩니다. 기존 가격 API에서 얻은 현재 ETH-USD 환율을 기반으로 트랜잭션을 실행하는 스마트 계약을 예로 들어 보겠습니다. 이 수치는 자주 변경될 가능성이 있으며(API가 더 이상 사용되지 않거나 해킹될 수 있다는 점은 말할 것도 없음), 이는 동일한 계약 코드를 실행하는 노드가 다른 결과에 도달한다는 것을 의미합니다.

전 세계 수천 개의 노드가 트랜잭션을 처리하는 이더리움과 같은 퍼블릭 블록체인의 경우 결정론이 중요합니다. 진실의 원천 역할을 하는 중앙 권한이 없으면 노드는 동일한 트랜잭션을 적용한 후 동일한 상태에 도달하기 위한 메커니즘이 필요합니다. 노드 A가 스마트 계약 코드를 실행하여 결과로 '3'을 얻고, 노드 B가 동일한 트랜잭션을 실행한 후 '7'을 얻는 경우는 합의를 깨뜨리고 탈중앙화 컴퓨팅 플랫폼으로서의 이더리움의 가치를 없앨 것입니다.

이 시나리오는 또한 외부 소스에서 정보를 가져오도록 블록체인을 설계할 때의 문제를 강조합니다. 그러나 오라클은 오프체인 소스에서 정보를 가져와 스마트 계약이 소비할 수 있도록 블록체인에 저장함으로써 이 문제를 해결합니다. 온체인에 저장된 정보는 변경할 수 없고 공개적으로 사용 가능하므로 이더리움 노드는 합의를 깨뜨리지 않고 오라클이 가져온 오프체인 데이터를 안전하게 사용하여 상태 변경을 계산할 수 있습니다.

이를 위해 오라클은 일반적으로 온체인에서 실행되는 스마트 계약과 일부 오프체인 구성 요소로 구성됩니다. 온체인 계약은 다른 스마트 계약으로부터 데이터 요청을 받아 이를 오프체인 구성 요소(오라클 노드라고 함)에 전달합니다. 이 오라클 노드는 예를 들어 애플리케이션 프로그래밍 인터페이스(API)를 사용하여 데이터 소스를 쿼리하고 트랜잭션을 보내 요청된 데이터를 스마트 계약의 저장 공간에 저장할 수 있습니다.

본질적으로 블록체인 오라클은 블록체인과 외부 환경 간의 정보 격차를 해소하여 '하이브리드 스마트 계약'을 만듭니다. 하이브리드 스마트 계약은 온체인 계약 코드와 오프체인 인프라의 조합을 기반으로 작동하는 계약입니다. 탈중앙화 예측 시장은 하이브리드 스마트 계약의 훌륭한 예입니다. 다른 예로는 오라클 집합이 특정 기상 현상이 발생했다고 판단할 때 지불하는 농작물 보험 스마트 계약이 있습니다.

## 오라클 문제란 무엇인가요? {#the-oracle-problem}

오라클은 중요한 문제를 해결하지만 다음과 같은 몇 가지 복잡한 문제도 야기합니다.

- 주입된 정보가 올바른 소스에서 추출되었거나 조작되지 않았는지 어떻게 확인할 수 있나요?

- 이 데이터가 항상 사용 가능하고 정기적으로 업데이트되도록 어떻게 보장할 수 있나요?

소위 '오라클 문제'는 블록체인 오라클을 사용하여 스마트 계약에 입력을 보내는 데 따르는 문제를 보여줍니다. 스마트 계약이 올바르게 실행되려면 오라클의 데이터가 정확해야 합니다. 또한 정확한 정보를 제공하기 위해 오라클 운영자를 '신뢰'해야 한다는 것은 스마트 계약의 '무신뢰' 측면을 훼손합니다.

서로 다른 오라클은 오라클 문제에 대해 서로 다른 솔루션을 제공하며, 이에 대해서는 나중에 살펴볼 것입니다. 오라클은 일반적으로 다음 과제를 얼마나 잘 처리하는지에 따라 평가됩니다.

1. **정확성**: 오라클은 스마트 계약이 유효하지 않은 오프체인 데이터를 기반으로 상태 변경을 트리거하게 해서는 안 됩니다. 오라클은 데이터의 _진위성_과 _무결성_을 보장해야 합니다. 진위성은 데이터가 올바른 소스에서 가져왔음을 의미하며, 무결성은 데이터가 온체인으로 전송되기 전에 그대로 유지되었음(즉, 변경되지 않음)을 의미합니다.

2. **가용성**: 오라클은 스마트 계약이 작업을 실행하고 상태 변경을 트리거하는 것을 지연시키거나 방해해서는 안 됩니다. 이는 오라클의 데이터가 중단 없이 _요청 시 사용 가능_해야 함을 의미합니다.

3. **인센티브 호환성**: 오라클은 오프체인 데이터 제공자가 스마트 계약에 정확한 정보를 제출하도록 인센티브를 제공해야 합니다. 인센티브 호환성에는 _기여 가능성_과 _책임성_이 포함됩니다. 기여 가능성은 외부 정보 조각을 제공자와 연결할 수 있게 하는 반면, 책임성은 데이터 제공자를 제공하는 정보에 결부시켜 제공된 정보의 품질에 따라 보상을 받거나 불이익을 받을 수 있도록 합니다.

## 블록체인 오라클 서비스는 어떻게 작동하나요? {#how-does-a-blockchain-oracle-service-work}

### 사용자 {#users}

사용자는 특정 작업을 완료하기 위해 블록체인 외부의 정보가 필요한 엔터티(즉, 스마트 계약)입니다. 오라클 서비스의 기본 워크플로는 사용자가 오라클 계약에 데이터 요청을 보내는 것으로 시작됩니다. 데이터 요청은 일반적으로 다음 질문 중 일부 또는 전부에 답합니다.

1. 오프체인 노드가 요청된 정보에 대해 참조할 수 있는 소스는 무엇인가요?

2. 보고자는 데이터 소스의 정보를 어떻게 처리하고 유용한 데이터 포인트를 추출하나요?

3. 데이터 검색에 몇 개의 오라클 노드가 참여할 수 있나요?

4. 오라클 보고서의 불일치는 어떻게 관리해야 하나요?

5. 제출물을 필터링하고 보고서를 단일 값으로 집계하는 데 어떤 방법을 구현해야 하나요?

### 오라클 계약 {#oracle-contract}

오라클 계약은 오라클 서비스의 온체인 구성 요소입니다. 다른 계약의 데이터 요청을 수신하고 데이터 쿼리를 오라클 노드에 전달하며 반환된 데이터를 클라이언트 계약에 브로드캐스팅합니다. 이 계약은 또한 반환된 데이터 포인트에 대한 일부 계산을 수행하여 요청 계약에 보낼 집계 값을 생성할 수 있습니다.

오라클 계약은 클라이언트 계약이 데이터 요청을 할 때 호출하는 일부 함수를 노출합니다. 새로운 쿼리를 수신하면 스마트 계약은 데이터 요청의 세부 정보와 함께 [로그 이벤트](/developers/docs/smart-contracts/anatomy/#events-and-logs)를 내보냅니다. 이는 로그를 구독하는 오프체인 노드(일반적으로 JSON-RPC `eth_subscribe` 명령과 같은 것을 사용)에 알리고, 노드는 로그 이벤트에 정의된 데이터를 검색합니다.

아래는 Pedro Costa의 [오라클 계약 예시](https://medium.com/@pedrodc/implementing-a-blockchain-oracle-on-ethereum-cedc7e26b49e)입니다. 이것은 다른 스마트 계약의 요청에 따라 오프체인 API를 쿼리하고 요청된 정보를 블록체인에 저장할 수 있는 간단한 오라클 서비스입니다.

```solidity
pragma solidity >=0.4.21 <0.6.0;

contract Oracle {
  Request[] requests; // 계약에 대한 요청 목록
  uint currentId = 0; // 증가하는 요청 ID
  uint minQuorum = 2; // 최종 결과를 선언하기 전에 수신해야 하는 최소 응답 수
  uint totalOracleCount = 3; // 하드코딩된 오라클 수

  // 일반적인 api 요청을 정의합니다
  struct Request {
    uint id; // 요청 ID
    string urlToQuery; // API URL
    string attributeToFetch; // 응답에서 검색할 json 속성(키)
    string agreedValue; // 키의 값
    mapping(uint => string) answers; // 오라클이 제공한 답변
    mapping(address => uint) quorum; // 답변을 쿼리할 오라클(1=오라클이 투표하지 않음, 2=오라클이 투표함)
  }

  // 블록체인 외부에서 오라클을 트리거하는 이벤트
  event NewRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch
  );

  // 최종 결과에 대한 합의가 있을 때 트리거됨
  event UpdatedRequest (
    uint id,
    string urlToQuery,
    string attributeToFetch,
    string agreedValue
  );

  function createRequest (
    string memory _urlToQuery,
    string memory _attributeToFetch
  )
  public
  {
    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, ""));
    Request storage r = requests[length-1];

    // 하드코딩된 오라클 주소
    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;
    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;
    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;

    // 블록체인 외부의 오라클이 감지할 이벤트를 발생시킴
    emit NewRequest (
      currentId,
      _urlToQuery,
      _attributeToFetch
    );

    // 요청 ID 증가
    currentId++;
  }

  // 오라클이 답변을 기록하기 위해 호출함
  function updateRequest (
    uint _id,
    string memory _valueRetrieved
  ) public {

    Request storage currRequest = requests[_id];

    // 오라클이 신뢰할 수 있는 오라클 목록에 있는지 확인
    // 그리고 오라클이 아직 투표하지 않았는지 확인
    if(currRequest.quorum[address(msg.sender)] == 1){

      // 이 주소가 투표했음을 표시
      currRequest.quorum[msg.sender] = 2;

      // 위치가 비어 있을 때까지 답변 '배열'을 반복하고 검색된 값을 저장
      uint tmpI = 0;
      bool found = false;
      while(!found) {
        // 첫 번째 빈 슬롯 찾기
        if(bytes(currRequest.answers[tmpI]).length == 0){
          found = true;
          currRequest.answers[tmpI] = _valueRetrieved;
        }
        tmpI++;
      }

      uint currentQuorum = 0;

      // 오라클 목록을 반복하고 충분한 오라클(최소 쿼럼)이
      // 현재 답변과 동일한 답변에 투표했는지 확인
      for(uint i = 0; i < totalOracleCount; i++){
        bytes memory a = bytes(currRequest.answers[i]);
        bytes memory b = bytes(_valueRetrieved);

        if(keccak256(a) == keccak256(b)){
          currentQuorum++;
          if(currentQuorum >= minQuorum){
            currRequest.agreedValue = _valueRetrieved;
            emit UpdatedRequest (
              currRequest.id,
              currRequest.urlToQuery,
              currRequest.attributeToFetch,
              currRequest.agreedValue
            );
          }
        }
      }
    }
  }
}
```

### 오라클 노드 {#oracle-nodes}

오라클 노드는 오라클 서비스의 오프체인 구성 요소입니다. 타사 서버에서 호스팅되는 API와 같은 외부 소스에서 정보를 추출하고 스마트 계약이 소비할 수 있도록 온체인에 배치합니다. 오라클 노드는 온체인 오라클 계약의 이벤트를 수신하고 로그에 설명된 작업을 완료합니다.

오라클 노드의 일반적인 작업은 API 서비스에 [HTTP GET](https://www.w3schools.com/tags/ref_httpmethods.asp) 요청을 보내고, 응답을 구문 분석하여 관련 데이터를 추출하고, 블록체인에서 읽을 수 있는 출력으로 형식을 지정하고, 오라클 계약에 대한 트랜잭션에 포함하여 온체인으로 보내는 것입니다. 오라클 노드는 나중에 살펴볼 '진위성 증명'을 사용하여 제출된 정보의 유효성과 무결성을 증명해야 할 수도 있습니다.

계산 오라클은 또한 가스 비용과 블록 크기 제한을 고려할 때 온체인에서 실행하기에는 비실용적인 계산 작업을 수행하기 위해 오프체인 노드에 의존합니다. 예를 들어, 오라클 노드는 검증 가능한 무작위 숫자(예: 블록체인 기반 게임용)를 생성하는 작업을 맡을 수 있습니다.

## 오라클 디자인 패턴 {#oracle-design-patterns}

오라클은 _즉시 읽기_, _게시-구독_, _요청-응답_ 등 다양한 유형이 있으며, 후자의 두 가지가 이더리움 스마트 계약에서 가장 많이 사용됩니다. 여기서는 게시-구독 및 요청-응답 모델에 대해 간략하게 설명합니다.

### 게시-구독 오라클 {#publish-subscribe-oracles}

이 유형의 오라클은 다른 계약이 정기적으로 정보를 읽을 수 있는 '데이터 피드'를 노출합니다. 이 경우 데이터는 자주 변경될 것으로 예상되므로 클라이언트 계약은 오라클의 저장 공간에 있는 데이터 업데이트를 수신해야 합니다. 예를 들어 사용자에게 최신 ETH-USD 가격 정보를 제공하는 오라클이 있습니다.

### 요청-응답 오라클 {#request-response-oracles}

요청-응답 설정을 통해 클라이언트 계약은 게시-구독 오라클에서 제공하는 것 이외의 임의의 데이터를 요청할 수 있습니다. 요청-응답 오라클은 데이터 세트가 너무 커서 스마트 계약의 저장 공간에 저장할 수 없거나 사용자가 특정 시점에 데이터의 일부만 필요할 경우에 이상적입니다.

게시-구독 모델보다 더 복잡하지만 요청-응답 오라클은 기본적으로 이전 섹션에서 설명한 것입니다. 오라클에는 데이터 요청을 수신하고 이를 처리를 위해 오프체인 노드에 전달하는 온체인 구성 요소가 있습니다.

데이터 쿼리를 시작하는 사용자는 오프체인 소스에서 정보를 검색하는 비용을 부담해야 합니다. 클라이언트 계약은 또한 요청에 지정된 콜백 함수를 통해 응답을 반환하는 데 오라클 계약이 발생시킨 가스 비용을 충당하기 위한 자금을 제공해야 합니다.

## 중앙화 오라클 대 탈중앙화 오라클 {#types-of-oracles}

### 중앙화 오라클 {#centralized-oracles}

중앙화 오라클은 오프체인 정보를 집계하고 요청에 따라 오라클 계약의 데이터를 업데이트하는 단일 엔터티에 의해 제어됩니다. 중앙화 오라클은 단일 진실의 원천에 의존하기 때문에 효율적입니다. 독점 데이터 세트가 널리 인정된 서명과 함께 소유자에 의해 직접 게시되는 경우 더 잘 작동할 수 있습니다. 그러나 단점도 있습니다.

#### 낮은 정확성 보장 {#low-correctness-guarantees}

중앙화 오라클을 사용하면 제공된 정보가 정확한지 아닌지 확인할 방법이 없습니다. 심지어 '평판이 좋은' 제공업체도 악의적으로 변하거나 해킹당할 수 있습니다. 오라클이 손상되면 스마트 계약은 잘못된 데이터를 기반으로 실행됩니다.

#### 낮은 가용성 {#poor-availability}

중앙화 오라클은 다른 스마트 계약에 항상 오프체인 데이터를 제공한다고 보장하지 않습니다. 제공업체가 서비스를 중단하기로 결정하거나 해커가 오라클의 오프체인 구성 요소를 탈취하면 스마트 계약은 서비스 거부(DoS) 공격의 위험에 처하게 됩니다.

#### 낮은 인센티브 호환성 {#poor-incentive-compatibility}

중앙화 오라클은 종종 데이터 제공자가 정확하거나 변경되지 않은 정보를 보내도록 하는 인센티브가 잘못 설계되었거나 존재하지 않습니다. 정확성을 위해 오라클에 비용을 지불한다고 해서 정직성이 보장되는 것은 아닙니다. 이 문제는 스마트 계약이 제어하는 가치의 양이 증가함에 따라 더욱 커집니다.

### 탈중앙화 오라클 {#decentralized-oracles}

탈중앙화 오라클은 단일 장애 지점을 제거하여 중앙화 오라클의 한계를 극복하도록 설계되었습니다. 탈중앙화 오라클 서비스는 스마트 계약에 보내기 전에 오프체인 데이터에 대한 합의를 형성하는 피어투피어 네트워크의 여러 참가자로 구성됩니다.

탈중앙화 오라클은 (이상적으로) 무허가성, 무신뢰성이어야 하며 중앙 기관의 관리에서 자유로워야 하지만, 실제로는 오라클 간의 탈중앙화는 스펙트럼 위에 있습니다. 누구나 참여할 수 있지만 과거 성과에 따라 노드를 승인하고 제거하는 '소유자'가 있는 반탈중앙화 오라클 네트워크가 있습니다. 완전히 탈중앙화된 오라클 네트워크도 존재합니다. 이들은 일반적으로 독립형 블록체인으로 실행되며 노드를 조정하고 잘못된 행동을 처벌하기 위한 정의된 합의 메커니즘을 가지고 있습니다.

탈중앙화 오라클을 사용하면 다음과 같은 이점이 있습니다.

### 높은 정확성 보장 {#high-correctness-guarantees}

탈중앙화 오라클은 다양한 접근 방식을 사용하여 데이터의 정확성을 달성하려고 합니다. 여기에는 반환된 정보의 진위성과 무결성을 증명하는 증명을 사용하고 여러 엔터티가 오프체인 데이터의 유효성에 대해 집단적으로 동의하도록 요구하는 것이 포함됩니다.

#### 진위성 증명 {#authenticity-proofs}

진위성 증명은 외부 소스에서 검색한 정보의 독립적인 검증을 가능하게 하는 암호화 메커니즘입니다. 이 증명은 정보의 출처를 검증하고 검색 후 데이터에 대한 가능한 변경을 감지할 수 있습니다.

진위성 증명의 예는 다음과 같습니다.

**전송 계층 보안(TLS) 증명**: 오라클 노드는 종종 전송 계층 보안(TLS) 프로토콜을 기반으로 하는 보안 HTTP 연결을 사용하여 외부 소스에서 데이터를 검색합니다. 일부 탈중앙화 오라클은 진위성 증명을 사용하여 TLS 세션을 확인하고(즉, 노드와 특정 서버 간의 정보 교환을 확인) 세션 내용이 변경되지 않았음을 확인합니다.

**신뢰 실행 환경(TEE) 증명**: [신뢰 실행 환경](https://en.wikipedia.org/wiki/Trusted_execution_environment)(TEE)은 호스트 시스템의 운영 프로세스로부터 격리된 샌드박스형 계산 환경입니다. TEE는 계산 환경에 저장/사용된 모든 애플리케이션 코드 또는 데이터가 무결성, 기밀성 및 불변성을 유지하도록 보장합니다. 사용자는 또한 신뢰 실행 환경 내에서 애플리케이션 인스턴스가 실행되고 있음을 증명하기 위해 증명을 생성할 수 있습니다.

특정 클래스의 탈중앙화 오라클은 오라클 노드 운영자가 TEE 증명을 제공하도록 요구합니다. 이는 사용자에게 노드 운영자가 신뢰 실행 환경에서 오라클 클라이언트 인스턴스를 실행하고 있음을 확인시켜 줍니다. TEE는 외부 프로세스가 애플리케이션의 코드와 데이터를 변경하거나 읽는 것을 방지하므로 이러한 증명은 오라클 노드가 정보를 그대로 기밀로 유지했음을 증명합니다.

#### 정보의 합의 기반 검증 {#consensus-based-validation-of-information}

중앙화 오라클은 스마트 계약에 데이터를 제공할 때 단일 진실의 원천에 의존하므로 부정확한 정보를 게시할 가능성이 있습니다. 탈중앙화 오라클은 여러 오라클 노드에 의존하여 오프체인 정보를 쿼리함으로써 이 문제를 해결합니다. 여러 소스의 데이터를 비교함으로써 탈중앙화 오라클은 온체인 계약에 유효하지 않은 정보를 전달할 위험을 줄입니다.

그러나 탈중앙화 오라클은 여러 오프체인 소스에서 검색된 정보의 불일치를 처리해야 합니다. 정보의 차이를 최소화하고 오라클 계약에 전달된 데이터가 오라클 노드의 집단적 의견을 반영하도록 보장하기 위해 탈중앙화 오라클은 다음 메커니즘을 사용합니다.

##### 데이터 정확성에 대한 투표/스테이킹

일부 탈중앙화 오라클 네트워크는 참가자가 데이터 쿼리에 대한 답변의 정확성에 대해 투표하거나 스테이킹하도록 요구합니다(예: '2020년 미국 선거에서 누가 이겼나요?'). 네트워크의 기본 토큰을 사용합니다. 그런 다음 집계 프로토콜은 투표와 스테이킹을 집계하고 다수가 지지하는 답변을 유효한 것으로 간주합니다.

다수결 답변에서 벗어난 노드는 더 정확한 값을 제공하는 다른 사람들에게 토큰을 분배받는 불이익을 받습니다. 노드가 데이터를 제공하기 전에 채권을 제공하도록 강제하는 것은 수익 극대화를 목표로 하는 합리적인 경제 주체로 가정되므로 정직한 응답을 유도합니다.

스테이킹/투표는 또한 악의적인 행위자가 합의 시스템을 조작하기 위해 여러 신원을 생성하는 [시빌 공격](/glossary/#sybil-attack)으로부터 탈중앙화 오라클을 보호합니다. 그러나 스테이킹은 '프리라이딩'(오라클 노드가 다른 노드의 정보를 복사하는 것)과 '게으른 검증'(오라클 노드가 정보를 직접 확인하지 않고 다수를 따르는 것)을 방지할 수 없습니다.

##### 셸링 포인트 메커니즘

[셸링 포인트](https://en.wikipedia.org/wiki/Focal_point_\(game_theory\))는 여러 엔터티가 통신이 없는 상태에서 문제에 대한 공통 해결책을 항상 기본으로 삼을 것이라고 가정하는 게임 이론 개념입니다. 셸링 포인트 메커니즘은 종종 탈중앙화 오라클 네트워크에서 노드가 데이터 요청에 대한 답변에 합의할 수 있도록 하는 데 사용됩니다.

이에 대한 초기 아이디어는 [SchellingCoin](https://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed)으로, 참가자가 보증금과 함께 '스칼라' 질문(답이 크기로 설명되는 질문, 예: 'ETH 가격은 얼마입니까?')에 대한 응답을 제출하는 제안된 데이터 피드였습니다. 25번째와 75번째 [백분위수](https://en.wikipedia.org/wiki/Percentile) 사이의 값을 제공하는 사용자에게는 보상이 주어지지만, 중앙값에서 크게 벗어나는 값을 제공하는 사용자에게는 불이익이 주어집니다.

오늘날 SchellingCoin은 존재하지 않지만, 특히 [Maker Protocol의 오라클](https://docs.makerdao.com/smart-contract-modules/oracle-module)과 같은 여러 탈중앙화 오라클은 오라클 데이터의 정확성을 향상시키기 위해 셸링 포인트 메커니즘을 사용합니다. 각 Maker Oracle은 담보 자산에 대한 시장 가격을 제출하는 오프체인 P2P 노드 네트워크('릴레이어' 및 '피드')와 제공된 모든 값의 중앙값을 계산하는 온체인 'Medianizer' 계약으로 구성됩니다. 지정된 지연 기간이 끝나면 이 중앙값은 관련 자산의 새로운 참조 가격이 됩니다.

셸링 포인트 메커니즘을 사용하는 다른 오라클의 예로는 [Chainlink 오프체인 보고](https://docs.chain.link/architecture-overview/off-chain-reporting) 및 [Witnet](https://witnet.io/)이 있습니다. 두 시스템 모두에서 피어투피어 네트워크의 오라클 노드로부터의 응답은 평균 또는 중앙값과 같은 단일 집계 값으로 집계됩니다. 노드는 응답이 집계 값과 일치하거나 벗어나는 정도에 따라 보상을 받거나 처벌을 받습니다.

셸링 포인트 메커니즘은 온체인 공간을 최소화하면서(하나의 트랜잭션만 보내면 됨) 탈중앙화를 보장하기 때문에 매력적입니다. 후자는 노드가 평균/중앙값을 생성하는 알고리즘에 공급되기 전에 제출된 응답 목록에 서명해야 하기 때문에 가능합니다.

### 가용성 {#availability}

탈중앙화 오라클 서비스는 스마트 계약에 오프체인 데이터의 높은 가용성을 보장합니다. 이는 오프체인 정보의 출처와 정보를 온체인으로 전송하는 책임이 있는 노드를 모두 탈중앙화함으로써 달성됩니다.

이는 오라클 계약이 다른 계약의 쿼리를 실행하기 위해 여러 노드(또한 여러 데이터 소스에 의존)에 의존할 수 있으므로 내결함성을 보장합니다. 소스 _및_ 노드 운영자 수준에서의 탈중앙화는 매우 중요합니다. 동일한 소스에서 검색된 정보를 제공하는 오라클 노드 네트워크는 중앙화 오라클과 동일한 문제에 직면하게 됩니다.

스테이킹 기반 오라클이 데이터 요청에 신속하게 응답하지 못하는 노드 운영자를 슬래싱하는 것도 가능합니다. 이는 오라클 노드가 내결함성 인프라에 투자하고 적시에 데이터를 제공하도록 크게 장려합니다.

### 양호한 인센티브 호환성 {#good-incentive-compatibility}

탈중앙화 오라클은 오라클 노드 간의 [비잔틴](https://en.wikipedia.org/wiki/Byzantine_fault) 행동을 방지하기 위해 다양한 인센티브 설계를 구현합니다. 구체적으로 _기여 가능성_과 _책임성_을 달성합니다.

1. 탈중앙화 오라클 노드는 종종 데이터 요청에 대한 응답으로 제공하는 데이터에 서명해야 합니다. 이 정보는 오라클 노드의 과거 성과를 평가하는 데 도움이 되므로 사용자는 데이터 요청을 할 때 신뢰할 수 없는 오라클 노드를 필터링할 수 있습니다. Witnet의 [알고리즘 평판 시스템](https://docs.witnet.io/intro/about/architecture#algorithmic-reputation-system)이 그 예입니다.

2. 앞서 설명했듯이 탈중앙화 오라클은 노드가 제출하는 데이터의 진실성에 대한 신뢰도에 스테이킹을 하도록 요구할 수 있습니다. 주장이 확인되면 이 스테이킹은 정직한 서비스에 대한 보상과 함께 반환될 수 있습니다. 그러나 정보가 부정확한 경우 슬래싱될 수도 있으며, 이는 어느 정도의 책임성을 제공합니다.

## 스마트 계약에서의 오라클 애플리케이션 {#applications-of-oracles-in-smart-contracts}

다음은 이더리움에서 오라클의 일반적인 사용 사례입니다.

### 금융 데이터 검색 {#retrieving-financial-data}

[탈중앙화 금융](/defi/)(디파이) 애플리케이션은 자산의 피어투피어 대출, 차입 및 거래를 허용합니다. 이를 위해서는 종종 환율 데이터(암호화폐의 법정화폐 가치를 계산하거나 토큰 가격을 비교하기 위해) 및 자본 시장 데이터(금 또는 미국 달러와 같은 토큰화된 자산의 가치를 계산하기 위해)를 포함한 다양한 금융 정보를 얻어야 합니다.

예를 들어, 디파이 대출 프로토콜은 담보로 예치된 자산(예: ETH)의 현재 시장 가격을 쿼리해야 합니다. 이를 통해 계약은 담보 자산의 가치를 결정하고 시스템에서 얼마나 빌릴 수 있는지 결정할 수 있습니다.

디파이에서 인기 있는 '가격 오라클'(흔히 이렇게 불림)에는 Chainlink 가격 피드, Compound Protocol의 [Open Price Feed](https://compound.finance/docs/prices), Uniswap의 [시간 가중 평균 가격(TWAP)](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) 및 [Maker Oracles](https://docs.makerdao.com/smart-contract-modules/oracle-module)이 있습니다.

개발자는 프로젝트에 통합하기 전에 이러한 가격 오라클과 관련된 주의 사항을 이해해야 합니다. 이 [문서](https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles)는 언급된 가격 오라클 중 하나를 사용할 계획일 때 고려해야 할 사항에 대한 자세한 분석을 제공합니다.

아래는 Chainlink 가격 피드를 사용하여 스마트 계약에서 최신 ETH 가격을 검색하는 방법의 예입니다.

```solidity
pragma solidity ^0.6.7;

import "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol";

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;

    /**
     * 네트워크: Kovan
     * 애그리게이터: ETH/USD
     * 주소: 0x9326BFA02ADD2366b30bacB125260Af641031331
     */
    constructor() public {
        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
    }

    /**
     * 최신 가격을 반환합니다
     */
    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```

### 검증 가능한 무작위성 생성 {#generating-verifiable-randomness}

블록체인 기반 게임이나 복권 제도와 같은 특정 블록체인 애플리케이션은 효과적으로 작동하기 위해 높은 수준의 예측 불가능성과 무작위성이 필요합니다. 그러나 블록체인의 결정론적 실행은 무작위성을 제거합니다.

원래 접근 방식은 `blockhash`와 같은 의사 난수 암호화 함수를 사용하는 것이었지만, 이는 작업 증명 알고리즘을 해결하는 [채굴자에 의해 조작될 수 있었습니다](https://ethereum.stackexchange.com/questions/3140/risk-of-using-blockhash-other-miners-preventing-attack#:~:text=So%20while%20the%20miners%20can,to%20one%20of%20the%20players.) 작업 증명 알고리즘을 해결합니다. 또한, 이더리움의 [지분 증명으로의 전환](/roadmap/merge/)은 개발자들이 더 이상 온체인 무작위성을 위해 `blockhash`에 의존할 수 없음을 의미합니다. 대신 비콘 체인의 [RANDAO 메커니즘](https://eth2book.info/altair/part2/building_blocks/randomness)이 무작위성의 대안 소스를 제공합니다.

무작위 값을 오프체인으로 생성하여 온체인으로 보낼 수 있지만, 그렇게 하면 사용자에게 높은 신뢰 요구 사항이 부과됩니다. 그들은 값이 예측 불가능한 메커니즘을 통해 실제로 생성되었고 전송 중에 변경되지 않았다고 믿어야 합니다.

오프체인 계산을 위해 설계된 오라클은 프로세스의 예측 불가능성을 증명하는 암호화 증명과 함께 온체인으로 브로드캐스팅하는 무작위 결과를 오프체인에서 안전하게 생성하여 이 문제를 해결합니다. 예를 들어, [Chainlink VRF](https://docs.chain.link/docs/chainlink-vrf/)(검증 가능한 랜덤 함수)는 예측 불가능한 결과에 의존하는 애플리케이션을 위한 신뢰할 수 있는 스마트 계약을 구축하는 데 유용한, 증명 가능하게 공정하고 변조 방지 기능이 있는 난수 생성기(RNG)입니다.

### 이벤트 결과 얻기 {#getting-outcomes-for-events}

오라클을 사용하면 실제 세계 이벤트에 응답하는 스마트 계약을 쉽게 만들 수 있습니다. 오라클 서비스는 계약이 오프체인 구성 요소를 통해 외부 API에 연결하고 해당 데이터 소스에서 정보를 소비할 수 있도록 하여 이를 가능하게 합니다. 예를 들어, 앞서 언급한 예측 탈중앙화앱은 신뢰할 수 있는 오프체인 소스(예: Associated Press)로부터 선거 결과를 반환하도록 오라클에 요청할 수 있습니다.

실제 세계 결과를 기반으로 데이터를 검색하기 위해 오라클을 사용하면 다른 새로운 사용 사례가 가능해집니다. 예를 들어, 탈중앙화 보험 상품이 효과적으로 작동하려면 날씨, 재해 등에 대한 정확한 정보가 필요합니다.

### 스마트 계약 자동화 {#automating-smart-contracts}

스마트 계약은 자동으로 실행되지 않으며, 외부 소유 계정(EOA) 또는 다른 컨트랙트 계정이 계약 코드를 실행하기 위해 올바른 함수를 트리거해야 합니다. 대부분의 경우 계약의 기능 대부분은 공개되어 있으며 EOA 및 다른 계약에서 호출할 수 있습니다.

그러나 계약 내에는 다른 사람이 액세스할 수 없지만 탈중앙화앱의 전반적인 기능에 중요한 _비공개 함수_도 있습니다. 예를 들어 사용자를 위해 주기적으로 새로운 NFT를 발행하는 `mintERC721Token()` 함수, 예측 시장에서 지불금을 수여하는 함수 또는 DEX에서 스테이킹된 토큰을 잠금 해제하는 함수가 있습니다.

개발자는 애플리케이션이 원활하게 실행되도록 유지하기 위해 일정한 간격으로 이러한 함수를 트리거해야 합니다. 그러나 이는 개발자에게 평범한 작업에 더 많은 시간을 낭비하게 할 수 있으며, 이것이 스마트 계약 실행 자동화가 매력적인 이유입니다.

일부 탈중앙화 오라클 네트워크는 자동화 서비스를 제공하여 오프체인 오라클 노드가 사용자가 정의한 매개 변수에 따라 스마트 계약 함수를 트리거할 수 있도록 합니다. 일반적으로 이를 위해서는 오라클 서비스에 대상 계약을 '등록'하고, 오라클 운영자에게 지불할 자금을 제공하고, 계약을 트리거할 조건이나 시간을 지정해야 합니다.

Chainlink의 [Keeper 네트워크](https://chain.link/keepers)는 스마트 계약이 신뢰를 최소화하고 탈중앙화된 방식으로 정기적인 유지 관리 작업을 아웃소싱할 수 있는 옵션을 제공합니다. 계약을 Keeper와 호환되게 만들고 Upkeep 서비스를 사용하는 방법에 대한 정보는 공식 [Keeper 개발문서](https://docs.chain.link/docs/chainlink-keepers/introduction/)를 참조하세요.

## 블록체인 오라클 사용 방법 {#use-blockchain-oracles}

이더리움 탈중앙화앱에 통합할 수 있는 여러 오라클 애플리케이션이 있습니다.

**[Chainlink](https://chain.link/)** - _Chainlink 탈중앙화 오라클 네트워크는 모든 블록체인에서 고급 스마트 계약을 지원하기 위해 변조 방지 입력, 출력 및 계산을 제공합니다._

**[RedStone Oracles](https://redstone.finance/)** - _RedStone은 가스 최적화 데이터 피드를 제공하는 탈중앙화 모듈형 오라클입니다. 유동성 스테이킹 토큰(LST), 유동성 리스테이킹 토큰(LRT), 비트코인 스테이킹 파생상품과 같은 신규 자산에 대한 가격 피드 제공을 전문으로 합니다._

**[Chronicle](https://chroniclelabs.org/)** - _Chronicle은 진정으로 확장 가능하고 비용 효율적이며 탈중앙화되고 검증 가능한 오라클을 개발하여 온체인 데이터 전송의 현재 한계를 극복합니다._

**[Witnet](https://witnet.io/)** - _Witnet은 강력한 암호 경제적 보장을 통해 스마트 계약이 실제 세계 이벤트에 반응하도록 돕는 무허가성, 탈중앙화 및 검열 저항성 오라클입니다._

**[UMA Oracle](https://uma.xyz)** - _UMA의 낙관적 오라클은 스마트 계약이 보험, 금융 파생 상품, 예측 시장을 포함한 다양한 애플리케이션을 위해 모든 종류의 데이터를 신속하게 수신할 수 있도록 합니다._

**[Tellor](https://tellor.io/)** - _Tellor는 스마트 계약이 필요할 때마다 모든 데이터를 쉽게 얻을 수 있는 투명하고 무허가성인 오라클 프로토콜입니다._

**[Band Protocol](https://bandprotocol.com/)** - _Band Protocol은 실제 세계 데이터와 API를 스마트 계약에 집계하고 연결하는 크로스 체인 데이터 오라클 플랫폼입니다._

**[Pyth Network](https://pyth.network/)** - _Pyth 네트워크는 변조 방지, 탈중앙화 및 자립 환경에서 연속적인 실제 세계 데이터를 온체인으로 게시하도록 설계된 1차 금융 오라클 네트워크입니다._

**[API3 DAO](https://www.api3.org/)** - _API3 DAO는 스마트 계약을 위한 탈중앙화 솔루션에서 더 큰 소스 투명성, 보안 및 확장성을 제공하는 1차 오라클 솔루션을 제공합니다._

**[Supra](https://supra.com/)** - 모든 블록체인(퍼블릭(L1 및 L2) 또는 프라이빗(기업))을 상호 연결하는 수직적으로 통합된 크로스 체인 솔루션 툴킷으로, 온체인 및 오프체인 사용 사례에 사용할 수 있는 탈중앙화 오라클 가격 피드를 제공합니다.

**[Gas Network](https://gas.network/)** - 블록체인 전반에 걸쳐 실시간 가스 가격 데이터를 제공하는 분산형 오라클 플랫폼입니다. 선도적인 가스 가격 데이터 제공업체의 데이터를 온체인으로 가져옴으로써 Gas Network는 상호 운용성을 촉진하는 데 도움을 줍니다. Gas Network는 이더리움 메인넷 및 다수의 선도적인 L2를 포함하여 35개 이상의 체인에 대한 데이터를 지원합니다.

## 더 읽어보기 {#further-reading}

**문서**

- [블록체인 오라클이란?](https://chain.link/education/blockchain-oracles) — _Chainlink_
- [블록체인 오라클이란?](https://medium.com/better-programming/what-is-a-blockchain-oracle-f5ccab8dbd72) — _Patrick Collins_
- [탈중앙화 오라클: 종합 개요](https://medium.com/fabric-ventures/decentralised-oracles-a-comprehensive-overview-d3168b9a8841) — _Julien Thevenard_
- [이더리움에서 블록체인 오라클 구현하기](https://medium.com/@pedrodc/implementing-a-blockchain-oracle-on-ethereum-cedc7e26b49e) – _Pedro Costa_
- [스마트 계약이 API를 호출할 수 없는 이유는 무엇인가요?](https://ethereum.stackexchange.com/questions/301/why-cant-contracts-make-api-calls) — _StackExchange_
- [그래서 당신은 가격 오라클을 사용하고 싶군요](https://samczsun.com/so-you-want-to-use-a-price-oracle/) — _samczsun_

**영상**

- [오라클과 블록체인 유틸리티의 확장](https://youtu.be/BVUZpWa8vpw) — _Real Vision Finance_

**튜토리얼**

- [솔리디티에서 현재 이더리움 가격 가져오는 방법](https://blog.chain.link/fetch-current-crypto-price-data-solidity/) — _Chainlink_
- [오라클 데이터 소비](https://docs.chroniclelabs.org/Developers/tutorials/Remix) — _Chronicle_

**예제 프로젝트**

- [이더리움을 위한 전체 Chainlink 스타터 프로젝트(솔리디티)](https://github.com/hackbg/chainlink-fullstack) — _HackBG_
