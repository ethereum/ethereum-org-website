---
title: "블록"
description: "이더리움 블록체인 내의 블록 개요 - 데이터 구조, 왜 필요한지 그리고 어떻게 만들어지는지"
lang: ko
---

블록은 이전 블록의 해시를 포함하는 체인 내의 트랜잭션의 묶음입니다. 블록을 체인으로 연결하는 이유는 해시는 암호화 방식으로 블록 데이터에서 파생되기 때문입니다. 이것은 이전의 어느 블록의 하나의 변경이 모든 이어지는 해시를 바꾸면서 그 다음의 모든 블록을 무효화하고, 블록체인을 실행하는 모두에게 알리기 때문에 사기를 막는다.

## 필수 구성 요소 {#prerequisites}

블록은 입문자에게 매우 친근한 주제입니다. 하지만 이 페이지를 더 잘 이해하는 데 도움이 되도록 먼저 [계정](/developers/docs/accounts/), [트랜잭션](/developers/docs/transactions/), [이더리움 소개](/developers/docs/intro-to-ethereum/)를 읽어보시는 것을 추천합니다.

## 블록을 사용하는 이유 {#why-blocks}

이더리움 네트워크의 모든 참여자가 동기화된 상태를 유지하고 정확한 트랜잭션 기록에 동의할 수 있도록 트랜잭션을 블록으로 일괄 처리합니다. 이는 수십(수백) 개의 트랜잭션이 제출되고, 합의하며, 한번에 동기화된다는 것을 의미합니다.

![블록 내 트랜잭션이 상태 변화를 일으키는 것을 보여주는 다이어그램](./tx-block.png)
_다이어그램은 [Ethereum EVM illustrated](https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf)에서 발췌_

제출 간격을 두어, 모든 네트워크 참여자들에게 합의할 수 있는 충분한 시간을 줍니다. 요청 트랜잭션이 초당 수십개가 발생하더라도, 블록은 매 12초마다 한번 생성되어 제출됩니다.

## 블록 작동 방식 {#how-blocks-work}

트랜잭션 기록을 보존하기 위해서, 블록은 엄격히 순서를 정하고 (모든 생성된 새로운 블록은 그 부모 블록의 참조를 갖는다), 블록 내의 트랜잭션도 엄격히 순서가 잘 정해진다. 드문 경우를 제외하고, 언제나 네트워크 상의 모든 참여자들은 정확한 숫자와 블록 기록 상에서 합의되어 있고, 현재 라이브 트랜잭션 요청을 다음 블록으로 묶기 위해 동작 중이다.

네트워크에서 무작위로 선택된 검증인이 블록을 구성하면 해당 블록은 네트워크의 나머지 부분으로 전파됩니다. 모든 노드는 이 블록을 블록체인 끝에 추가하고 다음 블록을 생성하기 위해 새로운 검증자가 선택됩니다 정확한 블록-구성 과정과 제출/합의 과정은 현재 이더리움의 "작업증명" 프로토콜에 명시되어있다.

## 지분 증명 프로토콜 {#proof-of-stake-protocol}

작업 증명은 다음을 의미합니다.

- 검증 노드는 나쁜 행동에 대한 담보로 예금 계좌에 32 ETH를 스테이킹해야 한다. 이는 부정직한 활동으로 인해 해당 지분의 일부 또는 전부가 파괴될 수 있으므로 네트워크를 보호하는 데 도움이 된다.
- 모든 슬롯(12초 간격) 에서 검증인은 블록 제안자로 무작위로 선택된다. 그들은 트랜잭션들을 하나로 묶어서 실행하고 새로운 'state'를 결정한다. 그들은 정보를 블럭에 담아 다른 검증자에게 전달한다.
- 새로운 블록에 대한 소식을 들은 다른 검증인은 트랜잭션을 다시 실행하여 글로벌 상태에 대한 제안된 변경 사항에 동의하는지 확인합니다. 블록이 유효하다고 가정하면 이를 자신의 데이터베이스에 추가합니다.
- 검증인이 동일한 슬롯에서 두 개의 충돌하는 블록에 대해 듣게 되면 포크 선택 알고리즘을 사용하여 가장 많이 스테이킹된 ETH가 지원하는 블록을 선택합니다.

[지분 증명에 대해 더 알아보기](/developers/docs/consensus-mechanisms/pos)

## 블록 내에 무엇이 있나요? {#block-anatomy}

블록은 수많은 정보를 담고 있습니다. 가장 높은 레벨의 블록에는 다음 필드가 포함됩니다:

| 필드               | 설명                     |
| :--------------- | :--------------------- |
| `슬롯`             | 블록이 속한 슬롯              |
| `proposer_index` | 블록을 제안하는 검증자의 ID       |
| `parent_root`    | 이전 블록의 해시              |
| `state_root`     | 상태 객체의 루트 해시           |
| `본문`             | 아래에 정의된 여러 필드를 포함하는 객체 |

블록 `body`는 자체적으로 여러 필드를 포함합니다:

| 필드                   | 설명                                     |
| :------------------- | :------------------------------------- |
| `randao_reveal`      | 다음 블록 제안자를 선택하는 데 사용되는 값               |
| `eth1_data`          | 예금 계약에 대한 정보                           |
| `graffiti`           | 블록에 태그를 지정하는 데 사용되는 임의의 데이터            |
| `proposer_slashings` | 슬래싱될 검증자 목록                            |
| `attester_slashings` | 슬래싱될 인증자 목록                            |
| `인증`                 | 이전 슬롯에 대해 이루어진 인증 목록                   |
| `입금`                 | 예금 계약에 대한 새로운 예금 목록                    |
| `voluntary_exits`    | 네트워크를 나가는 검증자 목록                       |
| `sync_aggregate`     | 라이트 클라이언트에 서비스를 제공하는 데 사용되는 검증자의 하위 집합 |
| `execution_payload`  | 실행 클라이언트에서 전달된 트랜잭션                    |

`attestations` 필드에는 블록에 있는 모든 인증 목록이 포함됩니다. 인증서에는 데이터 타입과 여러 조각의 데이터가 포함됩니다. 각 인증에는 다음이 포함됩니다.

| 필드                 | 설명                          |
| :----------------- | :-------------------------- |
| `aggregation_bits` | 이 인증에 참여한 검증자 목록            |
| `데이터`              | 여러 하위 필드가 있는 컨테이너           |
| `signature`        | `data` 부분에 대한 검증자 집합의 집계 서명 |

`attestation`의 `data` 필드에는 다음이 포함됩니다.

| 필드                  | 설명                        |
| :------------------ | :------------------------ |
| `슬롯`                | 인증과 관련된 슬롯                |
| `index`             | 인증하는 검증자의 인덱스             |
| `beacon_block_root` | 체인의 헤드로 간주되는 비콘 블록의 루트 해시 |
| `출처`                | 마지막으로 정당화된 체크포인트          |
| `target`            | 최신 에폭 경계 블록               |

`execution_payload`에서 트랜잭션을 실행하면 전역 상태가 업데이트됩니다. 모든 클라이언트는 `execution_payload`의 트랜잭션을 다시 실행하여 새로운 상태가 새 블록의 `state_root` 필드에 있는 상태와 일치하는지 확인합니다. 이것이 클라이언트가 새 블록이 유효하고 블록체인에 안전하게 추가할 수 있는지 알 수 있는 방법입니다. `execution payload` 자체는 여러 필드가 있는 객체입니다. 또한 실행 데이터에 대한 중요한 요약 정보가 포함된 `execution_payload_header`가 있습니다. 이러한 데이터 구조는 다음과 같이 구성됩니다.

`execution_payload_header`에는 다음 필드가 포함됩니다.

| 필드                  | 설명                                  |
| :------------------ | :---------------------------------- |
| `parent_hash`       | 부모 블록의 해시                           |
| `fee_recipient`     | 거래 수수료를 지불할 계정 주소                   |
| `state_root`        | 이 블록의 변경 사항을 적용한 후의 전역 상태에 대한 루트 해시 |
| `receipts_root`     | 거래 영수증 트리의 해시                       |
| `logs_bloom`        | 이벤트 로그를 포함하는 데이터 구조                 |
| `prev_randao`       | 임의 검증자 선택에 사용되는 값                   |
| `block_number`      | 현재 블록의 번호                           |
| `gas_limit`         | 이 블록에서 허용되는 최대 가스                   |
| `gas_used`          | 이 블록에서 실제 사용된 가스량                   |
| `timestamp`         | 블록 시간                               |
| `extra_data`        | 원시 바이트로서의 임의의 추가 데이터                |
| `base_fee_per_gas`  | 기본 수수료 값                            |
| `block_hash`        | 실행 블록의 해시                           |
| `transactions_root` | 페이로드에 있는 트랜잭션의 루트 해시                |
| `withdrawal_root`   | 페이로드에 있는 인출의 루트 해시                  |

`execution_payload` 자체에는 다음이 포함됩니다(트랜잭션의 루트 해시 대신 실제 트랜잭션 목록 및 인출 정보가 포함된다는 점을 제외하면 헤더와 동일합니다):

| 필드                 | 설명                                  |
| :----------------- | :---------------------------------- |
| `parent_hash`      | 부모 블록의 해시                           |
| `fee_recipient`    | 거래 수수료를 지불할 계정 주소                   |
| `state_root`       | 이 블록의 변경 사항을 적용한 후의 전역 상태에 대한 루트 해시 |
| `receipts_root`    | 거래 영수증 트리의 해시                       |
| `logs_bloom`       | 이벤트 로그를 포함하는 데이터 구조                 |
| `prev_randao`      | 임의 검증자 선택에 사용되는 값                   |
| `block_number`     | 현재 블록의 번호                           |
| `gas_limit`        | 이 블록에서 허용되는 최대 가스                   |
| `gas_used`         | 이 블록에서 실제 사용된 가스량                   |
| `timestamp`        | 블록 시간                               |
| `extra_data`       | 원시 바이트로서의 임의의 추가 데이터                |
| `base_fee_per_gas` | 기본 수수료 값                            |
| `block_hash`       | 실행 블록의 해시                           |
| `트랜잭션`             | 실행할 트랜잭션 목록                         |
| `출금`               | 인출 객체 목록                            |

`withdrawals` 목록에는 다음과 같이 구성된 `withdrawal` 객체가 포함됩니다.

| 필드               | 설명        |
| :--------------- | :-------- |
| `주소`             | 인출한 계정 주소 |
| `amount`         | 인출 금액     |
| `index`          | 인출 인덱스 값  |
| `validatorIndex` | 검증자 인덱스 값 |

## 블록 시간 {#block-time}

블록 시간이란 블록 사이의 시간을 의미합니다. 이더리움에서 시간은 '슬롯'이라고 하는 12초 단위로 나뉩니다. 각 슬롯에서 단일 검증자가 블록을 제안하도록 선택됩니다. 모든 검증자가 온라인 상태이고 완벽하게 작동한다고 가정하면 모든 슬롯에 블록이 존재하게 되며, 이는 블록 시간이 12초임을 의미합니다. 그러나 때로는 검증자가 블록을 제안하도록 호출되었을 때 오프라인 상태일 수 있으며, 이는 슬롯이 비어 있을 수 있음을 의미합니다.

이 구현은 블록 시간이 확률적이며 프로토콜의 목표 채굴 난이도에 따라 조정되는 작업 증명 기반 시스템과 다릅니다. 이더리움의 [평균 블록 시간](https://etherscan.io/chart/blocktime)은 작업 증명에서 지분 증명으로의 전환이 새로운 12초 블록 시간의 일관성을 기반으로 명확하게 추론될 수 있는 완벽한 예입니다.

## 블록 크기 {#block-size}

마지막 중요한 유의점은 블록 그 자체가 크기 한계를 가진다는 것이다. 각 블록의 목표 크기는 3,000만 가스이지만, 네트워크 수요에 따라 블록 크기는 6,000만 가스(목표 블록 크기의 2배) 한도까지 증가하거나 감소합니다. 블록 가스 한도는 이전 블록의 가스 한도에서 1/1024만큼 상향 또는 하향 조정될 수 있습니다. 결과적으로, 검증자는 합의를 통해 블록 가스 한도를 변경할 수 있습니다. 블록 내 모든 트랜잭션에서 소비된 총 가스량은 블록 가스 한도보다 작아야 합니다. 블록이 제멋대로 커질 수 없도록 보장하기 때문에 이는 중요하다. 블록이 제멋대로 커질 수 있다면, 적은 성능 기준의 풀 노드들이 공간과 시간적 요구 사항으로 인해 네트워크 유지를 차츰 멈출 것이다. 블록이 클수록 다음 슬롯 시간에 맞춰 처리하는 데 더 큰 컴퓨팅 파워가 필요합니다. 이는 중앙화 요인이며, 블록 크기를 제한함으로써 이를 방지합니다.

## 더 읽어보기 {#further-reading}

_도움이 되었던 커뮤니티 참고 자료를 알고 계신가요? 이 페이지를 편집해서 추가하세요!_

## 관련 주제 {#related-topics}

- [트랜잭션](/developers/docs/transactions/)
- [가스](/developers/docs/gas/)
- [지분 증명](/developers/docs/consensus-mechanisms/pos)
