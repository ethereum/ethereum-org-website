---
title: Nodes and clients
description: 이더리움 노드와 클라이언트 소프트웨어에 대한 개요. 노드를 설정하는 방법과 이용해야하는 이유에 대한 추가적인 설명
lang: ko
sidebarDepth: 2
---

이더리움은 블럭 및 트랜잭션 데이터 검증 소프트웨어를 실행하는 컴퓨터 (노드) 들의 분산 네트워크입니다. 이 소프트웨어는 컴퓨터에서 실행되어 이더리움 노드로 변환되어야 함 노드를 구성하려면 두 개의 별도 소프트웨어(‘클라이언트’로 알려짐)가 필요함

## 필수 구성 요소 {#prerequisites}

자신만의 이더리움 클라이언트를 실행하고 더 깊이 알아보기 전에, P2P(peer-to-peer) 네트워크 개념과 [EVM 기본 사항](/developers/docs/evm/)을 이해해야 합니다. [이더리움 소개](/developers/docs/intro-to-ethereum/)를 살펴보세요.

노드라는 주제가 처음이시라면, 사용자 친화적인 소개 문서인 [이더리움 노드 실행하기](/run-a-node)를 먼저 확인해 보시는 것을 추천합니다.

## 노드랑 클라이언트가 무엇인가요? {#what-are-nodes-and-clients}

"노드"는 이더리움 클라이언트 소프트웨어를 실행하여 네트워크를 형성하는 다른 컴퓨터와 연결된 이더리움 클라이언트 소프트웨어의 인스턴스를 의미함 클라이언트는 이더리움 데이터를 프로토콜 규칙에 따라 검증하고 네트워크의 보안을 유지하는 역할을 함 노드는 두 개의 클라이언트를 실행해야 함: 합의 클라이언트와 실행 클라이언트

- 실행 클라이언트(실행 엔진, EL 클라이언트 또는 이전의 Eth1 클라이언트라고도 함)는 네트워크에서 브로드캐스트되는 새로운 트랜잭션을 청취하고 EVM에서 이를 실행하며 최신 상태 및 모든 현재 이더리움 데이터베이스를 보유함
- 합의 클라이언트(비콘 노드, CL 클라이언트 또는 이전의 Eth2 클라이언트로도 알려짐)는 실행 클라이언트에서 검증된 데이터를 기반으로 네트워크가 합의에 도달할 수 있도록 하는 지분 증명 합의 알고리즘을 구현함 또한 합의 클라이언트에 추가할 수 있는 '검증자'라는 세 번째 소프트웨어가 있으며, 이를 통해 노드가 네트워크 보안에 참여할 수 있음

이러한 클라이언트는 함께 작동하여 이더리움 체인의 헤드를 추적하고 사용자가 이더리움 네트워크와 상호작용할 수 있도록 함 여러 소프트웨어가 함께 작동하는 모듈식 설계를 [캡슐화된 복잡성](https://vitalik.eth.limo/general/2022/02/28/complexity.html)이라고 합니다. 이 접근 방식 덕분에 [병합](/roadmap/merge)을 원활하게 실행할 수 있었으며, 클라이언트 소프트웨어의 유지보수 및 개발이 용이해졌고, 예를 들어 [레이어 2 생태계](/layer-2/)에서 개별 클라이언트를 재사용할 수 있게 되었습니다.

![실행 및 합의 클라이언트 결합](./eth1eth2client.png)
결합된 실행 및 합의 클라이언트의 단순화된 다이어그램입니다.

### 클라이언트 다양성 {#client-diversity}

[실행 클라이언트](/developers/docs/nodes-and-clients/#execution-clients)와 [합의 클라이언트](/developers/docs/nodes-and-clients/#consensus-clients)는 모두 여러 팀에서 개발한 다양한 프로그래밍 언어로 존재합니다.

다양한 클라이언트 구현은 단일 코드베이스에 대한 의존성을 줄여 네트워크를 더욱 강하게 만듭니다. 이상적인 목표는 어느 클라이언트도 네트워크를 지배하지 않으면서 다양성을 달성하여 잠재적인 단일 장애점을 제거하는 것입니다.
다양한 언어는 더 넓은 개발자 커뮤니티를 초대하고, 개발자가 선호하는 언어로 통합을 만들 수 있게 합니다.

[클라이언트 다양성](/developers/docs/nodes-and-clients/client-diversity/)에 대해 자세히 알아보세요.

이러한 구현들이 공통으로 가지고 있는 점은 모두 단일 사양을 따른다는 것입니다. 사양은 이더리움 네트워크와 블록체인이 작동하는 방식을 규정합니다. 모든 기술적 세부 사항이 정의되어 있으며, 사양은 다음에서 찾을 수 있습니다:

- 원래는 [이더리움 옐로 페이퍼](https://ethereum.github.io/yellowpaper/paper.pdf)
- [실행 사양](https://github.com/ethereum/execution-specs/)
- [합의 사양](https://github.com/ethereum/consensus-specs)
- 다양한 [네트워크 업그레이드](/ethereum-forks/)에서 구현된 [EIP](https://eips.ethereum.org/)

### 네트워크의 노드 추적 {#network-overview}

여러 추적기는 이더리움 네트워크의 노드를 실시간으로 개요를 제공합니다. 탈중앙화 네트워크의 특성상 이러한 크롤러는 네트워크의 제한된 뷰만 제공할 수 있으며, 서로 다른 결과를 보고할 수 있음을 유의하십시오.

- Etherscan의 [노드 맵](https://etherscan.io/nodetracker)
- Bitfly의 [Ethernodes](https://ethernodes.org/)
- Chainsafe의 [Nodewatch](https://www.nodewatch.io/), 합의 노드 크롤링
- [Monitoreth](https://monitoreth.io/) - MigaLabs 제공, 분산 네트워크 모니터링 도구
- [주간 네트워크 상태 보고서](https://probelab.io) - ProbeLab 제공, [Nebula 크롤러](https://github.com/dennis-tra/nebula) 및 기타 도구 사용

## 노드 유형 {#node-types}

자신만의 [노드를 실행](/developers/docs/nodes-and-clients/run-a-node/)하려면, 데이터를 다르게 소비하는 다양한 유형의 노드가 있다는 것을 이해해야 합니다. 실제로 클라이언트는 세 가지 유형의 노드를 실행할 수 있습니다: 라이트, 풀, 아카이브. 또한 더 빠른 동기화를 가능하게 하는 다양한 동기화 전략이 있습니다. 동기화는 이더리움 상태에 대한 최신 정보를 얼마나 빨리 얻을 수 있는지와 관련이 있습니다.

### 전체 노드 {#full-node}

풀 노드는 블록체인의 블록별 검증을 수행하며, 각 블록의 블록 본문과 상태 데이터를 다운로드하고 검증합니다. 다양한 클래스의 풀 노드가 있으며, 일부는 최초 블록부터 시작하여 블록체인의 전체 기록을 검증합니다. 다른 노드들은 유효하다고 신뢰하는 더 최신 블록에서 검증을 시작합니다(예: Geth의 '스냅 동기화'). 검증이 어디에서 시작되든 풀 노드는 비교적 최근의 데이터(일반적으로 최신 128개 블록)를 로컬에 저장하며, 오래된 데이터는 디스크 공간을 절약하기 위해 삭제됩니다. 필요할 때 오래된 데이터는 다시 생성될 수 있습니다.

- 풀 블록체인 데이터를 저장합니다(하지만 주기적으로 가지치기되므로 풀 노드는 모든 상태 데이터를 저장하지 않습니다).
- 블록 검증에 참여하며 모든 블록과 상태를 검증합니다.
- 모든 상태는 로컬 저장소에서 검색하거나 '스냅샷'에서 다시 생성할 수 있습니다.
- 네트워크에 데이터를 요청하면 제공합니다.

### 아카이브 노드 {#archive-node}

아카이브 노드는 모든 블록을 검증하고 다운로드한 데이터를 절대 삭제하지 않는 풀 노드입니다.

- 풀 노드에 저장된 모든 것을 보관하고 역사적 상태의 아카이브를 작성합니다. 블록 #4,000,000에서 계정 잔액과 같은 것을 조회하거나, 추적을 사용하여 트랜잭션 세트를 검증하지 않고 간단하고 안정적으로 테스트하려는 경우에 필요합니다.
- 이 데이터는 테라바이트 단위로 나타나기 때문에 일반 사용자에게는 덜 매력적일 수 있지만, 블록 탐색기, 지갑 공급업체, 체인 분석 서비스와 같은 서비스에 유용할 수 있습니다.

아카이브가 아닌 모드로 클라이언트를 동기화하면 가지치기된 블록체인 데이터가 발생합니다. 이는 모든 역사적 상태의 아카이브가 없다는 것을 의미하지만, 풀 노드는 필요할 때 이러한 상태를 구축할 수 있습니다.

[아카이브 노드](/developers/docs/nodes-and-clients/archive-nodes)에 대해 자세히 알아보세요.

### 라이트 노드 {#light-node}

라이트 노드는 모든 블록을 다운로드하는 대신 블록 헤더만 다운로드합니다. 이 헤더는 블록 내용에 대한 요약 정보를 포함하고 있습니다. 라이트 노드가 필요한 다른 정보는 풀 노드에서 요청됩니다. 라이트 노드는 받은 데이터를 블록 헤더의 상태 루트와 대조하여 독립적으로 검증할 수 있습니다. 라이트 노드는 강력한 하드웨어나 높은 대역폭 없이도 이더리움 네트워크에 참여할 수 있게 합니다. 결국, 라이트 노드는 모바일 전화기나 임베디드 장치에서 실행될 수 있습니다. 라이트 노드는 합의에 참여하지 않지만(즉, 검증자가 될 수 없음), 전체 노드와 동일한 기능 및 보안 보장으로 이더리움 블록체인에 액세스할 수 있습니다.

라이트 클라이언트는 이더리움의 활성 개발 분야이며, 조만간 합의 계층 및 실행 계층용 새로운 라이트 클라이언트를 볼 수 있을 것으로 기대됩니다.
[가십 네트워크](https://www.ethportal.net/)를 통해 라이트 클라이언트 데이터를 제공하는 잠재적 경로도 있습니다. 가십 네트워크가 전체 노드가 요청을 처리할 필요 없이 라이트 노드 네트워크를 지원할 수 있기 때문에 이점이 있습니다.

이더리움은 아직 많은 수의 라이트 노드를 지원하지 않지만, 라이트 노드 지원은 가까운 미래에 빠르게 발전할 것으로 예상됩니다. 특히 [Nimbus](https://nimbus.team/), [Helios](https://github.com/a16z/helios), [LodeStar](https://lodestar.chainsafe.io/)와 같은 클라이언트는 현재 라이트 노드에 크게 집중하고 있습니다.

## 왜 이더리움 노드를 실행해야 합니까? {#why-should-i-run-an-ethereum-node}

노드를 실행하면 네트워크를 더 강력하고 분산화된 상태로 유지하는 데 도움을 주면서 이더리움을 직접, 신뢰 없이, 비공개로 사용할 수 있습니다.

### 사용자에게 주는 이점 {#benefits-to-you}

자신의 노드를 실행하면 이더리움을 비공개, 자급자족 방식으로 신뢰 없이 사용할 수 있습니다. 네트워크를 신뢰할 필요가 없으며, 자신의 클라이언트를 사용해 데이터를 직접 검증할 수 있습니다. "신뢰하지 말고, 검증하라"는 블록체인에서 인기 있는 모토입니다.

- 귀하의 노드는 모든 거래와 블록을 합의 규칙에 따라 스스로 검증합니다. 즉, 네트워크 내 다른 노드를 신뢰할 필요가 없으며, 완전히 의존하지 않아도 됩니다.
- 자신의 노드와 함께 이더리움 지갑을 사용할 수 있습니다. 중개인에게 주소와 잔액을 유출하지 않고 더 안전하고 비공개로 dapp을 사용할 수 있습니다. 모든 것은 자신의 클라이언트로 확인할 수 있습니다. [MetaMask](https://metamask.io), [Frame](https://frame.sh/) 및 [기타 여러 지갑](/wallets/find-wallet/)은 사용자의 노드를 사용할 수 있도록 RPC 가져오기 기능을 제공합니다.
- 이더리움의 데이터를 필요로 하는 서비스(예: 비콘 체인 검증자, 레이어 2 소프트웨어, 블록 탐색기, 결제 처리기 등)를 실행하고 자체 호스팅할 수 있습니다. 이더리움의 데이터를 필요로 하는 서비스(예: 비콘 체인 검증자, 레이어 2 소프트웨어, 블록 탐색기, 결제 처리기 등)를 실행하고 자체 호스팅할 수 있습니다.
- 자신만의 맞춤형 [RPC 엔드포인트](/developers/docs/apis/json-rpc/)를 제공할 수 있습니다. 커뮤니티에 이러한 엔드포인트를 공개하여 대형 중앙 집중식 제공업체를 피하는 데 도움을 줄 수 있습니다.
- \*\*프로세스 간 통신(IPC)\*\*을 사용하여 노드에 연결하거나 노드를 다시 작성하여 프로그램을 플러그인으로 로드할 수 있습니다. 이는 낮은 지연 시간을 보장하며, 예를 들어 web3 라이브러리를 사용하여 많은 양의 데이터를 처리하거나 가능한 한 빨리 트랜잭션을 교체해야 할 때(즉, 프론트러닝) 많은 도움이 됩니다.
- ETH를 직접 스테이킹하여 네트워크를 보호하고 보상을 받을 수 있습니다. 시작하려면 [단독 스테이킹](/staking/solo/)을 참조하세요.

![애플리케이션과 노드를 통해 이더리움에 액세스하는 방법](./nodes.png)

### 네트워크 이점 {#network-benefits}

다양한 노드 세트는 이더리움의 건강, 보안 및 운영 복원력에 중요합니다.

- 전체 노드는 합의 규칙을 시행하므로 규칙을 따르지 않는 블록을 받아들이지 않습니다. 이것은 네트워크의 추가 보안을 제공하는데, 만약 모든 노드가 전체 검증을 하지 않는 라이트 노드였다면 검증자들이 네트워크를 공격할 수 있었을 것입니다.
- [지분 증명](/developers/docs/consensus-mechanisms/pos/#what-is-pos)의 암호경제학적 방어를 극복하는 공격이 발생할 경우, 전체 노드가 정직한 체인을 따르기로 선택하여 사회적 복구를 수행할 수 있습니다.
- 네트워크의 노드가 많을수록 네트워크가 더 다양하고 강력해지며, 이는 검열에 저항하고 신뢰할 수 있는 시스템을 가능하게 하는 궁극적인 목표인 탈중앙화로 이어집니다.
- 전체 노드는 이더리움에 의존하는 경량 클라이언트에게 블록체인 데이터를 제공합니다. 라이트 노드는 전체 블록체인을 저장하지 않고, 대신 [블록 헤더의 상태 루트](/developers/docs/blocks/#block-anatomy)를 통해 데이터를 검증합니다. 필요한 경우 전체 노드에서 추가 정보를 요청할 수 있습니다.

전체 노드를 실행하면, 검증자를 실행하지 않더라도 이더리움 네트워크 전체가 혜택을 받습니다.

## 자신의 노드 실행 {# running-your-own-node}

자신만의 이더리움 클라이언트를 실행해 보고 싶나요?

초보자를 위한 소개는 [노드 실행하기](/run-a-node) 페이지에서 자세히 알아보세요.

기술적인 사용자라면, [자신만의 노드를 가동하는 방법](/developers/docs/nodes-and-clients/run-a-node/)에 대한 자세한 내용과 옵션을 살펴보세요.

## 대안 {#alternatives}

자신만의 노드를 설정하는 데 시간과 자원이 소요될 수 있지만, 항상 자신의 인스턴스를 실행할 필요는 없습니다. 이 경우 제3자 API 제공업체를 사용할 수 있습니다. 이러한 서비스 사용에 대한 개요는 [서비스형 노드](/developers/docs/nodes-and-clients/nodes-as-a-service/)를 확인하세요.

커뮤니티 내에서 공용 API를 사용하는 이더리움 노드를 실행하는 사람이 있다면, 커스텀 RPC를 통해 지갑을 커뮤니티 노드에 연결하고 무작위로 신뢰된 제3자보다 더 많은 개인 정보를 확보할 수 있습니다.

반면에 클라이언트를 실행하면 필요할 때 친구들과 공유할 수 있습니다.

## 실행 클라이언트 {#execution-clients}

이더리움 커뮤니티는 여러 오픈 소스 실행 클라이언트(이전에는 'Eth1 클라이언트' 또는 '이더리움 클라이언트'로 알려짐)를 유지 관리하며, 다양한 프로그래밍 언어를 사용해 다양한 팀이 개발합니다. 이를 통해 네트워크는 더욱 강력해지고 [다양해집니다](/developers/docs/nodes-and-clients/client-diversity/). 궁극적인 목표는 어떤 클라이언트도 지배하지 않도록 다양성을 달성하여 단일 장애 지점을 줄이는 것입니다.

이 표는 다양한 클라이언트를 요약합니다. 모든 클라이언트는 [클라이언트 테스트](https://github.com/ethereum/tests)를 통과하며 네트워크 업그레이드에 맞춰 최신 상태를 유지하기 위해 활발하게 유지 관리됩니다.

| 클라이언트                                                                                     | 언어                       | 운영 체제                 | 네트워크                  | 동기화 전략                                                                  | 상태 가지치기    |
| ----------------------------------------------------------------------------------------- | ------------------------ | --------------------- | --------------------- | ----------------------------------------------------------------------- | ---------- |
| [Geth](https://geth.ethereum.org/)                                                        | Go                       | Linux, Windows, macOS | 메인넷, Sepolia, Holesky | [Snap](#snap-sync), [Full](#full-sync)                                  | 아카이브, 가지치기 |
| [Nethermind](https://www.nethermind.io/)                                                  | C#, .NET | Linux, Windows, macOS | 메인넷, Sepolia, Holesky | [Snap](#snap-sync)(제공 안 함), Fast, [Full](#full-sync) | 아카이브, 가지치기 |
| [Besu](https://besu.hyperledger.org/en/stable/)                                           | 자바                       | Linux, Windows, macOS | 메인넷, Sepolia, Holesky | [Snap](#snap-sync), [Fast](#fast-sync), [Full](#full-sync)              | 아카이브, 가지치기 |
| [Erigon](https://github.com/ledgerwatch/erigon)                                           | Go                       | Linux, Windows, macOS | 메인넷, Sepolia, Holesky | [Full](#full-sync)                                                      | 아카이브, 가지치기 |
| [Reth](https://reth.rs/)                                                                  | 러스트                      | Linux, Windows, macOS | 메인넷, Sepolia, Holesky | [Full](#full-sync)                                                      | 아카이브, 가지치기 |
| [EthereumJS](https://github.com/ethereumjs/ethereumjs-monorepo) _(베타)_ | 타입스크립트                   | Linux, Windows, macOS | Sepolia, Holesky      | [Full](#full-sync)                                                      | 삭제된 데이터    |

지원되는 네트워크에 대한 자세한 내용은 [이더리움 네트워크](/developers/docs/networks/)를 참조하세요.

각 클라이언트는 고유한 사용 사례와 장점을 가지고 있으며, 개인의 선호에 따라 선택해야 합니다. 다양성은 서로 다른 기능과 사용자층에 집중할 수 있는 구현을 가능하게 합니다. 기능, 지원, 프로그래밍 언어 또는 라이선스를 기반으로 클라이언트를 선택할 수 있습니다.

### Besu {#besu}

Hyperledger Besu는 공개 및 허가된 네트워크를 위한 엔터프라이즈급 이더리움 클라이언트입니다. 이 클라이언트는 추적에서 GraphQL까지 이더리움 메인넷의 모든 기능을 실행하며, ConsenSys의 개방형 커뮤니티 채널 및 기업을 위한 상업적 SLA를 통해 지원됩니다. 자바로 작성되었으며, Apache 2.0 라이선스를 따릅니다.

Besu의 광범위한 [문서](https://besu.hyperledger.org/en/stable/)는 기능 및 설정에 대한 모든 세부 정보를 안내합니다.

### Erigon {#erigon}

Erigon은 이전에는 Turbo-Geth로 알려졌으며, 디스크 공간 효율성과 속도를 중시하는 Go Ethereum의 포크로 시작되었습니다. Erigon은 완전히 재구성된 이더리움 구현체로, 현재는 Go로 작성되었지만 다른 언어로의 구현이 개발 중에 있습니다. Erigon의 목표는 더 빠르고 모듈화되고 최적화된 이더리움 구현을 제공하는 것입니다. 이 클라이언트는 약 2TB의 디스크 공간을 사용하여 3일 이내에 전체 아카이브 노드 동기화를 수행할 수 있습니다.

### Go Ethereum {#geth}

Go Ethereum(Geth로 약칭)은 이더리움 프로토콜의 최초 구현 중 하나입니다. 현재는 가장 널리 사용되는 클라이언트로, 가장 큰 사용자 기반과 다양한 도구를 제공합니다. Go로 작성되었으며, 완전한 오픈 소스이며, GNU LGPL v3 라이선스를 따릅니다.

Geth에 대한 자세한 내용은 해당 [문서](https://geth.ethereum.org/docs/)를 참조하세요.

### Nethermind {#nethermind}

Nethermind는 C# .NET 기술 스택을 사용하여 개발된 이더리움 구현체로, LGPL-3.0 라이선스를 따르며 ARM을 포함한 주요 플랫폼에서 실행됩니다. 최고의 성능을 제공합니다:

- 최적화된 가상 머신
- 상태 접근
- 최적화된 가상 머신과 상태 접근, 네트워킹, Prometheus/Grafana 대시보드, seq 엔터프라이즈 로깅 지원, JSON-RPC 추적 및 분석 플러그인과 같은 풍부한 기능을 제공합니다.

Nethermind는 또한 [자세한 문서](https://docs.nethermind.io), 강력한 개발자 지원, 온라인 커뮤니티 및 프리미엄 사용자를 위한 연중무휴 지원을 제공합니다.

### Reth {#reth}

Reth(러스트 이더리움의 약칭)는 사용자 친화적이고 모듈화되며 빠르고 효율적인 이더리움 전체 노드 구현체입니다. Reth는 원래 Paradigm에 의해 개발되었으며, Apache와 MIT 라이선스를 따릅니다.

Reth는 스테이킹이나 고가용성 서비스 같은 미션 크리티컬한 환경에서 사용할 수 있는 프로덕션 준비가 완료된 상태입니다. 높은 성능과 넓은 이익률이 요구되는 경우, 예를 들어 RPC, MEV, 인덱싱, 시뮬레이션 및 P2P 활동에서 뛰어난 성능을 발휘합니다.

[Reth Book](https://reth.rs/) 또는 [Reth GitHub 저장소](https://github.com/paradigmxyz/reth?tab=readme-ov-file#reth)를 확인하여 자세히 알아보세요.

### 개발 중 {#execution-in-development}

이 클라이언트들은 아직 개발 초기 단계에 있으며, 프로덕션 사용에 권장되지 않습니다.

#### EthereumJS {#ethereumjs}

EthereumJS 실행 클라이언트(EthereumJS)는 TypeScript로 작성되었으며, 블록, 트랜잭션 및 머클-패트리샤 트리 클래스와 같은 핵심 이더리움 원시 패키지 및 이더리움 가상 머신(EVM) 구현, 블록체인 클래스, DevP2P 네트워킹 스택을 포함한 핵심 클라이언트 구성 요소로 구성되어 있습니다.

[문서](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master)를 읽고 자세히 알아보세요.

## 합의 클라이언트 {#consensus-clients}

[합의 업그레이드](/roadmap/beacon-chain/)를 지원하는 여러 합의 클라이언트(이전에는 'Eth2' 클라이언트라고 알려짐)가 있습니다. 이들은 포크 선택 알고리즘, 증명 처리, [지분 증명](/developers/docs/consensus-mechanisms/pos) 보상 및 페널티 관리를 포함한 모든 합의 관련 로직을 담당합니다.

| 클라이언트                                                         | 언어     | 운영 체제                 | 네트워크                                       |
| ------------------------------------------------------------- | ------ | --------------------- | ------------------------------------------ |
| [Lighthouse](https://lighthouse.sigmaprime.io/)               | 러스트    | Linux, Windows, macOS | 비콘 체인, Holesky, Pyrmont, Sepolia 등         |
| [Lodestar](https://lodestar.chainsafe.io/)                    | 타입스크립트 | Linux, Windows, macOS | 비콘 체인, Holesky, Sepolia 등                  |
| [Nimbus](https://nimbus.team/)                                | Nim    | Linux, Windows, macOS | 비콘 체인, Holesky, Sepolia 등                  |
| [Prysm](https://prysm.offchainlabs.com/docs/)                 | Go     | Linux, Windows, macOS | 비콘 체인, Gnosis, Holesky, Pyrmont, Sepolia 등 |
| [Teku](https://consensys.net/knowledge-base/ethereum-2/teku/) | 자바     | Linux, Windows, macOS | 비콘 체인, Gnosis, Holesky, Sepolia 등          |
| [Grandine](https://docs.grandine.io/)                         | 러스트    | Linux, Windows, macOS | 비콘 체인, Holesky, Sepolia 등                  |

### Lighthouse {#lighthouse}

Lighthouse는 Rust로 작성된 합의 클라이언트 구현체이며 Apache-2.0 라이선스 하에 있습니다. 이 클라이언트는 Sigma Prime에서 유지 관리되며 비콘 체인 시작 이후로 안정적이고 생산 준비가 완료된 상태입니다. 여러 기업, 스테이킹 풀, 개인 사용자들이 이 클라이언트를 신뢰하고 있습니다. 이 클라이언트는 보안성, 성능, 그리고 데스크탑 PC부터 정교한 자동 배포에 이르기까지 다양한 환경에서의 상호 운용성을 목표로 하고 있습니다.

문서는 [Lighthouse Book](https://lighthouse-book.sigmaprime.io/)에서 찾을 수 있습니다.

### Lodestar {#lodestar}

Lodestar는 Typescript로 작성된 LGPL-3.0 라이선스 하의 생산 준비가 완료된 합의 클라이언트 구현체입니다. 이 클라이언트는 ChainSafe Systems에서 유지 관리되며 솔로 스테이커, 개발자 및 연구자를 위한 최신 합의 클라이언트 중 하나입니다. Lodestar는 이더리움 프로토콜의 JavaScript 구현을 바탕으로 비콘 노드와 검증자 클라이언트로 구성되어 있습니다. Lodestar는 라이트 클라이언트를 통해 이더리움 사용성을 개선하고 더 큰 개발자 그룹에 대한 접근성을 확장하며 생태계 다양성에 기여하는 것을 목표로 합니다.

자세한 정보는 [Lodestar 웹사이트](https://lodestar.chainsafe.io/)에서 찾을 수 있습니다.

### Nimbus {#nimbus}

Nimbus는 Nim으로 작성된 Apache-2.0 라이선스 하의 합의 클라이언트 구현체입니다. 이 클라이언트는 솔로 스테이커와 스테이킹 풀에서 사용되는 생산 준비가 완료된 클라이언트입니다. Nimbus는 리소스 효율성을 위해 설계되어 리소스가 제한된 장치 및 기업 인프라에서 안정성이나 보상 성능을 저해하지 않으면서도 쉽게 실행할 수 있습니다. 가벼운 리소스 풋프린트는 네트워크가 스트레스를 받을 때 클라이언트의 안전 여유를 더 크게 만듭니다.

[Nimbus 문서](https://nimbus.guide/)에서 자세히 알아보세요.

### Prysm {#prysm}

Prysm은 Go로 작성된 GPL-3.0 라이선스 하의 모든 기능을 갖춘 오픈 소스 합의 클라이언트입니다. 이 클라이언트는 선택적 웹앱 UI를 제공하며 사용자 경험, 문서화, 구성 가능성을 우선시합니다. 이는 가정 내 스테이킹 사용자와 기관 사용자를 위해 설계되었습니다.

자세히 알아보려면 [Prysm 문서](https://prysm.offchainlabs.com/docs/)를 방문하세요.

### Teku {#teku}

Teku는 최초의 비콘 체인 제네시스 클라이언트 중 하나입니다. 보안성, 강건성, 안정성, 사용성, 성능 등의 일반적인 목표와 함께, Teku는 다양한 합의 클라이언트 표준을 완전히 준수하는 것을 목표로 합니다.

Teku는 매우 유연한 배포 옵션을 제공합니다. 비콘 노드와 검증자 클라이언트는 단일 프로세스로 함께 실행될 수 있어 솔로 스테이커에게 매우 편리하며, 또는 더 정교한 스테이킹 작업을 위해 별도로 실행할 수 있습니다. 또한 Teku는 서명 키 보안 및 슬래싱 방지를 위해 [Web3Signer](https://github.com/ConsenSys/web3signer/)와 완벽하게 상호 운용됩니다.

Teku는 Java로 작성되었으며 Apache 2.0 라이선스를 따릅니다. 이 클라이언트는 Besu와 Web3Signer를 책임지는 ConsenSys의 프로토콜 팀에서 개발되었습니다. [Teku 문서](https://docs.teku.consensys.net/en/latest/)에서 자세히 알아보세요.

### Grandine {#grandine}

Grandine은 Rust로 작성된 합의 클라이언트 구현체로, GPL-3.0 라이선스를 따릅니다. Grandine Core Team에 의해 유지되며, 빠르고 고성능이며 경량입니다. 이 클라이언트는 Raspberry Pi와 같은 저자원 장치에서 실행되는 솔로 스테이커부터 수만 개의 검증자를 실행하는 대규모 기관 스테이커에 이르기까지 다양한 스테이커에 적합합니다.

문서는 [Grandine Book](https://docs.grandine.io/)에서 찾을 수 있습니다.

## 동기화 모드 {#sync-modes}

네트워크의 최신 데이터를 따르고 확인하기 위해 이더리움 클라이언트는 최신 네트워크 상태와 동기화되어야 합니다. 이것은 피어로부터 데이터를 다운로드하고 암호적으로 무결성을 확인하며 로컬 블록체인 데이터베이스를 구축하여 수행됩니다.

동기화 모드는 이러한 과정을 다양한 트레이드 오프와 함께 나타냅니다. 클라이언트는 동기화 알고리즘 구현에서도 차이가 있습니다. 구체적인 구현에 대해서는 선택한 클라이언트의 공식 문서를 항상 참조하십시오.

### 실행 레이어 동기화 모드 {#execution-layer-sync-modes}

실행 레이어는 다양한 사용 사례에 맞게 블록체인의 세계 상태를 재실행하는 것부터 신뢰할 수 있는 체크포인트에서 체인의 팁과만 동기화하는 것까지 다양한 모드에서 실행될 수 있습니다.

#### 전체 동기화 {#full-sync}

전체 동기화는 모든 블록(헤더 및 블록 본문 포함)을 다운로드하고 제네시스부터 모든 블록을 실행하여 블록체인의 상태를 점진적으로 재생성합니다.

- 모든 트랜잭션을 확인하여 신뢰를 최소화하고 최고 수준의 보안을 제공합니다.
- 트랜잭션 수가 증가함에 따라 모든 트랜잭션을 처리하는 데 며칠에서 몇 주가 걸릴 수 있습니다.

[아카이브 노드](#archive-node)는 전체 동기화를 수행하여 모든 블록의 모든 트랜잭션에 의해 발생한 상태 변경의 전체 기록을 구축(및 유지)합니다.

#### 빠른 동기화 {#fast-sync}

전체 동기화와 마찬가지로, 빠른 동기화는 모든 블록(헤더, 트랜잭션 및 영수증 포함)을 다운로드합니다. 그러나 과거의 트랜잭션을 재처리하는 대신 빠른 동기화는 최근 헤드에 도달할 때까지 영수증을 신뢰하고, 그 후에는 블록을 가져오고 처리하여 전체 노드를 제공합니다.

- 빠른 동기화 전략.
- 처리 수요를 줄이고 대역폭 사용을 선호합니다.

#### 스냅 동기화 {#snap-sync}

스냅 동기화도 체인을 블록별로 검증합니다. 하지만 스냅 동기화는 제네시스 블록에서 시작하지 않고, 진짜 블록체인의 일부로 확인된 '신뢰할 수 있는' 최신 체크포인트에서 시작합니다. 노드는 주기적으로 체크포인트를 저장하고 일정 연령 이상의 데이터를 삭제합니다. 이 스냅샷은 필요에 따라 상태 데이터를 재생성하는 데 사용되며, 데이터를 영구적으로 저장하지 않습니다.

- 현재 이더리움 메인넷에서 기본 설정된 가장 빠른 동기화 전략.
- 보안성을 희생하지 않고 디스크 사용량과 네트워크 대역폭을 많이 절약합니다.

[스냅 동기화에 대한 추가 정보](https://github.com/ethereum/devp2p/blob/master/caps/snap.md).

#### 라이트 동기화 {#light-sync}

경량 클라이언트 모드는 모든 블록 헤더, 블록 데이터를 다운로드하고 일부를 무작위로 검증합니다. 신뢰할 수 있는 체크포인트에서 체인의 팁만 동기화합니다.

- 개발자와 합의 메커니즘에 대한 신뢰를 바탕으로 최신 상태만 가져옵니다.
- 몇 분 안에 현재 네트워크 상태로 클라이언트를 사용할 수 있습니다.

**참고** 라이트 동기화는 아직 지분 증명 이더리움에서 작동하지 않습니다. 새로운 버전의 라이트 동기화가 곧 출시될 예정입니다!

[라이트 클라이언트에 대한 추가 정보](/developers/docs/nodes-and-clients/light-clients/)

### 합의 레이어 동기화 모드 {#consensus-layer-sync-modes}

#### 낙관적 동기화 {#optimistic-sync}

낙관적 동기화는 머지 이후의 동기화 전략으로, 선택적으로 사용할 수 있으며 이전 버전과 호환됩니다. 이를 통해 실행 노드가 기존 방법을 통해 동기화할 수 있습니다. 실행 엔진은 비콘 블록을 완전히 검증하지 않고 _낙관적으로_ 가져와 최신 헤드를 찾은 다음, 위 방법으로 체인 동기화를 시작할 수 있습니다. 그 후 실행 클라이언트가 최신 상태에 도달하면 비콘 체인의 트랜잭션 유효성을 합의 클라이언트에 알립니다.

[낙관적 동기화에 대한 추가 정보](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md)

#### 체크포인트 동기화 {#checkpoint-sync}

체크포인트 동기화, 즉 약한 주관성 동기화는 비콘 노드를 동기화하는 데 있어 우수한 사용자 경험을 제공합니다. 이는 [약한 주관성](/developers/docs/consensus-mechanisms/pos/weak-subjectivity/)의 가정을 기반으로 하며, 이를 통해 제네시스 대신 최근의 약한 주관성 체크포인트에서 비콘 체인을 동기화할 수 있습니다. 체크포인트 동기화는 [제네시스](/glossary/#genesis-block)에서 동기화하는 것과 유사한 신뢰 가정을 통해 초기 동기화 시간을 훨씬 더 빠르게 만듭니다.

실제로 이는 노드가 원격 서비스를 연결하여 최근의 최종 상태를 다운로드한 후 그 시점부터 데이터를 검증하는 것을 의미합니다. 데이터를 제공하는 제3자에 대한 신뢰가 필요하며, 신중히 선택해야 합니다.

[체크포인트 동기화](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice)에 대한 추가 정보

## 더 읽어보기 {#further-reading}

- [이더리움 101 - 2부 - 노드 이해하기](https://kauri.io/ethereum-101-part-2-understanding-nodes/48d5098292fd4f11b251d1b1814f0bba/a) _– Wil Barnes, 2019년 2월 13일_
- [이더리움 전체 노드 실행하기: 동기 부여가 거의 없는 분들을 위한 안내서](https://medium.com/@JustinMLeroux/running-ethereum-full-nodes-a-guide-for-the-barely-motivated-a8a13e7a0d31) _– Justin Leroux, 2019년 11월 7일_

## 관련 주제 {#related-topics}

- [블록](/developers/docs/blocks/)
- [네트워크](/developers/docs/networks/)

## 관련 튜토리얼 {#related-tutorials}

- [MicroSD 카드 플래싱만으로 Raspberry Pi 4를 검증자 노드로 전환하기 – 설치 가이드](/developers/tutorials/run-node-raspberry-pi/) _– Raspberry Pi 4를 플래시하고, 이더넷 케이블을 연결하고, SSD 디스크를 연결하고 장치에 전원을 공급하여 Raspberry Pi 4를 실행 레이어(메인넷) 및/또는 합의 레이어(비콘 체인/검증자)를 실행하는 전체 이더리움 노드로 전환합니다._
