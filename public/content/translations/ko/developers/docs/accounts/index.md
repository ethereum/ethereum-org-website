---
title: "이더리움 계정"
description: "이더리움 계정에 대한 설명 - 이더리움 데이터 구조와 주요 키 페어 크립토그래피들의 관계"
lang: ko
---

이더리움 계정은 이더(ETH) 잔액이 있으며 이더리움에 메시지를 전송할 수 있는 개체입니다. 계정은 사용자가 직접 제어하거나 스마트 계약을 통해 배포할 수도 있습니다.

## 필수 구성 요소 {#prerequisites}

이 페이지를 더 잘 이해하려면 먼저 [이더리움 소개](/developers/docs/intro-to-ethereum/)를 읽어보시는 것을 권장합니다.

## 계정 유형 {#types-of-account}

이더리움에는 두 가지의 계정 종류가 있습니다.

- 외부 계정 - 해당 계정의 개인 키가 있는 사람이라면 누구나 제어할 수 있습니다
- 컨트랙트 계정 - 네트워크에 배포된 스마트 계약이며 코드를 통해 제어합니다 [스마트 계약](/developers/docs/smart-contracts/)에 대해 알아보기

두 가지의 계정 종류 모두 아래와 같은 기능이 있습니다.

- ETH 및 토큰 수령, 보유, 전송
- 배포된 스마트 계약과 상호작용

### 주요 차이점 {#key-differences}

**외부 소유 계정**

- 비용 없이 계정을 만들 수 있습니다.
- 트랜잭션을 개시할 수 있습니다.
- 외부 소유 계정 간에는 ETH 또는 토큰 전송 거래만 가능합니다.
- 계정 활동을 제어하는 공개키와 비밀키로 만들어집니다.

**컨트랙트 계정**

- 네트워크 스토리지를 사용하기 때문에 계정을 만들 때 비용이 듭니다.
- 트랜잭션 수신에 대한 응답으로만 메시지를 전송할 수 있습니다.
- 외부 소유 계정에서 컨트랙트 계정으로의 트랜잭션은 토큰 전송이나 더 나아가 신규 컨트랙트 생성과 같은 다양한 작업을 실행할 수 있는 코드를 트리거 할 수 있습니다.
- 컨트랙트 계정은 비밀키를 갖고 있지 않습니다. 대신, 스마트 컨트랙트 로직에 의해 제어됩니다.

## 계정 살펴보기 {#an-account-examined}

이더리움 계정에는 네 가지의 값이 있습니다.

- `nonce` – 외부 소유 계정에서 전송한 트랜잭션 수 또는 컨트랙트 계정으로 생성된 컨트랙트 수를 나타내는 카운터입니다. 주어진 논스로는 한 계정당 하나의 트랜잭션만 수행될 수 있으며, 이는 이미 수행된 트랜잭션의 반복적인 전송과 수행을 이용한 반복 공격을 방지할 수 있습니다.
- `balance` – 해당 주소가 보유하고 있는 wei의 값입니다. 웨이(Wei)는 ETH의 단위이며 100경 Wei는 1 ETH를 나타냅니다.
- `codeHash` – 이 해시는 이더리움 가상 머신(EVM)에 있는 계정의 _코드_를 나타냅니다. 계약 계정에는 서로 다른 작업을 실행할 수 있도록 프로그램된 코드 조각들이 있습니다. 이 EVM 코드는 계정이 메시지 콜을 받았을 때 실행됩니다. 이 값은 다른 계정 값과는 다르게 바꿀 수 없습니다. 추후 검색을 위해 모든 코드 조각들은 상태 데이터베이스 내에 그에 해당하는 해쉬값 아래 보관됩니다. 이 해쉬값이 바로 codeHash입니다. 외부 소유 계정의 경우, codeHash 필드는 빈 문자열 해시입니다.
- `storageRoot` – 스토리지 해시라고도 합니다. 계정의 스토리지 콘텐츠(256비트 정수 값 간의 매핑)를 인코딩하는 [머클 패트리샤 트리](/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) 루트 노드의 256비트 해시입니다. 이는 256비트 정수 키의 Keccak-256 해시에서 RLP로 인코딩된 256비트 정수 값으로의 매핑으로 트라이에 인코딩됩니다. 이 트리는 계정에 저장된 내용을 해시로 인코딩한 것으로, 기본적으로는 비어 있습니다.

![계정의 구성을 보여주는 다이어그램](./accounts.png)
_[Ethereum EVM illustrated](https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf)에서 발췌한 다이어그램_

## 외부 소유 계정과 키 쌍 {#externally-owned-accounts-and-key-pairs}

계정은 공개 및 비공개 암호화 키 쌍으로 구성됩니다. 이러한 키 쌍들로 발송인이 실제로 트랜잭션에 서명하였는 지 증명하고 위조를 방지할 수 있습니다. 개인 키는 트랜잭션에 서명하는 데 쓰이며, 계정과 연결된 자금을 보관할 수 있도록 합니다. 본인은 실제로 암호화폐를 소유하지 않으며, 개인 키만을 가지고 있다는 사실을 기억하세요. 자금은 언제나 이더리움 원장 상에 존재합니다.

트랜잭션 전송인을 항상 검증할 수 있기 때문에 의심스러운 사용자들이 가짜 트랜잭션을 전송하는 것을 방지할 수 있습니다.

앨리스가 계정에서 밥의 계정으로 이더를 보내려면 엘리스는 트랜잭션 요청을 생성한 후 검증을 위해 트랜잭션을 네트워크로 보내야 합니다. 이더리움의 공개 키 암호 사용은 앨리스가 그 트랜잭션 요청을 처음 개시함을 증명할 수 있음을 보장합니다. 암호화 메커니즘이 없다면, 악의적 상대방인 이브가 "앨리스의 계정에서 이브의 계정으로 5 ETH 전송"과 같은 요청을 그냥 공개적으로 퍼뜨릴 수 있고 아무도 그러한 요청이 앨리스로부터 오지 않았음을 검증할 수 없을 겁니다.

## 계정 생성 {#account-creation}

계정을 생성하려면 대부분의 라이브러리가 무작위 비공개 키를 생성해 줍니다.

개인 키는 64개의 16진수 문자로 이루어져 있고 비밀번호로 암호화 가능합니다.

예시:

`fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036415f`

[타원 곡선 디지털 서명 알고리즘](https://wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)을 사용하여 개인 키에서 공개 키가 생성됩니다. 공개 키의 Keccak-256 해시값 중 마지막 20바이트를 가져와 맨 앞에 `0x`를 추가하면 계정의 공개 주소를 얻을 수 있습니다.

즉, 외부 소유 계정(EOA)은 42자의 주소(20바이트 세그먼트, 40개의 16진수 문자와 `0x` 접두사)로 구성됩니다.

예시:

`0x5e97870f263700f46aa00d967821199b9bc5a120`

다음 예제는 [Clef](https://geth.ethereum.org/docs/tools/clef/introduction)라는 서명 도구를 사용하여 새 계정을 생성하는 방법을 보여줍니다. Clef는 계정 관리 및 서명 도구로 이더리움 클라이언트인 [Geth](https://geth.ethereum.org)와 함께 제공됩니다. `clef newaccount` 명령어는 새로운 키 쌍을 생성하고 암호화된 키스토어에 저장합니다.

```
> clef newaccount --keystore <path>

생성할 새 계정의 암호를 입력하세요:
> <password>

------------
INFO [10-28|16:19:09.156] 새 키가 생성되었습니다       address=0x5e97870f263700f46aa00d967821199b9bc5a120
WARN [10-28|16:19:09.306] 키 파일을 백업하세요      path=/home/user/go-ethereum/data/keystore/UTC--2022-10-28T15-19-08.000825927Z--5e97870f263700f46aa00d967821199b9bc5a120
WARN [10-28|16:19:09.306] 암호를 꼭 기억하세요!
생성된 계정 0x5e97870f263700f46aa00d967821199b9bc5a120
```

[Geth 문서](https://geth.ethereum.org/docs)

개인 키로부터 새 공개 키를 파생하는 것은 가능하지만, 공개 키로부터 개인 키를 파생할 수는 없습니다. 개인 키를 안전하게 보관하고 이름 그대로 \*\*비공개(PRIVATE)\*\*로 유지하는 것이 중요합니다.

여러분은 메세지와 트랜잭션을 서명해서 서명을 만들기 위해서 개인 키가 필요합니다. 그러면 다른이들은 여러분의 공개 키를 도출해서 그 메시지의 작성자를 증명하기 위해서 그 서명을 획득 할 수 있습니다. 애플리케이션에서 JavaScript 라이브러리를 사용하여 네트워크에 트랜잭션을 전송할 수 있습니다.

## 컨트랙트 계정 {#contract-accounts}

컨트랙트 계정 또한 42개 문자로 이루어진 16진수 주소를 갖습니다.

예시:

`0x06012c8cf97bead5deae237070f9587f8e7a266d`

컨트랙트 주소는 대개 컨트랙트가 이더리움 블록체인에 배포되는 시점에 주어집니다. 이 주소는 그 생성자의 주소와 그 주소로부터 전송된 트랜잭션 번호("논스") 에서 추출됩니다.

## 검증자 키 {#validators-keys}

이더리움이 작업 증명에서 합의에 기반한 지분증명으로 바뀌면서 다른 타입의 키가 만들어집니다. 일명 BLS라는 키로, 이 키는 누가 검증자인지 구별하는데 쓰입니다. 이러한 키를 효율적으로 집계하여 네트워크가 합의에 도달하는 데 필요한 대역폭을 줄일 수 있습니다. 이 키 집계가 없으면 검증자의 최소 지분은 훨씬 더 높아질 것입니다.

[검증자 키에 대해 더 알아보기](/developers/docs/consensus-mechanisms/pos/keys/).

## 지갑에 대한 참고 사항 {#a-note-on-wallets}

계정은 지갑이 아닙니다. 지갑은 외부 소유 계정 또는 계약 계정과 상호작용할 수 있게 해주는 인터페이스 또는 애플리케이션입니다.

## 시각적 데모 {#a-visual-demo}

오스틴이 해시 함수와 키 쌍에 대해 설명하는 것을 보세요.

<YouTube id="QJ010l-pBpE" />

<YouTube id="9LtBDy67Tho" />

## 더 읽어보기 {#further-reading}

- [이더리움 계정 이해하기](https://info.etherscan.com/understanding-ethereum-accounts/) - etherscan

_도움이 되었던 커뮤니티 참고 자료를 알고 계신가요? 이 페이지를 편집해서 추가하세요!_

## 관련 주제 {#related-topics}

- [스마트 계약](/developers/docs/smart-contracts/)
- [트랜잭션](/developers/docs/transactions/)
