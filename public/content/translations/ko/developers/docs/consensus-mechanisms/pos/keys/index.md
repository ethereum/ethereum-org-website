---
title: "지분 증명 이더리움의 키"
description: "이더리움의 지분 증명 합의 메커니즘에서 사용되는 키에 대한 설명"
lang: ko
---

이더리움은 공개-개인 키 암호학을 사용하여 사용자 자산을 보호합니다. 공개 키는 이더리움 주소의 기반으로 사용됩니다. 즉, 일반 대중에게 공개되며 고유 식별자로 사용됩니다. 개인(또는 '비밀') 키는 계정 소유자만 액세스할 수 있어야 합니다. 개인 키는 트랜잭션과 데이터에 '서명'하는 데 사용되며, 이를 통해 암호학은 특정 개인 키의 보유자가 일부 작업을 승인했음을 증명할 수 있습니다.

이더리움의 키는 [타원 곡선 암호학](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)을 사용하여 생성됩니다.

하지만 이더리움이 [작업 증명](/developers/docs/consensus-mechanisms/pow)에서 [지분 증명](/developers/docs/consensus-mechanisms/pos)으로 전환되면서 새로운 유형의 키가 이더리움에 추가되었습니다. 기존 키는 이전과 똑같이 작동하며 계정을 보호하는 타원 곡선 기반 키에는 변경 사항이 없었습니다. 그러나 ETH를 스테이킹하고 검증자를 운영하여 지분 증명에 참여하려면 사용자에게 새로운 유형의 키가 필요했습니다. 이러한 필요성은 수많은 검증자 간에 오가는 많은 메시지로 인한 확장성 문제에서 비롯되었습니다. 네트워크가 합의에 도달하는 데 필요한 통신량을 줄이려면 쉽게 집계할 수 있는 암호화 방법이 필요했기 때문입니다.

이 새로운 유형의 키는 [**Boneh-Lynn-Shacham(BLS)** 서명 체계](https://wikipedia.org/wiki/BLS_digital_signature)를 사용합니다. BLS는 매우 효율적인 서명 집계를 가능하게 하지만, 집계된 개별 검증자 키의 리버스 엔지니어링도 허용하므로 검증자 간의 작업을 관리하는 데 이상적입니다.

## 두 가지 유형의 검증자 키 {#two-types-of-keys}

지분 증명으로 전환하기 전 이더리움 사용자는 자금에 액세스하기 위한 단일 타원 곡선 기반 개인 키만 가지고 있었습니다. 지분 증명이 도입되면서 단독 스테이커가 되고자 하는 사용자는 **검증자 키**와 **인출 키**도 필요하게 되었습니다.

### 검증자 키 {#validator-key}

검증자 서명 키는 두 가지 요소로 구성됩니다.

- 검증자 **개인** 키
- 검증자 **공개** 키

검증자 개인 키의 목적은 블록 제안 및 증명과 같은 온체인 작업에 서명하는 것입니다. 이 때문에 이 키는 핫월렛에 보관해야 합니다.

이러한 유연성 덕분에 검증자 서명 키를 한 장치에서 다른 장치로 매우 빠르게 이동할 수 있다는 장점이 있지만, 키를 분실하거나 도난당한 경우 도둑이 다음과 같은 몇 가지 방법으로 **악의적으로 행동**할 수 있습니다.

- 다음을 통해 검증자가 삭감되도록 합니다.
  - 제안자로서 동일한 슬롯에 대해 서로 다른 두 개의 비콘 블록에 서명
  - 증명자로서 다른 증명을 "둘러싸는" 증명에 서명
  - 증명자로서 동일한 대상을 갖는 서로 다른 두 개의 증명에 서명
- 자발적 출금을 강제하여 검증자의 스테이킹을 중단시키고, 인출 키 소유자에게 ETH 잔액에 대한 접근 권한을 부여합니다.

사용자가 스테이킹 예치 계약에 ETH를 예치할 때 **검증자 공개 키**가 트랜잭션 데이터에 포함됩니다. 이는 _예치 데이터_라고 하며, 이더리움이 검증자를 식별할 수 있도록 합니다.

### 인출 자격 증명 {#withdrawal-credentials}

모든 검증자는 _인출 자격 증명_이라는 속성을 가집니다. 이 32바이트 필드의 첫 번째 바이트는 계정 유형을 식별합니다. `0x00`은 기존 BLS(샤펠라 이전, 인출 불가) 자격 증명을, `0x01`은 실행 주소를 가리키는 레거시 자격 증명을, `0x02`는 최신 복리 자격 증명 유형을 나타냅니다.

`0x00` BLS 키를 가진 검증자는 초과 잔액 지급 또는 스테이킹에서 전체 인출을 활성화하기 위해 이러한 자격 증명을 실행 주소를 가리키도록 업데이트해야 합니다. 이는 초기 키 생성 시 예치 데이터에 실행 주소를 제공하거나, _또는_ 나중에 인출 키를 사용하여 `BLSToExecutionChange` 메시지에 서명하고 브로드캐스트함으로써 수행할 수 있습니다.

[검증자 인출 자격 증명에 대한 추가 정보](/developers/docs/consensus-mechanisms/pos/withdrawal-credentials/)

### 인출 키 {#withdrawal-key}

초기 예치 시 설정하지 않은 경우, 인출 자격 증명을 실행 주소를 가리키도록 업데이트하려면 인출 키가 필요합니다. 이를 통해 초과 잔액 지급 처리가 시작될 수 있으며, 사용자는 스테이킹된 ETH를 완전히 인출할 수 있게 됩니다.

검증자 키와 마찬가지로 인출 키도 다음 두 가지 구성 요소로 이루어져 있습니다.

- 인출 **개인** 키
- 인출 **공개** 키

인출 자격 증명을 `0x01` 유형으로 업데이트하기 전에 이 키를 분실하면 검증자 잔액에 대한 접근 권한을 잃게 됩니다. 이러한 작업에는 검증자의 개인 키가 필요하므로 검증자는 여전히 증명과 블록에 서명할 수 있지만, 인출 키를 분실하면 인센티브가 거의 또는 전혀 없습니다.

검증자 키를 이더리움 계정 키와 분리하면 단일 사용자가 여러 검증자를 실행할 수 있습니다.

![검증자 키 개요](validator-key-schematic.png)

**참고**: 스테이킹 의무를 종료하고 검증자 잔액을 인출하려면 현재 검증자 키로 [자발적 출금 메시지(VEM)](https://mirror.xyz/ladislaus.eth/wmoBbUBes2Wp1_6DvP6slPabkyujSU7MZOFOC3QpErs&1)에 서명해야 합니다. 그러나 [EIP-7002](https://eips.ethereum.org/EIPS/eip-7002)는 사용자가 향후 인출 키로 출금 메시지에 서명하여 검증자 출금을 트리거하고 잔액을 인출할 수 있도록 하는 제안입니다. 이를 통해 ETH를 [서비스형 스테이킹 제공자](/staking/saas/#what-is-staking-as-a-service)에게 위임하는 스테이커가 자신의 자금을 계속 통제할 수 있게 되어 신뢰 가정이 줄어들 것입니다.

## 시드 문구에서 키 파생 {#deriving-keys-from-seed}

스테이킹된 모든 32 ETH마다 완전히 독립적인 2개의 새로운 키 세트가 필요하다면, 특히 여러 검증자를 실행하는 사용자의 경우 키 관리가 금방 힘들어질 것입니다. 대신, 여러 검증자 키를 단일 공통 비밀에서 파생시킬 수 있으며, 그 단일 비밀을 저장하면 여러 검증자 키에 액세스할 수 있습니다.

[니모닉](https://en.bitcoinwiki.org/wiki/Mnemonic_phrase)과 경로는 사용자가 지갑에 [액세스할 때](https://ethereum.stackexchange.com/questions/19055/what-is-the-difference-between-m-44-60-0-0-and-m-44-60-0) 자주 접하게 되는 두드러진 특징입니다. 니모닉은 개인 키의 초기 시드 역할을 하는 단어 시퀀스입니다. 추가 데이터와 결합하면 니모닉은 '마스터 키'라고 알려진 해시를 생성합니다. 이것은 트리의 루트로 생각할 수 있습니다. 이 루트의 브랜치는 계층적 경로를 사용하여 파생될 수 있으며, 이를 통해 자식 노드는 부모 노드의 해시와 트리 내 인덱스의 조합으로 존재할 수 있습니다. 니모닉 기반 키 생성에 대한 [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) 및 [BIP-19](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) 표준에 대해 읽어보세요.

이러한 경로는 다음과 같은 구조를 가지며, 하드웨어 지갑과 상호 작용해 본 사용자에게는 익숙할 것입니다.

```
m/44'/60'/0'/0`
```

이 경로의 슬래시는 개인 키의 구성 요소를 다음과 같이 분리합니다.

```
마스터_키 / 용도 / 코인_타입 / 계정 / 변경 / 주소_인덱스
```

이 로직을 통해 사용자는 단일 **니모닉 문구**에 가능한 한 많은 검증자를 연결할 수 있습니다. 트리의 루트는 공통으로 사용할 수 있고, 브랜치에서 차별화가 일어날 수 있기 때문입니다. 사용자는 니모닉 문구에서 **원하는 수의 키를 파생**할 수 있습니다.

```
      [m / 0]
     /
    /
[m] - [m / 1]
    \
     \
      [m / 2]
```

각 브랜치는 `/`로 구분되므로 `m/2`는 마스터 키에서 시작하여 브랜치 2를 따른다는 의미입니다. 아래 개요에서는 단일 니모닉 문구를 사용하여 각각 두 개의 관련 검증자가 있는 세 개의 인출 키를 저장합니다.

![검증자 키 로직](multiple-keys.png)

## 더 읽어보기 {#further-reading}

- [Carl Beekhuizen의 이더리움 재단 블로그 게시물](https://blog.ethereum.org/2020/05/21/keys/)
- [EIP-2333 BLS12-381 키 생성](https://eips.ethereum.org/EIPS/eip-2333)
- [EIP-7002: 실행 레이어 트리거 출금](https://web.archive.org/web/20250125035123/https://research.2077.xyz/eip-7002-unpacking-improvements-to-staking-ux-post-merge)
- [대규모 키 관리](https://docs.ethstaker.cc/ethstaker-knowledge-base/scaled-node-operators/key-management-at-scale)
