---
title: 스마트 계약 인증
description: 이더리움 스마트 계약의 소스 코드 검증 개요
lang: ko
---

[스마트 계약](/developers/docs/smart-contracts/)은 '무신뢰성(trustless)'을 갖도록 설계되었습니다. 즉, 사용자가 계약과 상호 작용하기 전에 제3자(예: 개발자 및 회사)를 신뢰할 필요가 없다는 것을 의미합니다. 무신뢰성을 위한 전제 조건으로, 사용자와 다른 개발자는 스마트 계약의 소스 코드를 검증할 수 있어야 합니다. 소스 코드 검증은 게시된 계약 코드가 이더리움 블록체인의 계약 주소에서 실행되는 코드와 동일하다는 것을 사용자와 개발자에게 보장합니다.

"소스 코드 검증"과 "[정형 검증](/developers/docs/smart-contracts/formal-verification/)"을 구별하는 것이 중요합니다. 아래에서 자세히 설명하겠지만 소스 코드 검증은 고급 언어(예: Solidity)로 작성된 스마트 계약의 주어진 소스 코드가 계약 주소에서 실행될 바이트코드와 동일하게 컴파일되는지 검증하는 것을 말합니다. 하지만 정형 검증은 스마트 계약의 정확성을 검증하는 것을 의미하며, 이는 계약이 예상대로 작동하는 것을 의미합니다. 문맥에 따라 다르지만, 계약 검증은 일반적으로 소스 코드 검증을 의미합니다.

## 소스 코드 검증이란 무엇인가요? {#what-is-source-code-verification}

[이더리움 가상 머신(EVM)](/developers/docs/evm/)에 스마트 계약을 배포하기 전에 개발자들은 계약의 소스 코드, 즉 [솔리디티](/developers/docs/smart-contracts/languages/) 또는 다른 고급 프로그래밍 언어로 작성된 지침을 바이트코드로 [컴파일](/developers/docs/smart-contracts/compiling/)합니다. EVM은 고급 지침을 해석할 수 없으므로, 소스 코드를 바이트코드(즉, 저수준 기계 명령어)로 컴파일하는 것은 EVM에서 계약 로직을 실행하는 데 필요합니다.

소스 코드 검증은 스마트 계약의 소스 코드와 계약 생성 중에 사용된 컴파일된 바이트코드를 비교하여 차이점을 감지하는 것입니다. 스마트 계약을 검증하는 것이 중요한 이유는 광고된 계약 코드가 블록체인에서 실행되는 것과 다를 수 있기 때문입니다.

스마트 계약 검증을 통해 기계 코드를 읽을 필요 없이 계약이 작성된 고급 언어를 통해 계약이 수행하는 작업을 조사할 수 있습니다. 함수, 값, 그리고 일반적으로 변수 이름과 주석은 컴파일 및 배포된 원본 소스 코드와 동일하게 유지됩니다. 이를 통해 코드를 훨씬 쉽게 읽을 수 있습니다. 소스 검증은 또한 최종 사용자가 스마트 계약이 무엇을 하도록 설계되었는지 알 수 있도록 코드 문서화를 제공합니다.

### 전체 검증이란 무엇인가요? {#full-verification}

소스 코드에는 주석이나 변수 이름과 같이 컴파일된 바이트코드에 영향을 주지 않는 일부 부분이 있습니다. 이는 서로 다른 변수 이름과 다른 주석을 가진 두 개의 소스 코드가 모두 동일한 계약을 검증할 수 있다는 것을 의미합니다. 이로 인해 악의적인 행위자가 소스 코드 내에 기만적인 주석을 추가하거나 오해의 소지가 있는 변수 이름을 부여하고 원본 소스 코드와 다른 소스 코드로 계약을 검증받을 수 있습니다.

소스 코드의 정확성에 대한 _암호화 보증_과 컴파일 정보의 _지문_ 역할을 하도록 바이트코드에 추가 데이터를 추가하여 이를 방지할 수 있습니다. 필요한 정보는 [솔리디티의 계약 메타데이터](https://docs.soliditylang.org/en/v0.8.15/metadata.html)에 있으며, 이 파일의 해시는 계약의 바이트코드에 추가됩니다. [메타데이터 플레이그라운드](https://playground.sourcify.dev)에서 작동하는 것을 볼 수 있습니다.

메타데이터 파일에는 소스 파일과 그 해시를 포함하여 계약의 컴파일에 대한 정보가 포함되어 있습니다. 즉, 컴파일 설정이나 소스 파일 중 하나의 바이트라도 변경되면 메타데이터 파일이 변경됩니다. 결과적으로 바이트코드에 추가되는 메타데이터 파일의 해시도 변경됩니다. 즉, 계약의 바이트코드 + 추가된 메타데이터 해시가 주어진 소스 코드 및 컴파일 설정과 일치하면, 이것이 원본 컴파일에 사용된 소스 코드와 정확히 동일하며 단 한 바이트도 다르지 않다는 것을 확신할 수 있습니다.

메타데이터 해시를 활용하는 이러한 유형의 검증은 **"[전체 검증](https://docs.sourcify.dev/docs/full-vs-partial-match/)"**(또는 "완벽한 검증")이라고 합니다. 메타데이터 해시가 일치하지 않거나 검증에서 고려되지 않으면 "부분 일치"가 되며, 이는 현재 계약을 검증하는 더 일반적인 방법입니다. 전체 검증 없이는 검증된 소스 코드에 반영되지 않는 [악성 코드](https://samczsun.com/hiding-in-plain-sight/)를 삽입하는 것이 가능합니다. 대부분의 개발자는 전체 검증을 인지하지 못하고 컴파일의 메타데이터 파일을 보관하지 않으므로, 지금까지 부분 검증이 계약을 검증하는 사실상의 방법이었습니다.

## 소스 코드 검증이 왜 중요한가요? {#importance-of-source-code-verification}

### 무신뢰성 {#trustlessness}

무신뢰성은 스마트 계약과 [탈중앙화 애플리케이션(탈중앙화앱)](/developers/docs/dapps/)의 가장 큰 전제라고 할 수 있습니다. 스마트 계약은 “불변”이며 변경할 수 없습니다. 계약은 배포 시점에 코드에 정의된 비즈니스 로직만 실행합니다. 이는 개발자와 기업이 이더리움에 배포한 후 계약 코드를 변조할 수 없음을 의미합니다.

스마트 계약이 무신뢰성을 가지려면 계약 코드를 독립적으로 검증할 수 있어야 합니다. 모든 스마트 계약의 컴파일된 바이트코드는 블록체인에 공개적으로 사용할 수 있지만, 저수준 언어는 개발자와 사용자 모두에게 이해하기 어렵습니다.

프로젝트는 계약의 소스 코드를 게시하여 신뢰 가정을 줄입니다. 하지만 이는 또 다른 문제로 이어집니다. 게시된 소스 코드가 계약 바이트코드와 일치하는지 확인하기 어렵다는 것입니다. 이 시나리오에서는 사용자가 개발자가 블록체인에 배포하기 전에 계약의 비즈니스 로직(즉, 바이트코드를 변경)을 변경하지 않을 것이라고 신뢰해야 하므로 무신뢰성의 가치가 상실됩니다.

소스 코드 검증 도구는 스마트 계약의 소스 코드 파일이 어셈블리 코드와 일치함을 보장합니다. 그 결과 사용자가 제3자를 맹목적으로 신뢰하지 않고 계약에 자금을 예치하기 전에 코드를 검증하는 무신뢰 생태계가 만들어집니다.

### 사용자 안전 {#user-safety}

스마트 계약에는 일반적으로 많은 돈이 걸려 있습니다. 따라서 스마트 계약을 사용하기 전에 더 높은 보안 보장과 로직 검증이 필요합니다. 문제는 비양심적인 개발자가 스마트 계약에 악성 코드를 삽입하여 사용자를 속일 수 있다는 것입니다. 검증 없이는 악성 스마트 계약에 [백도어](https://www.trustnodes.com/2018/11/10/concerns-rise-over-backdoored-smart-contracts), 논란의 여지가 있는 접근 제어 메커니즘, 악용 가능한 취약점 및 감지되지 않은 채 사용자 안전을 위협하는 기타 사항들이 있을 수 있습니다.

스마트 계약의 소스 코드 파일을 게시하면 감사자와 같은 이해관계자들이 잠재적인 공격 벡터에 대해 계약을 평가하기가 더 쉬워집니다. 여러 당사자가 독립적으로 스마트 계약을 검증함으로써 사용자는 보안에 대한 더 강력한 보증을 받게 됩니다.

## 이더리움 스마트 계약의 소스 코드를 검증하는 방법 {#source-code-verification-for-ethereum-smart-contracts}

[이더리움에 스마트 계약 배포](/developers/docs/smart-contracts/deploying/)는 데이터 페이로드(컴파일된 바이트코드)가 포함된 트랜잭션을 특수 주소로 보내야 합니다. 데이터 페이로드는 소스 코드를 컴파일하여 생성되며, 여기에 트랜잭션의 데이터 페이로드에 추가된 계약 인스턴스의 [생성자 인수](https://docs.soliditylang.org/en/v0.8.14/contracts.html#constructor)가 더해집니다. 컴파일은 결정론적입니다. 즉, 동일한 소스 파일과 컴파일 설정(예: 컴파일러 버전, 최적화 프로그램)이 사용되는 경우 항상 동일한 출력(즉, 계약 바이트코드)을 생성합니다.

![스마트 계약 소스 코드 검증을 보여주는 다이어그램](./source-code-verification.png)

스마트 계약을 검증하는 것은 기본적으로 다음 단계를 포함합니다:

1. 컴파일러에 소스 파일과 컴파일 설정을 입력합니다.

2. 컴파일러는 계약의 바이트코드를 출력합니다.

3. 지정된 주소에서 배포된 계약의 바이트코드를 가져옵니다.

4. 배포된 바이트코드를 다시 컴파일된 바이트코드와 비교합니다. 코드가 일치하면 계약은 주어진 소스 코드와 컴파일 설정으로 검증됩니다.

5. 추가로, 바이트코드 끝에 있는 메타데이터 해시가 일치하면 전체 일치가 됩니다.

이는 검증에 대한 단순한 설명이며, [불변 변수](https://docs.sourcify.dev/docs/immutables/)를 갖는 것과 같이 이 방법으로 작동하지 않는 많은 예외가 있다는 점에 유의하세요.

## 소스 코드 검증 도구 {#source-code-verification-tools}

계약을 검증하는 전통적인 프로세스는 복잡할 수 있습니다. 이것이 이더리움에 배포된 스마트 계약의 소스 코드를 검증하기 위한 도구가 있는 이유입니다. 이러한 도구는 소스 코드 검증의 많은 부분을 자동화하고 사용자의 이익을 위해 검증된 계약을 큐레이션합니다.

### Etherscan {#etherscan}

주로 [이더리움 블록체인 탐색기](/developers/docs/data-and-analytics/block-explorers/)로 알려져 있지만, Etherscan은 스마트 계약 개발자와 사용자를 위한 [소스 코드 검증 서비스](https://etherscan.io/verifyContract)도 제공합니다.

Etherscan을 사용하면 원본 데이터 페이로드(소스 코드, 라이브러리 주소, 컴파일러 설정, 계약 주소 등)에서 계약 바이트코드를 다시 컴파일할 수 있습니다. 다시 컴파일된 바이트코드가 온체인 계약의 바이트코드(및 생성자 매개변수)와 연결되면 [계약이 검증됩니다](https://info.etherscan.com/types-of-contract-verification/).

검증이 완료되면 계약의 소스 코드는 "검증됨" 라벨을 받고 다른 사람들이 감사할 수 있도록 Etherscan에 게시됩니다. 또한 검증된 소스 코드가 있는 스마트 계약의 저장소인 [검증된 계약](https://etherscan.io/contractsVerified/) 섹션에도 추가됩니다.

Etherscan은 계약을 검증하는 데 가장 많이 사용되는 도구입니다. 그러나 Etherscan의 계약 검증에는 단점이 있습니다. 온체인 바이트코드와 재컴파일된 바이트코드의 **메타데이터 해시**를 비교하지 못합니다. 따라서 Etherscan에서의 일치는 부분 일치입니다.

[Etherscan에서 계약 검증에 대해 더 알아보기](https://medium.com/etherscan-blog/verifying-contracts-on-etherscan-f995ab772327).

### Blockscout {#blockscout}

[Blockscout](https://blockscout.com/)은 오픈소스 블록체인 탐색기로 스마트 계약 개발자와 사용자를 위한 [계약 검증 서비스](https://eth.blockscout.com/contract-verification)도 제공합니다. 오픈 소스 대안으로서 Blockscout은 검증이 수행되는 방식의 투명성을 제공하고 커뮤니티가 검증 프로세스를 개선하는 데 기여할 수 있도록 합니다.

다른 검증 서비스와 마찬가지로 Blockscout을 사용하면 바이트코드를 다시 컴파일하고 배포된 계약과 비교하여 계약의 소스 코드를 검증할 수 있습니다. 검증이 완료되면 계약은 검증 상태를 받게 되며 소스 코드는 감사 및 상호 작용을 위해 공개적으로 사용할 수 있게 됩니다. 검증된 계약은 쉽게 찾아보고 발견할 수 있도록 Blockscout의 [검증된 계약 저장소](https://eth.blockscout.com/verified-contracts)에도 나열됩니다.

### Sourcify {#sourcify}

[Sourcify](https://sourcify.dev/#/verifier)는 오픈 소스이고 분산된 또 다른 계약 검증 도구입니다. 이것은 블록 탐색기가 아니며 [다양한 EVM 기반 네트워크](https://docs.sourcify.dev/docs/chains)에서 계약만 검증합니다. 이는 다른 도구가 그 위에 구축할 수 있는 공용 인프라 역할을 하며, 메타데이터 파일에 있는 [ABI](/developers/docs/smart-contracts/compiling/#web-applications) 및 [NatSpec](https://docs.soliditylang.org/en/v0.8.15/natspec-format.html) 주석을 사용하여 보다 인간 친화적인 계약 상호 작용을 가능하게 하는 것을 목표로 합니다.

Etherscan과 달리 Sourcify는 메타데이터 해시와의 전체 일치를 지원합니다. 검증된 계약은 HTTP 및 분산된 [콘텐츠 주소 지정](https://docs.storacha.network/concepts/content-addressing/) 스토리지인 [IPFS](https://docs.ipfs.io/concepts/what-is-ipfs/#what-is-ipfs)의 [공개 리포지토리](https://docs.sourcify.dev/docs/repository/)에서 제공됩니다. 추가된 메타데이터 해시가 IPFS 해시이므로 이를 통해 IPFS를 통해 계약의 메타데이터 파일을 가져올 수 있습니다.

또한 이 파일들의 IPFS 해시도 메타데이터에서 찾을 수 있으므로 IPFS를 통해 소스 코드 파일을 검색할 수도 있습니다. API 또는 [UI](https://sourcify.dev/#/verifier)를 통해 메타데이터 파일과 소스 파일을 제공하거나 플러그인을 사용하여 계약을 확인할 수 있습니다. Sourcify 모니터링 도구는 또한 새 블록에서 계약 생성을 수신하고 메타데이터 및 소스 파일이 IPFS에 게시된 경우 계약을 확인하려고 시도합니다.

[Sourcify에서 계약 검증에 대해 더 알아보기](https://soliditylang.org/blog/2020/06/25/sourcify-faq/).

### Tenderly {#tenderly}

[Tenderly 플랫폼](https://tenderly.co/)은 웹3 개발자가 스마트 계약을 구축, 테스트, 모니터링 및 운영할 수 있도록 합니다. 디버깅 도구와 관찰 가능성 및 인프라 구성 요소를 결합하여 Tenderly는 개발자가 스마트 계약 개발을 가속화하도록 돕습니다. Tenderly 기능을 완전히 활성화하려면 개발자는 여러 방법을 사용하여 [소스 코드 검증을 수행](https://docs.tenderly.co/monitoring/contract-verification)해야 합니다.

계약을 비공개 또는 공개적으로 확인할 수 있습니다. 비공개로 확인된 경우 스마트 계약은 귀하(및 프로젝트의 다른 구성원)에게만 표시됩니다. 계약을 공개적으로 확인하면 Tenderly 플랫폼을 사용하는 모든 사람이 볼 수 있습니다.

[대시보드](https://docs.tenderly.co/contract-verification), [Tenderly Hardhat 플러그인](https://docs.tenderly.co/contract-verification/hardhat) 또는 [CLI](https://docs.tenderly.co/monitoring/smart-contract-verification/verifying-contracts-using-cli)를 사용하여 계약을 확인할 수 있습니다.

대시보드를 통해 계약을 확인할 때 Solidity 컴파일러에서 생성된 소스 파일 또는 메타데이터 파일, 주소/네트워크 및 컴파일러 설정을 가져와야 합니다.

Tenderly Hardhat 플러그인을 사용하면 더 적은 노력으로 검증 프로세스를 더 많이 제어할 수 있으므로 자동(코드 없음) 및 수동(코드 기반) 검증 중에서 선택할 수 있습니다.

## 더 읽어보기 {#further-reading}

- [계약 소스 코드 검증](https://programtheblockchain.com/posts/2018/01/16/verifying-contract-source-code/)
