---
title: 스마트 계약 업그레이드
description: 이더리움 스마트 계약의 업그레이드 패턴 개요
lang: ko
---

이더리움의 스마트 계약은 이더리움 가상 머신(EVM)에서 실행되는 자동 실행 프로그램입니다. 이 프로그램은 설계상 불변성을 가지므로 계약이 배포된 후에는 비즈니스 로직을 업데이트할 수 없습니다.

불변성은 스마트 계약의 무신뢰성, 탈중앙화 및 보안에 필수적이지만, 경우에 따라 단점이 될 수 있습니다. 예를 들어, 불변 코드로 인해 개발자가 취약한 계약을 수정하는 것이 불가능할 수 있습니다.

그러나 스마트 계약 개선에 대한 연구가 증가하면서 여러 업그레이드 패턴이 도입되었습니다. 이러한 업그레이드 패턴을 통해 개발자는 비즈니스 로직을 다른 계약에 배치하여 (불변성을 유지하면서) 스마트 계약을 업그레이드할 수 있습니다.

## 필수 구성 요소 {#prerequisites}

[스마트 계약](/developers/docs/smart-contracts/), [스마트 계약 구조](/developers/docs/smart-contracts/anatomy/), [이더리움 가상 머신(EVM)](/developers/docs/evm/)에 대해 잘 이해하고 있어야 합니다. 또한 이 가이드는 독자가 스마트 계약 프로그래밍에 대한 이해가 있다고 가정합니다.

## 스마트 계약 업그레이드란 무엇인가요? {#what-is-a-smart-contract-upgrade}

스마트 계약 업그레이드는 계약의 상태를 보존하면서 스마트 계약의 비즈니스 로직을 변경하는 것을 포함합니다. 특히 스마트 계약의 맥락에서 업그레이드 가능성과 가변성은 동일하지 않다는 점을 명확히 하는 것이 중요합니다.

이더리움 네트워크의 주소에 배포된 프로그램은 여전히 변경할 수 없습니다. 하지만 사용자가 스마트 계약과 상호 작용할 때 실행되는 코드는 변경할 수 있습니다.

다음과 같은 방법을 통해 수행할 수 있습니다.

1. 스마트 계약의 여러 버전을 만들고 이전 계약에서 계약의 새 인스턴스로 상태(즉, 데이터)를 마이그레이션합니다.

2. 비즈니스 로직과 상태를 저장하기 위해 별도의 계약을 생성합니다.

3. 프록시 패턴을 사용하여 불변 프록시 계약에서 수정 가능한 로직 계약으로 함수 호출을 위임합니다.

4. 특정 함수를 실행하기 위해 유연한 위성 계약과 인터페이스하고 의존하는 불변 메인 계약을 생성합니다.

5. 다이아몬드 패턴을 사용하여 프록시 계약에서 로직 계약으로 함수 호출을 위임합니다.

### 업그레이드 메커니즘 #1: 계약 마이그레이션 {#contract-migration}

계약 마이그레이션은 버전 관리를 기반으로 합니다. 이는 동일한 소프트웨어의 고유한 상태를 생성하고 관리하는 개념입니다. 계약 마이그레이션은 기존 스마트 계약의 새 인스턴스를 배포하고 저장 공간과 잔액을 새 계약으로 이전하는 것을 포함합니다.

새로 배포된 계약은 빈 저장 공간을 가지므로 이전 계약에서 데이터를 복구하고 새 구현에 쓸 수 있습니다. 그 후에는 이전 계약과 상호 작용했던 모든 계약을 업데이트하여 새 주소를 반영해야 합니다.

계약 마이그레이션의 마지막 단계는 사용자가 새 계약을 사용하도록 설득하는 것입니다. 새로운 계약 버전은 사용자 잔액과 주소를 유지하여 불변성을 보존합니다. 토큰 기반 계약인 경우 거래소에 연락하여 이전 계약을 폐기하고 새 계약을 사용하도록 해야 합니다.

계약 마이그레이션은 사용자 상호 작용을 방해하지 않고 스마트 계약을 업그레이드하는 비교적 간단하고 안전한 방법입니다. 그러나 사용자 저장 공간과 잔액을 새 계약으로 수동으로 마이그레이션하는 것은 시간이 많이 걸리고 높은 가스 비용이 발생할 수 있습니다.

[계약 마이그레이션에 대해 더 알아보기.](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/)

### 업그레이드 메커니즘 #2: 데이터 분리 {#data-separation}

스마트 계약을 업그레이드하는 또 다른 방법은 비즈니스 로직과 데이터 저장 공간을 별도의 계약으로 분리하는 것입니다. 즉, 사용자는 로직 계약과 상호 작용하고 데이터는 저장 공간 계약에 저장됩니다.

로직 계약에는 사용자가 애플리케이션과 상호 작용할 때 실행되는 코드가 포함됩니다. 또한 저장 공간 계약의 주소를 보유하고 이와 상호 작용하여 데이터를 가져오고 설정합니다.

한편, 저장 공간 계약은 사용자 잔액 및 주소와 같은 스마트 계약과 관련된 상태를 보유합니다. 저장 공간 계약은 로직 계약이 소유하며 배포 시 로직 계약의 주소로 구성됩니다. 이를 통해 승인되지 않은 계약이 저장 공간 계약을 호출하거나 데이터를 업데이트하는 것을 방지할 수 있습니다.

기본적으로 저장 공간 계약은 불변이지만, 가리키는 로직 계약을 새로운 구현으로 교체할 수 있습니다. 이렇게 하면 EVM에서 실행되는 코드가 변경되지만 저장 공간과 잔액은 그대로 유지됩니다.

이 업그레이드 방법을 사용하려면 저장 공간 계약에서 로직 계약의 주소를 업데이트해야 합니다. 앞서 설명한 이유로 새 로직 계약을 저장 공간 계약의 주소로 구성해야 합니다.

데이터 분리 패턴은 계약 마이그레이션에 비해 구현하기가 더 쉽다고 할 수 있습니다. 하지만 여러 계약을 관리하고 악의적인 업그레이드로부터 스마트 계약을 보호하기 위해 복잡한 권한 부여 체계를 구현해야 합니다.

### 업그레이드 메커니즘 #3: 프록시 패턴 {#proxy-patterns}

프록시 패턴은 또한 데이터 분리를 사용하여 비즈니스 로직과 데이터를 별도의 계약에 보관합니다. 그러나 프록시 패턴에서는 저장 공간 계약(프록시라고 함)이 코드 실행 중에 로직 계약을 호출합니다. 이것은 로직 계약이 저장 공간 계약을 호출하는 데이터 분리 방법의 반대입니다.

프록시 패턴에서 일어나는 일은 다음과 같습니다.

1. 사용자는 데이터를 저장하지만 비즈니스 로직은 보유하지 않는 프록시 계약과 상호 작용합니다.

2. 프록시 계약은 로직 계약의 주소를 저장하고 `delegatecall` 함수를 사용하여 모든 함수 호출을 로직 계약(비즈니스 로직을 보유함)에 위임합니다.

3. 호출이 로직 계약으로 전달된 후, 로직 계약에서 반환된 데이터는 검색되어 사용자에게 반환됩니다.

프록시 패턴을 사용하려면 **delegatecall** 함수에 대한 이해가 필요합니다. 기본적으로 `delegatecall`은 계약이 다른 계약을 호출할 수 있도록 하는 옵코드이며, 실제 코드 실행은 호출하는 계약의 컨텍스트에서 발생합니다. 프록시 패턴에서 `delegatecall`을 사용하는 것의 한 가지 의미는 프록시 계약이 내부 함수를 호출하는 것처럼 저장 공간을 읽고 쓰며 로직 계약에 저장된 로직을 실행한다는 것입니다.

[Solidity 개발문서](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)에서:

> _**delegatecall**이라는 특별한 메시지 호출 변형이 존재합니다. 이는 대상 주소의 코드가 호출 계약의 컨텍스트(즉, 주소)에서 실행되고 `msg.sender`와 `msg.value`의 값이 변경되지 않는다는 점을 제외하면 메시지 호출과 동일합니다._ _이는 계약이 런타임에 다른 주소에서 코드를 동적으로 로드할 수 있음을 의미합니다. 저장 공간, 현재 주소 및 잔액은 여전히 호출 계약을 참조하며, 코드는 호출된 주소에서만 가져옵니다._

프록시 계약은 내장된 `fallback` 함수가 있기 때문에 사용자가 함수를 호출할 때마다 `delegatecall`을 호출해야 한다는 것을 알고 있습니다. Solidity 프로그래밍에서 [폴백 함수](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function)는 함수 호출이 계약에 지정된 함수와 일치하지 않을 때 실행됩니다.

프록시 패턴이 작동하려면 프록시 계약이 지원하지 않는 함수 호출을 처리하는 방법을 지정하는 사용자 지정 폴백 함수를 작성해야 합니다. 이 경우 프록시의 폴백 함수는 delegatecall을 시작하고 사용자의 요청을 현재 로직 계약 구현으로 다시 라우팅하도록 프로그래밍됩니다.

프록시 계약은 기본적으로 불변이지만, 업데이트된 비즈니스 로직을 가진 새로운 로직 계약을 만들 수 있습니다. 그런 다음 업그레이드를 수행하는 것은 프록시 계약에서 참조되는 로직 계약의 주소를 변경하는 문제입니다.

프록시 계약이 새로운 로직 계약을 가리키도록 함으로써 사용자가 프록시 계약 함수를 호출할 때 실행되는 코드가 변경됩니다. 이를 통해 사용자에게 새로운 계약과 상호 작용하도록 요청하지 않고도 계약의 로직을 업그레이드할 수 있습니다.

프록시 패턴은 계약 마이그레이션과 관련된 어려움을 없애주기 때문에 스마트 계약을 업그레이드하는 데 널리 사용되는 방법입니다. 그러나 프록시 패턴은 사용하기가 더 복잡하며 부적절하게 사용될 경우 [함수 선택자 충돌](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357)과 같은 치명적인 결함을 유발할 수 있습니다.

[프록시 패턴에 대해 더 알아보기.](https://blog.openzeppelin.com/proxy-patterns/)

### 업그레이드 메커니즘 #4: 전략 패턴 {#strategy-pattern}

이 기술은 특정 기능을 구현하기 위해 다른 프로그램과 인터페이스하는 소프트웨어 프로그램을 만들도록 장려하는 [전략 패턴](https://en.wikipedia.org/wiki/Strategy_pattern)의 영향을 받았습니다. 전략 패턴을 이더리움 개발에 적용하는 것은 다른 계약의 함수를 호출하는 스마트 계약을 구축하는 것을 의미합니다.

이 경우 메인 계약에는 핵심 비즈니스 로직이 포함되어 있지만, 특정 함수를 실행하기 위해 다른 스마트 계약("위성 계약")과 인터페이스합니다. 이 메인 계약은 각 위성 계약의 주소를 저장하고 위성 계약의 다른 구현 간에 전환할 수 있습니다.

새로운 위성 계약을 구축하고 메인 계약을 새 주소로 구성할 수 있습니다. 이를 통해 스마트 계약의 _전략_을 변경(즉, 새로운 로직 구현)할 수 있습니다.

앞서 논의한 프록시 패턴과 유사하지만, 전략 패턴은 사용자가 상호 작용하는 메인 계약이 비즈니스 로직을 보유하기 때문에 다릅니다. 이 패턴을 사용하면 핵심 인프라에 영향을 주지 않고 스마트 계약에 제한적인 변경을 도입할 수 있습니다.

주요 단점은 이 패턴이 주로 사소한 업그레이드를 배포하는 데 유용하다는 것입니다. 또한, 메인 계약이 손상된 경우(예: 해킹) 이 업그레이드 방법을 사용할 수 없습니다.

### 업그레이드 메커니즘 #5: 다이아몬드 패턴 {#diamond-pattern}

다이아몬드 패턴은 프록시 패턴의 개선된 버전으로 간주될 수 있습니다. 다이아몬드 패턴은 다이아몬드 프록시 계약이 하나 이상의 로직 계약에 함수 호출을 위임할 수 있다는 점에서 프록시 패턴과 다릅니다.

다이아몬드 패턴의 로직 계약은 _패싯_으로 알려져 있습니다. 다이아몬드 패턴이 작동하려면 프록시 계약에 [함수 선택자](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector)를 다른 패싯 주소에 매핑하는 매핑을 만들어야 합니다.

사용자가 함수를 호출하면 프록시 계약은 매핑을 확인하여 해당 함수 실행을 담당하는 패싯을 찾습니다. 그런 다음 `delegatecall`(폴백 함수 사용)을 호출하고 해당 로직 계약으로 호출을 리디렉션합니다.

다이아몬드 업그레이드 패턴은 기존 프록시 업그레이드 패턴에 비해 몇 가지 장점이 있습니다.

1. 모든 코드를 변경하지 않고도 계약의 작은 부분을 업그레이드할 수 있습니다. 업그레이드를 위해 프록시 패턴을 사용하려면 사소한 업그레이드라도 완전히 새로운 로직 계약을 만들어야 합니다.

2. 모든 스마트 계약(프록시 패턴에서 사용되는 로직 계약 포함)은 24KB 크기 제한이 있으며, 이는 특히 더 많은 기능이 필요한 복잡한 계약의 경우 제한이 될 수 있습니다. 다이아몬드 패턴은 여러 로직 계약에 함수를 분할하여 이 문제를 쉽게 해결할 수 있습니다.

3. 프록시 패턴은 액세스 제어에 대해 포괄적인 접근 방식을 채택합니다. 업그레이드 함수에 접근할 수 있는 엔티티는 _전체_ 계약을 변경할 수 있습니다. 하지만 다이아몬드 패턴은 모듈식 권한 접근 방식을 가능하게 하여, 스마트 계약 내에서 특정 함수를 업그레이드하는 것을 엔티티에 제한할 수 있습니다.

[다이아몬드 패턴에 대해 더 알아보기](https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard?s=w).

## 스마트 계약 업그레이드의 장단점 {#pros-and-cons-of-upgrading-smart-contracts}

| 장점                                                                                      | 단점                                                                                            |
| --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| 스마트 계약 업그레이드를 통해 배포 후 단계에서 발견된 취약점을 더 쉽게 수정할 수 있습니다.                    | 스마트 계약을 업그레이드하는 것은 코드 불변성이라는 개념에 위배되며, 이는 탈중앙화와 보안에 영향을 미칩니다.                 |
| 개발자는 로직 업그레이드를 사용하여 탈중앙화 애플리케이션에 새로운 기능을 추가할 수 있습니다.                    | 사용자는 개발자가 스마트 계약을 임의로 수정하지 않을 것이라고 신뢰해야 합니다.                                  |
| 스마트 계약 업그레이드는 버그를 신속하게 수정할 수 있으므로 최종 사용자의 안전을 향상시킬 수 있습니다.              | 스마트 계약에 업그레이드 기능을 프로그래밍하는 것은 또 다른 복잡성을 더하고 치명적인 결함의 가능성을 높입니다.                |
| 계약 업그레이드는 개발자에게 다양한 기능을 실험하고 시간이 지남에 따라 탈중앙화앱을 개선할 수 있는 더 많은 여지를 제공합니다. | 스마트 계약을 업그레이드할 수 있는 기회는 개발자가 개발 단계에서 실사를 수행하지 않고 프로젝트를 더 빨리 출시하도록 장려할 수 있습니다. |
|                                                                                         | 스마트 계약의 안전하지 않은 접근 제어 또는 중앙 집중화는 악의적인 행위자가 무단 업그레이드를 수행하기 쉽게 만들 수 있습니다.       |

## 스마트 계약 업그레이드 시 고려 사항 {#considerations-for-upgrading-smart-contracts}

1. 특히 프록시 패턴, 전략 패턴 또는 데이터 분리를 사용하는 경우 무단 스마트 계약 업그레이드를 방지하기 위해 안전한 접근 제어/권한 부여 메커니즘을 사용하세요. 예를 들어, 계약의 소유자만 호출할 수 있도록 업그레이드 기능에 대한 접근을 제한하는 것입니다.

2. 스마트 계약 업그레이드는 복잡한 활동이며 취약점 도입을 방지하기 위해 높은 수준의 주의가 필요합니다.

3. 업그레이드 구현 프로세스를 탈중앙화하여 신뢰 가정을 줄이세요. [다중 서명 지갑 계약](/developers/docs/smart-contracts/#multisig)을 사용하여 업그레이드를 제어하거나 [DAO 구성원](/dao/)이 업그레이드 승인에 투표하도록 요구하는 전략이 포함될 수 있습니다.

4. 계약 업그레이드에 수반되는 비용을 인지하세요. 예를 들어, 계약 마이그레이션 중에 이전 계약에서 새 계약으로 상태(예: 사용자 잔액)를 복사하는 데 두 개 이상의 트랜잭션이 필요할 수 있으며, 이는 더 많은 가스 수수료를 의미합니다.

5. 사용자를 보호하기 위해 **타임락** 구현을 고려하세요. 타임락은 시스템 변경에 적용되는 지연을 의미합니다. 타임락은 다중 서명 거버넌스 시스템과 결합하여 업그레이드를 제어할 수 있습니다. 제안된 조치가 필요한 승인 임계값에 도달하면 사전 정의된 지연 기간이 경과할 때까지 실행되지 않습니다.

타임락은 사용자가 제안된 변경(예: 로직 업그레이드 또는 새로운 수수료 체계)에 동의하지 않을 경우 시스템을 종료할 시간을 줍니다. 타임락이 없으면 사용자는 개발자가 사전 통지 없이 스마트 계약에 임의의 변경을 구현하지 않을 것이라고 신뢰해야 합니다. 여기서 단점은 타임락이 취약점을 신속하게 패치하는 능력을 제한한다는 것입니다.

## 참고 자료 {#resources}

**OpenZeppelin 업그레이드 플러그인 - _업그레이드 가능한 스마트 계약을 배포하고 보안을 유지하기 위한 도구 모음._**

- [GitHub](https://github.com/OpenZeppelin/openzeppelin-upgrades)
- [개발문서](https://docs.openzeppelin.com/upgrades)

## 튜토리얼 {#tutorials}

- [스마트 계약 업그레이드하기 | 유튜브 튜토리얼](https://www.youtube.com/watch?v=bdXJmWajZRY) - Patrick Collins
- [이더리움 스마트 계약 마이그레이션 튜토리얼](https://medium.com/coinmonks/ethereum-smart-contract-migration-13f6f12539bd) - Austin Griffith
- [UUPS 프록시 패턴을 사용한 스마트 계약 업그레이드](https://blog.logrocket.com/author/praneshas/) - Pranesh A.S
- [Web3 튜토리얼: OpenZeppelin을 사용하여 업그레이드 가능한 스마트 계약(프록시) 작성하기](https://dev.to/yakult/tutorial-write-upgradeable-smart-contract-proxy-contract-with-openzeppelin-1916) - fangjun.eth

## 더 읽어보기 {#further-reading}

- [스마트 계약 업그레이드의 현황](https://blog.openzeppelin.com/the-state-of-smart-contract-upgrades/) - Santiago Palladino
- [Solidity 스마트 계약을 업그레이드하는 여러 방법](https://cryptomarketpool.com/multiple-ways-to-upgrade-a-solidity-smart-contract/) - Crypto Market Pool 블로그
- [학습: 스마트 계약 업그레이드](https://docs.openzeppelin.com/learn/upgrading-smart-contracts) - OpenZeppelin 개발문서
- [Solidity 계약의 업그레이드 가능성을 위한 프록시 패턴: 투명 프록시 vs UUPS 프록시](https://mirror.xyz/0xB38709B8198d147cc9Ff9C133838a044d78B064B/M7oTptQkBGXxox-tk9VJjL66E1V8BUF0GF79MMK4YG0) - Naveen Sahu
- [다이아몬드 업그레이드 작동 방식](https://dev.to/mudgen/how-diamond-upgrades-work-417j) - Nick Mudge
