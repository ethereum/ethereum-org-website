---
title: Доказательства Меркла для целостности офлайн-данных
description: Обеспечение целостности ончейн-данных для данных, которые хранятся преимущественно оффчейн
author: Ори Померанц
tags: [ "хранилище" ]
skill: advanced
lang: ru
published: 2021-12-30
---

## Введение {#introduction}

В идеале мы хотели бы хранить все в месте хранения Ethereum, которое распределено по тысячам компьютеров и обладает
чрезвычайно высокой доступностью (данные не могут быть подвергнуты цензуре) и целостностью (данные не могут быть изменены
несанкционированным образом), но хранение 32-байтового слова обычно стоит 20 000 единиц газа. На момент написания этой статьи эта стоимость
эквивалентна 6,60 долларам США. При цене 21 цент за байт это слишком дорого для многих вариантов использования.

Для решения этой проблемы экосистема Ethereum разработала множество альтернативных способов хранения данных децентрализованным
образом. Обычно они предполагают компромисс между доступностью
и ценой. Однако целостность обычно гарантируется.

В этой статье вы узнаете, **как** обеспечить целостность данных, не храня их в блокчейне, с помощью
[доказательств Меркла](https://computersciencewiki.org/index.php/Merkle_proof).

## Как это работает? {#how-does-it-work}

Теоретически мы могли бы просто хранить хэш данных в сети (он-чейн) и отправлять все данные в требующих их транзакциях. Однако это все еще слишком дорого. Байт данных в транзакции стоит около 16 единиц газа, что в настоящее время составляет около половины цента или около 5 долларов за килобайт. При цене 5000 долларов за мегабайт это все еще слишком дорого для многих вариантов использования, даже без учета дополнительных затрат на хэширование данных.

Решение заключается в многократном хэшировании различных подмножеств данных, поэтому для данных, которые вам не нужно отправлять, вы можете просто отправить хэш. Это делается с помощью дерева Меркла, древовидной структуры данных, в которой каждый узел представляет собой хэш узлов, расположенных под ним:

![Дерево Меркла](tree.png)

Корневой хэш — единственная часть, которую необходимо хранить в сети (он-чейн). Чтобы доказать определенное значение, вы предоставляете все хэши, которые необходимо объединить с ним для получения корневого хэша. Например, чтобы доказать `C`, вы предоставляете `D`, `H(A-B)` и `H(E-H)`.

![Доказательство значения C](proof-c.png)

## Реализация {#implementation}

[Пример кода приведен здесь](https://github.com/qbzzt/merkle-proofs-for-offline-data-integrity).

### Код вне сети (офф-чейн) {#offchain-code}

В этой статье мы используем JavaScript для вычислений вне сети (офф-чейн). Большинство децентрализованных приложений имеют свой компонент вне сети (офф-чейн), написанный на JavaScript.

#### Создание корня Меркла {#creating-the-merkle-root}

Сначала нам нужно предоставить корень Меркла в сеть.

```javascript
const ethers = require("ethers")
```

[Мы используем хэш-функцию из пакета ethers](https://docs.ethers.io/v5/api/utils/hashing/#utils-keccak256).

```javascript
// Необработанные данные, целостность которых мы должны проверить. Первые два байта
// — это идентификатор пользователя, а последние два байта — количество токенов, которыми
// пользователь владеет в настоящее время.
const dataArray = [
  0x0bad0010, 0x60a70020, 0xbeef0030, 0xdead0040, 0xca110050, 0x0e660060,
  0xface0070, 0xbad00080, 0x060d0091,
]
```

Кодирование каждой записи в одно 256-битное целое число приводит к менее читаемому коду, чем, например, при использовании JSON. Однако это означает значительно меньшую обработку для извлечения данных в контракте и, следовательно, гораздо более низкие затраты на газ. [Вы можете считывать JSON в сети (он-чейн)](https://github.com/chrisdotn/jsmnSol), но это плохая идея, если этого можно избежать.

```javascript
// Массив хэш-значений в виде BigInts
const hashArray = dataArray
```

В данном случае наши данные изначально представляют собой 256-битные значения, поэтому обработка не требуется. Если мы используем более сложную структуру данных, например строки, нам нужно сначала хэшировать данные, чтобы получить массив хэшей. Обратите внимание, что это также связано с тем, что нам неважно, знают ли пользователи информацию о других пользователях. В противном случае нам пришлось бы выполнить хэширование, чтобы пользователь 1 не знал значение для пользователя 0, пользователь 2 не знал значение для пользователя 3 и т. д.

```javascript
// Преобразование между строкой, которую ожидает хэш-функция, и
// BigInt, который мы используем во всем остальном коде.
const hash = (x) =>
  BigInt(ethers.utils.keccak256("0x" + x.toString(16).padStart(64, 0)))
```

Хэш-функция ethers ожидает получить строку JavaScript с шестнадцатеричным числом, например `0x60A7`, и возвращает другую строку с той же структурой. Однако для остальной части кода проще использовать `BigInt`, поэтому мы преобразуем его в шестнадцатеричную строку и обратно.

```javascript
// Симметричный хэш пары, поэтому нам неважно, обратный ли порядок.
const pairHash = (a, b) => hash(hash(a) ^ hash(b))
```

Эта функция симметрична (хэш от a [xor](https://en.wikipedia.org/wiki/Exclusive_or) b). Это означает, что при проверке доказательства Меркла нам не нужно беспокоиться о том, ставить ли значение из доказательства до или после вычисленного значения. Проверка доказательства Меркла выполняется в сети (он-чейн), поэтому чем меньше нам нужно там делать, тем лучше.

Предупреждение:
Криптография сложнее, чем кажется.
В первоначальной версии этой статьи была хэш-функция `hash(a^b)`.
Это была **плохая** идея, поскольку она означала, что если вы знаете допустимые значения `a` и `b`, вы можете использовать `b' = a^b^a'`, чтобы доказать любое желаемое значение `a'`.
С этой функцией вам пришлось бы вычислять `b'` так, чтобы `hash(a') ^ hash(b')` равнялось известному значению (следующей ветви на пути к корню), что намного сложнее.

```javascript
// Значение, обозначающее, что определенная ветвь пуста, то есть
// не имеет значения
const empty = 0n
```

Когда количество значений не является целой степенью двойки, нам нужно обрабатывать пустые ветви. Эта программа делает это, используя ноль в качестве заполнителя.

![Дерево Меркла с отсутствующими ветвями](merkle-empty-hash.png)

```javascript
// Вычислить один уровень вверх по дереву массива хэшей, взяв хэш
// каждой пары в последовательности
const oneLevelUp = (inputArray) => {
  var result = []
  var inp = [...inputArray] // Чтобы избежать перезаписи входных данных // При необходимости добавьте пустое значение (нам нужно, чтобы все листья были // объединены в пары)

  if (inp.length % 2 === 1) inp.push(empty)

  for (var i = 0; i < inp.length; i += 2)
    result.push(pairHash(inp[i], inp[i + 1]))

  return result
} // oneLevelUp
```

Эта функция «поднимается» на один уровень в дереве Меркла путем хэширования пар значений на текущем слое. Обратите внимание, что это не самая эффективная реализация. Мы могли бы избежать копирования входных данных и просто добавлять `hashEmpty` в цикле, где это необходимо, но этот код оптимизирован для удобочитаемости.

```javascript
const getMerkleRoot = (inputArray) => {
  var result

  result = [...inputArray] // Поднимаемся по дереву до тех пор, пока не останется только одно значение, которое и является // корнем. // // Если слой содержит нечетное количество записей, // код в oneLevelUp добавляет пустое значение, поэтому, если у нас, например, // 10 листьев, то на втором слое будет 5 ветвей, 3 // ветви на третьем, 2 на четвертом и корень на пятом

  while (result.length > 1) result = oneLevelUp(result)

  return result[0]
}
```

Чтобы получить корень, поднимайтесь вверх, пока не останется только одно значение.

#### Создание доказательства Меркла {#creating-a-merkle-proof}

Доказательство Меркла — это значения, которые необходимо хэшировать вместе с доказываемым значением, чтобы получить корень Меркла. Доказываемое значение часто доступно из других данных, поэтому я предпочитаю предоставлять его отдельно, а не как часть кода.

```javascript
// Доказательство Меркла состоит из списка значений, которые нужно
// хэшировать. Поскольку мы используем симметричную хэш-функцию, для проверки
// доказательства нам не требуется позиция элемента, она нужна только для его создания.
const getMerkleProof = (inputArray, n) => {
    var result = [], currentLayer = [...inputArray], currentN = n

    // Пока не достигнем вершины
    while (currentLayer.length > 1) {
        // Не допускаются слои нечетной длины
        if (currentLayer.length % 2)
            currentLayer.push(empty)

        result.push(currentN % 2
               // Если currentN нечетное, добавить в доказательство значение перед ним
            ? currentLayer[currentN-1]
               // Если четное, добавить значение после него
            : currentLayer[currentN+1])

```

Мы хэшируем `(v[0],v[1])`, `(v[2],v[3])` и т. д. Так, для четных значений нам нужно следующее, а для нечетных — предыдущее.

```javascript
        // Переход на следующий слой вверх
        currentN = Math.floor(currentN/2)
        currentLayer = oneLevelUp(currentLayer)
    }   // пока currentLayer.length > 1

    return result
}   // getMerkleProof
```

### Код в сети (он-чейн) {#onchain-code}

Наконец, у нас есть код, который проверяет доказательство. Код в сети (он-чейн) написан на [Solidity](https://docs.soliditylang.org/en/v0.8.11/). Здесь оптимизация гораздо важнее, потому что газ относительно дорог.

```solidity
//SPDX-License-Identifier: Public Domain
pragma solidity ^0.8.0;

import "hardhat/console.sol";
```

Я написал это с помощью [среды разработки Hardhat](https://hardhat.org/), которая позволяет нам получать [вывод консоли из Solidity](https://hardhat.org/docs/cookbook/debug-logs) во время разработки.

```solidity

contract MerkleProof {
    uint merkleRoot;

    function getRoot() public view returns (uint) {
      return merkleRoot;
    }

    // Крайне небезопасно, в рабочем коде доступ к
    // этой функции ДОЛЖЕН БЫТЬ строго ограничен, вероятно, только для
    // владельца
    function setRoot(uint _merkleRoot) external {
      merkleRoot = _merkleRoot;
    }   // setRoot
```

Функции установки и получения для корня Меркла. Разрешение всем обновлять корень Меркла — _крайне плохая идея_ в производственной системе. Я делаю это здесь для простоты примера кода. **Не делайте этого в системе, где целостность данных действительно важна**.

```solidity
    function hash(uint _a) internal pure returns(uint) {
      return uint(keccak256(abi.encode(_a)));
    }

    function pairHash(uint _a, uint _b) internal pure returns(uint) {
      return hash(hash(_a) ^ hash(_b));
    }
```

Эта функция генерирует хэш пары. Это просто перевод кода JavaScript для `hash` и `pairHash` на Solidity.

**Примечание:** это еще один случай оптимизации для удобочитаемости. Основываясь на [определении функции](https://www.tutorialspoint.com/solidity/solidity_cryptographic_functions.htm), возможно, можно хранить данные как значение [`bytes32`](https://docs.soliditylang.org/en/v0.5.3/types.html#fixed-size-byte-arrays) и избежать преобразований.

```solidity
    // Проверка доказательства Меркла
    function verifyProof(uint _value, uint[] calldata _proof)
        public view returns (bool) {
      uint temp = _value;
      uint i;

      for(i=0; i<_proof.length; i++) {
        temp = pairHash(temp, _proof[i]);
      }

      return temp == merkleRoot;
    }

}  // MarkleProof
```

В математической нотации проверка доказательства Меркла выглядит так: `H(proof_n, H(proof_n-1, H(proof_n-2, ...` H(proof_1, H(proof_0, value))...)))\`. Этот код реализует это.

## Доказательства Меркла и ролл-апы несовместимы {#merkle-proofs-and-rollups}

Доказательства Меркла плохо работают с [ролл-апами](/developers/docs/scaling/#rollups). Причина в том, что ролл-апы записывают все данные транзакций на уровне L1, но обрабатывают их на L2. Стоимость отправки доказательства Меркла с транзакцией составляет в среднем 638 единиц газа на слой (в настоящее время байт в данных вызова стоит 16 единиц газа, если он не равен нулю, и 4, если он равен нулю). Если у нас есть 1024 слова данных, доказательство Меркла потребует десять слоев, или в общей сложности 6380 единиц газа.

На примере [Optimism](https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m) можно увидеть, что запись газа на L1 стоит около 100 gwei, а газ на L2 — 0,001 gwei (это обычная цена, которая может расти при перегрузках). Таким образом, за стоимость одной единицы газа L1 мы можем потратить сто тысяч единиц газа на обработку L2. Если предположить, что мы не перезаписываем хранилище, это означает, что мы можем записать около пяти слов в хранилище на L2 по цене одной единицы газа L1. Для одного доказательства Меркла мы можем записать все 1024 слова в хранилище (при условии, что они могут быть вычислены в сети (он-чейн) с самого начала, а не предоставлены в транзакции), и при этом у нас останется большая часть газа.

## Заключение {#conclusion}

В реальной жизни вам, возможно, никогда не придется реализовывать деревья Меркла самостоятельно. Существуют хорошо известные и проверенные библиотеки, которые можно использовать, и, вообще говоря, лучше не реализовывать криптографические примитивы самостоятельно. Но я надеюсь, что теперь вы лучше понимаете доказательства Меркла и можете решить, когда их стоит использовать.

Обратите внимание, что, хотя доказательства Меркла сохраняют _целостность_, они не сохраняют _доступность_. Знание того, что никто другой не может забрать ваши активы, — слабое утешение, если хранилище данных решит запретить доступ и вы также не сможете построить дерево Меркла для доступа к ним. Поэтому деревья Меркла лучше всего использовать с каким-либо децентрализованным хранилищем, например IPFS.

[Больше моих работ смотрите здесь](https://cryptodocguy.pro/).
