---
title: "Использование скрытых адресов"
description: "Скрытые адреса позволяют пользователям анонимно переводить активы. Прочитав эту статью, вы сможете: объяснить, что такое скрытые адреса и как они работают, понять, как использовать скрытые адреса для сохранения анонимности, а также написать веб-приложение, использующее скрытые адреса."
author: Ори Померанц
tags:
  [
    "Скрытый адрес",
    "конфиденциальность",
    "криптография",
    "rust",
    "wasm"
  ]
skill: intermediate
published: 2025-11-30
lang: ru
sidebarDepth: 3
---

Вы — Билл. По причинам, которые мы не будем рассматривать, вы хотите сделать пожертвование в кампанию "Алиса — королева мира" и хотите, чтобы Алиса знала о вашем пожертвовании, чтобы она вознаградила вас в случае своей победы. К сожалению, ее победа не гарантирована. Существует конкурирующая кампания "Кэрол — императрица Солнечной системы". Если Кэрол победит и узнает, что вы пожертвовали Алисе, у вас будут проблемы. Поэтому вы не можете просто перевести 200 ETH со своего аккаунта на аккаунт Алисы.

Решение предлагает [ERC-5564](https://eips.ethereum.org/EIPS/eip-5564). Этот ERC объясняет, как использовать [скрытые адреса](https://nerolation.github.io/stealth-utils) для анонимных переводов.

**Предупреждение**. Криптография, лежащая в основе скрытых адресов, насколько нам известно, надежна. Однако существуют потенциальные атаки по побочным каналам. [Ниже](#go-wrong) вы увидите, что можно сделать, чтобы снизить этот риск.

## Как работают скрытые адреса {#how}

В этой статье мы попытаемся объяснить скрытые адреса двумя способами. Первый — [как их использовать](#how-use). Этой части достаточно, чтобы понять остальную часть статьи. Затем следует [объяснение математических основ](#how-math). Если вы интересуетесь криптографией, прочтите и эту часть.

### Простая версия (как использовать скрытые адреса) {#how-use}

Алиса создает два приватных ключа и публикует соответствующие публичные ключи (которые можно объединить в один метаадрес двойной длины). Билл также создает приватный ключ и публикует соответствующий публичный ключ.

Используя публичный ключ одной стороны и приватный ключ другой, можно получить общий секрет, известный только Алисе и Биллу (его нельзя получить только из публичных ключей). Используя этот общий секрет, Билл получает скрытый адрес и может отправлять на него активы.

Алиса также получает адрес из общего секрета, но поскольку она знает приватные ключи к опубликованным ею публичным ключам, она также может получить приватный ключ, который позволяет ей снимать средства с этого адреса.

### Математика (почему скрытые адреса работают именно так) {#how-math}

Стандартные скрытые адреса используют [криптографию на эллиптических кривых (ECC)](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/#elliptic-curves-building-blocks-of-a-better-trapdoor) для повышения производительности с меньшим количеством битов ключа при сохранении того же уровня безопасности. Но по большей части мы можем это игнорировать и делать вид, что используем обычную арифметику.

Существует число, известное всем, — _G_. Вы можете умножать на _G_. Но из-за природы ECC практически невозможно делить на _G_. В Ethereum криптография с публичным ключом обычно работает так: вы можете использовать приватный ключ _P<sub>priv</sub>_ для подписи транзакций, которые затем проверяются публичным ключом _P<sub>pub</sub> = GP<sub>priv</sub>_.

Алиса создает два приватных ключа: _K<sub>priv</sub>_ и _V<sub>priv</sub>_. _K<sub>priv</sub>_ будет использоваться для траты денег со скрытого адреса, а _V<sub>priv</sub>_ — для просмотра адресов, принадлежащих Алисе. Затем Алиса публикует публичные ключи: _K<sub>pub</sub> = GK<sub>priv</sub>_ и _V<sub>pub</sub> = GV<sub>priv</sub>_

Билл создает третий приватный ключ _R<sub>priv</sub>_ и публикует _R<sub>pub</sub> = GR<sub>priv</sub>_ в центральном реестре (Билл мог бы отправить его Алисе, но мы предполагаем, что Кэрол слушает).

Билл вычисляет _R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>_, который, как он ожидает, Алиса также знает (объяснено ниже). Это значение называется _S_, общий секрет. Это дает Биллу публичный ключ _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_. Из этого публичного ключа он может вычислить адрес и отправить на него любые ресурсы. В будущем, если Алиса победит, Билл может сообщить ей _R<sub>priv</sub>_, чтобы доказать, что ресурсы поступили от него.

Алиса вычисляет _R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_. Это дает ей тот же общий секрет, _S_. Поскольку она знает приватный ключ _K<sub>priv</sub>_, она может вычислить _P<sub>priv</sub> = K<sub>priv</sub>+hash(S)_. Этот ключ позволяет ей получить доступ к активам на адресе, который является результатом _P<sub>pub</sub> = GP<sub>priv</sub> = GK<sub>priv</sub>+G\*hash(S) = K<sub>pub</sub>+G\*hash(S)_.

У нас есть отдельный ключ просмотра, чтобы Алиса могла передать подряд Dave's World Domination Campaign Services. Алиса готова сообщить Дэйву публичные адреса и информировать ее о поступлении новых денег, но она не хочет, чтобы он тратил деньги ее кампании.

Поскольку для просмотра и траты используются разные ключи, Алиса может дать Дэйву _V<sub>priv</sub>_. Тогда Дэйв может вычислить _S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ и таким образом получить публичные ключи (_P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_). Но без _K<sub>priv</sub>_ Дэйв не сможет получить приватный ключ.

Таким образом, это значения, известные разным участникам.

| Алиса                                                                     | Опубликовано      | Билл                                                                      | Дэйв                                                                        |                                                 |
| ------------------------------------------------------------------------- | ----------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------- | ----------------------------------------------- |
| G                                                                         | G                 | G                                                                         | G                                                                           |                                                 |
| _K<sub>priv</sub>_                                                        | –                 | –                                                                         | –                                                                           |                                                 |
| _V<sub>priv</sub>_                                                        | –                 | –                                                                         | _V<sub>priv</sub>_                                                          |                                                 |
| _K<sub>pub</sub> = GK<sub>priv</sub>_                                     | _K<sub>pub</sub>_ | _K<sub>pub</sub>_                                                         | _K<sub>pub</sub>_                                                           |                                                 |
| _V<sub>pub</sub> = GV<sub>priv</sub>_                                     | _V<sub>pub</sub>_ | _V<sub>pub</sub>_                                                         | _V<sub>pub</sub>_                                                           |                                                 |
| –                                                                         | –                 | _R<sub>priv</sub>_                                                        | –                                                                           |                                                 |
| _R<sub>pub</sub>_                                                         | _R<sub>pub</sub>_ | _R<sub>pub</sub> = GR<sub>priv</sub>_                                     | _R<sub>pub</sub>_                                                           |                                                 |
| _S = R<sub>pub</sub>V<sub>priv</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | –                 | _S = R<sub>priv</sub>V<sub>pub</sub> = GR<sub>priv</sub>V<sub>priv</sub>_ | _S = _R<sub>pub</sub>V<sub>priv</sub>_ = GR<sub>priv</sub>V<sub>priv</sub>_ |                                                 |
| _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | –                 | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_         | _P<sub>pub</sub> = K<sub>pub</sub>+G\*hash(S)_           |                                                 |
| _Address=f(P<sub>pub</sub>)_                           | –                 | _Address=f(P<sub>pub</sub>)_                           | _Address=f(P<sub>pub</sub>)_                             | _Address=f(P<sub>pub</sub>)_ |
| _P<sub>priv</sub> = K<sub>priv</sub>+hash(S)_          | –                 | –                                                                         | –                                                                           |                                                 |

## Когда скрытые адреса работают не так, как надо {#go-wrong}

_В блокчейне нет секретов_. Хотя скрытые адреса могут обеспечить вам конфиденциальность, эта конфиденциальность уязвима для анализа трафика. В качестве простого примера представьте, что Билл пополняет адрес и сразу же отправляет транзакцию для публикации значения _R<sub>pub</sub>_. Без _V<sub>priv</sub>_ Алисы мы не можем быть уверены, что это скрытый адрес, но стоит сделать ставку именно на это. Затем мы видим еще одну транзакцию, которая переводит все ETH с этого адреса на адрес фонда кампании Алисы. Возможно, мы не сможем этого доказать, но, скорее всего, Билл только что сделал пожертвование в кампанию Алисы. Кэрол наверняка так и подумает.

Биллу легко отделить публикацию _R<sub>pub</sub>_ от финансирования скрытого адреса (делать это в разное время, с разных адресов). Однако этого недостаточно. Кэрол ищет закономерность: Билл пополняет адрес, а затем фонд кампании Алисы снимает с него средства.

Одно из решений состоит в том, чтобы кампания Алисы не снимала деньги напрямую, а использовала их для оплаты третьей стороне. Если кампания Алисы отправит 10 ETH в Dave's World Domination Campaign Services, Кэрол будет знать только то, что Билл сделал пожертвование одному из клиентов Дэйва. Если у Дэйва достаточно клиентов, Кэрол не сможет узнать, пожертвовал ли Билл Алисе, которая с ней конкурирует, или Адаму, Альберту или Эбигейл, до которых Кэрол нет дела. Алиса может включить в платеж хэшированное значение, а затем предоставить Дэйву прообраз, чтобы доказать, что это было ее пожертвование. В качестве альтернативы, как отмечалось выше, если Алиса даст Дэйву свой _V<sub>priv</sub>_, он уже будет знать, от кого пришел платеж.

Основная проблема этого решения в том, что оно требует от Алисы заботиться о секретности, когда эта секретность выгодна Биллу. Алиса может захотеть сохранить свою репутацию, чтобы друг Билла, Боб, тоже сделал ей пожертвование. Но также возможно, что она не прочь разоблачить Билла, потому что тогда он будет бояться того, что произойдет, если Кэрол победит. Билл может в итоге оказать Алисе еще большую поддержку.

### Использование нескольких скрытых слоев {#multi-layer}

Вместо того чтобы полагаться на Алису в сохранении конфиденциальности Билла, Билл может сделать это сам. Он может сгенерировать несколько метаадресов для вымышленных людей, Боба и Беллы. Затем Билл отправляет ETH Бобу, а "Боб" (который на самом деле Билл) отправляет их Белле. "Белла" (тоже Билл) отправляет их Алисе.

Кэрол все еще может анализировать трафик и видеть цепочку от Билла к Бобу, от Боба к Белле, от Беллы к Алисе. Однако, если "Боб" и "Белла" также используют ETH для других целей, не будет выглядеть так, будто Билл что-то перевел Алисе, даже если Алиса немедленно снимет средства со скрытого адреса на известный адрес своей кампании.

## Написание приложения для скрытых адресов {#write-app}

В этой статье объясняется приложение для скрытых адресов, [доступное на GitHub](https://github.com/qbzzt/251022-stealth-addresses.git).

### Инструменты {#tools}

Существует [библиотека скрытых адресов на typescript](https://github.com/ScopeLift/stealth-address-sdk), которую мы могли бы использовать. Однако криптографические операции могут быть ресурсоемкими для процессора. Я предпочитаю реализовывать их на компилируемом языке, таком как [Rust](https://rust-lang.org/), и использовать [WASM](https://webassembly.org/) для запуска кода в браузере.

Мы будем использовать [Vite](https://vite.dev/) и [React](https://react.dev/). Это стандартные отраслевые инструменты; если вы с ними не знакомы, можете воспользоваться [этим руководством](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/). Для использования Vite нам нужен Node.

### Скрытые адреса в действии {#in-action}

1. Установите необходимые инструменты: [Rust](https://rust-lang.org/tools/install/) и [Node](https://nodejs.org/en/download).

2. Клонируйте репозиторий GitHub.

   ```sh
   git clone https://github.com/qbzzt/251022-stealth-addresses.git
   cd 251022-stealth-addresses
   ```

3. Установите необходимые компоненты и скомпилируйте код Rust.

   ```sh
   cd src/rust-wasm
   rustup target add wasm32-unknown-unknown   
   cargo install wasm-pack   
   wasm-pack build --target web
   ```

4. Запустите веб-сервер.

   ```sh
   cd ../..
   npm install
   npm run dev
   ```

5. Перейдите в [приложение](http://localhost:5173/). Эта страница приложения имеет два фрейма: один для пользовательского интерфейса Алисы, а другой — для Билла. Два фрейма не взаимодействуют; они находятся на одной странице только для удобства.

6. От имени Алисы нажмите **Generate a Stealth Meta-Address**. Будет отображен новый скрытый адрес и соответствующие ему приватные ключи. Скопируйте скрытый метаадрес в буфер обмена.

7. От имени Билла вставьте новый скрытый метаадрес и нажмите **Generate an address**. Вы получите адрес для пополнения счета Алисы.

8. Скопируйте адрес и публичный ключ Билла и вставьте их в область "Private key for address generated by Bill" пользовательского интерфейса Алисы. После заполнения этих полей вы увидите приватный ключ для доступа к активам по этому адресу.

9. Вы можете использовать [онлайн-калькулятор](https://iancoleman.net/ethereum-private-key-to-address/), чтобы убедиться, что приватный ключ соответствует адресу.

### Как работает программа {#how-the-program-works}

#### Компонент WASM {#wasm}

Исходный код, который компилируется в WASM, написан на [Rust](https://rust-lang.org/). Вы можете увидеть его в [`src/rust_wasm/src/lib.rs`](https://github.com/qbzzt/251022-stealth-addresses/blob/main/src/rust-wasm/src/lib.rs). Этот код в основном является интерфейсом между кодом JavaScript и [библиотекой `eth-stealth-addresses`](https://github.com/kassandraoftroy/eth-stealth-addresses).

**`Cargo.toml`**

[`Cargo.toml`](https://doc.rust-lang.org/cargo/reference/manifest.html) в Rust является аналогом [`package.json`](https://docs.npmjs.com/cli/v9/configuring-npm/package-json) в JavaScript. Он содержит информацию о пакете, объявления зависимостей и т. д.

```toml
[package]
name = "rust-wasm"
version = "0.1.0"
edition = "2024"

[dependencies]
eth-stealth-addresses = "0.1.0"
hex = "0.4.3"
wasm-bindgen = "0.2.104"
getrandom = { version = "0.2", features = ["js"] }
```

Пакет [`getrandom`](https://docs.rs/getrandom/latest/getrandom/) необходим для генерации случайных значений. Это невозможно сделать чисто алгоритмическими средствами; для этого требуется доступ к физическому процессу как источнику энтропии. Это определение указывает, что мы будем получать эту энтропию, запрашивая ее у браузера, в котором мы работаем.

```toml
console_error_panic_hook = "0.1.7"
```

[Эта библиотека](https://docs.rs/console_error_panic_hook/latest/console_error_panic_hook/) выдает более содержательные сообщения об ошибках, когда код WASM паникует и не может продолжать работу.

```toml
[lib]
crate-type = ["cdylib", "rlib"]
```

Тип вывода, необходимый для создания кода WASM.

**`lib.rs`**

Это собственно код на Rust.

```rust
use wasm_bindgen::prelude::*;
```

Определения для создания пакета WASM из Rust. Они задокументированы [здесь](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/index.html).

```rust
use eth_stealth_addresses::{
    generate_stealth_meta_address,
    generate_stealth_address,
    compute_stealth_key
};
```

Функции, которые нам нужны из [библиотеки `eth-stealth-addresses`](https://github.com/kassandraoftroy/eth-stealth-addresses).

```rust
use hex::{decode,encode};
```

Rust обычно использует для значений байтовые [массивы](https://doc.rust-lang.org/std/primitive.array.html) (`[u8; <size>]`). Но в JavaScript мы обычно используем шестнадцатеричные строки. [Библиотека `hex`](https://docs.rs/hex/latest/hex/) переводит для нас значения из одного представления в другое.

```rust
#[wasm_bindgen]
```

Сгенерируйте привязки WASM, чтобы можно было вызывать эту функцию из JavaScript.

```rust
pub fn wasm_generate_stealth_meta_address() -> String {
```

Самый простой способ вернуть объект с несколькими полями — вернуть строку JSON.

```rust
    let (address, spend_private_key, view_private_key) = 
        generate_stealth_meta_address();
```

[`generate_stealth_meta_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_meta_address.html) возвращает три поля:

- Метаадрес (_K<sub>pub</sub>_ и _V<sub>pub</sub>_)
- Приватный ключ просмотра (_V<sub>priv</sub>_)
- Приватный ключ для траты средств (_K<sub>priv</sub>_)

Синтаксис [кортежа](https://doc.rust-lang.org/std/primitive.tuple.html) позволяет нам снова разделить эти значения.

```rust
    format!("{{\"address\":\"{}\",\"view_private_key\":\"{}\",\"spend_private_key\":\"{}\"}}",
        encode(address),
        encode(view_private_key),
        encode(spend_private_key)
    )
}
```

Используйте макрос [`format!`](https://doc.rust-lang.org/std/fmt/index.html) для генерации строки в формате JSON. Используйте [`hex::encode`](https://docs.rs/hex/latest/hex/fn.encode.html) для преобразования массивов в шестнадцатеричные строки.

```rust
fn str_to_array<const N: usize>(s: &str) -> Option<[u8; N]> {
```

Эта функция преобразует шестнадцатеричную строку (предоставленную JavaScript) в байтовый массив. Мы используем ее для разбора значений, предоставленных кодом JavaScript. Эта функция сложна из-за того, как Rust обрабатывает массивы и векторы.

Выражение `<const N: usize>` называется [обобщением (generic)](https://doc.rust-lang.org/book/ch10-01-syntax.html). `N` — это параметр, который управляет длиной возвращаемого массива. Функция на самом деле вызывается как `str_to_array::<n>`, где `n` — длина массива.

Возвращаемое значение — `Option<[u8; N]>`, что означает, что возвращаемый массив является [необязательным](https://doc.rust-lang.org/std/option/). Это типичный шаблон в Rust для функций, которые могут завершиться сбоем.

Например, если мы вызовем `str_to_array::10("bad060a7")`, функция должна вернуть массив из десяти значений, но на вход подается только четыре байта. Функция должна завершиться сбоем, и она делает это, возвращая `None`. Возвращаемым значением для `str_to_array::4("bad060a7")` будет `Some<[0xba, 0xd0, 0x60, 0xa7]>`.

```rust
    // decode возвращает Result<Vec<u8>, _>
    let vec = decode(s).ok()?;
```

Функция [`hex::decode`](https://docs.rs/hex/latest/hex/fn.decode.html) возвращает `Result<Vec<u8>, FromHexError>`. Тип [`Result`](https://doc.rust-lang.org/std/result/) может содержать либо успешный результат (`Ok(value)`), либо ошибку (`Err(error)`).

Метод `.ok()` превращает `Result` в `Option`, значением которого является либо значение `Ok()`, если успешно, либо `None`, если нет. Наконец, [оператор вопросительного знака](https://doc.rust-lang.org/std/option/#the-question-mark-operator-) прерывает текущие функции и возвращает `None`, если `Option` пуст. В противном случае он разворачивает значение и возвращает его (в данном случае для присвоения значения `vec`).

Это выглядит как странно запутанный метод обработки ошибок, но `Result` и `Option` гарантируют, что все ошибки будут обработаны тем или иным способом.

```rust
    if vec.len() != N { return None; }
```

Если количество байтов неверно, это сбой, и мы возвращаем `None`.

```rust
    // try_into поглощает vec и пытается создать [u8; N]
    let array: [u8; N] = vec.try_into().ok()?;
```

В Rust есть два типа массивов. [Массивы](https://doc.rust-lang.org/std/primitive.array.html) имеют фиксированный размер. [Векторы](https://doc.rust-lang.org/std/vec/index.html) могут расти и сжиматься. `hex::decode` возвращает вектор, но библиотека `eth_stealth_addresses` хочет получать массивы. [`.try_into()`](https://doc.rust-lang.org/std/convert/trait.TryInto.html#required-methods) преобразует значение в другой тип, например, вектор в массив.

```rust
    Some(array)
}
```

Rust не требует использования ключевого слова [`return`](https://doc.rust-lang.org/std/keyword.return.html) при возврате значения в конце функции.

```rust
#[wasm_bindgen]
pub fn wasm_generate_stealth_address(stealth_address: &str) -> Option<String> {
```

Эта функция получает публичный метаадрес, который включает в себя как _V<sub>pub</sub>_, так и _K<sub>pub</sub>_. Она возвращает скрытый адрес, публичный ключ для публикации (_R<sub>pub</sub>_) и однобайтовое значение сканирования, которое ускоряет идентификацию того, какие опубликованные адреса могут принадлежать Алисе.

Значение сканирования является частью общего секрета (_S = GR<sub>priv</sub>V<sub>priv</sub>_). Это значение доступно Алисе, и его проверка намного быстрее, чем проверка того, равно ли _f(K<sub>pub</sub>+G\*hash(S))_ опубликованному адресу.

```rust
    let (address, r_pub, scan) = 
        generate_stealth_address(&str_to_array::<66>(stealth_address)?);
```

Мы используем [`generate_stealth_address`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.generate_stealth_address.html) из библиотеки.

```rust
    format!("{{\"address\":\"{}\",\"rPub\":\"{}\",\"scan\":\"{}\"}}",
        encode(address),
        encode(r_pub),
        encode(&[scan])
    ).into()
}
```

Подготовьте выходную строку в формате JSON.

```rust
#[wasm_bindgen]
pub fn wasm_compute_stealth_key(
    address: &str, 
    bill_pub_key: &str, 
    view_private_key: &str,
    spend_private_key: &str    
) -> Option<String> {
    .
    .
    .
}
```

Эта функция использует [`compute_stealth_key`](https://docs.rs/eth-stealth-addresses/latest/eth_stealth_addresses/fn.compute_stealth_key.html) из библиотеки для вычисления приватного ключа для снятия средств с адреса (_R<sub>priv</sub>_). Для этого вычисления требуются следующие значения:

- Адрес (_Address=f(P<sub>pub</sub>)_)
- Публичный ключ, сгенерированный Биллом (_R<sub>pub</sub>_)
- Приватный ключ просмотра (_V<sub>priv</sub>_)
- Приватный ключ для траты средств (_K<sub>priv</sub>_)

```rust
#[wasm_bindgen(start)]
```

[`#[wasm_bindgen(start)]`](https://wasm-bindgen.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html) указывает, что функция выполняется при инициализации кода WASM.

```rust
pub fn main() {
    console_error_panic_hook::set_once();
}
```

Этот код указывает, что вывод паники должен быть отправлен в консоль JavaScript. Чтобы увидеть это в действии, используйте приложение и дайте Биллу неверный метаадрес (просто измените одну шестнадцатеричную цифру). Вы увидите эту ошибку в консоли JavaScript:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/subtle-2.6.1/src/lib.rs:701:9:
assertion `left == right` failed
  left: 0
 right: 1
```

За этим последует трассировка стека. Затем дайте Биллу действительный метаадрес, а Алисе — либо неверный адрес, либо неверный публичный ключ. Вы увидите эту ошибку:

```
rust_wasm.js:236 panicked at /home/ori/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/eth-stealth-addresses-0.1.0/src/lib.rs:78:9:
keys do not generate stealth address
```

Снова последует трассировка стека.

#### Пользовательский интерфейс {#ui}

Пользовательский интерфейс написан с использованием [React](https://react.dev/) и обслуживается [Vite](https://vite.dev/). Вы можете узнать о них из [этого руководства](/developers/tutorials/creating-a-wagmi-ui-for-your-contract/). Здесь нет необходимости в [WAGMI](https://wagmi.sh/), потому что мы не взаимодействуем напрямую с блокчейном или кошельком.

Единственная неочевидная часть пользовательского интерфейса — это подключение WASM. Вот как это работает.

**`vite.config.js`**

Этот файл содержит [конфигурацию Vite](https://vite.dev/config/).

```js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import wasm from "vite-plugin-wasm";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), wasm()],
})
```

Нам нужны два плагина Vite: [react](https://www.npmjs.com/package/@vitejs/plugin-react) и [wasm](https://github.com/Menci/vite-plugin-wasm#readme).

**`App.jsx`**

Этот файл является основным компонентом приложения. Это контейнер, который включает два компонента: `Alice` и `Bill` — пользовательские интерфейсы для этих пользователей. Актуальная часть для WASM — это код инициализации.

```jsx
import init from './rust-wasm/pkg/rust_wasm.js'
```

Когда мы используем [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/), он создает два файла, которые мы здесь используем: файл wasm с фактическим кодом (здесь `src/rust-wasm/pkg/rust_wasm_bg.wasm`) и файл JavaScript с определениями для его использования (здесь `src/rust_wasm/pkg/rust_wasm.js`). Экспорт по умолчанию этого файла JavaScript — это код, который необходимо запустить для инициации WASM.

```jsx
function App() {
    .
    .
    .
  useEffect(() => {
    const loadWasm = async () => {
      try {
        await init();
        setWasmReady(true)
      } catch (err) {
        console.error('Error loading wasm:', err)
        alert("Wasm error: " + err)
      }
    }

    loadWasm()
    }, []
  )
```

[Хук `useEffect`](https://react.dev/reference/react/useEffect) позволяет указать функцию, которая выполняется при изменении переменных состояния. Здесь список переменных состояния пуст (`[]`), поэтому эта функция выполняется только один раз при загрузке страницы.

Функция эффекта должна возвращаться немедленно. Чтобы использовать асинхронный код, такой как `init` WASM (который должен загрузить файл `.wasm` и, следовательно, занимает время), мы определяем внутреннюю функцию [`async`](https://en.wikipedia.org/wiki/Async/await) и запускаем ее без `await`.

**`Bill.jsx`**

Это пользовательский интерфейс для Билла. У него есть одно действие: создание адреса на основе скрытого метаадреса, предоставленного Алисой.

```jsx
import { wasm_generate_stealth_address } from './rust-wasm/pkg/rust_wasm.js'
```

В дополнение к экспорту по умолчанию, код JavaScript, сгенерированный `wasm-pack`, экспортирует функцию для каждой функции в коде WASM.

```jsx
            <button onClick={() => {
              setPublicAddress(JSON.parse(wasm_generate_stealth_address(stealthMetaAddress)))
            }}>
```

Для вызова функций WASM мы просто вызываем функцию, экспортируемую файлом JavaScript, созданным `wasm-pack`.

**`Alice.jsx`**

Код в `Alice.jsx` аналогичен, за исключением того, что у Алисы есть два действия:

- Сгенерировать метаадрес
- Получить приватный ключ для адреса, опубликованного Биллом

## Заключение {#conclusion}

Скрытые адреса не панацея; их нужно [использовать правильно](#go-wrong). Но при правильном использовании они могут обеспечить конфиденциальность в публичном блокчейне.

[Больше моих работ смотрите здесь](https://cryptodocguy.pro/).