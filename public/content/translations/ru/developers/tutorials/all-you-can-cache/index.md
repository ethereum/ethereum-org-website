---
title: "Что можно кешировать"
description: Узнайте, как создать и использовать кеширующий контракт для более дешевых транзакций ролл-апа
author: Ори Померанц
tags: [ "уровень 2", "кеширование", "хранилище" ]
skill: intermediate
published: 2022-09-15
lang: ru
---

При использовании ролл-апов стоимость байта в транзакции намного выше, чем стоимость слота в хранилище. Поэтому имеет смысл кешировать ончейн как можно больше информации.

В этой статье вы узнаете, как создавать и использовать кеширующий контракт таким образом, чтобы любое значение параметра, которое, скорее всего, будет использоваться несколько раз, кешировалось и было доступно для использования (после первого раза) с гораздо меньшим количеством байтов, и как писать оффчейн-код, использующий этот кеш.

Если вы хотите пропустить статью и просто посмотреть исходный код, [он находится здесь](https://github.com/qbzzt/20220915-all-you-can-cache). Стек разработки — [Foundry](https://getfoundry.sh/introduction/installation/).

## Общий дизайн {#overall-design}

Для простоты предположим, что все параметры транзакции имеют тип `uint256` и длину 32 байта. Когда мы получаем транзакцию, мы разбираем каждый параметр следующим образом:

1. Если первый байт равен `0xFF`, взять следующие 32 байта как значение параметра и записать его в кеш.

2. Если первый байт равен `0xFE`, взять следующие 32 байта как значение параметра, но _не_ записывать его в кеш.

3. Для любого другого значения взять старшие четыре бита как количество дополнительных байтов, а младшие четыре бита — как старшие значащие биты ключа кеша. Вот несколько примеров:

   | Байты в calldata | Ключ кеша |
   | :--------------- | --------: |
   | 0x0F             |      0x0F |
   | 0x10,0x10        |      0x10 |
   | 0x12,0xAC        |    0x02AC |
   | 0x2D,0xEA, 0xD6  |  0x0DEAD6 |

## Манипулирование кешем {#cache-manipulation}

Кеш реализован в [`Cache.sol`](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/Cache.sol). Давайте рассмотрим его построчно.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;


contract Cache {

    bytes1 public constant INTO_CACHE = 0xFF;
    bytes1 public constant DONT_CACHE = 0xFE;
```

Эти константы используются для интерпретации особых случаев, когда мы предоставляем всю информацию и решаем, записывать ее в кеш или нет. Запись в кеш требует двух операций [`SSTORE`](https://www.evm.codes/#55) в ранее неиспользованные слоты хранилища стоимостью 22100 ед. газа каждая, поэтому мы делаем ее необязательной.

```solidity

    mapping(uint => uint) public val2key;
```

[Сопоставление (mapping)](https://www.geeksforgeeks.org/solidity/solidity-mappings/) между значениями и их ключами. Эта информация необходима для кодирования значений перед отправкой транзакции.

```solidity
    // Ячейка n содержит значение для ключа n+1, потому что нам нужно сохранить
    // ноль как значение «не в кеше».
    uint[] public key2val;
```

Мы можем использовать массив для сопоставления ключей со значениями, потому что мы сами назначаем ключи, и для простоты делаем это последовательно.

```solidity
    function cacheRead(uint _key) public view returns (uint) {
        require(_key <= key2val.length, "Чтение неинициализированной записи кеша");
        return key2val[_key-1];
    }  // cacheRead
```

Чтение значения из кеша.

```solidity
    // Записать значение в кеш, если его там еще нет
    // Public только для того, чтобы тест работал
    function cacheWrite(uint _value) public returns (uint) {
        // Если значение уже есть в кеше, вернуть текущий ключ
        if (val2key[_value] != 0) {
            return val2key[_value];
        }
```

Нет смысла помещать одно и то же значение в кеш более одного раза. Если значение уже есть, просто верните существующий ключ.

```solidity
        // Поскольку 0xFE — это особый случай, самый большой ключ, который может
        // содержать кеш, — это 0x0D, за которым следуют 15 значений 0xFF. Если длина кеша уже
        // настолько велика, произойдет сбой.
        //                              1 2 3 4 5 6 7 8 9 A B C D E F
        require(key2val.length+1 < 0x0DFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
            "переполнение кеша");
```

Я не думаю, что мы когда-нибудь получим кеш такого большого размера (примерно 1,8\*10<sup>37</sup> записей, для хранения которых потребуется около 10<sup>27</sup> ТБ). Однако я достаточно стар, чтобы помнить [«640 КБ всегда будет достаточно»](https://quoteinvestigator.com/2011/09/08/640k-enough/). Эта проверка очень «дешевая» (не требует больших затрат).

```solidity
        // Записать значение, используя следующий ключ
        val2key[_value] = key2val.length+1;
```

Добавление обратного поиска (от значения к ключу).

```solidity
        key2val.push(_value);
```

Добавление прямого поиска (от ключа к значению). Поскольку мы присваиваем значения последовательно, мы можем просто добавить его после последнего значения массива.

```solidity
        return key2val.length;
    }  // cacheWrite
```

Возвращается новая длина `key2val`, которая является ячейкой, где хранится новое значение.

```solidity
    function _calldataVal(uint startByte, uint length)
        private pure returns (uint)
```

Эта функция считывает из calldata значение произвольной длины (до 32 байт, размер слова).

```solidity
    {
        uint _retVal;

        require(length < 0x21,
            "_calldataVal length limit is 32 bytes");
        require(length + startByte <= msg.data.length,
            "_calldataVal trying to read beyond calldatasize");
```

Эта функция является внутренней, поэтому, если остальная часть кода написана правильно, эти тесты не требуются. Однако они не требуют больших затрат, так что их можно оставить.

```solidity
        assembly {
            _retVal := calldataload(startByte)
        }
```

Этот код написан на [Yul](https://docs.soliditylang.org/en/v0.8.16/yul.html). Он считывает 32-байтовое значение из calldata. Это работает, даже если calldata заканчивается до `startByte+32`, потому что неинициализированное пространство в EVM считается нулевым.

```solidity
        _retVal = _retVal >> (256-length*8);
```

Нам не обязательно нужно 32-байтовое значение. Это избавляет от лишних байтов.

```solidity
        return _retVal;
    } // _calldataVal


    // Считать один параметр из calldata, начиная с _fromByte
    function _readParam(uint _fromByte) internal
        returns (uint _nextByte, uint _parameterValue)
    {
```

Считывание одного параметра из calldata. Обратите внимание, что нам нужно вернуть не только прочитанное значение, но и местоположение следующего байта, потому что параметры могут иметь длину от 1 до 33 байт.

```solidity
        // Первый байт говорит нам, как интерпретировать остальные
        uint8 _firstByte;

        _firstByte = uint8(_calldataVal(_fromByte, 1));
```

Solidity пытается уменьшить количество ошибок, запрещая потенциально опасные [неявные преобразования типов](https://docs.soliditylang.org/en/v0.8.16/types.html#implicit-conversions). Понижение, например с 256 бит до 8 бит, должно быть явным.

```solidity

        // Прочитать значение, но не записывать его в кеш
        if (_firstByte == uint8(DONT_CACHE))
            return(_fromByte+33, _calldataVal(_fromByte+1, 32));

        // Прочитать значение и записать его в кеш
        if (_firstByte == uint8(INTO_CACHE)) {
            uint _param = _calldataVal(_fromByte+1, 32);
            cacheWrite(_param);
            return(_fromByte+33, _param);
        }

        // Если мы дошли до этого места, это означает, что нам нужно читать из кеша

        // Количество дополнительных байтов для чтения
        uint8 _extraBytes = _firstByte / 16;
```

Возьмите младший [ниббл](https://en.wikipedia.org/wiki/Nibble) и объедините его с другими байтами, чтобы прочитать значение из кеша.

```solidity
        uint _key = (uint256(_firstByte & 0x0F) << (8*_extraBytes)) +
            _calldataVal(_fromByte+1, _extraBytes);

        return (_fromByte+_extraBytes+1, cacheRead(_key));

    }  // _readParam


    // Прочитать n параметров (функции знают, сколько параметров они ожидают)
    function _readParams(uint _paramNum) internal returns (uint[] memory) {
```

Мы могли бы получить количество имеющихся у нас параметров из самой calldata, но функции, которые нас вызывают, знают, сколько параметров они ожидают. Проще позволить им сообщить нам.

```solidity
        // Параметры, которые мы читаем
        uint[] memory params = new uint[](_paramNum);

        // Параметры начинаются с 4-го байта, до этого идет сигнатура функции
        uint _atByte = 4;

        for(uint i=0; i<_paramNum; i++) {
            (_atByte, params[i]) = _readParam(_atByte);
        }
```

Считывайте параметры, пока не получите необходимое их количество. Если мы выйдем за конец calldata, `_readParams` отменит вызов.

```solidity

        return(params);
    }   // readParams

    // Для тестирования _readParams, протестируйте чтение четырех параметров
    function fourParam() public
        returns (uint256,uint256,uint256,uint256)
    {
        uint[] memory params;
        params = _readParams(4);
        return (params[0], params[1], params[2], params[3]);
    }    // fourParam
```

Одним из больших преимуществ Foundry является то, что он позволяет писать тесты на Solidity ([см. Тестирование кеша ниже](#testing-the-cache)). Это значительно упрощает модульные тесты. Это функция, которая считывает четыре параметра и возвращает их, чтобы тест мог проверить их правильность.

```solidity
    // Получить значение, вернуть байты, которые будут его кодировать (используя кеш, если это возможно)
    function encodeVal(uint _val) public view returns(bytes memory) {
```

`encodeVal` — это функция, которую вызывает оффчейн-код, чтобы помочь создать calldata, использующую кеш. Она получает одно значение и возвращает байты, которые его кодируют. Эта функция является `view`, поэтому она не требует транзакции и при внешнем вызове не требует затрат газа.

```solidity
        uint _key = val2key[_val];

        // Значения еще нет в кеше, добавляем его
        if (_key == 0)
            return bytes.concat(INTO_CACHE, bytes32(_val));
```

В [EVM](/developers/docs/evm/) все неинициализированное хранилище считается нулевым. Поэтому, если мы ищем ключ для значения, которого там нет, мы получаем ноль. В этом случае байты, которые его кодируют, — это `INTO_CACHE` (чтобы в следующий раз оно было кешировано), за которым следует фактическое значение.

```solidity
        // Если ключ <0x10, вернуть его как один байт
        if (_key < 0x10)
            return bytes.concat(bytes1(uint8(_key)));
```

С одиночными байтами проще всего. Мы просто используем [`bytes.concat`](https://docs.soliditylang.org/en/v0.8.16/types.html#the-functions-bytes-concat-and-string-concat), чтобы превратить тип `bytes<n>` в массив байтов, который может быть любой длины. Несмотря на название, она отлично работает и при наличии только одного аргумента.

```solidity
        // Двухбайтовое значение, закодированное как 0x1vvv
        if (_key < 0x1000)
            return bytes.concat(bytes2(uint16(_key) | 0x1000));
```

Когда у нас есть ключ меньше 16<sup>3</sup>, мы можем выразить его в двух байтах. Сначала мы преобразуем `_key`, которое является 256-битным значением, в 16-битное значение и используем логическое «ИЛИ», чтобы добавить количество дополнительных байтов к первому байту. Затем мы просто преобразуем его в значение `bytes2`, которое может быть конвертировано в `bytes`.

```solidity
        // Вероятно, есть более изящный способ сделать следующие строки в виде цикла,
        // но это функция view, поэтому я оптимизирую ее с точки зрения времени программиста и
        // простоты.

        if (_key < 16*256**2)
            return bytes.concat(bytes3(uint24(_key) | (0x2 * 16 * 256**2)));
        if (_key < 16*256**3)
            return bytes.concat(bytes4(uint32(_key) | (0x3 * 16 * 256**3)));
             .
             .
             .
        if (_key < 16*256**14)
            return bytes.concat(bytes15(uint120(_key) | (0xE * 16 * 256**14)));
        if (_key < 16*256**15)
            return bytes.concat(bytes16(uint128(_key) | (0xF * 16 * 256**15)));
```

Другие значения (3 байта, 4 байта и т. д.) обрабатываются таким же образом, только с полями разного размера.

```solidity
        // Если мы дошли до этого места, что-то не так.
        revert("Ошибка в encodeVal, этого не должно было случиться");
```

Если мы дошли до этого места, это означает, что мы получили ключ, который не меньше 16\*256<sup>15</sup>. Но `cacheWrite` ограничивает ключи, поэтому мы не можем даже дойти до 14\*256<sup>16</sup> (первый байт которого будет 0xFE, так что это будет выглядеть как `DONT_CACHE`). Но добавить тест на случай, если будущий программист допустит ошибку, не составит большого труда.

```solidity
    } // encodeVal

}  // Cache
```

### Тестирование кеша {#testing-the-cache}

Одно из преимуществ Foundry заключается в том, что [оно позволяет писать тесты на Solidity](https://getfoundry.sh/forge/tests/overview/), что упрощает написание модульных тестов. Тесты для класса `Cache` находятся [здесь](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/test/Cache.t.sol). Поскольку код для тестов повторяется, что характерно для тестов, в этой статье объясняются только интересные части.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";


// Необходимо запустить `forge test -vv` для console.
import "forge-std/console.sol";
```

Это просто шаблонный код, необходимый для использования тестового пакета и `console.log`.

```solidity
import "src/Cache.sol";
```

Нам нужно знать контракт, который мы тестируем.

```solidity
contract CacheTest is Test {
    Cache cache;

    function setUp() public {
        cache = new Cache();
    }
```

Функция `setUp` вызывается перед каждым тестом. В этом случае мы просто создаем новый кеш, чтобы наши тесты не влияли друг на друга.

```solidity
    function testCaching() public {
```

Тесты — это функции, имена которых начинаются с `test`. Эта функция проверяет базовую функциональность кеша, записывая значения и считывая их снова.

```solidity
        for(uint i=1; i<5000; i++) {
            cache.cacheWrite(i*i);
        }

        for(uint i=1; i<5000; i++) {
            assertEq(cache.cacheRead(i), i*i);
```

Вот как вы проводите фактическое тестирование, используя [функции `assert...`](https://getfoundry.sh/reference/forge-std/std-assertions/). В этом случае мы проверяем, что значение, которое мы записали, является тем, которое мы прочитали. Мы можем отбросить результат `cache.cacheWrite`, потому что знаем, что ключи кеша назначаются линейно.

```solidity
        }
    }    // testCaching


    // Кешировать одно и то же значение несколько раз, убедиться, что ключ остается
    // прежним
    function testRepeatCaching() public {
        for(uint i=1; i<100; i++) {
            uint _key1 = cache.cacheWrite(i);
            uint _key2 = cache.cacheWrite(i);
            assertEq(_key1, _key2);
        }
```

Сначала мы записываем каждое значение в кеш дважды и убеждаемся, что ключи одинаковы (то есть вторая запись на самом деле не произошла).

```solidity
        for(uint i=1; i<100; i+=3) {
            uint _key = cache.cacheWrite(i);
            assertEq(_key, i);
        }
    }    // testRepeatCaching
```

Теоретически может существовать ошибка, которая не влияет на последовательные записи в кеш. Так что здесь мы делаем несколько записей, которые не являются последовательными, и видим, что значения все еще не перезаписываются.

```solidity
    // Считывание uint из буфера памяти (чтобы убедиться, что мы получаем обратно параметры,
    // которые отправили)
    function toUint256(bytes memory _bytes, uint256 _start) internal pure
        returns (uint256)
```

Считывание 256-битного слова из буфера `bytes memory`. Эта служебная функция позволяет нам убедиться, что мы получаем правильные результаты при выполнении вызова функции, использующей кеш.

```solidity
    {
        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
        uint256 tempUint;

        assembly {
            tempUint := mload(add(add(_bytes, 0x20), _start))
        }
```

Yul не поддерживает структуры данных сложнее `uint256`, поэтому, когда вы обращаетесь к более сложной структуре данных, такой как буфер памяти `_bytes`, вы получаете адрес этой структуры. Solidity хранит значения `bytes memory` в виде 32-байтового слова, которое содержит длину, за которой следуют фактические байты, так что для того чтобы получить байт номер `_start`, нам нужно вычислить `_bytes+32+_start`.

```solidity

        return tempUint;
    }     // toUint256

    // Сигнатура функции для fourParams() взята с
    // https://www.4byte.directory/signatures/?bytes4_signature=0x3edc1e6d
    bytes4 constant FOUR_PARAMS = 0x3edc1e6d;

    // Просто несколько постоянных значений, чтобы убедиться, что мы получаем правильные значения
    uint256 constant VAL_A = 0xDEAD60A7;
    uint256 constant VAL_B =     0xBEEF;
    uint256 constant VAL_C =     0x600D;
    uint256 constant VAL_D = 0x600D60A7;
```

Некоторые константы, которые нам нужны для тестирования.

```solidity
    function testReadParam() public {
```

Вызов `fourParams()`, функции, которая использует `readParams`, чтобы проверить, можем ли мы правильно читать параметры.

```solidity
        address _cacheAddr = address(cache);
        bool _success;
        bytes memory _callInput;
        bytes memory _callOutput;
```

Мы не можем использовать обычный механизм ABI для вызова функции, использующей кеш, поэтому нам нужно использовать низкоуровневый механизм [`<address>.call()`](https://docs.soliditylang.org/en/v0.8.16/types.html#members-of-addresses). Этот механизм принимает на вход `bytes memory` и возвращает его (а также логическое значение) в качестве выходных данных.

```solidity
        // Первый вызов, кеш пуст
        _callInput = bytes.concat(
            FOUR_PARAMS,
```

Полезно, чтобы один и тот же контракт поддерживал как кешированные функции (для вызовов непосредственно из транзакций), так и некешированные функции (для вызовов из других смарт-контрактов). Для этого нам нужно продолжать полагаться на механизм Solidity для вызова правильной функции, вместо того чтобы помещать все в [функцию `fallback`](https://docs.soliditylang.org/en/v0.8.16/contracts.html#fallback-function). Это значительно упрощает компонуемость. Одного байта в большинстве случаев было бы достаточно для идентификации функции, поэтому мы тратим впустую три байта (16\*3=48 ед. газа). Однако на момент написания этой статьи эти 48 ед. газа стоят 0,07 цента, что является разумной ценой за более простой и менее подверженный ошибкам код.

```solidity
            // Первое значение, добавить его в кеш
            cache.INTO_CACHE(),
            bytes32(VAL_A),
```

Первое значение: флаг, указывающий, что это полное значение, которое необходимо записать в кеш, за которым следуют 32 байта значения. Остальные три значения похожи, за исключением того, что `VAL_B` не записывается в кеш, а `VAL_C` является и третьим, и четвертым параметром.

```solidity
             .
             .
             .
        );
        (_success, _callOutput) = _cacheAddr.call(_callInput);
```

Здесь мы фактически вызываем контракт `Cache`.

```solidity
        assertEq(_success, true);
```

Мы ожидаем, что звонок будет успешным.

```solidity
        assertEq(cache.cacheRead(1), VAL_A);
        assertEq(cache.cacheRead(2), VAL_C);
```

Мы начинаем с пустого кеша, а затем добавляем `VAL_A`, а затем `VAL_C`. Мы ожидаем, что у первого будет ключ 1, а у второго — 2.

```
        assertEq(toUint256(_callOutput,0), VAL_A);
        assertEq(toUint256(_callOutput,32), VAL_B);
        assertEq(toUint256(_callOutput,64), VAL_C);
        assertEq(toUint256(_callOutput,96), VAL_C);
```

На выходе мы получаем четыре параметра. Здесь мы проверяем его правильность.

```solidity
        // Второй вызов, мы можем использовать кеш
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // Первое значение в кеше
            bytes1(0x01),
```

Ключи кеша размером менее 16 — это всего один байт.

```solidity
            // Второе значение, не добавляйте его в кеш
            cache.DONT_CACHE(),
            bytes32(VAL_B),

            // Третье и четвертое значения, одинаковые значения
            bytes1(0x02),
            bytes1(0x02)
        );
        .
        .
        .
    }   // testReadParam
```

Тесты после вызова идентичны тестам после первого вызова.

```solidity
    function testEncodeVal() public {
```

Эта функция похожа на `testReadParam`, за исключением того, что вместо явной записи параметров мы используем `encodeVal()`.

```solidity
        .
        .
        .
        _callInput = bytes.concat(
            FOUR_PARAMS,
            cache.encodeVal(VAL_A),
            cache.encodeVal(VAL_B),
            cache.encodeVal(VAL_C),
            cache.encodeVal(VAL_D)
        );
        .
        .
        .
        assertEq(_callInput.length, 4+1*4);
    }   // testEncodeVal
```

Единственный дополнительный тест в `testEncodeVal()` — это проверка правильности длины `_callInput`. Для первого вызова это 4+33\*4. Для второго, где каждое значение уже находится в кеше, это 4+1\*4.

```solidity
    // Тестирование encodeVal, когда ключ состоит более чем из одного байта
    // Максимум три байта, потому что заполнение кеша до четырех байт занимает
    // слишком много времени.
    function testEncodeValBig() public {
        // Поместить несколько значений в кеш.
        // Для простоты используйте ключ n для значения n.
        for(uint i=1; i<0x1FFF; i++) {
            cache.cacheWrite(i);
        }
```

Приведенная выше функция `testEncodeVal` записывает в кеш только четыре значения, поэтому [часть функции, которая работает с многобайтовыми значениями](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/Cache.sol#L144-L171), не проверяется. Но этот код сложен и подвержен ошибкам.

Первая часть этой функции представляет собой цикл, который записывает все значения от 1 до 0x1FFF в кеш по порядку, так что мы сможем закодировать эти значения и узнать, куда они пойдут.

```solidity
        .
        .
        .

        _callInput = bytes.concat(
            FOUR_PARAMS,
            cache.encodeVal(0x000F),   // Один байт        0x0F
            cache.encodeVal(0x0010),   // Два байта     0x1010
            cache.encodeVal(0x0100),   // Два байта     0x1100
            cache.encodeVal(0x1000)    // Три байта 0x201000
        );
```

Проверьте значения в один, два и три байта. Мы не будем тестировать дальше, потому что для записи достаточного количества записей стека потребуется слишком много времени (не менее 0x10000000, примерно четверть миллиарда).

```solidity
        .
        .
        .
        .
    }    // testEncodeValBig


    // Тестируем, что при слишком маленьком буфере мы получаем отмену
    function testShortCalldata() public {
```

Проверьте, что происходит в нештатном случае, когда параметров недостаточно.

```solidity
        .
        .
        .
        (_success, _callOutput) = _cacheAddr.call(_callInput);
        assertEq(_success, false);
    }   // testShortCalldata
```

Так как он отменяется, мы должны получить результат `false`.

```
    // Вызов с ключами кеша, которых нет
    function testNoCacheKey() public {
        .
        .
        .
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // Первое значение, добавить его в кеш
            cache.INTO_CACHE(),
            bytes32(VAL_A),

            // Второе значение
            bytes1(0x0F),
            bytes2(0x1234),
            bytes11(0xA10102030405060708090A)
        );
```

Эта функция получает четыре совершенно законных параметра, за исключением того, что кеш пуст, поэтому в нем нет значений для чтения.

```solidity
        .
        .
        .
    // Тестируем, что при слишком большом буфере все работает
    function testLongCalldata() public {
        address _cacheAddr = address(cache);
        bool _success;
        bytes memory _callInput;
        bytes memory _callOutput;

        // Первый вызов, кеш пуст
        _callInput = bytes.concat(
            FOUR_PARAMS,

            // Первое значение, добавить его в кеш
            cache.INTO_CACHE(), bytes32(VAL_A),

            // Второе значение, добавить его в кеш
            cache.INTO_CACHE(), bytes32(VAL_B),

            // Третье значение, добавить его в кеш
            cache.INTO_CACHE(), bytes32(VAL_C),

            // Четвертое значение, добавить его в кеш
            cache.INTO_CACHE(), bytes32(VAL_D),

            // И еще одно значение для «удачи»
            bytes4(0x31112233)
        );
```

Эта функция отправляет пять значений. Мы знаем, что пятое значение игнорируется, потому что оно не является допустимой записью кеша, что привело бы к отмене, если бы оно не было включено.

```solidity
        (_success, _callOutput) = _cacheAddr.call(_callInput);
        assertEq(_success, true);
        .
        .
        .
    }   // testLongCalldata

}        // CacheTest

```

## Пример приложения {#a-sample-app}

Писать тесты на Solidity — это, конечно, хорошо, но в конечном счете, чтобы быть полезным, децентрализованное приложение должно уметь обрабатывать запросы извне сети. В этой статье показано, как использовать кеширование в децентрализованном приложении с помощью `WORM`, что означает «Write Once, Read Many» (запись один раз, чтение много раз). Если ключ еще не записан, вы можете записать в него значение. Если ключ уже записан, вы получите отмену.

### Контракт {#the-contract}

[Вот этот контракт](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/src/WORM.sol). Он в основном повторяет то, что мы уже сделали с `Cache` и `CacheTest`, так что мы рассмотрим только интересные части.

```solidity
import "./Cache.sol";

contract WORM is Cache {
```

Самый простой способ использовать `Cache` — это унаследовать его в нашем собственном контракте.

```solidity
    function writeEntryCached() external {
        uint[] memory params = _readParams(2);
        writeEntry(params[0], params[1]);
    }    // writeEntryCached
```

Эта функция похожа на `fourParam` в `CacheTest` выше. Поскольку мы не следуем спецификациям ABI, лучше не объявлять никаких параметров в функции.

```solidity
    // Упростить вызов
    // Сигнатура функции для writeEntryCached() взята с
    // https://www.4byte.directory/signatures/?bytes4_signature=0xe4e4f2d3
    bytes4 constant public WRITE_ENTRY_CACHED = 0xe4e4f2d3;
```

Внешний код, который вызывает `writeEntryCached`, должен будет вручную создавать calldata, а не использовать `worm.writeEntryCached`, потому что мы не следуем спецификациям ABI. Наличие этого постоянного значения просто облегчает его написание.

Обратите внимание, что хотя мы определяем `WRITE_ENTRY_CACHED` как переменную состояния, для ее считывания извне необходимо использовать функцию-геттер для нее, `worm.WRITE_ENTRY_CACHED()`.

```solidity
    function readEntry(uint key) public view
        returns (uint _value, address _writtenBy, uint _writtenAtBlock)
```

Функция чтения — это `view`, поэтому она не требует транзакции и не расходует газ. В результате использование кеша для параметра не дает никаких преимуществ. С функциями view лучше использовать стандартный, более простой механизм.

### Тестовый код {#the-testing-code}

[Это тестовый код для контракта](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/test/WORM.t.sol). Опять же, давайте рассмотрим только то, что интересно.

```solidity
    function testWReadWrite() public {
        worm.writeEntry(0xDEAD, 0x60A7);

        vm.expectRevert(bytes("entry already written"));
        worm.writeEntry(0xDEAD, 0xBEEF);
```

[Так (`vm.expectRevert`)](https://book.getfoundry.sh/cheatcodes/expect-revert#expectrevert) мы указываем в тесте Foundry, что следующий вызов должен завершиться неудачей, и сообщаемую причину сбоя. Это применимо, когда мы используем синтаксис `<contract>.<function name>(), а не создаем calldata и вызываем контракт с помощью низкоуровневого интерфейса (`<contract>.call()\` и т. д.).

```solidity
    function testReadWriteCached() public {
        uint cacheGoat = worm.cacheWrite(0x60A7);
```

Здесь мы используем тот факт, что `cacheWrite` возвращает ключ кеша. Это не то, что мы ожидаем использовать в продакшене, потому что `cacheWrite` изменяет состояние и, следовательно, может вызываться только во время транзакции. Транзакции не возвращают значения, если у них есть результаты, эти результаты должны генерироваться как события. Таким образом, возвращаемое значение `cacheWrite` доступно только из ончейн-кода, а ончейн-код не нуждается в кешировании параметров.

```solidity
        (_success,) = address(worm).call(_callInput);
```

Вот как мы сообщаем Solidity, что, хотя `<contract address>.call()` имеет два возвращаемых значения, нас интересует только первое.

```solidity
        (_success,) = address(worm).call(_callInput);
        assertEq(_success, false);
```

Поскольку мы используем низкоуровневую функцию `<address>.call()`, мы не можем использовать `vm.expectRevert()` и должны смотреть на логическое значение успеха, которое мы получаем от вызова.

```solidity
    event EntryWritten(uint indexed key, uint indexed value);

        .
        .
        .

        _callInput = bytes.concat(
            worm.WRITE_ENTRY_CACHED(), worm.encodeVal(a), worm.encodeVal(b));
        vm.expectEmit(true, true, false, false);
        emit EntryWritten(a, b);
        (_success,) = address(worm).call(_callInput);
```

Это способ, которым мы проверяем, что код [правильно генерирует событие](https://getfoundry.sh/reference/cheatcodes/expect-emit/) в Foundry.

### Клиент {#the-client}

Единственное, что вы не получаете с тестами Solidity, — это код JavaScript, который можно вырезать и вставить в свое собственное приложение. Чтобы написать этот код, я развернул WORM в [Optimism Goerli](https://community.optimism.io/docs/useful-tools/networks/#optimism-goerli), новой тестовой сети [Optimism](https://www.optimism.io/). Он находится по адресу [`0xd34335b1d818cee54e3323d3246bd31d94e6a78a`](https://goerli-optimism.etherscan.io/address/0xd34335b1d818cee54e3323d3246bd31d94e6a78a).

[Вы можете увидеть код JavaScript для клиента здесь](https://github.com/qbzzt/20220915-all-you-can-cache/blob/main/javascript/index.js). Чтобы использовать его:

1. Клонируйте git-репозиторий:

   ```sh
   git clone https://github.com/qbzzt/20220915-all-you-can-cache.git
   ```

2. Установите необходимые пакеты:

   ```sh
   cd javascript
   yarn
   ```

3. Скопируйте файл конфигурации:

   ```sh
   cp .env.example .env
   ```

4. Отредактируйте `.env` для своей конфигурации:

   | Параметр                                                      | Значение                                                                                                                                                                                                            |
   | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
   | MNEMONIC                                                      | Мнемоническая фраза для аккаунта, у которого достаточно ETH для оплаты транзакции. [Вы можете получить бесплатный ETH для сети Optimism Goerli здесь](https://optimismfaucet.xyz/). |
   | OPTIMISM_GOERLI_URL | URL для Optimism Goerli. Общедоступная конечная точка `https://goerli.optimism.io` имеет ограничение по скорости, но этого достаточно для того, что нам здесь нужно.                |

5. Запустите `index.js`.

   ```sh
   node index.js
   ```

   Это примерное приложение сначала записывает запись в WORM, отображая calldata и ссылку на транзакцию в Etherscan. Затем оно считывает эту запись и отображает используемый ключ и значения в записи (значение, номер блока и автор).

Большая часть клиента — это обычный JavaScript для децентрализованных приложений. Так что, опять же, мы рассмотрим только интересные части.

```javascript
.
.
.
const main = async () => {
    const func = await worm.WRITE_ENTRY_CACHED()

    // Каждый раз нужен новый ключ
    const key = await worm.encodeVal(Number(new Date()))
```

В данный слот можно записать только один раз, поэтому мы используем временную метку, чтобы убедиться, что мы не будем повторно использовать слоты.

```javascript
const val = await worm.encodeVal("0x600D")

// Записать запись
const calldata = func + key.slice(2) + val.slice(2)
```

Ethers ожидает, что данные вызова будут шестнадцатеричной строкой, `0x`, за которым следует четное количество шестнадцатеричных цифр. Поскольку `key` и `val` начинаются с `0x`, нам нужно удалить эти заголовки.

```javascript
const tx = await worm.populateTransaction.writeEntryCached()
tx.data = calldata

sentTx = await wallet.sendTransaction(tx)
```

Как и в случае с тестовым кодом Solidity, мы не можем вызвать кешированную функцию обычным способом. Вместо этого нам нужно использовать механизм более низкого уровня.

```javascript
    .
    .
    .
    // Прочитать только что сделанную запись
    const realKey = '0x' + key.slice(4)  // удалить флаг FF
    const entryRead = await worm.readEntry(realKey)
    .
    .
    .
```

Для чтения записей можно использовать обычный механизм. Для функций `view` нет необходимости использовать кеширование параметров.

## Заключение {#conclusion}

Код в этой статье является доказательством концепции, цель которой — сделать идею легкой для понимания. Для готовой к производству системы вы можете захотеть реализовать некоторые дополнительные функции:

- Обработка значений, которые не являются `uint256`. Например, строки.
- Вместо глобального кеша, возможно, стоит использовать сопоставление между пользователями и кешами. Разные пользователи используют разные значения.
- Значения, используемые для адресов, отличаются от тех, что используются для других целей. Возможно, имеет смысл иметь отдельный кеш только для адресов.
- В настоящее время ключи кеша работают по алгоритму «первым пришел — наименьший ключ». Первые шестнадцать значений могут быть отправлены в виде одного байта. Следующие 4080 значений могут быть отправлены в виде двух байтов. Следующий примерно миллион значений — это три байта и т. д. Производственная система должна вести счетчики использования записей кеша и реорганизовывать их так, чтобы шестнадцать _наиболее распространенных_ значений занимали один байт, следующие 4080 наиболее распространенных значений — два байта и т. д.

  Однако это потенциально опасная операция. Представьте себе следующую последовательность событий:

  1. Ноам Наив вызывает `encodeVal` для кодирования адреса, на который он хочет отправить токены. Этот адрес является одним из первых, используемых в приложении, поэтому закодированное значение — 0x06. Это функция `view`, а не транзакция, поэтому это происходит между Ноамом и узлом, который он использует, и никто другой об этом не знает.

  2. Оуэн Оунер запускает операцию по реорганизации кеша. Очень немногие люди действительно используют этот адрес, поэтому теперь он закодирован как 0x201122. Другому значению, 10<sup>18</sup>, присваивается 0x06.

  3. Ноам Наив отправляет свои токены на 0x06. Они отправляются на адрес `0x0000000000000000000000000de0b6b3a7640000`, и, поскольку никто не знает приватный ключ для этого адреса, они просто застревают там. Ноам _недоволен_.

  Есть способы решить эту проблему и связанную с ней проблему транзакций, которые находятся в мемпуле во время реорганизации кеша, но вы должны знать об этом.

Я продемонстрировал кеширование здесь с помощью Optimism, потому что я сотрудник Optimism, и это ролл-ап, который я знаю лучше всего. Но это должно работать с любым ролл-апом, который взимает минимальную плату за внутреннюю обработку, так что по сравнению с этим запись данных транзакции в L1 является основной статьей расходов.

[Больше моих работ смотрите здесь](https://cryptodocguy.pro/).

