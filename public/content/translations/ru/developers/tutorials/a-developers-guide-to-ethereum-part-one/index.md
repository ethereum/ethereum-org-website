---
title: Введение в Ethereum для разработчиков на Python, часть 1
description: Введение в разработку для Ethereum, особенно полезное для тех, кто знаком с языком программирования Python
author: Марк Гарро
lang: ru
tags: [ "python", "web3.py" ]
skill: beginner
published: 08.09.2020
source: Snake charmers
sourceUrl: https://snakecharmers.ethereum.org/a-developers-guide-to-ethereum-pt-1/
---

Итак, вы слышали об Ethereum и готовы нырнуть в кроличью нору? В этой статье мы быстро рассмотрим некоторые основы блокчейна, а затем вы сможете поработать с симулированным узлом Ethereum: читать данные блоков, проверять балансы счетов и отправлять транзакции. Попутно мы выделим различия между традиционными способами создания приложений и этой новой децентрализованной парадигмой.

## Рекомендуемые предварительные требования {#soft-prerequisites}

Эта статья призвана быть доступной для широкого круга разработчиков. В статье будут использоваться [инструменты Python](/developers/docs/programming-languages/python/), но они являются лишь средством для демонстрации идей. Ничего страшного, если вы не являетесь Python-разработчиком. Однако я сделаю несколько предположений о том, что вы уже знаете, чтобы мы могли быстрее перейти к особенностям Ethereum.

Предположения:

- Вы умеете работать в терминале,
- Вы написали несколько строк кода на Python,
- На вашем компьютере установлен Python версии 3.6 или выше (настоятельно рекомендуется использовать [виртуальную среду](https://realpython.com/effective-python-environment/#virtual-environments)), и
- вы использовали `pip`, установщик пакетов Python.
  Опять же, если что-то из этого неверно или вы не планируете воспроизводить код из этой статьи, вы, скорее всего, все равно сможете без проблем следить за изложением.

## Коротко о блокчейнах {#blockchains-briefly}

Существует много способов описать Ethereum, но в его основе лежит блокчейн. Блокчейны состоят из серии блоков, так что давайте с этого и начнем. Проще говоря, каждый блок в блокчейне Ethereum — это просто набор метаданных и список транзакций. В формате JSON это выглядит примерно так:

```json
{
   "number": 1234567,
   "hash": "0xabc123...",
   "parentHash": "0xdef456...",
   ...,
   "transactions": [...]
}
```

Каждый [блок](/developers/docs/blocks/) содержит ссылку на предшествующий ему блок; `parentHash` — это просто хэш предыдущего блока.

<FeaturedText>Примечание. Ethereum регулярно использует <a href="https://wikipedia.org/wiki/Hash_function">хэш-функции</a> для получения значений фиксированного размера («хэшей»). Хэши играют важную роль в Ethereum, но пока вы можете спокойно считать их уникальными идентификаторами.</FeaturedText>

![Диаграмма, изображающая блокчейн, включая данные внутри каждого блока](./blockchain-diagram.png)

_По сути, блокчейн — это связный список; каждый блок содержит ссылку на предыдущий._

Эта структура данных не нова, но новаторскими являются правила (т. е. одноранговые протоколы), которые управляют сетью. Центрального органа управления нет; участники сети должны сотрудничать для ее поддержания и конкурировать за право решать, какие транзакции включать в следующий блок. Итак, когда вы хотите отправить деньги другу, вам нужно будет объявить об этой транзакции в сети, а затем дождаться ее включения в один из следующих блоков.

Единственный способ для блокчейна проверить, что деньги действительно были отправлены от одного пользователя другому, — это использовать собственную валюту (т. е. созданную и управляемую) этого блокчейна. В Ethereum эта валюта называется ether (эфир), а блокчейн Ethereum содержит единственную официальную запись о балансах счетов.

## Новая парадигма {#a-new-paradigm}

Этот новый децентрализованный технологический стек породил новые инструменты для разработчиков. Такие инструменты существуют для многих языков программирования, но мы будем рассматривать их через призму Python. Повторюсь: даже если Python не является языком вашего выбора, вам не составит особого труда следить за изложением.

Python-разработчики, которые хотят взаимодействовать с Ethereum, скорее всего, воспользуются [Web3.py](https://web3py.readthedocs.io/). Web3.py — это библиотека, которая значительно упрощает подключение к узлу Ethereum, а также отправку и получение данных от него.

<FeaturedText>Примечание. «Узел Ethereum» и «клиент Ethereum» используются как взаимозаменяемые понятия. В любом случае речь идет о программном обеспечении, которое запускает участник сети Ethereum. Это программное обеспечение может читать данные блоков, получать обновления при добавлении в цепь новых блоков, объявлять о новых транзакциях и многое другое. Технически клиент — это программное обеспечение, а узел — это компьютер, на котором это программное обеспечение запущено.</FeaturedText>

[Клиенты Ethereum](/developers/docs/nodes-and-clients/) могут быть настроены для доступа по [IPC](https://wikipedia.org/wiki/Inter-process_communication), HTTP или через веб-сокеты, поэтому Web3.py должен будет отражать эту конфигурацию. Web3.py называет эти варианты подключения **провайдерами**. Вам нужно будет выбрать одного из трех провайдеров, чтобы связать экземпляр Web3.py с вашим узлом.

![Диаграмма, показывающая, как web3.py использует IPC для подключения вашего приложения к узлу Ethereum](./web3py-and-nodes.png)

_Настройте узел Ethereum и Web3.py для обмена данными по одному и тому же протоколу, например, IPC на этой диаграмме._

После правильной настройки Web3.py вы можете начать взаимодействовать с блокчейном. Вот пара примеров использования Web3.py в качестве предварительного ознакомления с тем, что нас ждет впереди:

```python
# чтение данных блока:
w3.eth.get_block('latest')

# отправка транзакции:
w3.eth.send_transaction({'from': ..., 'to': ..., 'value': ...})
```

## Установка {#installation}

В этом пошаговом руководстве мы будем работать только в интерпретаторе Python. Мы не будем создавать никаких каталогов, файлов, классов или функций.

<FeaturedText>Примечание. В приведенных ниже примерах команды, начинающиеся с `$`, предназначены для запуска в терминале. (Не вводите символ `$`, он просто обозначает начало строки.)</FeaturedText>

Сначала установите [IPython](https://ipython.org/), чтобы получить удобную среду для изучения. Помимо прочих функций, IPython предлагает автодополнение по клавише Tab, что значительно упрощает изучение возможностей Web3.py.

```bash
pip install ipython
```

Web3.py опубликован под названием `web3`. Установить его можно так:

```bash
pip install web3
```

И еще кое-что: позже мы будем симулировать блокчейн, для чего потребуется еще пара зависимостей. Их можно установить с помощью следующей команды:

```bash
pip install 'web3[tester]'
```

Все готово к работе!

Примечание. Пакет `web3[tester]` работает вплоть до версии Python 3.10.xx

## Запускаем песочницу {#spin-up-a-sandbox}

Откройте новую среду Python, запустив `ipython` в своем терминале. Это похоже на запуск `python`, но с большим количеством дополнительных возможностей.

```bash
ipython
```

Будет выведена информация о версиях Python и IPython, после чего вы увидите приглашение для ввода:

```python
In [1]:
```

Теперь вы смотрите в интерактивную оболочку Python. По сути, это песочница для экспериментов. Если вы дошли до этого места, то пора импортировать Web3.py:

```python
In [1]: from web3 import Web3
```

## Знакомство с модулем Web3 {#introducing-the-web3-module}

Помимо того, что модуль [Web3](https://web3py.readthedocs.io/en/stable/overview.html#base-api) является шлюзом в Ethereum, он предлагает несколько удобных функций. Давайте рассмотрим некоторые из них.

В приложении Ethereum часто возникает необходимость конвертировать номиналы валют. Модуль Web3 предоставляет для этого пару вспомогательных методов: [from_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.from_wei) и [to_wei](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.to_wei).

<FeaturedText>
Примечание. Компьютеры печально известны плохой обработкой десятичной арифметики. Чтобы обойти это, разработчики часто хранят суммы в долларах в центах. Например, товар с ценой $5,99 может храниться в базе данных как 599.

Аналогичный подход используется при обработке транзакций в <b>ether</b>. Однако вместо двух десятичных знаков у ether их 18! Самая маленькая единица ether называется <b>wei</b>, и именно это значение указывается при отправке транзакций.

1 ether = 1000000000000000000 wei

1 wei = 0.000000000000000001 ether

</FeaturedText>

Попробуйте конвертировать некоторые значения в wei и обратно. Обратите внимание, что [многие из номиналов](https://web3py.readthedocs.io/en/stable/troubleshooting.html#how-do-i-convert-currency-denominations) между ether и wei имеют свои названия. Один из наиболее известных среди них — **gwei**, так как в нем часто указывают комиссию за транзакции.

```python
In [2]: Web3.to_wei(1, 'ether')
Out[2]: 1000000000000000000

In [3]: Web3.from_wei(500000000, 'gwei')
Out[3]: Decimal('0.5')
```

Другие служебные методы модуля Web3 включают преобразователи форматов данных (например, [`toHex`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.toHex)), вспомогательные функции для адресов (например, [`isAddress`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.isAddress)) и хэш-функции (например, [`keccak`](https://web3py.readthedocs.io/en/stable/web3.main.html#web3.Web3.keccak)). Многие из них будут рассмотрены далее в этой серии статей. Чтобы просмотреть все доступные методы и свойства, воспользуйтесь автодополнением IPython, набрав `Web3`. и дважды нажав клавишу Tab после точки.

## Общение с блокчейном {#talk-to-the-chain}

Вспомогательные методы — это прекрасно, но давайте перейдем к блокчейну. Следующим шагом является настройка Web3.py для взаимодействия с узлом Ethereum. Здесь у нас есть возможность использовать провайдеры IPC, HTTP или Websocket.

Мы не будем идти по этому пути, но пример полного рабочего процесса с использованием HTTP-провайдера может выглядеть примерно так:

- Скачайте узел Ethereum, например, [Geth](https://geth.ethereum.org/).
- Запустите Geth в одном окне терминала и дождитесь синхронизации с сетью. Порт HTTP по умолчанию — `8545`, но его можно настроить.
- Сообщите Web3.py, чтобы он подключался к узлу через HTTP, по адресу `localhost:8545`.
  `w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))`
- Используйте экземпляр `w3` для взаимодействия с узлом.

Хотя это один из «реальных» способов, процесс синхронизации занимает часы и не является необходимым, если вам просто нужна среда разработки. Для этой цели Web3.py предоставляет четвертый провайдер — **EthereumTesterProvider**. Этот тестовый провайдер подключается к симулированному узлу Ethereum с более мягкими правами доступа и поддельной валютой для экспериментов.

![Диаграмма, показывающая EthereumTesterProvider, связывающий ваше приложение web3.py с симулированным узлом Ethereum](./ethereumtesterprovider.png)

_EthereumTesterProvider подключается к симулированному узлу и удобен для быстрой организации сред разработки._

Этот симулированный узел называется [eth-tester](https://github.com/ethereum/eth-tester), и мы установили его в рамках команды `pip install web3[tester]`. Настроить Web3.py для использования этого тестового провайдера очень просто:

```python
In [4]: w3 = Web3(Web3.EthereumTesterProvider())
```

Теперь вы готовы к серфингу по блокчейну! Вообще-то так не говорят. Я только что это выдумал. Давайте совершим краткий тур.

## Краткий тур {#the-quick-tour}

Первым делом — проверка работоспособности:

```python
In [5]: w3.is_connected()
Out[5]: True
```

Поскольку мы используем тестовый провайдер, эта проверка не очень информативна, но если она не удалась, скорее всего, вы что-то не так набрали при создании экземпляра переменной `w3`. Перепроверьте, что вы включили внутренние скобки, т. е. `Web3.EthereumTesterProvider()`.

## Остановка № 1: [аккаунты](/developers/docs/accounts/) {#tour-stop-1-accounts}

Для удобства тестовый провайдер создал несколько аккаунтов и предварительно пополнил их тестовым эфиром.

Сначала давайте посмотрим список этих аккаунтов:

```python
In [6]: w3.eth.accounts
Out[6]: ['0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
 '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
 '0x6813Eb9362372EEF6200f3b1dbC3f819671cBA69', ...]
```

Если вы выполните эту команду, вы должны увидеть список из десяти строк, начинающихся с `0x`. Каждая из них является **публичным адресом** и в некотором роде аналогична номеру расчетного счета. Вы можете предоставить этот адрес тому, кто хочет отправить вам эфир.

Как уже упоминалось, тестовый провайдер предварительно пополнил каждый из этих аккаунтов некоторым количеством тестового эфира. Давайте узнаем, сколько средств на первом аккаунте:

```python
In [7]: w3.eth.get_balance(w3.eth.accounts[0])
Out[7]: 1000000000000000000000000
```

Как много нулей! Прежде чем вы побежите в поддельный банк, вспомните урок о номиналах валюты. Суммы в ether выражаются в наименьшем номинале — wei. Конвертируйте это в ether:

```python
In [8]: w3.from_wei(1000000000000000000000000, 'ether')
Out[8]: Decimal('1000000')
```

Один миллион тестовых ether — тоже неплохо.

## Остановка № 2: данные блока {#tour-stop-2-block-data}

Давайте посмотрим на состояние этого симулированного блокчейна:

```python
In [9]: w3.eth.get_block('latest')
Out[9]: AttributeDict({
   'number': 0,
   'hash': HexBytes('0x9469878...'),
   'parentHash': HexBytes('0x0000000...'),
   ...
   'transactions': []
})
```

О блоке возвращается много информации, но здесь следует отметить лишь несколько моментов:

- Номер блока — ноль, независимо от того, как давно вы настроили тестовый провайдер. В отличие от реальной сети Ethereum, которая добавляет новый блок каждые 12 секунд, эта симуляция будет ждать, пока вы не дадите ей какую-нибудь работу.
- `transactions` — это пустой список по той же причине: мы еще ничего не делали. Этот первый блок — **пустой блок**, он нужен просто для того, чтобы запустить цепочку.
- Обратите внимание, что `parentHash` — это просто набор пустых байтов. Это означает, что это первый блок в цепочке, также известный как **генезис-блок**.

## Остановка № 3: [транзакции](/developers/docs/transactions/) {#tour-stop-3-transactions}

Мы застряли на нулевом блоке, пока не появится ожидающая транзакция, так что давайте создадим ее. Отправьте несколько тестовых ether с одного аккаунта на другой:

```python
In [10]: tx_hash = w3.eth.send_transaction({
   'from': w3.eth.accounts[0],
   'to': w3.eth.accounts[1],
   'value': w3.to_wei(3, 'ether'),
   'gas': 21000
})
```

Обычно в этот момент вам пришлось бы ждать несколько секунд, пока ваша транзакция не будет включена в новый блок. Полный процесс выглядит примерно так:

1. Отправьте транзакцию и сохраните ее хэш. Пока блок, содержащий транзакцию, не будет создан и распространен, транзакция находится в состоянии «ожидания».
   `tx_hash = w3.eth.send_transaction({ … })`
2. Дождитесь включения транзакции в блок:
   `w3.eth.wait_for_transaction_receipt(tx_hash)`
3. Продолжите логику приложения. Чтобы просмотреть успешную транзакцию:
   `w3.eth.get_transaction(tx_hash)`

Наша симулированная среда мгновенно добавит транзакцию в новый блок, так что мы можем сразу же просмотреть транзакцию:

```python
In [11]: w3.eth.get_transaction(tx_hash)
Out[11]: AttributeDict({
   'hash': HexBytes('0x15e9fb95dc39...'),
   'blockNumber': 1,
   'transactionIndex': 0,
   'from': '0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf',
   'to': '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF',
   'value': 3000000000000000000,
   ...
})
```

Здесь вы увидите некоторые знакомые детали: поля `from`, `to` и `value` должны соответствовать входным данным нашего вызова `send_transaction`. Еще один обнадеживающий момент заключается в том, что эта транзакция была включена как первая транзакция (`'transactionIndex': 0`) в блок номер 1.

Мы также можем легко проверить успешность этой транзакции, проверив балансы двух задействованных аккаунтов. Три ether должны были переместиться с одного на другой.

```python
In [12]: w3.eth.get_balance(w3.eth.accounts[0])
Out[12]: 999996999979000000000000

In [13]: w3.eth.get_balance(w3.eth.accounts[1])
Out[13]: 1000003000000000000000000
```

Последний выглядит хорошо! Баланс изменился с 1 000 000 до 1 000 003 ether. Но что случилось с первым аккаунтом? Похоже, он потерял немного больше трех ether. Увы, в жизни ничто не дается бесплатно, и использование публичной сети Ethereum требует, чтобы вы компенсировали другим участникам их поддерживающую роль. С аккаунта, отправившего транзакцию, была списана небольшая комиссия за транзакцию. Эта комиссия представляет собой объем сожженного газа (21 000 единиц газа за перевод ETH), умноженный на базовую комиссию, которая варьируется в зависимости от активности сети, плюс чаевые, которые получает валидатор, включивший транзакцию в блок.

Подробнее о [газе](/developers/docs/gas/#post-london)

<FeaturedText>Примечание. В публичной сети комиссии за транзакции являются переменными и зависят от спроса в сети и от того, насколько быстро вы хотите, чтобы транзакция была обработана. Если вас интересует, как рассчитываются комиссии, см. мой предыдущий пост о том, <a href="https://medium.com/ethereum-grid/ethereum-101-how-are-transactions-included-in-a-block-9ae5f491853f">как транзакции включаются в блок</a>.</FeaturedText>

## И выдохнем {#and-breathe}

Мы уже довольно долго этим занимаемся, так что это хорошее место, чтобы сделать перерыв. Кроличья нора продолжается, и мы продолжим ее исследование во второй части этой серии статей. Некоторые из будущих тем: подключение к реальному узлу, смарт-контракты и токены. Остались вопросы? Дайте мне знать! Ваши отзывы повлияют на то, куда мы будем двигаться дальше. Запросы принимаются через [Twitter](https://twitter.com/wolovim).
