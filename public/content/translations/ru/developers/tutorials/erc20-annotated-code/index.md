---
title: "Пошаговый разбор контракта ERC-20"
description: "Что содержит контракт ERC-20 от OpenZeppelin и для чего это нужно?"
author: "Ори Померанц"
lang: ru
tags: [ "твердость", "erc-20" ]
skill: beginner
published: 2021-03-09
---

## Введение {#introduction}

Чаще всего Ethereum используется для создания собственного токена, который можно использовать как валюту. Эти токены обычно следуют стандарту,
[ERC-20](/developers/docs/standards/tokens/erc-20/). Этот стандарт позволяет создавать такие инструменты, как пулы ликвидности и кошельки, которые работают со всеми токенами
ERC-20. В этой статье мы проанализируем
[реализацию ERC20 на Solidity от OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol), а также
[определение интерфейса](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol).

Это аннотированный исходный код. Если вы хотите реализовать ERC-20,
[прочтите это руководство](https://docs.openzeppelin.com/contracts/2.x/erc20-supply).

## Интерфейс {#the-interface}

Цель такого стандарта, как ERC-20, — обеспечить совместимость множества реализаций токенов в различных приложениях, таких как кошельки и децентрализованные биржи. Для этого мы создаем
[интерфейс](https://www.geeksforgeeks.org/solidity/solidity-basics-of-interface/). Любой код, которому требуется использовать контракт токена,
может использовать те же определения в интерфейсе и быть совместимым со всеми контрактами токенов, которые его используют, будь то кошелек, такой как
MetaMask, децентрализованное приложение, такое как etherscan.io, или другой контракт, например пул ликвидности.

![Иллюстрация интерфейса ERC-20](erc20_interface.png)

Если вы опытный программист, вы, вероятно, помните, что видели подобные конструкции в [Java](https://www.w3schools.com/java/java_interface.asp)
или даже в [заголовочных файлах C](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html).

Это определение [интерфейса ERC-20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol)
от OpenZeppelin. Это перевод [человекочитаемого стандарта](https://eips.ethereum.org/EIPS/eip-20) в код Solidity. Конечно, сам
интерфейс не определяет, _как_ что-либо делать. Это объясняется в исходном коде контракта ниже.

&nbsp;

```solidity
// SPDX-License-Identifier: MIT
```

Файлы Solidity должны содержать идентификатор лицензии. [Вы можете посмотреть список лицензий здесь](https://spdx.org/licenses/). Если вам нужна другая
лицензия, просто укажите это в комментариях.

&nbsp;

```solidity
pragma solidity >=0.6.0 <0.8.0;
```

Язык Solidity все еще быстро развивается, и новые версии могут быть несовместимы со старым кодом
([см. здесь](https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html)). Поэтому рекомендуется указывать не только минимальную
версию языка, но и максимальную — последнюю, с которой вы тестировали код.

&nbsp;

```solidity
/**
 * @dev Интерфейс стандарта ERC20, как определено в EIP.
 */
```

`@dev` в комментарии является частью [формата NatSpec](https://docs.soliditylang.org/en/develop/natspec-format.html), используемого для создания
документации из исходного кода.

&nbsp;

```solidity
interface IERC20 {
```

По соглашению, имена интерфейсов начинаются с `I`.

&nbsp;

```solidity
    /**
     * @dev Возвращает количество существующих токенов.
     */
    function totalSupply() external view returns (uint256);
```

Эта функция является `external`, что означает, [что она может быть вызвана только извне контракта](https://docs.soliditylang.org/en/v0.7.0/cheatsheet.html#index-2).
Она возвращает общее количество токенов в контракте. Это значение возвращается с использованием самого распространенного типа в Ethereum, 256-битного беззнакового целого числа (256 бит — это
собственный размер слова EVM). Эта функция также является `view`, что означает, что она не изменяет состояние, поэтому ее можно выполнить на одном узле, вместо того чтобы ее
выполнял каждый узел в блокчейне. Такая функция не создает транзакцию и не требует [Газа](/developers/docs/gas/).

**Примечание.** Теоретически может показаться, что создатель контракта может сжульничать, возвращая общее предложение меньше реального, чтобы каждый токен казался
более ценным, чем он есть на самом деле. Однако этот страх игнорирует истинную природу блокчейна. Все, что происходит в блокчейне, может быть проверено
каждым узлом. Для этого машинный код и хранилище каждого контракта доступны на каждом узле. Хотя вы не обязаны публиковать код
Solidity для вашего контракта, никто не воспримет вас всерьез, если вы не опубликуете исходный код и версию Solidity, с которой он был скомпилирован, чтобы его можно было
проверить на соответствие предоставленному вами машинному коду.
Например, см. [этот контракт](https://eth.blockscout.com/address/0xa530F85085C6FE2f866E7FdB716849714a89f4CD?tab=contract).

&nbsp;

```solidity
    /**
     * @dev Возвращает количество токенов, принадлежащих `account`.
     */
    function balanceOf(address account) external view returns (uint256);
```

Как следует из названия, `balanceOf` возвращает баланс аккаунта. Аккаунты Ethereum идентифицируются в Solidity с помощью типа `address`, который содержит 160 бит.
Она также `external` и `view`.

&nbsp;

```solidity
    /**
     * @dev Перемещает `amount` токенов со счета вызывающего на `recipient`.
     *
     * Возвращает логическое значение, указывающее, успешно ли выполнена операция.
     *
     * Инициирует событие {Transfer}.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
```

Функция `transfer` переводит токены с вызывающего адреса на другой адрес. Это связано с изменением состояния, поэтому она не является `view`.
Когда пользователь вызывает эту функцию, создается транзакция и расходуется Газ. Она также инициирует событие `Transfer`, чтобы проинформировать всех в
блокчейне об этом событии.

Функция имеет два типа вывода для двух разных типов вызывающих:

- Пользователи, которые вызывают функцию напрямую из пользовательского интерфейса. Обычно пользователь отправляет транзакцию
  и не ждет ответа, что может занять неопределенное количество времени. Пользователь может увидеть, что произошло,
  поискав квитанцию о транзакции (которая идентифицируется по Хэшу транзакции) или поискав событие
  `Transfer`.
- Другие контракты, которые вызывают функцию как часть общей транзакции. Эти контракты получают результат немедленно,
  потому что они выполняются в той же транзакции, поэтому они могут использовать возвращаемое функцией значение.

Тот же тип вывода создается и другими функциями, которые изменяют состояние контракта.

&nbsp;

Разрешения позволяют аккаунту тратить некоторые токены, принадлежащие другому владельцу.
Это полезно, например, для контрактов, которые действуют как продавцы. Контракты не могут
отслеживать события, поэтому, если покупатель переведет токены на контракт продавца
напрямую, этот контракт не узнает, что ему заплатили. Вместо этого покупатель разрешает
контракту продавца потратить определенную сумму, и продавец переводит эту сумму.
Это делается с помощью функции, которую вызывает контракт продавца, поэтому контракт продавца
может узнать, была ли операция успешной.

```solidity
    /**
     * @dev Возвращает оставшееся количество токенов, которые `spender` сможет
     * потратить от имени `owner` через {transferFrom}. По умолчанию
     * это ноль.
     *
     * Это значение изменяется при вызове {approve} или {transferFrom}.
     */
    function allowance(address owner, address spender) external view returns (uint256);
```

Функция `allowance` позволяет любому запросить, какое разрешение один
адрес (`owner`) дает другому адресу (`spender`) на трату.

&nbsp;

```solidity
    /**
     * @dev Устанавливает `amount` в качестве разрешенной суммы для `spender` сверх токенов вызывающей стороны.
     *
     * Возвращает логическое значение, указывающее, успешно ли выполнена операция.
     *
     * ВАЖНО: имейте в виду, что изменение разрешения с помощью этого метода несет в себе риск,
     * что кто-то может использовать и старое, и новое разрешение из-за неудачного
     * порядка транзакций. Одним из возможных решений для смягчения этого состояния гонки
     * является сначала уменьшение разрешения для тратящего до 0, а затем установка
     * желаемого значения:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Инициирует событие {Approval}.
     */
    function approve(address spender, uint256 amount) external returns (bool);
```

Функция `approve` создает разрешение. Обязательно прочтите сообщение о том,
как это можно использовать не по назначению. В Ethereum вы контролируете порядок своих собственных транзакций,
но не можете контролировать порядок, в котором будут выполняться транзакции
других людей, если только вы не отправите свою собственную транзакцию после
того, как увидите, что транзакция другой стороны произошла.

&nbsp;

```solidity
    /**
     * @dev Перемещает токены в размере `amount` от `sender` к `recipient` с использованием
     * механизма разрешений. Затем `amount` вычитается из разрешения
     * вызывающей стороны.
     *
     * Возвращает логическое значение, указывающее, успешно ли выполнена операция.
     *
     * Инициирует событие {Transfer}.
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```

Наконец, `transferFrom` используется тратящим для фактического использования разрешения.

&nbsp;

```solidity

    /**
     * @dev Создается при перемещении `value` токенов с одного аккаунта (`from`) на
     * другой (`to`).
     *
     * Обратите внимание, что `value` может быть равно нулю.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Создается, когда лимит для `spender` от `owner` устанавливается
     * вызовом {approve}. `value` — это новый лимит.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```

Эти события инициируются при изменении состояния контракта ERC-20.

## Сам контракт {#the-actual-contract}

Это фактический контракт, реализующий стандарт ERC-20,
[взятый отсюда](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol).
Он не предназначен для использования «как есть», но вы можете
[наследоваться](https://www.tutorialspoint.com/solidity/solidity_inheritance.htm) от него, чтобы расширить его до чего-то пригодного для использования.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;
```

&nbsp;

### Инструкции импорта {#import-statements}

Помимо определений интерфейса выше, определение контракта импортирует два других файла:

```solidity

import "../../GSN/Context.sol";
import "./IERC20.sol";
import "../../math/SafeMath.sol";
```

- `GSN/Context.sol` — это определения, необходимые для использования [OpenGSN](https://www.opengsn.org/), системы, которая позволяет пользователям без
  ether использовать блокчейн. Обратите внимание, что это старая версия, если вы хотите интегрироваться с OpenGSN,
  [используйте это руководство](https://docs.opengsn.org/javascript-client/tutorial.html).
- [Библиотека SafeMath](https://ethereumdev.io/using-safe-math-library-to-prevent-from-overflows/), которая предотвращает
  арифметические переполнения/недополнения для версий Solidity **&lt;0.8.0**. В Solidity ≥0.8.0 арифметические операции автоматически
  отменяются при переполнении/недополнении, что делает SafeMath ненужной. Этот контракт использует SafeMath для обратной совместимости со
  старыми версиями компилятора.

&nbsp;

Этот комментарий объясняет назначение контракта.

```solidity
/**
 * @dev Реализация интерфейса {IERC20}.
 *
 * Эта реализация не зависит от способа создания токенов. Это означает,
 * что механизм предоставления должен быть добавлен в производный контракт с использованием {_mint}.
 * Общий механизм см. в {ERC20PresetMinterPauser}.
 *
 * СОВЕТ: для подробного описания см. наше руководство
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[Как
 * реализовать механизмы предоставления].
 *
 * Мы следовали общим рекомендациям OpenZeppelin: функции отменяются вместо
 * возврата `false` при сбое. Такое поведение, тем не менее, является общепринятым
 * и не противоречит ожиданиям приложений ERC20.
 *
 * Кроме того, при вызовах {transferFrom} инициируется событие {Approval}.
 * Это позволяет приложениям восстанавливать разрешение для всех аккаунтов, просто
 * прослушивая указанные события. Другие реализации EIP могут не инициировать
 * эти события, поскольку это не требуется спецификацией.
 *
 * Наконец, были добавлены нестандартные функции {decreaseAllowance} и {increaseAllowance}
 * для смягчения известных проблем, связанных с установкой
 * разрешений. См. {IERC20-approve}.
 */

```

### Определение контракта {#contract-definition}

```solidity
contract ERC20 is Context, IERC20 {
```

Эта строка определяет наследование, в данном случае от `IERC20` выше и `Context` для OpenGSN.

&nbsp;

```solidity

    using SafeMath for uint256;

```

Эта строка присоединяет библиотеку `SafeMath` к типу `uint256`. Вы можете найти эту библиотеку
[здесь](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol).

### Определения переменных {#variable-definitions}

Эти определения определяют переменные состояния контракта. Эти переменные объявлены `private`, но
это означает только то, что другие контракты в блокчейне не могут их читать. _В блокчейне нет
секретов_, программное обеспечение на каждом узле имеет состояние каждого контракта
в каждом блоке. По соглашению переменные состояния именуются `_<что-то>`.

Первые две переменные — это [сопоставления (mappings)](https://www.tutorialspoint.com/solidity/solidity_mappings.htm),
что означает, что они ведут себя примерно так же, как [ассоциативные массивы](https://wikipedia.org/wiki/Associative_array),
за исключением того, что ключи являются числовыми значениями. Хранилище выделяется только для записей, которые имеют значения, отличные
от значения по умолчанию (ноль).

```solidity
    mapping (address => uint256) private _balances;
```

Первое сопоставление, `_balances`, — это адреса и их соответствующие балансы этого токена. Чтобы получить доступ к
балансу, используйте этот синтаксис: `_balances[<address>]`.

&nbsp;

```solidity
    mapping (address => mapping (address => uint256)) private _allowances;
```

Эта переменная, `_allowances`, хранит разрешения, объясненные ранее. Первый индекс — это владелец
токенов, а второй — контракт с разрешением. Чтобы получить доступ к сумме, которую адрес A может
потратить со счета адреса B, используйте `_allowances[B][A]`.

&nbsp;

```solidity
    uint256 private _totalSupply;
```

Как следует из названия, эта переменная отслеживает общее предложение токенов.

&nbsp;

```solidity
    string private _name;
    string private _symbol;
    uint8 private _decimals;
```

Эти три переменные используются для улучшения читаемости. Первые две говорят сами за себя, а вот `_decimals`
— нет.

С одной стороны, в Ethereum нет переменных с плавающей запятой или дробных переменных. С другой стороны,
людям нравится иметь возможность делить токены. Одна из причин, по которой люди остановились на золоте в качестве валюты, заключалась в том, что
было трудно разменивать деньги, когда кто-то хотел купить утку за часть коровы.

Решение состоит в том, чтобы отслеживать целые числа, но считать не реальный токен, а дробный токен, который
почти ничего не стоит. В случае с ether дробный токен называется wei, и 10^18 wei равны одному
ETH. На момент написания 10 000 000 000 000 wei примерно равны одному центу США или евро.

Приложениям необходимо знать, как отображать баланс токена. Если у пользователя 3 141 000 000 000 000 000 wei, это
3,14 ETH? 31,41 ETH? 3141 ETH? В случае с ether определено 10^18 wei на ETH, но для вашего
токена вы можете выбрать другое значение. Если деление токена не имеет смысла, вы можете использовать
значение `_decimals`, равное нулю. Если вы хотите использовать тот же стандарт, что и для ETH, используйте значение **18**.

### Конструктор {#the-constructor}

```solidity
    /**
     * @dev Устанавливает значения для {name} и {symbol}, инициализирует {decimals} со
     * значением по умолчанию 18.
     *
     * Чтобы выбрать другое значение для {decimals}, используйте {_setupDecimals}.
     *
     * Все три этих значения неизменяемы: их можно установить только один раз во время
     * создания.
     */
    constructor (string memory name_, string memory symbol_) public {
        // В Solidity ≥0.7.0 'public' является неявным и может быть опущен.

        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
```

Конструктор вызывается при первом создании контракта. По соглашению параметры функции именуются `<что-то>_`.

### Функции пользовательского интерфейса {#user-interface-functions}

```solidity
    /**
     * @dev Возвращает имя токена.
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev Возвращает символ токена, обычно более короткую версию
     * имени.
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Возвращает количество десятичных знаков, используемых для получения его представления для пользователя.
     * Например, если `decimals` равно `2`, баланс `505` токенов должен
     * отображаться пользователю как `5,05` (`505 / 10 ** 2`).
     *
     * Токены обычно выбирают значение 18, имитируя отношение между
     * ether и wei. Это значение, которое использует {ERC20}, если не вызывается {_setupDecimals}.
     *
     * ПРИМЕЧАНИЕ: Эта информация используется только для _отображения_: она ни в коем
     * случае не влияет на арифметику контракта, включая
     * {IERC20-balanceOf} и {IERC20-transfer}.
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
```

Эти функции, `name`, `symbol` и `decimals`, помогают пользовательским интерфейсам узнать о вашем контракте, чтобы они могли правильно его отображать.

Возвращаемый тип — `string memory`, что означает возврат строки, которая хранится в памяти. Переменные, такие как
строки, могут храниться в трех местах:

|           | Время жизни   | Доступ к контракту | Стоимость Газа                                                                           |
| --------- | ------------- | ------------------ | ---------------------------------------------------------------------------------------- |
| Память    | Вызов функции | Чтение/запись      | Десятки или сотни (больше для более высоких местоположений)           |
| Calldata  | Вызов функции | Только для чтения  | Не может использоваться как тип возвращаемого значения, только как тип параметра функции |
| Хранилище | До изменения  | Чтение/запись      | Высокая (800 для чтения, 20 тыс. для записи)          |

В данном случае `memory` — лучший выбор.

### Чтение информации о токене {#read-token-information}

Это функции, которые предоставляют информацию о токене: общее предложение или баланс
аккаунта.

```solidity
    /**
     * @dev См. {IERC20-totalSupply}.
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
```

Функция `totalSupply` возвращает общее предложение токенов.

&nbsp;

```solidity
    /**
     * @dev См. {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }
```

Чтение баланса аккаунта. Обратите внимание, что любой может получить баланс аккаунта
любого другого. Нет смысла пытаться скрыть эту информацию, потому что она и так доступна на каждом
узле. _В блокчейне нет секретов._

### Перевод токенов {#transfer-tokens}

```solidity
    /**
     * @dev См. {IERC20-transfer}.
     *
     * Требования:
     *
     * - `recipient` не может быть нулевым адресом.
     * - у вызывающего должен быть баланс не менее `amount`.
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
```

Функция `transfer` вызывается для перевода токенов со счета отправителя на другой. Обратите
внимание, что хотя она и возвращает логическое значение, это значение всегда **true**. Если перевод
не удается, контракт отменяет вызов.

&nbsp;

```solidity
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
```

Функция `_transfer` выполняет фактическую работу. Это приватная функция, которая может быть вызвана только
другими функциями контракта. По соглашению приватные функции именуются `_<что-то>`, так же как и переменные
состояния.

Обычно в Solidity мы используем `msg.sender` для отправителя сообщения. Однако это нарушает работу
[OpenGSN](http://opengsn.org/). Если мы хотим разрешить транзакции без ether с нашим токеном, нам
нужно использовать `_msgSender()`. Она возвращает `msg.sender` для обычных транзакций, но для транзакций без ether
возвращает исходного подписанта, а не контракт, который переслал сообщение.

### Функции разрешений {#allowance-functions}

Это функции, которые реализуют функциональность разрешений: `allowance`, `approve`, `transferFrom`
и `_approve`. Кроме того, реализация OpenZeppelin выходит за рамки базового стандарта и включает некоторые функции, которые улучшают
безопасность: `increaseAllowance` и `decreaseAllowance`.

#### Функция allowance {#allowance}

```solidity
    /**
     * @dev См. {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
```

Функция `allowance` позволяет всем проверять любое разрешение.

#### Функция approve {#approve}

```solidity
    /**
     * @dev См. {IERC20-approve}.
     *
     * Требования:
     *
     * - `spender` не может быть нулевым адресом.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
```

Эта функция вызывается для создания разрешения. Она похожа на функцию `transfer` выше:

- Функция просто вызывает внутреннюю функцию (в данном случае `_approve`), которая выполняет реальную работу.
- Функция либо возвращает `true` (в случае успеха), либо отменяет операцию (в противном случае).

&nbsp;

```solidity
        _approve(_msgSender(), spender, amount);
        return true;
    }
```

Мы используем внутренние функции, чтобы минимизировать количество мест, где происходят изменения состояния. _Любая_ функция, изменяющая
состояние, является потенциальным риском безопасности, который необходимо проверить на безопасность. Таким образом, у нас меньше шансов ошибиться.

#### Функция transferFrom {#transferFrom}

Это функция, которую тратящий вызывает для использования разрешения. Это требует двух операций: перевода потраченной суммы
и уменьшения разрешения на эту сумму.

```solidity
    /**
     * @dev См. {IERC20-transferFrom}.
     *
     * Инициирует событие {Approval}, указывающее на обновленное разрешение. Это не
     * требуется EIP. См. примечание в начале {ERC20}.
     *
     * Требования:
     *
     * - `sender` и `recipient` не могут быть нулевыми адресами.
     * - у `sender` должен быть баланс не менее `amount`.
     * - у вызывающего должно быть разрешение на токены ``sender`` не менее
     * `amount`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual
                                                override returns (bool) {
        _transfer(sender, recipient, amount);
```

&nbsp;

Вызов функции `a.sub(b, "message")` выполняет две вещи. Во-первых, он вычисляет `a-b`, что является новым разрешением.
Во-вторых, он проверяет, что этот результат не является отрицательным. Если он отрицательный, вызов отменяется с предоставленным сообщением. Обратите внимание, что когда вызов отменяется, любая обработка, выполненная ранее во время этого вызова, игнорируется, поэтому нам не нужно
отменять `_transfer`.

```solidity
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount,
             "ERC20: сумма перевода превышает разрешение"));
        return true;
    }
```

#### Дополнения безопасности OpenZeppelin {#openzeppelin-safety-additions}

Опасно устанавливать ненулевое разрешение на другое ненулевое значение,
потому что вы контролируете только порядок своих собственных транзакций, а не чьих-либо еще. Представьте, что у вас
есть два пользователя: Алиса, которая наивна, и Билл, который нечестен. Алиса хочет получить какую-то услугу от
Билла, которая, по ее мнению, стоит пять токенов, поэтому она дает Биллу разрешение на пять токенов.

Затем что-то меняется, и цена Билла повышается до десяти токенов. Алиса, которая все еще хочет получить услугу,
отправляет транзакцию, которая устанавливает разрешение Билла на десять. В тот момент, когда Билл видит эту новую транзакцию
в пуле транзакций, он отправляет транзакцию, которая тратит пять токенов Алисы и имеет гораздо
более высокую цену на Газ, чтобы она была добыта быстрее. Таким образом, Билл может сначала потратить пять токенов, а затем,
когда новое разрешение Алисы будет добыто, потратить еще десять, что в общей сложности составит пятнадцать токенов — больше, чем
Алиса намеревалась разрешить. Этот метод называется
[опережением (фронтраннинг)](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/#front-running)

| Транзакция Алисы                     | Nonce Алисы | Транзакция Билла                                 | Nonce Билла | Разрешение для Билла | Общий доход Билла от Алисы |
| ------------------------------------ | ----------- | ------------------------------------------------ | ----------- | -------------------- | -------------------------- |
| approve(Bill, 5)  | 10          |                                                  |             | 5                    | 0                          |
|                                      |             | transferFrom(Alice, Bill, 5)  | 10,123      | 0                    | 5                          |
| approve(Bill, 10) | 11          |                                                  |             | 10                   | 5                          |
|                                      |             | transferFrom(Alice, Bill, 10) | 10,124      | 0                    | 15                         |

Чтобы избежать этой проблемы, эти две функции (`increaseAllowance` и `decreaseAllowance`) позволяют вам
изменять разрешение на определенную сумму. Так что, если Билл уже потратил пять токенов, он сможет
потратить еще пять. В зависимости от времени это может работать двумя способами, оба из
которых заканчиваются тем, что Билл получает только десять токенов:

A:

| Транзакция Алисы                              | Nonce Алисы | Транзакция Билла                                | Nonce Билла | Разрешение для Билла | Общий доход Билла от Алисы |
| --------------------------------------------- | ----------: | ----------------------------------------------- | ----------: | -------------------: | -------------------------- |
| approve(Bill, 5)           |          10 |                                                 |             |                    5 | 0                          |
|                                               |             | transferFrom(Alice, Bill, 5) |      10,123 |                    0 | 5                          |
| increaseAllowance(Bill, 5) |          11 |                                                 |             |              0+5 = 5 | 5                          |
|                                               |             | transferFrom(Alice, Bill, 5) |      10,124 |                    0 | 10                         |

B:

| Транзакция Алисы                              | Nonce Алисы | Транзакция Билла                                 | Nonce Билла | Разрешение для Билла | Общий доход Билла от Алисы |
| --------------------------------------------- | ----------: | ------------------------------------------------ | ----------: | -------------------: | -------------------------: |
| approve(Bill, 5)           |          10 |                                                  |             |                    5 |                          0 |
| increaseAllowance(Bill, 5) |          11 |                                                  |             |             5+5 = 10 |                          0 |
|                                               |             | transferFrom(Alice, Bill, 10) |      10,124 |                    0 |                         10 |

```solidity
    /**
     * @dev Атомарно увеличивает разрешение, предоставленное `spender` вызывающей стороной.
     *
     * Это альтернатива {approve}, которая может использоваться для смягчения
     * проблем, описанных в {IERC20-approve}.
     *
     * Инициирует событие {Approval}, указывающее на обновленное разрешение.
     *
     * Требования:
     *
     * - `spender` не может быть нулевым адресом.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
```

Функция `a.add(b)` — это безопасное сложение. В маловероятном случае, если `a`+`b`>=`2^256`, оно не переносится
, как обычное сложение.

```solidity

    /**
     * @dev Атомарно уменьшает разрешение, предоставленное `spender` вызывающей стороной.
     *
     * Это альтернатива {approve}, которая может использоваться для смягчения
     * проблем, описанных в {IERC20-approve}.
     *
     * Инициирует событие {Approval}, указывающее на обновленное разрешение.
     *
     * Требования:
     *
     * - `spender` не может быть нулевым адресом.
     * - `spender` должен иметь разрешение для вызывающей стороны не менее
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue,
                "ERC20: уменьшенное разрешение ниже нуля"));
        return true;
    }
```

### Функции, изменяющие информацию о токене {#functions-that-modify-token-information}

Это четыре функции, которые выполняют фактическую работу: `_transfer`, `_mint`, `_burn` и `_approve`.

#### Функция _transfer {#_transfer}

```solidity
    /**
     * @dev Перемещает токены в размере `amount` от `sender` к `recipient`.
     *
     * Эта внутренняя функция эквивалентна {transfer} и может использоваться для
     * реализации, например, автоматических комиссий за токены, механизмов слэшинга и т. д.
     *
     * Инициирует событие {Transfer}.
     *
     * Требования:
     *
     * - `sender` не может быть нулевым адресом.
     * - `recipient` не может быть нулевым адресом.
     * - у `sender` должен быть баланс не менее `amount`.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
```

Эта функция, `_transfer`, переводит токены с одного аккаунта на другой. Она вызывается как
`transfer` (для переводов с собственного счета отправителя), так и `transferFrom` (для использования разрешений
для перевода со счета другого лица).

&nbsp;

```solidity
        require(sender != address(0), "ERC20: перевод с нулевого адреса");
        require(recipient != address(0), "ERC20: перевод на нулевой адрес");
```

Никто на самом деле не владеет нулевым адресом в Ethereum (то есть никто не знает приватный ключ, соответствующий публичный ключ которого
преобразуется в нулевой адрес). Когда люди используют этот адрес, это обычно ошибка программного обеспечения, поэтому мы
прерываем операцию, если нулевой адрес используется как отправитель или получатель.

&nbsp;

```solidity
        _beforeTokenTransfer(sender, recipient, amount);

```

Есть два способа использовать этот контракт:

1. Использовать его как шаблон для своего собственного кода
2. [Наследоваться от него](https://www.bitdegree.org/learn/solidity-inheritance) и переопределять только те функции, которые вам нужно изменить

Второй метод намного лучше, потому что код OpenZeppelin ERC-20 уже был проверен и признан безопасным. Когда вы используете наследование,
ясно, какие функции вы изменяете, и чтобы доверять вашему контракту, людям нужно проверить только эти конкретные функции.

Часто бывает полезно выполнять функцию каждый раз, когда токены переходят из рук в руки. Однако `_transfer` — очень важная функция, и ее можно
написать небезопасно (см. ниже), поэтому лучше ее не переопределять. Решение — `_beforeTokenTransfer`,
[функция-перехватчик (hook)](https://wikipedia.org/wiki/Hooking). Вы можете переопределить эту функцию, и она будет вызываться при каждом переводе.

&nbsp;

```solidity
        _balances[sender] = _balances[sender].sub(amount, "ERC20: сумма перевода превышает баланс");
        _balances[recipient] = _balances[recipient].add(amount);
```

Это строки, которые фактически выполняют перевод. Обратите внимание, что между ними **ничего** нет, и что мы вычитаем
переведенную сумму у отправителя перед тем, как добавить ее получателю. Это важно, потому что если бы посредине был
вызов другого контракта, его можно было бы использовать для обмана этого контракта. Таким образом, перевод
является атомарным, ничего не может произойти в его середине.

&nbsp;

```solidity
        emit Transfer(sender, recipient, amount);
    }
```

Наконец, инициируйте событие `Transfer`. События недоступны для Умных контрактов, но код, работающий вне блокчейна,
может прослушивать события и реагировать на них. Например, кошелек может отслеживать, когда владелец получает больше токенов.

#### Функции _mint и _burn {#_mint-and-_burn}

Эти две функции (`_mint` и `_burn`) изменяют общее предложение токенов.
Они являются внутренними, и в этом контракте нет функции, которая их вызывает,
поэтому они полезны только в том случае, если вы наследуете от контракта и добавляете свою собственную
логику для решения, при каких условиях создавать новые токены или сжигать существующие.

**ПРИМЕЧАНИЕ:** У каждого токена ERC-20 своя бизнес-логика, которая диктует управление токенами.
Например, контракт с фиксированным предложением может вызывать `_mint` только
в конструкторе и никогда не вызывать `_burn`. Контракт, который продает токены,
будет вызывать `_mint` при получении оплаты и, предположительно, вызывать `_burn` в какой-то момент,
чтобы избежать безудержной инфляции.

```solidity
    /** @dev Создает `amount` токенов и назначает их `account`, увеличивая
     * общее предложение.
     *
     * Инициирует событие {Transfer} с `from`, установленным на нулевой адрес.
     *
     * Требования:
     *
     * - `to` не может быть нулевым адресом.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: создание токенов на нулевой адрес");
        _beforeTokenTransfer(address(0), account, amount);
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
```

Не забудьте обновить `_totalSupply` при изменении общего количества токенов.

&nbsp;

```solidity
    /**
     * @dev Уничтожает `amount` токенов с `account`, уменьшая
     * общее предложение.
     *
     * Инициирует событие {Transfer} с `to`, установленным на нулевой адрес.
     *
     * Требования:
     *
     * - `account` не может быть нулевым адресом.
     * - `account` должен иметь не менее `amount` токенов.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: сжигание с нулевого адреса");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: сумма сжигания превышает баланс");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }
```

Функция `_burn` почти идентична `_mint`, за исключением того, что она работает в обратном направлении.

#### Функция _approve {#_approve}

Это функция, которая фактически определяет разрешения. Обратите внимание, что она позволяет владельцу указать
разрешение, превышающее текущий баланс владельца. Это нормально, потому что баланс
проверяется во время перевода, когда он может отличаться от баланса при
создании разрешения.

```solidity
    /**
     * @dev Устанавливает `amount` в качестве разрешения `spender` над токенами `owner`.
     *
     * Эта внутренняя функция эквивалентна `approve` и может использоваться для
     * установки, например, автоматических разрешений для определенных подсистем и т. д.
     *
     * Инициирует событие {Approval}.
     *
     * Требования:
     *
     * - `owner` не может быть нулевым адресом.
     * - `spender` не может быть нулевым адресом.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: разрешение с нулевого адреса");
        require(spender != address(0), "ERC20: разрешение на нулевой адрес");

        _allowances[owner][spender] = amount;
```

&nbsp;

Инициируйте событие `Approval`. В зависимости от того, как написано приложение, контракт тратящего может быть уведомлен о
разрешении либо владельцем, либо сервером, который прослушивает эти события.

```solidity
        emit Approval(owner, spender, amount);
    }

```

### Изменение переменной decimals {#modify-the-decimals-variable}

```solidity


    /**
     * @dev Устанавливает {decimals} на значение, отличное от значения по умолчанию 18.
     *
     * ВНИМАНИЕ: Эту функцию следует вызывать только из конструктора. Большинство
     * приложений, взаимодействующих с контрактами токенов, не ожидают,
     * что {decimals} когда-либо изменится, и могут работать неправильно, если это произойдет.
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }
```

Эта функция изменяет переменную `_decimals`, которая используется для того, чтобы сообщить пользовательским интерфейсам, как интерпретировать сумму.
Вы должны вызывать ее из конструктора. Было бы нечестно вызывать ее в любой последующий момент, и приложения
не предназначены для обработки этого.

### Перехватчики {#hooks}

```solidity

    /**
     * @dev Перехватчик, который вызывается перед любым переводом токенов. Это включает
     * создание и сжигание.
     *
     * Условия вызова:
     *
     * - когда `from` и `to` оба не равны нулю, `amount` токенов ``from``
     * будет переведено `to`.
     * - когда `from` равно нулю, `amount` токенов будет создано для `to`.
     * - когда `to` равно нулю, `amount` токенов ``from`` будет сожжено.
     * - `from` и `to` никогда не равны нулю одновременно.
     *
     * Чтобы узнать больше о перехватчиках, перейдите к xref:ROOT:extending-contracts.adoc#using-hooks[Использование перехватчиков].
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
}
```

Это функция-перехватчик, которая вызывается во время переводов. Здесь она пуста, но если вам нужно,
чтобы она что-то делала, вы просто переопределяете ее.

## Заключение {#conclusion}

Для обзора, вот некоторые из самых важных идей в этом контракте (по моему мнению, ваше может отличаться):

- _В блокчейне не существует секретов_. Любая информация, к которой может получить доступ Умный контракт,
  доступна всему миру.
- Вы можете контролировать порядок своих собственных транзакций, но не то, когда происходят транзакции
  других людей. Именно по этой причине изменение разрешения может быть опасным, потому что оно позволяет
  тратящему потратить сумму обоих разрешений.
- Значения типа `uint256` циклически переносятся. Другими словами, _0-1=2^256-1_. Если это нежелательное
  поведение, вы должны проверять его (или использовать библиотеку SafeMath, которая делает это за вас). Обратите внимание, что это изменилось в
  [Solidity 0.8.0](https://docs.soliditylang.org/en/breaking/080-breaking-changes.html).
- Выполняйте все изменения состояния определенного типа в определенном месте, потому что это облегчает аудит.
  Именно по этой причине у нас есть, например, `_approve`, который вызывается `approve`, `transferFrom`,
  `increaseAllowance` и `decreaseAllowance`
- Изменения состояния должны быть атомарными, без каких-либо других действий в их середине (как вы можете видеть
  в `_transfer`). Это связано с тем, что во время изменения состояния у вас несогласованное состояние. Например,
  между моментом вычета из баланса отправителя и моментом добавления к балансу
  получателя существует меньше токенов, чем должно быть. Этим потенциально можно злоупотребить, если
  между ними есть операции, особенно вызовы другого контракта.

Теперь, когда вы увидели, как написан контракт OpenZeppelin ERC-20, и особенно как он
сделан более безопасным, идите и пишите свои собственные безопасные контракты и приложения.

[Больше моих работ смотрите здесь](https://cryptodocguy.pro/).
