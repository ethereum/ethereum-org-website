---
title: Регистрация данных из умных контрактов с помощью событий
description: Введение в события умных контрактов и способы их использования для регистрации данных.
author: "jdourlens"
tags: [ "Умные контракты", "remix", "твердость", "события" ]
skill: intermediate
lang: ru
published: 03-04-2020
source: EthereumDev
sourceUrl: https://ethereumdev.io/logging-data-with-events/
address: "0x19dE91Af973F404EDF5B4c093983a7c6E3EC8ccE"
---

В Solidity [события](/developers/docs/smart-contracts/anatomy/#events-and-logs) — это отправляемые сигналы, которые могут инициировать умные контракты. Децентрализованные приложения или все, что подключено к Ethereum JSON-RPC API, могут прослушивать эти события и действовать соответствующим образом. Событие также можно индексировать, чтобы в дальнейшем можно было осуществлять поиск по истории событий.

## События {#events}

Наиболее распространенным событием в блокчейне Ethereum на момент написания этой статьи является событие Transfer, которое генерируется токенами ERC20, когда кто-то переводит токены.

```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```

Сигнатура события объявляется внутри кода контракта и может быть вызвана с помощью ключевого слова emit. Например, событие transfer регистрирует, кто отправил перевод (_from_), кому (_to_) и сколько токенов было переведено (_value_).

Если мы вернемся к нашему умному контракту Counter и решим регистрировать каждое изменение значения. Поскольку этот контракт не предназначен для развертывания, а служит основой для создания другого контракта путем его расширения, он называется абстрактным контрактом. В случае с нашим примером счетчика это будет выглядеть так:

```solidity
pragma solidity 0.5.17;\n\ncontract Counter {\n\n    event ValueChanged(uint oldValue, uint256 newValue);\n\n    // Приватная переменная типа unsigned int для хранения количества подсчетов\n    uint256 private count = 0;\n\n    // Функция, которая увеличивает наш счетчик\n    function increment() public {\n        count += 1;\n        emit ValueChanged(count - 1, count);\n    }\n\n    // Геттер для получения значения счетчика\n    function getCount() public view returns (uint256) {\n        return count;\n    }\n\n}
```

Обратите внимание:

- **Строка 5**: мы объявляем наше событие и то, что оно содержит: старое и новое значение.

- **Строка 13**: когда мы увеличиваем нашу переменную count, мы генерируем событие.

Если мы сейчас развернем контракт и вызовем функцию increment, мы увидим, что Remix автоматически отобразит его, если вы нажмете на новую транзакцию в массиве с именем logs.

![Снимок экрана Remix](./remix-screenshot.png)

Логи очень полезны для отладки ваших умных контрактов, но они также важны, если вы создаете приложения, используемые разными людьми. Они облегчают аналитику для отслеживания и понимания того, как используется ваш умный контракт. Логи, сгенерированные транзакциями, отображаются в популярных инструментах изучения блоков, и вы также можете, например, использовать их для создания офф-чейн скриптов для прослушивания определенных событий и принятия мер при их возникновении.
