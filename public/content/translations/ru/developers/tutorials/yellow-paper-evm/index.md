---
title: "Понимание спецификаций EVM Желтой книги"
description: "Понимание той части Желтой книги (официальной спецификации Ethereum), которая объясняет виртуальную машину Ethereum (EVM)."
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: ru
published: 2022-05-15
---

[Желтая книга](https://ethereum.github.io/yellowpaper/paper.pdf) — это официальная спецификация Ethereum. За исключением поправок, внесенных в рамках [процесса EIP](/eips/), она содержит точное описание того, как все работает. Она написана в виде математического документа, который включает в себя терминологию, незнакомую программистам. В этой статье вы узнаете, как ее читать и, как следствие, другие связанные с ней математические документы.

## Какая Желтая книга? {#which-yellow-paper}

Как и почти все остальное в Ethereum, Желтая книга со временем развивается. Чтобы иметь возможность ссылаться на конкретную версию, я загрузил [текущую версию на момент написания статьи](yellow-paper-berlin.pdf). Номера разделов, страниц и уравнений, которые я использую, будут относиться к этой версии. Рекомендуется открыть ее в другом окне во время чтения этого документа.

### Почему EVM? {#why-the-evm}

Оригинальная Желтая книга была написана в самом начале разработки Ethereum. В ней описывается первоначальный механизм консенсуса на основе доказательства выполнения работы, который изначально использовался для обеспечения безопасности сети. Однако в сентябре 2022 года Ethereum отказался от доказательства выполнения работы и начал использовать консенсус на основе доказательства доли владения. Это руководство посвящено тем частям Желтой книги, которые определяют виртуальную машину Ethereum. EVM не изменилась после перехода на доказательство доли владения (за исключением возвращаемого значения опкода DIFFICULTY).

## 9. Модель выполнения {#9-execution-model}

Этот раздел (с. 12–14) включает большую часть определения EVM.

Термин _состояние системы_ включает в себя все, что вам нужно знать о системе для ее запуска. В обычном компьютере это означает память, содержимое регистров и т. д.

[Машина Тьюринга](https://en.wikipedia.org/wiki/Turing_machine) — это вычислительная модель. По сути, это упрощенная версия компьютера, для которой доказано, что она обладает той же способностью выполнять вычисления, что и обычный компьютер (все, что может вычислить компьютер, может вычислить и машина Тьюринга, и наоборот). Эта модель облегчает доказательство различных теорем о том, что вычислимо, а что нет.

Термин [«полный по Тьюрингу»](https://en.wikipedia.org/wiki/Turing_completeness) означает компьютер, который может выполнять те же вычисления, что и машина Тьюринга. Машины Тьюринга могут входить в бесконечные циклы, а EVM — нет, потому что у нее закончится газ, поэтому она является лишь квазиполной по Тьюрингу.

## 9.1. Основы {#91-basics}

В этом разделе приведены основы EVM и ее сравнение с другими вычислительными моделями.

[Стековая машина](https://en.wikipedia.org/wiki/Stack_machine) — это компьютер, который хранит промежуточные данные не в регистрах, а в [**стеке**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)). Это предпочтительная архитектура для виртуальных машин, потому что ее легко реализовать, а это означает, что вероятность появления ошибок и уязвимостей безопасности намного меньше. Память в стеке разделена на 256-битные слова. Этот размер был выбран потому, что он удобен для основных криптографических операций Ethereum, таких как хэширование Keccak-256 и вычисления на эллиптических кривых. Максимальный размер стека составляет 1024 элемента (1024 x 256 бит). При выполнении опкодов они обычно получают свои параметры из стека. Существуют опкоды, специально предназначенные для реорганизации элементов в стеке, такие как `POP` (удаляет элемент с вершины стека), `DUP_N` (дублирует N-й элемент в стеке) и т. д.

EVM также имеет энергозависимую область под названием **«память»**, которая используется для хранения данных во время выполнения. Эта память организована в виде 32-байтовых слов. Все ячейки памяти инициализируются нулем. Если вы выполните этот код на [Yul](https://docs.soliditylang.org/en/latest/yul.html), чтобы добавить слово в память, он заполнит 32 байта памяти, дополнив пустое пространство в слове нулями, т. е. создаст одно слово — с нулями в ячейках 0–29, 0x60 в 30-й ячейке и 0xA7 в 31-й.

```yul
mstore(0, 0x60A7)
```

`mstore` — это один из трех опкодов, предоставляемых EVM для взаимодействия с памятью — он загружает слово в память. Два других — это `mstore8`, который загружает один байт в память, и `mload`, который перемещает слово из памяти в стек.

EVM также имеет отдельную энергонезависимую модель **хранилища**, которая поддерживается как часть состояния системы — эта память организована в виде массивов слов (в отличие от адресуемых по словам байтовых массивов в стеке). В этом хранилище контракты хранят постоянные данные — контракт может взаимодействовать только со своим собственным хранилищем. Хранилище организовано в виде сопоставлений «ключ-значение».

Хотя об этом не упоминается в данном разделе Желтой книги, полезно также знать, что существует четвертый тип памяти. **Calldata** — это адресуемая по байтам память только для чтения, используемая для хранения значения, передаваемого с параметром `data` транзакции. В EVM есть специальные опкоды для управления `calldata`. `calldatasize` возвращает размер данных. `calldataload` загружает данные в стек. `calldatacopy` копирует данные в память.

Стандартная [архитектура фон Неймана](https://en.wikipedia.org/wiki/Von_Neumann_architecture) хранит код и данные в одной и той же памяти. EVM не следует этому стандарту по соображениям безопасности — совместное использование энергозависимой памяти позволяет изменять программный код. Вместо этого код сохраняется в хранилище.

Есть только два случая, когда код выполняется из памяти:

- Когда контракт создает другой контракт (с помощью [`CREATE`](https://www.evm.codes/#f0) или [`CREATE2`](https://www.evm.codes/#f5)), код конструктора контракта берется из памяти.
- Во время создания _любого_ контракта код конструктора запускается, а затем возвращает код фактического контракта, также из памяти.

Термин «исключительное выполнение» означает исключение, которое приводит к остановке выполнения текущего контракта.

## 9.2. Обзор комиссий {#92-fees-overview}

В этом разделе объясняется, как рассчитывается плата за газ. Существует три вида затрат:

### Стоимость опкода {#opcode-cost}

Собственная стоимость конкретного опкода. Чтобы получить это значение, найдите группу стоимости опкода в Приложении H (с. 28, под уравнением (327)) и найдите группу стоимости в уравнении (324). Это дает вам функцию стоимости, которая в большинстве случаев использует параметры из Приложения G (с. 27).

Например, опкод [`CALLDATACOPY`](https://www.evm.codes/#37) является членом группы _W<sub>copy</sub>_. Стоимость опкода для этой группы составляет _G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_. Глядя на Приложение G, мы видим, что обе константы равны 3, что дает нам _3+3×⌈μ<sub>s</sub>[2]÷32⌉_.

Нам все еще нужно расшифровать выражение _⌈μ<sub>s</sub>[2]÷32⌉_. Внешняя часть, _⌈ \<value\> ⌉_ — это функция округления вверх, которая для заданного значения возвращает наименьшее целое число, которое не меньше этого значения. Например, _⌈2,5⌉ = ⌈3⌉ = 3_. Внутренняя часть — _μ<sub>s</sub>[2]÷32_. В разделе 3 («Соглашения») на с. 3 указано, что _μ_ — это состояние машины. Состояние машины определено в разделе 9.4.1 на с. 13. Согласно этому разделу, одним из параметров состояния машины является _s_ для стека. Таким образом, _μ<sub>s</sub>[2]_ — это ячейка № 2 в стеке. Глядя на [опкод](https://www.evm.codes/#37), ячейка № 2 в стеке — это размер данных в байтах. Глядя на другие опкоды в группе W<sub>copy</sub>, [`CODECOPY`](https://www.evm.codes/#39) и [`RETURNDATACOPY`](https://www.evm.codes/#3e), у них также есть размер данных в той же ячейке. Таким образом, _⌈μ<sub>s</sub>[2]÷32⌉_ — это количество 32-байтовых слов, необходимых для хранения копируемых данных. В итоге собственная стоимость [`CALLDATACOPY`](https://www.evm.codes/#37) составляет 3 ед. газа плюс 3 ед. за каждое копируемое слово данных.

### Стоимость выполнения {#running-cost}

Стоимость выполнения вызываемого кода.

- В случае [`CREATE`](https://www.evm.codes/#f0) и [`CREATE2`](https://www.evm.codes/#f5) — конструктор нового контракта.
- В случае [`CALL`](https://www.evm.codes/#f1), [`CALLCODE`](https://www.evm.codes/#f2), [`STATICCALL`](https://www.evm.codes/#fa) или [`DELEGATECALL`](https://www.evm.codes/#f4) — контракт, который мы вызываем.

### Стоимость расширения памяти {#expanding-memory-cost}

Стоимость расширения памяти (при необходимости).

В уравнении 324 это значение записывается как _C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_. Снова взглянув на раздел 9.4.1, мы видим, что _μ<sub>i</sub>_ — это количество слов в памяти. Таким образом, _μ<sub>i</sub>_ — это количество слов в памяти до выполнения опкода, а _μ<sub>i</sub>'_ — количество слов в памяти после выполнения опкода.

Функция _C<sub>mem</sub>_ определена в уравнении 326: _C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_. _⌊x⌋_ — это функция округления вниз, которая для заданного значения возвращает наибольшее целое число, которое не больше этого значения. Например, _⌊2,5⌋ = ⌊2⌋ = 2._ Когда _a < √512_, _a<sup>2</sup> < 512_ и результат функции округления вниз равен нулю. Таким образом, для первых 22 слов (704 байт) стоимость растет линейно с количеством требуемых слов памяти. За этой точкой _⌊a<sup>2</sup> ÷ 512⌋_ становится положительным. Когда требуемый объем памяти достаточно велик, стоимость газа пропорциональна квадрату объема памяти.

**Примечание**: эти факторы влияют только на _собственную_ стоимость газа — они не учитывают рынок комиссий или вознаграждения валидаторам, которые определяют, сколько должен заплатить конечный пользователь. Это лишь «сырая» стоимость выполнения определенной операции в EVM.

[Подробнее о газе](/developers/docs/gas/).

## 9.3. Среда выполнения {#93-execution-env}

Среда выполнения — это кортеж _I_, который включает информацию, не являющуюся частью состояния блокчейна или EVM.

| Параметр        | Опкод для доступа к данным                                                                                        | Код на Solidity для доступа к данным                                       |
| --------------- | ----------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                                            | `address(this)`                                                            |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                                             | `tx.origin`                                                                |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                                           | `tx.gasprice`                                                              |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35) и др.                                                 | `msg.data`                                                                 |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                                             | `msg.sender`                                                               |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                                          | `уточнить сумму`                                                           |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                                           | `address(this).code`                                                       |
| _I<sub>H</sub>_ | Поля заголовка блока, такие как [`NUMBER`](https://www.evm.codes/#43) и [`DIFFICULTY`](https://www.evm.codes/#44) | `block.number`, `block.difficulty` и т. д. |
| _I<sub>e</sub>_ | Глубина стека вызовов для вызовов между контрактами (включая создание контрактов)              |                                                                            |
| _I<sub>w</sub>_ | Разрешено ли EVM изменять состояние, или она работает статически                                                  |                                                                            |

Для понимания остальной части раздела 9 необходимо еще несколько параметров:

| Параметр | Определено в разделе                                           | Значение                                                                                                                                                                                                                                                    |
| -------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _σ_      | 2 (с. 2, уравнение 1)       | Состояние блокчейна                                                                                                                                                                                                                                         |
| _g_      | 9.3 (с. 13) | Оставшийся газ                                                                                                                                                                                                                                              |
| _A_      | 6.1 (с. 8)  | Накопленное подсостояние (изменения, запланированные на момент завершения транзакции)                                                                                                                                                    |
| _o_      | 9.3 (с. 13) | Вывод — возвращаемый результат в случае внутренней транзакции (когда один контракт вызывает другой) и вызовов функций просмотра (когда вы просто запрашиваете информацию, поэтому нет необходимости ждать транзакции) |

## 9.4. Обзор выполнения {#94-execution-overview}

Теперь, когда мы рассмотрели все предварительные сведения, мы можем наконец-то приступить к изучению того, как работает EVM.

Уравнения 137–142 дают нам начальные условия для запуска EVM:

| Символ           | Начальное значение                                                               | Значение                                                                                                                                                                                                                                                                                                                                       |
| ---------------- | -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | Оставшийся газ                                                                                                                                                                                                                                                                                                                                 |
| _μ<sub>pc</sub>_ | _0_                                                                              | Счетчик команд, адрес следующей инструкции для выполнения                                                                                                                                                                                                                                                                                      |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | Память, инициализированная нулями                                                                                                                                                                                                                                                                                                              |
| _μ<sub>i</sub>_  | _0_                                                                              | Самая высокая используемая ячейка памяти                                                                                                                                                                                                                                                                                                       |
| _μ<sub>s</sub>_  | _()_                                                          | Стек, изначально пустой                                                                                                                                                                                                                                                                                                                        |
| _μ<sub>o</sub>_  | _∅_                                                                              | Выходные данные, пустое множество до тех пор, пока мы не остановимся либо с возвращаемыми данными ([`RETURN`](https://www.evm.codes/#f3) или [`REVERT`](https://www.evm.codes/#fd)), либо без них ([`STOP`](https://www.evm.codes/#00) или [`SELFDESTRUCT`](https://www.evm.codes/#ff)). |

Уравнение 143 говорит нам, что в каждый момент времени во время выполнения есть четыре возможных условия и что с ними делать:

1. `Z(σ,μ,A,I)`. Z представляет функцию, которая проверяет, создает ли операция недопустимый переход состояния (см. [исключительная остановка](#942-exceptional-halting)). Если ее значение равно True, новое состояние идентично старому (за исключением того, что сжигается газ), поскольку изменения не были реализованы.
2. Если выполняемый опкод — [`REVERT`](https://www.evm.codes/#fd), новое состояние совпадает со старым, при этом теряется некоторое количество газа.
3. Если последовательность операций завершена, о чем свидетельствует [`RETURN`](https://www.evm.codes/#f3)), состояние обновляется до нового.
4. Если мы не находимся в одном из конечных условий 1-3, продолжаем выполнение.

## 9.4.1. Состояние машины {#941-machine-state}

В этом разделе более подробно объясняется состояние машины. Здесь указано, что _w_ — это текущий опкод. Если _μ<sub>pc</sub>_ меньше _||I<sub>b</sub>||_, длины кода, то этот байт (_I<sub>b</sub>[μ<sub>pc</sub>]_) является опкодом. В противном случае опкод определяется как [`STOP`](https://www.evm.codes/#00).

Поскольку это [стековая машина](https://en.wikipedia.org/wiki/Stack_machine), нам необходимо отслеживать количество элементов, извлеченных (_δ_) и помещенных (_α_) каждым опкодом.

## 9.4.2. Исключительная остановка {#942-exceptional-halt}

В этом разделе определяется функция _Z_, которая указывает, когда происходит нештатное завершение. Это [логическая](https://ru.wikipedia.org/wiki/Логический_тип) функция, поэтому она использует [_∨_ для логического «или»](https://ru.wikipedia.org/wiki/Дизъюнкция) и [_∧_ для логического «и»](https://ru.wikipedia.org/wiki/Конъюнкция).

Исключительная остановка происходит, если выполняется любое из этих условий:

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  Как мы видели в разделе 9.2, _C_ — это функция, которая определяет стоимость газа. Недостаточно газа для покрытия следующего опкода.

- **_δ<sub>w</sub>=∅_**
  Если количество элементов, извлеченных для опкода, не определено, то сам опкод не определен.

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  Нехватка элементов в стеке; в стеке недостаточно элементов для текущего опкода.

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  Опкод — [`JUMP`](https://www.evm.codes/#56), а адрес не является [`JUMPDEST`](https://www.evm.codes/#5b). Переходы действительны _только_ тогда, когда место назначения — [`JUMPDEST`](https://www.evm.codes/#5b).

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  Опкод — [`JUMPI`](https://www.evm.codes/#57), условие истинно (не равно нулю), поэтому переход должен произойти, а адрес не является [`JUMPDEST`](https://www.evm.codes/#5b). Переходы действительны _только_ тогда, когда место назначения — [`JUMPDEST`](https://www.evm.codes/#5b).

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  Опкод — [`RETURNDATACOPY`](https://www.evm.codes/#3e). В этом опкоде элемент стека _μ<sub>s</sub>[1]_ — это смещение для чтения из буфера возвращаемых данных, а элемент стека _μ<sub>s</sub>[2]_ — это длина данных. Это условие возникает, когда вы пытаетесь читать за пределами буфера возвращаемых данных. Обратите внимание, что для calldata или для самого кода подобного условия нет. Когда вы пытаетесь читать за пределами этих буферов, вы просто получаете нули.

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  Переполнение стека. Если выполнение опкода приведет к тому, что стек превысит 1024 элемента, выполнение прерывается.

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  Работаем ли мы статически ([¬ — это отрицание](https://ru.wikipedia.org/wiki/Отрицание), а _I<sub>w</sub>_ — истина, когда нам разрешено изменять состояние блокчейна)? Если да, и мы пытаемся выполнить операцию, изменяющую состояние, этого не произойдет.

  Функция _W(w,μ)_ определяется далее в уравнении 150. _W(w,μ)_ истинно, если выполняется одно из этих условий:

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    Эти опкоды изменяют состояние либо путем создания нового контракта, сохранения значения, либо уничтожения текущего контракта.

  - **_LOG0≤w ∧ w≤LOG4_**
    Если нас вызывают статически, мы не можем создавать записи в журнале.
    Опкоды журнала находятся в диапазоне между [`LOG0` (A0)](https://www.evm.codes/#a0) и [`LOG4` (A4)](https://www.evm.codes/#a4).
    Число после опкода журнала указывает, сколько тем содержит запись журнала.

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    Вы можете вызвать другой контракт, будучи статичным, но в этом случае вы не можете передать ему ETH.

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  Вы не можете запустить [`SSTORE`](https://www.evm.codes/#55), если у вас нет больше G<sub>callstipend</sub> (определено как 2300 в Приложении G) газа.

## 9.4.3. Проверка действительности адреса назначения перехода {#943-jump-dest-valid}

Здесь мы формально определяем, что такое опкоды [`JUMPDEST`](https://www.evm.codes/#5b). Мы не можем просто искать байтовое значение 0x5B, потому что оно может находиться внутри PUSH (и, следовательно, быть данными, а не опкодом).

В уравнении (153) мы определяем функцию _N(i,w)_. Первый параметр, _i_, — это расположение опкода. Второй, _w_, — это сам опкод. Если _w∈[PUSH1, PUSH32]_, это означает, что опкод является PUSH (квадратные скобки определяют диапазон, включающий конечные точки). В этом случае следующий опкод находится в _i+2+(w−PUSH1)_. Для [`PUSH1`](https://www.evm.codes/#60) нам нужно продвинуться на два байта (сам PUSH и однобайтовое значение), для [`PUSH2`](https://www.evm.codes/#61) — на три байта, потому что это двухбайтовое значение, и т. д. Все остальные опкоды EVM имеют длину всего один байт, поэтому во всех остальных случаях _N(i,w)=i+1_.

Эта функция используется в уравнении (152) для определения _D<sub>J</sub>(c,i)_, которое является [множеством](https://ru.wikipedia.org/wiki/Множество) всех допустимых адресов назначения переходов в коде _c_, начиная с расположения опкода _i_. Эта функция определяется рекурсивно. Если _i≥||c||_, это означает, что мы находимся в конце кода или после него. Мы больше не найдем адресов назначения переходов, поэтому просто вернем пустое множество.

Во всех остальных случаях мы смотрим на остальную часть кода, переходя к следующему опкоду и получая множество, начинающееся с него. _c[i]_ — это текущий опкод, поэтому _N(i,c[i])_ — это расположение следующего опкода. Следовательно, _D<sub>J</sub>(c,N(i,c[i]))_ — это множество допустимых адресов назначения переходов, которое начинается со следующего опкода. Если текущий опкод не является `JUMPDEST`, просто верните это множество. Если это `JUMPDEST`, включите его в результирующее множество и верните его.

## 9.4.4. Нормальная остановка {#944-normal-halt}

Функция остановки _H_ может возвращать три типа значений.

- Если мы не находимся в опкоде остановки, возвращаем _∅_, пустое множество. По соглашению, это значение интерпретируется как логическое «ложь».
- Если у нас есть опкод остановки, который не производит вывода (либо [`STOP`](https://www.evm.codes/#00), либо [`SELFDESTRUCT`](https://www.evm.codes/#ff)), возвращаем последовательность байтов нулевого размера в качестве возвращаемого значения. Обратите внимание, что это сильно отличается от пустого множества. Это значение означает, что EVM действительно остановилась, просто нет возвращаемых данных для чтения.
- Если у нас есть опкод остановки, который производит вывод (либо [`RETURN`](https://www.evm.codes/#f3), либо [`REVERT`](https://www.evm.codes/#fd)), возвращаем последовательность байтов, указанную этим опкодом. Эта последовательность берется из памяти, значение на вершине стека (_μ<sub>s</sub>[0]_) — это первый байт, а значение после него (_μ<sub>s</sub>[1]_) — это длина.

## H.2. Набор инструкций {#h2-instruction-set}

Прежде чем мы перейдем к последнему подразделу EVM, 9.5, давайте посмотрим на сами инструкции. Они определены в Приложении H.2, которое начинается на с. 29. Все, что не указано как изменяющееся с этим конкретным опкодом, должно оставаться неизменным. Переменные, которые изменяются, обозначаются как \<что-то\>′.

Например, давайте посмотрим на опкод [`ADD`](https://www.evm.codes/#01).

| Значение | Мнемоника  | δ | α | Описание                                                                                                                                                                                                              |
| -------: | ---------- | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     0x01 | Добавление | 2 | 1 | Операция сложения.                                                                                                                                                                                    |
|          |            |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_ — это количество значений, которые мы извлекаем из стека. В данном случае два, потому что мы складываем два верхних значения.

_α_ — это количество значений, которые мы помещаем обратно. В данном случае одно, сумма.

Таким образом, новая вершина стека (_μ′<sub>s</sub>[0]_) — это сумма старой вершины стека (_μ<sub>s</sub>[0]_) и старого значения под ней (_μ<sub>s</sub>[1]_).

Вместо того чтобы перечислять все опкоды в виде скучного списка, в этой статье объясняются только те опкоды, которые вводят что-то новое.

| Значение | Мнемоника | δ | α | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| -------: | --------- | - | - | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     0x20 | KECCAK256 | 2 | 1 | Вычислить хэш Keccak-256.                                                                                                                                                                                                                                                                                                                                                                                                                            |
|          |           |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] . . . (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|          |           |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                                                     |

Это первый опкод, который обращается к памяти (в данном случае, только для чтения). Однако он может выйти за текущие пределы памяти, поэтому нам нужно обновить _μ<sub>i</sub>._ Мы делаем это с помощью функции _M_, определенной в уравнении 328 на с. 29.

| Значение | Мнемоника | δ | α | Описание                                            |
| -------: | --------- | - | - | --------------------------------------------------- |
|     0x31 | BALANCE   | 1 | 1 | Получить баланс данного аккаунта.   |
|          |           |   |   | ... |

Адрес, баланс которого нам нужно найти, — _μ<sub>s</sub>[0] mod 2<sup>160</sup>_. На вершине стека находится адрес, но поскольку адреса состоят всего из 160 бит, мы вычисляем значение [по модулю](https://ru.wikipedia.org/wiki/Сравнение_по_модулю) 2<sup>160</sup>.

Если _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_, это означает, что об этом адресе есть информация. В этом случае _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_ — это баланс для этого адреса. Если _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_, это означает, что этот адрес не инициализирован, и баланс равен нулю. Вы можете увидеть список полей информации об аккаунте в разделе 4.1 на с. 4.

Второе уравнение, _A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_, связано с разницей в стоимости доступа к «теплому» хранилищу (хранилищу, к которому недавно обращались и которое, вероятно, кэшировано) и «холодному» хранилищу (хранилищу, к которому не обращались и которое, вероятно, находится в более медленном хранилище, извлечение из которого дороже). _A<sub>a</sub>_ — это список адресов, к которым ранее обращалась транзакция, и поэтому доступ к которым должен быть дешевле, как определено в разделе 6.1 на с. 8. Вы можете прочитать больше по этой теме в [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929).

| Значение | Мнемоника | δ  | α  | Описание                                                                                                                                        |
| -------: | --------- | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
|     0x8F | DUP16     | 16 | 17 | Дублировать 16-й элемент стека.                                                                                                 |
|          |           |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

Обратите внимание, что для использования любого элемента стека нам нужно его извлечь, что означает, что нам также нужно извлечь все элементы стека над ним. В случае [`DUP<n>`](https://www.evm.codes/#8f) и [`SWAP<n>`](https://www.evm.codes/#9f) это означает необходимость извлечения, а затем помещения до шестнадцати значений.

## 9.5. Цикл выполнения {#95-exec-cycle}

Теперь, когда у нас есть все части, мы можем наконец понять, как документирован цикл выполнения EVM.

Уравнение (155) гласит, что при заданном состоянии:

- _σ_ (глобальное состояние блокчейна)
- _μ_ (состояние EVM)
- _A_ (подсостояние, изменения, которые должны произойти по завершении транзакции)
- _I_ (среда выполнения)

Новое состояние — _(σ', μ', A', I')_.

Уравнения (156)-(158) определяют стек и его изменение из-за опкода (_μ<sub>s</sub>_). Уравнение (159) — это изменение газа (_μ<sub>g</sub>_). Уравнение (160) — это изменение счетчика команд (_μ<sub>pc</sub>_). Наконец, уравнения (161)-(164) указывают, что остальные параметры остаются неизменными, если они не изменены явно опкодом.

Таким образом, EVM полностью определена.

## Заключение {#conclusion}

Математическая нотация точна и позволила Желтой книге определить каждую деталь Ethereum. Однако у нее есть и некоторые недостатки:

- Она может быть понята только людьми, что означает, что [тесты на соответствие](https://github.com/ethereum/tests) должны писаться вручную.
- Программисты понимают компьютерный код.
  Они могут понимать или не понимать математическую нотацию.

Возможно, по этим причинам более новые [спецификации уровня консенсуса](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md) написаны на Python. Существуют [спецификации уровня выполнения на Python](https://ethereum.github.io/execution-specs), но они неполные. До тех пор, пока вся Желтая книга не будет также переведена на Python или подобный язык, Желтая книга будет продолжать использоваться, и умение ее читать будет полезным.
