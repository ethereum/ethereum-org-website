---
title: "ERC-20 с мерами предосторожности"
description: "Как помочь людям избежать глупых ошибок"
author: "Ори Померанц"
lang: ru
tags: [ "erc-20" ]
skill: beginner
published: 2022-08-15
---

## Введение {#introduction}

Одно из замечательных качеств Ethereum — это отсутствие центрального органа, который мог бы изменять или отменять ваши транзакции. Одна из больших проблем Ethereum заключается в том, что нет центрального органа, уполномоченного исправлять ошибки пользователей или отменять незаконные транзакции. В этой статье вы узнаете о некоторых распространенных ошибках, которые пользователи совершают с токенами [ERC-20](/developers/docs/standards/tokens/erc-20/), а также о том, как создавать контракты ERC-20, которые помогают пользователям избежать этих ошибок или которые предоставляют центральному органу некоторые полномочия (например, для замораживания аккаунтов).

Обратите внимание, что, хотя мы будем использовать [контракт токена ERC-20 от OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20), в этой статье он не объясняется в мельчайших подробностях. Эту информацию можно найти [здесь](/developers/tutorials/erc20-annotated-code).

Если вы хотите увидеть полный исходный код:

1. Откройте [Remix IDE](https://remix.ethereum.org/).
2. Нажмите на значок клонирования github (![значок клонирования github](icon-clone.png)).
3. Клонируйте репозиторий github `https://github.com/qbzzt/20220815-erc20-safety-rails`.
4. Откройте **contracts > erc20-safety-rails.sol**.

## Создание контракта ERC-20 {#creating-an-erc-20-contract}

Прежде чем мы сможем добавить функциональность мер предосторожности, нам понадобится контракт ERC-20. В этой статье мы воспользуемся [Мастером контрактов OpenZeppelin](https://docs.openzeppelin.com/contracts/5.x/wizard). Откройте его в другом браузере и следуйте этим инструкциям:

1. Выберите **ERC20**.

2. Введите следующие настройки:

   | Параметр               | Значение         |
   | ---------------------- | ---------------- |
   | Имя                    | SafetyRailsToken |
   | Символ                 | SAFE             |
   | Premint                | 1000             |
   | Функции                | Нет              |
   | Контроль доступа       | Ownable          |
   | Возможность обновления | Нет              |

3. Прокрутите вверх и нажмите **Открыть в Remix** (для Remix) или **Загрузить**, чтобы использовать другую среду. Я буду исходить из того, что вы используете Remix. Если вы используете что-то другое, просто внесите соответствующие изменения.

4. Теперь у нас есть полнофункциональный контракт ERC-20. Вы можете развернуть `.deps` > `npm`, чтобы увидеть импортированный код.

5. Скомпилируйте, разверните и поработайте с контрактом, чтобы убедиться, что он функционирует как контракт ERC-20. Если вам нужно научиться пользоваться Remix, [воспользуйтесь этим руководством](https://remix.ethereum.org/?#activate=udapp,solidity,LearnEth).

## Распространенные ошибки {#common-mistakes}

### Ошибки {#the-mistakes}

Иногда пользователи отправляют токены на неверный адрес. Хотя мы не можем читать их мысли, чтобы знать, что они хотели сделать, есть два типа ошибок, которые случаются часто и легко обнаруживаются:

1. Отправка токенов на собственный адрес контракта. Например, [токену OP от Optimism](https://optimism.mirror.xyz/qvd0WfuLKnePm1Gxb9dpGchPf5uDz5NSMEFdgirDS4c) удалось накопить [более 120 000](https://optimism.blockscout.com/address/0x4200000000000000000000000000000000000042) токенов OP менее чем за два месяца. Это представляет собой значительное состояние, которое, по-видимому, люди просто потеряли.

2. Отправка токенов на пустой адрес, который не соответствует [внешнему аккаунту](/developers/docs/accounts/#externally-owned-accounts-and-key-pairs) или [умному контракту](/developers/docs/smart-contracts). Хотя у меня нет статистики о том, как часто это происходит, [один инцидент мог стоить 20 000 000 токенов](https://gov.optimism.io/t/message-to-optimism-community-from-wintermute/2595).

### Предотвращение переводов {#preventing-transfers}

Контракт ERC-20 от OpenZeppelin включает [перехватчик (hook) `_beforeTokenTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L364-L368), который вызывается перед передачей токена. По умолчанию этот перехватчик ничего не делает, но мы можем «повесить» на него собственную функциональность, например, проверки, которые отменяют транзакцию в случае возникновения проблемы.

Чтобы использовать перехватчик, добавьте эту функцию после конструктора:

```solidity
    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal virtual
        override(ERC20)
    {
        super._beforeTokenTransfer(from, to, amount);
    }
```

Некоторые части этой функции могут быть новыми, если вы не очень хорошо знакомы с Solidity:

```solidity
        internal virtual
```

Ключевое слово `virtual` означает, что так же, как мы унаследовали функциональность от `ERC20` и переопределили эту функцию, другие контракты могут наследоваться от нас и переопределять эту функцию.

```solidity
        override(ERC20)
```

Мы должны явно указать, что мы [переопределяем](https://docs.soliditylang.org/en/v0.8.15/contracts.html#function-overriding) определение `_beforeTokenTransfer` для токена ERC20. В целом, с точки зрения безопасности, явные определения намного лучше, чем неявные — вы не можете забыть, что что-то сделали, если это прямо перед вами. Это также причина, по которой нам нужно указать, чей `_beforeTokenTransfer` суперкласса мы переопределяем.

```solidity
        super._beforeTokenTransfer(from, to, amount);
```

Эта строка вызывает функцию `_beforeTokenTransfer` контракта или контрактов, от которых мы унаследовали и в которых она есть. В данном случае это только `ERC20`, у `Ownable` этого перехватчика нет. Несмотря на то, что в настоящее время `ERC20._beforeTokenTransfer` ничего не делает, мы вызываем его на случай, если в будущем будет добавлена функциональность (и мы затем решим переразвернуть контракт, потому что контракты не меняются после развертывания).

### Программирование требований {#coding-the-requirements}

Мы хотим добавить в функцию следующие требования:

- Адрес `to` не может быть равен `address(this)`, то есть адресу самого контракта ERC-20.
- Адрес `to` не может быть пустым, он должен быть либо:
  - Внешний аккаунт (EOA). Мы не можем напрямую проверить, является ли адрес EOA, но мы можем проверить баланс ETH по этому адресу. EOA почти всегда имеют баланс, даже если они больше не используются — трудно очистить их до последнего wei.
  - Умный контракт. Проверить, является ли адрес умным контрактом, немного сложнее. Существует код операции (opcode), который проверяет длину внешнего кода, он называется [`EXTCODESIZE`](https://www.evm.codes/#3b), но он недоступен напрямую в Solidity. Для этого мы должны использовать [Yul](https://docs.soliditylang.org/en/v0.8.15/yul.html), который является ассемблером EVM. Есть и другие значения, которые мы могли бы использовать из Solidity ([`<address>.code` и `<address>.codehash`](https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#members-of-address-types)), но они стоят дороже.

Давайте рассмотрим новый код построчно:

```solidity
        require(to != address(this), "Нельзя отправлять токены на адрес контракта");
```

Это первое требование, проверка того, что `to` и `this(address)` — это не одно и то же.

```solidity
        bool isToContract;
        assembly {
           isToContract := gt(extcodesize(to), 0)
        }
```

Вот как мы проверяем, является ли адрес контрактом. Мы не можем получать выходные данные напрямую из Yul, поэтому вместо этого мы определяем переменную для хранения результата (в данном случае `isToContract`). Yul работает так, что каждый код операции (opcode) считается функцией. Итак, сначала мы вызываем [`EXTCODESIZE`](https://www.evm.codes/#3b), чтобы получить размер контракта, а затем используем [`GT`](https://www.evm.codes/#11), чтобы проверить, что он не равен нулю (мы имеем дело с беззнаковыми целыми числами, поэтому, конечно, он не может быть отрицательным). Затем мы записываем результат в `isToContract`.

```solidity
        require(to.balance != 0 || isToContract, "Нельзя отправлять токены на пустой адрес");
```

И, наконец, у нас есть фактическая проверка на пустые адреса.

## Административный доступ {#admin-access}

Иногда полезно иметь администратора, который может исправлять ошибки. Чтобы уменьшить вероятность злоупотреблений, этот администратор может быть [мультиподписным кошельком (multisig)](https://blog.logrocket.com/security-choices-multi-signature-wallets/), чтобы для выполнения действия требовалось согласие нескольких человек. В этой статье мы рассмотрим две административные функции:

1. Замораживание и размораживание аккаунтов. Это может быть полезно, например, когда аккаунт может быть скомпрометирован.
2. Очистка активов.

   Иногда мошенники отправляют поддельные токены на контракт настоящего токена, чтобы завоевать доверие. Например, [смотрите здесь](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe?tab=holders). Настоящий контракт ERC-20 — это [0x4200....0042](https://optimism.blockscout.com/token/0x4200000000000000000000000000000000000042). Мошеннический контракт, который выдает себя за него, — это [0x234....bbe](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe).

   Также возможно, что люди по ошибке отправят настоящие токены ERC-20 на наш контракт, и это еще одна причина, по которой стоит иметь способ их оттуда вывести.

OpenZeppelin предоставляет два механизма для обеспечения административного доступа:

- Контракты [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/access-control#ownership-and-ownable) имеют одного владельца. Функции, имеющие [модификатор](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm) `onlyOwner`, могут вызываться только этим владельцем. Владельцы могут передать право собственности кому-то другому или полностью от него отказаться. Права всех остальных аккаунтов обычно идентичны.
- Контракты [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/access-control#role-based-access-control) имеют [управление доступом на основе ролей (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control).

Для простоты в этой статье мы используем `Ownable`.

### Замораживание и размораживание счетов {#freezing-and-thawing-contracts}

Для замораживания и размораживания счетов требуется несколько изменений:

- [Сопоставление (mapping)](https://www.tutorialspoint.com/solidity/solidity_mappings.htm) адресов с [логическими значениями (booleans)](https://en.wikipedia.org/wiki/Boolean_data_type) для отслеживания замороженных адресов. Все значения изначально равны нулю, что для логических значений интерпретируется как false. Это то, что нам нужно, потому что по умолчанию аккаунты не заморожены.

  ```solidity
      mapping(address => bool) public frozenAccounts;
  ```

- [События (events)](https://www.tutorialspoint.com/solidity/solidity_events.htm), информирующие всех заинтересованных лиц о замораживании или размораживании аккаунта. Технически говоря, события не требуются для этих действий, но они помогают коду вне блокчейна (offchain) прослушивать эти события и знать, что происходит. Считается хорошим тоном, когда умный контракт генерирует их, когда происходит что-то, что может быть важно для кого-то еще.

  События индексируются, поэтому можно будет найти все случаи замораживания или размораживания аккаунта.

  ```solidity
    // Когда аккаунты замораживаются или размораживаются
    event AccountFrozen(address indexed _addr);
    event AccountThawed(address indexed _addr);
  ```

- Функции для замораживания и размораживания аккаунтов. Эти две функции почти идентичны, поэтому мы рассмотрим только функцию заморозки.

  ```solidity
      function freezeAccount(address addr)
        public
        onlyOwner
  ```

  Функции, помеченные как [`public`](https://www.tutorialspoint.com/solidity/solidity_contracts.htm), могут вызываться из других умных контрактов или напрямую через транзакцию.

  ```solidity
    {
        require(!frozenAccounts[addr], "Аккаунт уже заморожен");
        frozenAccounts[addr] = true;
        emit AccountFrozen(addr);
    }  // freezeAccount
  ```

  Если аккаунт уже заморожен, отменить транзакцию. В противном случае заморозьте его и сгенерируйте (`emit`) событие.

- Измените `_beforeTokenTransfer`, чтобы предотвратить перемещение денег с замороженного аккаунта. Обратите внимание, что деньги все еще можно переводить на замороженный аккаунт.

  ```solidity
       require(!frozenAccounts[from], "Аккаунт заморожен");
  ```

### Очистка активов {#asset-cleanup}

Чтобы высвободить токены ERC-20, хранящиеся в этом контракте, нам нужно вызвать функцию в контракте токена, которому они принадлежат, — либо [`transfer`](https://eips.ethereum.org/EIPS/eip-20#transfer), либо [`approve`](https://eips.ethereum.org/EIPS/eip-20#approve). В данном случае нет смысла тратить газ на разрешения (allowances), мы можем просто перевести их напрямую.

```solidity
    function cleanupERC20(
        address erc20,
        address dest
    )
        public
        onlyOwner
    {
        IERC20 token = IERC20(erc20);
```

Это синтаксис для создания объекта для контракта, когда мы получаем адрес. Мы можем это сделать, потому что у нас есть определение для токенов ERC20 как часть исходного кода (см. строку 4), и этот файл включает [определение для IERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol), интерфейс для контракта ERC-20 от OpenZeppelin.

```solidity
        uint balance = token.balanceOf(address(this));
        token.transfer(dest, balance);
    }
```

Это функция очистки, поэтому, предположительно, мы не хотим оставлять никаких токенов. Вместо того чтобы получать баланс от пользователя вручную, мы можем автоматизировать этот процесс.

## Заключение {#conclusion}

Это не идеальное решение — идеального решения для проблемы «пользователь совершил ошибку» не существует. Однако использование подобных проверок может по крайней мере предотвратить некоторые ошибки. Возможность замораживать аккаунты, хотя и является опасной, может быть использована для ограничения ущерба от некоторых взломов, лишая хакера украденных средств.

[Больше моих работ смотрите здесь](https://cryptodocguy.pro/).
