---
title: "Рекомендации по обеспечению безопасности смарт-контрактов"
description: "Список рекомендаций по безопасности, которые следует учитывать при создании вашего децентрализованного приложения"
author: "Trailofbits"
tags: [ "твердость", "смарт-контракты", "безопасность" ]
skill: intermediate
lang: ru
published: 2020-09-06
source: "Создание безопасных контрактов"
sourceUrl: https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/guidelines.md
---

Следуйте этим общим рекомендациям для создания более защищенных смарт-контрактов.

## Руководство по дизайну {#design-guidelines}

Разработку контракта следует обсуждать заранее, ещё до написания кода.

### Документация и спецификации {#documentation-and-specifications}

Документация может быть написана на разных уровнях и должна обновляться в процессе реализации контрактов:

- **Описание системы на простом английском языке**, описывающее, что делают контракты, и любые допущения по кодовой базе.
- **Схемы и архитектурные диаграммы**, включая взаимодействия контрактов и конечный автомат системы. [Принтеры Slither](https://github.com/crytic/slither/wiki/Printer-documentation) могут помочь в создании этих схем.
- **Подробная документация кода**, для Solidity можно использовать [формат Natspec](https://docs.soliditylang.org/en/develop/natspec-format.html).

### Ончейн- и офчейн-вычисления {#onchain-vs-offchain-computation}

- **Старайтесь хранить как можно больше кода вне сети (офчейн).** Ончейн-уровень должен быть небольшим. Предварительно обрабатывайте данные с помощью кода офчейн таким образом, чтобы ончейн-проверка была простой. Вам нужен упорядоченный список? Сортируйте список офчейн, а затем просто проверяйте его порядок ончейн.

### Возможность обновления {#upgradeability}

Мы обсуждали различные решения для обновления в [нашей статье в блоге](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/). Примите осознанное решение о поддержке возможности обновления, прежде чем писать какой-либо код. Это решение повлияет на то, как вы структурируете свой код. В целом мы рекомендуем:

- **Отдавайте предпочтение [миграции контрактов](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) перед возможностью обновления.** Системы миграции имеют многие из тех же преимуществ, что и обновляемые, но лишены их недостатков.
- **Используйте шаблон разделения данных вместо шаблона delegatecallproxy.** Если в вашем проекте есть четкое разделение абстракций, возможность обновления с использованием разделения данных потребует лишь нескольких корректировок. Шаблон delegatecallproxy требует экспертных знаний EVM и очень подвержен ошибкам.
- **Документируйте процедуру миграции/обновления перед развертыванием.** Если вам придется реагировать в стрессовой ситуации без каких-либо инструкций, вы совершите ошибки. Заранее опишите процедуру, которой нужно следовать. Она должна включать:
  - Вызовы, которые инициируют новые контракты
  - Где хранятся ключи и как получить к ним доступ
  - Как проверить развертывание! Разработайте и протестируйте скрипт для запуска после развертывания.

## Руководство по реализации {#implementation-guidelines}

**Стремитесь к простоте.** Всегда используйте самое простое решение, которое соответствует вашей цели. Любой член вашей команды должен быть в состоянии понять ваше решение.

### Композиция функций {#function-composition}

Структура вашей кодовой базы должна облегчать просмотр вашего кода. Избегайте структуры, которая уменьшает возможность рассуждать о ее правильности.

- **Разделяйте логику вашей системы** либо с помощью нескольких контрактов, либо путем группировки схожих функций (например, аутентификация, арифметика и т. д.).
- **Пишите небольшие функции с четкой целью.** Это облегчит проверку и позволит тестировать отдельные компоненты.

### Наследование {#inheritance}

- **Сделайте наследование управляемым.** Наследование следует использовать для разделения логики, однако в вашем проекте следует стремиться к минимизации глубины и ширины дерева наследования.
- **Используйте [принтер наследования Slither](https://github.com/crytic/slither/wiki/Printer-documentation#inheritance-graph) для проверки иерархии контрактов.** Принтер наследования поможет вам проверить размер иерархии.

### События {#events}

- **Записывайте в журнал все важные операции.** События помогут отладить контракт во время разработки и отслеживать его работу после развертывания.

### Избегайте известных подводных камней {#avoid-known-pitfalls}

- **Помните о наиболее распространенных проблемах безопасности.** Существует множество онлайн-ресурсов для изучения распространенных проблем, таких как [Ethernaut CTF](https://ethernaut.openzeppelin.com/), [Capture the Ether](https://capturetheether.com/) или [Not so smart contracts](https://github.com/crytic/not-so-smart-contracts/).
- **Обращайте внимание на разделы с предупреждениями в [документации Solidity](https://docs.soliditylang.org/en/latest/).** Разделы с предупреждениями сообщат вам о неочевидном поведении языка.

### Зависимости {#dependencies}

- **Используйте хорошо протестированные библиотеки.** Импорт кода из хорошо протестированных библиотек снизит вероятность написания кода с ошибками. Если вы хотите написать контракт ERC20, используйте [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20).
- **Используйте менеджер зависимостей; избегайте копирования и вставки кода.** Если вы полагаетесь на внешний источник, вы должны поддерживать его в актуальном состоянии в соответствии с оригинальным источником.

### Тестирование и верификация {#testing-and-verification}

- **Пишите подробные модульные тесты.** Обширный набор тестов имеет решающее значение для создания высококачественного программного обеспечения.
- **Пишите пользовательские проверки и свойства для [Slither](https://github.com/crytic/slither), [Echidna](https://github.com/crytic/echidna) и [Manticore](https://github.com/trailofbits/manticore).** Автоматизированные инструменты помогут обеспечить безопасность вашего контракта. Ознакомьтесь с остальной частью этого руководства, чтобы узнать, как писать эффективные проверки и свойства.
- **Используйте [crytic.io](https://crytic.io/).** Crytic интегрируется с GitHub, предоставляет доступ к частным детекторам Slither и запускает пользовательские проверки свойств от Echidna.

### Solidity {#solidity}

- **Отдавайте предпочтение Solidity 0.5 перед 0.4 и 0.6.** По нашему мнению, Solidity 0.5 является более безопасным и имеет лучшие встроенные практики, чем 0.4. Solidity 0.6 оказался слишком нестабильным для производственного использования и ему нужно время, чтобы «созреть».
- **Используйте стабильный релиз для компиляции; используйте последний релиз для проверки предупреждений.** Убедитесь, что ваш код не имеет зарегистрированных проблем с последней версией компилятора. Однако у Solidity быстрый цикл релизов и есть история ошибок компилятора, поэтому мы не рекомендуем использовать последнюю версию для развертывания (см. [рекомендацию по версии solc от Slither](https://github.com/crytic/slither/wiki/Detector-Documentation#recommendation-33)).
- **Не используйте встроенный ассемблер.** Ассемблер требует экспертных знаний EVM. Не пишите код для EVM, если вы не _освоили_ «желтую книгу».

## Руководство по развертыванию {#deployment-guidelines}

После разработки и развертывания контракта:

- **Отслеживайте свои контракты.** Следите за журналами и будьте готовы отреагировать в случае компрометации контракта или кошелька.
- **Добавьте свою контактную информацию в [blockchain-security-contacts](https://github.com/crytic/blockchain-security-contacts).** Этот список поможет третьим лицам связаться с вами в случае обнаружения уязвимости в системе безопасности.
- **Обезопасьте кошельки привилегированных пользователей.** Следуйте нашим [лучшим практикам](https://blog.trailofbits.com/2018/11/27/10-rules-for-the-secure-use-of-cryptocurrency-hardware-wallets/), если вы храните ключи в аппаратных кошельках.
- **Имейте план реагирования на инциденты.** Учитывайте, что ваши умные контракты могут быть скомпрометированы. Даже если в ваших контрактах нет ошибок, злоумышленник может завладеть ключами владельца контракта.
