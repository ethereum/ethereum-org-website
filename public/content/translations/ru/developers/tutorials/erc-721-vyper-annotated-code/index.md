---
title: "Пошаговый разбор контракта Vyper ERC-721"
description: "Контракт ERC-721 от Ryuya Nakamura и принцип его работы"
author: Ori Pomerantz
lang: ru
tags: [ "vyper", "erc-721", "python" ]
skill: beginner
published: 2021-04-01
---

## Введение {#introduction}

Стандарт [ERC-721](/developers/docs/standards/tokens/erc-721/) используется для владения невзаимозаменяемыми токенами (NFT).
Токены [ERC-20](/developers/docs/standards/tokens/erc-20/) ведут себя как товар, так как между отдельными токенами нет разницы.
В отличие от них, токены ERC-721 предназначены для активов, которые похожи, но не идентичны, например, различные мультяшные
коты или права собственности на различные объекты недвижимости.

В этой статье мы проанализируем [контракт ERC-721 от Ryuya Nakamura](https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC721.vy).
Этот контракт написан на [Vyper](https://vyper.readthedocs.io/en/latest/index.html), языке контрактов, похожем на Python, который разработан таким образом, чтобы
затруднить написание небезопасного кода по сравнению с Solidity.

## Контракт {#contract}

```python
# @dev Реализация стандарта невзаимозаменяемых токенов ERC-721.
# @author Ryuya Nakamura (@nrryuya)
# Изменено из: https://github.com/vyperlang/vyper/blob/de74722bf2d8718cca46902be165f9fe0e3641dd/examples/tokens/ERC721.vy
```

Комментарии в Vyper, как и в Python, начинаются с символа решетки (`#`) и продолжаются до конца строки. Комментарии, которые включают
`@<keyword>`, используются [NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) для создания удобочитаемой
документации.

```python
from vyper.interfaces import ERC721

implements: ERC721
```

Интерфейс ERC-721 встроен в язык Vyper.
[Определение кода можно посмотреть здесь](https://github.com/vyperlang/vyper/blob/master/vyper/builtin_interfaces/ERC721.py).
Определение интерфейса написано на Python, а не на Vyper, потому что интерфейсы используются не только в
блокчейне, но и при отправке транзакции в блокчейн с внешнего клиента, который может быть написан на
Python.

Первая строка импортирует интерфейс, а вторая указывает, что мы реализуем его здесь.

### Интерфейс ERC721Receiver {#receiver-interface}

```python
# Интерфейс для контракта, вызываемого safeTransferFrom()
interface ERC721Receiver:
    def onERC721Received(
```

ERC-721 поддерживает два типа перевода:

- `transferFrom`, который позволяет отправителю указать любой адрес назначения и возлагает ответственность
  за перевод на отправителя. Это означает, что вы можете перевести средства на недействительный адрес, и в этом случае
  NFT будет безвозвратно утерян.
- `safeTransferFrom`, который проверяет, является ли адрес назначения контрактом. Если это так, контракт ERC-721
  спрашивает у принимающего контракта, хочет ли он получить NFT.

Чтобы отвечать на запросы `safeTransferFrom`, принимающий контракт должен реализовывать `ERC721Receiver`.

```python
            _operator: address,
            _from: address,
```

Адрес `_from` — это текущий владелец токена. Адрес `_operator` — это адрес, который
запросил перевод (эти два адреса могут не совпадать из-за разрешений).

```python
            _tokenId: uint256,
```

Идентификаторы токенов ERC-721 имеют размер 256 бит. Обычно они создаются путем хэширования описания того, что
представляет собой токен.

```python
            _data: Bytes[1024]
```

Запрос может содержать до 1024 байт пользовательских данных.

```python
        ) -> bytes32: view
```

Чтобы предотвратить случаи, когда контракт случайно принимает перевод, возвращаемое значение является не логическим,
а 256-битным значением с определенным содержанием.

Эта функция является `view`, что означает, что она может читать состояние блокчейна, но не изменять его.

### События {#events}

[События](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e)
создаются для информирования пользователей и серверов за пределами блокчейна о событиях. Обратите внимание, что содержимое событий
недоступно контрактам в блокчейне.

```python
# @dev Создается, когда право собственности на любой NFT изменяется любым механизмом. Это событие создается при создании NFT (`from` == 0) и их уничтожении (`to` == 0). Исключение: во время создания контракта любое
#      количество NFT может быть создано и назначено без создания события Transfer. Во время любого
#      перевода одобренный адрес для этого NFT (если он есть) сбрасывается.
# @param _from Отправитель NFT (если адрес нулевой, это указывает на создание токена).
# @param _to Получатель NFT (если адрес нулевой, это указывает на уничтожение токена).
# @param _tokenId Переданный NFT.
event Transfer:
    sender: indexed(address)
    receiver: indexed(address)
    tokenId: indexed(uint256)
```

Это похоже на событие Transfer в ERC-20, за исключением того, что мы сообщаем `tokenId` вместо суммы.
Никто не владеет нулевым адресом, поэтому по соглашению мы используем его для сообщения о создании и уничтожении токенов.

```python
# @dev Создается, когда одобренный адрес для NFT изменяется или подтверждается. Нулевой
#      адрес указывает на отсутствие одобренного адреса. Когда создается событие Transfer, это также
#      указывает, что одобренный адрес для этого NFT (если таковой имеется) сбрасывается.
# @param _owner Владелец NFT.
# @param _approved Адрес, который мы одобряем.
# @param _tokenId NFT, который мы одобряем.
event Approval:
    owner: indexed(address)
    approved: indexed(address)
    tokenId: indexed(uint256)
```

Одобрение в ERC-721 похоже на разрешение в ERC-20. Определенному адресу разрешается переводить определенный
токен. Это дает контрактам механизм для реагирования, когда они принимают токен. Контракты не могут
прослушивать события, поэтому, если вы просто переведете им токен, они не \"узнают\" об этом. Таким образом, владелец
сначала отправляет одобрение, а затем отправляет запрос контракту: \"Я одобрил для вас перевод токена
X, пожалуйста, сделайте ...\".

Это проектное решение, призванное сделать стандарт ERC-721 похожим на стандарт ERC-20. Поскольку
токены ERC-721 не являются взаимозаменяемыми, контракт также может определить, что он получил определенный токен,
проверив право собственности на токен.

```python
# @dev Это событие создается, когда оператор включается или отключается для владельца. Оператор может управлять
#      всеми NFT владельца.
# @param _owner Владелец NFT.
# @param _operator Адрес, которому мы устанавливаем права оператора.
# @param _approved Статус прав оператора (true, если права оператора предоставлены, и false, если
# они отозваны).
event ApprovalForAll:
    owner: indexed(address)
    operator: indexed(address)
    approved: bool
```

Иногда бывает полезно иметь _оператора_, который может управлять всеми токенами аккаунта определенного типа (теми, которые управляются
определенным контрактом), подобно доверенности. Например, я могу захотеть предоставить такие полномочия контракту, который проверяет, не
связывался ли я с ним в течение шести месяцев, и если да, то распределяет мои активы между моими наследниками (если один из них попросит об этом, контракты
не могут ничего делать без вызова транзакцией). В ERC-20 мы можем просто дать высокое разрешение на контракт наследования,
но это не работает для ERC-721, потому что токены не являются взаимозаменяемыми. Это эквивалент.

Значение `approved` говорит нам о том, является ли событие одобрением или отзывом одобрения.

### Переменные состояния {#state-vars}

Эти переменные содержат текущее состояние токенов: какие из них доступны и кто ими владеет. Большинство из них
это объекты `HashMap`, [однонаправленные сопоставления, которые существуют между двумя типами](https://vyper.readthedocs.io/en/latest/types.html#mappings).

```python
# @dev Сопоставление идентификатора NFT с адресом его владельца.
idToOwner: HashMap[uint256, address]

# @dev Сопоставление идентификатора NFT с одобренным адресом.
idToApprovals: HashMap[uint256, address]
```

Идентификаторы пользователей и контрактов в Ethereum представлены 160-битными адресами. Эти две переменные сопоставляют
идентификаторы токенов с их владельцами и теми, кто одобрен для их перевода (максимум по одному для каждого). В Ethereum
неинициализированные данные всегда равны нулю, поэтому, если нет владельца или одобренного отправителя, значение для этого токена
равно нулю.

```python
# @dev Сопоставление адреса владельца с количеством его токенов.
ownerToNFTokenCount: HashMap[address, uint256]
```

Эта переменная содержит количество токенов для каждого владельца. Сопоставления от владельцев к токенам не существует, поэтому
единственный способ идентифицировать токены, которыми владеет конкретный владелец, — это просмотреть историю событий блокчейна
и найти соответствующие события `Transfer`. Мы можем использовать эту переменную, чтобы знать, когда у нас есть все NFT и не
нужно заглядывать еще дальше во времени.

Обратите внимание, что этот алгоритм работает только для пользовательских интерфейсов и внешних серверов. Код, работающий в блокчейне,
сам по себе не может читать прошлые события.

```python
# @dev Сопоставление адреса владельца с сопоставлением адресов операторов.
ownerToOperators: HashMap[address, HashMap[address, bool]]
```

У аккаунта может быть несколько операторов. Простого `HashMap` недостаточно, чтобы
отслеживать их, потому что каждый ключ ведет к одному значению. Вместо этого вы можете использовать
`HashMap[address, bool]` в качестве значения. По умолчанию значение для каждого адреса — `False`, что означает, что он
не является оператором. Вы можете установить значения на `True` по мере необходимости.

```python
# @dev Адрес минтера, который может создавать токен
minter: address
```

Новые токены должны как-то создаваться. В этом контракте есть единственная сущность, которой разрешено это делать, —
`минтер`. Этого, например, скорее всего, будет достаточно для игры. Для других целей может потребоваться
создать более сложную бизнес-логику.

```python
# @dev Сопоставление идентификатора интерфейса с логическим значением о том, поддерживается он или нет
supportedInterfaces: HashMap[bytes32, bool]

# @dev Идентификатор интерфейса ERC165 для ERC165
ERC165_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000001ffc9a7

# @dev Идентификатор интерфейса ERC165 для ERC721
ERC721_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000080ac58cd
```

[ERC-165](https://eips.ethereum.org/EIPS/eip-165) определяет механизм, с помощью которого контракт может раскрывать, как приложения
могут с ним взаимодействовать, каким стандартам ERC он соответствует. В данном случае контракт соответствует стандартам ERC-165 и ERC-721.

### Функции {#functions}

Это функции, которые фактически реализуют ERC-721.

#### Конструктор {#constructor}

```python
@external
def __init__():
```

В Vyper, как и в Python, функция-конструктор называется `__init__`.

```python
    """
    @dev Конструктор контракта.
    """
```

В Python и Vyper вы также можете создать комментарий, указав многострочную строку (которая начинается и заканчивается
`"""`) и никак ее не используя. Эти комментарии также могут включать
[NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html).

```python
    self.supportedInterfaces[ERC165_INTERFACE_ID] = True
    self.supportedInterfaces[ERC721_INTERFACE_ID] = True
    self.minter = msg.sender
```

Для доступа к переменным состояния используйте `self.<имя переменной>`` (опять же, как и в Python).

#### Функции просмотра {#views}

Это функции, которые не изменяют состояние блокчейна и поэтому могут выполняться
бесплатно, если вызываются извне. Если функции просмотра вызываются контрактом, они все равно должны выполняться на
каждом узле и, следовательно, стоят газа.

```python
@view
@external
```

Эти ключевые слова перед определением функции, которые начинаются со знака «собачка» (`@`), называются _декораторами_. Они
указывают обстоятельства, при которых может быть вызвана функция.

- `@view` указывает, что эта функция является функцией просмотра.
- `@external` указывает, что данная функция может быть вызвана транзакциями и другими контрактами.

```python
def supportsInterface(_interfaceID: bytes32) -> bool:
```

В отличие от Python, Vyper — это [язык со статической типизацией](https://wikipedia.org/wiki/Type_system#Static_type_checking).
Нельзя объявить переменную или параметр функции, не указав [тип данных](https://vyper.readthedocs.io/en/latest/types.html). В данном случае входной параметр — `bytes32`, 256-битное значение
(256 бит — это нативный размер слова [виртуальной машины Ethereum](/developers/docs/evm/)). Выходные данные — это логическое
значение. По соглашению имена параметров функции начинаются с символа подчеркивания (`_`).

```python
    """
    @dev Идентификация интерфейса указана в ERC-165.
    @param _interfaceID Идентификатор интерфейса
    """
    return self.supportedInterfaces[_interfaceID]
```

Возвращает значение из HashMap `self.supportedInterfaces`, которое устанавливается в конструкторе (`__init__`).

```python
### ФУНКЦИИ ПРОСМОТРА ###

```

Это функции просмотра, которые делают информацию о токенах доступной для пользователей и других контрактов.

```python
@view
@external
def balanceOf(_owner: address) -> uint256:
    """
    @dev Возвращает количество NFT, принадлежащих `_owner`.
         Вызывает исключение, если `_owner` является нулевым адресом. NFT, назначенные нулевому адресу, считаются недействительными.
    @param _owner Адрес, для которого запрашивается баланс.
    """
    assert _owner != ZERO_ADDRESS
```

Эта строка [проверяет](https://vyper.readthedocs.io/en/latest/statements.html#assert), что `_owner` не
равен нулю. Если это так, возникает ошибка и операция отменяется.

```python
    return self.ownerToNFTokenCount[_owner]

@view
@external
def ownerOf(_tokenId: uint256) -> address:
    """
    @dev Возвращает адрес владельца NFT.
         Вызывает исключение, если `_tokenId` не является действительным NFT.
    @param _tokenId Идентификатор для NFT.
    """
    owner: address = self.idToOwner[_tokenId]
    # Вызывает исключение, если `_tokenId` не является действительным NFT
    assert owner != ZERO_ADDRESS
    return owner
```

В виртуальной машине Ethereum (EVM) любое хранилище, в котором не хранится значение, равно нулю.
Если по адресу `_tokenId` нет токена, то значение `self.idToOwner[_tokenId]` равно нулю. В этом
случае функция отменяется.

```python
@view
@external
def getApproved(_tokenId: uint256) -> address:
    """
    @dev Получает одобренный адрес для одного NFT.
         Вызывает исключение, если `_tokenId` не является действительным NFT.
    @param _tokenId Идентификатор NFT для запроса его одобрения.
    """
    # Вызывает исключение, если `_tokenId` не является действительным NFT
    assert self.idToOwner[_tokenId] != ZERO_ADDRESS
    return self.idToApprovals[_tokenId]
```

Обратите внимание, что `getApproved` _может_ вернуть ноль. Если токен действителен, он возвращает `self.idToApprovals[_tokenId]`.
Если нет утверждающего, это значение равно нулю.

```python
@view
@external
def isApprovedForAll(_owner: address, _operator: address) -> bool:
    """
    @dev Проверяет, является ли `_operator` одобренным оператором для `_owner`.
    @param _owner Адрес, которому принадлежат NFT.
    @param _operator Адрес, который действует от имени владельца.
    """
    return (self.ownerToOperators[_owner])[_operator]
```

Эта функция проверяет, разрешено ли `_operator` управлять всеми токенами `_owner` в этом контракте.
Поскольку операторов может быть несколько, это двухуровневый HashMap.

#### Вспомогательные функции перевода {#transfer-helpers}

Эти функции реализуют операции, которые являются частью перевода или управления токенами.

```python

### ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ПЕРЕВОДА ###

@view
@internal
```

Этот декоратор `@internal` означает, что функция доступна только из других функций в том
же контракте. По соглашению, имена этих функций также начинаются с символа подчеркивания (`_`).

```python
def _isApprovedOrOwner(_spender: address, _tokenId: uint256) -> bool:
    """
    @dev Возвращает, может ли данный тратящий перевести данный идентификатор токена
    @param spender адрес тратящего для запроса
    @param tokenId uint256 ID токена для перевода
    @return bool, является ли msg.sender одобренным для данного ID токена,
        является ли оператором владельца, или является владельцем токена
    """
    owner: address = self.idToOwner[_tokenId]
    spenderIsOwner: bool = owner == _spender
    spenderIsApproved: bool = _spender == self.idToApprovals[_tokenId]
    spenderIsApprovedForAll: bool = (self.ownerToOperators[owner])[_spender]
    return (spenderIsOwner or spenderIsApproved) or spenderIsApprovedForAll
```

Существует три способа, которыми адрес может быть разрешен для перевода токена:

1. Адрес является владельцем токена
2. Адрес одобрен для расходования этого токена
3. Адрес является оператором для владельца токена

Вышеупомянутая функция может быть функцией просмотра, поскольку она не изменяет состояние. Чтобы снизить эксплуатационные расходы, любая
функция, которая _может_ быть функцией просмотра, _должна_ ею быть.

```python
@internal
def _addTokenTo(_to: address, _tokenId: uint256):
    """
    @dev Добавляет NFT на данный адрес
         Вызывает исключение, если `_tokenId` принадлежит кому-то.
    """
    # Вызывает исключение, если `_tokenId` принадлежит кому-то
    assert self.idToOwner[_tokenId] == ZERO_ADDRESS
    # Изменение владельца
    self.idToOwner[_tokenId] = _to
    # Изменение отслеживания количества
    self.ownerToNFTokenCount[_to] += 1


@internal
def _removeTokenFrom(_from: address, _tokenId: uint256):
    """
    @dev Удаляет NFT с данного адреса
         Вызывает исключение, если `_from` не является текущим владельцем.
    """
    # Вызывает исключение, если `_from` не является текущим владельцем
    assert self.idToOwner[_tokenId] == _from
    # Изменение владельца
    self.idToOwner[_tokenId] = ZERO_ADDRESS
    # Изменение отслеживания количества
    self.ownerToNFTokenCount[_from] -= 1
```

Когда возникает проблема с переводом, мы отменяем вызов.

```python
@internal
def _clearApproval(_owner: address, _tokenId: uint256):
    """
    @dev Очищает одобрение для данного адреса
         Вызывает исключение, если `_owner` не является текущим владельцем.
    """
    # Вызывает исключение, если `_owner` не является текущим владельцем
    assert self.idToOwner[_tokenId] == _owner
    if self.idToApprovals[_tokenId] != ZERO_ADDRESS:
        # Сброс одобрений
        self.idToApprovals[_tokenId] = ZERO_ADDRESS
```

Изменяйте значение только при необходимости. Переменные состояния находятся в хранилище. Запись в хранилище —
одна из самых дорогих операций, которые выполняет EVM (виртуальная машина Ethereum) (с точки зрения
[газа](/developers/docs/gas/)). Поэтому хорошей идеей является ее минимизация, даже запись
существующего значения имеет высокую стоимость.

```python
@internal
def _transferFrom(_from: address, _to: address, _tokenId: uint256, _sender: address):
    """
    @dev Выполнение перевода NFT.
         Вызывает исключение, если `msg.sender` не является текущим владельцем, авторизованным оператором или одобренным
         адресом для этого NFT. (ПРИМЕЧАНИЕ: `msg.sender` не разрешен в приватной функции, поэтому передайте `_sender`.)
         Вызывает исключение, если `_to` является нулевым адресом.
         Вызывает исключение, если `_from` не является текущим владельцем.
         Вызывает исключение, если `_tokenId` не является действительным NFT.
    """
```

У нас есть эта внутренняя функция, потому что существует два способа перевода токенов (обычный и безопасный), но
мы хотим, чтобы это делалось только в одном месте кода, чтобы облегчить аудит.

```python
    # Проверка требований
    assert self._isApprovedOrOwner(_sender, _tokenId)
    # Вызывает исключение, если `_to` является нулевым адресом
    assert _to != ZERO_ADDRESS
    # Очистка одобрения. Вызывает исключение, если `_from` не является текущим владельцем
    self._clearApproval(_from, _tokenId)
    # Удаление NFT. Вызывает исключение, если `_tokenId` не является действительным NFT
    self._removeTokenFrom(_from, _tokenId)
    # Добавление NFT
    self._addTokenTo(_to, _tokenId)
    # Логирование перевода
    log Transfer(_from, _to, _tokenId)
```

Чтобы сгенерировать событие в Vyper, используется оператор `log` ([подробнее см. здесь](https://vyper.readthedocs.io/en/latest/event-logging.html#event-logging)).

#### Функции перевода {#transfer-funs}

```python

### ФУНКЦИИ ПЕРЕВОДА ###

@external
def transferFrom(_from: address, _to: address, _tokenId: uint256):
    """
    @dev Вызывает исключение, если `msg.sender` не является текущим владельцем, авторизованным оператором или одобренным
         адресом для этого NFT.
         Вызывает исключение, если `_from` не является текущим владельцем.
         Вызывает исключение, если `_to` является нулевым адресом.
         Вызывает исключение, если `_tokenId` не является действительным NFT.
    @notice Вызывающий несет ответственность за подтверждение того, что `_to` способен получать NFT, иначе
            они могут быть навсегда потеряны.
    @param _from Текущий владелец NFT.
    @param _to Новый владелец.
    @param _tokenId NFT для перевода.
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

Эта функция позволяет выполнять перевод на произвольный адрес. Если адрес не является адресом пользователя или контракта, который
знает, как переводить токены, любой переведенный вами токен застрянет на этом адресе и станет бесполезным.

```python
@external
def safeTransferFrom(
        _from: address,
        _to: address,
        _tokenId: uint256,
        _data: Bytes[1024]=b""
    ):
    """
    @dev Передает право собственности на NFT с одного адреса на другой.
         Вызывает исключение, если `msg.sender` не является текущим владельцем, авторизованным оператором или
         одобренным адресом для этого NFT.
         Вызывает исключение, если `_from` не является текущим владельцем.
         Вызывает исключение, если `_to` — нулевой адрес.
         Вызывает исключение, если `_tokenId` не является действительным NFT.
         Если `_to` — это смарт-контракт, он вызывает `onERC721Received` для `_to` и вызывает исключение, если
         возвращаемое значение не равно `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
         ПРИМЕЧАНИЕ: bytes4 представлен как bytes32 с дополнением
    @param _from Текущий владелец NFT.
    @param _to Новый владелец.
    @param _tokenId NFT для перевода.
    @param _data Дополнительные данные без определенного формата, отправляемые при вызове `_to`.
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

Можно сначала выполнить перевод, потому что если возникнет проблема, мы все равно отменим операцию,
так что все, что было сделано в вызове, будет отменено.

```python
    if _to.is_contract: # проверяем, является ли `_to` адресом контракта
```

Сначала проверьте, является ли адрес контрактом (есть ли у него код). Если нет, предположим, что это адрес пользователя,
и пользователь сможет использовать токен или перевести его. Но не позволяйте этому усыпить вашу
бдительность. Вы можете потерять токены, даже с `safeTransferFrom`, если переведете
их на адрес, для которого никто не знает приватный ключ.

```python
        returnValue: bytes32 = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data)
```

Вызовите целевой контракт, чтобы узнать, может ли он получать токены ERC-721.

```python
        # Вызывает исключение, если получатель перевода — это контракт, который не реализует 'onERC721Received'
        assert returnValue == method_id("onERC721Received(address,address,uint256,bytes)", output_type=bytes32)
```

Если получатель — это контракт, но он не принимает токены ERC-721 (или решил не принимать этот
конкретный перевод), отмените операцию.

```python
@external
def approve(_approved: address, _tokenId: uint256):
    """
    @dev Устанавливает или подтверждает одобренный адрес для NFT. Нулевой адрес указывает на отсутствие одобренного адреса.
         Вызывает исключение, если `msg.sender` не является текущим владельцем NFT или авторизованным оператором текущего владельца.
         Вызывает исключение, если `_tokenId` не является действительным NFT. (ПРИМЕЧАНИЕ: этого нет в EIP)
         Вызывает исключение, если `_approved` является текущим владельцем. (ПРИМЕЧАНИЕ: этого нет в EIP)
    @param _approved Адрес, который должен быть одобрен для данного идентификатора NFT.
    @param _tokenId Идентификатор токена, который должен быть одобрен.
    """
    owner: address = self.idToOwner[_tokenId]
    # Вызывает исключение, если `_tokenId` не является действительным NFT
    assert owner != ZERO_ADDRESS
    # Вызывает исключение, если `_approved` является текущим владельцем
    assert _approved != owner
```

По соглашению, если вы не хотите иметь утверждающего, вы назначаете нулевой адрес, а не себя.

```python
    # Проверка требований
    senderIsOwner: bool = self.idToOwner[_tokenId] == msg.sender
    senderIsApprovedForAll: bool = (self.ownerToOperators[owner])[msg.sender]
    assert (senderIsOwner or senderIsApprovedForAll)
```

Чтобы установить одобрение, вы можете быть либо владельцем, либо оператором, уполномоченным владельцем.

```python
    # Установка одобрения
    self.idToApprovals[_tokenId] = _approved
    log Approval(owner, _approved, _tokenId)


@external
def setApprovalForAll(_operator: address, _approved: bool):
    """
    @dev Включает или отключает одобрение для третьей стороны ("оператора") для управления всеми
         активами `msg.sender`. Также генерирует событие ApprovalForAll.
         Вызывает исключение, если `_operator` является `msg.sender`. (ПРИМЕЧАНИЕ: этого нет в EIP)
    @notice Это работает, даже если отправитель не владеет никакими токенами в данный момент.
    @param _operator Адрес для добавления в набор авторизованных операторов.
    @param _approved True, если оператор одобрен, false — для отзыва одобрения.
    """
    # Вызывает исключение, если `_operator` является `msg.sender`
    assert _operator != msg.sender
    self.ownerToOperators[msg.sender][_operator] = _approved
    log ApprovalForAll(msg.sender, _operator, _approved)
```

#### Создание новых токенов и уничтожение существующих {#mint-burn}

Аккаунт, создавший контракт, является `минтером` — суперпользователем, уполномоченным создавать
новые NFT. Однако даже ему не разрешается сжигать существующие токены. Это может сделать только владелец или уполномоченное им лицо.

```python
### ФУНКЦИИ СОЗДАНИЯ И СЖИГАНИЯ ###

@external
def mint(_to: address, _tokenId: uint256) -> bool:
```

Эта функция всегда возвращает `True`, потому что в случае сбоя операция отменяется.

```python
    """
    @dev Функция для создания токенов
         Вызывает исключение, если `msg.sender` не является минтером.
         Вызывает исключение, если `_to` является нулевым адресом.
         Вызывает исключение, если `_tokenId` уже принадлежит кому-то.
    @param _to Адрес, который получит созданные токены.
    @param _tokenId Идентификатор токена для создания.
    @return Логическое значение, которое указывает, была ли операция успешной.
    """
    # Вызывает исключение, если `msg.sender` не является минтером
    assert msg.sender == self.minter
```

Только минтер (аккаунт, создавший контракт ERC-721) может создавать новые токены. Это может
стать проблемой в будущем, если мы захотим изменить идентификатор минтера. В
рабочем контракте, вероятно, понадобится функция, позволяющая минтеру передавать
привилегии минтера кому-то другому.

```python
    # Вызывает исключение, если `_to` является нулевым адресом
    assert _to != ZERO_ADDRESS
    # Добавление NFT. Вызывает исключение, если `_tokenId` уже принадлежит кому-то
    self._addTokenTo(_to, _tokenId)
    log Transfer(ZERO_ADDRESS, _to, _tokenId)
    return True
```

По соглашению, создание новых токенов считается переводом с нулевого адреса.

```python

@external
def burn(_tokenId: uint256):
    """
    @dev Сжигает определенный токен ERC721.
         Вызывает исключение, если `msg.sender` не является текущим владельцем, авторизованным оператором или одобренным
         адресом для этого NFT.
         Вызывает исключение, если `_tokenId` не является действительным NFT.
    @param _tokenId uint256 id токена ERC721 для сжигания.
    """
    # Проверка требований
    assert self._isApprovedOrOwner(msg.sender, _tokenId)
    owner: address = self.idToOwner[_tokenId]
    # Вызывает исключение, если `_tokenId` не является действительным NFT
    assert owner != ZERO_ADDRESS
    self._clearApproval(owner, _tokenId)
    self._removeTokenFrom(owner, _tokenId)
    log Transfer(owner, ZERO_ADDRESS, _tokenId)
```

Любой, кому разрешено переводить токен, может его сжечь. Хотя сжигание кажется эквивалентным
переводу на нулевой адрес, нулевой адрес на самом деле не получает токен. Это позволяет нам
освободить все хранилище, которое использовалось для токена, что может снизить стоимость газа транзакции.

## Использование этого контракта {#using-contract}

В отличие от Solidity, в Vyper нет наследования. Это сознательное проектное решение, чтобы сделать
код более ясным и, следовательно, более простым в обеспечении безопасности. Поэтому для создания собственного контракта Vyper ERC-721 вы берете этот
контракт и изменяете его
для реализации желаемой бизнес-логики.

## Заключение {#conclusion}

Для обзора, вот некоторые из наиболее важных идей в этом контракте:

- Для получения токенов ERC-721 с помощью безопасного перевода контракты должны реализовывать интерфейс `ERC721Receiver`.
- Даже если вы используете безопасный перевод, токены все равно могут застрять, если вы отправите их на адрес, чей приватный ключ
  неизвестен.
- При возникновении проблемы с операцией рекомендуется `отменить` вызов, а не просто возвращать
  значение сбоя.
- Токены ERC-721 существуют, когда у них есть владелец.
- Есть три способа получить разрешение на передачу NFT. Вы можете быть владельцем, иметь одобрение для конкретного токена
  или быть оператором для всех токенов владельца.
- Прошлые события видны только за пределами блокчейна. Код, работающий внутри блокчейна, не может их просматривать.

А теперь идите и реализуйте безопасные контракты Vyper.

[Больше моих работ смотрите здесь](https://cryptodocguy.pro/).

