---
title: "Уменьшение размера контрактов для борьбы с ограничением их размера"
description: "Что можно сделать, чтобы ваши смарт-контракты не становились слишком большими?"
author: Markus Waas
lang: ru
tags: [ "твердость", "Умные контракты", "хранилище" ]
skill: intermediate
published: 2020-06-26
source: soliditydeveloper.com
sourceUrl: https://soliditydeveloper.com/max-contract-size
---

## Почему существует ограничение? {#why-is-there-a-limit}

22 ноября 2016 г. в хардфорке [Spurious Dragon](https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon/) было введено [EIP-170](https://eips.ethereum.org/EIPS/eip-170), которое добавило ограничение на размер смарт-контракта в 24,576 кб. Для вас как для разработчика на Solidity это означает, что по мере добавления все большей функциональности в ваш контракт в какой-то момент вы достигнете предела и при развертывании увидите ошибку:

`Предупреждение: Размер кода контракта превышает 24576 байт (ограничение, введенное в Spurious Dragon).` Этот контракт может оказаться невозможно развернуть в основной сети. `Рассмотрите возможность включения оптимизатора (с низким значением \"runs\"!), отключения строк отката или использования библиотек.`

Это ограничение было введено для предотвращения атак типа «отказ в обслуживании» (DoS-атак). Любой вызов контракта относительно дешев с точки зрения затрат газа. Однако влияние вызова контракта на узлы Ethereum непропорционально возрастает в зависимости от размера кода вызываемого контракта (чтение кода с диска, предварительная обработка кода, добавление данных в доказательство Меркла). Всякий раз, когда возникает ситуация, в которой атакующему требуется мало ресурсов, чтобы заставить других проделать большую работу, появляется возможность для DoS-атак.

Изначально это было не такой большой проблемой, потому что одним из естественных ограничений размера контракта является лимит газа блока. Очевидно, что контракт должен быть развернут в рамках транзакции, которая содержит весь байткод контракта. Если вы включите в блок только эту одну транзакцию, вы можете использовать весь газ, но он не бесконечен. После [обновления London](/ethereum-forks/#london) лимит газа блока может варьироваться от 15 до 30 млн единиц в зависимости от загруженности сети.

Далее мы рассмотрим некоторые методы, упорядоченные по их потенциальному влиянию. Думайте об этом как о похудении. Лучшая стратегия для достижения целевого веса (в нашем случае 24 кб) — это сначала сосредоточиться на методах с наибольшим влиянием. В большинстве случаев для достижения цели достаточно просто изменить свой рацион, но иногда требуется нечто большее. Затем вы можете добавить некоторые упражнения (среднее влияние) или даже пищевые добавки (небольшое влияние).

## Значительное влияние {#big-impact}

### Разделяйте свои контракты {#separate-your-contracts}

Это всегда должно быть вашим первым шагом. Как можно разделить контракт на несколько меньших? Как правило, это заставляет вас разработать хорошую архитектуру для ваших контрактов. С точки зрения читаемости кода всегда предпочтительнее использовать контракты меньшего размера. Чтобы разделить контракты, задайте себе следующие вопросы:

- Какие функции логически связаны? Каждый набор функций лучше всего разместить в отдельном контракте.
- Какие функции не требуют чтения состояния контракта или требуют лишь определенного подмножества состояния?
- Можно ли разделить хранилище и функциональность?

### Библиотеки {#libraries}

Один из простых способов отделить код функциональности от хранилища — использовать [библиотеку](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#libraries). Не объявляйте функции библиотеки как internal, так как они будут [добавлены в контракт](https://ethereum.stackexchange.com/questions/12975/are-internal-functions-in-libraries-not-covered-by-linking) напрямую во время компиляции. Но если вы используете функции public, то они фактически будут находиться в отдельном контракте библиотеки. Рассмотрите возможность использования [using for](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for), чтобы сделать использование библиотек более удобным.

### Прокси-контракты {#proxies}

Более продвинутой стратегией является система прокси-контрактов. Библиотеки используют `DELEGATECALL` «под капотом», что просто выполняет функцию другого контракта с состоянием вызывающего контракта. Прочтите [эту статью в блоге](https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2), чтобы узнать больше о системах прокси-контрактов. Они предоставляют вам больше функциональности, например, они обеспечивают возможность обновления, но они также добавляют много сложности. Я бы не стал добавлять их только для уменьшения размера контракта, если по какой-либо причине это не является вашим единственным вариантом.

## Среднее влияние {#medium-impact}

### Удаление функций {#remove-functions}

Это должно быть очевидно. Функции довольно сильно увеличивают размер контракта.

- **External**: Часто мы добавляем много функций `view` для удобства. Это совершенно нормально, пока вы не достигнете предела размера. Тогда вам, возможно, стоит подумать об удалении всех функций, кроме абсолютно необходимых.
- **Internal**: Вы также можете удалить функции `internal`/`private` и просто встроить код, если функция вызывается только один раз.

### Избегайте дополнительных переменных {#avoid-additional-variables}

```solidity
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
```

Такое простое изменение дает разницу в **0,28 кб**. Скорее всего, вы сможете найти много подобных ситуаций в ваших контрактах, и в сумме они могут дать значительную экономию.

### Сократите сообщения об ошибках {#shorten-error-message}

Длинные сообщения отката и, в частности, множество различных сообщений отката могут раздувать контракт. Вместо этого используйте короткие коды ошибок и декодируйте их в своем клиенте. Длинное сообщение может стать намного короче:

```solidity
require(msg.sender == owner, \"Только владелец этого контракта может вызывать эту функцию\");
```

```solidity
require(msg.sender == owner, \"OW1\");
```

### Используйте пользовательские ошибки вместо сообщений об ошибках

Пользовательские ошибки были введены в [Solidity 0.8.4](https://blog.soliditylang.org/2021/04/21/custom-errors/). Это отличный способ уменьшить размер ваших контрактов, потому что они кодируются в ABI как селекторы (так же, как и функции).

```solidity
error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
```

### Рассмотрите возможность использования низкого значения runs в оптимизаторе {#consider-a-low-run-value-in-the-optimizer}

Вы также можете изменить настройки оптимизатора. Значение по умолчанию, равное 200, означает, что он пытается оптимизировать байткод так, как если бы функция вызывалась 200 раз. Если вы измените его на 1, вы, по сути, даете команду оптимизатору оптимизировать код для случая, когда каждая функция выполняется только один раз. Оптимизированная для однократного выполнения функция означает, что она оптимизирована для самого развертывания. Имейте в виду, что **это увеличивает [стоимость газа](/developers/docs/gas/) за выполнение функций**, поэтому, возможно, вы не захотите этого делать.

## Небольшое влияние {#small-impact}

### Избегайте передачи структур в функции {#avoid-passing-structs-to-functions}

Если вы используете [ABIEncoderV2](https://solidity.readthedocs.io/en/v0.6.10/layout-of-source-files.html#abiencoderv2), может помочь отказ от передачи структур в функции. Вместо того чтобы передавать параметр в виде структуры, передавайте необходимые параметры напрямую. В этом примере мы сэкономили еще **0,1 кб**.

```solidity
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
```

### Объявляйте правильную область видимости для функций и переменных {#declare-correct-visibility-for-functions-and-variables}

- Функции или переменные, которые вызываются только извне? Объявляйте их как `external`, а не `public`.
- Функции или переменные, вызываемые только из самого контракта? Объявляйте их как `private` или `internal` вместо `public`.

### Удаление модификаторов {#remove-modifiers}

Модификаторы, особенно при интенсивном использовании, могут оказывать значительное влияние на размер контракта. Рассмотрите возможность их удаления и использования вместо них функций.

```solidity
modifier checkStuff() {}

function doSomething() checkStuff {}
```

```solidity
function checkStuff() private {}

function doSomething() { checkStuff(); }
```

Эти советы должны помочь вам значительно уменьшить размер контракта. Еще раз, не могу не подчеркнуть: всегда стремитесь к разделению контрактов, если это возможно, для достижения наибольшего эффекта.
