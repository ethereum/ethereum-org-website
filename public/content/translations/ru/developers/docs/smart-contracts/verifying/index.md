---
title: "Проверка смарт-контрактов"
description: "Обзор верификации исходного кода для смарт-контрактов Ethereum"
lang: ru
---

[Смарт-контракты](/developers/docs/smart-contracts/) спроектированы как «бездоверительные», что означает, что пользователям не нужно доверять третьим лицам (например, разработчикам и компаниям) перед взаимодействием с контрактом. В качестве обязательного условия для бездоверительности пользователи и другие разработчики должны иметь возможность верифицировать исходный код смарт-контракта. Верификация исходного кода гарантирует пользователям и разработчикам, что опубликованный код контракта является тем же кодом, который выполняется по адресу контракта в блокчейне Ethereum.

Важно различать «верификацию исходного кода» и «[формальную верификацию](/developers/docs/smart-contracts/formal-verification/)». Верификация исходного кода, которая будет подробно объяснена ниже, относится к проверке того, что данный исходный код смарт-контракта на языке высокого уровня (например, Solidity) компилируется в тот же байт-код, который должен выполняться по адресу контракта. Однако формальная верификация описывает проверку правильности смарт-контракта, то есть того, что контракт ведет себя так, как ожидалось. Хотя это зависит от контекста, верификация контракта обычно относится к верификации исходного кода.

## Что такое верификация исходного кода? {#what-is-source-code-verification}

Перед развертыванием смарт-контракта в [виртуальной машине Ethereum (EVM)](/developers/docs/evm/) разработчики [компилируют](/developers/docs/smart-contracts/compiling/) исходный код контракта — инструкции, [написанные на Solidity](/developers/docs/smart-contracts/languages/) или другом высокоуровневом языке программирования, — в байт-код. Поскольку EVM не может интерпретировать высокоуровневые инструкции, компиляция исходного кода в байт-код (т. е. низкоуровневые машинные инструкции) необходима для выполнения логики контракта в EVM.

Верификация исходного кода — это сравнение исходного кода смарт-контракта и скомпилированного байт-кода, использованного при создании контракта, для обнаружения любых различий. Верификация смарт-контрактов важна, потому что рекламируемый код контракта может отличаться от того, что работает в блокчейне.

Верификация смарт-контракта позволяет исследовать, что делает контракт, с помощью языка более высокого уровня, на котором он написан, без необходимости читать машинный код. Функции, значения и обычно имена переменных и комментарии остаются такими же, как в исходном коде, который компилируется и развертывается. Это значительно облегчает чтение кода. Верификация исходного кода также предусматривает документирование кода, чтобы конечные пользователи знали, для чего предназначен смарт-контракт.

### Что такое полная верификация? {#full-verification}

Есть некоторые части исходного кода, которые не влияют на скомпилированный байт-код, например комментарии или имена переменных. Это означает, что два исходных кода с разными именами переменных и разными комментариями могут верифицировать один и тот же контракт. Таким образом, злоумышленник может добавить вводящие в заблуждение комментарии или дать неверные имена переменных в исходном коде, и контракт будет верифицирован с исходным кодом, отличным от оригинального.

Этого можно избежать, добавив к байт-коду дополнительные данные, которые будут служить _криптографической гарантией_ точности исходного кода и _отпечатком_ информации о компиляции. Необходимая информация находится в [метаданных контракта Solidity](https://docs.soliditylang.org/en/v0.8.15/metadata.html), и хэш этого файла добавляется к байт-коду контракта. Вы можете увидеть это в действии на [площадке для работы с метаданными](https://playground.sourcify.dev)

Файл метаданных содержит информацию о компиляции контракта, включая исходные файлы и их хэши. Это означает, что если изменятся какие-либо параметры компиляции или даже один байт в одном из исходных файлов, файл метаданных изменится. Следовательно, хэш файла метаданных, который добавляется к байт-коду, также изменяется. Это означает, что если байт-код контракта + добавленный хэш метаданных совпадают с заданным исходным кодом и настройками компиляции, мы можем быть уверены, что это точно тот же исходный код, который использовался при первоначальной компиляции, и в нем не отличается ни один байт.

Этот тип верификации, использующий хэш метаданных, называется **«[полной верификацией](https://docs.sourcify.dev/docs/full-vs-partial-match/)»** (также «идеальной верификацией»). Если хэши метаданных не совпадают или не учитываются при верификации, это будет «частичное совпадение», что в настоящее время является более распространенным способом верификации контрактов. Без полной верификации возможно [внедрение вредоносного кода](https://samczsun.com/hiding-in-plain-sight/), который не будет отражен в верифицированном исходном коде. Большинство разработчиков не знают о полной верификации и не сохраняют файл метаданных своей компиляции, поэтому частичная верификация до сих пор является методом верификации контрактов де-факто.

## Почему важна верификация исходного кода? {#importance-of-source-code-verification}

### Бездоверительность {#trustlessness}

Бездоверительность — это, пожалуй, самая главная предпосылка для смарт-контрактов и [децентрализованных приложений (dapps)](/developers/docs/dapps/). Смарт-контракты являются «неизменяемыми» и не могут быть изменены; контракт будет выполнять только ту бизнес-логику, которая определена в коде на момент развертывания. Это означает, что разработчики и предприятия не могут вмешиваться в код контракта после его развертывания в Ethereum.

Чтобы смарт-контракт был бездоверительным, его код должен быть доступен для независимой верификации. Хотя скомпилированный байт-код для каждого смарт-контракта общедоступен в блокчейне, низкоуровневый язык трудно понять как разработчикам, так и пользователям.

Проекты снижают необходимость в доверии, публикуя исходный код своих контрактов. Но это приводит к другой проблеме: трудно проверить, что опубликованный исходный код соответствует байт-коду контракта. В этом случае ценность бездоверительности теряется, потому что пользователям приходится доверять разработчикам в том, что они не изменят бизнес-логику контракта (т. е. изменив байт-код) перед его развертыванием в блокчейне.

Инструменты верификации исходного кода предоставляют гарантии того, что файлы исходного кода смарт-контракта соответствуют ассемблерному коду. Результатом является бездоверительная экосистема, в которой пользователи не доверяют слепо третьим сторонам, а верифицируют код перед внесением средств в контракт.

### Безопасность пользователя {#user-safety}

В смарт-контрактах на кону обычно стоят большие деньги. Это требует более высоких гарантий безопасности и верификации логики смарт-контракта перед его использованием. Проблема в том, что недобросовестные разработчики могут обмануть пользователей, вставив в смарт-контракт вредоносный код. Без верификации вредоносные смарт-контракты могут иметь [бэкдоры](https://www.trustnodes.com/2018/11/10/concerns-rise-over-backdoored-smart-contracts), спорные механизмы контроля доступа, эксплуатируемые уязвимости и другие вещи, которые ставят под угрозу безопасность пользователей и остаются незамеченными.

Публикация файлов исходного кода смарт-контракта облегчает заинтересованным сторонам, таким как аудиторы, оценку контракта на предмет потенциальных векторов атаки. Когда несколько сторон независимо друг от друга верифицируют смарт-контракт, пользователи получают более надежные гарантии его безопасности.

## Как верифицировать исходный код для смарт-контрактов Ethereum {#source-code-verification-for-ethereum-smart-contracts}

[Развертывание смарт-контракта в Ethereum](/developers/docs/smart-contracts/deploying/) требует отправки транзакции с полезной нагрузкой данных (скомпилированным байт-кодом) на специальный адрес. Полезная нагрузка данных генерируется путем компиляции исходного кода, а также [аргументы конструктора](https://docs.soliditylang.org/en/v0.8.14/contracts.html#constructor) экземпляра контракта, добавляемые к полезной нагрузке данных в транзакции. Компиляция детерминирована, то есть она всегда дает один и тот же результат (т. е. байт-код контракта), если используются одни и те же исходные файлы и параметры компиляции (например, версия компилятора, оптимизатор).

![Диаграмма, показывающая верификацию исходного кода смарт-контракта](./source-code-verification.png)

Верификация смарт-контракта в основном включает в себя следующие шаги:

1. Передача исходных файлов и параметров компиляции в компилятор.

2. Компилятор выводит байт-код контракта

3. Получение байт-кода развернутого контракта по заданному адресу

4. Сравнение развернутого байт-кода с перекомпилированным байт-кодом. Если коды совпадают, контракт верифицируется с заданным исходным кодом и настройками компиляции.

5. Кроме того, если хэши метаданных в конце байт-кода совпадают, это будет полное совпадение.

Обратите внимание, что это упрощенное описание верификации, и существует множество исключений, которые с ним не сработают, например, наличие [неизменяемых переменных](https://docs.sourcify.dev/docs/immutables/).

## Инструменты верификации исходного кода {#source-code-verification-tools}

Традиционный процесс верификации контрактов может быть сложным. Вот почему у нас есть инструменты для верификации исходного кода смарт-контрактов, развернутых в Ethereum. Эти инструменты автоматизируют большую часть верификации исходного кода, а также курируют верифицированные контракты для удобства пользователей.

### Etherscan {#etherscan}

Хотя Etherscan в основном известен как [обозреватель блокчейна Ethereum](/developers/docs/data-and-analytics/block-explorers/), он также предлагает [сервис верификации исходного кода](https://etherscan.io/verifyContract) для разработчиков и пользователей смарт-контрактов.

Etherscan позволяет перекомпилировать байт-код контракта из исходной полезной нагрузки данных (исходный код, адрес библиотеки, настройки компилятора, адрес контракта и т. д.) Если перекомпилированный байт-код связан с байт-кодом (и параметрами конструктора) ончейн-контракта, то [контракт считается верифицированным](https://info.etherscan.com/types-of-contract-verification/).

После верификации исходный код вашего контракта получает метку «Verified» и публикуется на Etherscan, чтобы другие могли его проверить. Он также добавляется в раздел [Verified Contracts](https://etherscan.io/contractsVerified/) — репозиторий смарт-контрактов с верифицированным исходным кодом.

Etherscan — самый используемый инструмент для верификации контрактов. Однако верификация контрактов на Etherscan имеет недостаток: она не сравнивает **хэш метаданных** ончейн-байт-кода и перекомпилированного байт-кода. Поэтому совпадения в Etherscan являются частичными.

[Подробнее о верификации контрактов на Etherscan](https://medium.com/etherscan-blog/verifying-contracts-on-etherscan-f995ab772327).

### Blockscout {#blockscout}

[Blockscout](https://blockscout.com/) — это обозреватель блокчейна с открытым исходным кодом, который также предоставляет [сервис верификации контрактов](https://eth.blockscout.com/contract-verification) для разработчиков и пользователей смарт-контрактов. Как альтернатива с открытым исходным кодом, Blockscout предлагает прозрачность в том, как выполняется верификация, и позволяет сообществу вносить свой вклад в улучшение процесса верификации.

Подобно другим сервисам верификации, Blockscout позволяет вам верифицировать исходный код вашего контракта, перекомпилировав байт-код и сравнив его с развернутым контрактом. После верификации ваш контракт получает статус верификации, а исходный код становится общедоступным для аудита и взаимодействия. Верифицированные контракты также перечислены в [репозитории верифицированных контрактов](https://eth.blockscout.com/verified-contracts) Blockscout для удобного просмотра и поиска.

### Sourcify {#sourcify}

[Sourcify](https://sourcify.dev/#/verifier) — еще один инструмент для верификации контрактов с открытым исходным кодом, который является децентрализованным. Это не обозреватель блоков, он верифицирует контракты только в [различных сетях на базе EVM](https://docs.sourcify.dev/docs/chains). Он действует как публичная инфраструктура, на основе которой другие инструменты могут создавать свои решения, и нацелен на обеспечение более удобного для человека взаимодействия с контрактами с использованием комментариев [ABI](/developers/docs/smart-contracts/compiling/#web-applications) и [NatSpec](https://docs.soliditylang.org/en/v0.8.15/natspec-format.html), содержащихся в файле метаданных.

В отличие от Etherscan, Sourcify поддерживает полные совпадения с хэшем метаданных. Верифицированные контракты обслуживаются в его [публичном репозитории](https://docs.sourcify.dev/docs/repository/) по HTTP и [IPFS](https://docs.ipfs.io/concepts/what-is-ipfs/#what-is-ipfs), которое является децентрализованным [хранилищем с адресацией по содержимому](https://docs.storacha.network/concepts/content-addressing/). Это позволяет получать файл метаданных контракта через IPFS, поскольку добавленный хэш метаданных является хэшем IPFS.

Кроме того, можно также получить файлы исходного кода через IPFS, так как хэши IPFS этих файлов также находятся в метаданных. Контракт можно верифицировать, предоставив файл метаданных и исходные файлы через его API или [пользовательский интерфейс](https://sourcify.dev/#/verifier), или с помощью плагинов. Инструмент мониторинга Sourcify также отслеживает создание контрактов в новых блоках и пытается верифицировать контракты, если их метаданные и исходные файлы опубликованы на IPFS.

[Подробнее о верификации контрактов на Sourcify](https://soliditylang.org/blog/2020/06/25/sourcify-faq/).

### Tenderly {#tenderly}

[Платформа Tenderly](https://tenderly.co/) позволяет разработчикам Web3 создавать, тестировать, отслеживать и эксплуатировать смарт-контракты. Сочетая инструменты отладки с наблюдаемостью и стандартными элементами для создания инфраструктуры, Tenderly помогает разработчикам ускорить разработку смарт-контрактов. Чтобы полностью использовать функции Tenderly, разработчикам необходимо [выполнить верификацию исходного кода](https://docs.tenderly.co/monitoring/contract-verification) с помощью нескольких методов.

Верифицировать контракт можно в частном или публичном порядке. Если верификация частная, смарт-контракт виден только вам (и другим членам вашего проекта). Публичная верификация контракта делает его видимым для всех, кто использует платформу Tenderly.

Вы можете верифицировать свои контракты с помощью [панели управления](https://docs.tenderly.co/contract-verification), [плагина Tenderly для Hardhat](https://docs.tenderly.co/contract-verification/hardhat) или [интерфейса командной строки](https://docs.tenderly.co/monitoring/smart-contract-verification/verifying-contracts-using-cli).

При верификации контрактов через панель управления вам необходимо импортировать исходный файл или файл метаданных, сгенерированный компилятором Solidity, адрес/сеть и настройки компилятора.

Использование плагина Tenderly для Hardhat позволяет лучше контролировать процесс верификации с меньшими усилиями, давая вам возможность выбирать между автоматической (без кода) и ручной (на основе кода) верификацией.

## Дополнительные материалы {#further-reading}

- [Верификация исходного кода контракта](https://programtheblockchain.com/posts/2018/01/16/verifying-contract-source-code/)
