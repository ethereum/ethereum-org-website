---
title: Безопасность умных контрактов
description: Обзор руководящих принципов по созданию безопасных смарт-контрактов с помощью технологии Ethereum
lang: ru
---

Умные контракты чрезвычайно гибки и способны контролировать большие объемы ценностей и данных, выполняя при этом неизменяемую логику на основе кода, развернутого в блокчейне. Это привело к созданию активной экосистемы децентрализованных приложений, не требующих доверия, которые предоставляют множество преимуществ по сравнению с устаревшими системами. Они также предоставляют возможности для атакующих, которые хотят получить прибыль, используя уязвимости в умных контрактах.

Публичные блокчейны, такие как Ethereum, еще больше усложняют задачу обеспечения безопасности умных контрактов. Развернутый код контракта _обычно_ не может быть изменен для исправления недостатков безопасности, в то время как активы, украденные из умных контрактов, чрезвычайно трудно отследить и в основном невозможно восстановить из-за их неизменности.

Хотя цифры разнятся, по оценкам, общая сумма украденных или потерянных ценностей из-за дефектов безопасности в умных контрактах легко превышает 1 миллиард долларов. Сюда входят громкие инциденты, такие как [взлом DAO](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/) (украдено 3,6 млн ETH, что по сегодняшним ценам составляет более 1 млрд долларов), [взлом кошелька с мультиподписью Parity](https://www.coindesk.com/markets/2017/07/19/30-million-ether-reported-stolen-due-to-parity-wallet-breach) (хакеры похитили 30 млн долларов) и [проблема с замороженным кошельком Parity](https://www.theguardian.com/technology/2017/nov/08/cryptocurrency-300m-dollars-stolen-bug-ether) (более 300 млн долларов в ETH заблокированы навсегда).

Вышеупомянутые проблемы обязывают разработчиков прикладывать усилия для создания безопасных, надежных и отказоустойчивых умных контрактов. Безопасность умных контрактов — это серьезное дело, и каждому разработчику будет полезно его изучить. В этом руководстве будут рассмотрены аспекты безопасности для разработчиков Ethereum и изучены ресурсы для повышения безопасности умных контрактов.

## Предварительные условия {#prerequisites}

Прежде чем приступать к изучению вопросов безопасности, убедитесь, что вы знакомы с [основами разработки умных контрактов](/developers/docs/smart-contracts/).

## Руководство по созданию безопасных умных контрактов Ethereum {#smart-contract-security-guidelines}

### 1. Разработка надлежащих средств контроля доступа {#design-proper-access-controls}

В умных контрактах функции, помеченные как `public` или `external`, могут вызываться любыми внешними аккаунтами (EOA) или аккаунтами контрактов. Указание публичной видимости для функций необходимо, если вы хотите, чтобы другие могли взаимодействовать с вашим контрактом. Однако функции, помеченные как `private`, могут вызываться только функциями внутри умного контракта, а не внешними аккаунтами. Предоставление каждому участнику сети доступа к функциям контракта может вызвать проблемы, особенно если это означает, что кто угодно может выполнять конфиденциальные операции (например, чеканку новых токенов).

Чтобы предотвратить несанкционированное использование функций умного контракта, необходимо внедрить безопасные средства контроля доступа. Механизмы контроля доступа ограничивают возможность использования определенных функций в умном контракте только для утвержденных субъектов, таких как аккаунты, ответственные за управление контрактом. Патерн **Ownable** и **управление на основе ролей** — это два полезных патерна для реализации контроля доступа в умных контрактах:

#### Патерн Ownable {#ownable-pattern}

В патерне Ownable во время создания контракта один адрес назначается его «владельцем». Защищенным функциям присваивается модификатор `OnlyOwner`, который гарантирует, что контракт аутентифицирует личность вызывающего адреса перед выполнением функции. Вызовы защищенных функций с адресов, отличных от адреса владельца контракта, всегда отменяются, что предотвращает нежелательный доступ.

#### Управление доступом на основе ролей {#role-based-access-control}

Регистрация одного адреса в качестве `Owner` (владельца) в умном контракте создает риск централизации и представляет собой единую точку отказа. Если ключи аккаунта владельца будут скомпрометированы, атакующие смогут атаковать принадлежащий ему контракт. Вот почему использование патерна управления доступом на основе ролей с несколькими административными аккаунтами может быть лучшим вариантом.

При управлении доступом на основе ролей доступ к конфиденциальным функциям распределяется между набором доверенных участников. Например, один аккаунт может отвечать за чеканку токенов, а другой — за выполнение обновлений или приостановку контракта. Такая децентрализация контроля доступа устраняет единые точки отказа и снижает требования к доверию для пользователей.

##### Использование кошельков с мультиподписью

Другой подход к реализации безопасного контроля доступа — использование [аккаунта с мультиподписью](/developers/docs/smart-contracts/#multisig) для управления контрактом. В отличие от обычного EOA, аккаунты с мультиподписью принадлежат нескольким субъектам и требуют для выполнения транзакций подписи от минимального числа аккаунтов, например, 3 из 5.

Использование мультиподписи для контроля доступа добавляет дополнительный уровень безопасности, поскольку действия с целевым контрактом требуют согласия нескольких сторон. Это особенно полезно, если необходимо использовать патерн Ownable, поскольку это затрудняет для атакующего или недобросовестного инсайдера манипулирование конфиденциальными функциями контракта в злонамеренных целях.

### 2. Используйте операторы require(), assert() и revert() для защиты операций контракта {#use-require-assert-revert}

Как уже упоминалось, любой может вызывать публичные функции в вашем умном контракте после его развертывания в блокчейне. Поскольку вы не можете заранее знать, как внешние аккаунты будут взаимодействовать с контрактом, перед развертыванием идеально реализовать внутренние меры защиты от проблемных операций. Вы можете обеспечить правильное поведение в умных контрактах, используя операторы `require()`, `assert()` и `revert()` для вызова исключений и отмены изменений состояния, если выполнение не удовлетворяет определенным требованиям.

**`require()`**: `require` определяется в начале функций и гарантирует, что предварительно определенные условия выполнены до того, как будет выполнена вызываемая функция. Оператор `require` может использоваться для проверки вводимых пользователем данных, проверки переменных состояния или аутентификации личности вызывающего аккаунта перед продолжением выполнения функции.

**`assert()`**: `assert()` используется для обнаружения внутренних ошибок и проверки нарушений «инвариантов» в вашем коде. Инвариант — это логическое утверждение о состоянии контракта, которое должно оставаться истинным для всех выполнений функций. Инвариантным примером является максимальное общее предложение или баланс токенового контракта. Использование `assert()` гарантирует, что ваш контракт никогда не перейдет в уязвимое состояние, а если это произойдет, все изменения переменных состояния будут отменены.

**`revert()`**: `revert()` может использоваться в операторе if-else, который вызывает исключение, если требуемое условие не выполняется. В приведенном ниже примере контракта для защиты выполнения функций используется `revert()`:

```
pragma solidity ^0.8.4;

contract VendingMachine {
    address owner;
    error Unauthorized();
    function buy(uint amount) public payable {
        if (amount > msg.value / 2 ether)
            revert("Предоставлено недостаточно Ether.");
        // Выполнение покупки.
    }
    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}
```

### 3. Тестируйте умные контракты и проверяйте правильность кода {#test-smart-contracts-and-verify-code-correctness}

Неизменность кода, работающего в [виртуальной машине Ethereum](/developers/docs/evm/), означает, что умные контракты требуют более высокого уровня оценки качества на этапе разработки. Тщательное тестирование вашего контракта и отслеживание любых непредвиденных результатов значительно повысит безопасность и защитит ваших пользователей в долгосрочной перспективе.

Обычный метод — это написание небольших модульных тестов с использованием фиктивных данных, которые контракт, как ожидается, будет получать от пользователей. [Модульное тестирование](/developers/docs/smart-contracts/testing/#unit-testing) хорошо подходит для тестирования функциональности определенных функций и обеспечения того, чтобы умный контракт работал так, как ожидается.

К сожалению, модульное тестирование минимально эффективно для повышения безопасности умных контрактов при его изолированном использовании. Модульный тест может доказать, что функция выполняется правильно для фиктивных данных, но модульные тесты эффективны лишь настолько, насколько эффективны написанные тесты. Это затрудняет обнаружение пропущенных пограничных случаев и уязвимостей, которые могут нарушить безопасность вашего умного контракта.

Лучший подход — это сочетание модульного тестирования с тестированием на основе свойств, выполняемым с использованием [статического и динамического анализа](/developers/docs/smart-contracts/testing/#static-dynamic-analysis). Статический анализ опирается на низкоуровневые представления, такие как [графы потоков управления](https://en.wikipedia.org/wiki/Control-flow_graph) и [абстрактные синтаксические деревья](https://deepsource.io/glossary/ast/), для анализа достижимых состояний программы и путей выполнения. В то же время методы динамического анализа, такие как [фаззинг умных контрактов](https://www.cyfrin.io/blog/smart-contract-fuzzing-and-invariants-testing-foundry), выполняют код контракта со случайными входными значениями для обнаружения операций, нарушающих свойства безопасности.

[Формальная верификация](/developers/docs/smart-contracts/formal-verification) — это еще один метод проверки свойств безопасности в умных контрактах. В отличие от обычного тестирования, формальная верификация может убедительно доказать отсутствие ошибок в умном контракте. Это достигается путем создания формальной спецификации, которая отражает желаемые свойства безопасности, и доказательства того, что формальная модель контрактов соответствует этой спецификации.

### 4. Запросите независимую проверку вашего кода {#get-independent-code-reviews}

После того как Вы протестировали ваш контракт, хорошей идеей будет попросить других проверить исходный код на наличие проблем с безопасностью. Тестирование не сможет выявить все возможные недостатки смарт-контракта, но независимый аудит повышает вероятность того, что уязвимости будут обнаружены.

#### Аудиты {#audits}

Заказ аудита умного контракта — это один из способов проведения независимой проверки кода. Аудиторы играют важную роль в обеспечении безопасности умных контрактов и отсутствия в них дефектов качества и ошибок проектирования.

Тем не менее, не следует относиться к аудитам как к панацее. Аудиты умных контрактов не выявляют все ошибки и в основном предназначены для проведения дополнительного раунда проверок, который может помочь обнаружить проблемы, пропущенные разработчиками на начальных этапах разработки и тестирования. Вы также должны следовать лучшим практикам работы с аудиторами, таким как правильное документирование кода и добавление встроенных комментариев, чтобы извлечь максимальную пользу из аудита умного контракта.

- [Советы и хитрости по аудиту умных контрактов](https://twitter.com/tinchoabbate/status/1400170232904400897) — _@tinchoabbate_
- [Получите максимум от вашего аудита](https://inference.ag/blog/2023-08-14-tips/) — _Inference_

#### Вознаграждения за обнаружение ошибок {#bug-bounties}

Вознаграждения за обнаружение уязвимостей — ещё один способ проведения независимого аудита. Премией за обнаружение уязвимостей награждаются люди (обычно этические хакеры, или «белые шляпы»), которые находят уязвимости в приложениях.

При верном использовании, такие вознаграждения мотивируют членов хакерского сообщества проверить ваш код на уязвимости. Реальным примером является «ошибка бесконечных денег», которая позволила бы атакующему создать неограниченное количество эфира на [Optimism](https://www.optimism.io/), протоколе [Леер 2](/layer-2/), работающем на Ethereum. К счастью, «белый» хакер [обнаружил уязвимость](https://www.saurik.com/optimism.html) и уведомил команду, [заработав при этом крупное вознаграждение](https://cryptoslate.com/critical-bug-in-ethereum-l2-optimism-2m-bounty-paid/).

Хорошая стратегия — установить размер выплат по программе bug bounty пропорционально сумме средств, за которую вы отвечаете. Этот подход, названный «[масштабируемая программа вознаграждения за обнаружение ошибок](https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7)», предоставляет финансовые стимулы для ответственного раскрытия уязвимостей вместо их эксплуатации.

### 5. Следуйте лучшим практикам при разработке умных контрактов {#follow-smart-contract-development-best-practices}

Наличие аудитов и программ вознаграждения за обнаружение ошибок не освобождает вас от ответственности писать высококачественный код. Хорошая безопасность умных контрактов начинается с соблюдения надлежащих процессов проектирования и разработки:

- Храните весь код в системе контроля версий, такой как git

- Вносите все изменения в код через запросы на слияние

- Убедитесь, что запросы на слияние имеют хотя бы одного независимого рецензента — если вы работаете над проектом в одиночку, рассмотрите возможность найти других разработчиков и обмениваться с ними проверками кода

- Используйте [среду разработки](/developers/docs/frameworks/) для тестирования, компиляции и развертывания умных контрактов

- Прогоняйте свой код через базовые инструменты анализа кода, такие как [Cyfrin Aderyn](https://github.com/Cyfrin/aderyn), Mythril и Slither. В идеале это следует делать перед слиянием каждого запроса на слияние и сравнивать различия в результатах

- Убедитесь, что ваш код компилируется без ошибок и компилятор Solidity не выдает предупреждений

- Правильно документируйте свой код (используя [NatSpec](https://solidity.readthedocs.io/en/develop/natspec-format.html)) и описывайте детали архитектуры контракта на понятном языке. Это облегчит аудит и проверку вашего кода другими людьми.

### 6. Внедряйте надежные планы аварийного восстановления {#implement-disaster-recovery-plans}

Разработка безопасных средств контроля доступа, реализация модификаторов функций и другие предложения могут улучшить безопасность умных контрактов, но они не могут исключить возможность злонамеренных эксплойтов. Создание безопасных умных контрактов требует «подготовки к сбоям» и наличия запасного плана для эффективного реагирования на атаки. Надлежащий план аварийного восстановления будет включать некоторые или все из следующих компонентов:

#### Обновления контрактов {#contract-upgrades}

Хотя умные контракты Ethereum по умолчанию неизменяемы, можно достичь некоторой степени изменяемости, используя патерны обновления. Обновление контрактов необходимо в тех случаях, когда критическая уязвимость делает ваш старый контракт непригодным для использования, и развертывание новой логики является наиболее целесообразным вариантом.

Механизмы обновления контрактов работают по-разному, но «патерн прокси» является одним из наиболее популярных подходов к обновлению умных контрактов. [Патерны прокси](https://www.cyfrin.io/blog/upgradeable-proxy-smart-contract-pattern) разделяют состояние и логику приложения между _двумя_ контрактами. Первый контракт (называемый «прокси-контракт») хранит переменные состояния (например, балансы пользователей), в то время как второй контракт (называемый «логический контракт») содержит код для выполнения функций контракта.

Аккаунты взаимодействуют с прокси-контрактом, который перенаправляет все вызовы функций логическому контракту с помощью низкоуровневого вызова [`delegatecall()`](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries). В отличие от обычного вызова сообщения, `delegatecall()` гарантирует, что код, работающий по адресу логического контракта, выполняется в контексте вызывающего контракта. Это означает, что логический контракт всегда будет записывать данные в хранилище прокси-контракта (а не в свое собственное хранилище), а исходные значения `msg.sender` и `msg.value` сохраняются.

Делегирование вызовов логическому контракту требует хранения его адреса в хранилище прокси-контракта. Следовательно, обновление логики контракта — это всего лишь вопрос развертывания другого логического контракта и сохранения нового адреса в прокси-контракте. Поскольку последующие вызовы прокси-контракта автоматически направляются на новый логический контракт, вы «обновите» контракт, фактически не изменяя код.

[Подробнее об обновлении контрактов](/developers/docs/smart-contracts/upgrading/).

#### Аварийные остановки {#emergency-stops}

Как уже упоминалось, обширный аудит и тестирование не могут выявить все ошибки в умном контракте. Если после развертывания в вашем коде появляется уязвимость, исправить ее невозможно, поскольку вы не можете изменить код, работающий по адресу контракта. Кроме того, внедрение механизмов обновления (например, патернов прокси) может занять время (они часто требуют одобрения от разных сторон), что только дает атакующим больше времени для нанесения большего ущерба.

Кардинальным решением является реализация функции «аварийной остановки», которая блокирует вызовы уязвимых функций в контракте. Аварийные остановки обычно включают следующие компоненты:

1. Глобальная логическая переменная, указывающая, находится ли умный контракт в остановленном состоянии или нет. Эта переменная устанавливается в значение `false` при настройке контракта, но изменится на `true` после остановки контракта.

2. Функции, которые ссылаются на логическую переменную при своем выполнении. Такие функции доступны, когда умный контракт не остановлен, и становятся недоступными при срабатывании функции аварийной остановки.

3. Сущность, имеющая доступ к функции аварийной остановки, которая устанавливает логическую переменную в значение `true`. Для предотвращения злонамеренных действий вызовы этой функции могут быть ограничены доверенным адресом (например, владельцем контракта).

После того, как контракт активирует аварийную остановку, определенные функции станут недоступными для вызова. Это достигается путем обертывания избранных функций в модификатор, который ссылается на глобальную переменную. Ниже приведен [пример](https://github.com/fravoll/solidity-patterns/blob/master/EmergencyStop/EmergencyStop.sol), описывающий реализацию этого патерна в контрактах:

```solidity
// Этот код не прошел профессиональный аудит и не дает никаких гарантий безопасности или корректности. Используйте на свой страх и риск.

contract EmergencyStop {

    bool isStopped = false;

    modifier stoppedInEmergency {
        require(!isStopped);
        _;
    }

    modifier onlyWhenStopped {
        require(isStopped);
        _;
    }

    modifier onlyAuthorized {
        // Здесь проверьте авторизацию msg.sender
        _;
    }

    function stopContract() public onlyAuthorized {
        isStopped = true;
    }

    function resumeContract() public onlyAuthorized {
        isStopped = false;
    }

    function deposit() public payable stoppedInEmergency {
        // Здесь происходит логика депозита
    }

    function emergencyWithdraw() public onlyWhenStopped {
        // Здесь происходит экстренный вывод средств
    }
}
```

Этот пример показывает основные особенности аварийных остановок:

- `isStopped` — это логическая переменная, которая в начале имеет значение `false`, а когда контракт переходит в аварийный режим, — `true`.

- Модификаторы функций `onlyWhenStopped` и `stoppedInEmergency` проверяют переменную `isStopped`. `stoppedInEmergency` используется для управления функциями, которые должны быть недоступны, когда контракт уязвим (например, `deposit()`). Вызовы этих функций будут просто отменены.

`onlyWhenStopped` используется для функций, которые должны быть доступны для вызова во время чрезвычайной ситуации (например, `emergencyWithdraw()`). Такие функции могут помочь разрешить ситуацию, поэтому они исключены из списка «ограниченных функций».

Использование функциональности аварийной остановки обеспечивает эффективное временное решение для борьбы с серьезными уязвимостями в вашем умном контракте. Однако это увеличивает потребность пользователей доверять разработчикам, чтобы те не активировали ее в корыстных целях. Для этого возможными решениями являются децентрализация контроля над аварийной остановкой либо путем подчинения ее механизму ончейн-голосования, временной блокировке, либо одобрению с помощью кошелька с мультиподписью.

#### Мониторинг событий {#event-monitoring}

[События](https://docs.soliditylang.org/en/v0.8.15/contracts.html#events) позволяют отслеживать вызовы функций умного контракта и контролировать изменения переменных состояния. Идеально запрограммировать ваш умный контракт так, чтобы он генерировал событие всякий раз, когда какая-либо сторона предпринимает критически важное для безопасности действие (например, вывод средств).

Регистрация событий и их мониторинг вне сети (оффчейн) дают представление об операциях контракта и способствуют более быстрому обнаружению злонамеренных действий. Это означает, что ваша команда может быстрее реагировать на взломы и принимать меры для смягчения последствий для пользователей, такие как приостановка функций или выполнение обновления.

Вы также можете выбрать готовый инструмент мониторинга, который автоматически пересылает оповещения всякий раз, когда кто-то взаимодействует с вашими контрактами. Эти инструменты позволят вам создавать настраиваемые оповещения на основе различных триггеров, таких как объем транзакций, частота вызовов функций или конкретные задействованные функции. Например, вы можете запрограммировать оповещение, которое приходит, когда сумма, выведенная в одной транзакции, превышает определенный порог.

### 7. Проектирование безопасных систем управления {#design-secure-governance-systems}

Вы можете захотеть децентрализовать свое приложение, передав контроль над основными умными контрактами членам сообщества. В этом случае система умных контрактов будет включать модуль управления — механизм, который позволяет членам сообщества одобрять административные действия через ончейн-систему управления. Например, предложение обновить прокси-контракт до новой реализации может быть вынесено на голосование держателей токенов.

Децентрализованное управление может быть полезным, особенно потому, что оно согласовывает интересы разработчиков и конечных пользователей. Тем не менее, механизмы управления умными контрактами могут создавать новые риски при неправильной реализации. Возможный сценарий — если атакующий приобретает огромную голосующую силу (измеряемую в количестве имеющихся токенов), взяв [срочный заем](/defi/#flash-loans), и проталкивает вредоносное предложение.

Один из способов предотвращения проблем, связанных с ончейн-управлением, — [использование временной блокировки](https://blog.openzeppelin.com/protect-your-users-with-smart-contract-timelocks/). Временная блокировка не позволяет умному контракту выполнять определенные действия до истечения определенного времени. Другие стратегии включают присвоение «веса голоса» каждому токену в зависимости от того, как долго он был заблокирован, или измерение голосующей силы адреса в исторический период (например, 2-3 блока в прошлом) вместо текущего блока. Оба метода снижают вероятность быстрого накопления голосующей силы для влияния на результаты ончейн-голосований.

Подробнее о [проектировании безопасных систем управления](https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/), [различных механизмах голосования в DAO](https://hackernoon.com/governance-is-the-holy-grail-for-daos) и [распространенных векторах атак на DAO с использованием DeFi](https://dacian.me/dao-governance-defi-attacks) по приведенным ссылкам.

### 8. Сведите сложность кода к минимуму {#reduce-code-complexity}

Традиционные разработчики программного обеспечения знакомы с принципом KISS («делай проще, дурак»), который советует избегать ненужной сложности в проектировании программного обеспечения. Это следует из давнего убеждения, что «сложные системы дают сбой сложными способами» и более подвержены дорогостоящим ошибкам.

Простота особенно важна при написании умных контрактов, учитывая, что они потенциально контролируют большие объемы ценностей. Совет по достижению простоты при написании умных контрактов — по возможности повторно использовать существующие библиотеки, такие как [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/). Поскольку эти библиотеки были тщательно проверены и протестированы разработчиками, их использование снижает вероятность появления ошибок при написании новой функциональности с нуля.

Еще один распространенный совет — писать небольшие функции и сохранять модульность контрактов, разделяя бизнес-логику между несколькими контрактами. Написание более простого кода не только уменьшает поверхность атаки в умном контракте, но и облегчает рассуждения о корректности всей системы и раннее обнаружение возможных ошибок проектирования.

### 9. Защита от распространенных уязвимостей умных контрактов {#mitigate-common-smart-contract-vulnerabilities}

#### Повторный вход {#reentrancy}

EVM не допускает параллелизма, то есть два контракта, участвующие в вызове сообщения, не могут выполняться одновременно. Внешний вызов приостанавливает выполнение вызывающего контракта и его память до тех пор, пока вызов не вернется, после чего выполнение продолжается в обычном режиме. Этот процесс можно формально описать как передачу [потока управления](https://www.computerhope.com/jargon/c/contflow.htm) другому контракту.

Хотя в основном это безвредно, передача потока управления ненадежным контрактам может вызвать проблемы, такие как повторный вход. Атака повторного входа происходит, когда вредоносный контракт вызывает уязвимый контракт до того, как завершится первоначальный вызов функции. Этот тип атаки лучше всего объяснить на примере.

Рассмотрим простой умный контракт («Victim»), который позволяет любому вносить и выводить эфир:

```solidity
// Этот контракт уязвим. Не используйте в продакшене

contract Victim {
    mapping (address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

Этот контракт предоставляет функцию `withdraw()`, позволяющую пользователям выводить ETH, ранее внесенные в контракт. При обработке вывода средств контракт выполняет следующие операции:

1. Проверяет баланс ETH пользователя
2. Отправляет средства на вызывающий адрес
3. Сбрасывает их баланс до 0, предотвращая дальнейшие выводы средств пользователем

Функция `withdraw()` в контракте `Victim` следует патерну «проверки-взаимодействия-эффекты». Она _проверяет_, выполнены ли условия, необходимые для выполнения (т. е. у пользователя положительный баланс ETH), и выполняет _взаимодействие_, отправляя ETH на адрес вызывающего, прежде чем применить _эффекты_ транзакции (т. е. уменьшить баланс пользователя).

Если `withdraw()` вызывается из внешнего аккаунта (EOA), функция выполняется, как и ожидалось: `msg.sender.call.value()` отправляет ETH вызывающему. Однако, если `msg.sender` является аккаунтом умного контракта и вызывает `withdraw()`, отправка средств с помощью `msg.sender.call.value()` также вызовет запуск кода, хранящегося по этому адресу.

Представьте, что по адресу контракта развернут следующий код:

```solidity
 contract Attacker {
    function beginAttack() external payable {
        Victim(victim_address).deposit.value(1 ether)();
        Victim(victim_address).withdraw();
    }

    function() external payable {
        if (gasleft() > 40000) {
            Victim(victim_address).withdraw();
        }
    }
}
```

Этот контракт предназначен для выполнения трех действий:

1. Принять депозит с другого аккаунта (вероятно, EOA атакующего)
2. Внести 1 ETH в контракт Victim
3. Вывести 1 ETH, хранящийся в умном контракте

Здесь нет ничего плохого, за исключением того, что у `Attacker` есть еще одна функция, которая снова вызывает `withdraw()` в `Victim`, если оставшегося газа от входящего `msg.sender.call.value` больше 40 000. Это дает `Attacker` возможность повторно войти в `Victim` и вывести больше средств _до_ завершения первого вызова `withdraw`. Цикл выглядит следующим образом:

```solidity
- EOA атакующего вызывает `Attacker.beginAttack()` с 1 ETH
- `Attacker.beginAttack()` вносит 1 ETH в `Victim`
- `Attacker` вызывает `withdraw()` в `Victim`
- `Victim` проверяет баланс `Attacker` (1 ETH)
- `Victim` отправляет 1 ETH в `Attacker` (что вызывает функцию по умолчанию)
- `Attacker` снова вызывает `Victim.withdraw()` (обратите внимание, что `Victim` не уменьшил баланс `Attacker` после первого вывода средств)
- `Victim` проверяет баланс `Attacker` (который все еще составляет 1 ETH, потому что он не применил эффекты первого вызова)
- `Victim` отправляет 1 ETH в `Attacker` (что вызывает функцию по умолчанию и позволяет `Attacker` повторно войти в функцию `withdraw`)
- Процесс повторяется до тех пор, пока у `Attacker` не закончится газ, после чего `msg.sender.call.value` возвращается, не вызывая дополнительных выводов средств
- `Victim` наконец применяет результаты первой транзакции (и последующих) к своему состоянию, поэтому баланс `Attacker` устанавливается в 0
```

Суть в том, что, поскольку баланс вызывающего не устанавливается в 0 до завершения выполнения функции, последующие вызовы будут успешными и позволят вызывающему вывести свой баланс несколько раз. Такой тип атаки может быть использован для опустошения умного контракта, как это произошло во время [взлома DAO в 2016 году](https://www.coindesk.com/learn/understanding-the-dao-attack). Атаки повторного входа до сих пор остаются критической проблемой для умных контрактов, как показывают [публичные списки эксплойтов повторного входа](https://github.com/pcaversaccio/reentrancy-attacks).

##### Как предотвратить атаки повторного входа

Один из подходов к борьбе с повторным входом — следование [патерну «проверки-эффекты-взаимодействия»](https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern). Этот патерн упорядочивает выполнение функций таким образом, что код, выполняющий необходимые проверки перед продолжением выполнения, идет первым, за ним следует код, который манипулирует состоянием контракта, а код, взаимодействующий с другими контрактами или EOA, идет последним.

Патерн «проверки-эффект-взаимодействие» используется в исправленной версии контракта `Victim`, показанной ниже:

```solidity
contract NoLongerAVictim {
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
    }
}
```

Этот контракт выполняет _проверку_ баланса пользователя, применяет _эффекты_ функции `withdraw()` (сбрасывая баланс пользователя до 0) и переходит к _взаимодействию_ (отправке ETH на адрес пользователя). Это гарантирует, что контракт обновит свое хранилище до внешнего вызова, устраняя условие повторного входа, которое сделало возможной первую атаку. Контракт `Attacker` все еще мог бы вызвать `NoLongerAVictim`, но поскольку `balances[msg.sender]` был установлен в 0, дополнительные выводы средств вызовут ошибку.

Другой вариант — использовать блокировку взаимного исключения (обычно описываемую как «мьютекс»), которая блокирует часть состояния контракта до завершения вызова функции. Это реализуется с помощью логической переменной, которая устанавливается в `true` перед выполнением функции и возвращается в `false` после завершения вызова. Как видно из примера ниже, использование мьютекса защищает функцию от рекурсивных вызовов во время обработки исходного вызова, эффективно останавливая повторный вход.

```solidity
pragma solidity ^0.7.0;

contract MutexPattern {
    bool locked = false;
    mapping(address => uint256) public balances;

    modifier noReentrancy() {
        require(!locked, "Заблокировано от повторного входа.");
        locked = true;
        _;
        locked = false;
    }
    // Эта функция защищена мьютексом, поэтому повторные вызовы из `msg.sender.call` не могут снова вызвать `withdraw`.
    //  Оператор `return` возвращает `true`, но все равно выполняет оператор `locked = false` в модификаторе
    function withdraw(uint _amount) public payable noReentrancy returns(bool) {
        require(balances[msg.sender] >= _amount, "Нет баланса для вывода.");

        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success);

        return true;
    }
}
```

Вы также можете использовать систему [pull payments](https://docs.openzeppelin.com/contracts/5.x/api/security#PullPayment), которая требует от пользователей вывода средств из умных контрактов, вместо системы «push payments», которая отправляет средства на аккаунты. Это исключает возможность непреднамеренного запуска кода по неизвестным адресам (а также может предотвратить некоторые атаки типа «отказ в обслуживании»).

#### Целочисленные недополнения и переполнения {#integer-underflows-and-overflows}

Целочисленное переполнение происходит, когда результат арифметической операции выходит за пределы допустимого диапазона значений, что приводит к его «перебросу» на наименьшее представимое значение. Например, `uint8` может хранить значения только до 2^8-1=255. Арифметические операции, которые приводят к значениям выше `255`, переполнятся и сбросят `uint` до `0`, подобно тому, как одометр на автомобиле сбрасывается до 0, как только он достигает максимального пробега (999999).

Целочисленные недополнения происходят по схожим причинам: результат арифметической операции оказывается ниже допустимого диапазона. Допустим, вы попытались уменьшить `0` в `uint8`, результат просто перескочит на максимальное представимое значение (`255`).

Как целочисленные переполнения, так и недополнения могут привести к неожиданным изменениям переменных состояния контракта и привести к незапланированному выполнению. Ниже приведен пример, показывающий, как атакующий может использовать арифметическое переполнение в умном контракте для выполнения недействительной операции:

```
pragma solidity ^0.7.6;

// Этот контракт предназначен для использования в качестве хранилища с временной блокировкой.
// Пользователь может вносить средства в этот контракт, но не может выводить их в течение как минимум недели.
// Пользователь также может продлить время ожидания сверх 1-недельного периода.

/*
1. Разверните TimeLock
2. Разверните Attack с адресом TimeLock
3. Вызовите Attack.attack, отправив 1 эфир. Вы сразу сможете
   вывести свой эфир.

Что произошло?
Атака вызвала переполнение TimeLock.lockTime, что позволило вывести средства
до истечения 1-недельного периода ожидания.
*/

contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "Недостаточно средств");
        require(block.timestamp > lockTime[msg.sender], "Время блокировки не истекло");

        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Не удалось отправить Ether");
    }
}

contract Attack {
    TimeLock timeLock;

    constructor(TimeLock _timeLock) {
        timeLock = TimeLock(_timeLock);
    }

    fallback() external payable {}

    function attack() public payable {
        timeLock.deposit{value: msg.value}();
        /*
        если t = текущее время блокировки, то нам нужно найти x, такое что
        x + t = 2**256 = 0
        тогда x = -t
        2**256 = type(uint).max + 1
        тогда x = type(uint).max + 1 - t
        */
        timeLock.increaseLockTime(
            type(uint).max + 1 - timeLock.lockTime(address(this))
        );
        timeLock.withdraw();
    }
}
```

##### Как предотвратить целочисленные недополнения и переполнения

Начиная с версии 0.8.0, компилятор Solidity отклоняет код, который приводит к целочисленным недополнениям и переполнениям. Однако контракты, скомпилированные с более низкой версией компилятора, должны либо выполнять проверки в функциях, включающих арифметические операции, либо использовать библиотеку (например, [SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math)), которая проверяет на недополнение/переполнение.

#### Манипуляция оракулом {#oracle-manipulation}

[Оракулы](/developers/docs/oracles/) получают информацию из оффчейн-источников и отправляют ее ончейн для использования умными контрактами. С помощью оракулов вы можете создавать умные контракты, которые взаимодействуют с оффчейн-системами, такими как рынки капитала, что значительно расширяет их применение.

Но если оракул поврежден и отправляет неверную информацию ончейн, умные контракты будут выполняться на основе ошибочных данных, что может вызвать проблемы. В этом заключается основа «проблемы оракула», которая касается задачи обеспечения того, чтобы информация от блокчейн-оракула была точной, актуальной и своевременной.

Связанная с этим проблема безопасности — использование ончейн-оракула, такого как децентрализованная биржа, для получения спотовой цены актива. Платформы кредитования в индустрии [децентрализованных финансов (DeFi)](/defi/) часто делают это для определения стоимости залога пользователя, чтобы определить, сколько он может занять.

Цены на DEX часто точны, в основном благодаря арбитражерам, восстанавливающим паритет на рынках. Однако они подвержены манипуляциям, особенно если ончейн-оракул рассчитывает цены активов на основе исторических торговых патернов (как это обычно бывает).

Например, атакующий может искусственно завысить спотовую цену актива, взяв срочный заем прямо перед взаимодействием с вашим кредитным контрактом. Запрос цены актива у DEX вернет значение выше нормального (из-за того, что крупный «ордер на покупку» атакующего исказил спрос на актив), что позволит ему занять больше, чем следовало бы. Такие «атаки со срочными займами» использовались для эксплуатации зависимости от ценовых оракулов среди приложений DeFi, что стоило протоколам миллионов потерянных средств.

##### Как предотвратить манипуляции оракулом

Минимальное требование для [избежания манипуляций с оракулом](https://www.cyfrin.io/blog/price-oracle-manipultion-attacks-with-examples) — использование децентрализованной сети оракулов, которая запрашивает информацию из нескольких источников, чтобы избежать единых точек отказа. В большинстве случаев децентрализованные оракулы имеют встроенные криптоэкономические стимулы для поощрения узлов оракула сообщать верную информацию, что делает их более безопасными, чем централизованные оракулы.

Если вы планируете запрашивать цену актива у ончейн-оракула, рассмотрите возможность использования того, который реализует механизм средневзвешенной по времени цены (TWAP). [Оракул TWAP](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) запрашивает цену актива в два разных момента времени (которые вы можете изменять) и рассчитывает спотовую цену на основе полученного среднего значения. Выбор более длительных периодов времени защищает ваш протокол от манипулирования ценами, поскольку крупные ордера, выполненные недавно, не могут повлиять на цены активов.

## Ресурсы по безопасности умных контрактов для разработчиков {#smart-contract-security-resources-for-developers}

### Инструменты для анализа умных контрактов и проверки правильности кода {#code-analysis-tools}

- **[Инструменты и библиотеки для тестирования](/developers/docs/smart-contracts/testing/#testing-tools-and-libraries)** — _Коллекция стандартных отраслевых инструментов и библиотек для выполнения модульных тестов, статического и динамического анализа умных контрактов._

- **[Инструменты формальной верификации](/developers/docs/smart-contracts/formal-verification/#formal-verification-tools)** — _Инструменты для проверки функциональной корректности в умных контрактах и проверки инвариантов._

- **[Сервисы аудита умных контрактов](/developers/docs/smart-contracts/testing/#smart-contract-auditing-services)** — _Список организаций, предоставляющих услуги по аудиту умных контрактов для проектов разработки на Ethereum._

- **[Платформы вознаграждений за обнаружение ошибок](/developers/docs/smart-contracts/testing/#bug-bounty-platforms)** — _Платформы для координации программ вознаграждений за обнаружение ошибок и поощрения ответственного раскрытия критических уязвимостей в умных контрактах._

- **[Fork Checker](https://forkchecker.hashex.org/)** — _бесплатный онлайн-инструмент для проверки всей доступной информации о форкнутом контракте._

- **[ABI Encoder](https://abi.hashex.org/)** — _бесплатный онлайн-сервис для кодирования функций вашего контракта Solidity и аргументов конструктора._

- **[Aderyn](https://github.com/Cyfrin/aderyn)** — статический анализатор Solidity, обходящий абстрактные синтаксические деревья (AST) для выявления предполагаемых уязвимостей и вывода проблем в удобном для восприятия формате Markdown.

### Инструменты для мониторинга умных контрактов {#smart-contract-monitoring-tools}

- **[Tenderly Real-Time Alerting](https://tenderly.co/monitoring)** — _инструмент для получения уведомлений в реальном времени о необычных или неожиданных событиях в ваших умных контрактах или кошельках._

### Инструменты для безопасного администрирования умных контрактов {#smart-contract-administration-tools}

- **[Safe](https://safe.global/)** — _кошелек на основе умного контракта, работающий на Ethereum, который требует одобрения транзакции минимальным количеством людей (M из N)._

- **[OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/)** — _библиотеки контрактов для реализации административных функций, включая владение контрактом, обновления, контроль доступа, управление, возможность приостановки и многое другое._

### Сервисы аудита умных контрактов {#smart-contract-auditing-services}

- **[ConsenSys Diligence](https://diligence.consensys.io/)** — _сервис аудита умных контрактов, помогающий проектам по всей экосистеме блокчейна убедиться, что их протоколы готовы к запуску и созданы для защиты пользователей._

- **[CertiK](https://www.certik.com/)** — _фирма по безопасности блокчейна, пионер в использовании передовых технологий формальной верификации на умных контрактах и блокчейн-сетях._

- **[Trail of Bits](https://www.trailofbits.com/)** — _компания по кибербезопасности, которая сочетает исследования в области безопасности с мышлением атакующего, чтобы снизить риски и укрепить код._

- **[PeckShield](https://peckshield.com/)** — _компания по безопасности блокчейна, предлагающая продукты и услуги для обеспечения безопасности, конфиденциальности и удобства использования всей экосистемы блокчейна._

- **[QuantStamp](https://quantstamp.com/)** — _сервис аудита, способствующий массовому внедрению технологии блокчейн через услуги по оценке безопасности и рисков._

- **[OpenZeppelin](https://www.openzeppelin.com/security-audits)** — _компания по безопасности умных контрактов, предоставляющая аудиты безопасности для распределенных систем._

- **[Runtime Verification](https://runtimeverification.com/)** — _компания по безопасности, специализирующаяся на формальном моделировании и верификации умных контрактов._

- **[Hacken](https://hacken.io)** — _аудитор кибербезопасности Web3, применяющий 360-градусный подход к безопасности блокчейна._

- **[Nethermind](https://www.nethermind.io/smart-contract-audits)** — _услуги аудита Solidity и Cairo, обеспечивающие целостность умных контрактов и безопасность пользователей в Ethereum и Starknet._

- **[HashEx](https://hashex.org/)** — _HashEx специализируется на аудите блокчейна и умных контрактов для обеспечения безопасности криптовалют, предоставляя такие услуги, как разработка умных контрактов, тестирование на проникновение, консалтинг в области блокчейна._

- **[Code4rena](https://code4rena.com/)** — _конкурентная платформа для аудита, которая стимулирует экспертов по безопасности умных контрактов находить уязвимости и помогать делать web3 более безопасным._

- **[CodeHawks](https://codehawks.com/)** — _конкурентная аудиторская платформа, проводящая соревнования по аудиту умных контрактов для исследователей безопасности._

- **[Cyfrin](https://cyfrin.io)** — _мощный центр безопасности Web3, инкубирующий криптобезопасность через продукты и услуги по аудиту умных контрактов._

- **[ImmuneBytes](https://immunebytes.com/smart-contract-audit/)** — _фирма по безопасности Web3, предлагающая аудиты безопасности для блокчейн-систем с помощью команды опытных аудиторов и лучших в своем классе инструментов._

- **[Oxorio](https://oxor.io/)** — _аудиты умных контрактов и услуги по безопасности блокчейна с опытом в EVM, Solidity, ZK, кросс-чейн технологиях для криптофирм и проектов DeFi._

- **[Inference](https://inference.ag/)** — _аудиторская компания по безопасности, специализирующаяся на аудите умных контрактов для блокчейнов на базе EVM. Благодаря своим опытным аудиторам они выявляют потенциальные проблемы и предлагают действенные решения для их устранения до развертывания._

### Платформы вознаграждений за обнаружение ошибок {#bug-bounty-platforms}

- **[Immunefi](https://immunefi.com/)** — _платформа вознаграждений за обнаружение ошибок для умных контрактов и проектов DeFi, где исследователи безопасности просматривают код, раскрывают уязвимости, получают вознаграждение и делают криптовалюту безопаснее._

- **[HackerOne](https://www.hackerone.com/)** — _платформа для координации уязвимостей и вознаграждений за обнаружение ошибок, которая связывает компании с пентестерами и исследователями кибербезопасности._

- **[HackenProof](https://hackenproof.com/)** — _экспертная платформа вознаграждений за ошибки для криптопроектов (DeFi, умные контракты, кошельки, CEX и другие), где специалисты по безопасности обеспечивают сортировочные услуги и исследователям платят за соответствующие, проверенные сообщения об ошибках._

- **[Sherlock](https://www.sherlock.xyz/)** — _гарант безопасности умных контрактов в Web3, с выплатами для аудиторов, управляемыми через умные контракты, чтобы обеспечить справедливую оплату за обнаружение соответствующих ошибок._

- **[CodeHawks](https://www.codehawks.com/)** — _конкурентная платформа вознаграждений за обнаружение ошибок, где аудиторы принимают участие в конкурсах и челленджах по безопасности, а (скоро) и в своих собственных частных аудитах._

### Публикации известных уязвимостей и эксплойтов умных контрактов {#common-smart-contract-vulnerabilities-and-exploits}

- **[ConsenSys: известные атаки на умные контракты](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/)** — _понятное для новичков объяснение наиболее значительных уязвимостей контрактов с примерами кода для большинства случаев._

- **[SWC Registry](https://swcregistry.io/)** — _отобранный список элементов Common Weakness Enumeration (CWE), применимых к умным контрактам Ethereum._

- **[Rekt](https://rekt.news/)** — _регулярно обновляемое издание о громких крипто-взломах и эксплойтах, а также подробные отчеты о вскрытии._

### Задания для изучения безопасности умных контрактов {#challenges-for-learning-smart-contract-security}

- **[Awesome BlockSec CTF](https://github.com/blockthreat/blocksec-ctfs)** — _отобранный список военных игр, задач и соревнований [Capture The Flag](https://www.webopedia.com/definitions/ctf-event/amp/) в области безопасности блокчейна, а также разборы решений._

- **[Damn Vulnerable DeFi](https://www.damnvulnerabledefi.xyz/)** — _военная игра для изучения наступательной безопасности умных контрактов DeFi и развития навыков в поиске ошибок и аудите безопасности._

- **[Ethernaut](https://ethernaut.openzeppelin.com/)** — _военная игра на основе Web3/Solidity, где каждый уровень — это умный контракт, который нужно «взломать»._

- **[HackenProof x HackTheBox](https://app.hackthebox.com/tracks/HackenProof-Track)** — _задание по взлому умных контрактов в стиле фэнтезийного приключения. Успешное выполнение задания также дает доступ к частной программе вознаграждений за обнаружение ошибок._

### Лучшие практики по обеспечению безопасности умных контрактов {#smart-contract-security-best-practices}

- **[ConsenSys: лучшие практики безопасности умных контрактов Ethereum](https://consensys.github.io/smart-contract-best-practices/)** — _полный список рекомендаций по обеспечению безопасности умных контрактов Ethereum._

- **[Nascent: простой набор инструментов для обеспечения безопасности](https://github.com/nascentxyz/simple-security-toolkit)** — _коллекция практических руководств и контрольных списков по безопасности для разработки умных контрактов._

- **[Solidity Patterns](https://fravoll.github.io/solidity-patterns/)** — _полезная подборка безопасных патернов и лучших практик для языка программирования умных контрактов Solidity._

- **[Документация Solidity: соображения безопасности](https://docs.soliditylang.org/en/v0.8.16/security-considerations.html)** — _руководство по написанию безопасных умных контрактов на Solidity._

- **[Стандарт верификации безопасности умных контрактов](https://github.com/securing/SCSVS)** — _четырнадцатипунктовый контрольный список, созданный для стандартизации безопасности умных контрактов для разработчиков, архитекторов, ревьюеров безопасности и поставщиков._

- **[Изучение безопасности и аудита умных контрактов](https://updraft.cyfrin.io/courses/security)** — _полный курс по безопасности и аудиту умных контрактов, созданный для разработчиков умных контрактов, которые хотят повысить уровень своих знаний в области безопасности и стать исследователями безопасности._

### Учебные пособия по безопасности умных контрактов {#tutorials-on-smart-contract-security}

- [Как писать безопасные умные контракты](/developers/tutorials/secure-development-workflow/)

- [Как использовать Slither для поиска ошибок в умных контрактах](/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/)

- [Как использовать Manticore для поиска ошибок в умных контрактах](/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/)

- [Руководство по безопасности умных контрактов](/developers/tutorials/smart-contract-security-guidelines/)

- [Как безопасно интегрировать ваш контракт токенов с произвольными токенами](/developers/tutorials/token-integration-checklist/)

- [Cyfrin Updraft — полный курс по безопасности и аудиту умных контрактов](https://updraft.cyfrin.io/courses/security)
