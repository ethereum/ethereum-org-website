---
title: Dagger-Hashimoto
description: "Подробный обзор алгоритма Dagger-Hashimoto."
lang: ru
---

Dagger-Hashimoto был изначальной исследовательской реализацией и спецификацией алгоритма майнинга Ethereum. Dagger-Hashimoto был заменен на [Ethash](#ethash). Майнинг был полностью отключен во время [Слияния](/roadmap/merge/) 15 сентября 2022 года. С тех пор безопасность Ethereum обеспечивается с помощью механизма [доказательства доли владения](/developers/docs/consensus-mechanisms/pos). Эта страница представляет исторический интерес — информация на ней больше не актуальна для Ethereum после Слияния.

## Предварительные условия {#prerequisites}

Чтобы лучше понять эту страницу, мы рекомендуем вам сначала ознакомиться с [консенсусом на основе доказательства выполнения работы](/developers/docs/consensus-mechanisms/pow), [майнингом](/developers/docs/consensus-mechanisms/pow/mining) и [алгоритмами майнинга](/developers/docs/consensus-mechanisms/pow/mining/mining-algorithms).

## Dagger-Hashimoto {#dagger-hashimoto}

Dagger-Hashimoto нацелен на достижение двух целей:

1. **Устойчивость к ASIC**: преимущество от создания специализированного оборудования для этого алгоритма должно быть как можно меньшим
2. **Верифицируемость легким клиентом**: блок должен эффективно верифицироваться легким клиентом.

С дополнительной модификацией мы также указываем, как при желании достичь третьей цели, но за счет дополнительной сложности:

**Полное хранение цепочки**: майнинг должен требовать хранения полного состояния блокчейна (из-за нерегулярной структуры дерева состояний Ethereum мы предполагаем, что будет возможно некоторое усечение, в частности, некоторых часто используемых контрактов, но мы хотим свести это к минимуму).

## Генерация DAG {#dag-generation}

Код алгоритма будет определен на Python ниже. Сначала приведем `encode_int` для маршалинга беззнаковых целых чисел указанной точности в строки. Также приведена обратная функция:

```python
NUM_BITS = 512

def encode_int(x):
    "Кодирует целое число x в виде строки из 64 символов с использованием схемы с прямым порядком байтов"
    o = ''
    for _ in range(NUM_BITS / 8):
        o = chr(x % 256) + o
        x //= 256
    return o

def decode_int(s):
    "Декодирует целое число x из строки с использованием схемы с прямым порядком байтов"
    x = 0
    for c in s:
        x *= 256
        x += ord(c)
    return x
```

Далее мы предполагаем, что `sha3` — это функция, которая принимает и возвращает целое число, а `dbl_sha3` — это функция двойного sha3; при преобразовании этого эталонного кода в реализацию используйте:

```python
from pyethereum import utils
def sha3(x):
    if isinstance(x, (int, long)):
        x = encode_int(x)
    return decode_int(utils.sha3(x))

def dbl_sha3(x):
    if isinstance(x, (int, long)):
        x = encode_int(x)
    return decode_int(utils.sha3(utils.sha3(x)))
```

### Параметры {#parameters}

Для алгоритма используются следующие параметры:

```python
SAFE_PRIME_512 = 2**512 - 38117     # Наибольшее безопасное простое число, меньшее, чем 2**512

params = {
      "n": 4000055296 * 8 // NUM_BITS,  # Размер набора данных (4 гигабайта); ДОЛЖЕН БЫТЬ КРАТЕН 65536
      "n_inc": 65536,                   # Приращение значения n за период; ДОЛЖНО БЫТЬ КРАТНО 65536
                                        # при epochtime=20000 дает прирост 882 МБ в год
      "cache_size": 2500,               # Размер кэша легкого клиента (может быть выбран легким клиентом; не является частью спецификации алгоритма)
      "diff": 2**14,                    # Сложность (корректируется во время оценки блока)
      "epochtime": 100000,              # Длительность эпохи в блоках (как часто обновляется набор данных)
      "k": 1,                           # Количество родителей узла
      "w": w,                          # Используется для хэширования модульным возведением в степень
      "accesses": 200,                  # Количество обращений к набору данных во время хэширования
      "P": SAFE_PRIME_512               # Безопасное простое число для хэширования и генерации случайных чисел
}
```

В данном случае `P` является простым числом, выбранным таким образом, чтобы `log₂(P)` был незначительно меньше 512, что соответствует 512 битам, которые мы использовали для представления наших чисел. Обратите внимание, что фактически необходимо хранить только вторую половину DAG, поэтому фактическое требование к ОЗУ начинается с 1 ГБ и увеличивается на 441 МБ в год.

### Построение графа Dagger {#dagger-graph-building}

Примитив построения графа Dagger определяется следующим образом:

```python
def produce_dag(params, seed, length):
    P = params["P"]
    picker = init = pow(sha3(seed), params["w"], P)
    o = [init]
    for i in range(1, length):
        x = picker = (picker * init) % P
        for _ in range(params["k"]):
            x ^= o[x % i]
        o.append(pow(x, params["w"], P))
    return o
```

По сути, он начинает граф с одного узла `sha3(seed)`, а затем последовательно добавляет другие узлы на основе случайных предыдущих узлов. При создании нового узла вычисляется модульная степень начального числа для случайного выбора некоторых индексов, меньших `i` (с использованием `x % i` выше), и значения узлов по этим индексам используются в вычислении для генерации нового значения `x`, которое затем подается в небольшую функцию доказательства выполнения работы (на основе XOR) для окончательной генерации значения графа по индексу `i`. Обоснование этого конкретного дизайна заключается в том, чтобы принудить к последовательному доступу к DAG; следующее значение DAG, к которому будет осуществлен доступ, не может быть определено, пока не станет известно текущее значение. Наконец, модульное возведение в степень далее хэширует результат.

Этот алгоритм опирается на несколько результатов из теории чисел. См. обсуждение в приложении ниже.

## Оценка легкого клиента {#light-client-evaluation}

Приведенная выше конструкция графа предназначена для того, чтобы каждый узел в графе можно было реконструировать путем вычисления поддерева из небольшого числа узлов и требуя лишь небольшого количества вспомогательной памяти. Обратите внимание, что при k=1 поддерево представляет собой лишь цепочку значений, ведущую к первому элементу в DAG.

Вычислительная функция легкого клиента для DAG работает следующим образом:

```python
def quick_calc(params, seed, p):
    w, P = params["w"], params["P"]
    cache = {}

    def quick_calc_cached(p):
        if p in cache:
            pass
        elif p == 0:
            cache[p] = pow(sha3(seed), w, P)
        else:
            x = pow(sha3(seed), (p + 1) * w, P)
            for _ in range(params["k"]):
                x ^= quick_calc_cached(x % p)
            cache[p] = pow(x, w, P)
        return cache[p]

    return quick_calc_cached(p)
```

По сути, это просто переписанный вышеуказанный алгоритм, который удаляет цикл вычисления значений для всего DAG и заменяет предыдущий поиск узла рекурсивным вызовом или поиском в кэше. Обратите внимание, что для `k=1` кэш не нужен, хотя дальнейшая оптимизация фактически предварительно вычисляет первые несколько тысяч значений DAG и сохраняет их в качестве статического кэша для вычислений; см. приложение для реализации этого кода.

## Двойной буфер DAG {#double-buffer}

В полном клиенте используется [_двойной буфер_](https://wikipedia.org/wiki/Multiple_buffering) из 2 DAG, созданных по приведенной выше формуле. Идея заключается в том, что DAG создаются каждые `epochtime` блоков в соответствии с приведенными выше параметрами. Вместо того чтобы клиент использовал последний созданный DAG, он использует предыдущий. Преимущество этого заключается в том, что это позволяет заменять DAG со временем без необходимости включать шаг, на котором майнеры должны внезапно пересчитывать все данные. В противном случае существует вероятность резкого временного замедления обработки цепочки через равные промежутки времени и резкого усиления централизации. Таким образом, в течение тех нескольких минут, пока все данные не будут пересчитаны, возникают риски атаки 51 %.

Алгоритм, используемый для генерации набора DAG, который, в свою очередь, используется для вычисления работы для блока, следующий:

```python
def get_prevhash(n):
    from pyethereum.blocks import GENESIS_PREVHASH
    from pyethereum import chain_manager
    if n <= 0:
        return hash_to_int(GENESIS_PREVHASH)
    else:
        prevhash = chain_manager.index.get_block_by_number(n - 1)
        return decode_int(prevhash)

def get_seedset(params, block):
    seedset = {}
    seedset["back_number"] = block.number - (block.number % params["epochtime"])
    seedset["back_hash"] = get_prevhash(seedset["back_number"])
    seedset["front_number"] = max(seedset["back_number"] - params["epochtime"], 0)
    seedset["front_hash"] = get_prevhash(seedset["front_number"])
    return seedset

def get_dagsize(params, block):
    return params["n"] + (block.number // params["epochtime"]) * params["n_inc"]

def get_daggerset(params, block):
    dagsz = get_dagsize(params, block)
    seedset = get_seedset(params, block)
    if seedset["front_hash"] <= 0:
        # Создание резервного буфера невозможно, создается только передний буфер
        return {"front": {"dag": produce_dag(params, seedset["front_hash"], dagsz),
                          "block_number": 0}}
    else:
        return {"front": {"dag": produce_dag(params, seedset["front_hash"], dagsz),
                          "block_number": seedset["front_number"]},
                "back": {"dag": produce_dag(params, seedset["back_hash"], dagsz),
                         "block_number": seedset["back_number"]}}
```

## Hashimoto {#hashimoto}

Идея оригинального Hashimoto заключается в использовании блокчейна в качестве набора данных, выполняя вычисление, которое выбирает N индексов из блокчейна, собирает транзакции по этим индексам, выполняет операцию XOR над этими данными и возвращает хэш результата. Оригинальный алгоритм Таддеуша Дрии, переведенный на Python для согласованности, следующий:

```python
def orig_hashimoto(prev_hash, merkle_root, list_of_transactions, nonce):
    hash_output_A = sha256(prev_hash + merkle_root + nonce)
    txid_mix = 0
    for i in range(64):
        shifted_A = hash_output_A >> i
        transaction = shifted_A % len(list_of_transactions)
        txid_mix ^= list_of_transactions[transaction] << i
    return txid_mix ^ (nonce << 192)
```

К сожалению, хотя Hashimoto считается сложным для ОЗУ, он опирается на 256-битную арифметику, что влечет за собой значительные вычислительные накладные расходы. Однако для решения этой проблемы Dagger-Hashimoto использует только младшие 64 бита при индексации своего набора данных.

```python
def hashimoto(dag, dagsize, params, header, nonce):
    m = dagsize / 2
    mix = sha3(encode_int(nonce) + header)
    for _ in range(params["accesses"]):
        mix ^= dag[m + (mix % 2**64) % m]
    return dbl_sha3(mix)
```

Использование двойного SHA3 позволяет осуществлять своего рода почти мгновенную предварительную верификацию с нулевыми данными, проверяя только то, что было предоставлено правильное промежуточное значение. Этот внешний уровень доказательства выполнения работы очень дружелюбен к ASIC и довольно слаб, но существует для того, чтобы еще больше усложнить DDoS-атаки, поскольку этот небольшой объем работы должен быть выполнен для создания блока, который не будет немедленно отклонен. Вот версия для легкого клиента:

```python
def quick_hashimoto(seed, dagsize, params, header, nonce):
    m = dagsize // 2
    mix = sha3(nonce + header)
    for _ in range(params["accesses"]):
        mix ^= quick_calc(params, seed, m + (mix % 2**64) % m)
    return dbl_sha3(mix)
```

## Майнинг и верификация {#mining-and-verifying}

Давайте соберём это всё в алгоритм майнинга:

```python
def mine(daggerset, params, block):
    from random import randint
    nonce = randint(0, 2**64)
    while 1:
        result = hashimoto(daggerset, get_dagsize(params, block),
                           params, decode_int(block.prevhash), nonce)
        if result * params["diff"] < 2**256:
            break
        nonce += 1
        if nonce >= 2**64:
            nonce = 0
    return nonce
```

И в алгоритм верификации:

```python
def verify(daggerset, params, block, nonce):
    result = hashimoto(daggerset, get_dagsize(params, block),
                       params, decode_int(block.prevhash), nonce)
    return result * params["diff"] < 2**256
```

Верификация, дружественная к легким клиентам:

```python
def light_verify(params, header, nonce):
    seedset = get_seedset(params, block)
    result = quick_hashimoto(seedset["front_hash"], get_dagsize(params, block),
                             params, decode_int(block.prevhash), nonce)
    return result * params["diff"] < 2**256
```

Также обратите внимание, что Dagger-Hashimoto накладывает дополнительные требования на заголовок блока:

- Чтобы двухслойная верификация работала, заголовок блока должен содержать как nonce, так и промежуточное значение до применения sha3.
- Где-то в заголовке блока должен храниться sha3 текущего набора начальных чисел

## Дополнительные материалы {#further-reading}

_Знаете ресурс сообщества, который вам пригодился? Измените эту страницу и добавьте его!_

## Приложение {#appendix}

Как отмечалось выше, ГСЧ, используемый для генерации DAG, основывается на некоторых результатах теории чисел. Во-первых, мы даем гарантию, что ГСЧ Лемера, который лежит в основе переменной `picker`, имеет большой период. Во-вторых, мы показываем, что `pow(x,3,P)` не отобразит `x` в `1` или `P-1` при условии, что `x` изначально находится в диапазоне `[2,P-2]`. Наконец, мы показываем, что `pow(x,3,P)` имеет низкий уровень коллизий при использовании в качестве хэш-функции.

### Генератор случайных чисел Лемера {#lehmer-random-number}

Хотя функция `produce_dag` не обязана генерировать несмещенные случайные числа, потенциальная угроза заключается в том, что `seed**i % P` принимает лишь небольшое количество значений. Это может дать преимущество майнерам, распознающим закономерность, перед теми, кто ее не распознает.

Чтобы избежать этого, используется результат из теории чисел. [_Безопасное простое число_](https://en.wikipedia.org/wiki/Safe_prime) определяется как простое число `P`, такое что `(P-1)/2` также является простым числом. _Порядок_ члена `x` [мультипликативной группы](https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n) `ℤ/nℤ` определяется как минимальное `m`, такое что <pre>xᵐ mod P ≡ 1</pre>
Учитывая эти определения, мы имеем:

> Наблюдение 1. Пусть `x` — член мультипликативной группы `ℤ/Pℤ` для безопасного простого числа `P`. Если `x mod P ≠ 1 mod P` и `x mod P ≠ P-1 mod P`, то порядок `x` равен либо `P-1`, либо `(P-1)/2`.

_Доказательство_. Поскольку `P` — безопасное простое число, то по [теореме Лагранжа][lagrange] мы имеем, что порядок `x` равен либо `1`, `2`, `(P-1)/2`, либо `P-1`.

Порядок `x` не может быть `1`, поскольку по Малой теореме Ферма мы имеем:

<pre>x<sup>P-1</sup> mod P ≡ 1</pre>

Следовательно, `x` должен быть мультипликативной единицей `ℤ/nℤ`, которая является уникальной. Поскольку мы по предположению приняли, что `x ≠ 1`, это невозможно.

Порядок `x` не может быть `2`, если `x ≠ P-1`, поскольку это нарушило бы тот факт, что `P` является простым числом.

Из приведенного выше утверждения мы можем заключить, что итерация `(picker * init) % P` будет иметь длину цикла не менее `(P-1)/2`. Это связано с тем, что мы выбрали `P` как безопасное простое число, приблизительно равное высокой степени двойки, а `init` находится в интервале `[2,2**256+1]`. Учитывая величину `P`, мы не должны ожидать цикла от модульного возведения в степень.

Когда мы присваиваем значение первой ячейке в DAG (переменная с меткой `init`), мы вычисляем `pow(sha3(seed) + 2, 3, P)`. На первый взгляд, это не гарантирует, что результат не будет равен ни `1`, ни `P-1`. Однако, поскольку `P` является безопасным простым числом, у нас есть следующая дополнительная гарантия, которая является следствием Наблюдения 1:

> Наблюдение 2. Пусть `x` — член мультипликативной группы `ℤ/Pℤ` для безопасного простого числа `P`, и пусть `w` будет натуральным числом. Если `x mod P ≠ 1 mod P` и `x mod P ≠ P-1 mod P`, а также `w mod P ≠ P-1 mod P` и `w mod P ≠ 0 mod P`, то `xʷ mod P ≠ 1 mod P` и `xʷ mod P ≠ P-1 mod P`

### Модульное возведение в степень как хэш-функция {#modular-exponentiation}

Для определенных значений `P` и `w` функция `pow(x, w, P)` может иметь много коллизий. Например, `pow(x,9,19)` принимает только значения `{1,18}`.

Учитывая, что `P` является простым числом, подходящее `w` для хэш-функции модульного возведения в степень может быть выбрано с использованием следующего результата:

> Наблюдение 3. Пусть `P` — простое число; `w` и `P-1` взаимно просты тогда и только тогда, когда для всех `a` и `b` в `ℤ/Pℤ` выполняется следующее: <center>`aʷ mod P ≡ bʷ mod P` тогда и только тогда, когда `a mod P ≡ b mod P`</center>

Таким образом, учитывая, что `P` является простым числом, а `w` взаимно просто с `P-1`, мы имеем, что `|{pow(x, w, P) : x ∈ ℤ}| = P`, что означает, что хэш-функция имеет минимально возможную частоту коллизий.

В частном случае, когда `P` является выбранным нами безопасным простым числом, `P-1` имеет только множители 1, 2, `(P-1)/2` и `P-1`. Поскольку `P` > 7, мы знаем, что 3 взаимно просто с `P-1`, следовательно, `w=3` удовлетворяет вышеприведенному утверждению.

## Более эффективный алгоритм оценки на основе кэша {#cache-based-evaluation}

```python
def quick_calc(params, seed, p):
    cache = produce_dag(params, seed, params["cache_size"])
    return quick_calc_cached(cache, params, p)

def quick_calc_cached(cache, params, p):
    P = params["P"]
    if p < len(cache):
        return cache[p]
    else:
        x = pow(cache[0], p + 1, P)
        for _ in range(params["k"]):
            x ^= quick_calc_cached(cache, params, x % p)
        return pow(x, params["w"], P)

def quick_hashimoto(seed, dagsize, params, header, nonce):
    cache = produce_dag(params, seed, params["cache_size"])
    return quick_hashimoto_cached(cache, dagsize, params, header, nonce)

def quick_hashimoto_cached(cache, dagsize, params, header, nonce):
    m = dagsize // 2
    mask = 2**64 - 1
    mix = sha3(encode_int(nonce) + header)
    for _ in range(params["accesses"]):
        mix ^= quick_calc_cached(cache, params, m + (mix & mask) % m)
    return dbl_sha3(mix)
```
