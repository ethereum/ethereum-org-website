---
title: Узлы и клиенты
description: Немного об узлах Ethereum и клиентском программном обеспечении, а также о том, как настроить узел и почему вы должны это сделать.
lang: ru
sidebarDepth: 2
---

Ethereum — это распределенная сеть компьютеров с программным обеспечением (известным как узлы, или ноды), которое может проверять блоки и данные транзакций. Программное обеспечение должно быть запущено на вашем компьютере, чтобы превратить его в узел Ethereum. Для создания узла требуются две отдельные части программного обеспечения (известные как "клиенты").

## Предварительные условия {#prerequisites}

Вам следует разобраться в концепции одноранговых сетей и [основах EVM](/developers/docs/evm/), прежде чем углубляться в тему и запускать собственный экземпляр клиента Ethereum. Ознакомьтесь с нашим [введением в Ethereum](/developers/docs/intro-to-ethereum/).

Если вы новичок в теме узлов, мы рекомендуем сначала ознакомиться с нашим простым и понятным руководством по [запуску узла Ethereum](/run-a-node).

## Что такое узлы и клиенты? {#what-are-nodes-and-clients}

«Узел» - это любой экземпляр клиентского программного обеспечения Ethereum, который соединен с другими компьютерами, на которых также установлено программное обеспечение Ethereum, образуя сеть. Клиент - это реализация Ethereum, которая проверяет данные на соответствие правилам протокола и обеспечивает безопасность сети. Узел работает посредством двух клиентов: клиент консенсуса и клиент исполнения.

- Клиент исполнения (также известный как Execution Engine, EL-клиент, или ранее Eth1-клиент) улавливает новые транзакции, транслируемые в сети, выполняет их в EVM, а также хранит последнее состояние и базу данных всех текущих данных Ethereum.
- Клиент консенсуса (также известный как Beacon Node, клиент CL, или ранее клиент Eth2) реализует алгоритм консенсуса proof-of-stake, который позволяет сети достигать согласия на основе проверенных клиентом исполнения данных. Существует также третья часть программного обеспечения, известная как «валидатор», которая может быть добавлена к клиенту консенсуса, позволяя узлу участвовать в обеспечении безопасности сети.

Эти клиенты работают совместно для отслеживания текущего состояния блокчейна Ethereum и обеспечения взаимодействия пользователей с сетью Ethereum. Модульная архитектура, при которой множество программных компонентов работают совместно, называется [инкапсулированной сложностью](https://vitalik.eth.limo/general/2022/02/28/complexity.html). Этот подход упростил беспрепятственное выполнение [Слияния](/roadmap/merge), делает клиентское программное обеспечение более простым в обслуживании и разработке и позволяет повторно использовать отдельные клиенты, например, в [экосистеме леера 2](/layer-2/).

![Совмещенные клиенты исполнения и консенсуса](./eth1eth2client.png)
Упрощенная схема совмещенного клиента исполнения и консенсуса.

### Разнообразие клиентов {#client-diversity}

И [клиенты-исполнители](/developers/docs/nodes-and-clients/#execution-clients), и [клиенты консенсуса](/developers/docs/nodes-and-clients/#consensus-clients) существуют в версиях на разных языках программирования, разработанных разными командами.

Множественные реализации клиентов могут укрепить сеть, снижая её зависимость от единой кодовой базы. Идеальная цель - достичь разнообразия, при котором ни один клиент не доминирует в сети, тем самым устраняя потенциальную единую точку отказа.
Разнообразие языков программирования также привлекает более широкое сообщество разработчиков и позволяет им создавать интеграции на предпочтительном для них языке.

Узнайте больше о [разнообразии клиентов](/developers/docs/nodes-and-clients/client-diversity/).

Общим для этих клиентских реализаций является то, что все они следуют единой спецификации. Спецификации определяют, как функционирует сеть Ethereum и блокчейн. Все технические детали и спецификации доступны в следующих материалах:

- Изначально [Желтая книга Ethereum](https://ethereum.github.io/yellowpaper/paper.pdf)
- [Спецификации исполнения](https://github.com/ethereum/execution-specs/)
- [Спецификации консенсуса](https://github.com/ethereum/consensus-specs)
- [EIP](https://eips.ethereum.org/), реализованные в различных [обновлениях сети](/ethereum-forks/)

### Отслеживание узлов в сети {#network-overview}

Множество трекеров предлагают просмотр узлов сети Ethereum в реальном времени. Заметим, что из-за децентрализованной природы сетей, эти краулеры могут предоставить только ограниченную картину сети и иногда отображают разные данные.

- [Карта узлов](https://etherscan.io/nodetracker) от Etherscan
- [Ethernodes](https://ethernodes.org/) от Bitfly
- [Nodewatch](https://www.nodewatch.io/) от Chainsafe, сканирует узлы консенсуса
- [Monitoreth](https://monitoreth.io/) от MigaLabs, инструмент для мониторинга распределенных сетей
- [Еженедельные отчеты о состоянии сети](https://probelab.io) от ProbeLab, использует [Nebula crawler](https://github.com/dennis-tra/nebula) и другие инструменты

## Типы узлов {#node-types}

Если вы хотите [запустить собственный узел](/developers/docs/nodes-and-clients/run-a-node/), вы должны понимать, что существуют разные типы узлов, которые по-разному потребляют данные. В действительности, через клиенты можно выступить в роли узла трёх видов: облегчённые, полные и архивные. Также есть разные варианты, позволяющие добиться синхронизации быстрее. Синхронизация означает скорость, с которой он может получить самую свежую информацию о состоянии Ethereum.

### Полный узел {#full-node}

Полные узлы делают по-блоковую валидацию блокчейна. Сюда входит и загрузка и верификация тела блока, и данные состояния каждого блока. Существуют различные классы полных узлов — некоторые начинают с генезис-блока и проверяют каждый блок во всей истории блокчейна. Другие начинают свою проверку с более недавнего блока, который они считают действительным (например, «моментальная синхронизация» Geth). Независимо от того, с чего начинается проверка, полные узлы хранят только локальную копию относительно недавних данных (обычно последние 128 блоков), позволяя удалять более старые данные для экономии места на диске. Однако старые данные могут быть восстановлены при необходимости.

- Хранит полные данные блокчейна (хотя они периодически сокращаются, поэтому полный узел не хранит все данные о состоянии, начиная с создания)
- Участвует в проверке блоков, проверяет все блоки и состояния.
- Любые состояния могут быть возобновлены из локального хранилища или отпечатков «snapshots» полного узла.
- Обслуживает сеть и предоставляет данные по запросу.

### Архивный узел {#archive-node}

Архивные узлы — это полные узлы, которые верифицируют каждый блок начиная с генезиса, и никогда не удаляют скачанные данные.

- Хранит все, что хранится в полном узле, и создает архив исторических состояний. Это необходимо, если вы хотите запросить данные, например, баланс аккаунта на блоке #4,000,000, или просто надёжно протестировать собственный набор транзакций без их валидации с помощью трассировки.
- Эти данные исчисляются в терабайтах, что делает обслуживание архивных узлов менее привлекательным для рядовых пользователей. Но они будут очень полезны проводникам по блокам, сервисам-кошелькам и блокчейн аналитикам.

Синхронизация клиентов в любом режиме, кроме архива, приведет к удалению данных блокчейна. Это означает, что не существует архива всех исторических состояний, но полный узел способен построить их по требованию.

Узнайте больше об [архивных узлах](/developers/docs/nodes-and-clients/archive-nodes).

### Легкий узел {#light-node}

Вместо скачивания каждого блока, облегчённые узлы скачивают только заголовки блоков. Эти заголовки содержат суммированную информацию о содержимом блоков. За любой другой информацией облегчённый узел должен обращаться к полному узлу. Легкий узел может затем самостоятельно проверить данные, полученные из исходного состояния в заголовках блока. Легкие узлы позволяют пользователям участвовать в сети Ethereum без мощного оборудования или высокой пропускной способности, требуемых для запуска полных узлов. В конце концов, легкие узлы могут работать на мобильных телефонах или встроенных устройствах. Легкие узлы не участвуют в консенсусе (т. е. они не могут быть валидаторами), но они могут получать доступ к блокчейну Ethereum с той же функциональностью и гарантиями безопасности, что и полный узел.

Облегчённые клиенты — это зона активной разработки для Ethereum, и мы надеемся вскоре увидеть новые облегчённые клиенты для консенсусного и исполнительного слоёв.
Также существуют потенциальные маршруты для предоставления данных легкого клиента через [gossip-сеть](https://www.ethportal.net/). Это выгодно, потому что сеть сплетен могла бы поддержать сеть легких узлов, не нуждаясь в полных узлах для обслуживания запросов.

Ethereum пока не поддерживает большое количество легких узлов, но поддержка легкого узла - это область, которая, как ожидается, будет быстро развиваться в ближайшем будущем. В частности, такие клиенты, как [Nimbus](https://nimbus.team/), [Helios](https://github.com/a16z/helios) и [LodeStar](https://lodestar.chainsafe.io/), в настоящее время активно занимаются легкими узлами.

## Зачем мне запускать узел Ethereum? {#why-should-i-run-an-ethereum-node}

Обслуживание узла позволяет вам прямо, надёжно и приватно использовать сеть Ethereum, одновременно поддерживая её крепкость и децентрализованность.

### Преимущества для вас {#benefits-to-you}

Запуск собственного узла позволяет вам использовать Ethereum в конфиденциальной, самодостаточной и не требующей доверяться посторонним манере. Вам не нужно доверять сети, потому что вы можете сами проверить данные своим клиентом. «Не доверяйте, проверяйте» — популярная мантра блокчейна.

- Ваш узел самостоятельно проверяет все транзакции и блоки на соответствие правилам согласования. Это означает, что вам не нужно полагаться на какие-либо другие узлы в сети или полностью им доверять.
- Вы можете использовать кошелек Ethereum с собственной нодой. Использовать децентрализованные приложения более безопасно и конфиденциально, поскольку вам не придется передавать свои адреса и баланс посредникам. Все можно проверить с помощью собственного клиента. [MetaMask](https://metamask.io), [Frame](https://frame.sh/) и [многие другие кошельки](/wallets/find-wallet/) предлагают импорт RPC, что позволяет им использовать ваш узел.
- Вы можете запускать и самостоятельно размещать другие сервисы, которые зависят от данных из Ethereum. Например, это может быть валидатор Beacon Chain, программное обеспечение, такое как леер 2, инфраструктура, обозреватели блоков, платежные процессоры и т. д.
- Вы можете предоставлять свои собственные конечные точки [RPC](/developers/docs/apis/json-rpc/). Вы могли бы даже предложить эти конечные точки публично сообществу, чтобы помочь им избежать крупных централизованных провайдеров.
- Вы можете подключиться к своему узлу с помощью **межпроцессного взаимодействия (IPC)** или переписать узел, чтобы загрузить свою программу в виде плагина. Это обеспечивает низкую задержку, что очень помогает, например, при обработке большого количества данных с использованием библиотек web3 или когда вам нужно как можно быстрее заменить свои транзакции (т. е. опережение).
- Вы можете напрямую вносить ETH в стейкинг, чтобы защитить сеть и получать вознаграждения. Чтобы начать, ознакомьтесь с [индивидуальным стейкингом](/staking/solo/).

![Как вы получаете доступ к Ethereum через ваше приложение и узлы](./nodes.png)

### Преимущества для сети {#network-benefits}

Разнообразный набор узлов важен для работоспособности, безопасности и отказоустойчивости Ethereum.

- Полные узлы обеспечивают соблюдение правил консенсуса, поэтому их нельзя обманом заставить принимать блоки, которые им не соответствуют. Это обеспечивает дополнительную безопасность в сети, потому что если бы все узлы были легкими узлами, которые не выполняют полную проверку, валидаторы могли бы атаковать сеть.
- В случае атаки, которая преодолевает криптоэкономическую защиту [доказательства владения](/developers/docs/consensus-mechanisms/pos/#what-is-pos), может быть выполнено социальное восстановление полными узлами, которые выберут следовать честной цепи.
- Чем больше узлов в сети, тем более разнообразна и надежна сеть — это и есть конечная цель децентрализации, которая обеспечивает устойчивую к цензуре и надежную систему.
- Полные узлы предоставляют доступ к данным блокчейна для легких клиентов, которые от него зависят. Легкие узлы не хранят всю цепочку блоков, вместо этого они проверяют данные через [корни состояний в заголовках блоков](/developers/docs/blocks/#block-anatomy). При необходимости они могут запросить у полных узлов дополнительную информацию.

Если вы запускаете полный узел, вся сеть Ethereum выигрывает от этого, даже если вы не запускаете валидатор.

## Запуск собственного узла {#running-your-own-node}

Заинтересованы в запуске собственного клиента Ethereum?

Для получения понятного новичкам введения посетите нашу страницу [Запуск узла](/run-a-node), чтобы узнать больше.

Если вы более технически подкованный пользователь, погрузитесь в детали и варианты того, как [запустить свой собственный узел](/developers/docs/nodes-and-clients/run-a-node/).

## Альтернативы {#alternatives}

Настройка собственного узла может стоить вам времени и ресурсов, но вам не всегда нужно запускать собственный экземпляр. API Для обзора использования этих сервисов ознакомьтесь со статьей [узлы как услуга](/developers/docs/nodes-and-clients/nodes-as-a-service/).

Если в вашем сообществе кто-то запускает узел Ethereum с общедоступным API, вы можете направить свои кошельки на узел сообщества через Custom RPC и обезопасить себя больше, чем при работе с какой-то случайной третьей стороной.

С другой стороны, если вы запустите клиент, вы можете поделиться им со своими друзьями, которым он может понадобиться.

## Клиенты-исполнители {#execution-clients}

Сообщество Ethereum поддерживает несколько клиентов-исполнителей с открытым исходным кодом (ранее известных как «клиенты Eth1« или просто «клиенты Ethereum»), разработанных разными командами с использованием разных языков программирования. Это делает сеть сильнее и более [разнообразной](/developers/docs/nodes-and-clients/client-diversity/). Идеальная цель — добиться разнообразия без доминирования клиентов, чтобы уменьшить количество точек отказа.

В этой таблице представлены различные клиенты. Все они проходят [тесты клиентов](https://github.com/ethereum/tests) и активно поддерживаются, чтобы оставаться в курсе обновлений сети.

| Клиент                                                                                             | Язык                     | Операционные системы  | Сети                      | Стратегии синхронизации                                                            | Обрезка мусора |
| -------------------------------------------------------------------------------------------------- | ------------------------ | --------------------- | ------------------------- | ---------------------------------------------------------------------------------- | -------------- |
| [Geth](https://geth.ethereum.org/)                                                                 | Go                       | Linux, Windows, macOS | Mainnet, Sepolia, Holesky | [Snap](#snap-sync), [Full](#full-sync)                                             | Архив, обрезка |
| [Nethermind](https://www.nethermind.io/)                                                           | C#, .NET | Linux, Windows, macOS | Mainnet, Sepolia, Holesky | [Snap](#snap-sync) (без обслуживания), Fast, [Full](#full-sync) | Архив, обрезка |
| [Besu](https://besu.hyperledger.org/en/stable/)                                                    | Java                     | Linux, Windows, macOS | Mainnet, Sepolia, Holesky | [Snap](#snap-sync), [Fast](#fast-sync), [Full](#full-sync)                         | Архив, обрезка |
| [Erigon](https://github.com/ledgerwatch/erigon)                                                    | Go                       | Linux, Windows, macOS | Mainnet, Sepolia, Holesky | [Full](#full-sync)                                                                 | Архив, обрезка |
| [Reth](https://reth.rs/)                                                                           | Rust                     | Linux, Windows, macOS | Mainnet, Sepolia, Holesky | [Full](#full-sync)                                                                 | Архив, обрезка |
| [EthereumJS](https://github.com/ethereumjs/ethereumjs-monorepo) _(бета-версия)_ | TypeScript               | Linux, Windows, macOS | Sepolia, Holesky          | [Full](#full-sync)                                                                 | Урезанный      |

Подробнее о поддерживаемых сетях читайте в статье о [сетях Ethereum](/developers/docs/networks/).

У каждого клиента есть уникальные варианты использования и преимущества, поэтому вы должны выбрать один, исходя из своих предпочтений. Разнообразие позволяет сфокусировать реализации на различных функциях и пользовательских аудиториях. Вы можете выбрать клиента на основе функций, поддержки, языка программирования или лицензий.

### Besu {#besu}

Hyperledger Besu — это клиент Ethereum корпоративного уровня для общедоступных и разрешенных сетей. Он работает со всеми функциями основной Ethereum, от трассировки до GraphQL, имеет обширный мониторинг и поддерживается ConsenSys, как в открытых каналах сообщества, так и в коммерческих соглашениях об уровне обслуживания для предприятий. Он написан на Java и имеет лицензию Apache 2.0.

Обширная [документация](https://besu.hyperledger.org/en/stable/) Besu проведет вас через все детали его функций и настроек.

### Erigon {#erigon}

Erigon (в прошлом — Turbo-Geth) представляет собой ответвление Go Ethereum, ориентированное на скорость и эффективность использования дискового пространства. Erigon — это полностью переработанная архитектура реализации Ethereum, написанная на языке Go, но с планируемыми реализациями на других языках. Цель Erigon — обеспечение быстрой, более модульной и более оптимизированной реализации Ethereum. Он может выполнить полную синхронизацию архивного узла, используя менее 2ТВ дискового пространства менее чем за 3 дня.

### Go Ethereum {#geth}

Go Ethereum (сокращенно Geth) — одна из оригинальных реализаций протокола Ethereum. В настоящее время это самый распространенный клиент с самой большой пользовательской базой и множеством инструментов для пользователей и разработчиков. Он написан на Go с полностью открытым исходным кодом и под лицензией GNU LGPL v3.

Узнайте больше о Geth в его [документации](https://geth.ethereum.org/docs/).

### Nethermind {#nethermind}

Nethermind — это реализация Ethereum под лицензией LGPL-3.0, созданная с помощью технического стека C# .NET, работающая на всех основных платформах, включая ARM. Он предлагает отличную производительность с:

- оптимизированной виртуальной машиной;
- доступом к состоянию;
- сетью и богатым набором функций, таких как панели управления Prometheus/Grafana, поддержка корпоративного логирования seq, трассировка JSON-RPC и аналитические плагины.

Nethermind также имеет [подробную документацию](https://docs.nethermind.io), сильную поддержку разработчиков, онлайн-сообщество и круглосуточную поддержку для премиум-пользователей.

### Reth {#reth}

Reth (сокращение от Rust Ethereum) — это реализация полного узла Ethereum, ориентированная на удобство использования, высокую модульность, скорость и эффективность. Reth был первоначально создан и развит компанией Paradigm и лицензирован по лицензиям Apache и MIT.

Reth готов к производственному использованию и подходит для применения в критически важных средах, таких как стейкинг или сервисы с высоким временем безотказной работы. Хорошо работает в сценариях, где требуется высокая производительность с большим запасом, например, RPC, MEV, индексация, симуляции и P2P-активность.

Узнайте больше, ознакомившись с [Reth Book](https://reth.rs/) или [репозиторием Reth на GitHub](https://github.com/paradigmxyz/reth?tab=readme-ov-file#reth).

### В разработке {#execution-in-development}

Эти клиенты все еще находятся на ранних стадиях разработки и пока не рекомендуются для использования в производственной среде.

#### EthereumJS {#ethereumjs}

Клиент исполнения EthereumJS (EthereumJS) написан на TypeScript и состоит из ряда пакетов, включая основные примитивы Ethereum, представленные классами Block, Transaction и Merkle-Patricia Trie, а также основные компоненты клиента, включая реализацию виртуальной машины Ethereum (EVM), класс блокчейна и сетевой стек DevP2P.

Узнайте о нем больше, прочитав его [документацию](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master)

## Клиенты консенсуса {#consensus-clients}

Существует несколько клиентов консенсуса (ранее известных как клиенты «Eth2»), поддерживающих [обновления консенсуса](/roadmap/beacon-chain/). Они отвечают за всю логику, связанную с консенсусом, включая алгоритм выбора форка, обработку аттестаций и управление вознаграждениями и штрафами [доказательства владения](/developers/docs/consensus-mechanisms/pos).

| Клиент                                                        | Язык       | Операционные системы  | Сети                                                     |
| ------------------------------------------------------------- | ---------- | --------------------- | -------------------------------------------------------- |
| [Lighthouse](https://lighthouse.sigmaprime.io/)               | Rust       | Linux, Windows, macOS | Beacon Chain, Holesky, Pyrmont, Sepolia и другие         |
| [Lodestar](https://lodestar.chainsafe.io/)                    | TypeScript | Linux, Windows, macOS | Beacon Chain, Holesky, Sepolia и другие                  |
| [Nimbus](https://nimbus.team/)                                | Nim        | Linux, Windows, macOS | Beacon Chain, Holesky, Sepolia и другие                  |
| [Prysm](https://prysm.offchainlabs.com/docs/)                 | Go         | Linux, Windows, macOS | Beacon Chain, Gnosis, Holesky, Pyrmont, Sepolia и другие |
| [Teku](https://consensys.net/knowledge-base/ethereum-2/teku/) | Java       | Linux, Windows, macOS | Beacon Chain, Gnosis, Holesky, Sepolia и другие          |
| [Grandine](https://docs.grandine.io/)                         | Rust       | Linux, Windows, macOS | Beacon Chain, Holesky, Sepolia и другие                  |

### Lighthouse {#lighthouse}

Lighthouse — это реализация клиента консенсуса, написанная на Rust под лицензией Apache-2.0. Он поддерживается Sigma Prime и является стабильным и готовым к работе с момента генезиса Beacon Chain. На него полагаются различные предприятия, стейкинг-пулы и частные лица. Он стремится быть безопасным, производительным и совместимым в широком диапазоне сред, от настольных ПК до сложных автоматизированных развертываний.

Документацию можно найти в [Lighthouse Book](https://lighthouse-book.sigmaprime.io/)

### Lodestar {#lodestar}

Lodestar — это готовая к работе реализация клиента консенсуса, написанная на Typescript под лицензией LGPL-3.0. Он поддерживается ChainSafe Systems и является новейшим из клиентов консенсуса для соло-стейкеров, разработчиков и исследователей. Lodestar состоит из узла-маяка и клиента-валидатора, основанных на реализациях протоколов Ethereum на JavaScript. Lodestar стремится улучшить удобство использования Ethereum с помощью легких клиентов, расширить доступность для более широкой группы разработчиков и внести дальнейший вклад в разнообразие экосистемы.

Больше информации можно найти на [сайте Lodestar](https://lodestar.chainsafe.io/)

### Nimbus {#nimbus}

Nimbus — это реализация клиента консенсуса, написанная на Nim под лицензией Apache-2.0. Это готовый к работе клиент, используемый соло-стейкерами и стейкинг-пулами. Nimbus разработан для эффективного использования ресурсов, что позволяет легко запускать его как на устройствах с ограниченными ресурсами, так и на корпоративной инфраструктуре, не жертвуя стабильностью или производительностью вознаграждений. Меньшее потребление ресурсов означает, что клиент имеет больший запас прочности, когда сеть находится под нагрузкой.

Узнайте больше в [документации Nimbus](https://nimbus.guide/)

### Prysm {#prysm}

Prysm — это полнофункциональный клиент консенсуса с открытым исходным кодом, написанный на Go под лицензией GPL-3.0. Он имеет опциональный пользовательский веб-интерфейс и уделяет первостепенное внимание удобству использования, документации и настраиваемости как для домашних стейкеров, так и для институциональных пользователей.

Посетите [документацию Prysm](https://prysm.offchainlabs.com/docs/), чтобы узнать больше.

### Teku {#teku}

Teku — один из оригинальных клиентов генезиса Beacon Chain. Наряду с обычными целями (безопасность, надежность, стабильность, удобство использования, производительность), Teku специально стремится полностью соответствовать всем различным стандартам клиентов консенсуса.

Teku предлагает очень гибкие настройки разработки. Узел-маяк и клиент-валидатор могут быть запущены вместе как один процесс, что чрезвычайно удобно для соло-стейкеров, или узлы могут быть запущены отдельно для сложных операций стейкинга. Кроме того, Teku полностью совместим с [Web3Signer](https://github.com/ConsenSys/web3signer/) для обеспечения безопасности ключей подписи и защиты от слешинга.

Teku написан на Java и имеет лицензию Apache 2.0. Он разработан командой Protocols в ConsenSys, которая также отвечает за Besu и Web3Signer. Узнайте больше в [документации Teku](https://docs.teku.consensys.net/en/latest/).

### Grandine {#grandine}

Grandine — это реализация клиента консенсуса, написанная на Rust под лицензией GPL-3.0. Он поддерживается командой Grandine Core Team и является быстрым, высокопроизводительным и легковесным. Он подходит для широкого круга стейкеров, от соло-стейкеров, работающих на устройствах с низкими ресурсами, таких как Raspberry Pi, до крупных институциональных стейкеров, управляющих десятками тысяч валидаторов.

Документацию можно найти в [Grandine Book](https://docs.grandine.io/)

## Режимы синхронизации {#sync-modes}

Чтобы отслеживать и проверять текущие данные в сети, клиент Ethereum должен синхронизироваться с последним ее состоянием. Это делается путем загрузки данных от пиров, криптографической проверки их целостности и создания локальной базы данных блокчейна.

Режимы синхронизации с различными решениями представляют разные подходы к этому процессу. Клиенты также различаются по реализации алгоритмов синхронизации. Всегда обращайтесь к официальной документации выбранного клиента для уточнения особенностей реализации.

### Режимы синхронизации уровня исполнения {#execution-layer-sync-modes}

Уровень исполнения может работать в разных режимах для различных сценариев использования: от повторного выполнения мирового состояния блокчейна до синхронизации только с верхушкой цепи из доверенной контрольной точки.

#### Полная синхронизация {#full-sync}

Полная синхронизация загружает все блоки (включая заголовки и тела блоков) и постепенно воссоздает состояние блокчейна, выполняя каждый блок с самого начала (генезис-блока).

- Минимизирует необходимость доверия и обеспечивает максимальную безопасность, проверяя каждую транзакцию.
- При увеличении количества транзакций обработка всех транзакций может занять от нескольких дней до нескольких недель.

[Архивные узлы](#archive-node) выполняют полную синхронизацию для создания (и сохранения) полной истории изменений состояния, произведенных каждой транзакцией в каждом блоке.

#### Быстрая синхронизация {#fast-sync}

Как и полная синхронизация, быстрая синхронизация загружает все блоки (включая заголовки, транзакции и квитанции). Однако вместо повторной обработки исторических транзакций быстрая синхронизация полагается на квитанции, пока не достигнет недавней верхушки цепи, после чего переключается на импорт и обработку блоков, чтобы стать полным узлом.

- Стратегия быстрой синхронизации.
- Снижает нагрузку на обработку в пользу использования пропускной способности.

#### Моментальная синхронизация {#snap-sync}

Моментальная синхронизация также проверяет цепочку блок за блоком. Однако вместо того, чтобы начинать с генезис-блока, моментальная синхронизация начинается с более свежей «доверенной» контрольной точки, которая, как известно, является частью истинного блокчейна. Узел сохраняет периодические контрольные точки, удаляя данные старше определенного возраста. Эти снимки используются для воссоздания данных о состоянии по мере необходимости, а не для их постоянного хранения.

- Самая быстрая стратегия синхронизации, в настоящее время используется по умолчанию в основной сети Ethereum.
- Экономия дискового пространства и пропускной способности сети без ущерба для безопасности.

[Подробнее о моментальной синхронизации](https://github.com/ethereum/devp2p/blob/master/caps/snap.md).

#### Легкая синхронизация {#light-sync}

В легком режиме клиент загружает все заголовки блоков и данные блоков, а некоторые из них проверяются случайным образом. Синхронизируется только конец цепи из доверенной контрольной точки.

- Получает только последнее состояние, полагаясь на доверие к разработчикам и механизму консенсуса.
- Клиент будет готов к использованию с текущим состоянием сети через несколько минут.

**Примечание:** легкая синхронизация еще не работает с Ethereum на proof-of-stake — новые версии легкой синхронизации должны появиться в ближайшее время!

[Подробнее о легких клиентах](/developers/docs/nodes-and-clients/light-clients/)

### Режимы синхронизации уровня консенсуса {#consensus-layer-sync-modes}

#### Оптимистическая синхронизация {#optimistic-sync}

Оптимистическая синхронизация — это стратегия синхронизации после Слияния, разработанная как опциональная и обратно совместимая, позволяющая узлам исполнения синхронизироваться с помощью установленных методов. Механизм исполнения может _оптимистично_ импортировать блоки-маяки без их полной проверки, найти последнюю верхушку и затем начать синхронизацию цепи с помощью вышеупомянутых методов. Затем, после того как клиент исполнения догонит сеть, он проинформирует клиента консенсуса о валидности транзакций в Beacon Chain.

[Подробнее об оптимистической синхронизации](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md)

#### Синхронизация по контрольным точкам {#checkpoint-sync}

Синхронизация по контрольным точкам, также известная как синхронизация со слабой субъективностью, создает превосходный пользовательский опыт для синхронизации узла Beacon. Она основана на допущениях о [слабой субъективности](/developers/docs/consensus-mechanisms/pos/weak-subjectivity/), что позволяет синхронизировать Beacon Chain с недавней контрольной точки слабой субъективности вместо генезиса. Синхронизация по контрольным точкам делает начальное время синхронизации значительно быстрее с аналогичными допущениями о доверии, как и при синхронизации с [генезиса](/glossary/#genesis-block).

На практике это означает, что ваш узел подключается к удаленному сервису для загрузки последних финализированных состояний и продолжает проверять данные с этой точки. Третья сторона, предоставляющая данные, является доверенной и должна быть выбрана тщательно.

Подробнее о [синхронизации по контрольным точкам](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice)

## Дополнительные материалы {#further-reading}

- [Ethereum 101 – Часть 2 – Понимание узлов](https://kauri.io/ethereum-101-part-2-understanding-nodes/48d5098292fd4f11b251d1b1814f0bba/a) _– Уил Барнс, 13 февраля 2019 г._
- [Запуск полных узлов Ethereum: руководство для слабо мотивированных](https://medium.com/@JustinMLeroux/running-ethereum-full-nodes-a-guide-for-the-barely-motivated-a8a13e7a0d31) _– Джастин Леру, 7 ноября 2019 г._

## Смежные темы {#related-topics}

- [Блоки](/developers/docs/blocks/)
- [Сети](/developers/docs/networks/)

## Связанные руководства {#related-tutorials}

- [Превратите свой Raspberry Pi 4 в узел валидатора, просто прошив карту MicroSD — Руководство по установке](/developers/tutorials/run-node-raspberry-pi/) _– Прошейте ваш Raspberry Pi 4, подключите кабель Ethernet, подсоедините SSD-диск и включите устройство, чтобы превратить Raspberry Pi 4 в полноценный узел Ethereum, работающий на уровне исполнения (Mainnet) и/или на уровне консенсуса (Beacon Chain/валидатор)._
