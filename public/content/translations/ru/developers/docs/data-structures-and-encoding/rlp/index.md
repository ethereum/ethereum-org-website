---
title: "Recursive-length prefix (RLP) кодирование"
description: "Описание кодирования RLP в слое выполнения Ethereum."
lang: ru
sidebarDepth: 2
---

Сериализация с помощью рекурсивной длинны префикса (RLP) обширно используется в клиентах сети Ethereum. RLP стандартизирует передачу данных между узлами в пространственно эффективном формате. Цель RLP - кодировать произвольное количество вложенных массивов двоичных данных. RLP - это метод первичной кодировки, используемый для сериализации объектов в исполнительном слое Ethereum. Основное предназначение RLP — кодировать структуру; за исключением положительных целых чисел, RLP делегирует кодирование определенных типов данных (например, строк, чисел с плавающей запятой) протоколам более высокого порядка. Положительные целые числа должны быть представлены в двоичном виде с прямым порядком байтов без ведущих нулей (таким образом, целочисленное значение ноль эквивалентно пустому байтовому массиву). Десериализованные положительные целые числа с ведущими нулями должны рассматриваться как недействительные любым протоколом более высокого порядка, использующим RLP.

Больше информации в [Желтой книге Ethereum (Приложение B)](https://ethereum.github.io/yellowpaper/paper.pdf#page=19).

Для использования RLP при кодировании словаря предлагаются следующие две канонические формы:

- используйте `[[k1,v1],[k2,v2]...]` с ключами в лексикографическом порядке
- использовать более высокоуровневую кодировку Patricia Tree как Ethereum

## Определение {#definition}

Функция кодирования RLP принимает один из элементов. Элемент определяется следующим образом：

- строка (т. е. массив байтов) является элементом
- список элементов - элемент
- положительное целое число является элементом

Например, все следующие пункты - элементы:

- пустая строка;
- строка, содержащая слово "cat";
- список, содержащий любое количество строк;
- и более сложные структуры данных, такие как `["cat", ["puppy", "cow"], "horse", [[]], "pig", [""], "sheep"]`.
- число `100`

Обратите внимание, что в контексте остальной части этой страницы «строка» означает «определенное количество байтов двоичных данных»; никакие специальные кодировки не используются и никакие сведения о содержании строк не подразумеваются (за исключением случаев, когда это требуется правилом, запрещающим неминимальные положительные целые числа).

Кодирование RLP определяется следующим образом:

- Для положительного целого числа оно преобразуется в кратчайший байтовый массив, интерпретация которого с прямым порядком байтов (big-endian) является целым числом, а затем кодируется как строка в соответствии с приведенными ниже правилами.
- Для одного байта, значение которого находится в диапазоне `[0x00, 0x7f]` (десятичное `[0, 127]`), этот байт является своей собственной RLP-кодировкой.
- В противном случае, если строка имеет длину 0–55 байтов, кодировка RLP состоит из одного байта со значением **0x80** (десятичное 128) плюс длина строки, за которой следует сама строка. Таким образом, диапазон первого байта: `[0x80, 0xb7]` (десятичное `[128, 183]`).
- Если строка длиннее 55 байтов, кодировка RLP состоит из одного байта со значением **0xb7** (десятичное 183) плюс длина в байтах длины строки в двоичной форме, за которой следует длина строки, а затем сама строка. Например, строка длиной 1024 байта будет закодирована как `\xb9\x04\x00` (десятичное `185, 4, 0`), за которой следует сама строка. Здесь `0xb9` (183 + 2 = 185) — это первый байт, за которым следуют 2 байта `0x0400` (десятичное 1024), которые обозначают длину фактической строки. Таким образом, диапазон первого байта: `[0xb8, 0xbf]` (десятичное `[184, 191]`).
- Если строка имеет длину 2^64 байтов или больше, ее нельзя закодировать.
- Если общая полезная нагрузка списка (т. е. общая длина всех его RLP-кодированных элементов) составляет 0–55 байт, кодировка RLP состоит из одного байта со значением **0xc0** плюс длина полезной нагрузки, за которой следует конкатенация RLP-кодировок элементов. Таким образом, диапазон первого байта: `[0xc0, 0xf7]` (десятичное `[192, 247]`).
- Если общая полезная нагрузка списка превышает 55 байт, кодировка RLP состоит из одного байта со значением **0xf7** плюс длина в байтах длины полезной нагрузки в двоичной форме, за которой следует длина полезной нагрузки, а затем — конкатенация RLP-кодировок элементов. Таким образом, диапазон первого байта: `[0xf8, 0xff]` (десятичное `[248, 255]`).

В коде это выражается как:

```python
def rlp_encode(input):
    if isinstance(input,str):
        if len(input) == 1 and ord(input) < 0x80:
            return input
        return encode_length(len(input), 0x80) + input
    elif isinstance(input, list):
        output = ''
        for item in input:
            output += rlp_encode(item)
        return encode_length(len(output), 0xc0) + output

def encode_length(L, offset):
    if L < 56:
         return chr(L + offset)
    elif L < 256**8:
         BL = to_binary(L)
         return chr(len(BL) + offset + 55) + BL
    raise Exception("слишком длинные входные данные")

def to_binary(x):
    if x == 0:
        return ''
    return to_binary(int(x / 256)) + chr(x % 256)
```

## Примеры: {#examples}

- строка "dog" = [ 0x83, 'd', 'o', 'g' ]
- список [ "cat", "dog" ] = `[ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]`
- пустая строка ('null') = `[ 0x80 ]`
- пустой список = `[ 0xc0 ]`
- целое число 0 = `[ 0x80 ]`
- байт '\\x00' = `[ 0x00 ]`
- байт '\\x0f' = `[ 0x0f ]`
- байты '\\x04\\x00' = `[ 0x82, 0x04, 0x00 ]`
- [теоретико-множественное представление](http://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers) числа три, `[ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]`
- строка "Lorem ipsum dolor sit amet, consectetur adipisicing elit" = `[ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ...` , 'e', 'l', 'i', 't' ]`

## Декодирование RLP {#rlp-decoding}

В соответствии с правилами и процессами RLP кодирования, входными данными RLP декодирования является массив с бинарными данными. Процесс декодирования RLP следующий:

1. в соответствии с первым байтом (т. е. префиксом) входных данных и декодирования типа данных, длины фактических данных и смещения;

2. в соответствии с типом и смещением данных соответствующим образом декодируйте данные, соблюдая правило минимального кодирования для положительных целых чисел;

3. продолжить декодирование остальных входных данных;

Правила декодирования типов данных и смещения следующие:

1. данные являются строкой, если диапазон первого байта (т. е. префикса) — [0x00, 0x7f], и строка — это в точности сам первый байт;

2. данные являются строкой если значение первого байта (т.е. префикса) находится в промежутке [0x80, 0xb7] и последующей строкой, длина которой равно значению первого байта минус 0x80;

3. данные являются строкой, если значение первого байта (т.е. префикса) находится в промежутке [0xb8, 0xbf] и длина строки чья длина в байтах равна значению первого байта минус 0xb7 после первого байта и последующая строка;

4. данные являются списком, если значение первого байта находится в промежутке [0xc0, 0xf7], и конкатенация RLP кодирований всех элементов списка, следующего за первым байтом, равна значению первого байта минус 0xc0;

5. данные являются списком, если диапазон первого байта — [0xf8, 0xff], и общая полезная нагрузка списка, длина которого равна значению первого байта минус 0xf7, следует за первым байтом, и конкатенация RLP-кодировок всех элементов списка следует за общей полезной нагрузкой списка;

В коде это выражается как:

```python
def rlp_decode(input):
    if len(input) == 0:
        return
    output = ''
    (offset, dataLen, type) = decode_length(input)
    if type is str:
        output = instantiate_str(substr(input, offset, dataLen))
    elif type is list:
        output = instantiate_list(substr(input, offset, dataLen))
    output += rlp_decode(substr(input, offset + dataLen))
    return output

def decode_length(input):
    length = len(input)
    if length == 0:
        raise Exception("входные данные — null")
    prefix = ord(input[0])
    if prefix <= 0x7f:
        return (0, 1, str)
    elif prefix <= 0xb7 and length > prefix - 0x80:
        strLen = prefix - 0x80
        return (1, strLen, str)
    elif prefix <= 0xbf and length > prefix - 0xb7 and length > prefix - 0xb7 + to_integer(substr(input, 1, prefix - 0xb7)):
        lenOfStrLen = prefix - 0xb7
        strLen = to_integer(substr(input, 1, lenOfStrLen))
        return (1 + lenOfStrLen, strLen, str)
    elif prefix <= 0xf7 and length > prefix - 0xc0:
        listLen = prefix - 0xc0;
        return (1, listLen, list)
    elif prefix <= 0xff and length > prefix - 0xf7 and length > prefix - 0xf7 + to_integer(substr(input, 1, prefix - 0xf7)):
        lenOfListLen = prefix - 0xf7
        listLen = to_integer(substr(input, 1, lenOfListLen))
        return (1 + lenOfListLen, listLen, list)
    raise Exception("входные данные не соответствуют формату кодировки RLP")

def to_integer(b):
    length = len(b)
    if length == 0:
        raise Exception("входные данные — null")
    elif length == 1:
        return ord(b[0])
    return ord(substr(b, -1)) + to_integer(substr(b, 0, -1)) * 256
```

## Дополнительные материалы {#further-reading}

- [RLP в Ethereum](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)
- [Ethereum изнутри: RLP](https://medium.com/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58)
- [Coglio, A. (2020). Ethereum's Recursive Length Prefix in ACL2. arXiv preprint arXiv:2009.13769.](https://arxiv.org/abs/2009.13769)

## Смежные темы {#related-topics}

- [Дерево Меркла — Патриции](/developers/docs/data-structures-and-encoding/patricia-merkle-trie)
