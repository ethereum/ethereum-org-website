---
title: کتابخانه های قرارداد هوشمند
description:
lang: fa
---

لازم نیست هر قرارداد هوشمندی را در پروژه خود از ابتدا بنویسید. بسیاری از کتابخانه‌های قراردادهای هوشمند منبع باز موجود هستند که بلوک‌های ساختن قابل استفاده مجدد را برای پروژه شما فراهم می‌کنند که می‌تواند شما را از اختراع مجدد چرخ نجات دهد.

## پیش‌نیازها {#prerequisites}

قبل از ورود به کتابخانه های قرارداد هوشمند، ایده خوبی است که درک خوبی از ساختار قرارداد هوشمند داشته باشید. اگر هنوز این کار را نکرده‌اید، به [آناتومی قراردادهای هوشمند](/developers/docs/smart-contracts/anatomy/) بروید.

## در یک کتابخانه چه چیز است؟ {#whats-in-a-library}

معمولاً می‌توانید دو نوع بلوک ساختن را در کتابخانه‌های قراردادهای هوشمند بیابید: رفتارهای قابل استفاده مجدد که می‌توانید به قراردادهای خود اضافه کنید، و اجرای استانداردهای مختلف.

### رفتارها {#behaviors}

هنگام نوشتن قراردادهای هوشمند، این احتمال وجود دارد که شما بارها و بارها الگوهای مشابهی را بنویسید، مانند اختصاص یک آدرس _ادمین_ برای انجام عملیات محافظت شده در یک قرارداد، یا افزودن دکمه _مکث_ اضطراری در صورت بروز مشکل غیرمنتظره.

کتابخانه‌های قراردادهای هوشمند معمولاً پیاده‌سازی‌های قابل استفاده مجدد از این رفتارها را به‌عنوان [کتابخانه‌ها](https://solidity.readthedocs.io/en/v0.7.2/contracts.html#libraries) یا [ارث‌بری](https://solidity.readthedocs.io/en/v0.7.2/contracts.html#inheritance) در Solidity ارائه می‌کنند.

به عنوان یک مثال، یک نسخه‌ی ساده‌شده از [قرارداد `قابل تصاحب`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/access/Ownable.sol) از [کتابخانه‌ی قراردادهای OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts) را دنبال کنید که یک آدرس را به عنوان مالک قرارداد تعیین می کند و یک اصلاح کننده برای محدود کردن دسترسی به یک روش فقط به آن مالک ارائه می دهد.

```solidity
contract Ownable {
    address public owner;

    constructor() internal {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }
}
```

برای استفاده از یک بلوک مانند این در قرارداد خود، باید ابتدا آن را وارد کنید، و سپس آن را در قراردادهای خود بسط دهید. این به شما امکان می دهد از اصلاح کننده ارائه شده توسط قرارداد پایه `Ownable` برای ایمن‌سازی توابع خود استفاده کنید.

```solidity
import ".../Ownable.sol"; // Path to the imported library

contract MyContract is Ownable {
    // The following function can only be called by the owner
    function secured() onlyOwner public {
        msg.sender.transfer(1 ether);
    }
}
```

یک مثال محبوب دیگر [SafeMath](https://docs.openzeppelin.com/contracts/3.x/utilities#math) یا [DsMath](https://dappsys.readthedocs.io/en/latest/ds_math.html) است. اینها کتابخانه‌هایی هستند (برخلاف قراردادهای پایه) که توابع حسابی را با بررسی‌های سرریز ارائه می‌کنند که توسط زبان ارائه نمی‌شود. استفاده از هر یک از این کتابخانه ها به جای عملیات محاسباتی بومی برای محافظت از قرارداد شما در برابر سرریزها، که می تواند عواقب فاجعه باری داشته باشد، تمرین خوبی است!

### استاندارد‌ها {#standards}

برای تسهیل [ترکیب پذیری و قابلیت همکاری](/developers/docs/smart-contracts/composability/)، جامعه‌ی اتریوم چند استاندارد به شکل **ERCها** طراحی کرده‌ است. شما می‌توانید درباره‌ی آن‌ها در بخش [استانداردها](/developers/docs/standards/) بیشتر بخوانید.

هنگامی که یک ERC را به عنوان بخشی از قراردادهای خود درج می کنید، ایده خوبی است که به جای اجرای پیاده‌سازی های خود، به دنبال پیاده‌سازی های استاندارد باشید. بسیاری از کتابخانه های قراردادهای هوشمند شامل پیاده‌سازی هایی برای محبوب ترین ERC ها هستند. برای مثال [استاندارد توکن‌های قابل معاوضه ERC20](/developers/tutorials/understand-the-erc-20-token-smart-contract/) که همه‌جا وجود دارد می‌توانند در [HQ20](https://github.com/HQ20/contracts/blob/master/contracts/token/README.md)، [DappSys](https://github.com/dapphub/ds-token/) و [OpenZeppelin](https://docs.openzeppelin.com/contracts/3.x/erc20) یافت شوند. علاوه بر این، برخی از ERC ها نیز پیاده‌سازی های متعارف را به عنوان بخشی از خود ERC ارائه می دهند.

شایان ذکر است که برخی از ERC ها مستقل نیستند، بلکه اضافه شده به سایر ERC ها هستند. برای مثال، [ERC2612](https://eips.ethereum.org/EIPS/eip-2612) یک افزونه‌ای به ERC20 برای بهبود استفاده‌اش اضافه می‌کند.

## چگونه یک کتابخانه اضافه کنیم {#how-to}

برای دستورالعمل‌های خاص در مورد نحوه گنجاندن کتابخانه در پروژه، همیشه به مستندات کتابخانه‌ای که اضافه می‌کنید مراجعه کنید. چندین کتابخانه قرارداد Solidity با استفاده از `npm` بسته بندی شده اند، بنابراین شما می توانید آنها را `npm install` کنید. بیشتر ابزارهای [کامپایل کردن](/developers/docs/smart-contracts/compiling/) قراردادها، به `node_modules` برای کتابخانه‌های قرارداد هوشمند نگاه می‌کنند، در نتیجه شما می‌توانید به روش زیر عمل کنید:

```solidity
// This will load the @openzeppelin/contracts library from your node_modules
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract MyNFT is ERC721 {
    constructor() ERC721("MyNFT", "MNFT") public { }
}
```

صرف نظر از روشی که استفاده می‌کنید، هنگام گنجاندن کتابخانه، همیشه به نسخه [زبان](/developers/docs/smart-contracts/languages/) توجه داشته باشید. به عنوان مثال، اگر قراردادهای خود را در Solidity 0.5 می نویسید، نمی توانید از کتابخانه برای Solidity 0.6 استفاده کنید.

## چه زمانی استفاده کنیم {#when-to-use}

استفاده از کتابخانه قرارداد هوشمند برای پروژه شما مزایای متعددی دارد. اول از همه، با ارائه بلوک‌های ساخت آماده‌ای که می‌توانید در سیستم خود بگنجانید، در وقت شما صرفه‌جویی می‌کند، نه اینکه خودتان آن‌ها را کدنویسی کنید.

امنیت نیز یک مزیت اصلی است. کتابخانه های قراردادهای هوشمند منبع باز نیز اغلب به شدت مورد بررسی قرار می گیرند. با توجه به اینکه بسیاری از پروژه‌ها به آنها وابسته هستند، جامعه انگیزه زیادی برای نگه داشتن آنها تحت بررسی دائمی دارد. یافتن خطا در کد برنامه بسیار رایج تر از کتابخانه های قراردادی قابل استفاده مجدد است. برخی از کتابخانه‌ها نیز برای امنیت بیشتر تحت [ممیزی‌های خارجی](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/audits) قرار می‌گیرند.

با این حال، استفاده از کتابخانه‌های قرارداد هوشمند خطر گنجاندن کدهایی را که با آن‌ها آشنا نیستید در پروژه خود به همراه دارد. وسوسه انگیز است که یک قرارداد را وارد کنید و آن را مستقیماً در پروژه خود شامل کنید، اما بدون درک خوب از آنچه آن قرارداد انجام می دهد، ممکن است به دلیل یک رفتار غیرمنتظره به طور ناخواسته مشکلی را در سیستم خود وارد کنید. همیشه مطمئن شوید که مستندات کدی را که وارد می‌کنید بخوانید و سپس قبل از اینکه آن را بخشی از پروژه خود کنید، خود کد را بررسی کنید!

در آخر، هنگام تصمیم گیری در مورد گنجاندن کتابخانه، استفاده کلی از آن را در نظر بگیرید. یک مورد که به طور گسترده پذیرفته شده است و دارای مزایای داشتن یک جامعه بزرگتر و افراد بیشتر در آن برای رسیدگی به مسائل است. هنگام ساخت با قراردادهای هوشمند، امنیت باید تمرکز اصلی شما باشد!

## ابزارهای مرتبط {#related-tools}

**قراردادهای OpenZeppelin -** **_محبوب ترین کتابخانه برای توسعه قراردادهای هوشمند ایمن._**

- [مستندات](https://docs.openzeppelin.com/contracts/)
- [گیت هاب](https://github.com/OpenZeppelin/openzeppelin-contracts)
- [انجمن گفتگو](https://forum.openzeppelin.com/c/general/16)

**DappSys -** **_بلوک های ساخت ایمن، ساده و انعطاف‌پذیر برای قراردادهای هوشمند._**

- [مستندات](https://dappsys.readthedocs.io/)
- [گیت هاب](https://github.com/dapphub/dappsys)

**HQ20 -** **_یک پروژه Solidity با قراردادها، کتابخانه ها و نمونه هایی که به شما کمک می کند تا برنامه های کاربردی توزیع شده با ویژگی های کامل را برای دنیای واقعی بسازید._**

- [گیت هاب](https://github.com/HQ20/contracts)

**کیت توسعه نرم‌افزار سالیدیتی Thirdweb-****_ ابزار های لازم برای ساخت قراردادهای هوشمند بهینه و مؤثر را در اختیار توسعه دهندگان میگذارد_**

- [اسناد](https://portal.thirdweb.com/solidity/)
- [گیت هاب](https://github.com/thirdweb-dev/contracts)

## آموزش های مرتبط {#related-tutorials}

- [ملاحظات امنیتی برای توسعه دهندگان اتریوم](/developers/docs/smart-contracts/security/) _- آموزشی در مورد ملاحظات امنیتی هنگام ساخت قراردادهای هوشمند، از جمله استفاده از کتابخانه._
- [فهم قرارداد هوشمند توکن ERC-20](/developers/tutorials/understand-the-erc-20-token-smart-contract/) _- آموزشی بر استاندارد ERC20، فراهم شده توسط چندین کتابخانه._

## بیشتر بخوانید {#further-reading}

_می‌خواهید در مورد منابع جامعه که به شما کمک کرده بدانید؟ این صفحه را ویرایش و اضافه کنید!_
