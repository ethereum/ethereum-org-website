---
title: امنیت قرارداد هوشمند
description: مروری بر دستورالعمل‌های ساخت قراردادهای هوشمند ایمن در اتریوم
lang: fa
---

قراردادهای هوشمند بسیار انعطاف‌پذیر هستند و می توانند مقادیر زیادی از ارزش و داده را کنترل کنند، در حالی که منطق تغییرناپذیر مبتنی بر کد مستقر در بلاک چین را اجرا می کنند. این یک اکوسیستم پر جنب و جوش از برنامه های کاربردی بی نیاز از اعتماد و غیرمتمرکز ایجاد کرده است که مزایای زیادی را نسبت به سیستم های قدیمی ارائه می دهد. آنها همچنین فرصت‌هایی را برای مهاجمانی که به دنبال سودجویی از طریق سوءاستفاده از آسیب‌پذیری‌ها در قراردادهای هوشمند هستند، نشان می‌دهند.

بلاک چین های عمومی، مانند اتریوم، مسئله ایمن‌سازی قراردادهای هوشمند را پیچیده‌تر و سخت‌تر می کند. _معمولا_ پس از استقرار کد قرارداد در شبکه، نمی‌توان آن را به منظور رفع نقص های امنیتی را تغییر داد، در حالی که ردیابی دارایی های دزدیده شده از قراردادهای هوشمند بسیار دشوار است و عمدتاً به دلیل تغییر ناپذیری قابل بازیابی نیستند.

اگرچه اعداد و ارقام متفاوت است، تخمین زده می شود که کل ارزش سرقت شده یا از دست رفته به دلیل نقص امنیتی در قراردادهای هوشمند به راحتی بیش از یک میلیارد دلار است. این شامل حوادث پرمخاطب، مانند [هک DAO](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/) (3.6M اتریوم دزدیده شده، به ارزش بیش از 1 میلیارد دلار در قیمت های امروزی)، [هک کیف پول چند علامتی Parity](https://www.coindesk.com/30-million-ether-reported-stolen-parity-wallet-breach) (30 میلیون دلار از دست هکرها) و [ مشکل کیف پول منجمد شده](https://www.theguardian.com/technology/2017/nov/08/cryptocurrency-300m-dollars-stolen-bug-ether) (بیش از 300 میلیون دلار ETH برای همیشه قفل شده است).

مسائل ذکر شده، توسعه دهندگان را مجبور می‌کند تا تلاش کنند قراردادهای هوشمند ایمن، نبوغ آمیز و منعطف بسازند. امنیت قراردادهای هوشمند یک تجارت جدی است و هر توسعه‌دهنده‌ای باید آن را یاد بگیرد. این راهنما ملاحظات امنیتی برای توسعه دهندگان اتریوم را پوشش می دهد و منابعی را برای بهبود امنیت قراردادهای هوشمند بررسی می کند.

## پیش‌نیازها {#prerequisites}

قبل از پرداختن به امنیت، مطمئن شوید که با [مبانی توسعه قرارداد هوشمند](/developers/docs/smart-contracts/) آشنا هستید.

## دستورالعمل هایی برای ساخت قراردادهای هوشمند ایمن در اتریوم {#smart-contract-security-guidelines}

### 1. کنترل های دسترسی طراحی مناسب {#design-proper-access-controls}

در قراردادهای هوشمند، عملکردهایی که `public` یا `external` علامت‌گذاری شده‌اند، می‌توانند توسط هر حساب تحت مالکیت خارجی (EOA) یا حساب قراردادی فراخوانی شوند. اگر می‌خواهید دیگران با قرارداد شما در تعامل باشند، مشخص کردن نمای عمومی برای عملکردها ضروری است. با این حال، عملکردهایی که با `private` علامت‌گذاری شده‌اند، فقط توسط توابع داخل قرارداد هوشمند فراخوانی می‌شوند و در حساب‌های خارجی مورد استفاده قرار نمی گیرند. دادن دسترسی به هر یک از شرکت‌کنندگان شبکه به توابع قرارداد می‌تواند باعث ایجاد مشکلاتی شود، به‌ویژه اگر به این معنی باشد که هر کسی بتواند عملیات حساس را انجام دهد (به عنوان مثال، استخراج توکن‌های جدید).

برای جلوگیری از استفاده غیرمجاز از توابع قرارداد هوشمند، لازم است کنترل های دسترسی ایمن را اجرا کنید. مکانیسم‌های کنترل دسترسی، توانایی استفاده از عملکردهای خاص در یک قرارداد هوشمند را به نهادهای تایید شده، مانند حساب‌های مسئول مدیریت قرارداد، محدود می‌کند. **الگوی مالکیت** و **کنترل مبتنی بر نقش** دو الگوی مفید برای اجرای کنترل دسترسی در قراردادهای هوشمند هستند:

#### الگوی قابل مالکیت {#ownable-pattern}

در الگویل قابل مالکیت، یک آدرس به عنوان "مالک" قرارداد در طول فرآیند ایجاد قرارداد تنظیم می شود. به توابع محافظت شده یک اصلاح‌کننده `OnlyOwner` اختصاص داده می‌شود، که تضمین می‌کند قرارداد قبل از اجرای تابع، هویت آدرس تماس را تأیید می‌کند. تماس‌های توابع محافظت‌شده از آدرس‌های دیگر به غیر از مالک قرارداد، همیشه برمی‌گردند و از دسترسی ناخواسته جلوگیری می‌کنند.

#### کنترل دسترسی مبتنی بر نقش {#role-based-access-control}

ثبت یک آدرس واحد به‌عنوان `Owner` در یک قرارداد هوشمند، خطر تمرکز را معرفی می‌کند و نشان‌دهنده یک نقطه شکست واحد است. اگر کلیدهای حساب مالک به خطر بیفتد، مهاجمان می توانند به قرارداد مالکیت حمله کنند. به همین دلیل است که استفاده از الگوی کنترل دسترسی مبتنی بر نقش با چندین حساب اداری ممکن است گزینه بهتری باشد.

در کنترل دسترسی مبتنی بر نقش، دسترسی به عملکردهای حساس بین مجموعه ای از شرکت کنندگان قابل اعتماد توزیع می شود. به عنوان مثال، یک حساب ممکن است مسئول ضرب توکن ها باشد، در حالی که حساب دیگری ارتقاء داده یا قرارداد را متوقف می کند. غیرمتمرکز کردن کنترل دسترسی به این روش، نقاط منفرد شکست را از بین می برد و مفروضات اعتماد را برای کاربران کاهش می دهد.

##### استفاده از کیف پول‌های چند امضایی

روش دیگر برای اجرای کنترل دسترسی ایمن استفاده از [حساب چند امضایی](/developers/docs/smart-contracts/#multisig) برای مدیریت قرارداد است. برخلاف یک EOA معمولی، حساب‌های چند امضایی متعلق به چندین نهاد هستند و برای انجام تراکنش‌ها به امضای حداقل تعداد حساب‌ها (مثلاً 3 از 5) نیاز دارند.

استفاده از مالتی سیگ برای کنترل دسترسی، یک لایه امنیتی اضافی را معرفی می‌کند زیرا اقدامات روی قرارداد هدف مستلزم رضایت چندین طرف است. این مورد به ویژه در صورتی مفید است که استفاده از الگوی اونبل (Ownable) ضروری باشد، زیرا دستکاری عملکردهای حساس قرارداد برای اهداف مخرب را برای مهاجم دشوارتر می‌کند.

### 2. برای محافظت از عملیات قرارداد از عبارات require() و assert() و revert() استفاده کنید {#use-require-assert-revert}

همانطور که گفته شد، هر کسی می‌تواند توابع عمومی را در قرارداد هوشمند شما پس از استقرار در بلاک‌چین فراخوانی کند. از آنجایی که نمی‌توانید از قبل بدانید حساب‌های خارجی چگونه با یک قرارداد تعامل خواهند داشت، بهتراست که قبل از استقرار، حفاظت‌های داخلی در برابر عملیات مشکل‌ساز را اجرا کنید. می‌توانید با استفاده از دستورات `require()`، `assert()` و `revert()` رفتار صحیح را در قراردادهای هوشمند برای راه‌اندازی استثناها و برگرداندن تغییرات حالت اعمال کنید، در صورتی که اجرا نتواند الزامات خاصی را برآورده کند.

**`require()`**: دستورها `require` در شروع توابع تعریف می‌شوند و اطمینان می‌دهند که شرایط از پیش تعریف شده قبل از اجرای تابع فراخوانی شده برآورده می‌شوند. یک عبارت `require` را می‌توان برای اعتبارسنجی ورودی های کاربر، بررسی متغیرهای حالت، یا احراز هویت حساب فراخوان قبل از پیشرفت با یک تابع استفاده کرد.

**`assert()`**: دستور `assert()` برای شناسایی خطاهای داخلی و بررسی نقض "invariants" در کد شما استفاده می شود. یک invariant یک ادعای منطقی در مورد وضعیت قرارداد است که باید برای اجرای همه توابع صادق باشد. یک مثال ثابت، حداکثر عرضه یا موجودی یک قرارداد توکن است. استفاده از `assert()` تضمین می‌کند که قرارداد شما هرگز به یک وضعیت آسیب‌پذیر نمی‌رسد، و در صورت رسیدن، همه تغییرات در متغیرهای حالت برگردانده می‌شوند.

**`revert()`**: دستور `revert()` را می توان در یک عبارت if-else استفاده کرد که در صورت عدم رعایت شرایط مورد نیاز، یک استثنا ایجاد می کند. قرارداد نمونه زیر از `revert()` برای محافظت از اجرای توابع استفاده می کند:

```
pragma solidity ^0.8.4;

contract VendingMachine {
    address owner;
    error Unauthorized();
    function buy(uint amount) public payable {
        if (amount > msg.value / 2 ether)
            revert("Not enough Ether provided.");
        // Perform the purchase.
    }
    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}
```

### 3. قراردادهای هوشمند را تست کنید و صحت کد را تأیید کنید {#test-smart-contracts-and-verify-code-correctness}

تغییرناپذیری کدهای در حال اجرا در [ماشین مجازی اتریوم](/developers/docs/evm/) به این معنی است که قراردادهای هوشمند سطح بالاتری از ارزیابی کیفیت را در مرحله توسعه می طلبد. تست قرارداد خود به طور گسترده و مشاهده آن برای نتایج غیرمنتظره امنیت را تا حد زیادی بهبود می‌بخشد و در دراز مدت از کاربران شما محافظت می‌کند.

روش معمول نوشتن تست‌های واحد کوچک با استفاده از داده‌های ساختگی است که انتظار می‌رود قرارداد را از کاربران دریافت کند. [آزمایش Unit](/developers/docs/smart-contracts/testing/#unit-testing) برای آزمایش عملکرد عملکردهای خاص و اطمینان از اینکه قرارداد هوشمند مطابق انتظار عمل می کند خوب است.

متأسفانه، تست واحد برای بهبود امنیت قراردادهای هوشمند زمانی که به صورت مجزا مورد استفاده قرار می‌گیرد، حداقل مؤثر است. یک تست واحد ممکن است ثابت کند که یک تابع برای داده‌های ساختگی به درستی اجرا می‌شود، اما تست‌های واحد فقط به اندازه تست‌های نوشته شده مؤثر هستند. این امر تشخیص موارد لبه از دست رفته و آسیب پذیری هایی را که می تواند ایمنی قرارداد هوشمند شما را به هم بزند، دشوار می کند.

یک رویکرد بهتر ترکیب آزمایش واحد با آزمایش مبتنی بر ویژگی است که با استفاده از [تحلیل استاتیک و پویا](/developers/docs/smart-contracts/testing/#static-dynamic-analysis) انجام می‌شود. تجزیه و تحلیل استاتیک بر نمایش‌های سطح پایین، مانند [گراف‌های جریان کنترل](https://en.wikipedia.org/wiki/Control-flow_graph) و[درخت‌های نحو انتزاعی](https://deepsource.io/glossary/ast/) برای تجزیه و تحلیل وضعیت‌های قابل دسترسی برنامه و مسیرهای اجرا. در همین حال، تکنیک‌های تحلیل پویا، مانند [فازی قرارداد هوشمند](https://www.cyfrin.io/blog/smart-contract-fuzzing-and-invariants-testing-foundry)، قرارداد را اجرا می‌کنند. کد با مقادیر ورودی تصادفی برای شناسایی عملیاتی که ویژگی‌های امنیتی را نقض می‌کند.

[تأیید رسمی](/developers/docs/smart-contracts/formal-verification) تکنیک دیگری برای تأیید ویژگی‌های امنیتی در قراردادهای هوشمند است. برخلاف تست‌های معمولی، تأیید رسمی می‌تواند به طور قطعی عدم وجود خطا در یک قرارداد هوشمند را ثابت کند. این امر با ایجاد یک مشخصات رسمی که ویژگی‌های امنیتی مورد نظر را نشان می‌دهد و اثبات اینکه مدل رسمی قراردادها به این مشخصات پایبند است، به دست می‌آید.

### 4. درخواست بررسی مستقل کد خود را داشته باشید {#get-independent-code-reviews}

پس از تست قرارداد خود، بهتر است از دیگران بخواهید که کد منبع را برای هرگونه مشکل امنیتی بررسی کنند. تست تمام ایرادات یک قرارداد هوشمند را آشکار نمی‌کند، اما دریافت یک بررسی مستقل امکان شناسایی آسیب پذیری‌ها را افزایش می‌دهد.

#### حسابرسی‌های امنیتی {#audits}

راه‌اندازی آدیت قرارداد هوشمند یکی از راه‌های انجام بررسی مستقل کد است. حسابرسان یا آدیتورها نقش مهمی در حصول اطمینان از ایمن بودن قراردادهای هوشمند و عاری از نقص کیفی و خطاهای طراحی دارند.

با وجود همه‌ی این موارد، شما نباید با حسابرسی امنیتی مانند پاسخی برای تمام مشکلات برخورد کنید. آدیت قراردادهای هوشمند هر اشکالی را شناسایی نمی‌کند و عمدتاً برای ارائه یک سری بررسی اضافی طراحی شده است که می‌تواند به شناسایی مشکلاتی که توسعه دهندگان در طول توسعه و تست اولیه از قلم انداخته‌اند کمک کند. همچنین باید بهترین روش‌ها را برای کار با حسابرسان، مانند مستندسازی کد به درستی و افزودن نظرات درون خطی، دنبال کنید تا از مزایای حسابرسی قرارداد هوشمند به حداکثر برسانید.

- [نکات حسابرسی قرارداد هوشمند و amp; ترفندها](https://twitter.com/tinchoabbate/status/1400170232904400897) - _@tinchoabbate_
- [از حسابرسی خود حداکثر استفاده را ببرید](https://inference.ag/blog/2023-08-14-tips/)

#### پاداش‌های باگ {#bug-bounties}

راه اندازی یک برنامه باگ بانتی روش دیگری برای اجرای بررسی کدهای خار‌جی است. جایزه باگ یک پاداش مالی است که به افرادی (معمولاً هکرهای کلاه سفید) که آسیب‌پذیری‌های یک برنامه را کشف می‌کنند، داده می‌شود.

هنگامی که به درستی استفاده می‌شود، پاداش‌های باگ به اعضای جامعه هکر انگیزه می‌دهد تا کد شما را از نظر نقص‌های مهم بررسی کنند. یک مثال واقعی "باگ پول بی‌نهایت" است که به مهاجم اجازه می‌دهد مقدار نامحدودی اتر را در [آپتیمیزم](https://www.optimism.io/) ایجاد کند، یک < یک پروتکل لایه که روی اتریوم اجرا می‌شود. خوشبختانه، یک هکر whitehat [این نقص را کشف کرد](https://www.saurik.com/optimism.html) و به تیم اطلاع داد، [کسب پرداختی بزرگ در این فرآیند انجام شد](https://cryptoslate.com/in-ethereum-l2-optimism-2m-bounty-paid/) بحرانی-اشکال-.

یک استراتژی مفید این است که پرداخت برنامه پاداش اشکال را متناسب با مقدار وجوه مورد نظر تنظیم کنید. این رویکرد به‌عنوان «[اشکال مقیاس‌گذاری](https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7) توصیف می‌شود. انگیزه‌های مالی برای افراد برای افشای مسئولانه آسیب پذیری‌ها به جای سوء استفاده از آنها را ایجاد می‌کند.

### 5. در هنگام توسعه قراردادهای هوشمند بهترین رویه های موجود را دنبال کنید {#follow-smart-contract-development-best-practices}

وجود آدیت و پاداش باگ مسئولیت شما را برای نوشتن کد با کیفیت بالا توجیه نمی‌کند. امنیت قرارداد هوشمند خوب با فرآیندهای طراحی و توسعه مناسب زیر شروع می‌شود:

- همه کدها را در یک سیستم کنترل نسخه مانند git ذخیره کنید

- تمام تغییرات کد را از طریق درخواست‌های pull انجام دهید

- اطمینان حاصل کنید که درخواست‌های pull حداقل یک بازبین مستقل دارند—اگر به تنهایی روی پروژه‌ای کار می‌کنید، توسعه‌دهندگان دیگر و بررسی‌های کد تجاری را پیدا کنید

- از یک [محیط توسعه](/developers/docs/frameworks/) برای آزمایش، کامپایل، استقرار قراردادهای هوشمند استفاده کنید

- کد خود را از طریق ابزارهای اصلی تجزیه و تحلیل کد، مانند [Cyfrin Aaderyn](https://github.com/Cyfrin/aderyn)، Mythril و Slither اجرا کنید. در حالت ایده‌آل، باید این کار را قبل از ادغام هر درخواست pull انجام دهید و تفاوت‌ها را در خروجی مقایسه کنید

- مطمئن شوید که کد شما بدون خطا کامپایل شده است و کامپایلر سالیدیتی هیچ هشداری صادر نمی‌کند

- کد خود را به درستی مستند کنید (با استفاده از [NatSpec](https://solidity.readthedocs.io/en/develop/natspec-format.html)) و جزئیات مربوط به معماری قرارداد را به آسانی شرح دهید. این کار بررسی و بازبینی کد شما را برای دیگران آسان‌تر می‌کند.

### 6. اجرای طرح‌های قوی بازیابی حوادث {#implement-disaster-recovery-plans}

طراحی کنترل‌های دسترسی ایمن، اجرای اصلاح‌کننده‌های عملکرد و سایر پیشنهادها می‌تواند امنیت قرارداد هوشمند را بهبود بخشد، اما نمی‌تواند احتمال سوء استفاده‌های مخرب را رد کند. ایجاد قراردادهای هوشمند ایمن مستلزم «آماده شدن برای شکست» و داشتن یک برنامه بازگشتی برای پاسخگویی مؤثر به حملات است. یک طرح مناسب برای بازیابی حوادث شامل برخی یا همه اجزای زیر است:

#### ارتقاهای قرارداد {#contract-upgrades}

در حالی که قراردادهای هوشمند اتریوم به طور پیش فرض تغییر ناپذیر هستند، می‌توان با استفاده از الگوهای ارتقا به درجاتی از تغییرپذیری دست یافت. به روز رسانی قراردادها در مواردی ضروری است که یک نقص مهم قرارداد قدیمی شما را غیرقابل استفاده می‌کند و به کارگیری منطق جدید امکان پذیرترین گزینه است.

مکانیسم‌های ارتقای قرارداد متفاوت عمل می‌کنند، اما «الگوی پروکسی» یکی از محبوب‌ترین رویکردها برای ارتقای قراردادهای هوشمند است. [الگوهای پراکسی](https://www.cyfrin.io/blog/upgradeable-proxy-smart-contract-pattern) منطق اجرائی و فضای ذخیره‌سازی داده‌ها را بین _دو_ قرارداد تقسیم می‌کند. قرارداد اول (که "قرارداد پراکسی" نامیده می‌شود) متغیرهای حالت را ذخیره می‌کند (به عنوان مثال، موجودی کاربر)، در حالی که قرارداد دوم (که "منطق قرارداد" نامیده می‌شود) کد اجرای توابع قرارداد را نگه می‌دارد.

حساب‌ها با قرارداد پروکسی تعامل دارند، که همه فراخوانی‌های تابع را با استفاده از [`delegatecall()`](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries) به قرارداد منطقی ارسال می‌کند.  تماس سطح پایین. برخلاف یک تماس پیامی معمولی، `delegatecall()` تضمین می‌کند که کد در حال اجرا در آدرس قرارداد منطقی در متن قرارداد فراخوانی اجرا می‌شود. یک تماس پیامی معمولی، `delegatecall()` تضمین می‌کند که کد در حال اجرا در آدرس قرارداد منطقی در متن قرارداد فراخوانی اجرا می‌شود.

واگذاری تماس‌ها به قرارداد منطقی مستلزم ذخیره آدرس آن در فضای ذخیره‌سازی قرارداد پروکسی است. از این رو، ارتقاء منطق قرارداد فقط به استقرار یک قرارداد منطقی دیگر و ذخیره آدرس جدید در قرارداد پروکسی بستگی دارد. از آنجایی که فراخوانی یا تماس‌های بعدی به قرارداد پروکسی به طور خودکار به قرارداد منطقی جدید هدایت می‌شوند، می‌توانید قرارداد را بدون تغییر واقعی کد «ارتقاء» می‌دادید.

[اطلاعات بیشتر در مورد ارتقاء قراردادها](/developers/docs/smart-contracts/upgrading/).

#### توقف‌های اضطراری {#emergency-stops}

همانطور که گفته شد، آدیت و آزمایش گسترده نمی‌تواند تمام اشکالات یک قرارداد هوشمند را کشف کند. اگر پس از استقرار یک آسیب‌پذیری در کد شما ظاهر شد، اصلاح آن غیرممکن است، زیرا نمی‌توانید کد در حال اجرا در آدرس قرارداد را تغییر دهید. همچنین، مکانیسم‌های ارتقا (مثلاً الگوهای پروکسی) ممکن است برای پیاده‌سازی زمان ببرد (اغلب به تأیید طرف‌های مختلف نیاز دارند)، که تنها به مهاجمان زمان بیشتری برای ایجاد آسیب بیشتر می‌دهد.

گزینه هسته‌ای اجرای یک تابع "توقف اضطراری" است که تماس‌های عملکردهای آسیب پذیر را در یک قرارداد مسدود می‌کند. توقف‌های اضطراری معمولاً شامل اجزای زیر است:

1. یک متغیر جهانی بولی (Boolean) که نشان می‌دهد قرارداد هوشمند در حالت توقف است یا خیر. این متغیر هنگام تنظیم قرارداد روی `false` تنظیم می‌شود، اما پس از توقف قرارداد به `true` برمی‌گردد.

2. توابعی که در اجرای خود به متغیر بولی (Boolean) اشاره می‌کنند. زمانی که قرارداد هوشمند متوقف نشده باشد، چنین عملکردهایی قابل دسترسی هستند و با فعال شدن ویژگی توقف اضطراری، غیرقابل دسترس می‌شوند.

3. موجودی که به تابع توقف اضطراری دسترسی دارد، که متغیر Boolean را روی `true` تنظیم می‌کند. برای جلوگیری از اعمال مخرب، تماس‌های این تابع را می‌توان به یک آدرس مطمئن محدود کرد (به عنوان مثال، مالک قرارداد).

هنگامی که قرارداد توقف اضطراری را فعال کرد، عملکردهای خاصی قابل فراخوانی نخواهند بود. این مورد با قرار دادن توابع انتخابی در یک اصلاح کننده که به متغیر سراسری ارجاع می‌دهد، به دست می‌آید. در زیر [نمونه‌ای](https://github.com/fravoll/solidity-patterns/blob/master/EmergencyStop/EmergencyStop.sol) وجود دارد که اجرای این الگو را در قراردادها شرح می‌دهد:

```solidity
// This code has not been professionally audited and makes no promises about safety or correctness. Use at your own risk.

contract EmergencyStop {

    bool isStopped = false;

    modifier stoppedInEmergency {
        require(!isStopped);
        _;
    }

    modifier onlyWhenStopped {
        require(isStopped);
        _;
    }

    modifier onlyAuthorized {
        // Check for authorization of msg.sender here
        _;
    }

    function stopContract() public onlyAuthorized {
        isStopped = true;
    }

    function resumeContract() public onlyAuthorized {
        isStopped = false;
    }

    function deposit() public payable stoppedInEmergency {
        // Deposit logic happening here
    }

    function emergencyWithdraw() public onlyWhenStopped {
        // Emergency withdraw happening here
    }
}
```

این مثال ویژگی‌های اساسی توقف‌های اضطراری را نشان می‌دهد:

- `isStopped` یک بولین است که در ابتدا به `false` و هنگامی که قرارداد وارد حالت اضطراری می‌شود `true` ارزیابی می‌شود.

- تغییردهنده تابع `onlyWhenStopped` و `stoppedInEmergency` متغیر `isStopped` را بررسی می‌کنند. `stoppedInEmergency` برای کنترل توابعی استفاده می‌شود که در صورت آسیب‌پذیر بودن قرارداد، غیرقابل دسترسی هستند (به عنوان مثال، `deposit()`). تماس‌های این توابع به سادگی برمی‌گردند.

`onlyWhenStopped` برای توابعی استفاده می‌شود که باید در مواقع اضطراری قابل فراخوانی باشند (مانند `emergencyWithdraw()`). چنین توابعی می‌توانند به حل وضعیت کمک کنند، از این رو آنها را از لیست "عملکردهای محدود" حذف می‌کنند.

استفاده از عملکرد توقف اضطراری یک توقف مؤثر برای مقابله با آسیب پذیری‌های جدی در قرارداد هوشمند شما فراهم می‌کند. با این حال، نیاز کاربران به اعتماد به توسعه‌دهندگان را افزایش می‌دهد تا آن را به دلایل خود خدمتی فعال نکنند. برای این منظور، غیرمتمرکز کردن کنترل توقف اضطراری یا با قرار دادن آن در معرض مکانیزم رای‌گیری زنجیره‌ای، قفل زمانی یا تایید از یک کیف پول مالتی سیگ راه‌حل‌های ممکن است.

#### نظارت بر رویداد {#event-monitoring}

[رویدادها](https://docs.soliditylang.org/en/v0.8.15/contracts.html#events) به شما امکان می‌دهد تماس‌های مربوط به عملکردهای قرارداد هوشمند را ردیابی و تغییرات متغیرهای حالت را نظارت کنید. بهتر است که قرارداد هوشمند خود را طوری برنامه‌ریزی کنید که هر زمان که یکی از طرفین یک اقدام مهم ایمنی (مثلاً برداشت وجه) انجام می‌دهد، رویدادی را منتشر کند.

ثبت رویدادها و نظارت بر آنها به صورت غیر زنجیره‌ای بینش‌هایی در مورد عملیات قرارداد ارائه می‌دهد و به کشف سریع‌تر اقدامات مخرب کمک می‌کند. این بدان معناست که تیم شما می‌تواند سریع‌تر به هک‌ها پاسخ دهد و برای کاهش تأثیر روی کاربران، مانند توقف موقت عملکردها یا انجام ارتقا، اقدام کند.

همچنین می‌توانید ابزار نظارتی خارج از قفسه را انتخاب کنید که به طور خودکار هشدارها را هر زمان که کسی با قراردادهای شما تعامل دارد، ارسال می‌کند. این ابزارها به شما این امکان را می‌دهند که بر اساس محرک‌های مختلف، مانند حجم تراکنش، فرکانس فراخوانی عملکرد، یا عملکردهای خاص، هشدارهای سفارشی ایجاد کنید. برای مثال، می‌توانید هشداری را برنامه‌ریزی کنید که زمانی که مبلغ برداشت شده در یک تراکنش از یک آستانه خاص عبور می‌کند، وارد می‌شود.

### 7. طراحی سیستم‌های حاکمیت ایمن {#design-secure-governance-systems}

ممکن است بخواهید با سپردن کنترل قراردادهای هوشمند اصلی به اعضای جامعه، برنامه خود را غیرمتمرکز کنید. در این مورد، سیستم قرارداد هوشمند شامل یک ماژول حاکمیتی خواهد بود – مکانیزمی که به اعضای جامعه اجازه می‌دهد تا اقدامات اداری را از طریق یک سیستم حاکمیت زنجیره‌ای تأیید کنند. برای مثال، پیشنهادی برای ارتقاء قرارداد پروکسی به یک پیاده‌سازی جدید ممکن است توسط دارندگان توکن به رأی گذاشته شود.

حاکمیت غیرمتمرکز می تواند سودمند باشد، به ویژه به این دلیل که منافع توسعه دهندگان و کاربران نهایی را همسو می کند. با این وجود، مکانیسم‌های حکمرانی قراردادهای هوشمند ممکن است در صورت اجرای نادرست، خطرات جدیدی را ایجاد کنند. یک سناریوی قابل قبول این است که مهاجم با گرفتن [وام فوری](/defi/#flash-loans) قدرت رای عظیمی (که بر حسب تعداد توکن‌های نگهداری شده اندازه‌گیری می‌شود) به دست‌آورد و یک پیشنهاد مخرب را انجام دهد.

یکی از راه های جلوگیری از مشکلات مربوط به حاکمیت زنجیره ای، [استفاده از قفل زمانی](https://blog.openzeppelin.com/protect-your-users-with-smart-contract-timelocks/) است. قفل زمانی مانع از اجرای یک قرارداد هوشمند تا زمان مشخصی می شود. راهبردهای دیگر عبارتند از اختصاص یک "وزن رای" به هر توکن بر اساس مدت زمانی که قفل شده است، یا اندازه گیری قدرت رای دادن یک آدرس در یک دوره تاریخی (مثلاً 2-3 بلوک در گذشته) به جای بلوک فعلی. هر دو روش امکان جمع‌آوری سریع قدرت رای برای تغییر آرای زنجیره ای را کاهش می دهند.

اطلاعات بیشتر در مورد [طراحی سیستم‌های حاکمیت ایمن](https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/)، [مکانیسم‌های رای‌گیری مختلف در DAOها](https://hackernoon.com/governance-is-the-holy-grail-for-daos)، و [بردارهای رایج حمله DAO با استفاده از دیفای](https://dacian.me/dao-governance-defi-attacks) در لینک‌های مشترک.

### 8. کاهش پیچیدگی کد به حداقل {#reduce-code-complexity}

توسعه دهندگان نرم‌افزار سنتی با اصل KISS ("ساده نگهش دار، احمقانه") آشنا هستند، که توصیه می کند از وارد کردن پیچیدگی های غیر ضروری در طراحی نرم‌افزار خودداری کنید. این امر متعاقب این تفکر دیرینه است که "سیستم های پیچیده به روش های پیچیده شکست می خورند" و بیشتر مستعد خطاهای پرهزینه هستند.

با توجه به اینکه قراردادهای هوشمند به طور بالقوه مقادیر زیادی از ارزش را کنترل می کنند، ساده نگه داشتن چیزها هنگام نوشتن قراردادهای هوشمند از اهمیت ویژه ای برخوردار است. نکته ای برای دستیابی به سادگی هنگام نوشتن قراردادهای هوشمند، استفاده مجدد از کتابخانه های موجود، مانند [قراردادهای OpenZeppelin](https://docs.openzeppelin.com/contracts/4.x/)، در صورت امکان است. از آنجایی که این کتابخانه ها به طور گسترده توسط توسعه دهندگان ممیزی و آزمایش شده اند، استفاده از آنها با نوشتن عملکردهای جدید از ابتدا، شانس معرفی اشکالات را کاهش می دهد.

توصیه رایج دیگر نوشتن توابع کوچک و مدولار نگه داشتن قراردادها با تقسیم منطق تجاری در چندین قرارداد است. نه تنها نوشتن کد ساده‌تر سطح حمله را در یک قرارداد هوشمند کاهش می‌دهد، بلکه استدلال درباره درستی سیستم کلی و تشخیص زودهنگام خطاهای احتمالی طراحی را آسان‌تر می‌کند.

### 9. دفاع در برابر آسیب‌پذیری‌های رایج قرارداد هوشمند {#mitigate-common-smart-contract-vulnerabilities}

#### ورود دوباره {#reentrancy}

EVM اجازه همزمانی را نمی دهد، به این معنی که دو قرارداد درگیر در یک تماس پیام نمی توانند به طور همزمان اجرا شوند. یک فراخوانی خارجی، اجرای قرارداد و حافظه فراخوان را تا زمانی که تماس برگردد، متوقف می‌کند، در این مرحله اجرا به طور معمول ادامه می‌یابد. این فرآیند را می توان به طور رسمی به عنوان انتقال [جریان کنترل](https://www.computerhope.com/jargon/c/contflow.htm) به قرارداد دیگری توصیف کرد.

اگرچه اغلب بی ضرر هستند، اما انتقال جریان کنترل به قراردادهای غیرقابل اعتماد می تواند مشکلاتی مانند ورود دوباره ایجاد کند. یک حمله ورود دوباره زمانی اتفاق می‌افتد که یک قرارداد مخرب قبل از تکمیل فراخوانی عملکرد اصلی، یک قرارداد آسیب‌پذیر را دوباره فراخوانی کند. این نوع حمله به بهترین شکل با یک مثال توضیح داده می شود.

یک قرارداد هوشمند ساده ("قربانی") را در نظر بگیرید که به هر کسی اجازه می دهد اتر را واریز و برداشت کند:

```solidity
// This contract is vulnerable. Do not use in production

contract Victim {
    mapping (address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

این قرارداد یک تابع `withdraw()` را نشان می‌دهد تا به کاربران امکان می‌دهد ETH را که قبلاً در قرارداد سپرده شده برداشت کنند. هنگام پردازش یک برداشت، قرارداد عملیات زیر را انجام می‌دهد:

1. تعادل اتر کاربر را بررسی می‌کند
2. وجوه را به آدرس تماس ارسال می‌کند
3. موجودی آنها را به 0 بازنشانی می‌کند و از برداشت اضافی از کاربر جلوگیری می‌کند

تابع `withdraw()` در قرارداد ` قربانی` از الگوی "بررسی-تعامل-اثرات" پیروی می کند. که _بررسی می‌کند_ آیا شرایط لازم برای اجرا برآورده شده است (یعنی کاربر دارای موجودی ETH مثبت است) و قبل از اعمال _اثرات_ تراکنش (یعنی کاهش موجودی کاربر) _تعامل_ را با ارسال ETH به آدرس تماس‌گیرنده انجام می‌دهد.

اگر `withdraw()` از یک حساب تحت مالکیت خارجی (EOA) فراخوانی شود، تابع همانطور که انتظار می رود اجرا می شود: `msg.sender.call.value()` ETH را برای تماس گیرنده ارسال می کند. با این حال، اگر `msg.sender` یک حساب قرارداد هوشمند باشد، `withdraw()` را فراخوانی می‌کند، ارسال وجوه با استفاده از `msg.sender.call.value()` انجام می‌شود. همچنین کدهای ذخیره شده در آن آدرس را برای اجرا راه اندازی کنید.

تصور کنید این کدی است که در آدرس قرارداد مستقر شده است:

```solidity
 contract Attacker {
    function beginAttack() external payable {
        Victim(victim_address).deposit.value(1 ether)();
        Victim(victim_address).withdraw();
    }

    function() external payable {
        if (gasleft() > 40000) {
            Victim(victim_address).withdraw();
        }
    }
}
```

این قرارداد برای انجام سه کار طراحی شده است:

1. پذیرش سپرده از حساب دیگری (احتمالاً EOA مهاجم)
2. واریز یک سکه ETH به قرارداد قربانی
3. برداشت یک سکه ETH ذخیره شده در قرارداد هوشمند

هیچ مشکلی در اینجا وجود ندارد، به جز اینکه `مهاجم` تابع دیگری دارد که اگر گس باقی مانده از `msg.sender.call.value` ورودی بیش از 40،000 باشد.ده باشد، تابع دیگری دارد که `withdraw()` را در ` قربانی` دوباره فراخوانی می‌کند. این به `مهاجم` این امکان را می‌دهد تا `قربانی` را دوباره وارد کرده و وجوه بیشتری را _قبل از_ تکمیل اولین فراخوان `خروج` برداشت کند. چرخه به این صورت است:

```solidity
- Attacker's EOA calls `Attacker.beginAttack()` with 1 ETH
- `Attacker.beginAttack()` deposits 1 ETH into `Victim`
- `Attacker` calls `withdraw() in `Victim`
- `Victim` checks `Attacker`’s balance (1 ETH)
- `Victim` sends 1 ETH to `Attacker` (which triggers the default function)
- `Attacker` calls `Victim.withdraw()` again (note that `Victim` hasn’t reduced `Attacker`’s balance from the first withdrawal)
- `Victim` checks `Attacker`’s balance (which is still 1 ETH because it hasn’t applied the effects of the first call)
- `Victim` sends 1 ETH to `Attacker` (which triggers the default function and allows `Attacker` to reenter the `withdraw` function)
- The process repeats until `Attacker` runs out of gas, at which point `msg.sender.call.value` returns without triggering additional withdrawals
- `Victim` finally applies the results of the first transaction (and subsequent ones) to its state, so `Attacker`’s balance is set to 0
```

خلاصه موضوع این است که چون موجودی تماس‌گیرنده تا زمانی که اجرای تابع کامل نشود روی 0 تنظیم نمی‌شود، فراخوانی‌های بعدی موفق خواهند شد و به تماس‌گیرنده اجازه می‌دهند تا موجودی خود را چندین بار برداشت کند. از این نوع حمله می توان برای تخلیه یک قرارداد هوشمند از وجوه آن استفاده کرد، مانند آنچه در [هک DAO سال 2016](https://www.coindesk.com/learn/2016/06/25/understanding-the-dao-attack/) اتفاق افتاد. همانطور که [فهرست‌های عمومی اکسپلویت‌های reentrancy](https://github.com/pcaversaccio/reentrancy-attacks) نشان می‌دهند، حملات reentrancy امروزه همچنان یک موضوع حیاتی برای قراردادهای هوشمند است.

##### چگونه از حملات بازگشت مجدد جلوگیری کنیم

یک رویکرد برای مقابله با reentrancy، پیروی از [الگوی بررسی-اثرات-تعامل](https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern) است. این الگو دستور اجرای توابع را می‌دهد به گونه‌ای که کدی که بررسی‌های لازم را قبل از پیشرفت در اجرا انجام می‌دهد، ابتدا می‌آید، به دنبال آن کدی که وضعیت قرارداد را دستکاری می‌کند، کدی که با قراردادهای دیگر تعامل دارد یا EOA‌ها در آخر می‌آیند.

الگوی بررسی-اثرات-تعامل در نسخه اصلاح شده قرارداد `قربانی` که در زیر نشان داده شده است استفاده می شود:

```solidity
contract NoLongerAVictim {
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
    }
}
```

این قرارداد یک _بررسی_ در موجودی کاربر انجام می دهد، _اثرات_ تابع `withdraw()` را اعمال می کند (با تنظیم مجدد موجودی کاربر به 0)، و به انجام _تعامل_ (ارسال ETH به آدرس کاربر) ادامه می دهد. این مورد تضمین می‌کند که قرارداد قبل از تماس خارجی، فضای ذخیره‌سازی خود را به‌روزرسانی می‌کند و شرایط ورود مجدد را که اولین حمله را فعال می‌کرد، حذف می‌کند. قرارداد `مهاجم` همچنان می‌تواند به `NoLongerAVictim` برگردد، اما از آنجایی که `balances[msg.sender]` روی 0 تنظیم شده است، برداشت‌های اضافی با خطا مواجه می‌شوند.

گزینه دیگر استفاده از یک قفل محرومیت متقابل (که معمولاً به عنوان "mutex" توصیف می شود) است که بخشی از وضعیت قرارداد را تا زمانی که فراخوانی عملکرد کامل شود قفل می کند. این امر با استفاده از یک متغیر بولین که قبل از اجرای تابع روی `true` تنظیم شده است و پس از انجام فراخوانی به `false` برمی‌گردد پیاده‌سازی می‌شود. همانطور که در مثال زیر مشاهده می‌شود، استفاده از میوتکس از یک تابع در برابر تماس‌های بازگشتی محافظت می‌کند در حالی که فراخوان اصلی هنوز در حال پردازش است، و به طور مؤثر ورود مجدد را متوقف می‌کند.

```solidity
pragma solidity ^0.7.0;

contract MutexPattern {
    bool locked = false;
    mapping(address => uint256) public balances;

    modifier noReentrancy() {
        require(!locked, "Blocked from reentrancy.");
        locked = true;
        _;
        locked = false;
    }
    // This function is protected by a mutex, so reentrant calls from within `msg.sender.call` cannot call `withdraw` again.
    //  The `return` statement evaluates to `true` but still evaluates the `locked = false` statement in the modifier
    function withdraw(uint _amount) public payable noReentrancy returns(bool) {
        require(balances[msg.sender] >= _amount, "No balance to withdraw.");

        balances[msg.sender] -= _amount;
        bool (success, ) = msg.sender.call{value: _amount}("");
        require(success);

        return true;
    }
}
```

همچنین می‌توانید به جای سیستم «پرداخت فشاری» که وجوه را به حساب‌ها ارسال می‌کند، از سیستم [برگشت پرداخت‌ها](https://docs.openzeppelin.com/contracts/4.x/api/security#PullPayment) استفاده کنید که کاربران را ملزم به برداشت وجه از قراردادهای هوشمند می‌کند. با این کار امکان راه‌اندازی ناخواسته کد در آدرس‌های ناشناس حذف می‌شود (و همچنین می‌تواند از برخی حملات انکار سرویس جلوگیری کند).

#### پاریز و سرریز اعداد صحیح {#integer-underflows-and-overflows}

سرریز یا اورفلو اعداد صحیح زمانی اتفاق می‌افتد که نتایج یک عملیات حسابی خارج از محدوده قابل قبول مقادیر قرار می‌گیرد و باعث می‌شود که آن را به پایین‌ترین مقدار قابل نمایش تبدیل کند. برای مثال، یک `uint8` فقط می‌تواند مقادیر تا 2^8-1=255 را ذخیره کند. عملیات حسابی که به مقادیر بالاتر از `255` منجر می‌شود، سرریز یا اورفلو می‌شوند و `uint` را به `0` بازنشانی می‌کنند، مشابه اینکه کیلومترشمار ماشین بعد از به حداکثر رسیدن مسافت پیموده شده (999999) به 0 بازنشانی شود.

جریان‌های آندرفلو صحیح به دلایل مشابهی اتفاق می‌افتد: نتایج یک عملیات حسابی کمتر از محدوده قابل قبول است. فرض کنید سعی کرده‌اید `0` را در `uint8` کاهش دهید، نتیجه به سادگی به حداکثر مقدار قابل نمایش (`255`) می‌رسد.

هم اورفلو و هم آندرفلو اعداد صحیح می‌تواند منجر به تغییرات غیرمنتظره در متغیرهای حالت قرارداد شود و منجر به اجرای برنامه ریزی نشده شود. در زیر مثالی وجود دارد که نشان می‌دهد چگونه یک مهاجم می‌تواند از سرریز حسابی در یک قرارداد هوشمند برای انجام یک عملیات نامعتبر سوء استفاده کند:

```
pragma solidity ^0.7.6;

// This contract is designed to act as a time vault.
// User can deposit into this contract but cannot withdraw for at least a week.
// User can also extend the wait time beyond the 1 week waiting period.

/*
1. Deploy TimeLock
2. Deploy Attack with address of TimeLock
3. Call Attack.attack sending 1 ether. You will immediately be able to
   withdraw your ether.

What happened?
Attack caused the TimeLock.lockTime to overflow and was able to withdraw
before the 1 week waiting period.
*/

contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "Insufficient funds");
        require(block.timestamp > lockTime[msg.sender], "Lock time not expired");

        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Failed to send Ether");
    }
}

contract Attack {
    TimeLock timeLock;

    constructor(TimeLock _timeLock) {
        timeLock = TimeLock(_timeLock);
    }

    fallback() external payable {}

    function attack() public payable {
        timeLock.deposit{value: msg.value}();
        /*
        if t = current lock time then we need to find x such that
        x + t = 2**256 = 0
        so x = -t
        2**256 = type(uint).max + 1
        so x = type(uint).max + 1 - t
        */
        timeLock.increaseLockTime(
            type(uint).max + 1 - timeLock.lockTime(address(this))
        );
        timeLock.withdraw();
    }
}
```

##### چگونه از سرریز و آندرفلو اعداد صحیح جلوگیری کنیم

از نسخه 0.8.0، کامپایلر سالیدیتی کدهایی را که منجر به سرریز و زیر جریان یا همان آندر فلو اعداد صحیح می‌شود، رد می‌کند. با این حال، قراردادهایی که با یک نسخه کامپایلر پایین‌تر کامپایل می‌شوند باید یا باید توابع مربوط به عملیات حسابی را بررسی یا از یک کتابخانه استفاده کنند (به عنوان مثال، [SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math)) که اورفلو یا آندرفلو را بررسی می‌کند.

#### دستکاری اوراکل {#oracle-manipulation}

[اوراکل‌ها](/developers/docs/oracles/) اطلاعات خارج از زنجیره را منبع قرار می‌دهند و آن‌ها را به صورت زنجیره‌ای برای استفاده از قراردادهای هوشمند ارسال می‌کند. با اوراکل‌ها، می‌توانید قراردادهای هوشمندی را طراحی کنید که با سیستم‌های خارج از زنجیره، مانند بازارهای سرمایه، همکاری می‌کنند و کاربرد آن‌ها را تا حد زیادی گسترش می‌دهند.

اما اگر اوراکل خراب شود و اطلاعات نادرست را روی زنجیره ارسال کند، قراردادهای هوشمند بر اساس ورودی‌های اشتباه اجرا می‌شوند که می‌تواند مشکلاتی را ایجاد کند. این اساس "مشکل اوراکل" است که به وظیفه اطمینان از دقیق، به روز و به موقع بودن اطلاعات یک اوراکل بلاک چین مربوط می‌شود.

یک نگرانی امنیتی مرتبط، استفاده از یک اوراکل زنجیره‌ای، مانند یک صرافی غیرمتمرکز، برای دریافت قیمت ‌ای یک دارایی است. پلتفرم‌های وام‌دهی در صنعت [مالی غیرمتمرکز (DeFi)](/defi/) اغلب این کار را برای تعیین ارزش وثیقه کاربر انجام می‌دهند تا تعیین کنند چقدر می‌توانند وام بگیرند.

قیمت‌های صرافی‌های غیرمتمرکز اغلب دقیق هستند، که عمدتاً به دلیل بازیابی برابری توسط آربیتراژها در بازارها است. با این حال، آنها در معرض دستکاری هستند، به ویژه اگر اوراکل روی زنجیره قیمت دارایی‌ها را بر اساس الگوهای معاملاتی تاریخی محاسبه کند (همانطور که معمولاً اتفاق می‌افتد).

به عنوان مثال، یک مهاجم می‌تواند به‌طور مصنوعی قیمت نقدی یک دارایی را با گرفتن وام فوری یا همان فلش لون درست قبل از تعامل با قرارداد وام شما، افزایش دهد. پرس و جو از دکس برای قیمت دارایی، ارزشی بالاتر از حد معمول را به دست می‌آورد (به دلیل تقاضای انحرافی «سفارش خرید» مهاجم برای دارایی)، به آنها اجازه می‌دهد بیشتر از آنچه باید وام بگیرند. چنین "حملات وام فلش یا همان فلش لون" برای بهره‌برداری از اتکا به اوراکل‌های قیمت در میان برنامه‌های کاربردی دیفای استفاده شده است که میلیون‌ها وجوه از دست رفته پروتکل‌ها ایجاد کرده است.

##### چگونه از دستکاری اوراکل جلوگیری کنیم؟

حداقل نیاز برای [جلوگیری از دستکاری اوراکل](https://www.cyfrin.io/blog/price-oracle-manipultion-attacks-with-examples) استفاده از یک شبکه اوراکل غیرمتمرکز است که پرس و جو یا اطلاعات از چندین منبع برای جلوگیری از نقاط شکست کوئری می‌کند. در بیشتر موارد، اوراکل‌های غیرمتمرکز دارای انگیزه‌های اقتصادی رمزارزی شده‌اند تا نود یا گره‌های اوراکل را تشویق کرده تا اطلاعات صحیح را گزارش کنند و آنها را از اوراکل‌های متمرکز ایمن‌تر می‌کند.

اگر قصد دارید از یک اوراکل زنجیره‌ای یا آنچین برای قیمت دارایی‌ها پرس و جو کنید، از یکی استفاده کنید که مکانیزم قیمت میانگین وزن شده با زمان (TWAP) را پیاده‌سازی می‌کند. یک [اوراکل TWAP](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) قیمت یک دارایی را در دو مقطع زمانی مختلف (که شما می‌توانید اصلاح کنید) و قیمت لحظه‌ای را بر اساس میانگین به دست آمده محاسبه می‌کند. انتخاب دوره‌های زمانی طولانی‌تر از پروتکل شما در برابر دستکاری قیمت محافظت می‌کند، زیرا سفارش‌های بزرگی که اخیراً اجرا شده‌اند نمی‌توانند بر قیمت دارایی تأثیر بگذارند.

## منابع امنیتی قرارداد هوشمند برای توسعه‌دهندگان {#smart-contract-security-resources-for-developers}

### ابزارهایی برای تجزیه و تحلیل قراردادهای هوشمند و تأیید صحت کد {#code-analysis-tools}

- **[ابزارها و کتابخانه‌های تست](/developers/docs/smart-contracts/testing/#testing-tools-and-libraries)** - مجموعه ای از ابزارها و کتابخانه‌های استاندارد صنعتی برای انجام تست‌های واحد، تجزیه و تحلیل استاتیک و تجزیه و تحلیل پویا در قراردادهای هوشمند است

- **[ابزارهای تأیید رسمی](/developers/docs/smart-contracts/formal-verification/#formal-verification-tools)** - _ابزارهایی برای تأیید صحت عملکرد در قراردادهای هوشمند و بررسی متغیرها هستند._

- **[خدمات حسابرسی قراردادهای هوشمند](/developers/docs/smart-contracts/testing/#smart-contract-auditing-services)** - فهرست ‌هایی که خدمات حسابرسی قرارداد هوشمند برای پروژه‌های توسعه اتریوم ارائه می‌کنند.

- **[پلتفرم‌های پاداش باگ](/developers/docs/smart-contracts/testing/#bug-bounty-platforms)** - _پلتفرم‌هایی برای هماهنگی پاداش‌های اشکال و پاداش افشای مسئولانه آسیب‌پذیری‌های مهم در قراردادهای هوشمند هستند_

- **[فورک چکر](https://forkchecker.hashex.org/)** - _رایگان بوده و ابزار آنلاین برای بررسی تمام اطلاعات موجود در مورد قرارداد منشعب شده است._

- **[رمزگذار ABI](https://abi.hashex.org/)** - _یک رمزگذار رایگان سرویس آنلاین برای رمزگذاری توابع قرارداد سالیدیتی و آرگومان‌های سازنده (constructor) شما است._

- **[آدرین](https://github.com/Cyfrin/aderyn)** - _ تحلیلگر استاتیک سالیدیتی ، از درختان نحو انتزاعی (AST) عبور می‌کند تا آسیب‌پذیری‌های مشکوک را مشخص کرده و مسائل را در قالب علامت‌گذاری آسان برای مصرف چاپ کند._

### ابزارهای نظارت بر قراردادهای هوشمند {#smart-contract-monitoring-tools}

- **[OpenZeppelin Defender Sentinels](https://docs.openzeppelin.com/defender/v1/sentinel)** - _ابزاری برای نظارت و پاسخگویی خودکار به رویدادها، عملکردها و پارامترهای تراکنش در قراردادهای هوشمند شما است._

- **[هشدار هم‌زمان با ملایمت](https://tenderly.co/alerting/)** - _ابزاری برای دریافت اعلان‌های هم‌زمان هنگامی که رویدادهای غیرمنتظره در قراردادهای هوشمند یا کیف پول‌های شما اتفاق می‌افتد._

### ابزارهایی برای مدیریت امن قراردادهای هوشمند {#smart-contract-administration-tools}

- **[OpenZeppelin Defender Admin](https://docs.openzeppelin.com/defender/v1/admin)** - _رابطی برای مدیریت قراردادهای هوشمند، از جمله کنترل‌های دسترسی، ارتقاء و توقف است._

- **[ایمن](https://safe.global/)** - _کیف پول قرارداد هوشمند در حال اجرا اتریوم که به حداقل تعداد افراد نیاز دارد تا تراکنش را قبل از انجام آن تأیید کنند (M-of-N)._

- **[قراردادهای اوپن زپلین](https://docs.openzeppelin.com/contracts/4.x/)** - _کتابخانه‌ها را برای اجرای ویژگی‌های اداری، از جمله مالکیت قرارداد، ارتقاء، کنترل‌های دسترسی، حاکمیت، قابلیت توقف موقت و موارد دیگر مدیریت می‌کند._

### خدمات حسابرسی قرارداد هوشمند {#smart-contract-auditing-services}

- **[ConsenSys Diligence](https://consensys.net/diligence/)** - _خدمات آدیت قرارداد هوشمند که به پروژه‌ها در سراسر اکوسیستم بلاک چین کمک می‌کند مطمئن شوند که پروتکل‌های آن‌ها برای راه‌اندازی آماده هستند و برای محافظت از کاربران ساخته شده‌اند._

- **[CertiK](https://www.certik.com/)** - _شرکت امنیت بلاک چین پیشگام در استفاده از فناوری تایید رسمی پیشرفته در قراردادهای هوشمند و شبکه‌های بلاک چین است._

- **[رد بیت](https://www.trailofbits.com/)** - _امنیت سایبری شرکتی که تحقیقات امنیتی را با ذهنیت مهاجم برای کاهش ریسک و تقویت کد ترکیب می‌کند._

- **[PeckShield](https://peckshield.com/)** - _شرکت امنیت بلاک چین که محصولات و خدماتی برای امنیت، حریم خصوصی و قابلیت استفاده کل اکوسیستم بلاک چین ارائه می‌کند._

- **[QuantStamp](https://quantstamp.com/)** - _سرویس حسابرسی تسهیل کننده جریان اصلی پذیرش فناوری بلاک چین از طریق خدمات امنیت و ارزیابی ریسک است._

- **[اوپن زپلین](https://www.openzeppelin.com/security-audits)** - _ شرکت امنیتی قرارداد هوشمند که حسابرسی‌های امنیتی سیستم‌های توزیع شده را ارائه می‌دهد._

- **[تأیید زمان اجرا](https://runtimeverification.com/)** - _شرکت امنیتی متخصص در مدل سازی رسمی و تأیید قراردادهای هوشمند است_

- **[هک](https://hacken.io)** - _حسابرس امنیت سایبری Web3 که ارائه دهنده 360 رویکرد درجه به امنیت بلاک چین است._

- **[Nethermind](https://nethermind.io/smart-contracts-audits)** - _ خدمات حسابرسی سالیدیتی و کایرو، تضمین یکپارچگی قراردادهای هوشمند و ایمنی کاربران در سراسر اتریوم و استارک نت را ارائه می‌دهد._

- **[HashEx](https://hashex.org/)** - _HashEx بر روی بلاکین و حسابرسی قراردادهای هوشمند برای اطمینان از امنیت ارزهای دیجیتال، ارائه خدماتی مانند توسعه قرارداد هوشمند، تست نفوذ، مشاوره بلاکچین تمرکز دارد.

- **[Code4rena](https://code4rena.com/)** - _پلتفرم حسابرسی رقابتی که کارشناسان امنیت قراردادهای هوشمند را تشویق می‌کند تا آسیب‌پذیری‌ها را بیابند و به ایمن‌تر شدن Web3 کمک کنند._

- **[CodeHawks](https://codehawks.com/)** - _پلتفرم حسابرسی رقابتی میزبان مسابقات حسابرسی قراردادهای هوشمند برای محققان امنیتی._

- **[Cyfrin](https://cyfrin.io)** - _ نیروگاه امنیتی وب3، انکوباتور امنیت رمزارز از طریق محصولات و خدمات حسابرسی قرارداد هوشمند._

- **[ImmuneBytes](https://www.immunebytes.com//smart-contract-audit/)** - _شرکت امنیتی وب3 که ممیزی های امنیتی سیستم های بلاکچین را از طریق تیمی از حسابرسان مجرب و بهترین ابزارها ارائه می کند._

- **[Oxorio](https://oxor.io/)** - _ممیزی قراردادهای هوشمند و خدمات امنیتی بلاکین با تخصص در EVM، سالیدیتی، ZK، فناوری زنجیره‌ای متقابل برای شرکت‌های رمزنگاری و پروژه‌های دیفای._

- **[Inference](https://inference.ag/)** - _شرکت حسابرسی امنیتی، متخصص در حسابرسی قراردادهای هوشمند برای بلاکچین‌های مبتنی بر EVM. با تشکر از حسابرسان متخصص آن، آنها مشکلات بالقوه را شناسایی کرده و راه‌حل‌های عملی را برای رفع آنها قبل از استقرار پیشنهاد می‌کنند._

### پلتفرم‌های باگ‌بانتی {#bug-bounty-platforms}

- **[Immunefi](https://immunefi.com/)** - _پلتفرم باگ‌بانتی برای قراردادهای هوشمند و پروژه‌های دیفای، که در آن محققان امنیتی کد را بررسی می‌کنند، آسیب‌پذیری‌ها را فاش می‌کنند، پاداش دریافت می‌کنند و دنیای رمزارز را ایمن‌تر می‌کنند._

- **[HackerOne](https://www.hackerone.com/)** - _پلتفرم هماهنگی آسیب‌پذیری و باگ‌بانتی که کسب‌وکارها را با کارشناسان تست نفوذ و محققان امنیت سایبری مرتبط می‌کند._

- **[HackenProof](https://hackenproof.com/)** - _پلتفرم باگ‌بانتی متخصص برای پروژه‌های رمزارزی (دیفای، قراردادهای هوشمند، کیف پول‌ها، CEX و موارد دیگر)، جایی که متخصصان امنیتی خدمات تریاژ را ارائه می دهند و محققان برای گزارش های مربوط به باگ هایتأیید شده پاداش دریافت می کنند._

-  **[Sherlock](https://www.sherlock.xyz/)** - _ عریضه‌نویس در وب3 برای امنیت قراردادهای هوشمند، با پرداخت‌هایی برای حسابرسان که از طریق قراردادهای هوشمند مدیریت می‌شوند تا از پرداخت عادلانه باگ های مربوطه اطمینان حاصل شود._

-  **[CodeHawks](https://www.codehawks.com/)** - _پلتفرم باگ‌بانتی رقابتی که در آن حسابرسان در مسابقات و چالش‌های امنیتی و (به زودی) در ممیزی‌های خصوصی خودشان شرکت می‌کنند._

### رسانه های آسیب پذیری ها و اکسپلویت های شناخته شده قرارداد هوشمند {#common-smart-contract-vulnerabilities-and-exploits}

- قماله **[کانسنسیس: حملات شناخته شده قرارداد هوشمند](https://consensys.github.io/smart-contract-best-practices/attacks/)** - _توضیحات مبتدی مهم ترین آسیب پذیری های قرارداد، با کد نمونه برای اکثر موارد._

- **[SWC Registry](https://swcregistry.io/)** - _فهرست تنظیم‌شده از موارد سرشماری ضعف مشترک (CWE) که در قراردادهای هوشمند اتریوم اعمال می‌شود._

- **[Rekt](https://rekt.news/)** - _ انتشار منظم هک‌ها و سوء استفاده‌های رمزنگاری با مشخصات بالا، همراه با کالبدشکافی._

### چالش‌های یادگیری امنیت قراردادهای هوشمند {#challenges-for-learning-smart-contract-security}

- **[Awesome BlockSec CTF ](https://github.com/blockthreat/blocksec-ctfs)** - _فهرست تنظیم‌شده بازی‌های امنیتی بلاکچین، چالش‌ها و مسابقات [Capture The Flag](https://www.webopedia.com/definitions/ctf-event/amp/) و نوشته‌های راه‌حل._

- **[DeFi آسیب پذیر لعنتی](https://www.damnvulnerabledefi.xyz/)** - _بازی برای یادگیری امنیت تهاجمی قراردادهای هوشمند دیفای و ایجاد مهارت در شکار باگ و ممیزی امنیتی._

- **[Ethernaut](https://ethernaut.openzeppelin.com/)** - _بازی جنگی مبتنی بر وب3/سالیدیتی که در آن هر سطح یک قرارداد هوشمند است که باید "هک" شود._

- **[HackenProof x HackTheBox](https://app.hackthebox.com/tracks/HackenProof-Track)** - _چالش هک قرارداد هوشمند، در یک ماجراجویی فانتزی. تکمیل موفقیت‌آمیز چالش به یک برنامه باگ‌بانتی خصوصی نیز دسترسی پیدا می‌کند._

### بهترین روش ها برای ایمن سازی قراردادهای هوشمند {#smart-contract-security-best-practices}

- **[کانسنسیس: بهترین روش‌های امنیتی قراردادهای هوشمند اتریوم](https://consensys.github.io/smart-contract-best-practices/)** - _فهرست جامع دستورالعمل‌ها برای ایمن کردن قراردادهای هوشمند اتریوم._

- **[Nascent: ابزار ساده امنیتی](https://github.com/nascentxyz/simple-security-toolkit)** - _مجموعه راهنماها و چک لیست های عملی مبتنی بر امنیت برای توسعه قراردادهای هوشمند._

- **[Solidity Patterns](https://fravoll.github.io/solidity-patterns/)** - _تلفیقی مفید از الگوهای امن و بهترین شیوه ها برای زبان برنامه نویسی قرارداد هوشمند سالیدیتی._

- **[اسناد سالیدیتی: ملاحظات امنیتی](https://docs.soliditylang.org/en/v0.8.16/security-considerations.html)** - _دستورالعمل‌هایی برای نوشتن قراردادهای هوشمند ایمن با سالیدیتی._

- **[استاندارد تأیید امنیت قراردادهای هوشمند](https://github.com/securing/SCSVS)** - _چک لیست چهارده قسمتی ایجاد شده برای استانداردسازی امنیت قراردادهای هوشمند برای توسعه دهندگان، معماران، بازبینان امنیتی و فروشندگان._

- **[امنیت و حسابرسی قرارداد هوشمند را بیاموزید](https://updraft.cyfrin.io/courses/security) - _دوره ممیزی و امنیت قراردادهای هوشمند نهایی، ایجاد شده برای توسعه دهندگان قراردادهای هوشمند که به دنبال ارتقای بهترین شیوه های امنیتی خود و تبدیل شدن به محققین امنیتی هستند._

### آموزش امنیت قراردادهای هوشمند {#tutorials-on-smart-contract-security}

- [نحوه نوشتن قراردادهای هوشمند امن](/developers/tutorials/secure-development-workflow/)

- [نحوه استفاده از Slither برای یافتن اشکالات قرارداد هوشمند](/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/)

- [نحوه استفاده از Manticore برای یافتن اشکالات قرارداد هوشمند](/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/)

- [راهنمای امنیتی قراردادهای هوشمند](/developers/tutorials/smart-contract-security-guidelines/)

- [چگونه به طور ایمن قرارداد توکن خود را با توکن‌های دلخواه ادغام کنیم](/developers/tutorials/token-integration-checklist/)

- [Cyfrin Updraft - امنیت قراردادهای هوشمند و دوره کامل ممیزی](https://updraft.cyfrin.io/courses/security)
