---
title: "EIP-1271: スマートコントラクト署名に対する署名と検証"
description: "EIP-1271を使ったスマートコントラクト署名の生成および検証の概要。 スマートコントラクト・デベロッパーが構築できるように具体的な例としてSafe (旧 Gnosis Safe) で使用される EIP-1271実装についても説明します。"
author: Nathan H. Leung
lang: ja
tags: [ "eip-1271", "スマート契約", "検証", "署名(signing)" ]
skill: intermediate
published: 2023-01-12
---

[EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)標準は、スマートコントラクトによる署名の検証を可能にします。

このチュートリアルでは、デジタル署名、EIP-1271の背景、および[Safe](https://safe.global/) (旧Gnosis Safe) が使用するEIP-1271の特定の実装の概要を説明します。 このチュートリアル全体を通して、EIP-1271を自身のコントラクトへ実装するための出発点として使うことができます。

## 「署名」とは何か

このチュートリアルにおいて、署名 (正確には「デジタル署名」) とは、特定の人物/送信者/アドレスから送信されたものであることを示す何らかの証拠をそのメッセージに対して加えたものです。

具体的には、デジタル署名は次のようなものです。

1. メッセージ: 「イーサリアムウォレットを使用してこのWebサイトにログインしたい」
2. 署名者: 私のアドレスは`0x000…`です。
3. 証拠: 私(`0x000…`)が、このメッセージ全体を実際に作成したという証拠がこちらです(これは通常、暗号化されたものです)。

デジタル署名には、「メッセージ」と「署名」の両方が含まれていることが重要です。

それはなぜでしょうか？ 具体的には、あなたが私に署名するように契約書を渡した後、私が署名のあるページを切り取り、契約事項のない署名だけを返した場合、その契約は無効なることがあげられます。

同様にデジタル署名においても、それに紐づいたメッセージがなければ意味がありません。

## EIP-1271が必要な理由

イーサリアムベースのブロックチェーン上でデジタル署名を作成するには、通常、他の人が知らない秘密鍵が必要になります。 秘密鍵により、あなたの署名が自身のものになります (誰も秘密鍵を知らない限り、同じ署名を作成できません) 。

イーサリアムアカウント(i.e.、外部所有アカウント/EOA)には秘密鍵が関連付けられています。この秘密鍵は、ウェブサイトやdappが署名(例: 「イーサリアムでログイン」)を求める際に通常使用されるものです。

アプリは、ethers.jsのようなサードパーティのライブラリを使い、あなたが作成した署名を[検証](https://www.alchemy.com/docs/how-to-verify-a-message-signature-on-ethereum)し、[あなたの秘密鍵を知ることなく](https://en.wikipedia.org/wiki/Public-key_cryptography)、_あなた_がその署名を作成したと確信できます。

> 事実、EOAのデジタル署名は公開鍵暗号を使用するため、**オフチェーン**で生成・検証できます。 これは、ガスレスDAO投票の仕組みです。オンチェーンで投票を送信する代わりに、暗号ライブラリを使用してオフチェーンでデジタル署名を作成し、検証できます。

EOAの各アカウントには秘密鍵がありますが、スマートコントラクトアカウントにはいかなる種類の共通鍵も秘密鍵もありません (そのため、「イーサリアムでログイン」などはスマートコントラクトのアカウントにおいては、ネイティブで機能しません) 。

EIP-1271は、スマートコントラクトで署名に使う「秘密鍵」がないのであれば、スマートコントラクト署名が有効かどうかをどのように判断すればよいのかという問題を解決することを目的にしています。

## EIP-1271の仕組み

スマートコントラクトには、メッセージの署名に使用する秘密鍵がありません。 署名が本物かどうかをどのようにして判断するのでしょうか？

そこで考えられるのが、署名が本物かどうかをスマートコントラクトに直接_問い合わせて_みることです。

EIP-1271が行っているのは、与えられた署名が有効かどうかをスマートコントラクトに「尋ねる」アイデアを標準化です。

EIP-1271を実装するコントラクトは、メッセージと署名を受け取る`isValidSignature`という名前の関数を持つ必要があります。 次にコントラクトは、いくつかの検証ロジックを実行し (仕様書では、具体的なことを何も強制していません) 、署名が有効かどうかを示す値を返します。

`isValidSignature`が有効な結果を返した場合、それはコントラクトが「はい、この署名とメッセージを承認します！」と言っているのとほぼ同じです。

### インターフェース

以下がEIP-1271仕様の正確なインターフェイスです(`_hash`パラメータについては後述しますが、ここでは検証対象のメッセージだと考えてください):

```jsx
pragma solidity ^0.5.0;

contract ERC1271 {

  // bytes4(keccak256("isValidSignature(bytes32,bytes)")
  bytes4 constant internal MAGICVALUE = 0x1626ba7e;

  /**
   * @dev 提供されたハッシュに対して、提供された署名が有効かどうかを返すべきです
   * @param _hash      署名されるデータのハッシュ
   * @param _signature _hashに関連付けられた署名バイト配列
   *
   * 関数が成功した場合、bytes4のマジック値0x1626ba7eを返さなければなりません(MUST)。
   * 状態を変更してはいけません(MUST NOT)。(solc < 0.5の場合はSTATICCALLを使用、solc > 0.5の場合はview修飾子を使用)
   * 外部呼び出しを許可しなければなりません(MUST)。
   */
  function isValidSignature(
    bytes32 _hash,
    bytes memory _signature)
    public
    view
    returns (bytes4 magicValue);
}
```

## EIP-1271実装の例: Safe

コントラクトはさまざまな方法で`isValidSignature`を実装できます。仕様では、正確な実装についてはあまり言及されていません。

EIP-1271を実装した有名なコントラクトの1つにSafe (旧Gnosis Safe) があります。

Safeのコードでは、`isValidSignature`は、署名が[2つの方法](https://ethereum.stackexchange.com/questions/122635/signing-messages-as-a-gnosis-safe-eip1271-support)で作成・検証できるように[実装](https://github.com/safe-global/safe-contracts/blob/main/contracts/handler/CompatibilityFallbackHandler.sol)されています:

1. オンチェーンメッセージ
   1. 作成: Safeの所有者は、メッセージに「署名」するための新しいSafeのトランザクションを作成し、メッセージをデータとしてトランザクションに渡します。 十分な数の所有者がトランザクションに署名してマルチシグのしきい値に達すると、トランザクションがブロードキャストされて実行されます。 トランザクションには、メッセージを「承認済み」メッセージのリストに追加する (`signMessage(bytes calldata _data)`) というSafe関数があります。
   2. 検証: Safeコントラクトで`isValidSignature`を呼び出し、検証するメッセージをメッセージパラメータとして、[署名パラメータには空の値](https://github.com/safe-global/safe-contracts/blob/main/contracts/handler/CompatibilityFallbackHandler.sol#L32) (i.e.、`0x`) を渡します。 Safeは、署名パラメータが空であることを確認し、署名を暗号的に検証する代わりに、メッセージが「承認された」メッセージのリストに存在するかのみを確認します。
2. オフチェーンメッセージ:
   1. 作成: Safeの所有者はオフチェーンでメッセージを作成し、マルチシグの承認しきい値を超えるのに十分な署名が集まるまで、他のSafe所有者に個別にメッセージへ署名してもらいます。
   2. 検証: `isValidSignature`を呼び出します。 メッセージパラメータの中に、検証するメッセージを渡します。 署名パラメーターでは、Safe所有者各自の署名をすべて連結して、一斉に渡します。 Safeは、しきい値を満たすのに十分な署名があること、**かつ**各署名が有効であることをチェックします。 有効であれば、署名の検証が成功したことを示す値を返します。

## `_hash`パラメータとは正確には何ですか? およびメッセージ全体を渡さない理由

[EIP-1271インターフェイス](https://eips.ethereum.org/EIPS/eip-1271)の`isValidSignature`関数が、メッセージ自体ではなく`_hash`パラメータを受け取ることに気づいたかもしれません。 これは、任意の長さのメッセージ全体を`isValidSignature`に渡す代わりに、メッセージの32バイトのハッシュ(通常はkeccak256)を渡すことを意味します。

コールデータの各バイト、すなわちスマートコントラクト関数に渡される関数パラメータデータは、[16ガス(ゼロバイトの場合は4ガス)のコストがかかる](https://eips.ethereum.org/EIPS/eip-2028)ため、メッセージが長い場合は多くのガスを節約できます。

### 以前のEIP-1271仕様

実際には、最初のパラメータが`bytes`型(固定長の`bytes32`ではなく任意長)で、パラメータ名が`message`である`isValidSignature`関数を持つEIP-1271仕様が存在します。 これは、EIP-1271標準の[古いバージョン](https://github.com/safe-global/safe-contracts/issues/391#issuecomment-1075427206)です。

## EIP-1271を各自のコントラクトにどのように実装すべきか

実装は自由にできる仕様になっています。 Safeの実装には、次のいくつかの優れたアイデアがあります。

- コントラクト「所有者」からのEOA署名を有効とみなせる
- 承認されたメッセージのリストを保存し、それらのメッセージのみを有効であるとみなせる

最後に、実装はスマートコントラクトデベロッパーであるあなた次第です！

## まとめ

[EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)は、スマートコントラクトが署名を検証できるようにする汎用性の高い標準です。 EIP-1271により、スマートコントラクトをEOAのように動作させることができます。例えば、「イーサリアムでログイン」をスマートコントラクトで動作させる方法を提供できます。また、さまざまな方法で実装できます (考慮するのに興味深い重要な実装としてSafeがあります) 。
