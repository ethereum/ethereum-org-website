---
title: イエローペーパーにおけるEVM仕様の理解
description: イーサリアムの正式な仕様であるイエローペーパーでのイーサリアム仮想マシン(EVM)についての説明を理解する。
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: ja
published: 2022-05-15
---

[イエローペーパー](https://ethereum.github.io/yellowpaper/paper.pdf)は、イーサリアムの正式な仕様です。 [EIPプロセス](/eips/)によって修正される場合を除き、すべての動作方式が正確に記されています。 数学の論文形式で書かれており、プログラマーには馴染みのない専門用語が含まれています。 この論文を通して、論文の読み方を学び、他の関連する数学論文も読めるようにしましょう。

## 解説するイエローペーパーについて {#which-yellow-paper}

イーサリアムに関する他のものと同じように、イエローペーパーも時間の経過とともに進化しています。 特定のバージョンを参照できるように、[執筆時の現行バージョン](yellow-paper-berlin.pdf)をアップロードしました。 このドキュメントで使用するセクション番号、ページ番号、数式番号は、そのバージョンを参照しています。 このドキュメントを読む際は、別のウィンドウで開いておくことをお勧めします。

### なぜEVMなのか？ {#why-the-evm}

オリジナルのイエローペーパーは、イーサリアムの開発が始まった直後に書かれました。 そこには、ネットワークのセキュリティを確保するために当初使用されていた、プルーフ・オブ・ワークベースの独自のコンセンサスメカニズムが記述されています。 しかし、イーサリアムは2022年9月にプルーフ・オブ・ワークを停止し、プルーフ・オブ・ステークベースのコンセンサスを使用し始めました。 このチュートリアルでは、イーサリアム仮想マシンを定義するイエローペーパーの部分に焦点を当てます。 EVMは、プルーフ・オブ・ステークへの移行による影響を受けませんでした（DIFFICULTYオペコードの戻り値を除く）。

## 9 実行モデル {#9-execution-model}

このセクション（12～14ページ）には、EVMの定義のほとんどが含まれています。

_システム状態_という用語には、システムの実行に必要なすべての情報が含まれます。 典型的なコンピュータでは、これはメモリやレジスタの内容などを意味します。

[チューリングマシン](https://en.wikipedia.org/wiki/Turing_machine)は計算モデルです。 本質的に、これはコンピュータの簡易版であり、通常のコンピュータと同じ計算を実行する能力があることが証明されています（コンピュータが計算できるものはすべてチューリングマシンでも計算でき、その逆も同様です）。 このモデルは、計算可能なものと計算不可能なものに関するさまざまな定理の証明を容易にします。

[チューリング完全](https://en.wikipedia.org/wiki/Turing_completeness)という用語は、チューリングマシンと同じ計算を実行できるコンピュータを意味します。 チューリングマシンは無限ループに陥ることがありますが、EVMはガスがなくなるため無限ループに陥ることができず、準チューリング完全であるにすぎません。

## 9.1 基本 {#91-basics}

このセクションでは、EVMの基本と、他の計算モデルとの比較について説明します。

[スタックマシン](https://en.wikipedia.org/wiki/Stack_machine)とは、中間データをレジスタではなく[**スタック**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\))に格納するコンピュータです。 これは実装が容易で、バグやセキュリティの脆弱性がはるかに少なくなるため、仮想マシンで好まれるアーキテクチャです。 スタック内のメモリは、256ビットのワードに分割されます。 これは、Keccak-256のハッシュ化や楕円曲線計算など、イーサリアムの中核となる暗号操作に便利であるため、選択されました。 スタックの最大サイズは1024アイテム（1024 x 256ビット）です。 オペコードが実行されるとき、通常はスタックからパラメータを取得します。 `POP`（スタックの先頭からアイテムを削除）、`DUP_N`（スタックのN番目のアイテムを複製）など、スタック内の要素を再編成するための専用オペコードがあります。

EVMには、実行中にデータを保存するために使用される**メモリ**と呼ばれる揮発性スペースもあります。 このメモリは、32バイトのワードで構成されます。 すべてのメモリロケーションはゼロで初期化されます。 この[Yul](https://docs.soliditylang.org/en/latest/yul.html)コードを実行してメモリにワードを追加すると、ワード内の空きスペースがゼロでパディングされて32バイトのメモリが埋められます。つまり、ロケーション0-29はゼロ、30は0x60、31は0xA7である1ワードが作成されます。

```yul
mstore(0, 0x60A7)
```

`mstore`は、EVMがメモリと対話するために提供する3つのオペコードの1つで、ワードをメモリにロードします。 他の2つは、1バイトをメモリにロードする`mstore8`と、メモリからスタックにワードを移動する`mload`です。

EVMには、システム状態の一部として維持される、独立した不揮発性の**ストレージ**モデルもあります。このメモリは、（スタック内のワードアドレス指定可能なバイト配列とは対照的に）ワード配列として構成されます。 このストレージは、コントラクトが永続データを保持する場所であり、コントラクトは自身のストレージとのみ対話できます。 ストレージは、キーと値のマッピングで構成されます。

イエローペーパーのこのセクションでは言及されていませんが、4番目のタイプのメモリがあることを知っておくと便利です。 **Calldata**は、トランザクションの`data`パラメータで渡された値を格納するために使用される、バイトアドレス指定可能な読み取り専用メモリです。 EVMには、`calldata`を管理するための特定のオペコードがあります。 `calldatasize`は、データのサイズを返します。 `calldataload`は、データをスタックにロードします。 `calldatacopy`は、データをメモリにコピーします。

標準の[フォン・ノイマン・アーキテクチャ](https://en.wikipedia.org/wiki/Von_Neumann_architecture)では、コードとデータが同じメモリに格納されます。 EVMはセキュリティ上の理由からこの標準に従いません。揮発性メモリを共有すると、プログラムコードが変更される可能性があるためです。 代わりに、コードはストレージに保存されます。

コードがメモリから実行されるのは、次の2つのケースだけです。

- コントラクトが別のコントラクトを作成する場合（[`CREATE`](https://www.evm.codes/#f0)または[`CREATE2`](https://www.evm.codes/#f5)を使用）、コントラクトコンストラクタのコードはメモリから取得されます。
- コントラクトの作成中、コンストラクタコードが実行され、実際のコントラクトのコードとともにメモリから返されます。

例外実行という用語は、現在のコントラクトの実行を停止させる例外を意味します。

## 9.2 手数料の概要 {#92-fees-overview}

このセクションでは、ガス代の計算方法について説明します。 次の3つのコストがあります。

### オペコードのコスト {#opcode-cost}

特定のオペコードで発生する固有のコストです。 この値を取得するには、付録H（28ページ、式（327）の下）でオペコードのコストグループを見つけ、式（324）でコストグループを見つけます。 これによりコスト関数が得られますが、ほとんどの場合、付録G（27ページ）のパラメータを使用します。

例えば、オペコード[`CALLDATACOPY`](https://www.evm.codes/#37)は、グループ_W<sub>copy</sub>_のメンバーです。 このグループにおけるオペコードのコストは、_G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_となります。 付録Gを見ると、両方の定数が3であることがわかり、この式は_3+3×⌈μ<sub>s</sub>[2]÷32⌉_です。

次に、式_⌈μ<sub>s</sub>[2]÷32⌉_を解読する必要があります。 外側の部分_⌈ \<value\> ⌉_は天井関数であり、与えられた値に対して、その値以上である最小の整数を返す関数です。 例えば、_⌈2.5⌉ = ⌈3⌉ = 3_となります。 内側の部分は、_μ<sub>s</sub>[2]÷32_です。 3ページ目のセクション3（表記法）を見ると、_μ_はマシンの状態です。 マシンの状態は、13ページのセクション9.4.1で定義されています。 そのセクションによると、マシンの状態パラメータの1つはスタックの_s_です。 すべてをまとめると、_μ<sub>s</sub>[2]_はスタック内のロケーション#2であるようです。 [このオペコード](https://www.evm.codes/#37)を見ると、スタック内のロケーション#2はデータのサイズ（バイト単位）です。 グループW<sub>copy</sub>の他のオペコード、[`CODECOPY`](https://www.evm.codes/#39)および[`RETURNDATACOPY`](https://www.evm.codes/#3e)を見ると、それらも同じロケーションにデータサイズを持っています。 したがって、_⌈μ<sub>s</sub>[2]÷32⌉_は、コピーされるデータを保存するために必要な32バイトのワード数です。 すべてをまとめると、[`CALLDATACOPY`](https://www.evm.codes/#37)の固有コストは3ガスに加えて、コピーされるデータのワードごとに3ガスです。

### 実行コスト {#running-cost}

呼び出すコードの実行コスト。

- [`CREATE`](https://www.evm.codes/#f0)と[`CREATE2`](https://www.evm.codes/#f5)の場合、新しいコントラクトのコンストラクタ。
- [`CALL`](https://www.evm.codes/#f1)、[`CALLCODE`](https://www.evm.codes/#f2)、[`STATICCALL`](https://www.evm.codes/#fa)、または[`DELEGATECALL`](https://www.evm.codes/#f4)の場合、呼び出すコントラクト。

### メモリ拡張コスト {#expanding-memory-cost}

（必要な場合の）メモリ拡張のコスト。

式324では、この値は_C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_として記述されています。 セクション9.4.1をもう一度見ると、_μ<sub>i</sub>_はメモリ内のワード数であることがわかります。 したがって、_μ<sub>i</sub>_はオペコード実行前のメモリ内のワード数であり、_μ<sub>i</sub>'_はオペコード実行後のメモリ内のワード数です。

関数_C<sub>mem</sub>_は、式326で次のように定義されます：_C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_。 _⌊x⌋_は床関数で、与えられた値に対して、その値以下である最大の整数を返す関数です。 例えば、_⌊2.5⌋ = ⌊2⌋ = 2_。_a < √512_の場合、_a<sup>2</sup> < 512_となり、床関数の結果はゼロになります。 そのため、最初の22ワード（704バイト）については、必要なメモリワード数に応じてコストが線形的に増加します。 その点を超えると、_⌊a<sup>2</sup> ÷ 512⌋_は正になります。 必要なメモリが十分に大きい場合、ガスコストはメモリ量の2乗に比例します。

**注**：これらの要素は_固有の_ガス代にのみ影響し、エンドユーザーが支払う必要のある金額を決定する手数料マーケットやバリデータへのチップは考慮されていません。これは、EVMで特定の操作を実行するための生のコストにすぎません。

[ガスについての詳細](/developers/docs/gas/)

## 9.3 実行環境 {#93-execution-env}

実行環境は、ブロックチェーンの状態やEVMの一部ではない情報を含むタプル_I_です。

| パラメータ           | データにアクセスするためのオペコード                                                                               | データにアクセスするためのSolidityのコード           |
| --------------- | ------------------------------------------------------------------------------------------------ | ----------------------------------- |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                           | `address(this)`                     |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                            | `tx.origin`                         |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                          | `tx.gasprice`                       |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35)など                                                    | `msg.data`                          |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                            | `msg.sender`                        |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                         | `msg.value`                         |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                          | `address(this).code`                |
| _I<sub>H</sub>_ | ブロックヘッダーフィールド（[`NUMBER`](https://www.evm.codes/#43)や[`DIFFICULTY`](https://www.evm.codes/#44)など） | `block.number`、`block.difficulty`など |
| _I<sub>e</sub>_ | コントラクト間のコールのコールスタックの深さ（コントラクトの作成を含む）                                                             |                                     |
| _I<sub>w</sub>_ | EVMが状態を変更できるか、静的に実行されているか                                                                        |                                     |

セクション9の残りを理解するには、他にいくつかのパラメータが必要です。

| パラメータ | 定義されているセクション                                                   | 意味                                                                                        |
| ----- | -------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| _σ_   | 2 (p. 2, equation 1)        | ブロックチェーンの状態                                                                               |
| _g_   | 9.3 (p. 13) | 残りのガス                                                                                     |
| _A_   | 6.1 (p. 8)  | 発生したサブ状態（トランザクション終了時に予定されている変更）                                                           |
| _o_   | 9.3 (p. 13) | 出力 - 内部トランザクション（あるコントラクトが別のコントラクトを呼び出す場合）やビュー関数の呼び出し（情報を要求するだけでトランザクションを待つ必要がない場合）で返される結果 |

## 9.4 実行の概要 {#94-execution-overview}

すべての準備が整ったので、いよいよEVMの仕組みについて取り組んでいきます。

式137～142は、EVMを実行するための初期条件を示しています。

| 記号               | 初期値                                                                              | 意味                                                                                                                                                                                                 |
| ---------------- | -------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | 残りのガス                                                                                                                                                                                              |
| _μ<sub>pc</sub>_ | _0_                                                                              | プログラムカウンタ、実行する次の命令のアドレス                                                                                                                                                                            |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | メモリ、すべてゼロに初期化                                                                                                                                                                                      |
| _μ<sub>i</sub>_  | _0_                                                                              | 使用される最上位のメモリ位置                                                                                                                                                                                     |
| _μ<sub>s</sub>_  | _()_                                                          | スタック、最初は空                                                                                                                                                                                          |
| _μ<sub>o</sub>_  | _∅_                                                                              | 出力、戻りデータで停止する（[`RETURN`](https://www.evm.codes/#f3)または[`REVERT`](https://www.evm.codes/#fd)）か、戻りデータなしで停止する（[`STOP`](https://www.evm.codes/#00)または[`SELFDESTRUCT`](https://www.evm.codes/#ff)）まで空集合 |

式143は、実行中の各時点で4つの可能な条件があり、それらをどう処理するかを示しています。

1. `Z(σ,μ,A,I)` Zは、操作が無効な状態遷移を引き起こすかどうかをテストする関数を表します（[例外的な停止](#942-exceptional-halting)を参照）。 Trueと評価された場合、変更が実装されていないため、新しい状態は古い状態と同一です（ガスがバーンされる場合を除く）。
2. 実行中のオペコードが[`REVERT`](https://www.evm.codes/#fd)の場合、新しい状態は古い状態と同じで、一部のガスが失われます。
3. [`RETURN`](https://www.evm.codes/#f3)で示されるように、操作のシーケンスが終了した場合、状態は新しい状態に更新されます。
4. 終了条件1～3のいずれでもない場合は、実行を続けます。

## 9.4.1 マシンの状態 {#941-machine-state}

このセクションでは、マシンの状態について詳しく説明します。 これは、_w_が現在のオペコードであることを指定します。 _μ<sub>pc</sub>_がコードの長さである_||I<sub>b</sub>||_より小さい場合、そのバイト（_I<sub>b</sub>[μ<sub>pc</sub>]_）がオペコードです。 それ以外の場合、オペコードは[`STOP`](https://www.evm.codes/#00)として定義されます。

これは[スタックマシン](https://en.wikipedia.org/wiki/Stack_machine)であるため、各オペコードによってポップアウトされたアイテムの数（_δ_）とプッシュインされたアイテムの数（_α_）を追跡する必要があります。

## 9.4.2 例外的な停止 {#942-exceptional-halt}

このセクションでは、異常終了が発生するタイミングを指定する_Z_関数を定義します。 これは[ブール](https://en.wikipedia.org/wiki/Boolean_data_type)関数なので、[論理和には_∨_](https://en.wikipedia.org/wiki/Logical_disjunction)を、[論理積には_∧_](https://en.wikipedia.org/wiki/Logical_conjunction)を使用します。

次のいずれかの条件が真になる場合、例外による停止が発生します。

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  セクション9.2で見たように、_C_はガス代を指定する関数です。 次のオペコードをカバーするのに十分なガスが残っていません。

- **_δ<sub>w</sub>=∅_**
  オペコードに対してポップされるアイテムの数が未定義の場合、オペコード自体も未定義です。

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  スタックアンダーフロー。現在のオペコードに対してスタック内に十分なアイテムがありません。

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  オペコードが[`JUMP`](https://www.evm.codes/#56)で、アドレスが[`JUMPDEST`](https://www.evm.codes/#5b)ではありません。 ジャンプは、ジャンプ先が[`JUMPDEST`](https://www.evm.codes/#5b)のときのみ有効です。

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  オペコードが[`JUMPI`](https://www.evm.codes/#57)で、条件が真（非ゼロ）であるためジャンプが発生しますが、アドレスが[`JUMPDEST`](https://www.evm.codes/#5b)ではありません。 ジャンプは、ジャンプ先が[`JUMPDEST`](https://www.evm.codes/#5b)のときのみ有効です。

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  オペコードは[`RETURNDATACOPY`](https://www.evm.codes/#3e)です。 このオペコードでは、スタック要素_μ<sub>s</sub>[1]_は戻りデータバッファから読み取るオフセットで、スタック要素_μ<sub>s</sub>[2]_はデータの長さです。 この条件は、戻りデータバッファの末尾を超えて読み取ろうとしたときに発生します。 コールデータやコード自体には同様の条件がないことに注意してください。 これらのバッファの末尾を超えて読み取ろうとすると、ゼロが返されるだけです。

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  スタックオーバーフロー。 オペコードの実行で1024を超えるアイテムのスタックが生成された場合は、中断されます。

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  静的に実行していますか（[¬は否定](https://en.wikipedia.org/wiki/Negation)で、ブロックチェーンの状態を変更できる場合に_I<sub>w</sub>_は真になります）？ その場合、状態変更操作を試行しようとしてもできません。

  関数_W(w,μ)_は、後の式150で定義されています。 次のいずれかの条件が真の場合、_W(w,μ)_は真になります。

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    これらのオペコードは、新しいコントラクトの作成、値の保存、または現在のコントラクトの破棄によって状態を変更します。

  - **_LOG0≤w ∧ w≤LOG4_**
    静的に呼び出された場合、ログエントリを出力できません。
    ログオペコードはすべて、[`LOG0` (A0)](https://www.evm.codes/#a0)から[`LOG4` (A4)](https://www.evm.codes/#a4)の範囲にあります。
    ログオペコードの後の数字は、ログエントリに含まれるトピックの数を指定します。

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    静的な場合、別のコントラクトを呼び出すことはできますが、ETHをそれに送金することはできません。

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  G<sub>callstipend</sub>（付録Gで2300と定義）を超えるガスがない限り、[`SSTORE`](https://www.evm.codes/#55)は実行できません。

## 9.4.3 ジャンプ先の有効性 {#943-jump-dest-valid}

ここでは、[`JUMPDEST`](https://www.evm.codes/#5b)オペコードについて正式に定義します。 バイト値0x5Bを単純に探すことはできません。PUSHの内部にある可能性があり（したがってオペコードではなくデータ）、そのためです。

式(153)では、関数_N(i,w)_を定義します。 最初のパラメータ_i_は、オペコードのロケーションです。 2番目のパラメータ_w_は、オペコード自体です。 _w∈[PUSH1, PUSH32]_の場合、オペコードがPUSHであることを意味します（角括弧は端点を含む範囲を定義しています）。 その場合、次のオペコードは_i+2+(w−PUSH1)_にあります。 [`PUSH1`](https://www.evm.codes/#60)では、2バイト（PUSH自体と1バイトの値）進む必要があります。[`PUSH2`](https://www.evm.codes/#61)では、2バイトの値であるため、3バイト進める必要があります。 他のすべてのEVMオペコードは1バイト長なので、他のすべてのケースでは_N(i,w)=i+1_です。

この関数は、式(152)で_D<sub>J</sub>(c,i)_を定義するために使用されます。これは、コード_c_内のすべての有効なジャンプ先の[集合](https://en.wikipedia.org/wiki/Set_\(mathematics\))であり、オペコードのロケーション_i_から始まります。 この関数は、再帰的に定義されています。 _i≥||c||_の場合、コードの末尾またはそれ以降にいることを意味します。 これ以上ジャンプ先は見つからないので、空集合を返すだけです。

それ以外のすべてのケースでは、次のオペコードに移動し、そこから始まる集合を取得することで、コードの残りの部分を調べます。 _c[i]_は現在のオペコードなので、_N(i,c[i])_は次のオペコードのロケーションです。 したがって、_D<sub>J</sub>(c,N(i,c[i]))_は、次のオペコードから始まる有効なジャンプ先の集合です。 現在のオペコードが`JUMPDEST`でなければ、その集合を返すだけです。 `JUMPDEST`であれば、結果の集合にそれを含めて返します。

## 9.4.4 通常の停止 {#944-normal-halt}

停止関数_H_は、3つの型の値を返すことができます。

- 停止オペコードでない場合は、空集合である_∅_を返します。 慣例により、この値はブール型の偽（false）として解釈されます。
- 出力を生成しない停止オペコード（[`STOP`](https://www.evm.codes/#00)または[`SELFDESTRUCT`](https://www.evm.codes/#ff)）がある場合、戻り値としてサイズがゼロバイトのシーケンスを返します。 これは空集合とは大きく異なることに注意してください。 この値は、EVMが実際に停止したことを意味しますが、読み取る戻りデータはありません。
- 出力を生成する停止オペコード（[`RETURN`](https://www.evm.codes/#f3)または[`REVERT`](https://www.evm.codes/#fd)）がある場合、そのオペコードで指定されたバイトのシーケンスを返します。 このシーケンスはメモリから取得され、スタックの先頭の値（_μ<sub>s</sub>[0]_）が最初のバイトで、その後の値（_μ<sub>s</sub>[1]_）が長さです。

## H.2 命令セット {#h2-instruction-set}

EVMの最後のサブセクション9.5に進む前に、命令自体を見てみましょう。 これらは付録H.2（29ページから）で定義されています。 特定のオペコードで変更されると指定されていないものはすべて、同じままであることが期待されます。 変更される変数は、\<something\>′として指定されます。

例えば、[`ADD`](https://www.evm.codes/#01)オペコードを見てみましょう。

|    値 | ニーモニック | δ | α | 説明                                                                                                                                                                                                                    |
| ---: | ------ | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0x01 | ADD    | 2 | 1 | 加算演算                                                                                                                                                                                                                  |
|      |        |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_は、スタックからポップする値の個数です。 この場合は、先頭にある2つの値を加算するので、2になります。

_α_は、プッシュバックする値の個数です。 この場合は合計で、1になります。

したがって、新しいスタックの先頭（_μ′<sub>s</sub>[0]）は、古いスタックの先頭（_μ<sub>s</sub>[0]）とその下の古い値（_μ<sub>s</sub>[1]_）の合計です。

退屈なリストですべてのオペコードを確認する代わりに、この記事では何か新しいものを導入するオペコードのみを説明します。

|    値 | ニーモニック    | δ | α | 説明                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ---: | --------- | - | - | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0x20 | KECCAK256 | 2 | 1 | Keccak-256ハッシュの計算                                                                                                                                                                                                                                                                                                                                                                                                                                     |
|      |           |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] .. 。 。 (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|      |           |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                                      |

これはメモリにアクセスする最初のオペコードです（この場合は読み取り専用）。 ただし、現在のメモリの制限を超えて拡張される可能性があるため、_μ<sub>i</sub>_を更新する必要があります。これには、29ページの式328で定義されている_M_関数を使用します。

|    値 | ニーモニック  | δ | α | 説明                                                  |
| ---: | ------- | - | - | --------------------------------------------------- |
| 0x31 | BALANCE | 1 | 1 | 指定されたアカウントの残高を取得します。                                |
|      |         |   |   | ... |

残高を調べる必要のあるアドレスは_μ<sub>s</sub>[0] mod 2<sup>160</sup>_です。 スタックの最上位がアドレスですが、アドレスは160ビットしかないため、値を[モジュロ](https://en.wikipedia.org/wiki/Modulo_operation)2<sup>160</sup>で計算します。

_σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_の場合、このアドレスに関する情報が存在することを意味します。 その場合、_σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_はそのアドレスの残高です。 _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_の場合、このアドレスは初期化されておらず、残高はゼロであることを意味します。 アカウント情報フィールドのリストは、4ページのセクション4.1に記載されています。

2番目の式、_A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_は、ウォームストレージ（最近アクセスされ、キャッシュされている可能性が高いストレージ）へのアクセスとコールドストレージ（アクセスされておらず、取得によりコストがかかる低速なストレージにある可能性が高いストレージ）へのアクセスのコスト差に関連しています。 _A<sub>a</sub>_は、トランザクションによって以前にアクセスされたアドレスのリストであり、8ページのセクション6.1で定義されているように、アクセスするコストが安くなるはずです。 この主題について詳しくは、[EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)で読むことができます。

|    値 | ニーモニック | δ  | α  | 説明                                                                                                                                              |
| ---: | ------ | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 0x8F | DUP16  | 16 | 17 | 16番目のスタックアイテムを複製します。                                                                                                                            |
|      |        |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

スタックアイテムを使用するには、それをポップする必要があることに注意してください。これは、その上にあるすべてのスタックアイテムもポップする必要があることを意味します。 [`DUP<n>`](https://www.evm.codes/#8f)および[`SWAP<n>`](https://www.evm.codes/#9f)の場合、これは最大16個の値をポップしてからプッシュする必要があることを意味します。

## 9.5 実行サイクル {#95-exec-cycle}

すべてのパーツが揃ったので、いよいよEVMの実行サイクルがどのように文書化されているのかを理解できます。

式（155）は、次の状態が与えられたことを示しています。

- _σ_（グローバルブロックチェーン状態）
- _μ_（EVM状態）
- _A_（サブ状態、トランザクション終了時に発生する変更）
- _I_（実行環境）

新しい状態は_(σ', μ', A', I')_です。

式（156）～（158）は、スタックとオペコード（_μ<sub>s</sub>_）によるスタックの変化を定義しています。 式（159）は、ガスの変化（_μ<sub>g</sub>_）です。 式（160）は、プログラムカウンタ（_μ<sub>pc</sub>_）の変化です。 最後に、式（161）～（164）は、オペコードによって明示的に変更されない限り、他のパラメータが同じままであることを指定しています。

これにより、EVMが完全に定義されました。

## 結論 {#conclusion}

数学的表記法は正確であり、イエローペーパーでイーサリアムのあらゆる詳細を指定することが可能になっています。 ただし、次のような欠点があります。

- 人間だけが理解できるため、[コンプライアンステスト](https://github.com/ethereum/tests)は手動で書く必要があります。
- プログラマーはコンピュータのコードを理解します。
  しかし、数学的な表記法については理解できないかもしれません。

おそらくこれらの理由から、新しい[コンセンサスレイヤー仕様](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md)はPythonで書かれています。 [Pythonで書かれた実行レイヤー仕様](https://ethereum.github.io/execution-specs)がありますが、完全ではありません。 イエローペーパー全体がPythonまたは同様の言語に翻訳されるまで、イエローペーパーは使用され続けるため、読めるようにしておくと便利です。
