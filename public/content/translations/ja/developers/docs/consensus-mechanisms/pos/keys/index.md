---
title: "イーサリアムのプルーフ・オブ・ステークにおける鍵について"
description: "イーサリアムにおけるプルーフ・オブ・ステークのコンセンサスメカニズムで使用される各種の鍵の説明"
lang: ja
---

イーサリアムでは、公開鍵と秘密鍵による暗号化を用いてユーザーの資産を保護しています。 公開鍵は、イーサリアムアドレスの基盤として使用されるもので、誰もが見ることができ、一意の識別子として使用されます。 一方で、プライベートキー(すなわち「秘密鍵」)はアカウント所有者以外はアクセスできないものでなければなりません。 秘密鍵は、トランザクションおよびデータに「署名」するために用いられ、特定の秘密鍵の所有者がその鍵のアクションを承認したことを暗号化によって証明できるものです。

イーサリアムの鍵は、[楕円曲線暗号](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)を使用して生成されます。

しかし、イーサリアムが[プルーフ・オブ・ワーク](/developers/docs/consensus-mechanisms/pow)から[プルーフ・オブ・ステーク](/developers/docs/consensus-mechanisms/pos)に移行した際、新しい種類の鍵がイーサリアムに追加されました。 従来の鍵も、これまでとまったく同様に機能し、楕円曲線暗号を用いて生成された鍵により保護されるアカウントは従来とまったく変更されません。 しかし、イーサのステーキングやバリデータの実行によりプルーフ・オブ・ステークに参加するには、新しい種類の鍵が必要になります。 この新しい種類の鍵は、暗号化の手段を必要とする非常に多くのバリデータ間におけるメッセージのやりとりが必要であるというスケーラビリティの課題を克服するために導入されたもので、メッセージを集約することで、ネットワークがコンセンサスを実現するために必要なコミュニケーションの規模を縮小することができます。

この新しい種類の鍵は、[**Boneh-Lynn-Shacham (BLS)** 署名方式](https://wikipedia.org/wiki/BLS_digital_signature)を使用します。 BLSは、署名を非常に効率的に集約できるだけでなく、集約された個々のバリデータの鍵に対してリバースエンジニアリングを実行することも可能であり、バリデータ間のアクションを管理する上で理想的なソリューションです。

## 2種類のバリデータ鍵 {#two-types-of-keys}

イーサリアムでは、プルーフ・オブ・ステークへの移行前は、楕円曲線ベースの秘密鍵だけを用いて資金にアクセスしていました。 プルーフ・オブ・ステークの導入により、ソロステーカーになることを希望するユーザーには、**バリデータ鍵**と**出金鍵**も必要になりました。

### バリデータ鍵 {#validator-key}

バリデータの署名鍵は、以下の2つの要素で構成されます：

- バリデータ**秘密**鍵
- バリデータ**公開**鍵

バリデータ秘密鍵は、ブロックの提案やアテステーションといったオンチェーンの操作を行うために使用します。 このため、バリデータ秘密鍵は常にホットウォレットで管理しなければなりません。

この柔軟性により、バリデータの署名鍵をあるデバイスから別のデバイスに非常に迅速に移動できるという利点がありますが、紛失または盗難された場合、攻撃者はいくつかの方法で**悪意のある行動**をとることができます:

- 以下の行為に対して、バリデータの資産がスラッシングされうる：
  - 提案者となり、同一スロットにおいて2つの異なるビーコンブロックに署名してしまう
  - アテスターとなり、他のアテステーションを「取り囲む」アテステーションに署名してしまう
  - アテスターとなり、同一のターゲットに対して2つの異なるアテステーションを署名する場合
- 自発的な退出を強制して、当該のバリデータがステーキングを行えなくし、出金鍵の所有者がバリデータのETH残高にアクセスできるようにする場合

**バリデータ公開鍵**は、ユーザーがステーキングの入金コントラクトにETHを入金する際のトランザクションデータに含まれています。 これは、入金データと呼ばれ、イーサリアムがバリデータを特定するために用いられます。

### 出金の認証情報 {#withdrawal-credentials}

すべてのバリデータは、_出金の認証情報_として知られるプロパティを持っています。 この32バイトのフィールドは、BLSによる出金の認証情報を表す`0x00`か、実行アドレスを示す認証情報を表す`0x01`のどちらかで始まります。

`0x00`のBLS鍵を持つバリデータは、超過残高の支払いやステーキングからの全額出金を有効にするために、これらの認証情報を実行アドレスを指すように更新する必要があります。 これは、最初の鍵生成時に入金データで実行アドレスを提供するか、_または_後で出金鍵を使用して`BLSToExecutionChange`メッセージに署名し、ブロードキャストすることで行えます。

### 出金鍵 {#withdrawal-key}

出金鍵は、最初の入金時において設定していない場合、実行アドレスを示す出金の認証情報を更新する際に必要になります。 これにより、超過残高の支払いプロセスを開始できるだけでなく、ユーザーはステークしたETH全額を出金できるようになります。

出金鍵は、バリデータ鍵と同様に、以下の2つの要素で構成されます：

- 出金用**秘密**鍵
- 出金用**公開**鍵

出金の認証情報を0x01タイプに更新する前にこの鍵を紛失してしまうと、バリデータは残高にアクセスできなくなります。 ブロックや署名に必要なのはバリデータの秘密鍵であるため、この場合でも、バリデータはアテステーションやブロックに署名を行うことができますが、出金鍵を紛失してしまった場合、バリデータが署名を行う理由はほぼ／まったくなくなります。

イーサリアムのアカウント鍵とバリデータ鍵を分離することで、1人のユーザーが複数のバリデータを実行することが可能になります。

![バリデータ鍵の概略図](validator-key-schematic.png)

**注**: 現在、ステーキングの責務から退出してバリデータの残高を引き出すには、バリデータ鍵で[自発的退出メッセージ(VEM)](https://mirror.xyz/ladislaus.eth/wmoBbUBes2Wp1_6DvP6slPabkyujSU7MZOFOC3QpErs&1)に署名する必要があります。 ただし、[EIP-7002](https://eips.ethereum.org/EIPS/eip-7002)は、将来、ユーザーが出金鍵で退出メッセージに署名することで、バリデータの退出をトリガーし、その残高を引き出すことを可能にする提案です。 これにより、[ステーキング・アズ・ア・サービス・プロバイダー](/staking/saas/#what-is-staking-as-a-service)にETHを委任するステーカーが自身の資金の管理を維持できるようになり、信頼の仮定が軽減されます。

## シードフレーズからの鍵の導出 {#deriving-keys-from-seed}

ユーザーが32ETHをステークするには、相互に完全に独立した2つの鍵セットが新たに必要になるため、特に複数のバリデータを実行するユーザーにとっては鍵の管理がとても煩雑になります。 この状況を回避するため、1つの共通のシークレットから複数のバリデータ鍵を導出できるようになっており、この1つのシークレットを保存することで、複数のバリデータ鍵へのアクセスが可能になります。

[ニーモニック](https://en.bitcoinwiki.org/wiki/Mnemonic_phrase)とパスは、ユーザーが自分のウォレットに[アクセスする](https://ethereum.stackexchange.com/questions/19055/what-is-the-difference-between-m-44-60-0-0-and-m-44-60-0)際によく遭遇する顕著な機能です。 ニーモニックとは、特定の秘密鍵に対する当初のシードとして機能する単語のつらなりです。 ニーモニックは、追加のデータと結合することで、「マスター鍵」と呼ばれるハッシュを生成できます。 マスター鍵は、特定のツリーにおけるルートだと考えればよいでしょう。 このルートから派生したブランチについては、階層的なパスを用いて導出できるので、子ノードは親ノードのハッシュとツリー上のインデックスを結合したものとして存在することになります。 ニーモニックベースの鍵生成に関する[BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)および[BIP-19](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)標準についてお読みください。

パスは、以下のような構造を持ちます。ハードウェアのウォレットを使用したことがあるユーザーにとっては、おなじみでしょう。

```
m/44'/60'/0'/0`
```

このパスでは、秘密鍵の各要素をスラッシュで区切っています：

```
master_key / purpose / coin_type / account / change / address_index
```

このロジックにより、ツリーのルートは共通で、分岐点で差別化できるため、ユーザーは単一の**ニーモニックフレーズ**にできるだけ多くのバリデータを関連付けることができます。 ユーザーは、ニーモニックフレーズを用いて、鍵をいくつでも導出することができます。

```
      [m / 0]
     /
    /
[m] - [m / 1]
    \
     \
      [m / 2]
```

各ブランチは、/で区切られるため、m/2は、マスター鍵で開始され、ブランチ2に従うことを意味します。 以下の図の場合、1つのニーモニックフレーズを用いて3つの出金鍵が保存され、それぞれに2つのバリデータが関連付けられています。

![バリデータ鍵のロジック](multiple-keys.png)

## 参考リンク{#further-reading}

- [Carl Beekhuizenによるイーサリアム・ファウンデーションのブログ投稿](https://blog.ethereum.org/2020/05/21/keys/)
- [EIP-2333 BLS12-381 鍵生成](https://eips.ethereum.org/EIPS/eip-2333)
- [EIP-7002: 実行レイヤーによってトリガーされる退出](https://web.archive.org/web/20250125035123/https://research.2077.xyz/eip-7002-unpacking-improvements-to-staking-ux-post-merge)
- [大規模な鍵管理](https://docs.ethstaker.cc/ethstaker-knowledge-base/scaled-node-operators/key-management-at-scale)
