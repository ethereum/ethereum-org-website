---
title: ノードとクライアント
description: イーサリアムノードとクライアントソフトの概要、ノードを設定する方法とその必要性
lang: ja
sidebarDepth: 2
---

イーサリアムは、「ノード」と呼ばれるコンピュータの分散型ネットワークです。ノードで実行されているソフトウェアが、ブロックとトランザクションデータを検証します。 このソフトウェアは、コンピュータをイーサリアムノードにするために、必ず実行する必要があります。 ノードを構成するには、 別々のソフトウェア (「クライアント」と呼ばれる) が2つ必要です。

## 前提知識 {#prerequisites}

イーサリアムクライアントの詳細を学び、自分で動かすには、P2Pネットワークの概念と[EVMの基本](/developers/docs/evm/)を理解する必要があります。 まずは[イーサリアム入門](/developers/docs/intro-to-ethereum/)を読んでください。

ノード運用初心者の方は、まず[イーサリアムノードの運用](/run-a-node)というユーザーフレンドリーな導入方法をチェックすることをお勧めします。

## ノードとクライアントとは {#what-are-nodes-and-clients}

「ノード」とは、イーサリアムソフトウェアを実行している他のコンピュータと接続されたイーサリアムクライアントソフトウェアの任意のインスタンスであり、ネットワークを形成します。 「クライアント」とは、プロトコルルールに従ってデータを検証し、安全なネットワークを維持するイーサリアムの実装です。 ノードでは、コンセンサスクライアントと実行クライアントの2つのクライアントを実行する必要があります。

- 実行クライアント(ELクライアントや実行エンジンとも呼ばれ、過去の名称はEth1クライアント)は、ネットワークでブロードキャストされた新たなトランザクションを受け取り、EVM(イーサリアム仮想マシン)でトランザクションを実行し、すべての現在のイーサリアムデータの最新の状態とデータベースを保持します。
- コンセンサスクライアント(ビーコンノードやCLクライアントとも呼ばれ、過去の名称はETh2クライアント)は、プルーフ・オブ・ステークのコンセンサスアルゴリズムを実行し、実行クライアントからの検証されたデータに基づき、ネットワークの合意を形成します。 「バリデータ」と呼ばれる3つ目のソフトウェアもあります。バリデータをコンセンサスクライアントに追加することで、ネットワークのセキュリティの確保にノードを参加させることができます。

これらのクライアントは、連携してイーサリアムチェーンのヘッドを追跡し、ユーザーがイーサリアムネットワークとやり取りできるようにします。 複数のソフトウェアを組み合わせたモジュラー型設計は、[カプセル化された複雑性](https://vitalik.eth.limo/general/2022/02/28/complexity.html)と呼ばれます。 このアプローチにより、[マージ](/roadmap/merge)をシームレスに実行できるようになりました。また、クライアントソフトウェアの保守や開発が容易になり、[レイヤー2エコシステム](/layer-2/)などの各クライアントを再利用できるようになりました。

![実行クライアントとコンセンサスクライアントの連結](./eth1eth2client.png) 実行クライアントとコンセンサスクライアントの統合の簡略図

### クライアントの多様性 {#client-diversity}

[実行クライアント](/developers/docs/nodes-and-clients/#execution-clients)と[コンセンサスクライアント](/developers/docs/nodes-and-clients/#consensus-clients)は、それぞれ異なるチームが、さまざまなプログラミング言語を使って開発しています。

複数のクライアント実装が、単一のコードベースへの依存を減らし、ネットワークをより強固にします。 理想は、どのクライアントもネットワークの大多数を占めることなく、多様性を実現し、単一障害点を減らすことです。 また、多様な言語を揃えることで、デベロッパーコミュニティがより広範になり、デベロッパーの希望言語で開発できるようになります。

[クライアントの多様性についての詳細](/developers/docs/nodes-and-clients/client-diversity/)

これらのクライアント実装は、すべて同じ仕様に従っています。 仕様はイーサリアムネットワークとブロックチェーンの機能や技術的な詳細を定義しており、 下記で確認することができます。

- 元々は[イーサリアムイエローペーパー](https://ethereum.github.io/yellowpaper/paper.pdf)
- [実行クライアントの仕様](https://github.com/ethereum/execution-specs/)
- [コンセンサスクライアントの仕様](https://github.com/ethereum/consensus-specs)
- さまざまな[ネットワーク・アップグレード](/history/)で実装された[EIP](https://eips.ethereum.org/)

### ネットワークのノードの追跡 {#network-overview}

イーサリアムネットワークのノードの概要をリアルタイムで提供しているトラッカーが複数あります。 しかし、分散型ネットワークの性質上、これらのクローラーはネットワークの一部しか把握できず、異なる結果を報告する可能性があることに注意してください。

- Etherscanによる[ノードのマップ](https://etherscan.io/nodetracker)
- Bitflyによる[Ethernodes](https://ethernodes.org/)
- [Nodewatch](https://www.nodewatch.io/): Chainsafeによるコンセンサスノードのクローリング

## ノードの類型 {#node-types}

[自分でノードを実行](/developers/docs/nodes-and-clients/run-a-node/)したい場合、ノードの種類を選ぶ必要があります。ノードにはいくつかの種類があり、それぞれデータの扱い方が異なります。 実際に、クライアントが実行できるノードには、ライトノード、フルノード、アーカイブノードの3種類があります。 また、同期時間を短縮する同期戦略のオプションを選ぶこともできます。 同期とは、イーサリアムの状態についての最新情報をどれだけ迅速に取得できるかを意味します。

### フルノード {#full-node}

フルノードは、各ブロックごとのブロックボディーと状態データのダウンロードおよび検証に加え、ブロックチェーンの各ブロックの検証を行います。 フルノードにはさまざまな種類があります。ジェネシスブロックから開始してブロックチェーンの履歴にあるすべてのブロックを1つずつ検証するものや、 直近のブロックで有効性が信頼できるものから検証を開始するものがあります(例: Gethの「スナップ同期」) 。 ディスク領域を節約するため、フルノードは検証の開始位置に関係なく、比較的最近のデータ(通常は直近の128ブロック)のローカルコピーのみを保存し、古いデータを削除できるようにしています。 古いデータは、必要に応じて再生成されます。

- 完全なブロックチェーンデータを保存(ただし、フルノードは定期的にプルーニングされており、最初のジェネシス(誕生)までさかのぼる状態は保存されていない)
- ブロック検証に参加し、すべてのブロックと状態を検証する
- すべての状態は、ローカルストレージから取得するか、フルノードによって「スナップショット」から再生成できます。
- ネットワークに貢献し、リクエストに応じてデータを提供する

### アーカイブノード {#archive-node}

アーカイブノードは、ジェネシスからすべてのブロックを検証し、ダウンロードしたデータを永久に保存するフルノードです。

- フルノードに保存されているすべてを保持し、過去の状態のアーカイブを構築する。 例えば、ブロック4,000,000のアカウント残高をクエリしたい場合、または簡単にかつ確実にトレースを使用してマイニングを行うことなく、自分のトランザクションセットをテストしたい場合などに必要。
- データがテラバイト単位になるため、平均的なユーザーにとってアーカイブノードは魅力的なものではないが、ブロックエクスプローラー、ウォレットベンダー、チェーン分析などのサービスに有用。

アーカイブ以外の任意のモードでクライアントを同期すると、ブロックチェーンデータがプルーニングされます。 つまり、すべての過去の状態を保存するアーカイブは存在しませんが、フルノードは必要に応じて構築できます。

[アーカイブノードの詳細](/developers/docs/nodes-and-clients/archive-nodes)

### ライトノード {#light-node}

ライトノードは、すべてのブロックをダウンロードする代わりに、ブロックヘッダーのみをダウンロードします。 ブロックヘッダーには、ブロックの内容に関するサマリー情報が含まれています。 ライトノードは、必要に応じて、フルノードからブロックヘッダー以外の情報を取得します。 また、受信したデータをブロックヘッダーの状態ルートに対して個別に検証できます。 ライトノードでは、フルノードを実行するために必要な強力なハードウェアや高帯域幅がなくても、イーサリアムネットワークに参加できます。 最終的には、ライトノードは携帯電話や組み込み機器で動作できるようになる可能性があります。 ライトノードはコンセンサスには参加せず、マイナーやバリデータにはなれませんが、フルノードと同じ機能とセキュリティ保証でイーサリアムブロックチェーンにアクセスできます。

イーサリアムでは、ライトクライアントの開発が活発に行われています。コンセンサスレイヤーと実行レイヤーの新しいライトクライアントが、まもなくリリースされる予定です。 また、[ゴシップネットワーク](https://www.ethportal.net/)を介して、ライトクライアントデータを提供する方法もあります。 ゴシップネットワークは、フルノードがリクエストに応答することなくライトノードのネットワークをサポートできるため効率的です。

イーサリアムでは現在、ライトノードは多数サポートされていませんが、今後急速に普及していくと考えられています。 特に、[Nimbus](https://nimbus.team/)、[Helios](https://github.com/a16z/helios)、[LodeStar](https://lodestar.chainsafe.io/)などのクライアントは、現在ライトノードを重点的に開発しています。

## イーサリアムノードを運用する必要性 {#why-should-i-run-an-ethereum-node}

ノードを実行することで、イーサリアムを直接、トラストレスかつプライベートに利用することができます。また、イーサリアムのネットワークをより強固にし、分散化の促進に貢献することができます。

### メリット {#benefits-to-you}

自分のノードを実行すると、プライベートで自己完結したトラストレスな形でイーサリアムを利用することができます。 クライアントを使って自分でデータを検証できるので、ネットワークを信頼する必要はありません。 「信頼するな、検証せよ」はブロックチェーンで頻繁に唱えられるマントラです。

- ノードはすべてのトランザクションとブロックをコンセンサスルールに対して検証する。 つまり、ネットワークの他のノードに依存したり、完全に信頼する必要がない。
- 自分のノードでイーサリアムウォレットを使用可能。 仲介業者に自分のアドレスや残高情報を渡す必要がないため、より安全かつプライベートに分散型アプリ(Dapp)を利用できる。 自身のクライアントですべてをチェックできる。 [MetaMask](https://metamask.io)、[Frame](https://frame.sh/)、[他の多くのウォレット](/wallets/find-wallet/)はRPCインポート機能を提供し、自分のノードを使用できる。
- イーサリアムからのデータに依存する他のサービスを実行および自分でホスト可能 (例えば、ビーコンチェーンのバリデータ、レイヤー2などのソフトウェア、インフラストラクチャ、ブロックエクスプローラー、ペイメントプロセッサーなど)。
- 独自のカスタム[RPCエンドポイント](/developers/docs/apis/json-rpc/)を提供できる。 このエンドポイントをコミュニティに公開することで、巨大な中央集権型プロバイダーへの依存を減らすことができる。
- **プロセス間通信(IPC)**を利用してノードに接続、またはノードを書き換えプラグインとしてプログラムの読み込みが可能。 これにより、レイテンシーが低くなり、Web3ライブラリを使用して大量のデータを処理する場合、またはトランザクションをできるだけ早く置き換える必要がある場合に(フロントランニング)、非常に有用。
- ETHを直接ステーキングでき、ネットワークの安全性に貢献し、同時に報酬を得ることができる。 始めるには[ソロステーキング](/staking/solo/)を参照。

![アプリケーションやノードを介してイーサリアムにアクセスする方法](./nodes.png)

### ネットワークのメリット {#network-benefits}

イーサリアムの健全性、セキュリティ、運用レジリエンスにとって、ノードの多様性は重要です。

- フルノードがコンセンサスルールを強制するため、ルールに従わないブロックが受け入れられることはない。 これはネットワークのセキュリティ強化につながる(すべてのノードが完全な検証ができないライトノードの場合では、バリデータがネットワークに対して攻撃できる恐れがあるため)。
- [プルーフ・オブ・ステーク](/developers/docs/consensus-mechanisms/pos/#what-is-pos)の暗号経済的な防御を上回る攻撃の場合、正しいチェーンを選ぶフルノードによって、社会的回復が行われる。
- ネットワークのノード数が増えることで、分散化の究極の目標である多様で堅牢なネットワークとなり、検閲耐性があり、信頼性の高いシステムになる。
- フルノードからのブロックチェーンデータに依存するライトクライアントに、ブロックチェーンデータへのアクセスを提供する。 ライトノードはブロックチェーンの全データを保持せず、代わりに、[ブロックヘッダーのステートルート](/developers/docs/blocks/#block-anatomy)を利用してデータを検証する。 また、必要に応じて、フルノードから追加情報のリクエストを行う。

フルノードを実行すると、バリデータを実行しなくても、イーサリアムネットワーク全体がそのメリットを享受することができます。

## 自分のノードの運用 {#running-your-own-node}

自分のイーサリアムクライアントを運用してみませんか?

初心者向けの導入方法については、[ノードの運用](/run-a-node)ページをご覧ください。

上級者の方は、[自分のノードを立ち上げる](/developers/docs/nodes-and-clients/run-a-node/)を参照し、詳細やオプションを確認してください。

## 代替手段 {#alternatives}

自分のノードを設定するには、時間とリソースがかかりますが、必ずしも独自のインスタンスを実行する必要はありません。 サードパーティのAPIプロバイダーを利用すれば負担を軽減できます。 これらのサービスの概要については、 [ノード・アズ・ア・サービス(NaaS)](/developers/docs/nodes-and-clients/nodes-as-a-service/)で確認してください。

コミュニティでパブリックなAPIを持つイーサリアムノードが運用されている場合、カスタムRPCを介してウォレットをコミュニティノードに向けることができ、ランダムなサードパーティを使うよりも、プライバシーを確保することができます。

一方で、自分のクライアントを運用している場合は、必要としている友人とクライアントを共有できます。

## 実行クライアント {#execution-clients}

イーサリアムコミュニティでは、異なるプログラミング言語で、さまざまなチームが開発した、複数のオープンソースの実行クライアント(旧称は「Eth1クライアント」または「イーサリアムクライアント」)を維持しています。 これにより、ネットワークがより強固になり、[多様性](/developers/docs/nodes-and-clients/client-diversity/)を実現しています。 理想は、どのクライアントもネットワークの大部分を占めることなく、多様性を実現し、単一障害点を減らすことです。

この表は、いくつかのクライアントの情報をまとめたものです。 これらのクライアントはすべて、[クライアントテスト](https://github.com/ethereum/tests)に合格しており、ネットワークのアップグレードによって最新の状態に維持されています。

| クライアント                                                                  | 言語         | オペレーティングシステム        | ネットワーク                    | 同期戦略                                                     | 状態剪定       |
| ----------------------------------------------------------------------- | ---------- | ------------------- | ------------------------- | -------------------------------------------------------- | ---------- |
| [Geth](https://geth.ethereum.org/)                                      | Go         | Linux、Windows、macOS | Mainnet, Sepolia, Holesky | [スナップ](#snap-sync)、[フル](#full-sync)                      | アーカイブ、プルーン |
| [Nethermind](https://www.nethermind.io/)                                | C#、.NET    | Linux、Windows、macOS | Mainnet, Sepolia, Holesky | [スナップ](#snap-sync) (without serving)、高速、[フル](#full-sync) | アーカイブ、プルーン |
| [Besu](https://besu.hyperledger.org/en/stable/)                         | Java       | Linux、Windows、macOS | Mainnet, Sepolia, Holesky | [スナップ](#snap-sync)、[高速](#fast-sync)、[フル](#full-sync)     | アーカイブ、プルーン |
| [Erigon](https://github.com/ledgerwatch/erigon)                         | Go         | Linux、Windows、macOS | Mainnet, Sepolia, Holesky | [フル](#full-sync)                                         | アーカイブ、プルーン |
| [Reth](https://reth.rs/)                                                | Rust       | Linux、Windows、macOS | Mainnet, Sepolia, Holesky | [フル](#full-sync)                                         | アーカイブ、プルーン |
| [EthereumJS](https://github.com/ethereumjs/ethereumjs-monorepo) _(ベータ)_ | TypeScript | Linux、Windows、macOS | Sepolia, Holesky          | [フル](#full-sync)                                         | プルーン       |

サポートされているネットワークの詳細については、[イーサリアムネットワーク](/developers/docs/networks/)をご覧ください。

各クライアントには、それぞれに応じたユースケースとメリットがあります。自分に合ったクライアントを選択してください。 多様性により、さまざまな機能やユーザー層に合わせた実装が可能です。 機能、サポート、プログラミング言語、またはライセンスなどの観点から、クライアントを選択することをお勧めします。

### Besu {#besu}

ハイパーレジャーBesuは、パブリックネットワークと許可型ネットワークの両方に対応する、エンタープライズグレードのイーサリアムクライアントです。 イーサリアムメインネットのすべての機能を実行するクライアントは、ConsenSys社によりサポートされています。トレースからGraphQLまで、幅広いモニタリング機能を備えており、公開コミュニティチャンネルと企業向けの商用SLAの両方に対応しています。 また、Javaで実装されており、Apache 2.0ライセンスです。

機能とセットアップの詳細については、Besuの完全版[ドキュメント](https://besu.hyperledger.org/en/stable/)に記載されています。

### Erigon {#erigon}

Erigon(旧称: Turbo-Geth)は、Go Ethereumのフォークから派生したものであり、速度とディスク容量の効率を重視しています。 イーサリアムの完全に再設計された実装であり、現在はGoで書かれていますが、他の言語での実装も開発中です。 Erigonは、より高速で、よりモジュール化されており、より最適化されたイーサリアムの実装を目指しています。 2TB程度のディスク容量があれば、3日以内にフルアーカイブノードの同期が可能です。

### Go Ethereum(Geth) {#geth}

Go Ethereum(略してGeth)は、イーサリアムプロトコルのオリジナルの実装の1つです。 現在、最も普及しているクライアントであり、ユーザーやデベロッパー向けのツールの種類も豊富です。 Go言語で実装されており、完全にオープンソースで、GNU LGPL v3ライセンスの下で提供されています。

Gethの詳細については、[ドキュメント](https://geth.ethereum.org/docs/)を参照してください。

### Nethermind {#nethermind}

Nethermindは、C# .NETの技術スタックで開発されたイーサリアムの実装で、LGPL-3.0ライセンスの下で提供されています。ARMを含むすべての主要なプラットフォームに対応しており、 以下のような優れたパフォーマンスを発揮します。

- 最適化された仮想マシン
- 状態アクセス
- ネットワーキングや、Prometheus/Grafanaダッシュボード、Seqエンタープライズロギングサポート、JSON-RPCトレーシング、分析プラグインなどの豊富な機能

また、Nethermindは、[詳細なドキュメント](https://docs.nethermind.io)、強力な開発サポート、オンラインコミュニティ、プレミアムユーザー向けの24時間年中無休のサポートなど、充実したサポート体制を整えています。

### Reth {#reth}

Reth (Rust Ethereumの略) は、使いやすさ、高度なモジュール化、速さ、効率性を重視したイーサリアムフルノード実装です。 Rethは元々Paradigmによって開発・推進されており、ApacheおよびMITライセンスの下で提供されています。

Rethは本番環境での利用が可能で、ステーキングや高稼働サービスなどのミッションクリティカルな環境での使用に適しています。 また、RPC、MEV、インデックス作成、シミュレーション、P2P活動など、高いパフォーマンスと大きなマージンが求められるユースケースでも優れた性能を発揮します。

詳細は[Reth Book](https://reth.rs/)や[Reth GitHubリポジトリ](https://github.com/paradigmxyz/reth?tab=readme-ov-file#reth)をご覧ください。

### 開発中 {#execution-in-development}

これらのクライアントはまだ開発の初期段階であるため、今のところ本番環境での使用は推奨されていません。

#### EthereumJS {#ethereumjs}

EthereumJS実行クライアント(EthereumJS)は、TypeScriptで書かれ、いくつかのパッケージで構成されています。ブロック、トランザクション、マークルパトリシアツリークラスで表すコアイーサリアムプリミティブや、イーサリアム仮想マシン(EVM)、ブロックチェーンクラス、DevP2Pネットワークスタックの実装などのコアクライアントコンポーネントを含みます。

詳細については、EthereumJSの[ドキュメント](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master)を参照してください。

## コンセンサスクライアント {#consensus-clients}

[コンセンサスアップグレード](/roadmap/beacon-chain/)に対応する複数のコンセンサスクライアント(旧称: 「Eth2」クライアント) があります。 コンセンサスクライアントは、フォーク選択アルゴリズム、アテステーションの処理、[プルーフ・オブ・ステーク](/developers/docs/consensus-mechanisms/pos)の報酬とペナルティの管理など、コンセンサスに関連するロジックをすべて担っています。

| クライアント                                                        | 言語         | オペレーティングシステム        | ネットワーク                                           |
| ------------------------------------------------------------- | ---------- | ------------------- | ------------------------------------------------ |
| [Lighthouse](https://lighthouse.sigmaprime.io/)               | Rust       | Linux、Windows、macOS | ビーコンチェーン、Goerli、Pyrmont、Sepolia、Ropstenなど        |
| [Lodestar](https://lodestar.chainsafe.io/)                    | TypeScript | Linux、Windows、macOS | ビーコンチェーン、Goerli、Sepolia、Ropstenなど                |
| [Nimbus](https://nimbus.team/)                                | Nim        | Linux、Windows、macOS | ビーコンチェーン、Goerli、Sepolia、Ropstenなど                |
| [Prysm](https://docs.prylabs.network/docs/getting-started/)   | Go         | Linux、Windows、macOS | ビーコンチェーン、Gnosis、Goerli、Pyrmont、Sepolia、Ropstenなど |
| [Teku](https://consensys.net/knowledge-base/ethereum-2/teku/) | Java       | Linux、Windows、macOS | ビーコンチェーン、Gnosis、Goerli、Sepolia、Ropstenなど         |

### Lighthouse {#lighthouse}

Lighthouseは、Apache-2.0ライセンスの下、Rustで書かれたコンセンサスクライアントの実装です。 Sigma Primeによって管理されており、ビーコンチェーン誕生以降、安定したパフォーマンスで稼働しています。 また、さまざまなエンタープライズやステーキングプール、個人からの信頼を得ています。 デスクトップPCから高度な自動デプロイまで、あらゆる環境における安全性、パフォーマンス、相互運用性を目指しています。

ドキュメントは、[Lighthouse Book](https://lighthouse-book.sigmaprime.io/)で参照できます。

### Lodestar {#lodestar}

Lodestarは、LGPL-3.0ライセンスの下、Typescriptで書かれた、本番環境に対応したコンセンサスクライアントの実装です。 ChainSafe Systems社によって管理されており、ソロステーカー、デベロッパー、研究者向けのコンセンサスクライアントの中で最も新しいものです。 Loadstarは、イーサリアムプロトコルをJavaScriptで実装した、ビーコンノードとバリデータクライアントから構成されています。 ライトクライアントでのイーサリアムの使いやすさを向上させ、より多くのデベロッパーグループがアクセスできるようにすることで、エコシステムの多様性にさらに貢献することを目指しています。

詳細については、[Lodestarのウェブサイト](https://lodestar.chainsafe.io/)をご覧ください。

### Nimbus {#nimbus}

Nimbusは、Apache-2.0ライセンスの下、Nimで書かれたコンセンサスクライアントの実装です。 ソロステーカーやステーキングプールで使用されており、本番環境に対応したクライアントです。 Nimbusはリソース効率を重視して設計されており、リソースに制限のあるデバイスや企業のインフラストラクチャ上でも、安定性や報酬のパフォーマンスを損なわずに簡単に実行できます。 リソース利用量が少ないと、ネットワークに負荷がかかっても、クライアントは安全に動作します。

詳しくは、[Nimbusのドキュメント](https://nimbus.guide/)をご覧ください。

### Prysm {#prysm}

Prysmは、GPL-3.0ライセンスの下、Goで書かれたフル機能のオープンソースのコンセンサスクライアントです。 オプションのWebアプリのUIを備え、自宅でステーキングするユーザーと機関ユーザーの両方に向けて、ユーザーエクスペリエンス、ドキュメント、設定可能性を優先しているのが特徴です。

詳しくは、[Prysmのドキュメント](https://docs.prylabs.network/docs/getting-started/)をご覧ください。

### Teku {#teku}

Tekuは、オリジナルのビーコンチェーンで誕生したクライアントの1つです。 セキュリティ、堅牢性、安定性、使いやすさ、パフォーマンスなどの基本的な目標に加えて、Tekuはさまざまなコンセンサスクライアント標準に完全に準拠することを特に重視しています。

Tekuは、非常に柔軟なデプロイメントオプションを提供しています。 ビーコンノードとバリデータクライアントをシングルプロセスとして実行できるので、ソロステーカーにとって非常に便利です。または、高度なステーキング操作を行う場合は、個別にノードを実行することもできます。 さらに、署名キーのセキュリティとスラッシング保護のために、[Web3Signer](https://github.com/ConsenSys/web3signer/)と完全に互換性があります。

Tekuは、Javaで実装されており、Apache 2.0でライセンスされています。 BesuやWeb3Signerを手がけるConsenSys社のプロトコルチームによって開発されています。 詳しくは、[Tekuのドキュメント](https://docs.teku.consensys.net/en/latest/)をご覧ください。

## 同期モード {#sync-modes}

イーサリアムクライアントがネットワークの現在のデータを追って検証するには、最新のネットワーク状態と同期する必要があります。 そのためには、ピアからデータをダウンロードし、暗号的に完全性を検証した上で、ローカルのブロックチェーンデータベースを構築する必要があります。

同期モードには、さまざまなトレードオフを持つ異なるアプローチがあります。 また、各クライアントによって、同期アルゴリズムの実装が異なります。 そのため、実装の詳細については、必ずクライアントの公式ドキュメントを参照してください。

### 実行レイヤーの同期モード {#execution-layer-sync-modes}

実行レイヤーは、ブロックチェーンのワールドステートを再実行するモードから、信頼できるチェックポイントからチェーンの最新部分にのみ同期するモードまで、さまざまなユースケースに合わせて異なるモードで実行できます。

#### フル同期(Full sync) {#full-sync}

フル同期では、すべてのブロック (ヘッダーとブロックボディを含む) をダウンロードし、ジェネシスブロックからすべてのブロックを実行することで、ブロックチェーンの状態を段階的に再生成します。

- すべてのトランザクションを検証することにより、信用する必要性を最小限に抑え、最高のセキュリティを提供
- トランザクション数が増えると、全トランザクションを処理するのに数日から数週間かかることがある

[アーカイブノード](#archive-node)は、フル同期を実行して、すべてのブロック内のすべてのトランザクションによって行われた状態変化の完全な履歴を構築し、保持します。

#### 高速同期(Fast sync) {#fast-sync}

フル同期と同様に、高速同期もすべてのブロック (ヘッダー、トランザクション、レシートを含む) をダウンロードします。 しかし、高速同期は過去のトランザクションを再処理する代わりに、レシートに依存し、最新のヘッドに到達するとフルノードを提供するためにブロックのインポートと処理に切り替わります。

- 高速同期戦略
- 帯域幅の使用を優先した処理負荷の軽減

#### スナップ同期(Snap sync) {#snap-sync}

スナップ同期もチェーンをブロックごとに検証します。 ただし、ジェネシスブロックからではなく、「信頼できる」最新のチェックポイントから開始します。このチェックポイントは、正しいブロックチェーンの一部であることが確認されています。 ノードは、一定期間を経過したデータを削除しますが、定期的にチェックポイントを保存します。 これらのスナップショットは、データを永続的に保存するのではなく、必要に応じてステートデータを再生成するために使用されます。

- 最速の同期戦略で、現在のイーサリアムメインネットのデフォルトです。
- セキュリティを犠牲にすることなく、多くのディスク使用量とネットワーク帯域幅を節約できます。

[スナップ同期の詳細はこちら](https://github.com/ethereum/devp2p/blob/master/caps/snap.md)

#### 軽量同期(Light sync) {#light-sync}

ライトクライアントモードでは、すべてのブロックヘッダーとブロックデータをダウンロードし、ランダムに検証を行います。 信頼できるチェックポイントからチェーンの先端までのみを同期します。

- デベロッパーへの信頼と合意メカニズムに依存し、最新の状態のみを取得
- クライアントは数分で現在のネットワーク状態で使用できるようになる

**注: ** 現在、プルーフ・オブ・ステークのイーサリアムでは、軽量同期は利用できません。軽量同期の新しいバージョンが、まもなくリリースされる予定です。

[ライトクライアントの詳細](/developers/docs/nodes-and-clients/light-clients/)

### コンセンサスレイヤーの同期モード {#consensus-layer-sync-modes}

#### オプティミスティック同期 {#optimistic-sync}

オプティミスティック同期はマージ後の同期戦略で、オプトインで下位互換性を備えており、実行ノードが確立された方法で同期できます。 実行エンジンは、ビーコンブロックを完全に検証せず、_オプティミスティックに(楽観的に)_インポートすることができます。そして、最新のブロックの先頭を探し、上記の方法でチェーンの同期を開始します。 次に、実行クライアントが追いつくと、ビーコンチェーンのトランザクションの有効性をコンセンサスクライアントに通知します。

[オプティミスティック同期の詳細](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md)

#### チェックポイント同期 {#checkpoint-sync}

チェックポイント同期は、弱い主観性の同期とも呼ばれ、ビーコンノードの同期において優れたユーザーエクスペリエンスを提供します。 これは、ジェネシスではなく、最近の弱い主観性チェックポイントからビーコンチェーンを同期できるようにする[弱い主観性](/developers/docs/consensus-mechanisms/pos/weak-subjectivity/)の前提に基づいています。 チェックポイント同期は、[ジェネシス](/glossary/#genesis-block)からの同期と同様の信頼性の前提を保ちながら、初期同期時間を大幅に短縮します。

実運用では、ノードがリモートサービスに接続して最新のファイナライズされた状態をダウンロードし、その時点からデータの検証を続けます。 データを提供する第三者は信頼されるべき存在であり、慎重に選ぶ必要があります。

[チェックポイント同期](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice)の詳細

## 参考文献 {#further-reading}

- [イーサリアム101 - パート2 - ノードについての理解](https://kauri.io/ethereum-101-part-2-understanding-nodes/48d5098292fd4f11b251d1b1814f0bba/a) _– 2019年2月13日 - Wil Barnes_
- [イーサリアムフルノードの運用: 手間を省きたい人向けのガイド](https://medium.com/@JustinMLeroux/running-ethereum-full-nodes-a-guide-for-the-barely-motivated-a8a13e7a0d31) _2019年11月7日 - Justin Leroux_

## 関連トピック {#related-topics}

- [ブロック](/developers/docs/blocks/)
- [ネットワーク](/developers/docs/networks/)

## 関連チュートリアル {#related-tutorials}

- [MicroSDカードを挿入するだけで、Raspberry Pi 4をバリデータノードにする – インストールガイド](/developers/tutorials/run-node-raspberry-pi/) _– Raspberry Pi 4をフラッシュし、イーサネットケーブルを接続し、SSDディスクを接続して電源を入れることで、Raspberry Pi 4を、実行レイヤー(メインネット)とコンセンサスレイヤー(ビーコンチェーン/バリデータ)の両方もしくは片方を実行するフルイーサリアムノードにする。_
