---
title: "ノードとクライアント"
description: "イーサリアムノードとクライアントソフトの概要、ノードを設定する方法とその必要性"
lang: ja
sidebarDepth: 2
---

イーサリアムは、「ノード」と呼ばれるコンピュータの分散型ネットワークです。ノードで実行されているソフトウェアが、ブロックとトランザクションデータを検証します。 このソフトウェアは、コンピュータをイーサリアムノードにするために、必ず実行する必要があります。 ノードを構成するには、 別々のソフトウェア (「クライアント」と呼ばれる) が2つ必要です。

## 前提条件{#prerequisites}

イーサリアムクライアントの独自のインスタンスを実行し、より深く掘り下げる前に、ピアツーピアネットワークの概念と[EVMの基礎](/developers/docs/evm/)を理解する必要があります。 [イーサリアムの紹介](/developers/docs/intro-to-ethereum/)をご覧ください。

ノードのトピックに慣れていない場合は、まず[イーサリアムノードの実行](/run-a-node)に関するユーザーフレンドリーな紹介をご覧ください。

## ノードとクライアントとは {#what-are-nodes-and-clients}

「ノード」とは、イーサリアムソフトウェアを実行している他のコンピュータと接続されたイーサリアムクライアントソフトウェアの任意のインスタンスであり、ネットワークを形成します。 「クライアント」とは、プロトコルルールに従ってデータを検証し、安全なネットワークを維持するイーサリアムの実装です。 ノードでは、コンセンサスクライアントと実行クライアントの2つのクライアントを実行する必要があります。

- 実行クライアント(ELクライアントや実行エンジンとも呼ばれ、過去の名称はEth1クライアント)は、ネットワークでブロードキャストされた新たなトランザクションを受け取り、EVM(イーサリアム仮想マシン)でトランザクションを実行し、すべての現在のイーサリアムデータの最新の状態とデータベースを保持します。
- コンセンサスクライアント(ビーコンノードやCLクライアントとも呼ばれ、過去の名称はETh2クライアント)は、プルーフ・オブ・ステークのコンセンサスアルゴリズムを実行し、実行クライアントからの検証されたデータに基づき、ネットワークの合意を形成します。 「バリデータ」と呼ばれる3つ目のソフトウェアもあります。バリデータをコンセンサスクライアントに追加することで、ネットワークのセキュリティの確保にノードを参加させることができます。

これらのクライアントは、連携してイーサリアムチェーンのヘッドを追跡し、ユーザーがイーサリアムネットワークとやり取りできるようにします。 複数のソフトウェアが連携して動作するモジュラー設計は、[カプセル化された複雑性](https://vitalik.eth.limo/general/2022/02/28/complexity.html)と呼ばれます。 このアプローチにより、[The Merge](/roadmap/merge)をシームレスに実行しやすくなり、クライアントソフトウェアの保守と開発が容易になり、例えば[レイヤー2エコシステム](/layer-2/)での個々のクライアントの再利用が可能になります。

![結合された実行クライアントとコンセンサスクライアント](./eth1eth2client.png)
結合された実行クライアントとコンセンサスクライアントの簡易図です。

### クライアントの多様性 {#client-diversity}

[実行クライアント](/developers/docs/nodes-and-clients/#execution-clients)と[コンセンサスクライアント](/developers/docs/nodes-and-clients/#consensus-clients)はどちらも、さまざまなチームによって開発された多様なプログラミング言語で存在します。

複数のクライアント実装が、単一のコードベースへの依存を減らし、ネットワークをより強固にします。 理想は、どのクライアントもネットワークの大多数を占めることなく、多様性を実現し、単一障害点を減らすことです。
また、多様な言語を揃えることで、デベロッパーコミュニティがより広範になり、デベロッパーの希望言語で開発できるようになります。

[クライアントの多様性](/developers/docs/nodes-and-clients/client-diversity/)についての詳細はこちら。

これらのクライアント実装は、すべて同じ仕様に従っています。 仕様はイーサリアムネットワークとブロックチェーンの機能や技術的な詳細を定義しており、 下記で確認することができます。

- 元々は、[イーサリアム・イエローペーパー](https://ethereum.github.io/yellowpaper/paper.pdf)
- [実行仕様](https://github.com/ethereum/execution-specs/)
- [コンセンサス仕様](https://github.com/ethereum/consensus-specs)
- さまざまな[ネットワークアップグレード](/ethereum-forks/)で実装された[EIP](https://eips.ethereum.org/)

### ネットワーク内のノードの追跡 {#network-overview}

イーサリアムネットワークのノードの概要をリアルタイムで提供しているトラッカーが複数あります。 しかし、分散型ネットワークの性質上、これらのクローラーはネットワークの一部しか把握できず、異なる結果を報告する可能性があることに注意してください。

- Etherscanによる[ノードのマップ](https://etherscan.io/nodetracker)
- Bitflyによる[Ethernodes](https://ethernodes.org/)
- Chainsafeによる[Nodewatch](https://www.nodewatch.io/)、コンセンサスノードをクロール
- [Monitoreth](https://monitoreth.io/) - MigaLabsによる、分散型ネットワーク監視ツール
- [Weekly Network Health Reports](https://probelab.io) - ProbeLabによる、[Nebula crawler](https://github.com/dennis-tra/nebula)やその他のツールを使用

## ノードのタイプ {#node-types}

[自身のノードを実行](/developers/docs/nodes-and-clients/run-a-node/)したい場合、データを異なる方法で消費するさまざまなタイプのノードがあることを理解する必要があります。 実際に、クライアントが実行できるノードには、ライトノード、フルノード、アーカイブノードの3種類があります。 また、同期時間を短縮する同期戦略のオプションを選ぶこともできます。 同期とは、イーサリアムの状態についての最新情報をどれだけ迅速に取得できるかを意味します。

### フルノード {#full-node}

フルノードは、各ブロックごとのブロックボディーと状態データのダウンロードおよび検証に加え、ブロックチェーンの各ブロックの検証を行います。 フルノードにはさまざまな種類があります。ジェネシスブロックから開始してブロックチェーンの履歴にあるすべてのブロックを1つずつ検証するものや、 その他は、有効であると信頼するより最近のブロックで検証を開始します(例：Gethの「スナップ同期」)。 ディスク領域を節約するため、フルノードは検証の開始位置に関係なく、比較的最近のデータ(通常は直近の128ブロック)のローカルコピーのみを保存し、古いデータを削除できるようにしています。 古いデータは、必要に応じて再生成されます。

- 完全なブロックチェーンデータを保存(ただし、フルノードは定期的にプルーニングされており、最初のジェネシス(誕生)までさかのぼる状態は保存されていない)
- ブロック検証に参加し、すべてのブロックと状態を検証する
- すべての状態は、ローカルストレージから取得するか、フルノードによって「スナップショット」から再生成できます。
- ネットワークに貢献し、リクエストに応じてデータを提供する

### アーカイブノード {#archive-node}

アーカイブノードは、ジェネシスからすべてのブロックを検証し、ダウンロードしたデータを永久に保存するフルノードです。

- フルノードに保存されているすべてを保持し、過去の状態のアーカイブを構築する。 例えば、ブロック4,000,000のアカウント残高をクエリしたい場合や、トレースを使用して検証せずに、簡単にかつ確実に自分のトランザクションセットをテストしたい場合などに必要。
- データがテラバイト単位になるため、平均的なユーザーにとってアーカイブノードは魅力的なものではないが、ブロックエクスプローラー、ウォレットベンダー、チェーン分析などのサービスに有用。

アーカイブ以外の任意のモードでクライアントを同期すると、ブロックチェーンデータがプルーニングされます。 つまり、すべての過去の状態を保存するアーカイブは存在しませんが、フルノードは必要に応じて構築できます。

[アーカイブノード](/developers/docs/nodes-and-clients/archive-nodes)についての詳細はこちら。

### ライトノード {#light-node}

ライトノードは、すべてのブロックをダウンロードする代わりに、ブロックヘッダーのみをダウンロードします。 ブロックヘッダーには、ブロックの内容に関するサマリー情報が含まれています。 ライトノードは、必要に応じて、フルノードからブロックヘッダー以外の情報を取得します。 また、受信したデータをブロックヘッダーの状態ルートに対して個別に検証できます。 ライトノードでは、フルノードを実行するために必要な強力なハードウェアや高帯域幅がなくても、イーサリアムネットワークに参加できます。 最終的には、ライトノードは携帯電話や組み込み機器で動作できるようになる可能性があります。 ライトノードはコンセンサスには参加しません(つまり、バリデーターにはなれません)が、フルノードと同じ機能とセキュリティ保証でイーサリアムブロックチェーンにアクセスできます。

イーサリアムでは、ライトクライアントの開発が活発に行われています。コンセンサスレイヤーと実行レイヤーの新しいライトクライアントが、まもなくリリースされる予定です。
[ゴシップネットワーク](https://www.ethportal.net/)を介してライトクライアントデータを提供する潜在的なルートもあります。 ゴシップネットワークは、フルノードがリクエストに応答することなくライトノードのネットワークをサポートできるため効率的です。

イーサリアムでは現在、ライトノードは多数サポートされていませんが、今後急速に普及していくと考えられています。 特に、[Nimbus](https://nimbus.team/)、[Helios](https://github.com/a16z/helios)、[LodeStar](https://lodestar.chainsafe.io/)のようなクライアントは現在、ライトノードに重点を置いています。

## イーサリアムノードを運用する必要性 {#why-should-i-run-an-ethereum-node}

ノードを実行することで、イーサリアムを直接、トラストレスかつプライベートに利用することができます。また、イーサリアムのネットワークをより強固にし、分散化の促進に貢献することができます。

### あなたにとってのメリット {#benefits-to-you}

自分のノードを実行すると、プライベートで自己完結したトラストレスな形でイーサリアムを利用することができます。 クライアントを使って自分でデータを検証できるので、ネットワークを信頼する必要はありません。 「信頼するな、検証せよ」はブロックチェーンで頻繁に唱えられるマントラです。

- ノードはすべてのトランザクションとブロックをコンセンサスルールに対して検証する。 つまり、ネットワークの他のノードに依存したり、完全に信頼する必要がない。
- 自分のノードでイーサリアムウォレットを使用可能。 仲介業者に自分のアドレスや残高情報を渡す必要がないため、より安全かつプライベートに分散型アプリ(Dapp)を利用できる。 自身のクライアントですべてをチェックできる。 [MetaMask](https://metamask.io)、[Frame](https://frame.sh/)、そして[その他多くのウォレット](/wallets/find-wallet/)はRPCインポートを提供しており、あなたのノードを使用できます。
- イーサリアムからのデータに依存する他のサービスを実行および自分でホスト可能 (例えば、ビーコンチェーンのバリデータ、レイヤー2などのソフトウェア、インフラストラクチャ、ブロックエクスプローラー、ペイメントプロセッサーなど)。
- 独自のカスタム[RPCエンドポイント](/developers/docs/apis/json-rpc/)を提供できます。 このエンドポイントをコミュニティに公開することで、巨大な中央集権型プロバイダーへの依存を減らすことができる。
- \*\*プロセス間通信(IPC)\*\*を使用してノードに接続するか、ノードを書き換えてプログラムをプラグインとして読み込むことができます。 これにより低レイテンシが実現され、例えば、web3ライブラリを使用して大量のデータを処理する場合や、トランザクションをできるだけ早く置き換える必要がある場合(フロントランニングなど)に非常に役立ちます。
- ETHを直接ステーキングでき、ネットワークの安全性に貢献し、同時に報酬を得ることができる。 開始するには[ソロステーキング](/staking/solo/)を参照してください。

![アプリケーションとノードを介してイーサリアムにアクセスする方法](./nodes.png)

### ネットワークのメリット {#network-benefits}

イーサリアムの健全性、セキュリティ、運用レジリエンスにとって、ノードの多様性は重要です。

- フルノードがコンセンサスルールを強制するため、ルールに従わないブロックが受け入れられることはない。 これはネットワークのセキュリティ強化につながる(すべてのノードが完全な検証ができないライトノードの場合では、バリデータがネットワークに対して攻撃できる恐れがあるため)。
- [プルーフ・オブ・ステーク](/developers/docs/consensus-mechanisms/pos/#what-is-pos)の暗号経済的防御を乗り越える攻撃が発生した場合、正直なチェーンに従うことを選択したフルノードによってソーシャルリカバリーを実行できます。
- ネットワークのノード数が増えることで、分散化の究極の目標である多様で堅牢なネットワークとなり、検閲耐性があり、信頼性の高いシステムになる。
- フルノードからのブロックチェーンデータに依存するライトクライアントに、ブロックチェーンデータへのアクセスを提供する。 ライトノードはブロックチェーン全体を保存せず、代わりに[ブロックヘッダー内のステート・ルート](/developers/docs/blocks/#block-anatomy)を介してデータを検証します。 また、必要に応じて、フルノードから追加情報のリクエストを行う。

フルノードを実行すると、バリデータを実行しなくても、イーサリアムネットワーク全体がそのメリットを享受することができます。

## 独自のノードの実行 {#running-your-own-node}

自分のイーサリアムクライアントを運用してみませんか?

初心者向けの紹介については、[ノードを実行](/run-a-node)ページで詳細をご覧ください。

より技術的なユーザーであれば、[独自のノードを立ち上げる](/developers/docs/nodes-and-clients/run-a-node/)方法に関する詳細とオプションを掘り下げてください。

## 代替案 {#alternatives}

自分のノードを設定するには、時間とリソースがかかりますが、必ずしも独自のインスタンスを実行する必要はありません。 サードパーティのAPIプロバイダーを利用すれば負担を軽減できます。 これらのサービスの使用概要については、[サービスとしてのノード](/developers/docs/nodes-and-clients/nodes-as-a-service/)をご覧ください。

コミュニティでパブリックなAPIを持つイーサリアムノードが運用されている場合、カスタムRPCを介してウォレットをコミュニティノードに向けることができ、ランダムなサードパーティを使うよりも、プライバシーを確保することができます。

一方で、自分のクライアントを運用している場合は、必要としている友人とクライアントを共有できます。

## 実行クライアント {#execution-clients}

イーサリアムコミュニティでは、異なるプログラミング言語で、さまざまなチームが開発した、複数のオープンソースの実行クライアント(旧称は「Eth1クライアント」または「イーサリアムクライアント」)を維持しています。 これにより、ネットワークはより強力で[多様](/developers/docs/nodes-and-clients/client-diversity/)になります。 理想は、どのクライアントもネットワークの大部分を占めることなく、多様性を実現し、単一障害点を減らすことです。

この表は、いくつかのクライアントの情報をまとめたものです。 それらはすべて[クライアントテスト](https://github.com/ethereum/tests)に合格しており、ネットワークのアップグレードに合わせて最新の状態を保つために積極的に維持されています。

| クライアント                                                                                      | 言語                      | オペレーティングシステム        | ネットワーク                | 同期戦略                                                               | 状態剪定       |
| ------------------------------------------------------------------------------------------- | ----------------------- | ------------------- | --------------------- | ------------------------------------------------------------------ | ---------- |
| [Geth](https://geth.ethereum.org/)                                                          | Go                      | Linux、Windows、macOS | Mainnet、Sepolia、Hoodi | [スナップ](#snap-sync)、[フル](#full-sync)                                | アーカイブ、プルーン |
| [Nethermind](https://www.nethermind.io/)                                                    | C#、.NET | Linux、Windows、macOS | Mainnet、Sepolia、Hoodi | [スナップ](#snap-sync)(サービングなし)、高速、[フル](#full-sync) | アーカイブ、プルーン |
| [Besu](https://besu.hyperledger.org/en/stable/)                                             | Java                    | Linux、Windows、macOS | Mainnet、Sepolia、Hoodi | [スナップ](#snap-sync)、[高速](#fast-sync)、[フル](#full-sync)               | アーカイブ、プルーン |
| [Erigon](https://github.com/ledgerwatch/erigon)                                             | Go                      | Linux、Windows、macOS | Mainnet、Sepolia、Hoodi | [フル](#full-sync)                                                   | アーカイブ、プルーン |
| [Reth](https://reth.rs/)                                                                    | Rust                    | Linux、Windows、macOS | Mainnet、Sepolia、Hoodi | [フル](#full-sync)                                                   | アーカイブ、プルーン |
| [EthereumJS](https://github.com/ethereumjs/ethereumjs-monorepo) _(ベータ版)_ | TypeScript              | Linux、Windows、macOS | Sepolia、Hoodi         | [フル](#full-sync)                                                   | プルーン       |

サポートされているネットワークの詳細については、[イーサリアムネットワーク](/developers/docs/networks/)をご覧ください。

各クライアントには、それぞれに応じたユースケースとメリットがあります。自分に合ったクライアントを選択してください。 多様性により、さまざまな機能やユーザー層に合わせた実装が可能です。 機能、サポート、プログラミング言語、またはライセンスなどの観点から、クライアントを選択することをお勧めします。

### Besu {#besu}

ハイパーレジャーBesuは、パブリックネットワークと許可型ネットワークの両方に対応する、エンタープライズグレードのイーサリアムクライアントです。 イーサリアムメインネットのすべての機能を実行するクライアントは、ConsenSys社によりサポートされています。トレースからGraphQLまで、幅広いモニタリング機能を備えており、公開コミュニティチャンネルと企業向けの商用SLAの両方に対応しています。 また、Javaで実装されており、Apache 2.0ライセンスです。

Besuの広範な[ドキュメント](https://besu.hyperledger.org/en/stable/)では、その機能と設定に関するすべての詳細が案内されています。

### Erigon {#erigon}

Erigon(旧称: Turbo-Geth)は、Go Ethereumのフォークから派生したものであり、速度とディスク容量の効率を重視しています。 イーサリアムの完全に再設計された実装であり、現在はGoで書かれていますが、他の言語での実装も開発中です。 Erigonは、より高速で、よりモジュール化されており、より最適化されたイーサリアムの実装を目指しています。 2TB程度のディスク容量があれば、3日以内にフルアーカイブノードの同期が可能です。

### Go Ethereum {#geth}

Go Ethereum(略してGeth)は、イーサリアムプロトコルのオリジナルの実装の1つです。 現在、最も普及しているクライアントであり、ユーザーやデベロッパー向けのツールの種類も豊富です。 Go言語で実装されており、完全にオープンソースで、GNU LGPL v3ライセンスの下で提供されています。

Gethの詳細については、その[ドキュメント](https://geth.ethereum.org/docs/)をご覧ください。

### Nethermind {#nethermind}

Nethermindは、C# .NETの技術スタックで開発されたイーサリアムの実装で、LGPL-3.0ライセンスの下で提供されています。ARMを含むすべての主要なプラットフォームに対応しており、 以下のような優れたパフォーマンスを発揮します。

- 最適化された仮想マシン
- 状態アクセス
- ネットワーキングや、Prometheus/Grafanaダッシュボード、Seqエンタープライズロギングサポート、JSON-RPCトレーシング、分析プラグインなどの豊富な機能

Nethermindには[詳細なドキュメント](https://docs.nethermind.io)もあり、強力な開発者サポート、オンラインコミュニティ、プレミアムユーザー向けの24時間365日のサポートが利用可能です。

### Reth {#reth}

Reth (Rust Ethereumの略) は、使いやすさ、高度なモジュール化、速さ、効率性を重視したイーサリアムフルノード実装です。 Rethは元々Paradigmによって開発・推進されており、ApacheおよびMITライセンスの下で提供されています。

Rethは本番環境での利用が可能で、ステーキングや高稼働サービスなどのミッションクリティカルな環境での使用に適しています。 また、RPC、MEV、インデックス作成、シミュレーション、P2P活動など、高いパフォーマンスと大きなマージンが求められるユースケースでも優れた性能を発揮します。

[Reth Book](https://reth.rs/)または[Reth GitHubリポジトリ](https://github.com/paradigmxyz/reth?tab=readme-ov-file#reth)を確認して詳細をご覧ください。

### 開発中 {#execution-in-development}

これらのクライアントはまだ開発の初期段階であるため、今のところ本番環境での使用は推奨されていません。

#### EthereumJS {#ethereumjs}

EthereumJS実行クライアント(EthereumJS)は、TypeScriptで書かれ、いくつかのパッケージで構成されています。ブロック、トランザクション、マークルパトリシアツリークラスで表すコアイーサリアムプリミティブや、イーサリアム仮想マシン(EVM)、ブロックチェーンクラス、DevP2Pネットワークスタックの実装などのコアクライアントコンポーネントを含みます。

その[ドキュメント](https://github.com/ethereumjs/ethereumjs-monorepo/tree/master)を読んで詳細をご覧ください

## コンセンサスクライアント {#consensus-clients}

[コンセンサスのアップグレード](/roadmap/beacon-chain/)をサポートするために、複数のコンセンサスクライアント(以前は「Eth2」クライアントとして知られていました)が存在します。 これらは、フォーク選択アルゴリズム、アテステーションの処理、[プルーフ・オブ・ステーク](/developers/docs/consensus-mechanisms/pos)の報酬とペナルティの管理など、コンセンサス関連のすべてのロジックを担当します。

| クライアント                                                        | 言語         | オペレーティングシステム        | ネットワーク                                      |
| ------------------------------------------------------------- | ---------- | ------------------- | ------------------------------------------- |
| [Lighthouse](https://lighthouse.sigmaprime.io/)               | Rust       | Linux、Windows、macOS | Beacon Chain、Hoodi、Pyrmont、Sepoliaなど        |
| [Lodestar](https://lodestar.chainsafe.io/)                    | TypeScript | Linux、Windows、macOS | Beacon Chain、Hoodi、Sepoliaなど                |
| [Nimbus](https://nimbus.team/)                                | Nim        | Linux、Windows、macOS | Beacon Chain、Hoodi、Sepoliaなど                |
| [Prysm](https://prysm.offchainlabs.com/docs/)                 | Go         | Linux、Windows、macOS | Beacon Chain、Gnosis、Hoodi、Pyrmont、Sepoliaなど |
| [Teku](https://consensys.net/knowledge-base/ethereum-2/teku/) | Java       | Linux、Windows、macOS | Beacon Chain、Gnosis、Hoodi、Sepoliaなど         |
| [Grandine](https://docs.grandine.io/)                         | Rust       | Linux、Windows、macOS | Beacon Chain、Hoodi、Sepoliaなど                |

### Lighthouse {#lighthouse}

Lighthouseは、Apache-2.0ライセンスの下、Rustで書かれたコンセンサスクライアントの実装です。 Sigma Primeによって管理されており、ビーコンチェーン誕生以降、安定したパフォーマンスで稼働しています。 また、さまざまなエンタープライズやステーキングプール、個人からの信頼を得ています。 デスクトップPCから高度な自動デプロイまで、あらゆる環境における安全性、パフォーマンス、相互運用性を目指しています。

ドキュメントは[Lighthouse Book](https://lighthouse-book.sigmaprime.io/)にあります

### Lodestar {#lodestar}

Lodestarは、LGPL-3.0ライセンスの下、Typescriptで書かれた、本番環境に対応したコンセンサスクライアントの実装です。 ChainSafe Systems社によって管理されており、ソロステーカー、デベロッパー、研究者向けのコンセンサスクライアントの中で最も新しいものです。 Loadstarは、イーサリアムプロトコルをJavaScriptで実装した、ビーコンノードとバリデータクライアントから構成されています。 ライトクライアントでのイーサリアムの使いやすさを向上させ、より多くのデベロッパーグループがアクセスできるようにすることで、エコシステムの多様性にさらに貢献することを目指しています。

詳細は[Lodestarウェブサイト](https://lodestar.chainsafe.io/)でご覧いただけます

### Nimbus {#nimbus}

Nimbusは、Apache-2.0ライセンスの下、Nimで書かれたコンセンサスクライアントの実装です。 ソロステーカーやステーキングプールで使用されており、本番環境に対応したクライアントです。 Nimbusはリソース効率を重視して設計されており、リソースに制限のあるデバイスや企業のインフラストラクチャ上でも、安定性や報酬のパフォーマンスを損なわずに簡単に実行できます。 リソース利用量が少ないと、ネットワークに負荷がかかっても、クライアントは安全に動作します。

[Nimbusドキュメント](https://nimbus.guide/)で詳細をご覧ください

### Prysm {#prysm}

Prysmは、GPL-3.0ライセンスの下、Goで書かれたフル機能のオープンソースのコンセンサスクライアントです。 オプションのWebアプリのUIを備え、自宅でステーキングするユーザーと機関ユーザーの両方に向けて、ユーザーエクスペリエンス、ドキュメント、設定可能性を優先しているのが特徴です。

[Prysmドキュメント](https://prysm.offchainlabs.com/docs/)にアクセスして詳細をご覧ください。

### Teku {#teku}

Tekuは、オリジナルのビーコンチェーンで誕生したクライアントの1つです。 セキュリティ、堅牢性、安定性、使いやすさ、パフォーマンスなどの基本的な目標に加えて、Tekuはさまざまなコンセンサスクライアント標準に完全に準拠することを特に重視しています。

Tekuは、非常に柔軟なデプロイメントオプションを提供しています。 ビーコンノードとバリデータクライアントをシングルプロセスとして実行できるので、ソロステーカーにとって非常に便利です。または、高度なステーキング操作を行う場合は、個別にノードを実行することもできます。 さらに、Tekuは署名キーのセキュリティとスラッシング保護のために[Web3Signer](https://github.com/ConsenSys/web3signer/)と完全に相互運用可能です。

Tekuは、Javaで実装されており、Apache 2.0でライセンスされています。 BesuやWeb3Signerを手がけるConsenSys社のプロトコルチームによって開発されています。 [Tekuドキュメント](https://docs.teku.consensys.net/en/latest/)で詳細をご覧ください。

### Grandine {#grandine}

Grandineは、GPL-3.0ライセンスの下、Rustで書かれたコンセンサスクライアントの実装です。 Gradineコアチームによって管理されており、高速・高性能かつ軽量です。 ラズベリーパイのようなリソースの限られたデバイスで動かすソロステーカーから、数万のバリデータを運用する大規模機関のステーカーまで、幅広く対応することができます。

ドキュメントは[Grandine Book](https://docs.grandine.io/)にあります

## 同期モード {#sync-modes}

イーサリアムクライアントがネットワークの現在のデータを追って検証するには、最新のネットワーク状態と同期する必要があります。 そのためには、ピアからデータをダウンロードし、暗号的に完全性を検証した上で、ローカルのブロックチェーンデータベースを構築する必要があります。

同期モードには、さまざまなトレードオフを持つ異なるアプローチがあります。 また、各クライアントによって、同期アルゴリズムの実装が異なります。 そのため、実装の詳細については、必ずクライアントの公式ドキュメントを参照してください。

### 実行レイヤーの同期モード {#execution-layer-sync-modes}

実行レイヤーは、ブロックチェーンのワールドステートを再実行するモードから、信頼できるチェックポイントからチェーンの最新部分にのみ同期するモードまで、さまざまなユースケースに合わせて異なるモードで実行できます。

#### フル同期 {#full-sync}

フル同期では、すべてのブロック (ヘッダーとブロックボディを含む) をダウンロードし、ジェネシスブロックからすべてのブロックを実行することで、ブロックチェーンの状態を段階的に再生成します。

- すべてのトランザクションを検証することにより、信用する必要性を最小限に抑え、最高のセキュリティを提供
- トランザクション数が増えると、全トランザクションを処理するのに数日から数週間かかることがある

[アーカイブノード](#archive-node)はフル同期を実行して、すべてのブロックのすべてのトランザクションによる状態変更の完全な履歴を構築(および保持)します。

#### 高速同期 {#fast-sync}

フル同期と同様に、高速同期もすべてのブロック (ヘッダー、トランザクション、レシートを含む) をダウンロードします。 しかし、高速同期は過去のトランザクションを再処理する代わりに、レシートに依存し、最新のヘッドに到達するとフルノードを提供するためにブロックのインポートと処理に切り替わります。

- 高速同期戦略
- 帯域幅の使用を優先した処理負荷の軽減

#### スナップ同期 {#snap-sync}

スナップ同期もチェーンをブロックごとに検証します。 ただし、ジェネシスブロックからではなく、「信頼できる」最新のチェックポイントから開始します。このチェックポイントは、正しいブロックチェーンの一部であることが確認されています。 ノードは、一定期間を経過したデータを削除しますが、定期的にチェックポイントを保存します。 これらのスナップショットは、データを永続的に保存するのではなく、必要に応じてステートデータを再生成するために使用されます。

- 最速の同期戦略で、現在のイーサリアムメインネットのデフォルトです。
- セキュリティを犠牲にすることなく、多くのディスク使用量とネットワーク帯域幅を節約できます。

[スナップ同期の詳細](https://github.com/ethereum/devp2p/blob/master/caps/snap.md)。

#### ライト同期 {#light-sync}

ライトクライアントモードでは、すべてのブロックヘッダーとブロックデータをダウンロードし、ランダムに検証を行います。 信頼できるチェックポイントからチェーンの先端までのみを同期します。

- デベロッパーへの信頼と合意メカニズムに依存し、最新の状態のみを取得
- クライアントは数分で現在のネットワーク状態で使用できるようになる

**注** ライト同期はまだプルーフ・オブ・ステークのイーサリアムでは機能しません。ライト同期の新しいバージョンはまもなくリリースされる予定です！

[ライトクライアントの詳細](/developers/docs/nodes-and-clients/light-clients/)

### コンセンサスレイヤーの同期モード {#consensus-layer-sync-modes}

#### オプティミスティック同期 {#optimistic-sync}

オプティミスティック同期はマージ後の同期戦略で、オプトインで下位互換性を備えており、実行ノードが確立された方法で同期できます。 実行エンジンは、ビーコンブロックを完全に検証せずに_オプティミスティックに_(楽観的に)インポートし、最新のヘッドを見つけてから、上記の方法でチェーンの同期を開始できます。 次に、実行クライアントが追いつくと、ビーコンチェーンのトランザクションの有効性をコンセンサスクライアントに通知します。

[オプティミスティック同期の詳細](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md)

#### チェックポイント同期 {#checkpoint-sync}

チェックポイント同期は、弱い主観性の同期とも呼ばれ、ビーコンノードの同期において優れたユーザーエクスペリエンスを提供します。 これは[弱い主観性](/developers/docs/consensus-mechanisms/pos/weak-subjectivity/)の仮定に基づいており、ジェネシスからではなく最近の弱い主観性のチェックポイントからビーコンチェーンを同期できます。 チェックポイント同期は、[ジェネシス](/glossary/#genesis-block)からの同期と同様の信頼性の仮定で、初期同期時間を大幅に短縮します。

実運用では、ノードがリモートサービスに接続して最新のファイナライズされた状態をダウンロードし、その時点からデータの検証を続けます。 データを提供する第三者は信頼されるべき存在であり、慎重に選ぶ必要があります。

[チェックポイント同期](https://notes.ethereum.org/@djrtwo/ws-sync-in-practice)の詳細

## 参考リンク{#further-reading}

- [イーサリアム 101 - パート 2 - ノードを理解する](https://kauri.io/ethereum-101-part-2-understanding-nodes/48d5098292fd4f11b251d1b1814f0bba/a) _– Wil Barnes、2019年2月13日_
- [イーサリアムフルノードの実行：やる気のない人向けガイド](https://medium.com/@JustinMLeroux/running-ethereum-full-nodes-a-guide-for-the-barely-motivated-a8a13e7a0d31) _– Justin Leroux、2019年11月7日_

## 関連トピック{#related-topics}

- [ブロック](/developers/docs/blocks/)
- [ネットワーク](/developers/docs/networks/)

## 関連チュートリアル {#related-tutorials}

- [MicroSDカードを書き込むだけでRaspberry Pi 4をバリデーターノードに変える – インストールガイド](/developers/tutorials/run-node-raspberry-pi/) _– Raspberry Pi 4を書き込み、イーサネットケーブルを差し込み、SSDディスクを接続して電源を入れることで、Raspberry Pi 4を、実行レイヤー(メインネット)および/またはコンセンサスレイヤー(ビーコンチェーン/バリデーター)を実行する完全なイーサリアムノードに変えることができます。_
