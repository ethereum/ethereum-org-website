---
title: ネットワークレイヤー
description: イーサリアムネットワークレイヤー入門
lang: ja
sidebarDepth: 2
---

イーサリアムは、何千ものノードからなるピアツーピアネットワークですが、標準プロトコルを使用して、複数のノード間で直接的に相互に通信できる必要があります。 「ネットワークレイヤー」とは、これらのノードが互いを見つけて情報を交換可能とする為のプロトコルが集まったものです。 イーサリアムのネットワークレイヤーには、特定のノード間でのリクエストとレスポンスの交換(1 対 1 の通信)だけでなく、ネットワーク上での情報の「ゴシップ」(1 対多の通信)も含まれます。 各ノードは、正しい情報を送受信するために、特定のネットワークルールを遵守する必要があります。

クライアントソフトウェアには 2 つの部分(実行クライアントとコンセンサスクライアント)があり、それぞれ独自のネットワークスタックを備えています。 他のイーサリアムノードと通信するだけでなく、実行クライアントとコンセンサスクライアントは互いに通信する必要があります。 このページでは、初心者向けに、この通信を可能にするプロトコルを説明をします。

実行クライアントは、実行レイヤーのピアツーピアネットワーク上でトランザクションをゴシップします。 これには、認証されたピア同士の暗号化通信が必要です。 ブロックを提案するバリデータが選ばれると、そのノードのローカルトランザクションプールからトランザクションがローカル RPC 接続を介してコンセンサスクライアントに渡され、ビーコンブロックにパッケージ化されます。 コンセンサスクライアントはその後、ピアツーピアネットワーク上でビーコンブロックをゴシップします。 これは 2 つの別々のピアツーピアネットワークを必要とします。1 つはトランザクションゴシップのための実行クライアントを接続するもので、もう 1 つはブロックゴシップのためのコンセンサスクライアントを接続するものです。

## 前提知識 {#prerequisites}

このページを理解する上で、あらかじめ、イーサリアム [ノードとクライアント](/developers/docs/nodes-and-clients/) についてある程度理解を深めておくと良いでしょう。

## 実行レイヤー {#execution-layer}

実行レイヤーのネットワークプロトコルは、2 つのスタックに分割されています:

- ディスカバリースタック: UDP 上に構築され、新しいノードがピアに接続できるようにする

- DevP2P スタック：TCP 上に構築され、ノードが情報交換できるようにする

両スタックは、並列的に動作します。 ディスカバリースタックは新しいネットワーク参加者をネットワークに送り込み、DevP2P スタックによって相互通信が可能になります。

### ディスカバリー(Discovery) {#discovery}

ディスカバリーとは、ネットワークの他のノードを見つけるプロセスです。 これは、小規模なブートノード(クライアントをすぐに見つけピアに接続できるように、アドレスがクライアントに [ハードコードされている](https://github.com/ethereum/go-ethereum/blob/master/params/bootnodes.go)ノード)を使用してブートストラップされています。 これらのブートノードは、新しいノードをピアのセットに追加するためにのみ存在します。これが唯一の目的で、チェーンの同期などの通常のクライアントタスクには参加せず、クライアントが初回起動した時にのみ使用されます。

ノードとブートノードとのやり取りに使用されるプロトコルは、[Kademlia](https://medium.com/coinmonks/a-brief-overview-of-kademlia-and-its-use-in-various-decentralized-platforms-da08a7f72b8f)が修正された形式です。これは、[分散ハッシュテーブル](https://en.wikipedia.org/wiki/Distributed_hash_table)を使用してノードのリストを共有します。 各ノードには、最も近いピアに接続するために必要な情報を含む、分散ハッシュテーブルのバージョンがあります。 この「近さ」とは地理的なものではありません。ここでの距離はノードの ID の類似性によって定義されるものです。 各ノードのテーブルは、セキュリティ機能として定期的に更新されます。 例えば、 [Discv5](https://github.com/ethereum/devp2p/tree/master/discv5)では、ディスカバリープロトコルのノードは、クライアントがサポートするサブプロトコルを表示する「広告」を送信することもでき、ピアは両者が通信に使用できるプロトコルについて取り決めることができます。

ディスカバリーは、PING-PONG から始まります。 ピンポンが成功すると、新しいノードはブートノードに「結合」されます。 ネットワークに入る新しいノードの存在をブートノードに通知する最初のメッセージは `PING` です。 この`PING`には、新しいノード、ブートノード、および期限切れのタイムスタンプに関するハッシュ化された情報が含まれています。 ブートノードは`PING`を受信し、 `PING` のハッシュを含む`PONG`を返します。 `PING`と`PONG`のハッシュが一致すると、新しいノードとブートノードの接続が確認され、「結合」されたと言うことになります。

一度結合されると、新しいノードはブートノードに`FIND-NEIGHBOURS`リクエストを送信できるようになります。 ブートノードから返されるデータには、新しいノードが接続できるピアのリストが含まれています。 ノードが結合されていない場合、`FIND-NEIGHBOURS`リクエストは失敗となるため、新しいノードはネットワークに入ることができません。

新しいノードは、ブートノードから近隣ノードのリストを受け取ると、それぞれのノードと PING-PONG を開始します。 PING-PONG が成功すると、新しいノードとその隣接ノードが結合され、メッセージの交換が可能になります。

```
start client --> connect to bootnode --> bond to bootnode --> find neighbours --> bond to neighbours
```

実行クライアントは、現在[Discv4](https://github.com/ethereum/devp2p/blob/master/discv4.md)ディスカバリープロトコルを使っています。[Discv5](https://github.com/ethereum/devp2p/tree/master/discv5)プロトコルに移行するための積極的に取り組んでいます。

#### ENR: イーサリアムノードレコード(Ethereum Node Record) {#enr}

[イーサリアムノードレコード (ENR)](/developers/docs/networking-layer/network-addresses/) とは、署名(合意された 認証スキームに従って作成されたレコード内容のハッシュ)、レコードへの変更を追跡するシーケンス番号、およびキーと値のペアの任意のリストという 3 つの基本要素を含むオブジェクトのことです。 これは、新しいピア間で識別情報の交換を容易にする、将来性のあるフォーマットで、イーサリアムノードの[ネットワークアドレス](/developers/docs/networking-layer/network-addresses)の優先フォーマットです。

#### ディスカバリーが UDP で構築されている理由 {#why-udp}

UDP はエラーチェック、失敗したパケットの再送、接続の動的な開閉をサポートしません。UDP は、受信に成功したかどうかにかかわらず、単にターゲットに対して連続的な情報ストリームを送信するだけです。 こうした最小限の機能により、オーバーヘッドも最小限に抑えられ、接続は非常に高速になります。 ノードが単に自分の存在を知らせ、相手との正式な接続を確立するためのディスカバリーにとっては、UDP で十分に要件を満たすことができます。 しかし、ディスカバリー以外の残りのネットワークスタックにとっては、UDP では目的を満たすことはできません。 ノード間の情報交換は非常に複雑であるため、再送信やエラーチェックなどに対応できる、より高機能なプロトコルが必要です。 TCP に付随する追加のオーバーヘッドは、まさにこうした追加機能として必要な要件を満たしています。 したがって、P2P スタックの大部分は TCP で動作することになります。

### DevP2P {#devp2p}

DevP2P は、それ自体がピアツーピアネットワークの確立と維持するためにイーサリアムが実装しているプロトコルのスタックをすべてを包括しています。 新しいノードがネットワークに参加した後、その相互通信は[DevP2P](https://github.com/ethereum/devp2p)スタックのプロトコルによって制御されます。 これらはすべて TCP 上にあり、RLPx トランスポートプロトコル、ワイヤプロトコル、およびいくつかのサブプロトコルが含まれています。 [RLPx](https://github.com/ethereum/devp2p/blob/master/rlpx.md)は、ノード間のセッションを開始、認証、維持するためのプロトコルです。 RLPx はデータをノード間で送信するための最小限の構造にエンコードする非常にスペース効率の良い RLP (再帰的な長さのプレフィックス)を使ってメッセージをエンコードします。

2 つのノード間の RLPx セッションは、最初の暗号化ハンドシェイクで始まります。 このプロセスには、ノードが auth メッセージを送信し、ピアによって検証されることが含まれます。 検証に成功すると、ピアは auth-acknowledgement メッセージを生成し、イニシエーター・ノードに返します。 これは、ノードが非公開で安全に通信できるようにするための鍵交換プロセスです。 暗号化ハンドシェイクが成功すると、両ノードに「Hello」メッセージを互いに「ワイヤ上」で送信するようにトリガーします。 Hello メッセージの交換に成功すると、ワイヤプロトコルが開始されます。

Hello メッセージには以下が含まれます。

- プロトコルバージョン
- クライアント ID
- ポート
- ノード ID
- サポートされるサブプロトコルのリスト

これらは両ノード間で相互作用を成功させるために、共有される機能を定義し、通信を構成するのに必要な情報です。 各ノードがサポートするサブプロトコルのリストを比較し、両ノードに共通するものをセッションで使用できるようにするサブプロトコルネゴシエーションというプロセスがあります。

ワイヤプロトコルは、Hello メッセージとともに、接続が終了することを相手に警告する「切断」メッセージも送信することができます。 ワイヤプロトコルは、セッションを開いたままにするために定期的に送信される PING と PONG メッセージも含んでいます。 したがって、RLPx とワイヤプロトコルの交換は、ノード間の通信の基礎を確立し、特定のサブプロトコルに従って交換される有用な情報のための土台を提供します。

### サブプロトコル {#sub-protocols}

#### ワイヤプロトコル {#wire-protocol}

ピアが接続され、RLPx セッションが開始されると、ワイヤプロトコルはピアがどのように通信するかを定義します。 当初、ワイヤプロトコルは、チェーンの同期、ブロックの伝搬、トランザクションの交換という 3 つの主要なタスクを定義していました。 しかし、イーサリアムがプルーフ・オブ・ステーク(PoS)に移行すると、ブロック伝搬とチェーン同期はコンセンサスレイヤーの一部となりました。 トランザクションの交換は、依然として実行クライアントの範疇にあります。 トランザクションの交換とは、保留中のトランザクションをノード間で交換し、マイナーがその一部を次のブロックに含めるために選択できるようにすることです。 これらのタスクの詳細については、[こちら](https://github.com/ethereum/devp2p/blob/master/caps/eth.md)をご覧ください。 これらのサブプロトコルをサポートするクライアントは、[JSON-RPC](/developers/docs/apis/json-rpc/)を介してそれらを公開します。

#### ライト・イーサリアム・サブプロトコル(les) {#les}

これは、ライトクライアントの同期用の最小限のプロトコルです。 フルノードはインセンティブなしにライトクライアントにデータを提供する必要があるため、従来このプロトコルはほとんど使用されてきませんでした。 実行クライアントのデフォルトの動作は、les でライトクライアントのデータを提供しないようになっています。 詳細については、les [仕様](https://github.com/ethereum/devp2p/blob/master/caps/les.md)をご確認ください。

#### スナップ(Snap) {#snap}

[スナッププロトコル](https://github.com/ethereum/devp2p/blob/master/caps/snap.md#ethereum-snapshot-protocol-snap)は、ピアが最近の状態のスナップショットを交換できるようにするオプションの拡張機能で、ピアがマークルツリーの中間ノードをダウンロードせずにアカウントとストレージデータを検証できるようにするものです。

#### ウィットネスプロトコル(Wit) {#wit}

[ウィットネスプロトコル](https://github.com/ethereum/devp2p/blob/master/caps/wit.md#ethereum-witness-protocol-wit) は、ピア間で状態のウィットネスを交換できるようにするオプションの拡張機能で、クライアントをチェーンの先頭に同期させるのに役立ちます。

#### ウィスパー(Whisper) {#whisper}

ウィスパーは、ブロックチェーンに情報を書き込むことなくピア間で安全なメッセージングを提供することを目的としたプロトコルです。 DevP2P ワイヤープロトコルの一部でしたが、現在は非推奨となっています。 他にも同様の目的を持つ[関連プロジェクト](https://wakunetwork.com/)があります。

## コンセンサスレイヤー(consensus layer) {#consensus-layer}

コンセンサスクライアントは、仕様が異なる別のピアツーピアネットワークに参加します。 コンセンサスクライアントは、ピアから新しいブロックを受け取り、自分がブロックを提案する番が来たらブロードキャストできるよう、ブロック・ゴシップに参加する必要があります。 実行レイヤーと同様に、ノードがピアを見つけてブロックや認証などを取引するための安全なセッションを確立できるよう、まずディスカバリー・プロトコルが必要です。

### ディスカバリ {#consensus-discovery}

実行クライアントと同様に、コンセンサスクライアントもピアを見つけるために UDP 上の [discv5](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#the-discovery-domain-discv5) を使用します。 コンセンサスレイヤーの discv5 の実装は、discv5 を[libP2P](https://libp2p.io/)スタックに接続するアダプターを含んでおり、DevP2P を非推奨としている点のみ、実行クライアントの実装と異なります。 実行レイヤーの RLPx セッションは廃止され、libP2P のノイズセキュアチャネル・ハンドシェイクが採用されています。

### ENR {#consensus-enr}

コンセンサスノードの ENR には、ノードの公開鍵、IP アドレス、UDP および TCP ポート、コンセンサス特有の 2 つのフィールド(認証サブネットビットフィールドと`eth2`)が含まれます。 前者は、ノードが特定の認証ゴシップ・サブネットワークに参加しているピアを見つけやすくします。 `eth2`キーには、ノードが使用しているイーサリアムフォークのバージョンに関する情報が含まれており、ピアが正しいイーサリアムに接続していることを確認できます。

### libP2P {#libp2p}

libP2P スタックは、ディスカバリー後のすべての通信をサポートします。 クライアントは、ENR で定義された IPv4 および/または IPv6 でダイヤルおよびリッスンできます。 libP2P レイヤーのプロトコルは、ゴシップとリクエスト/レスポンスのドメインに細分化されます。

### ゴシップ(Gossip) {#gossip}

ゴシップドメインは、ネットワーク全体に直ぐに広まる必要のあるすべての情報を含みます。 これには、ビーコンブロック、証明、アテステーション、イグジット、スラッシングが含まれます。 これは libP2P ゴシップサブ v1 を使って送信され、受信・送信するゴシップペイロードの最大サイズなどの各ノードにローカルに保存されている様々なメタデータに依存します。 ゴシップドメインに関する詳細な情報は、[こちら](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#the-gossip-domain-gossipsub)をご覧ください。

### リクエスト/レスポンス(Request-response) {#request-response}

リクエスト/レスポンス・ドメインには、クライアントがピアに特定の情報を要求するためのプロトコルが含まれます。 例えば、あるルートハッシュに一致する特定のビーコンブロックや、スロット範囲内のビーコンブロックのリクエストなどがあります。 レスポンスは常に snappy(圧縮アルゴリズムの一つ)圧縮された SSZ エンコードバイトとして返されます。

## コンセンサスクライアントで RLP より SSZ が好まれる理由 {#ssz-vs-rlp}

SSZ は、シンプル・シリアライゼーションの略です。 SSZ は、固定オフセットを使うことで、構造全体をデコードすることなく、エンコードされたメッセージの個々の部分を簡単にデコードすることができます。これは、エンコードされたメッセージから特定の情報を効率的に取得できるため、コンセンサスクライアントにとって非常に便利な機能です。 また、マークルプロトコルと統合するように特別に設計されており、マークル化に関連した効率化も得られます。 コンセンサスレイヤーのハッシュはすべてマークルルートであるため、これは大きな改善となります。 また、SSZ は値の一意性も保証します。

## 実行クライアントとコンセンサスクライアントの接続 {#connecting-clients}

コンセンサスクライアントと実行クライアントは、並列に動作します。 コンセンサスクライアントが実行クライアントに指示を出し、実行クライアントがコンセンサスクライアントにトランザクション・バンドルを渡してビーコンブロックに含めることができるように、両者は接続されている必要があります。 両クライアント間の通信は、ローカル RPC 接続を使用して実現することができます。 [「エンジン API」](https://github.com/ethereum/execution-apis/blob/main/src/engine/common.md) と呼ばれる API が、両クライアント間で送信される命令を定義します。 両クライアントは単一のネットワーク ID の背後に位置するため、各クライアントの個別のキー(eth1 キーと eth2 キー)を含む ENR(イーサリアムノードレコード)を共有します。

制御フローの概要を以下に示します。括弧内は関連するネットワークスタックです。

### コンセンサスクライアントがブロック生成者でない場合:

- コンセンサスクライアントがブロック・ゴシップ・プロトコル(コンセンサス p2p)を介してブロックを受信する
- コンセンサスクライアントはブロックを事前に検証し、確正しいメタデータを持つ有効な送信者からのものであることを確実にする
- ブロックのトランザクションが実行ペイロードとして実行レイヤーに送信される(ローカル RPC 接続)
- 実行レイヤーはトランザクションを実行し、ブロックヘッダーの状態を検証する(ハッシュ値の一致をチェックする)
- 実行レイヤーは検証データをコンセンサスレイヤーに返し、ブロックは検証済みとみなされる(ローカル RPC 接続)
- コンセンサスレイヤーはブロックを自分のブロックチェーンの先頭に追加して証明し、そのアテステーション(証明)をネットワーク上にブロードキャストする(コンセンサス p2p)

### コンセンサスクライアントがブロック生成者の場合:

- コンセンサスクライアントが次のブロック生成者であることを通知される(consensus p2p)
- コンセンサスレイヤーが実行クライアントの`create block`メソッドを呼び出す(ローカル RPC)
- 実行レイヤーは、トランザクション・ゴシップ・プロトコルによって生成されたトランザクション・メンプールにアクセスする(実行 p2p)
- 実行クライアントはトランザクションをブロックにまとめ、トランザクションを実行し、ブロックハッシュを生成する
- コンセンサスクライアントは実行クライアントからトランザクションとブロックハッシュを取得し、ビーコンブロックに追加する(ローカル RPC)
- コンセンサスクライアントは、ブロック・ゴシップ・プロトコルでブロックをブロードキャストする(コンセンサス p2p)
- 他のクライアントが、ブロック・ゴシップ・プロトコルで提案されたブロックを受信し、上記のように検証する(コンセンサス p2p)

十分な数のバリデータによってブロックが認証されると、チェーンの先頭に追加され、正当性が確認された後、最終的に確定(ファイナライズ)される。

![](cons_client_net_layer.png) ![](exe_client_net_layer.png)

コンセンサスクライアントと実行クライアントのネットワークレイヤー概略図( [ethresear.ch](https://ethresear.ch/t/eth1-eth2-client-relationship/7248) より)

## 参考文献 {#further-reading}

[DevP2P](https://github.com/ethereum/devp2p) [LibP2p](https://github.com/libp2p/specs) [コンセンサスレイヤーネットワークの仕様](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.md#enr-structure) カデムリアから discv5[discv5](https://vac.dev/kademlia-to-discv5) [カデムリアペーパー](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf) [Ethereum ピアツーピア入門](https://p2p.paris/en/talks/intro-ethereum-networking/) [eth1eth2 の関係](http://ethresear.ch/t/eth1-eth2-client-relationship/7248) [マージと eth2 クライアントの詳細に関するビデオ](https://www.youtube.com/watch?v=zNIrIninMgg)
