---
title: "সরল সিরিয়ালাইজ"
description: "ইথেরিয়াম-এর SSZ ফরম্যাটের ব্যাখ্যা।"
lang: bn
sidebarDepth: 2
---

**সরল সিরিয়ালাইজ (SSZ)** হল বিকন চেইন-এ ব্যবহৃত সিরিয়ালাইজেশন পদ্ধতি। এটি এক্সিকিউশন লেয়ার-এ ব্যবহৃত RLP সিরিয়ালাইজেশনকে পিয়ার ডিসকভারি প্রোটোকল ছাড়া কনসেন্সাস লেয়ার-এর সর্বত্র প্রতিস্থাপন করে। RLP সিরিয়ালাইজেশন সম্পর্কে আরও জানতে, দেখুন [রিকার্সিভ-লেংথ প্রিফিক্স (RLP)](/developers/docs/data-structures-and-encoding/rlp/)। SSZ ডিটারমিনিস্টিক হওয়ার জন্য এবং দক্ষতার সাথে Merkleize করার জন্য ডিজাইন করা হয়েছে। SSZ-কে দুটি উপাদান আছে বলে ভাবা যেতে পারে: একটি সিরিয়ালাইজেশন স্কিম এবং একটি Merkleization স্কিম যা সিরিয়ালাইজড ডেটা স্ট্রাকচার-এর সাথে দক্ষতার সাথে কাজ করার জন্য ডিজাইন করা হয়েছে।

## SSZ কিভাবে কাজ করে? {#how-does-ssz-work}

### সিরিয়ালাইজেশন {#serialization}

SSZ একটি সিরিয়ালাইজেশন স্কিম যা স্ব-বর্ণনামূলক নয় - বরং এটি একটি স্কিমার উপর নির্ভর করে যা আগে থেকে জানা আবশ্যক। SSZ সিরিয়ালাইজেশন-এর লক্ষ্য হল নির্বিচারে জটিলতার বস্তুগুলোকে বাইটের স্ট্রিং হিসাবে উপস্থাপন করা। এটি "বেসিক টাইপ"-এর জন্য একটি খুব সহজ প্রক্রিয়া। এলিমেন্টটি কেবল হেক্সাডেসিমেল বাইটে রূপান্তরিত হয়। বেসিক টাইপের মধ্যে রয়েছে:

- আনসাইন্ড ইন্টিজার
- বুলিয়ান

জটিল "কম্পোজিট" টাইপের জন্য, সিরিয়ালাইজেশন আরও জটিল কারণ কম্পোজিট টাইপের মধ্যে একাধিক এলিমেন্ট থাকে যার বিভিন্ন টাইপ বা বিভিন্ন আকার বা উভয়ই থাকতে পারে। যেখানে এই সমস্ত অবজেক্টগুলির একটি নির্দিষ্ট দৈর্ঘ্য থাকে (অর্থাৎ, এলিমেন্টগুলির আকার তাদের প্রকৃত মান নির্বিশেষে সর্বদা ধ্রুবক থাকে), সেখানে সিরিয়ালাইজেশন হল কম্পোজিট টাইপের প্রতিটি এলিমেন্টকে ছোট-এন্ডিয়ান বাইটস্ট্রিং-এ রূপান্তরিত করা। এই বাইটস্ট্রিংগুলো একসাথে যুক্ত করা হয়। সিরিয়ালাইজড অবজেক্টটিতে ডিসিরিয়ালাইজড অবজেক্টে যেভাবে নির্দিষ্ট-দৈর্ঘ্যের এলিমেন্টগুলি উপস্থিত থাকে সেই একই ক্রমে তাদের বাইটলিস্ট রিপ্রেজেন্টেশন থাকে।

পরিবর্তনশীল দৈর্ঘ্যের টাইপের জন্য, আসল ডেটাটি সিরিয়ালাইজড অবজেক্টে সেই এলিমেন্টের অবস্থানে একটি "অফসেট" মান দ্বারা প্রতিস্থাপিত হয়। আসল ডেটা সিরিয়ালাইজড অবজেক্টের শেষে একটি হিপে যুক্ত করা হয়। অফসেট মানটি হল হিপে আসল ডেটার শুরুর জন্য ইনডেক্স, যা প্রাসঙ্গিক বাইটের জন্য একটি পয়েন্টার হিসাবে কাজ করে।

নীচের উদাহরণটি নির্দিষ্ট এবং পরিবর্তনশীল দৈর্ঘ্যের উভয় এলিমেন্ট সহ একটি কন্টেইনারের জন্য অফসেটিং কীভাবে কাজ করে তা ব্যাখ্যা করে:

```Rust

    struct Dummy {

        number1: u64,
        number2: u64,
        vector: Vec<u8>,
        number3: u64
    }

    dummy = Dummy{

        number1: 37,
        number2: 55,
        vector: vec![1,2,3,4],
        number3: 22,
    }

    serialized = ssz.serialize(dummy)

```

`serialized`-এর নিম্নলিখিত কাঠামো থাকবে (এখানে শুধুমাত্র 4 বিটে প্যাড করা হয়েছে, বাস্তবে 32 বিটে প্যাড করা হয়েছে এবং স্পষ্টতার জন্য `int` উপস্থাপনা রাখা হয়েছে):

```
[37, 0, 0, 0, 55, 0, 0, 0, 16, 0, 0, 0, 22, 0, 0, 0, 1, 2, 3, 4]
------------  -----------  -----------  -----------  ----------
      |             |            |           |            |
   নম্বর1         নম্বর2       ভেক্টরের      নম্বর 3    ভেক্টরের
                            জন্য অফসেট                জন্য মান

```

স্বচ্ছতার জন্য লাইনে বিভক্ত করা হয়েছে:

```
[
  37, 0, 0, 0,  # `number1`-এর লিটল-এন্ডিয়ান এনকোডিং।
  55, 0, 0, 0,  # `number2`-এর লিটল-এন্ডিয়ান এনকোডিং।
  16, 0, 0, 0,  # "অফসেট" যা নির্দেশ করে `vector`-এর মান কোথায় শুরু হয় (লিটল-এন্ডিয়ান 16)।
  22, 0, 0, 0,  # `number3`-এর লিটল-এন্ডিয়ান এনকোডিং।
  1, 2, 3, 4,   # `vector`-এর আসল মান।
]
```

এটি এখনও একটি সরলীকরণ - উপরের পরিকল্পিত চিত্রগুলিতে পূর্ণসংখ্যা এবং শূন্যগুলি আসলে বাইটলিস্ট হিসাবে সংরক্ষণ করা হবে, এইভাবে:

```
[
  10100101000000000000000000000000  # `number1`-এর লিটল-এন্ডিয়ান এনকোডিং
  10110111000000000000000000000000  # `number2`-এর লিটল-এন্ডিয়ান এনকোডিং।
  10010000000000000000000000000000  # "অফসেট" যা নির্দেশ করে `vector`-এর মান কোথায় শুরু হয় (লিটল-এন্ডিয়ান 16)।
  10010110000000000000000000000000  # `number3`-এর লিটল-এন্ডিয়ান এনকোডিং।
  10000001100000101000001110000100   # `bytes` ফিল্ডের আসল মান।
]
```

সুতরাং পরিবর্তনশীল-দৈর্ঘ্যের টাইপের জন্য আসল মানগুলি সিরিয়ালাইজড অবজেক্টের শেষে একটি হিপ-এ সংরক্ষণ করা হয়, এবং তাদের অফসেটগুলি ফিল্ডের ক্রমबद्ध তালিকায় তাদের সঠিক অবস্থানে সংরক্ষণ করা হয়।

এছাড়াও কিছু বিশেষ ক্ষেত্র রয়েছে যার জন্য নির্দিষ্ট আচরণের প্রয়োজন হয়, যেমন `BitList` টাইপ যার জন্য সিরিয়ালাইজেশনের সময় একটি দৈর্ঘ্যের ক্যাপ যোগ করতে হয় এবং ডিসিরিয়ালাইজেশনের সময় অপসারণ করতে হয়। [SSZ স্পেক](https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md)-এ সম্পূর্ণ বিবরণ উপলব্ধ আছে।

### ডিসিরিয়ালাইজেশন {#deserialization}

এই অবজেক্টটিকে ডিসিরিয়ালাইজ করতে <b>স্কিমা</b> প্রয়োজন। স্কিমাটি সিরিয়ালাইজড ডেটার সুনির্দিষ্ট বিন্যাসকে সংজ্ঞায়িত করে যাতে প্রতিটি নির্দিষ্ট এলিমেন্ট বাইটের একটি ব্লব থেকে সঠিক টাইপ, মান, আকার এবং অবস্থান সহ কিছু অর্থপূর্ণ অবজেক্টে ডিসিরিয়ালাইজ করা যায়। স্কিমাটিই ডিসিরিয়ালাইজারকে বলে যে কোন মানগুলি আসল মান এবং কোনটি অফসেট। একটি অবজেক্ট সিরিয়ালাইজ করা হলে সমস্ত ফিল্ডের নাম অদৃশ্য হয়ে যায়, কিন্তু স্কিমা অনুসারে ডিসিরিয়ালাইজেশনের সময় পুনরায় ইনস্ট্যানশিয়েট করা হয়।

এটির উপর একটি ইন্টারেক্টিভ ব্যাখ্যার জন্য [ssz.dev](https://www.ssz.dev/overview) দেখুন।

## মার্কেলাইজেশন {#merkleization}

এই SSZ সিরিয়ালাইজড অবজেক্টটি তারপর মার্কেলাইজ করা যেতে পারে - অর্থাৎ একই ডেটার একটি মার্কল-ট্রি উপস্থাপনায় রূপান্তরিত করা যেতে পারে। প্রথমে, সিরিয়ালাইজড অবজেক্টে 32-বাইট চাঙ্কের সংখ্যা নির্ধারণ করা হয়। এগুলি গাছের "লিফ"। লিফের মোট সংখ্যা অবশ্যই 2-এর ঘাত হতে হবে যাতে লিফগুলিকে একসাথে হ্যাস করে অবশেষে একটি একক হ্যাস-ট্রি-রুট তৈরি হয়। যদি স্বাভাবিকভাবে এটি না হয়, তাহলে শূন্যের 32 বাইট ধারণকারী অতিরিক্ত লিফ যোগ করা হয়। ডায়াগ্রামের মাধ্যমে:

```
        হ্যাস ট্রি রুট
            /     \
           /       \
          /         \
         /           \
   লিফ ১ এবং ২    লিফ ৩ এবং ৪
      এর হ্যাস          এর হ্যাস
      /   \            /  \
     /     \          /    \
    /       \        /      \
 লিফ১     লিফ২    লিফ৩     লিফ৪
```

এমন কিছু ক্ষেত্রও রয়েছে যেখানে গাছের লিফগুলি স্বাভাবিকভাবে উপরের উদাহরণের মতো সমানভাবে বন্টিত হয় না। উদাহরণস্বরূপ, লিফ 4 একাধিক এলিমেন্ট সহ একটি কন্টেইনার হতে পারে যার জন্য মার্কল ট্রিতে অতিরিক্ত "গভীরতা" যোগ করার প্রয়োজন হয়, যা একটি অসম ট্রি তৈরি করে।

এই ট্রি এলিমেন্টগুলিকে লিফ X, নোড X ইত্যাদি হিসাবে উল্লেখ করার পরিবর্তে, আমরা তাদের সাধারণীকৃত সূচক দিতে পারি, রুট = 1 থেকে শুরু করে এবং প্রতিটি স্তর বরাবর বাম থেকে ডানে গণনা করে। এটি উপরে ব্যাখ্যা করা সাধারণীকৃত সূচক। সিরিয়ালাইজড তালিকার প্রতিটি এলিমেন্টের একটি সাধারণীকৃত সূচক রয়েছে যা `2**depth + idx`-এর সমান, যেখানে idx হল সিরিয়ালাইজড অবজেক্টে এর শূন্য-সূচিত অবস্থান এবং ডেপথ হল মার্কল ট্রিতে স্তরের সংখ্যা, যা এলিমেন্টের সংখ্যার (লিফ) বেস-টু লগারিদম হিসাবে নির্ধারণ করা যেতে পারে।

## সাধারণীকৃত সূচক {#generalized-indices}

একটি সাধারণীকৃত সূচক হল একটি পূর্ণসংখ্যা যা একটি বাইনারি মার্কল ট্রিতে একটি নোডকে প্রতিনিধিত্ব করে যেখানে প্রতিটি নোডের একটি সাধারণীকৃত সূচক `2 ** depth + index in row` থাকে।

```
        1           --ডেপথ = 0  2**0 + 0 = 1
    2       3       --ডেপথ = 1  2**1 + 0 = 2, 2**1+1 = 3
  4   5   6   7     --ডেপথ = 2  2**2 + 0 = 4, 2**2 + 1 = 5...

```

এই উপস্থাপনাটি মার্কল ট্রিতে ডেটার প্রতিটি অংশের জন্য একটি নোড সূচক প্রদান করে।

## মাল্টিপ্রুফস {#multiproofs}

একটি নির্দিষ্ট এলিমেন্টকে প্রতিনিধিত্বকারী সাধারণীকৃত সূচকের তালিকা প্রদান করা আমাদেরকে হ্যাস-ট্রি-রুটের বিরুদ্ধে এটি যাচাই করার সুযোগ দেয়। এই রুটটি আমাদের বাস্তবতার স্বীকৃত সংস্করণ। আমাদেরকে প্রদত্ত যেকোনো ডেটা সেই বাস্তবতার বিরুদ্ধে মার্কল ট্রিতে সঠিক স্থানে (তার সাধারণীকৃত সূচক দ্বারা নির্ধারিত) প্রবেশ করিয়ে এবং রুটটি স্থির থাকে তা পর্যবেক্ষণ করে যাচাই করা যেতে পারে। স্পেকে [এখানে](https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs) এমন ফাংশন রয়েছে যা একটি নির্দিষ্ট সাধারণীকৃত সূচকের সেটের বিষয়বস্তু যাচাই করার জন্য প্রয়োজনীয় নোডের ন্যূনতম সেট কীভাবে গণনা করা যায় তা দেখায়।

উদাহরণস্বরূপ, নীচের ট্রিতে ইনডেক্স 9-এ ডেটা যাচাই করতে, আমাদের ইনডেক্স 8, 9, 5, 3, 1-এ ডেটার হ্যাস প্রয়োজন।
(8,9)-এর হ্যাস (4)-এর হ্যাসের সমান হওয়া উচিত, যা 5-এর সাথে হ্যাস করে 2 তৈরি করে, যা 3-এর সাথে হ্যাস করে ট্রি রুট 1 তৈরি করে। যদি 9-এর জন্য ভুল ডেটা সরবরাহ করা হয়, তাহলে রুটটি পরিবর্তিত হবে - আমরা এটি সনাক্ত করব এবং শাখাটি যাচাই করতে ব্যর্থ হব।

```
* = প্রমাণ তৈরি করার জন্য প্রয়োজনীয় ডেটা

                    1*
          2                      3*
    4          5*          6          7
8*     9*   10    11   12    13    14    15

```

## আরও পড়ুন {#further-reading}

- [ইথেরিয়াম আপগ্রেড করা: SSZ](https://eth2book.info/altair/part2/building_blocks/ssz)
- [ইথেরিয়াম আপগ্রেড করা: মার্কেলাইজেশন](https://eth2book.info/altair/part2/building_blocks/merkleization)
- [SSZ ইমপ্লিমেন্টেশন](https://github.com/ethereum/consensus-specs/issues/2138)
- [SSZ ক্যালকুলেটর](https://simpleserialize.com/)
- [SSZ.dev](https://www.ssz.dev/)
