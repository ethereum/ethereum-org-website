---
title: রিকার্সিভ-লেংথ প্রিফিক্স (RLP) সিরিয়ালাইজেশন
description: ইথেরিয়ামের এক্সিকিউশন লেয়ারে rlp এনকোডিং-এর একটি সংজ্ঞা।
lang: bn
sidebarDepth: 2
---

ইথেরিয়ামের এক্সিকিউশন ক্লায়েন্টগুলিতে রিকার্সিভ লেংথ প্রিফিক্স (RLP) সিরিয়ালাইজেশন ব্যাপকভাবে ব্যবহৃত হয়। RLP একটি স্পেস-এফিশিয়েন্ট ফরম্যাটে নোডগুলির মধ্যে ডেটা স্থানান্তরকে প্রমিত করে। RLP-এর উদ্দেশ্য হল বাইনারি ডেটার নির্বিচারে নেস্টেড অ্যারে এনকোড করা, এবং RLP হল ইথেরিয়ামের এক্সিকিউশন লেয়ারে অবজেক্ট সিরিয়ালাইজ করার জন্য ব্যবহৃত প্রাথমিক এনকোডিং পদ্ধতি। RLP-এর মূল উদ্দেশ্য হল গঠন এনকোড করা; ধনাত্মক পূর্ণসংখ্যা ছাড়া, RLP নির্দিষ্ট ডেটা প্রকার (যেমন, স্ট্রিং, ফ্লোট) এনকোড করার দায়িত্ব উচ্চ-স্তরের প্রোটোকলগুলিতে অর্পণ করে। ধনাত্মক পূর্ণসংখ্যাগুলিকে অবশ্যই বিগ-এন্ডিয়ান বাইনারি আকারে উপস্থাপন করতে হবে যেখানে কোনো লিডিং জিরো থাকবে না (এভাবে শূন্য পূর্ণসংখ্যার মানকে খালি বাইট অ্যারের সমতুল্য করে তোলে)। RLP ব্যবহারকারী যেকোনো উচ্চ-স্তরের প্রোটোকল দ্বারা লিডিং জিরো সহ ডিসিরিয়ালাইজড ধনাত্মক পূর্ণসংখ্যাগুলিকে অবশ্যই অবৈধ হিসাবে গণ্য করতে হবে।

[ইথেরিয়াম ইয়েলো পেপার (পরিশিষ্ট B)](https://ethereum.github.io/yellowpaper/paper.pdf#page=19)-এ আরও তথ্য।

একটি ডিকশনারি এনকোড করতে RLP ব্যবহার করার জন্য, দুটি প্রস্তাবিত ক্যানোনিকাল ফর্ম হল:

- লেক্সিকোগ্রাফিক ক্রমে কি সহ `[[k1,v1],[k2,v2]...]` ব্যবহার করুন
- ইথেরিয়ামের মতো উচ্চ-স্তরের প্যাট্রিসিয়া ট্রি এনকোডিং ব্যবহার করুন

## সংজ্ঞা {#definition}

RLP এনকোডিং ফাংশন একটি আইটেম ইনপুট হিসাবে নেয়। একটি আইটেমকে নিম্নরূপ সংজ্ঞায়িত করা হয়েছে:

- একটি স্ট্রিং (অর্থাৎ, বাইট অ্যারে) একটি আইটেম
- আইটেমের একটি তালিকা একটি আইটেম
- একটি ধনাত্মক পূর্ণসংখ্যা একটি আইটেম

উদাহরণস্বরূপ, নিম্নলিখিত সবগুলি আইটেম:

- একটি খালি স্ট্রিং;
- "cat" শব্দটি ধারণকারী স্ট্রিং;
- যেকোনো সংখ্যক স্ট্রিং ধারণকারী একটি তালিকা;
- এবং `["cat", ["puppy", "cow"], "horse", [[]], "pig", [""], "sheep"]`-এর মতো আরও জটিল ডেটা স্ট্রাকচার।
- `100` সংখ্যাটি

মনে রাখবেন যে এই পৃষ্ঠার বাকি প্রেক্ষাপটে, 'স্ট্রিং' মানে "বাইনারি ডেটার একটি নির্দিষ্ট সংখ্যক বাইট"; কোনো বিশেষ এনকোডিং ব্যবহার করা হয় না, এবং স্ট্রিংগুলির বিষয়বস্তু সম্পর্কে কোনো জ্ঞানের ইঙ্গিত দেওয়া হয় না (নন-মিনিমাল ধনাত্মক পূর্ণসংখ্যার বিরুদ্ধে নিয়মের প্রয়োজন ছাড়া)।

RLP এনকোডিং নিম্নরূপ সংজ্ঞায়িত করা হয়েছে:

- একটি ধনাত্মক পূর্ণসংখ্যার জন্য, এটিকে সবচেয়ে ছোট বাইট অ্যারেতে রূপান্তরিত করা হয় যার বিগ-এন্ডিয়ান ব্যাখ্যা হল পূর্ণসংখ্যা, এবং তারপর নীচের নিয়ম অনুসারে একটি স্ট্রিং হিসাবে এনকোড করা হয়।
- `[0x00, 0x7f]` (ডেসিমেল `[0, 127]`) পরিসরের মধ্যে থাকা একটি একক বাইটের জন্য, সেই বাইটটিই তার নিজস্ব RLP এনকোডিং।
- অন্যথায়, যদি একটি স্ট্রিং 0-55 বাইট দীর্ঘ হয়, তাহলে RLP এনকোডিং-এ **0x80** (ডেসিমেল 128) মানের একটি একক বাইট এবং স্ট্রিংটির দৈর্ঘ্য এবং তারপরে স্ট্রিংটি থাকে। সুতরাং প্রথম বাইটের পরিসর হল `[0x80, 0xb7]` (ডেসিমেল `[128, 183]`)।
- যদি একটি স্ট্রিং 55 বাইটের বেশি দীর্ঘ হয়, তাহলে RLP এনকোডিং-এ **0xb7** (ডেসিমেল 183) মানের একটি একক বাইট এবং বাইনারি আকারে স্ট্রিংটির দৈর্ঘ্যের বাইটে দৈর্ঘ্য, তারপরে স্ট্রিংটির দৈর্ঘ্য এবং তারপরে স্ট্রিংটি থাকে। উদাহরণস্বরূপ, একটি 1024 বাইট দীর্ঘ স্ট্রিং `\xb9\x04\x00` (ডেসিমেল `185, 4, 0`) হিসাবে এনকোড করা হবে এবং তারপরে স্ট্রিংটি থাকবে। এখানে, প্রথম বাইট হিসাবে `0xb9` (183 + 2 = 185), তারপরে 2 বাইট `0x0400` (ডেসিমেল 1024) যা আসল স্ট্রিংটির দৈর্ঘ্য নির্দেশ করে। সুতরাং প্রথম বাইটের পরিসর হল `[0xb8, 0xbf]` (ডেসিমেল `[184, 191]`)।
- যদি একটি স্ট্রিং 2^64 বাইট দীর্ঘ বা তার বেশি হয়, তবে এটি এনকোড করা নাও হতে পারে।
- যদি একটি তালিকার মোট পেলোড (অর্থাৎ, RLP এনকোড করা তার সমস্ত আইটেমের সম্মিলিত দৈর্ঘ্য) 0-55 বাইট দীর্ঘ হয়, তবে RLP এনকোডিং-এ **0xc0** মানের একটি একক বাইট এবং পেলোডের দৈর্ঘ্য এবং তারপরে আইটেমগুলির RLP এনকোডিংগুলির ক্যাটেনেশন থাকে। সুতরাং প্রথম বাইটের পরিসর হল `[0xc0, 0xf7]` (ডেসিমেল `[192, 247]`)।
- যদি একটি তালিকার মোট পেলোড 55 বাইটের বেশি দীর্ঘ হয়, তবে RLP এনকোডিং-এ **0xf7** মানের একটি একক বাইট এবং বাইনারি আকারে পেলোডের দৈর্ঘ্যের বাইটে দৈর্ঘ্য, তারপরে পেলোডের দৈর্ঘ্য এবং তারপরে আইটেমগুলির RLP এনকোডিংগুলির ক্যাটেনেশন থাকে। সুতরাং প্রথম বাইটের পরিসর হল `[0xf8, 0xff]` (ডেসিমেল `[248, 255]`)।

কোডে, এটি হল:

```python
def rlp_encode(input):
    if isinstance(input,str):
        if len(input) == 1 and ord(input) < 0x80:
            return input
        return encode_length(len(input), 0x80) + input
    elif isinstance(input, list):
        output = ''
        for item in input:
            output += rlp_encode(item)
        return encode_length(len(output), 0xc0) + output

def encode_length(L, offset):
    if L < 56:
         return chr(L + offset)
    elif L < 256**8:
         BL = to_binary(L)
         return chr(len(BL) + offset + 55) + BL
    raise Exception("input too long")

def to_binary(x):
    if x == 0:
        return ''
    return to_binary(int(x / 256)) + chr(x % 256)
```

## উদাহরণ {#examples}

- "dog" স্ট্রিংটি = [ 0x83, 'd', 'o', 'g' ]
- [ "cat", "dog" ] তালিকাটি = `[ 0xc8, 0x83, 'c', 'a', 't', 0x83, 'd', 'o', 'g' ]`
- খালি স্ট্রিং ('null') = `[ 0x80 ]`
- খালি তালিকা = `[ 0xc0 ]`
- পূর্ণসংখ্যা 0 = `[ 0x80 ]`
- বাইট '\\x00' = `[ 0x00 ]`
- বাইট '\\x0f' = `[ 0x0f ]`
- বাইট '\\x04\\x00' = `[ 0x82, 0x04, 0x00 ]`
- তিন-এর [সেট থিওরেটিক্যাল রিপ্রেজেন্টেশন](http://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers), `[ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]`
- "Lorem ipsum dolor sit amet, consectetur adipisicing elit" স্ট্রিংটি = `[ 0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ... `, 'e', 'l', 'i', 't' ]\`

## RLP ডিকোডিং {#rlp-decoding}

RLP এনকোডিং-এর নিয়ম এবং প্রক্রিয়া অনুসারে, RLP ডিকোডিং-এর ইনপুটকে বাইনারি ডেটার একটি অ্যারে হিসাবে গণ্য করা হয়। RLP ডিকোডিং প্রক্রিয়াটি নিম্নরূপ:

1. ইনপুট ডেটার প্রথম বাইট (অর্থাৎ, প্রিফিক্স) অনুযায়ী ডেটার ধরন, আসল ডেটার দৈর্ঘ্য এবং অফসেট ডিকোড করা;

2. ডেটার ধরন এবং অফসেট অনুযায়ী, ধনাত্মক পূর্ণসংখ্যার জন্য মিনিমাল এনকোডিং নিয়মকে সম্মান করে ডেটা ডিকোড করা;

3. ইনপুটের বাকি অংশ ডিকোড করা চালিয়ে যাওয়া;

তাদের মধ্যে, ডেটার ধরন এবং অফসেট ডিকোড করার নিয়মগুলি নিম্নরূপ:

1. ডেটা একটি স্ট্রিং যদি প্রথম বাইটের (অর্থাৎ, প্রিফিক্স) পরিসর [0x00, 0x7f] হয়, এবং স্ট্রিংটি ঠিক প্রথম বাইট নিজেই;

2. ডেটা একটি স্ট্রিং যদি প্রথম বাইটের পরিসর [0x80, 0xb7] হয়, এবং যে স্ট্রিংটির দৈর্ঘ্য প্রথম বাইট মাইনাস 0x80 এর সমান, তা প্রথম বাইটকে অনুসরণ করে;

3. ডেটা একটি স্ট্রিং যদি প্রথম বাইটের পরিসর [0xb8, 0xbf] হয়, এবং যে স্ট্রিংটির বাইটে দৈর্ঘ্য প্রথম বাইট মাইনাস 0xb7 এর সমান তা প্রথম বাইটকে অনুসরণ করে, এবং স্ট্রিংটি স্ট্রিংয়ের দৈর্ঘ্যকে অনুসরণ করে;

4. ডেটা একটি তালিকা যদি প্রথম বাইটের পরিসর [0xc0, 0xf7] হয়, এবং তালিকার সমস্ত আইটেমের RLP এনকোডিংগুলির ক্যাটেনেশন, যার মোট পেলোড প্রথম বাইট মাইনাস 0xc0 এর সমান, তা প্রথম বাইটকে অনুসরণ করে;

5. ডেটা একটি তালিকা যদি প্রথম বাইটের পরিসর [0xf8, 0xff] হয়, এবং তালিকার মোট পেলোড যার দৈর্ঘ্য প্রথম বাইট মাইনাস 0xf7 এর সমান, তা প্রথম বাইটকে অনুসরণ করে, এবং তালিকার সমস্ত আইটেমের RLP এনকোডিংগুলির ক্যাটেনেশন তালিকার মোট পেলোডকে অনুসরণ করে;

কোডে, এটি হল:

```python
def rlp_decode(input):
    if len(input) == 0:
        return
    output = ''
    (offset, dataLen, type) = decode_length(input)
    if type is str:
        output = instantiate_str(substr(input, offset, dataLen))
    elif type is list:
        output = instantiate_list(substr(input, offset, dataLen))
    output += rlp_decode(substr(input, offset + dataLen))
    return output

def decode_length(input):
    length = len(input)
    if length == 0:
        raise Exception("input is null")
    prefix = ord(input[0])
    if prefix <= 0x7f:
        return (0, 1, str)
    elif prefix <= 0xb7 and length > prefix - 0x80:
        strLen = prefix - 0x80
        return (1, strLen, str)
    elif prefix <= 0xbf and length > prefix - 0xb7 and length > prefix - 0xb7 + to_integer(substr(input, 1, prefix - 0xb7)):
        lenOfStrLen = prefix - 0xb7
        strLen = to_integer(substr(input, 1, lenOfStrLen))
        return (1 + lenOfStrLen, strLen, str)
    elif prefix <= 0xf7 and length > prefix - 0xc0:
        listLen = prefix - 0xc0;
        return (1, listLen, list)
    elif prefix <= 0xff and length > prefix - 0xf7 and length > prefix - 0xf7 + to_integer(substr(input, 1, prefix - 0xf7)):
        lenOfListLen = prefix - 0xf7
        listLen = to_integer(substr(input, 1, lenOfListLen))
        return (1 + lenOfListLen, listLen, list)
    raise Exception("input does not conform to RLP encoding form")

def to_integer(b):
    length = len(b)
    if length == 0:
        raise Exception("input is null")
    elif length == 1:
        return ord(b[0])
    return ord(substr(b, -1)) + to_integer(substr(b, 0, -1)) * 256
```

## আরও পড়ুন {#further-reading}

- [ইথেরিয়ামে RLP](https://medium.com/coinmonks/data-structure-in-ethereum-episode-1-recursive-length-prefix-rlp-encoding-decoding-d1016832f919)
- [ইথেরিয়ামের আদ্যোপান্ত: RLP](https://medium.com/coinmonks/ethereum-under-the-hood-part-3-rlp-decoding-df236dc13e58)
- Coglio, A. (2020)। ACL2-তে ইথেরিয়ামের রিকার্সিভ লেংথ প্রিফিক্স। arXiv preprint arXiv:2009.13769.](https://arxiv.org/abs/2009.13769)

## সম্পর্কিত বিষয় {#related-topics}

- [প্যাট্রিসিয়া মার্কল ট্রাই](/developers/docs/data-structures-and-encoding/patricia-merkle-trie)
