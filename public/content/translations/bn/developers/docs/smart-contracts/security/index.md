---
title: "স্মার্ট কন্ট্র্যাক্ট সুরক্ষা"
description: "সুরক্ষিত ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট তৈরির জন্য নির্দেশাবলীর একটি সংক্ষিপ্ত বিবরণ"
lang: bn
---

স্মার্ট কন্ট্র্যাক্টগুলো অত্যন্ত ফ্লেক্সিবল, এবং বিপুল পরিমাণ ভ্যালু ও ডেটা নিয়ন্ত্রণ করতে সক্ষম, যখন ব্লকচেইনে ডিপ্লয় করা কোডের উপর ভিত্তি করে অপরিবর্তনীয় লজিক চালায়। এটি ট্রাস্টলেস এবং ডিসেন্ট্রালাইজড এপ্লিকেশনগুলোর একটি প্রাণবন্ত ইকোসিস্টেম তৈরি করেছে যা লিগ্যাসি সিস্টেমের তুলনায় অনেক সুবিধা প্রদান করে। তারা স্মার্ট কন্ট্র্যাক্টে থাকা দুর্বলতাগুলোকে কাজে লাগিয়ে মুনাফা অর্জন করতে চাওয়া অ্যাটাকারদের জন্য সুযোগও তৈরি করে।

পাবলিক ব্লকচেইন, যেমন ইথেরিয়াম, স্মার্ট কন্ট্র্যাক্ট সুরক্ষিত করার বিষয়টিকে আরও জটিল করে তোলে। ডিপ্লয় করা কন্ট্র্যাক্ট কোড _সাধারণত_ নিরাপত্তা ত্রুটি প্যাচ করার জন্য পরিবর্তন করা যায় না, যেখানে স্মার্ট কন্ট্র্যাক্ট থেকে চুরি করা সম্পদগুলো ট্র্যাক করা অত্যন্ত কঠিন এবং অপরিবর্তনীয়তার কারণে বেশিরভাগই পুনরুদ্ধার করা যায় না।

যদিও পরিসংখ্যান ভিন্ন হতে পারে, তবে অনুমান করা হয় যে স্মার্ট কন্ট্র্যাক্টগুলোতে নিরাপত্তা ত্রুটির কারণে চুরি বা হারিয়ে যাওয়া মোট মূল্যের পরিমাণ সহজেই $1 বিলিয়নের বেশি। এর মধ্যে উচ্চ-প্রোফাইল ঘটনাগুলো অন্তর্ভুক্ত, যেমন [DAO হ্যাক](https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/) (3.6M ETH চুরি হয়েছে, যার আজকের মূল্যে $1B-এর বেশি), [প্যারিটি মাল্টি-সিগ ওয়ালেট হ্যাক](https://www.coindesk.com/markets/2017/07/19/30-million-ether-reported-stolen-due-to-parity-wallet-breach) (হ্যাকারদের কাছে $30M হারিয়েছে), এবং [প্যারিটি ফ্রোজেন ওয়ালেট সমস্যা](https://www.theguardian.com/technology/2017/nov/08/cryptocurrency-300m-dollars-stolen-bug-ether) (ETH-এ $300M-এর বেশি চিরতরে লক হয়ে গেছে)।

উপরে উল্লিখিত সমস্যাগুলো ডেভেলপারদের জন্য সুরক্ষিত, মজবুত এবং স্থিতিস্থাপক স্মার্ট কন্ট্র্যাক্ট তৈরিতে প্রচেষ্টা বিনিয়োগ করা অপরিহার্য করে তোলে। স্মার্ট কন্ট্র্যাক্ট সুরক্ষা একটি গুরুতর ব্যবসা, এবং এটি এমন একটি বিষয় যা প্রত্যেক ডেভেলপারের ভালোভাবে শেখা উচিত। এই গাইডটি ইথেরিয়াম ডেভেলপারদের জন্য নিরাপত্তা বিবেচনার বিষয়গুলো কভার করবে এবং স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা উন্নত করার জন্য রিসোর্সগুলো অন্বেষণ করবে।

## পূর্বশর্ত {#prerequisites}

নিরাপত্তার বিষয়টি মোকাবেলা করার আগে নিশ্চিত করুন যে আপনি [স্মার্ট কন্ট্র্যাক্ট ডেভেলপমেন্টের মূল বিষয়গুলো](/developers/docs/smart-contracts/) সম্পর্কে পরিচিত।

## সুরক্ষিত ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট তৈরির জন্য নির্দেশিকা {#smart-contract-security-guidelines}

### ১. সঠিক অ্যাক্সেস কন্ট্রোল ডিজাইন করুন {#design-proper-access-controls}

স্মার্ট কন্ট্র্যাক্টে, `public` বা `external` হিসেবে চিহ্নিত ফাংশনগুলো যেকোনো এক্সটার্নালি ওনড অ্যাকাউন্ট (EOAs) বা কন্ট্র্যাক্ট অ্যাকাউন্ট দ্বারা কল করা যেতে পারে। ফাংশনগুলোর জন্য পাবলিক ভিজিবিলিটি নির্দিষ্ট করা প্রয়োজন যদি আপনি চান অন্যরা আপনার কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করুক। তবে, `private` হিসেবে চিহ্নিত ফাংশনগুলো শুধুমাত্র স্মার্ট কন্ট্র্যাক্টের মধ্যে থাকা ফাংশন দ্বারা কল করা যেতে পারে, এক্সটার্নাল অ্যাকাউন্ট দ্বারা নয়। প্রতিটি নেটওয়ার্ক অংশগ্রহণকারীকে কন্ট্র্যাক্ট ফাংশনে অ্যাক্সেস দেওয়া সমস্যা তৈরি করতে পারে, বিশেষ করে যদি এর মানে হয় যে কেউ সংবেদনশীল অপারেশন (যেমন, নতুন টোকেন মিন্ট করা) সম্পাদন করতে পারে।

স্মার্ট কন্ট্র্যাক্ট ফাংশনের অননুমোদিত ব্যবহার রোধ করতে, সুরক্ষিত অ্যাক্সেস কন্ট্রোল বাস্তবায়ন করা প্রয়োজন। অ্যাক্সেস কন্ট্রোল মেকানিজম একটি স্মার্ট কন্ট্র্যাক্টে নির্দিষ্ট ফাংশন ব্যবহার করার ক্ষমতাকে অনুমোদিত সত্তার মধ্যে সীমাবদ্ধ করে, যেমন কন্ট্র্যাক্ট পরিচালনার জন্য দায়ী অ্যাকাউন্টগুলো। স্মার্ট কন্ট্র্যাক্টে অ্যাক্সেস কন্ট্রোল বাস্তবায়নের জন্য **ওনেবল প্যাটার্ন** এবং **রোল-বেসড কন্ট্রোল** দুটি দরকারী প্যাটার্ন:

#### ওনেবল প্যাটার্ন {#ownable-pattern}

ওনেবল প্যাটার্নে, কন্ট্র্যাক্ট-তৈরির প্রক্রিয়া চলাকালীন একটি অ্যাড্রেসকে কন্ট্র্যাক্টের “মালিক” হিসাবে সেট করা হয়। সুরক্ষিত ফাংশনগুলোতে একটি `OnlyOwner` মডিফায়ার বরাদ্দ করা হয়, যা নিশ্চিত করে যে কন্ট্র্যাক্টটি ফাংশনটি কার্যকর করার আগে কলিং অ্যাড্রেসের পরিচয় প্রমাণ করে। কন্ট্র্যাক্টের মালিক ছাড়া অন্য অ্যাড্রেস থেকে সুরক্ষিত ফাংশনে করা কলগুলো সর্বদা রিভার্ট হয়, যা অবাঞ্ছিত অ্যাক্সেস প্রতিরোধ করে।

#### ভূমিকা-ভিত্তিক অ্যাক্সেস কন্ট্রোল {#role-based-access-control}

একটি স্মার্ট কন্ট্র্যাক্টে একটি একক অ্যাড্রেসকে `Owner` হিসাবে নিবন্ধন করা সেন্ট্রালাইজেশনের ঝুঁকি তৈরি করে এবং একটি সিঙ্গেল পয়েন্ট-অফ-ফেলিওর উপস্থাপন করে। যদি মালিকের অ্যাকাউন্টের কী গুলো আপোস করা হয়, তাহলে অ্যাটাকাররা মালিকানাধীন কন্ট্র্যাক্টে আক্রমণ করতে পারে। এ কারণেই একাধিক প্রশাসনিক অ্যাকাউন্ট সহ একটি ভূমিকা-ভিত্তিক অ্যাক্সেস কন্ট্রোল প্যাটার্ন ব্যবহার করা একটি ভাল বিকল্প হতে পারে।

ভূমিকা-ভিত্তিক অ্যাক্সেস কন্ট্রোলে, সংবেদনশীল ফাংশনগুলোতে অ্যাক্সেস বিশ্বস্ত অংশগ্রহণকারীদের একটি সেটের মধ্যে বিতরণ করা হয়। উদাহরণস্বরূপ, একটি অ্যাকাউন্ট টোকেন মিন্ট করার জন্য দায়ী হতে পারে, যখন অন্য একটি অ্যাকাউন্ট আপগ্রেড সম্পাদন করে বা কন্ট্র্যাক্টটি পজ করে। এইভাবে অ্যাক্সেস কন্ট্রোল ডিসেন্ট্রালাইজ করা সিঙ্গেল পয়েন্ট অফ ফেলিওর দূর করে এবং ব্যবহারকারীদের জন্য বিশ্বাসের অনুমান কমায়।

##### মাল্টি-সিগনেচার ওয়ালেট ব্যবহার করা

সুরক্ষিত অ্যাক্সেস কন্ট্রোল বাস্তবায়নের আরেকটি পদ্ধতি হল একটি কন্ট্র্যাক্ট পরিচালনা করার জন্য একটি [মাল্টি-সিগনেচার অ্যাকাউন্ট](/developers/docs/smart-contracts/#multisig) ব্যবহার করা। একটি সাধারণ EOA-এর মতো নয়, মাল্টি-সিগনেচার অ্যাকাউন্টগুলো একাধিক সত্তার মালিকানাধীন এবং লেনদেন সম্পাদন করার জন্য ন্যূনতম সংখ্যক অ্যাকাউন্ট থেকে স্বাক্ষরের প্রয়োজন হয়—ধরুন 5টির মধ্যে 3টি।

অ্যাক্সেস কন্ট্রোলের জন্য একটি মাল্টিসিগ ব্যবহার করা সুরক্ষার একটি অতিরিক্ত লেয়ার যোগ করে কারণ টার্গেট কন্ট্র্যাক্টের উপর অ্যাকশনগুলোর জন্য একাধিক পক্ষের সম্মতি প্রয়োজন। এটি বিশেষভাবে উপযোগী যদি ওনেবল প্যাটার্ন ব্যবহার করা প্রয়োজন হয়, কারণ এটি একজন অ্যাটাকার বা দুর্বৃত্ত অভ্যন্তরীণ ব্যক্তির পক্ষে ক্ষতিকারক উদ্দেশ্যে সংবেদনশীল কন্ট্র্যাক্ট ফাংশনগুলোকে ম্যানিপুলেট করা আরও কঠিন করে তোলে।

### 2. কন্ট্র্যাক্ট অপারেশন রক্ষা করতে require(), assert(), এবং revert() স্টেটমেন্ট ব্যবহার করুন {#use-require-assert-revert}

যেমন উল্লেখ করা হয়েছে, একবার আপনার স্মার্ট কন্ট্র্যাক্ট ব্লকচেইনে ডিপ্লয় করা হলে যে কেউ পাবলিক ফাংশন কল করতে পারে। যেহেতু আপনি আগে থেকে জানতে পারবেন না যে এক্সটার্নাল অ্যাকাউন্টগুলো কীভাবে একটি কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করবে, তাই ডিপ্লয় করার আগে সমস্যাযুক্ত অপারেশনের বিরুদ্ধে অভ্যন্তরীণ সুরক্ষা প্রয়োগ করা আদর্শ। আপনি `require()`, `assert()`, এবং `revert()` স্টেটমেন্ট ব্যবহার করে স্মার্ট কন্ট্র্যাক্টে সঠিক আচরণ প্রয়োগ করতে পারেন যাতে এক্সিকিউশন নির্দিষ্ট প্রয়োজনীয়তা পূরণ করতে ব্যর্থ হলে ব্যতিক্রম ট্রিগার করে এবং স্টেট পরিবর্তনগুলো রিভার্ট করে।

**`require()`**: `require` ফাংশনের শুরুতে সংজ্ঞায়িত করা হয় এবং এটি নিশ্চিত করে যে কল করা ফাংশনটি কার্যকর করার আগে পূর্বনির্ধারিত শর্তগুলো পূরণ করা হয়েছে। একটি ফাংশনের সাথে অগ্রসর হওয়ার আগে ব্যবহারকারীর ইনপুট ভ্যালিডেট করতে, স্টেট ভ্যারিয়েবল চেক করতে বা কলিং অ্যাকাউন্টের পরিচয় প্রমাণ করতে একটি `require` স্টেটমেন্ট ব্যবহার করা যেতে পারে।

**`assert()`**: `assert()` অভ্যন্তরীণ ত্রুটি সনাক্ত করতে এবং আপনার কোডে “ইনভ্যারিয়েন্ট” এর লঙ্ঘন পরীক্ষা করতে ব্যবহৃত হয়। একটি ইনভ্যারিয়েন্ট হলো একটি কন্ট্র্যাক্টের স্টেট সম্পর্কে একটি যৌক্তিক দাবি যা সমস্ত ফাংশন এক্সিকিউশনের জন্য সত্য থাকা উচিত। একটি উদাহরণ ইনভ্যারিয়েন্ট হলো একটি টোকেন কন্ট্র্যাক্টের সর্বোচ্চ মোট সরবরাহ বা ব্যালেন্স। `assert()` ব্যবহার করা নিশ্চিত করে যে আপনার কন্ট্র্যাক্ট কখনও একটি দুর্বল স্টেটে পৌঁছায় না, এবং যদি পৌঁছায়, তবে স্টেট ভ্যারিয়েবলের সমস্ত পরিবর্তন রোল ব্যাক করা হয়।

**`revert()`**: `revert()` একটি if-else স্টেটমেন্টে ব্যবহার করা যেতে পারে যা প্রয়োজনীয় শর্ত পূরণ না হলে একটি ব্যতিক্রম ট্রিগার করে। নিচের স্যাম্পল কন্ট্র্যাক্টটি ফাংশনের এক্সিকিউশন রক্ষা করতে `revert()` ব্যবহার করে:

```
pragma solidity ^0.8.4;

contract VendingMachine {
    address owner;
    error Unauthorized();
    function buy(uint amount) public payable {
        if (amount > msg.value / 2 ether)
            revert("Not enough Ether provided.");
        // Perform the purchase.
    }
    function withdraw() public {
        if (msg.sender != owner)
            revert Unauthorized();

        payable(msg.sender).transfer(address(this).balance);
    }
}
```

### 3. স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করুন এবং কোডের সঠিকতা যাচাই করুন {#test-smart-contracts-and-verify-code-correctness}

[ইথেরিয়াম ভার্চুয়াল মেশিন](/developers/docs/evm/) এ চালিত কোডের অপরিবর্তনীয়তার অর্থ হলো স্মার্ট কন্ট্র্যাক্টগুলোর ডেভেলপমেন্ট পর্যায়ে উচ্চ স্তরের গুণমান মূল্যায়নের প্রয়োজন হয়। আপনার কন্ট্র্যাক্ট ব্যাপকভাবে পরীক্ষা করা এবং যেকোনো অপ্রত্যাশিত ফলাফলের জন্য এটি পর্যবেক্ষণ করা নিরাপত্তা অনেক উন্নত করবে এবং দীর্ঘমেয়াদে আপনার ব্যবহারকারীদের রক্ষা করবে।

সাধারণ পদ্ধতি হলো ব্যবহারকারীদের কাছ থেকে কন্ট্র্যাক্ট যে মক ডেটা পাওয়ার আশা করে তা ব্যবহার করে ছোট ইউনিট টেস্ট লেখা। [ইউনিট টেস্টিং](/developers/docs/smart-contracts/testing/#unit-testing) নির্দিষ্ট ফাংশনের ফাংশনালিটি পরীক্ষা করার জন্য এবং একটি স্মার্ট কন্ট্র্যাক্ট প্রত্যাশিতভাবে কাজ করে তা নিশ্চিত করার জন্য ভালো।

দুর্ভাগ্যবশত, বিচ্ছিন্নভাবে ব্যবহার করা হলে স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা উন্নত করার জন্য ইউনিট টেস্টিং ন্যূনতম কার্যকর। একটি ইউনিট টেস্ট প্রমাণ করতে পারে যে একটি ফাংশন মক ডেটার জন্য সঠিকভাবে এক্সিকিউট হয়, কিন্তু ইউনিট টেস্টগুলো ততটাই কার্যকর যতটা টেস্ট লেখা হয়। এটি মিস করা এজ কেস এবং দুর্বলতাগুলো সনাক্ত করা কঠিন করে তোলে যা আপনার স্মার্ট কন্ট্র্যাক্টের নিরাপত্তাকে ভেঙে দিতে পারে।

একটি ভালো পদ্ধতি হল [স্ট্যাটিক এবং ডাইনামিক বিশ্লেষণ](/developers/docs/smart-contracts/testing/#static-dynamic-analysis) ব্যবহার করে সম্পাদিত প্রপার্টি-বেসড টেস্টিংয়ের সাথে ইউনিট টেস্টিং একত্রিত করা। স্ট্যাটিক বিশ্লেষণ পৌঁছানোযোগ্য প্রোগ্রাম স্টেট এবং এক্সিকিউশন পাথ বিশ্লেষণ করতে নিম্ন-স্তরের উপস্থাপনার উপর নির্ভর করে, যেমন [কন্ট্রোল ফ্লো গ্রাফ](https://en.wikipedia.org/wiki/Control-flow_graph) এবং [অ্যাবস্ট্রাক্ট সিনট্যাক্স ট্রি](https://deepsource.io/glossary/ast/)। এদিকে, ডাইনামিক বিশ্লেষণ কৌশল, যেমন [স্মার্ট কন্ট্র্যাক্ট ফাজিং](https://www.cyfrin.io/blog/smart-contract-fuzzing-and-invariants-testing-foundry), নিরাপত্তা বৈশিষ্ট্য লঙ্ঘন করে এমন অপারেশন সনাক্ত করতে র‍্যান্ডম ইনপুট মান সহ কন্ট্র্যাক্ট কোড এক্সিকিউট করে।

[ফর্মাল ভেরিফিকেশন](/developers/docs/smart-contracts/formal-verification) স্মার্ট কন্ট্র্যাক্টে নিরাপত্তা বৈশিষ্ট্য যাচাই করার আরেকটি কৌশল। নিয়মিত পরীক্ষার মতো নয়, ফর্মাল ভেরিফিকেশন একটি স্মার্ট কন্ট্র্যাক্টে ত্রুটির অনুপস্থিতি নিশ্চিতভাবে প্রমাণ করতে পারে। এটি একটি ফর্মাল স্পেসিফিকেশন তৈরি করে অর্জন করা হয় যা পছন্দসই নিরাপত্তা বৈশিষ্ট্যগুলো ক্যাপচার করে এবং প্রমাণ করে যে কন্ট্র্যাক্টগুলোর একটি ফর্মাল মডেল এই স্পেসিফিকেশন মেনে চলে।

### ৪. আপনার কোডের একটি স্বাধীন পর্যালোচনার জন্য অনুরোধ করুন {#get-independent-code-reviews}

আপনার কন্ট্র্যাক্ট পরীক্ষা করার পরে, অন্যদের কোনো নিরাপত্তা সমস্যার জন্য সোর্স কোড চেক করতে বলা ভালো। টেস্টিং একটি স্মার্ট কন্ট্র্যাক্টের প্রতিটি ত্রুটি উন্মোচন করবে না, তবে একটি স্বাধীন পর্যালোচনা পাওয়া দুর্বলতা চিহ্নিত করার সম্ভাবনা বাড়িয়ে দেয়।

#### অডিট {#audits}

একটি স্মার্ট কন্ট্র্যাক্ট অডিট কমিশন করা একটি স্বাধীন কোড রিভিউ পরিচালনা করার একটি উপায়। অডিটররা স্মার্ট কন্ট্র্যাক্টগুলো সুরক্ষিত এবং গুণমান ত্রুটি ও ডিজাইনের ভুল থেকে মুক্ত তা নিশ্চিত করতে একটি গুরুত্বপূর্ণ ভূমিকা পালন করে।

তবুও, আপনার অডিটকে একটি অব্যর্থ সমাধান হিসেবে বিবেচনা করা উচিত নয়। স্মার্ট কন্ট্র্যাক্ট অডিট প্রতিটি বাগ ধরতে পারে না এবং বেশিরভাগই পর্যালোচনার একটি অতিরিক্ত রাউন্ড প্রদানের জন্য ডিজাইন করা হয়, যা প্রাথমিক ডেভেলপমেন্ট এবং পরীক্ষার সময় ডেভেলপারদের দ্বারা মিস করা সমস্যাগুলো সনাক্ত করতে সাহায্য করতে পারে। একটি স্মার্ট কন্ট্র্যাক্ট অডিটের সুবিধা সর্বাধিক করার জন্য আপনার অডিটরদের সাথে কাজ করার জন্য সেরা অনুশীলনগুলোও অনুসরণ করা উচিত, যেমন কোড সঠিকভাবে ডকুমেন্ট করা এবং ইনলাইন মন্তব্য যোগ করা।

- [স্মার্ট কন্ট্র্যাক্ট অডিটিং টিপস ও ট্রিকস](https://twitter.com/tinchoabbate/status/1400170232904400897) - _@tinchoabbate_
- [আপনার অডিট থেকে সর্বাধিক সুবিধা নিন](https://inference.ag/blog/2023-08-14-tips/) - _ইনফারেন্স_

#### বাগ বাউন্টি {#bug-bounties}

একটি বাগ বাউন্টি প্রোগ্রাম সেট আপ করা এক্সটার্নাল কোড রিভিউ বাস্তবায়নের আরেকটি পদ্ধতি। একটি বাগ বাউন্টি হল এমন ব্যক্তিদের (সাধারণত হোয়াইটহ্যাট হ্যাকার) দেওয়া একটি আর্থিক পুরস্কার যারা একটি অ্যাপ্লিকেশনে দুর্বলতা আবিষ্কার করে।

সঠিকভাবে ব্যবহার করা হলে, বাগ বাউন্টি হ্যাকার সম্প্রদায়ের সদস্যদের আপনার কোডকে গুরুতর ত্রুটির জন্য পরিদর্শন করার জন্য উৎসাহ দেয়। একটি বাস্তব-জীবনের উদাহরণ হল “ইনফিনিট মানি বাগ” যা একজন অ্যাটাকারকে [Optimism](https://www.optimism.io/)-এ সীমাহীন পরিমাণে ইথার তৈরি করতে দিত, যা Ethereum-এ চলমান একটি [লেয়ার 2](/layer-2/) প্রোটোকল। সৌভাগ্যবশত, একজন হোয়াইটহ্যাট হ্যাকার [ত্রুটিটি আবিষ্কার করেন](https://www.saurik.com/optimism.html) এবং টিমকে অবহিত করেন, [প্রক্রিয়াটিতে একটি বড় পেআউট অর্জন করেন](https://cryptoslate.com/critical-bug-in-ethereum-l2-optimism-2m-bounty-paid/)।

একটি দরকারী কৌশল হল একটি বাগ বাউন্টি প্রোগ্রামের পেআউটকে স্টেক করা ফান্ডের পরিমাণের অনুপাতে সেট করা। “[স্কেলিং বাগ বাউন্টি](https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7)” হিসাবে বর্ণিত, এই পদ্ধতিটি ব্যক্তিদের দুর্বলতাগুলো কাজে লাগানোর পরিবর্তে দায়িত্বশীলভাবে প্রকাশ করার জন্য আর্থিক উৎসাহ প্রদান করে।

### ৫। স্মার্ট কন্ট্র্যাক্ট ডেভেলপমেন্টের সময় সেরা অনুশীলনগুলো অনুসরণ করুন {#follow-smart-contract-development-best-practices}

অডিট এবং বাগ বাউন্টির অস্তিত্ব উচ্চ-মানের কোড লেখার আপনার দায়িত্ব থেকে আপনাকে অব্যাহতি দেয় না। ভালো স্মার্ট কন্ট্র্যাক্ট সুরক্ষা সঠিক ডিজাইন এবং ডেভেলপমেন্ট প্রক্রিয়া অনুসরণ করার মাধ্যমে শুরু হয়:

- সমস্ত কোড একটি ভার্সন কন্ট্রোল সিস্টেমে সংরক্ষণ করুন, যেমন git

- সমস্ত কোড পরিবর্তন পুল রিকোয়েস্টের মাধ্যমে করুন

- নিশ্চিত করুন যে পুল রিকোয়েস্টগুলোতে অন্তত একজন স্বাধীন পর্যালোচক আছে—যদি আপনি কোনো প্রকল্পে একা কাজ করেন, তবে অন্য ডেভেলপার খুঁজে বের করার এবং কোড রিভিউ ট্রেড করার কথা বিবেচনা করুন

- স্মার্ট কন্ট্র্যাক্ট পরীক্ষা, কম্পাইল এবং ডিপ্লয় করার জন্য একটি [ডেভেলপমেন্ট এনভায়রনমেন্ট](/developers/docs/frameworks/) ব্যবহার করুন

- আপনার কোডটি বেসিক কোড অ্যানালাইসিস টুলস, যেমন [Cyfrin Aderyn](https://github.com/Cyfrin/aderyn), Mythril এবং Slither-এর মাধ্যমে চালান। আদর্শগতভাবে, প্রতিটি পুল রিকোয়েস্ট মার্জ করার আগে আপনার এটি করা উচিত এবং আউটপুটের পার্থক্য তুলনা করা উচিত

- নিশ্চিত করুন যে আপনার কোড কোনো ত্রুটি ছাড়াই কম্পাইল হয়, এবং Solidity কম্পাইলার কোনো সতর্কতা জারি করে না

- আপনার কোড সঠিকভাবে ডকুমেন্ট করুন ([NatSpec](https://solidity.readthedocs.io/en/develop/natspec-format.html) ব্যবহার করে) এবং কন্ট্র্যাক্ট আর্কিটেকচার সম্পর্কে বিস্তারিত সহজ-বোধ্য ভাষায় বর্ণনা করুন। এটি অন্যদের জন্য আপনার কোড অডিট এবং পর্যালোচনা করা সহজ করে তুলবে।

### ৬. মজবুত ডিজাস্টার রিকভারি প্ল্যান বাস্তবায়ন করুন {#implement-disaster-recovery-plans}

সুরক্ষিত অ্যাক্সেস কন্ট্রোল ডিজাইন করা, ফাংশন মডিফায়ার বাস্তবায়ন করা, এবং অন্যান্য পরামর্শগুলো স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা উন্নত করতে পারে, কিন্তু তারা ক্ষতিকারক এক্সপ্লয়েটের সম্ভাবনাকে বাতিল করতে পারে না। সুরক্ষিত স্মার্ট কন্ট্র্যাক্ট তৈরির জন্য “ব্যর্থতার জন্য প্রস্তুতি” এবং আক্রমণের বিরুদ্ধে কার্যকরভাবে প্রতিক্রিয়া জানানোর জন্য একটি ফলব্যাক প্ল্যান থাকা প্রয়োজন। একটি সঠিক ডিজাস্টার রিকভারি প্ল্যানে নিম্নলিখিত উপাদানগুলোর কিছু বা সবগুলো অন্তর্ভুক্ত থাকবে:

#### কন্ট্র্যাক্ট আপগ্রেড {#contract-upgrades}

যদিও Ethereum স্মার্ট কন্ট্র্যাক্টগুলো ডিফল্টভাবে অপরিবর্তনীয়, আপগ্রেড প্যাটার্ন ব্যবহার করে কিছু মাত্রার মিউটেবিলিটি অর্জন করা সম্ভব। কন্ট্র্যাক্ট আপগ্রেড করা সেইসব ক্ষেত্রে প্রয়োজন যেখানে একটি গুরুতর ত্রুটি আপনার পুরানো কন্ট্র্যাক্টকে অব্যবহারযোগ্য করে তোলে এবং নতুন লজিক ডিপ্লয় করা সবচেয়ে কার্যকর বিকল্প।

কন্ট্র্যাক্ট আপগ্রেড মেকানিজমগুলো ভিন্নভাবে কাজ করে, কিন্তু “প্রক্সি প্যাটার্ন” স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার জন্য আরও জনপ্রিয় পদ্ধতিগুলোর মধ্যে একটি। [প্রক্সি প্যাটার্ন](https://www.cyfrin.io/blog/upgradeable-proxy-smart-contract-pattern) একটি অ্যাপ্লিকেশনের স্টেট এবং লজিককে _দুইটি_ কন্ট্র্যাক্টের মধ্যে বিভক্ত করে। প্রথম কন্ট্র্যাক্টটি (যাকে ‘প্রক্সি কন্ট্র্যাক্ট’ বলা হয়) স্টেট ভ্যারিয়েবল (যেমন, ব্যবহারকারীর ব্যালেন্স) স্টোর করে, যখন দ্বিতীয় কন্ট্র্যাক্টটি (যাকে ‘লজিক কন্ট্র্যাক্ট’ বলা হয়) কন্ট্র্যাক্ট ফাংশন এক্সিকিউট করার জন্য কোড ধারণ করে।

অ্যাকাউন্টগুলো প্রক্সি কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করে, যা [`delegatecall()`](https://docs.soliditylang.org/en/v0.8.16/introduction-to-smart-contracts.html?highlight=delegatecall#delegatecall-callcode-and-libraries) লো-লেভেল কল ব্যবহার করে সমস্ত ফাংশন কল লজিক কন্ট্র্যাক্টে প্রেরণ করে। একটি নিয়মিত মেসেজ কলের মতো নয়, `delegatecall()` নিশ্চিত করে যে লজিক কন্ট্র্যাক্টের অ্যাড্রেসে চলমান কোডটি কলিং কন্ট্র্যাক্টের প্রেক্ষাপটে এক্সিকিউট হয়। এর মানে হল লজিক কন্ট্র্যাক্টটি সর্বদা প্রক্সির স্টোরেজে লিখবে (এর নিজস্ব স্টোরেজের পরিবর্তে) এবং `msg.sender` ও `msg.value`-এর মূল মানগুলো সংরক্ষিত থাকবে।

লজিক কন্ট্র্যাক্টে কল ডেলিগেট করার জন্য প্রক্সি কন্ট্র্যাক্টের স্টোরেজে এর অ্যাড্রেস সংরক্ষণ করা প্রয়োজন। সুতরাং, কন্ট্র্যাক্টের লজিক আপগ্রেড করা শুধুমাত্র অন্য একটি লজিক কন্ট্র্যাক্ট ডিপ্লয় করা এবং প্রক্সি কন্ট্র্যাক্টে নতুন অ্যাড্রেস সংরক্ষণ করার বিষয়। যেহেতু প্রক্সি কন্ট্র্যাক্টে পরবর্তী কলগুলো স্বয়ংক্রিয়ভাবে নতুন লজিক কন্ট্র্যাক্টে রাউট করা হয়, আপনি আসলে কোড পরিবর্তন না করেই কন্ট্র্যাক্টটি “আপগ্রেড” করেছেন।

[কন্ট্র্যাক্ট আপগ্রেড করার বিষয়ে আরও জানুন](/developers/docs/smart-contracts/upgrading/)।

#### জরুরী স্টপ {#emergency-stops}

যেমন উল্লেখ করা হয়েছে, ব্যাপক অডিটিং এবং টেস্টিং সম্ভবত একটি স্মার্ট কন্ট্র্যাক্টের সমস্ত বাগ আবিষ্কার করতে পারে না। ডিপ্লয়মেন্টের পরে যদি আপনার কোডে কোনো দুর্বলতা দেখা দেয়, তবে এটি প্যাচ করা অসম্ভব কারণ আপনি কন্ট্র্যাক্ট অ্যাড্রেসে চলমান কোড পরিবর্তন করতে পারবেন না। এছাড়াও, আপগ্রেড মেকানিজম (যেমন, প্রক্সি প্যাটার্ন) বাস্তবায়ন করতে সময় লাগতে পারে (এগুলোর জন্য প্রায়শই বিভিন্ন পক্ষের অনুমোদন প্রয়োজন হয়), যা শুধুমাত্র অ্যাটাকারদের আরও বেশি ক্ষতি করার জন্য আরও সময় দেয়।

চূড়ান্ত বিকল্প হলো একটি “জরুরী স্টপ” ফাংশন বাস্তবায়ন করা যা একটি কন্ট্র্যাক্টে দুর্বল ফাংশনে কল ব্লক করে। জরুরী স্টপগুলোতে সাধারণত নিম্নলিখিত উপাদানগুলো থাকে:

1. একটি গ্লোবাল বুলিয়ান ভ্যারিয়েবল যা নির্দেশ করে স্মার্ট কন্ট্র্যাক্টটি বন্ধ স্টেটে আছে কি না। কন্ট্র্যাক্ট সেট আপ করার সময় এই ভ্যারিয়েবলটি `false` তে সেট করা হয়, কিন্তু কন্ট্র্যাক্টটি বন্ধ হয়ে গেলে এটি `true` তে রিভার্ট হবে।

2. ফাংশনগুলো যা তাদের এক্সিকিউশনে বুলিয়ান ভ্যারিয়েবলকে রেফারেন্স করে। এই ধরনের ফাংশনগুলো তখন অ্যাক্সেসযোগ্য হয় যখন স্মার্ট কন্ট্র্যাক্টটি বন্ধ থাকে না, এবং যখন জরুরী স্টপ বৈশিষ্ট্যটি ট্রিগার করা হয় তখন অ্যাক্সেসযোগ্য থাকে না।

3. একটি সত্তা যার জরুরী স্টপ ফাংশনে অ্যাক্সেস আছে, যা বুলিয়ান ভ্যারিয়েবলকে `true` তে সেট করে। ক্ষতিকারক অ্যাকশন প্রতিরোধ করার জন্য, এই ফাংশনে কল একটি বিশ্বস্ত অ্যাড্রেসে (যেমন, কন্ট্র্যাক্টের মালিক) সীমাবদ্ধ করা যেতে পারে।

একবার কন্ট্র্যাক্ট জরুরী স্টপ সক্রিয় করলে, নির্দিষ্ট ফাংশনগুলো কলযোগ্য হবে না। এটি গ্লোবাল ভ্যারিয়েবলকে রেফারেন্স করে এমন একটি মডিফায়ারে নির্বাচিত ফাংশনগুলো র‍্যাপ করে অর্জন করা হয়। নীচে [একটি উদাহরণ](https://github.com/fravoll/solidity-patterns/blob/master/EmergencyStop/EmergencyStop.sol) দেওয়া হল যা কন্ট্র্যাক্টে এই প্যাটার্নের একটি বাস্তবায়ন বর্ণনা করে:

```solidity
// This code has not been professionally audited and makes no promises about safety or correctness. Use at your own risk.

contract EmergencyStop {

    bool isStopped = false;

    modifier stoppedInEmergency {
        require(!isStopped);
        _;
    }

    modifier onlyWhenStopped {
        require(isStopped);
        _;
    }

    modifier onlyAuthorized {
        // Check for authorization of msg.sender here
        _;
    }

    function stopContract() public onlyAuthorized {
        isStopped = true;
    }

    function resumeContract() public onlyAuthorized {
        isStopped = false;
    }

    function deposit() public payable stoppedInEmergency {
        // Deposit logic happening here
    }

    function emergencyWithdraw() public onlyWhenStopped {
        // Emergency withdraw happening here
    }
}
```

এই উদাহরণটি জরুরী স্টপের মৌলিক বৈশিষ্ট্যগুলো দেখায়:

- `isStopped` একটি বুলিয়ান যা শুরুতে `false` এবং কন্ট্র্যাক্ট জরুরী মোডে প্রবেশ করলে `true` তে মূল্যায়ন করে।

- ফাংশন মডিফায়ার `onlyWhenStopped` এবং `stoppedInEmergency` `isStopped` ভ্যারিয়েবলটি চেক করে। `stoppedInEmergency` সেই ফাংশনগুলো নিয়ন্ত্রণ করতে ব্যবহৃত হয় যা কন্ট্র্যাক্ট দুর্বল হলে অ্যাক্সেসযোগ্য হওয়া উচিত নয় (যেমন, `deposit()`)। এই ফাংশনগুলোতে কলগুলো কেবল রিভার্ট হবে।

`onlyWhenStopped` সেই ফাংশনগুলোর জন্য ব্যবহৃত হয় যা জরুরী অবস্থায় কলযোগ্য হওয়া উচিত (যেমন, `emergencyWithdraw()`)। এই ধরনের ফাংশনগুলো পরিস্থিতি সমাধানে সাহায্য করতে পারে, তাই “সীমাবদ্ধ ফাংশন” তালিকা থেকে তাদের বাদ দেওয়া হয়েছে।

একটি জরুরী স্টপ ফাংশনালিটি ব্যবহার করা আপনার স্মার্ট কন্ট্র্যাক্টে গুরুতর দুর্বলতাগুলোর সাথে মোকাবিলা করার জন্য একটি কার্যকর স্টপগ্যাপ প্রদান করে। যাইহোক, এটি ব্যবহারকারীদের ডেভেলপারদের উপর বিশ্বাস করার প্রয়োজন বাড়িয়ে দেয় যে তারা স্বার্থপর কারণে এটি সক্রিয় করবে না। এই লক্ষ্যে, একটি অনচেন ভোটিং মেকানিজম, টাইমলক, বা একটি মাল্টিসিগ ওয়ালেট থেকে অনুমোদনের মাধ্যমে জরুরী স্টপের নিয়ন্ত্রণ ডিসেন্ট্রালাইজ করা সম্ভাব্য সমাধান।

#### ইভেন্ট মনিটরিং {#event-monitoring}

[ইভেন্টস](https://docs.soliditylang.org/en/v0.8.15/contracts.html#events) আপনাকে স্মার্ট কন্ট্র্যাক্ট ফাংশনে কল ট্র্যাক করতে এবং স্টেট ভ্যারিয়েবলের পরিবর্তনগুলো নিরীক্ষণ করতে দেয়। আপনার স্মার্ট কন্ট্র্যাক্টকে এমনভাবে প্রোগ্রাম করা আদর্শ যে যখনই কোনো পক্ষ একটি নিরাপত্তা-গুরুত্বপূর্ণ অ্যাকশন নেয় (যেমন, ফান্ড উইথড্র করা) তখন এটি একটি ইভেন্ট নির্গত করে।

ইভেন্টগুলো লগ করা এবং অফচেইনে সেগুলোকে মনিটর করা কন্ট্র্যাক্ট অপারেশনের উপর অন্তর্দৃষ্টি প্রদান করে এবং ক্ষতিকারক অ্যাকশনগুলোর দ্রুত আবিষ্কারে সহায়তা করে। এর মানে হল আপনার দল হ্যাকের বিরুদ্ধে দ্রুত প্রতিক্রিয়া জানাতে পারে এবং ব্যবহারকারীদের উপর প্রভাব কমাতে পদক্ষেপ নিতে পারে, যেমন ফাংশন পজ করা বা একটি আপগ্রেড সম্পাদন করা।

আপনি একটি অফ-দ্য-শেল্ফ মনিটরিং টুলের জন্যও বেছে নিতে পারেন যা যখনই কেউ আপনার কন্ট্র্যাক্টগুলোর সাথে ইন্টারঅ্যাক্ট করে তখন স্বয়ংক্রিয়ভাবে অ্যালার্ট ফরওয়ার্ড করে। এই টুলসগুলো আপনাকে বিভিন্ন ট্রিগারের উপর ভিত্তি করে কাস্টম অ্যালার্ট তৈরি করতে দেবে, যেমন লেনদেনের পরিমাণ, ফাংশন কলের ফ্রিকোয়েন্সি, বা জড়িত নির্দিষ্ট ফাংশন। উদাহরণস্বরূপ, আপনি একটি অ্যালার্ট প্রোগ্রাম করতে পারেন যা একটি একক লেনদেনে উইথড্র করা পরিমাণ একটি নির্দিষ্ট থ্রেশহোল্ড অতিক্রম করলে আসে।

### ৭. সুরক্ষিত গভর্নেন্স সিস্টেম ডিজাইন করুন {#design-secure-governance-systems}

আপনি আপনার অ্যাপ্লিকেশনকে ডিসেন্ট্রালাইজড করতে চাইতে পারেন কমিউনিটির সদস্যদের কাছে কোর স্মার্ট কন্ট্র্যাক্টগুলোর নিয়ন্ত্রণ হস্তান্তর করে। এই ক্ষেত্রে, স্মার্ট কন্ট্র্যাক্ট সিস্টেমে একটি গভর্নেন্স মডিউল অন্তর্ভুক্ত থাকবে—একটি মেকানিজম যা কমিউনিটির সদস্যদের একটি অনচেন গভর্নেন্স সিস্টেমের মাধ্যমে প্রশাসনিক অ্যাকশন অনুমোদন করতে দেয়। উদাহরণস্বরূপ, একটি প্রক্সি কন্ট্র্যাক্টকে একটি নতুন ইমপ্লিমেন্টেশনে আপগ্রেড করার একটি প্রস্তাব টোকেন-হোল্ডারদের দ্বারা ভোট দেওয়া হতে পারে।

ডিসেন্ট্রালাইজড গভর্নেন্স উপকারী হতে পারে, বিশেষ করে কারণ এটি ডেভেলপার এবং শেষ-ব্যবহারকারীদের স্বার্থকে একত্রিত করে। তা সত্ত্বেও, স্মার্ট কন্ট্র্যাক্ট গভর্নেন্স মেকানিজম ভুলভাবে বাস্তবায়িত হলে নতুন ঝুঁকি তৈরি করতে পারে। একটি সম্ভাব্য দৃশ্য হল যদি একজন অ্যাটাকার একটি [ফ্ল্যাশ লোন](/defi/#flash-loans) নিয়ে বিপুল পরিমাণ ভোটিং পাওয়ার (ধরে রাখা টোকেনের সংখ্যায় পরিমাপ করা) অর্জন করে এবং একটি ক্ষতিকারক প্রস্তাব পাস করিয়ে নেয়।

অনচেন গভর্নেন্স সম্পর্কিত সমস্যা প্রতিরোধের একটি উপায় হল [একটি টাইমলক ব্যবহার করা](https://blog.openzeppelin.com/protect-your-users-with-smart-contract-timelocks/)। একটি টাইমলক একটি স্মার্ট কন্ট্র্যাক্টকে একটি নির্দিষ্ট পরিমাণ সময় অতিবাহিত না হওয়া পর্যন্ত নির্দিষ্ট অ্যাকশন এক্সিকিউট করা থেকে বিরত রাখে। অন্যান্য কৌশলগুলোর মধ্যে রয়েছে প্রতিটি টোকেনের জন্য একটি “ভোটিং ওয়েট” বরাদ্দ করা যা এটি কতক্ষণ ধরে লক করা হয়েছে তার উপর ভিত্তি করে, বা বর্তমান ব্লকের পরিবর্তে একটি ঐতিহাসিক সময়ে (উদাহরণস্বরূপ, অতীতে 2-3 ব্লক) একটি অ্যাড্রেসের ভোটিং পাওয়ার পরিমাপ করা। উভয় পদ্ধতিই অনচেন ভোট প্রভাবিত করার জন্য দ্রুত ভোটিং পাওয়ার জমা করার সম্ভাবনা কমিয়ে দেয়।

শেয়ার করা লিঙ্কগুলোতে [সুরক্ষিত গভর্নেন্স সিস্টেম ডিজাইন করা](https://blog.openzeppelin.com/smart-contract-security-guidelines-4-strategies-for-safer-governance-systems/), [DAO-তে বিভিন্ন ভোটিং মেকানিজম](https://hackernoon.com/governance-is-the-holy-grail-for-daos), এবং [DeFi লিভারেজ করে সাধারণ DAO আক্রমণ ভেক্টর](https://dacian.me/dao-governance-defi-attacks) সম্পর্কে আরও জানুন।

### ৮. কোডের জটিলতা ন্যূনতম পর্যায়ে কমান {#reduce-code-complexity}

ঐতিহ্যবাহী সফটওয়্যার ডেভেলপাররা KISS (“keep it simple, stupid”) নীতির সাথে পরিচিত, যা সফটওয়্যার ডিজাইনে অপ্রয়োজনীয় জটিলতা আনা থেকে বিরত থাকার পরামর্শ দেয়। এটি দীর্ঘদিনের চিন্তাভাবনা অনুসরণ করে যে “জটিল সিস্টেমগুলো জটিল উপায়ে ব্যর্থ হয়” এবং ব্যয়বহুল ত্রুটির জন্য বেশি সংবেদনশীল।

স্মার্ট কন্ট্র্যাক্ট লেখার সময় জিনিসগুলো সহজ রাখা বিশেষভাবে গুরুত্বপূর্ণ, কারণ স্মার্ট কন্ট্র্যাক্টগুলো সম্ভাব্যভাবে বিপুল পরিমাণ মূল্য নিয়ন্ত্রণ করে। স্মার্ট কন্ট্র্যাক্ট লেখার সময় সরলতা অর্জনের জন্য একটি টিপস হল বিদ্যমান লাইব্রেরি, যেমন [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/), যেখানে সম্ভব সেখানে পুনরায় ব্যবহার করা। যেহেতু এই লাইব্রেরিগুলো ডেভেলপারদের দ্বারা ব্যাপকভাবে অডিট এবং পরীক্ষা করা হয়েছে, তাই এগুলো ব্যবহার করলে স্ক্র্যাচ থেকে নতুন ফাংশনালিটি লিখে বাগ আনার সম্ভাবনা কমে যায়।

আরেকটি সাধারণ পরামর্শ হল ছোট ফাংশন লেখা এবং একাধিক কন্ট্র্যাক্টে ব্যবসায়িক লজিক বিভক্ত করে কন্ট্র্যাক্টগুলোকে মডুলার রাখা। সহজ কোড লেখা কেবল একটি স্মার্ট কন্ট্র্যাক্টে আক্রমণের পৃষ্ঠকে কমায় না, এটি সামগ্রিক সিস্টেমের সঠিকতা সম্পর্কে যুক্তি দেওয়া এবং সম্ভাব্য ডিজাইনের ত্রুটিগুলো তাড়াতাড়ি সনাক্ত করা সহজ করে তোলে।

### ৯. সাধারণ স্মার্ট কন্ট্র্যাক্ট দুর্বলতার বিরুদ্ধে প্রতিরক্ষা করুন {#mitigate-common-smart-contract-vulnerabilities}

#### রিএন্ট্রেন্সি {#reentrancy}

EVM কনকারেন্সি অনুমতি দেয় না, যার মানে একটি মেসেজ কলে জড়িত দুটি কন্ট্র্যাক্ট একযোগে চলতে পারে না। একটি এক্সটার্নাল কল কলিং কন্ট্র্যাক্টের এক্সিকিউশন এবং মেমরিকে কলটি ফিরে না আসা পর্যন্ত পজ করে, যার পরে এক্সিকিউশন স্বাভাবিকভাবে চলতে থাকে। এই প্রক্রিয়াটিকে আনুষ্ঠানিকভাবে অন্য কন্ট্র্যাক্টে [কন্ট্রোল ফ্লো](https://www.computerhope.com/jargon/c/contflow.htm) স্থানান্তর হিসাবে বর্ণনা করা যেতে পারে।

যদিও বেশিরভাগ ক্ষেত্রে এটি ক্ষতিকারক নয়, অবিশ্বস্ত কন্ট্র্যাক্টে কন্ট্রোল ফ্লো স্থানান্তর করা সমস্যা তৈরি করতে পারে, যেমন রিএন্ট্রেন্সি। একটি রিএন্ট্রেন্সি অ্যাটাক ঘটে যখন একটি ক্ষতিকারক কন্ট্র্যাক্ট মূল ফাংশন ইনভোকেশন সম্পূর্ণ হওয়ার আগে একটি দুর্বল কন্ট্র্যাক্টে আবার কল করে। এই ধরনের অ্যাটাক একটি উদাহরণের মাধ্যমে সবচেয়ে ভালো ব্যাখ্যা করা যায়।

একটি সাধারণ স্মার্ট কন্ট্র্যাক্ট (‘ভিকটিম’) বিবেচনা করুন যা যে কাউকে ইথার জমা এবং উইথড্র করতে দেয়:

```solidity
// This contract is vulnerable. Do not use in production

contract Victim {
    mapping (address => uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw() external {
        uint256 amount = balances[msg.sender];
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

এই কন্ট্র্যাক্টটি ব্যবহারকারীদের কন্ট্র্যাক্টে পূর্বে জমা করা ETH উইথড্র করার জন্য একটি `withdraw()` ফাংশন প্রকাশ করে। উইথড্রয়াল প্রসেস করার সময়, কন্ট্র্যাক্টটি নিম্নলিখিত অপারেশনগুলো সম্পাদন করে:

1. ব্যবহারকারীর ETH ব্যালেন্স চেক করে
2. কলিং অ্যাড্রেসে ফান্ড পাঠায়
3. তাদের ব্যালেন্স 0 এ রিসেট করে, ব্যবহারকারীর কাছ থেকে অতিরিক্ত উইথড্রয়াল প্রতিরোধ করে

`Victim` কন্ট্র্যাক্টে `withdraw()` ফাংশনটি একটি “চেক-ইন্টারঅ্যাকশন-ইফেক্টস” প্যাটার্ন অনুসরণ করে। এটি _চেক_ করে যে এক্সিকিউশনের জন্য প্রয়োজনীয় শর্তগুলো পূরণ হয়েছে কিনা (যেমন, ব্যবহারকারীর একটি পজিটিভ ETH ব্যালেন্স আছে) এবং লেনদেনের _ইফেক্টস_ প্রয়োগ করার আগে (যেমন, ব্যবহারকারীর ব্যালেন্স কমানো) কলারের অ্যাড্রেসে ETH পাঠিয়ে _ইন্টারঅ্যাকশন_ সম্পাদন করে।

যদি `withdraw()` একটি এক্সটার্নালি ওনড অ্যাকাউন্ট (EOA) থেকে কল করা হয়, তবে ফাংশনটি প্রত্যাশিতভাবে এক্সিকিউট হয়: `msg.sender.call.value()` কলারকে ETH পাঠায়। যাইহোক, যদি `msg.sender` একটি স্মার্ট কন্ট্র্যাক্ট অ্যাকাউন্ট হয় যা `withdraw()` কল করে, তবে `msg.sender.call.value()` ব্যবহার করে ফান্ড পাঠানো সেই অ্যাড্রেসে সংরক্ষিত কোডকেও ট্রিগার করবে।

কল্পনা করুন এটি কন্ট্র্যাক্ট অ্যাড্রেসে ডিপ্লয় করা কোড:

```solidity
 contract Attacker {
    function beginAttack() external payable {
        Victim(victim_address).deposit.value(1 ether)();
        Victim(victim_address).withdraw();
    }

    function() external payable {
        if (gasleft() > 40000) {
            Victim(victim_address).withdraw();
        }
    }
}
```

এই কন্ট্র্যাক্টটি তিনটি জিনিস করার জন্য ডিজাইন করা হয়েছে:

1. অন্য একটি অ্যাকাউন্ট থেকে একটি ডিপোজিট গ্রহণ করা (সম্ভবত অ্যাটাকারের EOA)
2. ভিকটিম কন্ট্র্যাক্টে 1 ETH জমা করা
3. স্মার্ট কন্ট্র্যাক্টে সংরক্ষিত 1 ETH উইথড্র করা

এখানে কোনো ভুল নেই, শুধুমাত্র `Attacker`-এর আরেকটি ফাংশন আছে যা `Victim`-এ আবার `withdraw()` কল করে যদি ইনকামিং `msg.sender.call.value` থেকে অবশিষ্ট গ্যাস 40,000 এর বেশি হয়। এটি `Attacker` কে `Victim`-এ পুনরায় প্রবেশ করার এবং `withdraw`-এর প্রথম ইনভোকেশন সম্পূর্ণ হওয়ার _আগে_ আরও ফান্ড উইথড্র করার ক্ষমতা দেয়। চক্রটি দেখতে এইরকম:

```solidity
- Attacker's EOA calls `Attacker.beginAttack()` with 1 ETH
- `Attacker.beginAttack()` deposits 1 ETH into `Victim`
- `Attacker` calls `withdraw() in `Victim`
- `Victim` checks `Attacker`’s balance (1 ETH)
- `Victim` sends 1 ETH to `Attacker` (which triggers the default function)
- `Attacker` calls `Victim.withdraw()` again (note that `Victim` hasn’t reduced `Attacker`’s balance from the first withdrawal)
- `Victim` checks `Attacker`’s balance (which is still 1 ETH because it hasn’t applied the effects of the first call)
- `Victim` sends 1 ETH to `Attacker` (which triggers the default function and allows `Attacker` to reenter the `withdraw` function)
- The process repeats until `Attacker` runs out of gas, at which point `msg.sender.call.value` returns without triggering additional withdrawals
- `Victim` finally applies the results of the first transaction (and subsequent ones) to its state, so `Attacker`’s balance is set to 0
```

সারাংশ হল যে যেহেতু ফাংশন এক্সিকিউশন সম্পূর্ণ না হওয়া পর্যন্ত কলারের ব্যালেন্স 0 এ সেট করা হয় না, তাই পরবর্তী ইনভোকেশনগুলো সফল হবে এবং কলারকে তাদের ব্যালেন্স একাধিকবার উইথড্র করতে দেবে। এই ধরনের অ্যাটাক একটি স্মার্ট কন্ট্র্যাক্টকে তার ফান্ড থেকে খালি করার জন্য ব্যবহার করা যেতে পারে, যেমনটি [2016 সালের DAO হ্যাক](https://www.coindesk.com/learn/understanding-the-dao-attack)-এ হয়েছিল। রিএন্ট্রেন্সি অ্যাটাক এখনও স্মার্ট কন্ট্র্যাক্টগুলোর জন্য একটি গুরুতর সমস্যা যেমন [রিএন্ট্রেন্সি এক্সপ্লয়েটের পাবলিক তালিকা](https://github.com/pcaversaccio/reentrancy-attacks) দেখায়।

##### কিভাবে রিএন্ট্রেন্সি অ্যাটাক প্রতিরোধ করা যায়

রিএন্ট্রেন্সির সাথে মোকাবিলা করার একটি পদ্ধতি হল [চেক-ইফেক্টস-ইন্টারঅ্যাকশন প্যাটার্ন](https://docs.soliditylang.org/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern) অনুসরণ করা। এই প্যাটার্নটি ফাংশনগুলোর এক্সিকিউশনকে এমনভাবে অর্ডার করে যে এক্সিকিউশন এগিয়ে যাওয়ার আগে প্রয়োজনীয় চেক সম্পাদনকারী কোডটি প্রথমে আসে, তারপরে কন্ট্র্যাক্ট স্টেট ম্যানিপুলেটকারী কোড, এবং শেষে অন্য কন্ট্র্যাক্ট বা EOA-এর সাথে ইন্টারঅ্যাক্টকারী কোড আসে।

চেক-ইফেক্ট-ইন্টারঅ্যাকশন প্যাটার্নটি `Victim` কন্ট্র্যাক্টের একটি সংশোধিত সংস্করণে ব্যবহার করা হয়েছে যা নীচে দেখানো হয়েছে:

```solidity
contract NoLongerAVictim {
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call.value(amount)("");
        require(success);
    }
}
```

এই কন্ট্র্যাক্টটি ব্যবহারকারীর ব্যালেন্সের উপর একটি _চেক_ সম্পাদন করে, `withdraw()` ফাংশনের _ইফেক্টস_ প্রয়োগ করে (ব্যবহারকারীর ব্যালেন্স 0 এ রিসেট করে), এবং _ইন্টারঅ্যাকশন_ সম্পাদনের দিকে অগ্রসর হয় (ব্যবহারকারীর অ্যাড্রেসে ETH পাঠানো)। এটি নিশ্চিত করে যে কন্ট্র্যাক্টটি এক্সটার্নাল কলের আগে তার স্টোরেজ আপডেট করে, যা প্রথম অ্যাটাক সক্ষমকারী রি-এন্ট্রেন্সি শর্তটি দূর করে। `Attacker` কন্ট্র্যাক্টটি এখনও `NoLongerAVictim`-এ আবার কল করতে পারে, কিন্তু যেহেতু `balances[msg.sender]` 0 এ সেট করা হয়েছে, তাই অতিরিক্ত উইথড্রয়াল একটি ত্রুটি নিক্ষেপ করবে।

আরেকটি বিকল্প হল একটি মিউচুয়াল এক্সক্লুশন লক (সাধারণত "মিউটেক্স" হিসাবে বর্ণিত) ব্যবহার করা যা একটি ফাংশন ইনভোকেশন সম্পূর্ণ না হওয়া পর্যন্ত একটি কন্ট্র্যাক্টের স্টেটের একটি অংশ লক করে। এটি একটি বুলিয়ান ভ্যারিয়েবল ব্যবহার করে বাস্তবায়িত হয় যা ফাংশন এক্সিকিউট হওয়ার আগে `true` তে সেট করা হয় এবং ইনভোকেশন শেষ হওয়ার পরে `false` তে ফিরে আসে। নীচের উদাহরণে যেমন দেখা যায়, একটি মিউটেক্স ব্যবহার করা একটি ফাংশনকে রিকার্সিভ কল থেকে রক্ষা করে যখন মূল ইনভোকেশন এখনও প্রসেস হচ্ছে, কার্যকরভাবে রিএন্ট্রেন্সি বন্ধ করে।

```solidity
pragma solidity ^0.7.0;

contract MutexPattern {
    bool locked = false;
    mapping(address => uint256) public balances;

    modifier noReentrancy() {
        require(!locked, "Blocked from reentrancy.");
        locked = true;
        _;
        locked = false;
    }
    // This function is protected by a mutex, so reentrant calls from within `msg.sender.call` cannot call `withdraw` again.
    //  The `return` statement evaluates to `true` but still evaluates the `locked = false` statement in the modifier
    function withdraw(uint _amount) public payable noReentrancy returns(bool) {
        require(balances[msg.sender] >= _amount, "No balance to withdraw.");

        balances[msg.sender] -= _amount;
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success);

        return true;
    }
}
```

আপনি একটি [পুল পেমেন্টস](https://docs.openzeppelin.com/contracts/5.x/api/security#PullPayment) সিস্টেমও ব্যবহার করতে পারেন যা ব্যবহারকারীদের স্মার্ট কন্ট্র্যাক্ট থেকে ফান্ড উইথড্র করতে বলে, "পুশ পেমেন্টস" সিস্টেমের পরিবর্তে যা অ্যাকাউন্টগুলোতে ফান্ড পাঠায়। এটি অজানা অ্যাড্রেসে অনিচ্ছাকৃতভাবে কোড ট্রিগার করার সম্ভাবনা দূর করে (এবং নির্দিষ্ট ডিনায়াল-অফ-সার্ভিস অ্যাটাকও প্রতিরোধ করতে পারে)।

#### পূর্ণসংখ্যা আন্ডারফ্লো এবং ওভারফ্লো {#integer-underflows-and-overflows}

একটি পূর্ণসংখ্যা ওভারফ্লো ঘটে যখন একটি গাণিতিক অপারেশনের ফলাফল মানের গ্রহণযোগ্য পরিসরের বাইরে চলে যায়, যার ফলে এটি সর্বনিম্ন প্রতিনিধিত্বযোগ্য মানে "রোল ওভার" করে। উদাহরণস্বরূপ, একটি `uint8` শুধুমাত্র 2^8-1=255 পর্যন্ত মান সংরক্ষণ করতে পারে। `255` এর চেয়ে বেশি মানের গাণিতিক অপারেশনগুলো ওভারফ্লো হবে এবং `uint`-কে `0` এ রিসেট করবে, যেমন একটি গাড়ির ওডোমিটার সর্বোচ্চ মাইলেজ (999999) পৌঁছানোর পরে 0 এ রিসেট হয়।

পূর্ণসংখ্যা আন্ডারফ্লো অনুরূপ কারণে ঘটে: একটি গাণিতিক অপারেশনের ফলাফল গ্রহণযোগ্য পরিসরের নীচে চলে যায়। ধরুন আপনি একটি `uint8`-এ `0` ডিক্রিমেন্ট করার চেষ্টা করেছেন, ফলাফলটি কেবল সর্বোচ্চ প্রতিনিধিত্বযোগ্য মানে (`255`) রোল ওভার করবে।

পূর্ণসংখ্যা ওভারফ্লো এবং আন্ডারফ্লো উভয়ই একটি কন্ট্র্যাক্টের স্টেট ভ্যারিয়েবলে অপ্রত্যাশিত পরিবর্তন ঘটাতে পারে এবং অপরিকল্পিত এক্সিকিউশনের কারণ হতে পারে। নীচে একটি উদাহরণ দেখানো হয়েছে যা দেখায় কিভাবে একজন অ্যাটাকার একটি স্মার্ট কন্ট্র্যাক্টে গাণিতিক ওভারফ্লো ব্যবহার করে একটি অবৈধ অপারেশন সম্পাদন করতে পারে:

```
pragma solidity ^0.7.6;

// This contract is designed to act as a time vault.
// User can deposit into this contract but cannot withdraw for at least a week.
// User can also extend the wait time beyond the 1 week waiting period.

/*
1. Deploy TimeLock
2. Deploy Attack with address of TimeLock
3. Call Attack.attack sending 1 ether. You will immediately be able to
   withdraw your ether.

What happened?
Attack caused the TimeLock.lockTime to overflow and was able to withdraw
before the 1 week waiting period.
*/

contract TimeLock {
    mapping(address => uint) public balances;
    mapping(address => uint) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "Insufficient funds");
        require(block.timestamp > lockTime[msg.sender], "Lock time not expired");

        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Failed to send Ether");
    }
}

contract Attack {
    TimeLock timeLock;

    constructor(TimeLock _timeLock) {
        timeLock = TimeLock(_timeLock);
    }

    fallback() external payable {}

    function attack() public payable {
        timeLock.deposit{value: msg.value}();
        /*
        if t = current lock time then we need to find x such that
        x + t = 2**256 = 0
        so x = -t
        2**256 = type(uint).max + 1
        so x = type(uint).max + 1 - t
        */
        timeLock.increaseLockTime(
            type(uint).max + 1 - timeLock.lockTime(address(this))
        );
        timeLock.withdraw();
    }
}
```

##### কিভাবে পূর্ণসংখ্যা আন্ডারফ্লো এবং ওভারফ্লো প্রতিরোধ করা যায়

ভার্সন 0.8.0 থেকে, Solidity কম্পাইলার সেই কোড প্রত্যাখ্যান করে যা পূর্ণসংখ্যা আন্ডারফ্লো এবং ওভারফ্লো ঘটায়। যাইহোক, একটি নিম্ন কম্পাইলার সংস্করণ দিয়ে কম্পাইল করা কন্ট্র্যাক্টগুলোতে হয় গাণিতিক অপারেশন জড়িত ফাংশনগুলোতে চেক সম্পাদন করা উচিত অথবা একটি লাইব্রেরি (যেমন, [SafeMath](https://docs.openzeppelin.com/contracts/2.x/api/math)) ব্যবহার করা উচিত যা আন্ডারফ্লো/ওভারফ্লো জন্য চেক করে।

#### ওরাকল ম্যানিপুলেশন {#oracle-manipulation}

[ওরাকলস](/developers/docs/oracles/) অফচেন তথ্য উৎস করে এবং স্মার্ট কন্ট্র্যাক্ট ব্যবহারের জন্য অনচেইনে পাঠায়। ওরাকলের সাহায্যে, আপনি এমন স্মার্ট কন্ট্র্যাক্ট ডিজাইন করতে পারেন যা অফচেন সিস্টেমের সাথে ইন্টারঅপারেট করে, যেমন মূলধনের বাজার, যা তাদের অ্যাপ্লিকেশনকে ব্যাপকভাবে প্রসারিত করে।

কিন্তু যদি ওরাকলটি দুর্নীতিগ্রস্ত হয় এবং অনচেইনে ভুল তথ্য পাঠায়, স্মার্ট কন্ট্র্যাক্টগুলো ভুল ইনপুটের উপর ভিত্তি করে এক্সিকিউট হবে, যা সমস্যা সৃষ্টি করতে পারে। এটি “ওরাকল সমস্যা”র ভিত্তি, যা একটি ব্লকচেইন ওরাকল থেকে তথ্য সঠিক, আপ-টু-ডেট এবং সময়মত কিনা তা নিশ্চিত করার কাজ নিয়ে উদ্বিগ্ন।

একটি সম্পর্কিত নিরাপত্তা উদ্বেগ হল একটি অনচেন ওরাকল, যেমন একটি ডিসেন্ট্রালাইজড এক্সচেঞ্জ, ব্যবহার করে একটি সম্পদের স্পট মূল্য পাওয়া। [ডিসেন্ট্রালাইজড ফাইন্যান্স (DeFi)](/defi/) শিল্পের লেন্ডিং প্ল্যাটফর্মগুলো প্রায়শই এটি করে ব্যবহারকারীর কোল্যাটেরালের মূল্য নির্ধারণ করতে, যাতে তারা কতটুকু ধার নিতে পারবে তা নির্ধারণ করা যায়।

DEX মূল্য প্রায়শই সঠিক হয়, মূলত আরবিট্রেজররা বাজারে প্যারিটি পুনরুদ্ধার করার কারণে। যাইহোক, তারা ম্যানিপুলেশনের জন্য উন্মুক্ত, বিশেষ করে যদি অনচেন ওরাকল ঐতিহাসিক ট্রেডিং প্যাটার্নের উপর ভিত্তি করে সম্পদের মূল্য গণনা করে (যেমনটি সাধারণত হয়)।

উদাহরণস্বরূপ, একজন অ্যাটাকার আপনার লেন্ডিং কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করার ঠিক আগে একটি ফ্ল্যাশ লোন নিয়ে একটি সম্পদের স্পট মূল্য কৃত্রিমভাবে পাম্প করতে পারে। সম্পদের মূল্যের জন্য DEX-কে কোয়েরি করলে একটি স্বাভাবিকের চেয়ে বেশি মান ফেরত আসবে (অ্যাটাকারের বড় “ক্রয় অর্ডার” সম্পদের চাহিদা বিকৃত করার কারণে), যা তাদের প্রয়োজনের চেয়ে বেশি ধার নিতে দেয়। এই ধরনের "ফ্ল্যাশ লোন অ্যাটাক" DeFi অ্যাপ্লিকেশনগুলোর মধ্যে মূল্য ওরাকলের উপর নির্ভরতা কাজে লাগাতে ব্যবহার করা হয়েছে, যা প্রোটোকলগুলোকে লক্ষ লক্ষ ডলারের ফান্ড হারিয়েছে।

##### কিভাবে ওরাকল ম্যানিপুলেশন প্রতিরোধ করা যায়

[ওরাকল ম্যানিপুলেশন এড়ানোর](https://www.cyfrin.io/blog/price-oracle-manipultion-attacks-with-examples) জন্য ন্যূনতম প্রয়োজনীয়তা হল একটি ডিসেন্ট্রালাইজড ওরাকল নেটওয়ার্ক ব্যবহার করা যা একাধিক উৎস থেকে তথ্য কোয়েরি করে যাতে সিঙ্গেল পয়েন্ট অফ ফেলিওর এড়ানো যায়। বেশিরভাগ ক্ষেত্রে, ডিসেন্ট্রালাইজড ওরাকলগুলোতে বিল্ট-ইন ক্রিপ্টোইকোনমিক ইনসেনটিভ থাকে যা ওরাকল নোডগুলোকে সঠিক তথ্য রিপোর্ট করতে উৎসাহিত করে, যা তাদের সেন্ট্রালাইজড ওরাকলের চেয়ে বেশি সুরক্ষিত করে তোলে।

যদি আপনি সম্পদের মূল্যের জন্য একটি অনচেন ওরাকল কোয়েরি করার পরিকল্পনা করেন, তবে এমন একটি ব্যবহার করার কথা বিবেচনা করুন যা একটি টাইম-ওয়েটেড অ্যাভারেজ প্রাইস (TWAP) মেকানিজম বাস্তবায়ন করে। একটি [TWAP ওরাকল](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles) দুটি ভিন্ন সময়ে (যা আপনি পরিবর্তন করতে পারেন) একটি সম্পদের মূল্য কোয়েরি করে এবং প্রাপ্ত গড়ের উপর ভিত্তি করে স্পট মূল্য গণনা করে। দীর্ঘ সময়কাল বেছে নেওয়া আপনার প্রোটোকলকে মূল্য ম্যানিপুলেশন থেকে রক্ষা করে কারণ সম্প্রতি এক্সিকিউট করা বড় অর্ডারগুলো সম্পদের মূল্যকে প্রভাবিত করতে পারে না।

## ডেভেলপারদের জন্য স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা রিসোর্স {#smart-contract-security-resources-for-developers}

### স্মার্ট কন্ট্র্যাক্ট বিশ্লেষণ এবং কোডের সঠিকতা যাচাই করার জন্য টুলস {#code-analysis-tools}

- **[টেস্টিং টুলস এবং লাইব্রেরি](/developers/docs/smart-contracts/testing/#testing-tools-and-libraries)** - _স্মার্ট কন্ট্র্যাক্টে ইউনিট টেস্ট, স্ট্যাটিক বিশ্লেষণ এবং ডাইনামিক বিশ্লেষণ সম্পাদনের জন্য ইন্ডাস্ট্রি-স্ট্যান্ডার্ড টুলস এবং লাইব্রেরির সংগ্রহ।_

- **[ফর্মাল ভেরিফিকেশন টুলস](/developers/docs/smart-contracts/formal-verification/#formal-verification-tools)** - _স্মার্ট কন্ট্র্যাক্টে ফাংশনাল সঠিকতা যাচাই এবং ইনভ্যারিয়েন্ট চেক করার জন্য টুলস।_

- **[স্মার্ট কন্ট্র্যাক্ট অডিটিং পরিষেবা](/developers/docs/smart-contracts/testing/#smart-contract-auditing-services)** - _ইথেরিয়াম ডেভেলপমেন্ট প্রজেক্টের জন্য স্মার্ট কন্ট্র্যাক্ট অডিটিং পরিষেবা প্রদানকারী সংস্থাগুলোর তালিকা।_

- **[বাগ বাউন্টি প্ল্যাটফর্ম](/developers/docs/smart-contracts/testing/#bug-bounty-platforms)** - _বাগ বাউন্টি সমন্বয় এবং স্মার্ট কন্ট্র্যাক্টে গুরুতর দুর্বলতার দায়িত্বশীল প্রকাশের জন্য পুরস্কৃত করার প্ল্যাটফর্ম।_

- **[Fork Checker](https://forkchecker.hashex.org/)** - _একটি ফর্ক করা কন্ট্র্যাক্ট সম্পর্কিত সমস্ত উপলব্ধ তথ্য পরীক্ষা করার জন্য একটি বিনামূল্যের অনলাইন টুল।_

- **[ABI Encoder](https://abi.hashex.org/)** - _আপনার Solidity কন্ট্র্যাক্ট ফাংশন এবং কনস্ট্রাক্টর আর্গুমেন্ট এনকোড করার জন্য একটি বিনামূল্যের অনলাইন পরিষেবা।_

- **[Aderyn](https://github.com/Cyfrin/aderyn)** - _Solidity স্ট্যাটিক অ্যানালাইজার, অ্যাবস্ট্রাক্ট সিনট্যাক্স ট্রি (AST) ট্র্যাভার্স করে সন্দেহজনক দুর্বলতা চিহ্নিত করে এবং সহজে ব্যবহারযোগ্য মার্কডাউন ফরম্যাটে সমস্যাগুলো প্রিন্ট করে।_

### স্মার্ট কন্ট্র্যাক্ট মনিটরিংয়ের জন্য টুলস {#smart-contract-monitoring-tools}

- **[Tenderly রিয়েল-টাইম অ্যালার্টিং](https://tenderly.co/monitoring)** - _আপনার স্মার্ট কন্ট্র্যাক্ট বা ওয়ালেটে অস্বাভাবিক বা অপ্রত্যাশিত ইভেন্ট ঘটলে রিয়েল-টাইম নোটিফিকেশন পাওয়ার জন্য একটি টুল।_

### স্মার্ট কন্ট্র্যাক্টের সুরক্ষিত প্রশাসনের জন্য টুলস {#smart-contract-administration-tools}

- **[Safe](https://safe.global/)** - _ইথেরিয়ামে চলমান স্মার্ট কন্ট্র্যাক্ট ওয়ালেট যার জন্য একটি লেনদেন ঘটার আগে ন্যূনতম সংখ্যক লোকের অনুমোদন প্রয়োজন (M-of-N)।_

- **[OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/)** - _কন্ট্র্যাক্ট মালিকানা, আপগ্রেড, অ্যাক্সেস কন্ট্রোল, গভর্নেন্স, পজেবিলিটি এবং আরও অনেক কিছু সহ প্রশাসনিক বৈশিষ্ট্য বাস্তবায়নের জন্য কন্ট্র্যাক্ট লাইব্রেরি।_

### স্মার্ট কন্ট্র্যাক্ট অডিটিং পরিষেবা {#smart-contract-auditing-services}

- **[ConsenSys Diligence](https://diligence.consensys.io/)** - _স্মার্ট কন্ট্র্যাক্ট অডিটিং পরিষেবা যা ব্লকচেইন ইকোসিস্টেম জুড়ে প্রকল্পগুলোকে তাদের প্রোটোকলগুলো লঞ্চের জন্য প্রস্তুত এবং ব্যবহারকারীদের সুরক্ষার জন্য নির্মিত তা নিশ্চিত করতে সাহায্য করে।_

- **[CertiK](https://www.certik.com/)** - _ব্লকচেইন নিরাপত্তা সংস্থা যা স্মার্ট কন্ট্র্যাক্ট এবং ব্লকচেইন নেটওয়ার্কে অত্যাধুনিক ফর্মাল ভেরিফিকেশন প্রযুক্তির ব্যবহারে অগ্রণী ভূমিকা পালন করছে।_

- **[Trail of Bits](https://www.trailofbits.com/)** - _সাইবারসিকিউরিটি কোম্পানি যা ঝুঁকি কমাতে এবং কোডকে শক্তিশালী করতে নিরাপত্তা গবেষণার সাথে একজন অ্যাটাকারের মানসিকতাকে একত্রিত করে।_

- **[PeckShield](https://peckshield.com/)** - _ব্লকচেইন নিরাপত্তা সংস্থা যা সমগ্র ব্লকচেইন ইকোসিস্টেমের নিরাপত্তা, গোপনীয়তা এবং ব্যবহারযোগ্যতার জন্য পণ্য এবং পরিষেবা সরবরাহ করে।_

- **[QuantStamp](https://quantstamp.com/)** - _নিরাপত্তা এবং ঝুঁকি মূল্যায়ন পরিষেবার মাধ্যমে ব্লকচেইন প্রযুক্তির মূলধারার গ্রহণকে সহজতরকারী অডিটিং পরিষেবা।_

- **[OpenZeppelin](https://www.openzeppelin.com/security-audits)** - _স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা সংস্থা যা ডিস্ট্রিবিউটেড সিস্টেমের জন্য নিরাপত্তা অডিট প্রদান করে।_

- **[Runtime Verification](https://runtimeverification.com/)** - _নিরাপত্তা সংস্থা যা স্মার্ট কন্ট্র্যাক্টের ফর্মাল মডেলিং এবং ভেরিফিকেশনে বিশেষজ্ঞ।_

- **[Hacken](https://hacken.io)** - _ওয়েব3 সাইবারসিকিউরিটি অডিটর যা ব্লকচেইন নিরাপত্তায় ৩৬০-ডিগ্রি পদ্ধতি নিয়ে আসে।_

- **[Nethermind](https://www.nethermind.io/smart-contract-audits)** - _Solidity এবং Cairo অডিটিং পরিষেবা, যা Ethereum এবং Starknet জুড়ে স্মার্ট কন্ট্র্যাক্টের অখণ্ডতা এবং ব্যবহারকারীদের নিরাপত্তা নিশ্চিত করে।_

- **[HashEx](https://hashex.org/)** - _HashEx ব্লকচেইন এবং স্মার্ট কন্ট্র্যাক্ট অডিটিংয়ে ফোকাস করে ক্রিপ্টোকারেন্সির নিরাপত্তা নিশ্চিত করতে, যেমন স্মার্ট কন্ট্র্যাক্ট ডেভেলপমেন্ট, পেনিট্রেশন টেস্টিং, ব্লকচেইন কনসাল্টিং পরিষেবা প্রদান করে।_

- **[Code4rena](https://code4rena.com/)** - _প্রতিযোগিতামূলক অডিট প্ল্যাটফর্ম যা স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা বিশেষজ্ঞদের দুর্বলতা খুঁজে বের করতে এবং ওয়েব3 কে আরও সুরক্ষিত করতে সাহায্য করার জন্য উৎসাহিত করে।_

- **[CodeHawks](https://codehawks.com/)** - _প্রতিযোগিতামূলক অডিট প্ল্যাটফর্ম যা নিরাপত্তা গবেষকদের জন্য স্মার্ট কন্ট্র্যাক্ট অডিটিং প্রতিযোগিতার আয়োজন করে।_

- **[Cyfrin](https://cyfrin.io)** - _ওয়েব3 নিরাপত্তা পাওয়ারহাউস, যা পণ্য এবং স্মার্ট কন্ট্র্যাক্ট অডিটিং পরিষেবার মাধ্যমে ক্রিপ্টো নিরাপত্তাকে ইনকিউবেট করে।_

- **[ImmuneBytes](https://immunebytes.com/smart-contract-audit/)** - _ওয়েব3 নিরাপত্তা সংস্থা যা অভিজ্ঞ অডিটর এবং সেরা-শ্রেণীর টুলসের একটি দলের মাধ্যমে ব্লকচেইন সিস্টেমের জন্য নিরাপত্তা অডিট সরবরাহ করে।_

- **[Oxorio](https://oxor.io/)** - _স্মার্ট কন্ট্র্যাক্ট অডিট এবং ব্লকচেইন নিরাপত্তা পরিষেবা যা EVM, Solidity, ZK, ক্রিপ্টো ফার্ম এবং DeFi প্রকল্পের জন্য ক্রস-চেইন প্রযুক্তিতে বিশেষজ্ঞ।_

- **[Inference](https://inference.ag/)** - _নিরাপত্তা অডিটিং কোম্পানি, যা EVM-ভিত্তিক ব্লকচেইনের জন্য স্মার্ট কন্ট্র্যাক্ট অডিটিংয়ে বিশেষজ্ঞ। এর বিশেষজ্ঞ অডিটরদের ধন্যবাদ, তারা সম্ভাব্য সমস্যাগুলো চিহ্নিত করে এবং ডিপ্লয়মেন্টের আগে সেগুলো সমাধানের জন্য কার্যকর সমাধান প্রস্তাব করে।_

### বাগ বাউন্টি প্ল্যাটফর্ম {#bug-bounty-platforms}

- **[Immunefi](https://immunefi.com/)** - _স্মার্ট কন্ট্র্যাক্ট এবং DeFi প্রকল্পগুলোর জন্য বাগ বাউন্টি প্ল্যাটফর্ম, যেখানে নিরাপত্তা গবেষকরা কোড পর্যালোচনা করে, দুর্বলতা প্রকাশ করে, অর্থ প্রদান পায় এবং ক্রিপ্টোকে আরও নিরাপদ করে তোলে।_

- **[HackerOne](https://www.hackerone.com/)** - _দুর্বলতা সমন্বয় এবং বাগ বাউন্টি প্ল্যাটফর্ম যা ব্যবসাগুলোকে পেনিট্রেশন টেস্টার এবং সাইবারসিকিউরিটি গবেষকদের সাথে সংযুক্ত করে।_

- **[HackenProof](https://hackenproof.com/)** - _ক্রিপ্টো প্রকল্পগুলোর (DeFi, স্মার্ট কন্ট্র্যাক্ট, ওয়ালেট, CEX এবং আরও অনেক কিছু) জন্য বিশেষজ্ঞ বাগ বাউন্টি প্ল্যাটফর্ম, যেখানে নিরাপত্তা পেশাদাররা ট্রায়াজ পরিষেবা প্রদান করে এবং গবেষকরা প্রাসঙ্গিক, যাচাইকৃত বাগ রিপোর্টের জন্য অর্থ প্রদান পায়।_

- **[Sherlock](https://www.sherlock.xyz/)** - _স্মার্ট কন্ট্র্যাক্ট নিরাপত্তার জন্য ওয়েব3-এর আন্ডাররাইটার, যেখানে অডিটরদের জন্য পেআউট স্মার্ট কন্ট্র্যাক্টের মাধ্যমে পরিচালিত হয় যাতে প্রাসঙ্গিক বাগগুলো ন্যায্যভাবে পরিশোধ করা হয় তা নিশ্চিত করা যায়।_

- **[CodeHawks](https://www.codehawks.com/)** - _প্রতিযোগিতামূলক বাগ বাউন্টি প্ল্যাটফর্ম যেখানে অডিটররা নিরাপত্তা প্রতিযোগিতা এবং চ্যালেঞ্জে অংশ নেয় এবং (শীঘ্রই) তাদের নিজস্ব ব্যক্তিগত অডিটে অংশ নেবে।_

### পরিচিত স্মার্ট কন্ট্র্যাক্ট দুর্বলতা এবং এক্সপ্লয়েটের প্রকাশনা {#common-smart-contract-vulnerabilities-and-exploits}

- **[ConsenSys: স্মার্ট কন্ট্র্যাক্টের পরিচিত অ্যাটাক](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/)** - _সবচেয়ে গুরুত্বপূর্ণ কন্ট্র্যাক্ট দুর্বলতার শিক্ষানবিস-বান্ধব ব্যাখ্যা, বেশিরভাগ ক্ষেত্রে স্যাম্পল কোড সহ।_

- **[SWC রেজিস্ট্রি](https://swcregistry.io/)** - _কমন উইকনেস এনুমারেশন (CWE) আইটেমগুলোর একটি কিউরেটেড তালিকা যা ইথেরিয়াম স্মার্ট কন্ট্র্যাক্টে প্রযোজ্য।_

- **[Rekt](https://rekt.news/)** - _নিয়মিতভাবে আপডেট হওয়া উচ্চ-প্রোফাইল ক্রিপ্টো হ্যাক এবং এক্সপ্লয়েটের প্রকাশনা, সাথে বিস্তারিত পোস্ট-মর্টেম রিপোর্ট।_

### স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা শেখার জন্য চ্যালেঞ্জ {#challenges-for-learning-smart-contract-security}

- **[Awesome BlockSec CTF](https://github.com/blockthreat/blocksec-ctfs)** - _ব্লকচেইন নিরাপত্তা ওয়ারগেম, চ্যালেঞ্জ, এবং [ক্যাপচার দ্য ফ্ল্যাগ](https://www.webopedia.com/definitions/ctf-event/amp/) প্রতিযোগিতা এবং সমাধান রাইটআপের একটি কিউরেটেড তালিকা।_

- **[Damn Vulnerable DeFi](https://www.damnvulnerabledefi.xyz/)** - _DeFi স্মার্ট কন্ট্র্যাক্টের আক্রমণাত্মক নিরাপত্তা শেখার এবং বাগ-হান্টিং ও নিরাপত্তা অডিটিংয়ে দক্ষতা তৈরির জন্য ওয়ারগেম।_

- **[Ethernaut](https://ethernaut.openzeppelin.com/)** - _ওয়েব3/Solidity-ভিত্তিক ওয়ারগেম যেখানে প্রতিটি লেভেল একটি স্মার্ট কন্ট্র্যাক্ট যা 'হ্যাক' করতে হবে।_

- **[HackenProof x HackTheBox](https://app.hackthebox.com/tracks/HackenProof-Track)** - _একটি ফ্যান্টাসি অ্যাডভেঞ্চারে সেট করা স্মার্ট কন্ট্র্যাক্ট হ্যাকিং চ্যালেঞ্জ। চ্যালেঞ্জটি সফলভাবে সম্পন্ন করলে একটি ব্যক্তিগত বাগ বাউন্টি প্রোগ্রামে অ্যাক্সেসও পাওয়া যায়।_

### স্মার্ট কন্ট্র্যাক্ট সুরক্ষিত করার জন্য সেরা অনুশীলন {#smart-contract-security-best-practices}

- **[ConsenSys: ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা সেরা অনুশীলন](https://consensys.github.io/smart-contract-best-practices/)** - _ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট সুরক্ষিত করার জন্য নির্দেশাবলীর একটি বিস্তৃত তালিকা।_

- **[Nascent: সিম্পল সিকিউরিটি টুলকিট](https://github.com/nascentxyz/simple-security-toolkit)** - _স্মার্ট কন্ট্র্যাক্ট ডেভেলপমেন্টের জন্য ব্যবহারিক নিরাপত্তা-কেন্দ্রিক গাইড এবং চেকলিস্টের সংগ্রহ।_

- **[Solidity প্যাটার্নস](https://fravoll.github.io/solidity-patterns/)** - _স্মার্ট কন্ট্র্যাক্ট প্রোগ্রামিং ভাষা Solidity-এর জন্য সুরক্ষিত প্যাটার্ন এবং সেরা অনুশীলনের একটি দরকারী সংকলন।_

- **[Solidity ডক্স: নিরাপত্তা বিবেচনা](https://docs.soliditylang.org/en/v0.8.16/security-considerations.html)** - _Solidity দিয়ে সুরক্ষিত স্মার্ট কন্ট্র্যাক্ট লেখার জন্য নির্দেশিকা।_

- **[স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা যাচাইকরণ স্ট্যান্ডার্ড](https://github.com/securing/SCSVS)** - _ডেভেলপার, আর্কিটেক্ট, নিরাপত্তা পর্যালোচক এবং বিক্রেতাদের জন্য স্মার্ট কন্ট্র্যাক্টের নিরাপত্তা মানক করার জন্য তৈরি করা চৌদ্দ-অংশের চেকলিস্ট।_

- **[স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা এবং অডিটিং শিখুন](https://updraft.cyfrin.io/courses/security)** - _চূড়ান্ত স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা এবং অডিটিং কোর্স, যা স্মার্ট কন্ট্র্যাক্ট ডেভেলপারদের জন্য তৈরি করা হয়েছে যারা তাদের নিরাপত্তা সেরা অনুশীলনগুলো উন্নত করতে এবং নিরাপত্তা গবেষক হতে চান।_

### স্মার্ট কন্ট্র্যাক্ট নিরাপত্তার উপর টিউটোরিয়াল {#tutorials-on-smart-contract-security}

- [কিভাবে সুরক্ষিত স্মার্ট কন্ট্র্যাক্ট লিখবেন](/developers/tutorials/secure-development-workflow/)

- [স্মার্ট কন্ট্র্যাক্ট বাগ খুঁজে পেতে কিভাবে Slither ব্যবহার করবেন](/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/)

- [স্মার্ট কন্ট্র্যাক্ট বাগ খুঁজে পেতে কিভাবে Manticore ব্যবহার করবেন](/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/)

- [স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা নির্দেশিকা](/developers/tutorials/smart-contract-security-guidelines/)

- [কিভাবে আপনার টোকেন কন্ট্র্যাক্টকে নির্বিচারে টোকেনগুলোর সাথে নিরাপদে একীভূত করবেন](/developers/tutorials/token-integration-checklist/)

- [সাইফ্রিন আপড্রাফট - স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা এবং অডিটিং সম্পূর্ণ কোর্স](https://updraft.cyfrin.io/courses/security)
