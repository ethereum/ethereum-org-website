---
title: স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করা
description: ইথেরিয়াম স্মার্ট কন্ট্র্যাক্টের জন্য আপগ্রেড প্যাটার্নের একটি সংক্ষিপ্ত বিবরণ
lang: bn
---

ইথেরিয়ামের স্মার্ট কন্ট্র্যাক্ট হলো স্ব-নির্বাহী প্রোগ্রাম যা Ethereum Virtual Machine (EVM)-এ চলে। এই প্রোগ্রামগুলো ডিজাইনের দ্বারা অপরিবর্তনীয়, যা কন্ট্র্যাক্ট স্থাপন করার পরে ব্যবসায়িক যুক্তিতে কোনো আপডেট করা থেকে বিরত রাখে।

যদিও স্মার্ট কন্ট্র্যাক্টের বিশ্বাসহীনতা, বিকেন্দ্রীকরণ এবং নিরাপত্তার জন্য অপরিবর্তনীয়তা প্রয়োজন, এটি কিছু ক্ষেত্রে একটি অসুবিধাও হতে পারে। উদাহরণস্বরূপ, অপরিবর্তনীয় কোড ডেভেলপারদের জন্য দুর্বল কন্ট্র্যাক্ট ঠিক করা অসম্ভব করে তুলতে পারে।

যাইহোক, স্মার্ট কন্ট্র্যাক্ট উন্নত করার জন্য বর্ধিত গবেষণা বেশ কয়েকটি আপগ্রেড প্যাটার্নের প্রচলন ঘটিয়েছে। এই আপগ্রেড প্যাটার্নগুলো ডেভেলপারদের বিভিন্ন কন্ট্র্যাক্টে ব্যবসায়িক যুক্তি স্থাপন করে স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করতে সক্ষম করে (অপরিবর্তনীয়তা সংরক্ষণ করার সাথে সাথে)।

## পূর্বশর্ত {#prerequisites}

আপনার [স্মার্ট কন্ট্র্যাক্ট](/developers/docs/smart-contracts/), [স্মার্ট কন্ট্র্যাক্টের অ্যানাটমি](/developers/docs/smart-contracts/anatomy/), এবং [Ethereum Virtual Machine (EVM)](/developers/docs/evm/) সম্পর্কে একটি ভালো ধারণা থাকা উচিত। এই গাইডটি আরও ধরে নেয় যে পাঠকদের স্মার্ট কন্ট্র্যাক্ট প্রোগ্রামিং সম্পর্কে ধারণা আছে।

## স্মার্ট কন্ট্র্যাক্ট আপগ্রেড কী? {#what-is-a-smart-contract-upgrade}

একটি স্মার্ট কন্ট্র্যাক্ট আপগ্রেড হলো কন্ট্র্যাক্টের স্টেট সংরক্ষণ করে একটি স্মার্ট কন্ট্র্যাক্টের ব্যবসায়িক যুক্তির পরিবর্তন করা। এটা স্পষ্ট করা গুরুত্বপূর্ণ যে, বিশেষ করে স্মার্ট কন্ট্র্যাক্টের প্রসঙ্গে, আপগ্রেডযোগ্যতা এবং পরিবর্তনীয়তা একই জিনিস নয়।

আপনি ইথেরিয়াম নেটওয়ার্কের কোনো ঠিকানায় স্থাপন করা প্রোগ্রাম এখনও পরিবর্তন করতে পারবেন না। কিন্তু যখন ব্যবহারকারীরা একটি স্মার্ট কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করে তখন যে কোডটি নির্বাহ করা হয়, আপনি সেটি পরিবর্তন করতে পারেন।

এটি নিম্নলিখিত পদ্ধতির মাধ্যমে করা যেতে পারে:

1. একটি স্মার্ট কন্ট্র্যাক্টের একাধিক সংস্করণ তৈরি করা এবং পুরনো কন্ট্র্যাক্ট থেকে কন্ট্র্যাক্টের একটি নতুন ইনস্ট্যান্সে স্টেট (অর্থাৎ, ডেটা) স্থানান্তর করা।

2. ব্যবসায়িক যুক্তি এবং স্টেট সংরক্ষণের জন্য পৃথক কন্ট্র্যাক্ট তৈরি করা।

3. একটি অপরিবর্তনীয় প্রক্সি কন্ট্র্যাক্ট থেকে একটি পরিবর্তনযোগ্য লজিক কন্ট্র্যাক্টে ফাংশন কল অর্পণ করতে প্রক্সি প্যাটার্ন ব্যবহার করা।

4. একটি অপরিবর্তনীয় প্রধান কন্ট্র্যাক্ট তৈরি করা যা নির্দিষ্ট ফাংশন নির্বাহ করার জন্য ফ্লেক্সিবল স্যাটেলাইট কন্ট্র্যাক্টের সাথে ইন্টারফেস করে এবং তার উপর নির্ভর করে।

5. একটি প্রক্সি কন্ট্র্যাক্ট থেকে লজিক কন্ট্র্যাক্টে ফাংশন কল অর্পণ করার জন্য ডায়মন্ড প্যাটার্ন ব্যবহার করা।

### আপগ্রেড প্রক্রিয়া #1: কন্ট্র্যাক্ট মাইগ্রেশন {#contract-migration}

কন্ট্র্যাক্ট মাইগ্রেশন ভার্সনিং-এর উপর ভিত্তি করে তৈরি—একই সফ্টওয়্যারের অনন্য স্টেট তৈরি এবং পরিচালনা করার ধারণা। কন্ট্র্যাক্ট মাইগ্রেশনের মধ্যে একটি বিদ্যমান স্মার্ট কন্ট্র্যাক্টের একটি নতুন ইনস্ট্যান্স স্থাপন করা এবং নতুন কন্ট্র্যাক্টে সংগ্রহস্থল এবং ব্যালেন্স স্থানান্তর করা অন্তর্ভুক্ত।

নতুন স্থাপিত কন্ট্র্যাক্টের একটি খালি সংগ্রহস্থল থাকবে, যা আপনাকে পুরনো কন্ট্র্যাক্ট থেকে ডেটা পুনরুদ্ধার করতে এবং এটি নতুন বাস্তবায়নে লিখতে দেবে। এরপরে, আপনাকে পুরনো কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করা সমস্ত কন্ট্র্যাক্ট আপডেট করতে হবে যাতে নতুন ঠিকানাটি প্রতিফলিত হয়।

কন্ট্র্যাক্ট মাইগ্রেশনের শেষ ধাপ হলো ব্যবহারকারীদের নতুন কন্ট্র্যাক্ট ব্যবহার শুরু করতে রাজি করানো। নতুন কন্ট্র্যাক্টের সংস্করণটি ব্যবহারকারীর ব্যালেন্স এবং ঠিকানাগুলো ধরে রাখবে, যা অপরিবর্তনীয়তা সংরক্ষণ করে। যদি এটি একটি টোকেন-ভিত্তিক কন্ট্র্যাক্ট হয়, তাহলে আপনাকে পুরনো কন্ট্র্যাক্টটি বাতিল করতে এবং নতুন কন্ট্র্যাক্টটি ব্যবহার করতে এক্সচেঞ্জগুলোর সাথেও যোগাযোগ করতে হবে।

ব্যবহারকারীর ইন্টারঅ্যাকশনে বাধা না দিয়ে স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার জন্য কন্ট্র্যাক্ট মাইগ্রেশন একটি তুলনামূলকভাবে সহজ এবং নিরাপদ ব্যবস্থা। তবে, নতুন কন্ট্র্যাক্টে ব্যবহারকারীর সংগ্রহস্থল এবং ব্যালেন্স ম্যানুয়ালি স্থানান্তর করা সময়সাপেক্ষ এবং এতে উচ্চ গ্যাস খরচ হতে পারে।

[কন্ট্র্যাক্ট মাইগ্রেশন সম্পর্কে আরও জানুন।](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/)

### আপগ্রেড প্রক্রিয়া #2: ডেটা পৃথকীকরণ {#data-separation}

স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার আরেকটি পদ্ধতি হলো ব্যবসায়িক যুক্তি এবং ডেটা সংগ্রহস্থলকে পৃথক কন্ট্র্যাক্টে আলাদা করা। এর মানে হলো ব্যবহারকারীরা লজিক কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করে, যখন ডেটা সংগ্রহস্থল কন্ট্র্যাক্টে সংরক্ষণ করা হয়।

লজিক কন্ট্র্যাক্টে সেই কোড থাকে যা ব্যবহারকারীরা অ্যাপ্লিকেশনের সাথে ইন্টারঅ্যাক্ট করার সময় নির্বাহ করা হয়। এটি সংগ্রহস্থল কন্ট্র্যাক্টের ঠিকানাও ধরে রাখে এবং ডেটা পেতে ও সেট করতে এর সাথে ইন্টারঅ্যাক্ট করে।

এদিকে, সংগ্রহস্থল কন্ট্র্যাক্টটি স্মার্ট কন্ট্র্যাক্টের সাথে সম্পর্কিত স্টেট, যেমন ব্যবহারকারীর ব্যালেন্স এবং ঠিকানা, ধরে রাখে। মনে রাখবেন যে সংগ্রহস্থল কন্ট্র্যাক্টটি লজিক কন্ট্র্যাক্টের মালিকানাধীন এবং স্থাপনের সময় এটি লজিক কন্ট্র্যাক্টের ঠিকানা দিয়ে কনফিগার করা হয়। এটি অননুমোদিত কন্ট্র্যাক্টকে সংগ্রহস্থল কন্ট্র্যাক্টে কল করা বা এর ডেটা আপডেট করা থেকে বিরত রাখে।

ডিফল্টরূপে, সংগ্রহস্থল কন্ট্র্যাক্টটি অপরিবর্তনীয়—কিন্তু আপনি এটি যে লজিক কন্ট্র্যাক্টকে নির্দেশ করে তা একটি নতুন বাস্তবায়ন দিয়ে প্রতিস্থাপন করতে পারেন। এটি EVM-এ চালিত কোড পরিবর্তন করবে এবং সংগ্রহস্থল ও ব্যালেন্স অক্ষত রাখবে।

এই আপগ্রেড পদ্ধতি ব্যবহার করার জন্য সংগ্রহস্থল কন্ট্র্যাক্টে লজিক কন্ট্র্যাক্টের ঠিকানা আপডেট করতে হবে। পূর্বে ব্যাখ্যা করা কারণগুলোর জন্য আপনাকে অবশ্যই সংগ্রহস্থল কন্ট্র্যাক্টের ঠিকানা দিয়ে নতুন লজিক কন্ট্র্যাক্টটি কনফিগার করতে হবে।

ডেটা পৃথকীকরণ প্যাটার্নটি কন্ট্র্যাক্ট মাইগ্রেশনের তুলনায় প্রয়োগ করা তর্কযোগ্যভাবে সহজ। তবে, ক্ষতিকারক আপগ্রেড থেকে স্মার্ট কন্ট্র্যাক্টকে রক্ষা করার জন্য আপনাকে একাধিক কন্ট্র্যাক্ট পরিচালনা করতে হবে এবং জটিল অনুমোদন স্কিম প্রয়োগ করতে হবে।

### আপগ্রেড প্রক্রিয়া #3: প্রক্সি প্যাটার্ন {#proxy-patterns}

প্রক্সি প্যাটার্নও ব্যবসায়িক যুক্তি এবং ডেটাকে পৃথক কন্ট্র্যাক্টে রাখার জন্য ডেটা পৃথকীকরণ ব্যবহার করে। তবে, একটি প্রক্সি প্যাটার্নে, কোড নির্বাহের সময় সংগ্রহস্থল কন্ট্র্যাক্ট (যাকে প্রক্সি বলা হয়) লজিক কন্ট্র্যাক্টকে কল করে। এটি ডেটা পৃথকীকরণ পদ্ধতির বিপরীত, যেখানে লজিক কন্ট্র্যাক্ট সংগ্রহস্থল কন্ট্র্যাক্টকে কল করে।

একটি প্রক্সি প্যাটার্নে যা ঘটে তা হলো:

1. ব্যবহারকারীরা প্রক্সি কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করে, যা ডেটা সংরক্ষণ করে, কিন্তু ব্যবসায়িক যুক্তি ধারণ করে না।

2. প্রক্সি কন্ট্র্যাক্ট লজিক কন্ট্র্যাক্টের ঠিকানা সংরক্ষণ করে এবং `delegatecall` ফাংশন ব্যবহার করে সমস্ত ফাংশন কল লজিক কন্ট্র্যাক্টে (যা ব্যবসায়িক যুক্তি ধারণ করে) অর্পণ করে।

3. কলটি লজিক কন্ট্র্যাক্টে ফরওয়ার্ড করার পরে, লজিক কন্ট্র্যাক্ট থেকে ফেরত আসা ডেটা পুনরুদ্ধার করা হয় এবং ব্যবহারকারীকে ফেরত দেওয়া হয়।

প্রক্সি প্যাটার্ন ব্যবহার করার জন্য **delegatecall** ফাংশন সম্পর্কে বোঝার প্রয়োজন। মূলত, `delegatecall` হলো একটি অপকোড যা একটি কন্ট্র্যাক্টকে অন্য একটি কন্ট্র্যাক্ট কল করতে দেয়, যখন প্রকৃত কোড নির্বাহ কলিং কন্ট্র্যাক্টের প্রেক্ষাপটে ঘটে। প্রক্সি প্যাটার্নে `delegatecall` ব্যবহার করার একটি প্রভাব হলো যে প্রক্সি কন্ট্র্যাক্ট তার সংগ্রহস্থল থেকে পড়ে এবং লেখে এবং লজিক কন্ট্র্যাক্টে সংরক্ষিত যুক্তি নির্বাহ করে, যেন এটি একটি অভ্যন্তরীণ ফাংশন কল করছে।

[Solidity ডকুমেন্টেশন](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries) থেকে:

> _মেসেজ কলের একটি বিশেষ ভ্যারিয়েন্ট রয়েছে, যার নাম **delegatecall**, যা একটি মেসেজ কলের মতোই, শুধুমাত্র এই तथ्यটি ছাড়া যে টার্গেট ঠিকানার কোডটি কলিং কন্ট্র্যাক্টের প্রেক্ষাপটে (অর্থাৎ, ঠিকানায়) নির্বাহ করা হয় এবং `msg.sender` ও `msg.value`-এর মান পরিবর্তন হয় না।_ _এর মানে হলো একটি কন্ট্র্যাক্ট রানটাইমে একটি ভিন্ন ঠিকানা থেকে ডাইনামিকভাবে কোড লোড করতে পারে।_ সংগ্রহস্থল, বর্তমান ঠিকানা এবং ব্যালেন্স এখনও কলিং কন্ট্র্যাক্টকে নির্দেশ করে, শুধুমাত্র কোডটি কল করা ঠিকানা থেকে নেওয়া হয়।_

প্রক্সি কন্ট্র্যাক্টটি জানে যে যখনই কোনো ব্যবহারকারী কোনো ফাংশন কল করে তখন `delegatecall` ইনভোক করতে হবে, কারণ এর মধ্যে একটি `fallback` ফাংশন বিল্ট-ইন রয়েছে। Solidity প্রোগ্রামিং-এ [ফলব্যাক ফাংশন](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function) তখনই নির্বাহ করা হয় যখন একটি ফাংশন কল কোনো কন্ট্র্যাক্টে নির্দিষ্ট করা ফাংশনগুলোর সাথে মেলে না।

প্রক্সি প্যাটার্ন কার্যকর করার জন্য একটি কাস্টম ফলব্যাক ফাংশন লেখা প্রয়োজন যা নির্দিষ্ট করে যে প্রক্সি কন্ট্র্যাক্টটি সমর্থন করে না এমন ফাংশন কলগুলো কীভাবে পরিচালনা করবে। এই ক্ষেত্রে প্রক্সির ফলব্যাক ফাংশনটি একটি delegatecall শুরু করার জন্য এবং ব্যবহারকারীর অনুরোধটি বর্তমান লজিক কন্ট্র্যাক্ট বাস্তবায়নে পুনরায় রুট করার জন্য প্রোগ্রাম করা হয়।

প্রক্সি কন্ট্র্যাক্টটি ডিফল্টরূপে অপরিবর্তনীয়, কিন্তু আপডেট করা ব্যবসায়িক যুক্তি সহ নতুন লজিক কন্ট্র্যাক্ট তৈরি করা যেতে পারে। আপগ্রেড করাটা তখন প্রক্সি কন্ট্র্যাক্টে উল্লেখিত লজিক কন্ট্র্যাক্টের ঠিকানা পরিবর্তন করার একটি ব্যাপার মাত্র।

প্রক্সি কন্ট্র্যাক্টকে একটি নতুন লজিক কন্ট্র্যাক্টে নির্দেশ করার মাধ্যমে, ব্যবহারকারীরা যখন প্রক্সি কন্ট্র্যাক্ট ফাংশন কল করে তখন নির্বাহিত কোডটি পরিবর্তিত হয়। এটি আমাদেরকে ব্যবহারকারীদের একটি নতুন কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করতে না বলেই একটি কন্ট্র্যাক্টের যুক্তি আপগ্রেড করতে দেয়।

প্রক্সি প্যাটার্ন স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার জন্য একটি জনপ্রিয় পদ্ধতি কারণ এটি কন্ট্র্যাক্ট মাইগ্রেশনের সাথে সম্পর্কিত অসুবিধাগুলো দূর করে। তবে, প্রক্সি প্যাটার্ন ব্যবহার করা আরও জটিল এবং ভুলভাবে ব্যবহার করা হলে [ফাংশন সিলেক্টর ক্ল্যাশ](https://medium.com/nomic-foundation-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357)-এর মতো গুরুতর ত্রুটি সৃষ্টি করতে পারে।

[প্রক্সি প্যাটার্ন সম্পর্কে আরও জানুন।](https://blog.openzeppelin.com/proxy-patterns/)

### আপগ্রেড প্রক্রিয়া #4: স্ট্র্যাটেজি প্যাটার্ন {#strategy-pattern}

এই কৌশলটি [স্ট্র্যাটেজি প্যাটার্ন](https://en.wikipedia.org/wiki/Strategy_pattern) দ্বারা প্রভাবিত, যা নির্দিষ্ট বৈশিষ্ট্য প্রয়োগ করার জন্য অন্যান্য প্রোগ্রামের সাথে ইন্টারফেস করে এমন সফ্টওয়্যার প্রোগ্রাম তৈরি করতে উৎসাহিত করে। ইথেরিয়াম ডেভেলপমেন্টে স্ট্র্যাটেজি প্যাটার্ন প্রয়োগ করার অর্থ হলো এমন একটি স্মার্ট কন্ট্র্যাক্ট তৈরি করা যা অন্যান্য কন্ট্র্যাক্ট থেকে ফাংশন কল করে।

এই ক্ষেত্রে প্রধান কন্ট্র্যাক্টটিতে মূল ব্যবসায়িক যুক্তি থাকে, কিন্তু এটি নির্দিষ্ট ফাংশন সম্পাদন করার জন্য অন্যান্য স্মার্ট কন্ট্র্যাক্টের ("স্যাটেলাইট কন্ট্র্যাক্ট") সাথে ইন্টারফেস করে। এই প্রধান কন্ট্র্যাক্টটি প্রতিটি স্যাটেলাইট কন্ট্র্যাক্টের ঠিকানা সংরক্ষণ করে এবং স্যাটেলাইট কন্ট্র্যাক্টের বিভিন্ন বাস্তবায়নের মধ্যে পরিবর্তন করতে পারে।

আপনি একটি নতুন স্যাটেলাইট কন্ট্র্যাক্ট তৈরি করতে পারেন এবং নতুন ঠিকানা দিয়ে প্রধান কন্ট্র্যাক্টটি কনফিগার করতে পারেন। এটি আপনাকে একটি স্মার্ট কন্ট্র্যাক্টের জন্য _স্ট্র্যাটেজি_ পরিবর্তন করতে (অর্থাৎ নতুন যুক্তি প্রয়োগ করতে) দেয়।

যদিও এটি পূর্বে আলোচিত প্রক্সি প্যাটার্নের মতো, তবে স্ট্র্যাটেজি প্যাটার্নটি ভিন্ন কারণ প্রধান কন্ট্র্যাক্ট, যার সাথে ব্যবহারকারীরা ইন্টারঅ্যাক্ট করে, সেটি ব্যবসায়িক যুক্তি ধারণ করে। এই প্যাটার্নটি ব্যবহার করে আপনি মূল পরিকাঠামোকে প্রভাবিত না করে একটি স্মার্ট কন্ট্র্যাক্টে সীমিত পরিবর্তন আনার সুযোগ পান।

এর প্রধান অসুবিধা হলো এই প্যাটার্নটি বেশিরভাগ ক্ষেত্রে ছোটখাটো আপগ্রেড করার জন্য উপযোগী। এছাড়াও, যদি প্রধান কন্ট্র্যাক্টটি ক্ষতিগ্রস্ত হয় (যেমন, একটি হ্যাকের মাধ্যমে), আপনি এই আপগ্রেড পদ্ধতি ব্যবহার করতে পারবেন না।

### আপগ্রেড প্রক্রিয়া #5: ডায়মন্ড প্যাটার্ন {#diamond-pattern}

ডায়মন্ড প্যাটার্নকে প্রক্সি প্যাটার্নের একটি উন্নত সংস্করণ হিসেবে বিবেচনা করা যেতে পারে। ডায়মন্ড প্যাটার্নগুলো প্রক্সি প্যাটার্ন থেকে ভিন্ন কারণ ডায়মন্ড প্রক্সি কন্ট্র্যাক্ট একাধিক লজিক কন্ট্র্যাক্টে ফাংশন কল অর্পণ করতে পারে।

ডায়মন্ড প্যাটার্নে লজিক কন্ট্র্যাক্টগুলো _ফেসেট_ নামে পরিচিত। ডায়মন্ড প্যাটার্নটি কাজ করানোর জন্য, আপনাকে প্রক্সি কন্ট্র্যাক্টে একটি ম্যাপিং তৈরি করতে হবে যা বিভিন্ন ফেসেট ঠিকানায় [ফাংশন সিলেক্টর](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector) ম্যাপ করে।

যখন একজন ব্যবহারকারী একটি ফাংশন কল করে, প্রক্সি কন্ট্র্যাক্ট সেই ফাংশনটি সম্পাদনের জন্য দায়ী ফেসেট খুঁজে বের করার জন্য ম্যাপিং পরীক্ষা করে। তারপর এটি `delegatecall` (ফলব্যাক ফাংশন ব্যবহার করে) ইনভোক করে এবং কলটি উপযুক্ত লজিক কন্ট্র্যাক্টে পুনঃনির্দেশিত করে।

প্রচলিত প্রক্সি আপগ্রেড প্যাটার্নের তুলনায় ডায়মন্ড আপগ্রেড প্যাটার্নের কিছু সুবিধা রয়েছে:

1. এটি আপনাকে সমস্ত কোড পরিবর্তন না করে কন্ট্র্যাক্টের একটি ছোট অংশ আপগ্রেড করতে দেয়। আপগ্রেডের জন্য প্রক্সি প্যাটার্ন ব্যবহার করার জন্য একটি সম্পূর্ণ নতুন লজিক কন্ট্র্যাক্ট তৈরি করতে হয়, এমনকি ছোট আপগ্রেডের জন্যও।

2. সমস্ত স্মার্ট কন্ট্র্যাক্টের (প্রক্সি প্যাটার্নে ব্যবহৃত লজিক কন্ট্র্যাক্ট সহ) একটি 24KB আকারের সীমা রয়েছে, যা একটি সীমাবদ্ধতা হতে পারে—বিশেষ করে জটিল কন্ট্র্যাক্টের জন্য যার জন্য আরও ফাংশন প্রয়োজন। ডায়মন্ড প্যাটার্ন একাধিক লজিক কন্ট্র্যাক্টে ফাংশন বিভক্ত করে এই সমস্যার সমাধান করা সহজ করে তোলে।

3. প্রক্সি প্যাটার্নগুলো অ্যাক্সেস নিয়ন্ত্রণের জন্য একটি ক্যাচ-অল পদ্ধতি গ্রহণ করে। আপগ্রেড ফাংশনে অ্যাক্সেস থাকা একটি সত্তা _সম্পূর্ণ_ কন্ট্র্যাক্ট পরিবর্তন করতে পারে। কিন্তু ডায়মন্ড প্যাটার্ন একটি মডুলার অনুমতি পদ্ধতি সক্ষম করে, যেখানে আপনি সত্তাগুলোকে একটি স্মার্ট কন্ট্র্যাক্টের মধ্যে নির্দিষ্ট ফাংশন আপগ্রেড করতে সীমাবদ্ধ করতে পারেন।

[ডায়মন্ড প্যাটার্ন সম্পর্কে আরও জানুন](https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard?s=w)।

## স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার সুবিধা এবং অসুবিধা {#pros-and-cons-of-upgrading-smart-contracts}

| যেসব বিষয়ে এর সুফল পাওয়া যায়                                                                                                        | কনস                                                                                                                                                 |
| ----------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| একটি স্মার্ট কন্ট্র্যাক্ট আপগ্রেড স্থাপনার পরবর্তী পর্যায়ে আবিষ্কৃত দুর্বলতাগুলো ঠিক করা সহজ করে তুলতে পারে।                       | স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করা কোডের অপরিবর্তনীয়তার ধারণাকে অস্বীকার করে, যা বিকেন্দ্রীকরণ এবং নিরাপত্তার উপর প্রভাব ফেলে।                       |
| ডেভেলপাররা ডিসেন্ট্রালাইজড এপ্লিকেশনগুলোতে নতুন বৈশিষ্ট্য যোগ করতে লজিক আপগ্রেড ব্যবহার করতে পারেন।                                 | ব্যবহারকারীদের অবশ্যই ডেভেলপারদের উপর বিশ্বাস রাখতে হবে যেন তারা ইচ্ছামত স্মার্ট কন্ট্র্যাক্ট পরিবর্তন না করে।                                      |
| স্মার্ট কন্ট্র্যাক্ট আপগ্রেডগুলো শেষ-ব্যবহারকারীদের জন্য নিরাপত্তা উন্নত করতে পারে কারণ বাগগুলো দ্রুত ঠিক করা যায়।                 | স্মার্ট কন্ট্র্যাক্টে আপগ্রেড কার্যকারিতা প্রোগ্রামিং করা জটিলতার আরও একটি স্তর যোগ করে এবং গুরুতর ত্রুটির সম্ভাবনা বাড়িয়ে তোলে।                  |
| কন্ট্র্যাক্ট আপগ্রেড ডেভেলপারদের বিভিন্ন বৈশিষ্ট্য নিয়ে পরীক্ষা করার এবং সময়ের সাথে সাথে ডিএ্যাপস উন্নত করার জন্য আরও সুযোগ দেয়। | স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার সুযোগ ডেভেলপারদেরকে ডেভেলপমেন্ট পর্যায়ে যথাযথ সতর্কতা অবলম্বন না করেই দ্রুত প্রকল্প চালু করতে উৎসাহিত করতে পারে। |
|                                                                                                                                     | স্মার্ট কন্ট্র্যাক্টে নিরাপত্তাহীন অ্যাক্সেস কন্ট্রোল বা কেন্দ্রীকরণ ক্ষতিকারক অভিনেতাদের জন্য অননুমোদিত আপগ্রেড করা সহজ করে তুলতে পারে।            |

## স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার জন্য বিবেচনা {#considerations-for-upgrading-smart-contracts}

1. অননুমোদিত স্মার্ট কন্ট্র্যাক্ট আপগ্রেড প্রতিরোধ করতে নিরাপদ অ্যাক্সেস নিয়ন্ত্রণ/অনুমোদন প্রক্রিয়া ব্যবহার করুন, বিশেষ করে যদি প্রক্সি প্যাটার্ন, স্ট্র্যাটেজি প্যাটার্ন, বা ডেটা সেপারেশন ব্যবহার করেন। একটি উদাহরণ হলো আপগ্রেড ফাংশনে অ্যাক্সেস সীমাবদ্ধ করা, যাতে শুধুমাত্র কন্ট্র্যাক্টের মালিকই এটি কল করতে পারে।

2. স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করা একটি জটিল কার্যকলাপ এবং দুর্বলতা সৃষ্টি রোধ করার জন্য উচ্চ স্তরের সতর্কতা প্রয়োজন।

3. আপগ্রেড বাস্তবায়নের প্রক্রিয়াকে বিকেন্দ্রীকরণ করে বিশ্বাসের অনুমান হ্রাস করুন। সম্ভাব্য কৌশলগুলোর মধ্যে রয়েছে আপগ্রেড নিয়ন্ত্রণের জন্য একটি [মাল্টি-সিগ ওয়ালেট কন্ট্র্যাক্ট](/developers/docs/smart-contracts/#multisig) ব্যবহার করা, অথবা আপগ্রেড অনুমোদনের জন্য একটি [DAO-এর সদস্যদের](/dao/) ভোট দেওয়ার প্রয়োজন।

4. কন্ট্র্যাক্ট আপগ্রেড করার সাথে জড়িত খরচ সম্পর্কে সচেতন থাকুন। উদাহরণস্বরূপ, কন্ট্র্যাক্ট মাইগ্রেশনের সময় একটি পুরানো কন্ট্র্যাক্ট থেকে একটি নতুন কন্ট্র্যাক্টে স্টেট (যেমন ব্যবহারকারীর ব্যালেন্স) অনুলিপি করতে একাধিক লেনদেনের প্রয়োজন হতে পারে, যার অর্থ আরও বেশি গ্যাস ফি।

5. ব্যবহারকারীদের সুরক্ষার জন্য **টাইমলক** বাস্তবায়নের কথা বিবেচনা করুন। টাইমলক বলতে একটি সিস্টেমে পরিবর্তনের উপর প্রয়োগ করা একটি বিলম্বকে বোঝায়। আপগ্রেড নিয়ন্ত্রণের জন্য টাইমলক একটি মাল্টি-সিগ গভর্নেন্স সিস্টেমের সাথে মিলিত হতে পারে: যদি একটি প্রস্তাবিত পদক্ষেপ প্রয়োজনীয় অনুমোদনের থ্রেশহোল্ডে পৌঁছায়, তবে পূর্বনির্ধারিত বিলম্বের সময় শেষ না হওয়া পর্যন্ত এটি কার্যকর হয় না।

টাইমলক ব্যবহারকারীদের সিস্টেম থেকে বেরিয়ে যাওয়ার জন্য কিছু সময় দেয় যদি তারা প্রস্তাবিত পরিবর্তনের সাথে একমত না হয় (যেমন, লজিক আপগ্রেড বা নতুন ফি স্কিম)। টাইমলক ছাড়া, ব্যবহারকারীদের ডেভেলপারদের উপর বিশ্বাস করতে হবে যে তারা পূর্ব নোটিশ ছাড়াই একটি স্মার্ট কন্ট্র্যাক্টে ইচ্ছামত পরিবর্তন করবে না। এর অসুবিধা হলো টাইমলক দ্রুত দুর্বলতা প্যাচ করার ক্ষমতাকে সীমাবদ্ধ করে।

## রিসোর্স {#resources}

**OpenZeppelin আপগ্রেড প্লাগইন - _আপগ্রেডযোগ্য স্মার্ট কন্ট্র্যাক্ট স্থাপন এবং সুরক্ষিত করার জন্য একটি টুলস স্যুট।_**

- [GitHub](https://github.com/OpenZeppelin/openzeppelin-upgrades)
- [নথিপত্র](https://docs.openzeppelin.com/upgrades)

## টিউটোরিয়াল {#tutorials}

- প্যাট্রিক কলিন্সের [আপনার স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করা | ইউটিউব টিউটোরিয়াল](https://www.youtube.com/watch?v=bdXJmWajZRY)
- অস্টিন গ্রিফিথের [ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট মাইগ্রেশন টিউটোরিয়াল](https://medium.com/coinmonks/ethereum-smart-contract-migration-13f6f12539bd)
- [স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার জন্য UUPS প্রক্সি প্যাটার্ন ব্যবহার করা](https://blog.logrocket.com/author/praneshas/) - লেখক প্রনেশ এ.এস
- [Web3 টিউটোরিয়াল: OpenZeppelin ব্যবহার করে আপগ্রেডযোগ্য স্মার্ট কন্ট্র্যাক্ট (প্রক্সি) লিখুন](https://dev.to/yakult/tutorial-write-upgradeable-smart-contract-proxy-contract-with-openzeppelin-1916) - লেখক fangjun.eth

## আরও পড়ুন {#further-reading}

- সান্তিয়াগো প্যালাডিনোর [দ্য স্টেট অফ স্মার্ট কন্ট্র্যাক্ট আপগ্রেডস](https://blog.openzeppelin.com/the-state-of-smart-contract-upgrades/)
- [একটি সলিডিটি স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করার একাধিক উপায়](https://cryptomarketpool.com/multiple-ways-to-upgrade-a-solidity-smart-contract/) - ক্রিপ্টো মার্কেট পুল ব্লগ
- [শিখুন: স্মার্ট কন্ট্র্যাক্ট আপগ্রেড করা](https://docs.openzeppelin.com/learn/upgrading-smart-contracts) - OpenZeppelin ডক্স
- [সলিডিটি কন্ট্র্যাক্টসের আপগ্রেডযোগ্যতার জন্য প্রক্সি প্যাটার্নস: ট্রান্সপারেন্ট বনাম UUPS প্রক্সি](https://mirror.xyz/0xB38709B8198d147cc9Ff9C133838a044d78B064B/M7oTptQkBGXxox-tk9VJjL66E1V8BUF0GF79MMK4YG0) - লেখক নবীন সাহু
- নিক মুজের [ডায়মন্ড আপগ্রেড কীভাবে কাজ করে](https://dev.to/mudgen/how-diamond-upgrades-work-417j)
