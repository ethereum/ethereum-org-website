---
title: "স্মার্ট কন্ট্র্যাক্ট টেস্টিং"
description: "ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করার জন্য কৌশল এবং বিবেচ্য বিষয়গুলির একটি সংক্ষিপ্ত বিবরণ।"
lang: bn
---

ইথেরিয়াম-এর মতো পাবলিক ব্লকচেইন অপরিবর্তনীয়, যা ডেপ্লয়মেন্টের পরে একটি স্মার্ট কন্ট্র্যাক্ট-এর কোড পরিবর্তন করা কঠিন করে তোলে। "ভার্চুয়াল আপগ্রেড" সম্পাদনের জন্য [কন্ট্র্যাক্ট আপগ্রেড প্যাটার্ন](/developers/docs/smart-contracts/upgrading/) বিদ্যমান, কিন্তু এগুলি বাস্তবায়ন করা কঠিন এবং এর জন্য সামাজিক কনসেন্সাস প্রয়োজন। অধিকন্তু, একটি আপগ্রেড শুধুমাত্র একটি ত্রুটি আবিষ্কৃত হওয়ার _পরেই_ তা ঠিক করতে পারে—যদি একজন আক্রমণকারী প্রথমে দুর্বলতাটি আবিষ্কার করে, তবে আপনার স্মার্ট কন্ট্র্যাক্ট একটি এক্সপ্লয়েটের ঝুঁকিতে থাকবে।

এই কারণগুলির জন্য, Mainnet-এ [ডেপ্লয়](/developers/docs/smart-contracts/deploying/) করার আগে স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করা [নিরাপত্তার](/developers/docs/smart-contracts/security/) জন্য একটি ন্যূনতম প্রয়োজনীয়তা। কন্ট্র্যাক্ট পরীক্ষা করা এবং কোডের সঠিকতা মূল্যায়নের জন্য অনেক কৌশল রয়েছে; আপনি কোনটি বেছে নেবেন তা আপনার প্রয়োজনের উপর নির্ভর করে। তা সত্ত্বেও, কন্ট্র্যাক্ট কোডে ছোট এবং বড় উভয় নিরাপত্তা ত্রুটি ধরার জন্য বিভিন্ন টুলস এবং পদ্ধতির সমন্বয়ে তৈরি একটি টেস্ট স্যুট আদর্শ।

## পূর্বশর্ত {#prerequisites}

এই পৃষ্ঠাটি ইথেরিয়াম নেটওয়ার্কে ডেপ্লয় করার আগে কীভাবে স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করতে হয় তা ব্যাখ্যা করে। এটি ধরে নেওয়া হয়েছে যে আপনি [স্মার্ট কন্ট্র্যাক্ট](/developers/docs/smart-contracts/) সম্পর্কে পরিচিত।

## স্মার্ট কন্ট্র্যাক্ট টেস্টিং কী? {#what-is-smart-contract-testing}

স্মার্ট কন্ট্র্যাক্ট টেস্টিং হল একটি স্মার্ট কন্ট্র্যাক্টের কোড প্রত্যাশা অনুযায়ী কাজ করছে কিনা তা যাচাই করার প্রক্রিয়া। একটি নির্দিষ্ট স্মার্ট কন্ট্র্যাক্ট নির্ভরযোগ্যতা, ব্যবহারযোগ্যতা এবং নিরাপত্তার জন্য প্রয়োজনীয়তা পূরণ করে কিনা তা পরীক্ষা করার জন্য টেস্টিং উপযোগী।

যদিও পদ্ধতিগুলো ভিন্ন হয়, তবে বেশিরভাগ টেস্টিং পদ্ধতির জন্য একটি স্মার্ট কন্ট্র্যাক্টকে ডেটার একটি ছোট নমুনা দিয়ে এক্সিকিউট করতে হয় যা এটি পরিচালনা করবে বলে আশা করা হয়। যদি কন্ট্র্যাক্টটি নমুনা ডেটার জন্য সঠিক ফলাফল দেয়, তবে ধরে নেওয়া হয় যে এটি সঠিকভাবে কাজ করছে। বেশিরভাগ টেস্টিং টুলস একটি কন্ট্র্যাক্টের এক্সিকিউশন প্রত্যাশিত ফলাফলের সাথে মেলে কিনা তা পরীক্ষা করার জন্য [টেস্ট কেস](https://en.m.wikipedia.org/wiki/Test_case) লেখা এবং এক্সিকিউট করার জন্য রিসোর্স সরবরাহ করে।

### স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করা কেন গুরুত্বপূর্ণ? {#importance-of-testing-smart-contracts}

যেহেতু স্মার্ট কন্ট্র্যাক্ট প্রায়ই উচ্চ-মূল্যের আর্থিক সম্পদ পরিচালনা করে, তাই ছোটখাটো প্রোগ্রামিং ত্রুটি [ব্যবহারকারীদের জন্য বিশাল ক্ষতির](https://rekt.news/leaderboard/) কারণ হতে পারে এবং প্রায়শই হয়। তবে, কঠোর টেস্টিং একটি স্মার্ট কন্ট্র্যাক্টের কোডে থাকা ত্রুটি এবং সমস্যাগুলি আগে থেকে আবিষ্কার করতে এবং Mainnet-এ চালু করার আগে সেগুলি ঠিক করতে আপনাকে সাহায্য করতে পারে।

যদিও একটি বাগ আবিষ্কৃত হলে কন্ট্র্যাক্ট আপগ্রেড করা সম্ভব, তবে আপগ্রেডগুলি জটিল এবং ভুলভাবে পরিচালনা করা হলে [ত্রুটির কারণ হতে পারে](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/)। একটি কন্ট্র্যাক্ট আপগ্রেড করা অপরিবর্তনীয়তার নীতিকে আরও অস্বীকার করে এবং ব্যবহারকারীদের উপর অতিরিক্ত বিশ্বাসের অনুমানের বোঝা চাপায়। বিপরীতভাবে, আপনার কন্ট্র্যাক্ট পরীক্ষা করার জন্য একটি ব্যাপক পরিকল্পনা স্মার্ট কন্ট্র্যাক্টের নিরাপত্তা ঝুঁকি কমায় এবং ডেপ্লয় করার পরে জটিল লজিক আপগ্রেড করার প্রয়োজন কমিয়ে দেয়।

## স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করার পদ্ধতি {#methods-for-testing-smart-contracts}

ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করার পদ্ধতি দুটি প্রধান বিভাগে পড়ে: **স্বয়ংক্রিয় টেস্টিং** এবং **ম্যানুয়াল টেস্টিং**। স্বয়ংক্রিয় টেস্টিং এবং ম্যানুয়াল টেস্টিং অনন্য সুবিধা এবং ট্রেডঅফ অফার করে, কিন্তু আপনি আপনার কন্ট্র্যাক্ট বিশ্লেষণ করার জন্য একটি শক্তিশালী পরিকল্পনা তৈরি করতে উভয়কে একত্রিত করতে পারেন।

### স্বয়ংক্রিয় টেস্টিং {#automated-testing}

স্বয়ংক্রিয় টেস্টিং এমন টুলস ব্যবহার করে যা এক্সিকিউশনের ত্রুটির জন্য একটি স্মার্ট কন্ট্র্যাক্টের কোড স্বয়ংক্রিয়ভাবে পরীক্ষা করে। স্বয়ংক্রিয় টেস্টিংয়ের সুবিধাটি কন্ট্র্যাক্টের কার্যকারিতার মূল্যায়নকে গাইড করার জন্য [স্ক্রিপ্ট](https://www.techtarget.com/whatis/definition/script?amp=1) ব্যবহার করা থেকে আসে। স্ক্রিপ্টেড টেস্টগুলি ন্যূনতম মানুষের হস্তক্ষেপের সাথে বারবার চালানোর জন্য সময়সূচী করা যেতে পারে, যা স্বয়ংক্রিয় টেস্টিংকে টেস্টিংয়ের ম্যানুয়াল পদ্ধতির চেয়ে আরও দক্ষ করে তোলে।

স্বয়ংক্রিয় টেস্টিং বিশেষভাবে উপযোগী যখন টেস্টগুলি পুনরাবৃত্তিমূলক এবং সময়সাপেক্ষ হয়; ম্যানুয়ালি সম্পাদন করা কঠিন; মানুষের ভুলের প্রবণ; অথবা জটিল কন্ট্র্যাক্ট ফাংশন মূল্যায়ন জড়িত থাকে। কিন্তু স্বয়ংক্রিয় টেস্টিং টুলসের কিছু অসুবিধা থাকতে পারে—এগুলো কিছু বাগ মিস করতে পারে এবং অনেক [ফলস পজিটিভ](https://www.contrastsecurity.com/glossary/false-positive) তৈরি করতে পারে। তাই, স্মার্ট কন্ট্র্যাক্টের জন্য স্বয়ংক্রিয় টেস্টিংয়ের সাথে ম্যানুয়াল টেস্টিং যুক্ত করা আদর্শ।

### ম্যানুয়াল টেস্টিং {#manual-testing}

ম্যানুয়াল টেস্টিং মানুষ-সহায়তায় করা হয় এবং এতে একটি স্মার্ট কন্ট্র্যাক্টের সঠিকতা বিশ্লেষণ করার সময় আপনার টেস্ট স্যুটের প্রতিটি টেস্ট কেস একের পর এক এক্সিকিউট করা জড়িত থাকে। এটি স্বয়ংক্রিয় টেস্টিংয়ের মতো নয়, যেখানে আপনি একই সাথে একটি কন্ট্র্যাক্টে একাধিক বিচ্ছিন্ন টেস্ট চালাতে পারেন এবং সমস্ত ব্যর্থ এবং পাস করা টেস্ট দেখানো একটি রিপোর্ট পেতে পারেন।

ম্যানুয়াল টেস্টিং একজন একক ব্যক্তি দ্বারা একটি লিখিত টেস্ট প্ল্যান অনুসরণ করে করা যেতে পারে যা বিভিন্ন টেস্ট সিনারিও কভার করে। ম্যানুয়াল টেস্টিংয়ের অংশ হিসাবে আপনি একাধিক ব্যক্তি বা গোষ্ঠীকে একটি নির্দিষ্ট সময়ের জন্য একটি স্মার্ট কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করাতেও পারেন। টেস্টাররা কন্ট্র্যাক্টের প্রকৃত আচরণকে প্রত্যাশিত আচরণের সাথে তুলনা করবে এবং যেকোনো পার্থক্যকে একটি বাগ হিসেবে ফ্ল্যাগ করবে।

কার্যকর ম্যানুয়াল টেস্টিংয়ের জন্য যথেষ্ট রিসোর্স (দক্ষতা, সময়, অর্থ এবং প্রচেষ্টা) প্রয়োজন, এবং টেস্ট এক্সিকিউট করার সময় মানুষের ভুলের কারণে কিছু ত্রুটি মিস করা সম্ভব। কিন্তু ম্যানুয়াল টেস্টিং উপকারীও হতে পারে—উদাহরণস্বরূপ, একজন মানুষ টেস্টার (যেমন, একজন অডিটর) এমন এজ কেস শনাক্ত করতে অন্তর্দৃষ্টি ব্যবহার করতে পারে যা একটি স্বয়ংক্রিয় টেস্টিং টুল মিস করবে।

## স্মার্ট কন্ট্র্যাক্টের জন্য স্বয়ংক্রিয় টেস্টিং {#automated-testing-for-smart-contracts}

### ইউনিট টেস্টিং {#unit-testing-for-smart-contracts}

ইউনিট টেস্টিং কন্ট্র্যাক্ট ফাংশনগুলিকে আলাদাভাবে মূল্যায়ন করে এবং প্রতিটি কম্পোনেন্ট সঠিকভাবে কাজ করছে কিনা তা পরীক্ষা করে। ভালো ইউনিট টেস্ট সহজ, দ্রুত চালানোর মতো হওয়া উচিত এবং টেস্ট ব্যর্থ হলে কী ভুল হয়েছে তার একটি স্পষ্ট ধারণা প্রদান করা উচিত।

ফাংশনগুলি প্রত্যাশিত মান ফেরত দেয় কিনা এবং ফাংশন এক্সিকিউশনের পরে কন্ট্র্যাক্ট সংগ্রহস্থল সঠিকভাবে আপডেট হয় কিনা তা পরীক্ষা করার জন্য ইউনিট টেস্ট উপযোগী। অধিকন্তু, একটি কন্ট্র্যাক্টের কোডবেসে পরিবর্তন আনার পর ইউনিট টেস্ট চালালে এটি নিশ্চিত করা যায় যে নতুন লজিক যোগ করার ফলে কোনো ত্রুটি তৈরি হচ্ছে না। কার্যকরী ইউনিট টেস্ট চালানোর জন্য নিচে কিছু নির্দেশিকা দেওয়া হল:

#### স্মার্ট কন্ট্র্যাক্টের ইউনিট টেস্টিংয়ের জন্য নির্দেশিকা {#unit-testing-guidelines}

##### ১. আপনার কন্ট্র্যাক্টের ব্যবসায়িক যুক্তি এবং কর্মপ্রবাহ বুঝুন

ইউনিট টেস্ট লেখার আগে, একটি স্মার্ট কন্ট্র্যাক্ট কী কী কার্যকারিতা অফার করে এবং ব্যবহারকারীরা কীভাবে সেই ফাংশনগুলি অ্যাক্সেস এবং ব্যবহার করবে তা জানা সাহায্য করে। এটি বিশেষত [হ্যাপি পাথ টেস্ট](https://en.m.wikipedia.org/wiki/Happy_path) চালানোর জন্য উপযোগী যা নির্ধারণ করে যে একটি কন্ট্র্যাক্টের ফাংশনগুলি বৈধ ব্যবহারকারী ইনপুটের জন্য সঠিক আউটপুট ফেরত দেয় কিনা। আমরা [একটি নিলাম কন্ট্র্যাক্ট](https://docs.soliditylang.org/en/v0.8.17/solidity-by-example.html?highlight=Auction%20contract#simple-open-auction)-এর এই (সংক্ষিপ্ত) উদাহরণ ব্যবহার করে এই ধারণাটি ব্যাখ্যা করব।

```solidity
constructor(
        uint biddingTime,
        address payable beneficiaryAddress
    ) {
        beneficiary = beneficiaryAddress;
        auctionEndTime = block.timestamp + biddingTime;
    }

function bid() external payable {

      if (block.timestamp > auctionEndTime)
            revert AuctionAlreadyEnded();

      if (msg.value <= highestBid)
            revert BidNotHighEnough(highestBid);

 if (highestBid != 0) {
    pendingReturns[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        emit HighestBidIncreased(msg.sender, msg.value);
    }

 function withdraw() external returns (bool) {
        uint amount = pendingReturns[msg.sender];
        if (amount > 0) {
           pendingReturns[msg.sender] = 0;

        if (!payable(msg.sender).send(amount)) {
                pendingReturns[msg.sender] = amount;
                return false;
            }
        }
        return true;
    }

function auctionEnd() external {
       if (block.timestamp < auctionEndTime)
            revert AuctionNotYetEnded();
        if (ended)
            revert AuctionEndAlreadyCalled();

        ended = true;
        emit AuctionEnded(highestBidder, highestBid);

        beneficiary.transfer(highestBid);
    }
}
```

এটি একটি সাধারণ নিলাম কন্ট্র্যাক্ট যা বিডিং সময়কালে বিড গ্রহণ করার জন্য ডিজাইন করা হয়েছে। যদি `highestBid` বৃদ্ধি পায়, তাহলে পূর্ববর্তী সর্বোচ্চ দরদাতা তার টাকা ফেরত পায়; বিডিং সময়কাল শেষ হয়ে গেলে, `beneficiary` তার টাকা পেতে কন্ট্র্যাক্টটি কল করে।

এই ধরনের একটি কন্ট্র্যাক্টের জন্য ইউনিট টেস্টগুলি বিভিন্ন ফাংশন কভার করবে যা একজন ব্যবহারকারী কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করার সময় কল করতে পারে। একটি উদাহরণ হতে পারে একটি ইউনিট টেস্ট যা পরীক্ষা করে যে একজন ব্যবহারকারী নিলাম চলাকালীন বিড করতে পারে কিনা (অর্থাৎ, `bid()`-এ কল সফল হয়) অথবা একটি যা পরীক্ষা করে যে একজন ব্যবহারকারী বর্তমান `highestBid`-এর চেয়ে বেশি বিড করতে পারে কিনা।

একটি কন্ট্র্যাক্টের অপারেশনাল কর্মপ্রবাহ বোঝা ইউনিট টেস্ট লিখতে সাহায্য করে যা এক্সিকিউশন প্রয়োজনীয়তা পূরণ করে কিনা তা পরীক্ষা করে। উদাহরণস্বরূপ, নিলাম কন্ট্র্যাক্টটি নির্দিষ্ট করে যে নিলাম শেষ হয়ে গেলে ব্যবহারকারীরা বিড করতে পারবে না (অর্থাৎ, যখন `auctionEndTime`, `block.timestamp`-এর থেকে কম হয়)। সুতরাং, একজন ডেভেলপার একটি ইউনিট টেস্ট চালাতে পারেন যা পরীক্ষা করে যে নিলাম শেষ হয়ে গেলে `bid()` ফাংশনে কল সফল হয় না ব্যর্থ হয় (অর্থাৎ, যখন `auctionEndTime` > `block.timestamp`)।

##### 2. কন্ট্র্যাক্ট এক্সিকিউশন সম্পর্কিত সমস্ত অনুমান মূল্যায়ন করুন

একটি কন্ট্র্যাক্টের এক্সিকিউশন সম্পর্কে যেকোনো অনুমান নথিভুক্ত করা এবং সেই অনুমানগুলির বৈধতা যাচাই করার জন্য ইউনিট টেস্ট লেখা গুরুত্বপূর্ণ। অপ্রত্যাশিত এক্সিকিউশনের বিরুদ্ধে সুরক্ষা অফার করার পাশাপাশি, টেস্টিং অ্যাসারশন আপনাকে এমন অপারেশন সম্পর্কে ভাবতে বাধ্য করে যা একটি স্মার্ট কন্ট্র্যাক্টের নিরাপত্তা মডেলকে ভেঙে দিতে পারে। একটি দরকারী টিপ হল "হ্যাপি ইউজার টেস্ট" এর বাইরে গিয়ে নেগেটিভ টেস্ট লেখা যা পরীক্ষা করে যে একটি ফাংশন ভুল ইনপুটের জন্য ব্যর্থ হয় কিনা।

অনেক ইউনিট টেস্টিং ফ্রেমওয়ার্ক আপনাকে অ্যাসারশন তৈরি করতে দেয়—সাধারণ বিবৃতি যা বলে একটি কন্ট্র্যাক্ট কী করতে পারে এবং কী করতে পারে না—এবং সেই অ্যাসারশনগুলি এক্সিকিউশনের অধীনে টিকে থাকে কিনা তা দেখার জন্য টেস্ট চালাতে দেয়। পূর্বে বর্ণিত নিলাম কন্ট্র্যাক্টে কাজ করা একজন ডেভেলপার নেগেটিভ টেস্ট চালানোর আগে এর আচরণ সম্পর্কে নিম্নলিখিত অ্যাসারশনগুলি করতে পারেন:

- নিলাম শেষ হয়ে গেলে বা শুরু না হলে ব্যবহারকারীরা বিড করতে পারবে না।

- গ্রহণযোগ্য থ্রেশহোল্ডের নিচে বিড হলে নিলাম কন্ট্র্যাক্টটি রিভার্ট হয়ে যায়।

- যে ব্যবহারকারীরা বিড জিততে ব্যর্থ হয় তাদের ফান্ড তাদের অ্যাকাউন্টে জমা করে দেওয়া হয়।

**দ্রষ্টব্য**: অনুমান পরীক্ষা করার আরেকটি উপায় হল এমন টেস্ট লেখা যা একটি কন্ট্র্যাক্টে [ফাংশন মডিফায়ার](https://docs.soliditylang.org/en/v0.8.16/contracts.html#function-modifiers) ট্রিগার করে, বিশেষ করে `require`, `assert`, এবং `if…else` স্টেটমেন্ট।

##### 3. কোড কভারেজ পরিমাপ করুন

[কোড কভারেজ](https://en.m.wikipedia.org/wiki/Code_coverage) একটি টেস্টিং মেট্রিক যা টেস্ট চলাকালীন আপনার কোডে এক্সিকিউট করা ব্রাঞ্চ, লাইন এবং স্টেটমেন্টের সংখ্যা ট্র্যাক করে। পরীক্ষা না করা দুর্বলতার ঝুঁকি কমাতে টেস্টগুলির ভালো কোড কভারেজ থাকা উচিত। পর্যাপ্ত কভারেজ ছাড়া, আপনি ভুলভাবে ধরে নিতে পারেন যে আপনার কন্ট্র্যাক্টটি সুরক্ষিত কারণ সমস্ত টেস্ট পাস হয়েছে, যদিও পরীক্ষা না করা কোড পাথে দুর্বলতা এখনও বিদ্যমান থাকতে পারে। তবে, উচ্চ কোড কভারেজ রেকর্ড করা এই নিশ্চয়তা দেয় যে একটি স্মার্ট কন্ট্র্যাক্টের সমস্ত স্টেটমেন্ট/ফাংশন সঠিকতার জন্য পর্যাপ্তভাবে পরীক্ষা করা হয়েছে।

##### ৪. সু-বিকশিত টেস্টিং ফ্রেমওয়ার্ক ব্যবহার করুন

আপনার স্মার্ট কন্ট্র্যাক্টের জন্য ইউনিট টেস্ট চালানোর জন্য ব্যবহৃত টুলগুলির গুণমান অত্যন্ত গুরুত্বপূর্ণ। একটি আদর্শ টেস্টিং ফ্রেমওয়ার্ক হল এমন একটি যা নিয়মিত রক্ষণাবেক্ষণ করা হয়; দরকারী বৈশিষ্ট্য (যেমন, লগিং এবং রিপোর্টিং ক্ষমতা) প্রদান করে; এবং অবশ্যই অন্য ডেভেলপারদের দ্বারা ব্যাপকভাবে ব্যবহৃত এবং পরীক্ষিত হতে হবে।

Solidity স্মার্ট কন্ট্র্যাক্টের জন্য ইউনিট টেস্টিং ফ্রেমওয়ার্ক বিভিন্ন ভাষায় (বেশিরভাগ JavaScript, Python, এবং Rust) আসে। বিভিন্ন টেস্টিং ফ্রেমওয়ার্কের সাথে ইউনিট টেস্ট চালানো শুরু করার তথ্যের জন্য নীচের কিছু গাইড দেখুন:

- **[Brownie দিয়ে ইউনিট টেস্ট চালানো](https://eth-brownie.readthedocs.io/en/v1.0.0_a/tests.html)**
- **[Foundry দিয়ে ইউনিট টেস্ট চালানো](https://book.getfoundry.sh/forge/writing-tests)**
- **[Waffle দিয়ে ইউনিট টেস্ট চালানো](https://ethereum-waffle.readthedocs.io/en/latest/getting-started.html#writing-tests)**
- **[Remix দিয়ে ইউনিট টেস্ট চালানো](https://remix-ide.readthedocs.io/en/latest/unittesting.html#write-tests)**
- **[Ape দিয়ে ইউনিট টেস্ট চালানো](https://docs.apeworx.io/ape/stable/userguides/testing.html)**
- **[Hardhat দিয়ে ইউনিট টেস্ট চালানো](https://hardhat.org/hardhat-runner/docs/guides/test-contracts)**
- **[Wake দিয়ে ইউনিট টেস্ট চালানো](https://ackeeblockchain.com/wake/docs/latest/testing-framework/overview/)**

### ইন্টিগ্রেশন টেস্টিং {#integration-testing-for-smart-contracts}

যেখানে ইউনিট টেস্টিং বিচ্ছিন্নভাবে কন্ট্র্যাক্ট ফাংশন ডিবাগ করে, সেখানে ইন্টিগ্রেশন টেস্টগুলি একটি স্মার্ট কন্ট্র্যাক্টের উপাদানগুলিকে সামগ্রিকভাবে মূল্যায়ন করে। ইন্টিগ্রেশন টেস্টিং ক্রস-কন্ট্র্যাক্ট কল বা একই স্মার্ট কন্ট্র্যাক্টে বিভিন্ন ফাংশনের মধ্যে মিথস্ক্রিয়া থেকে উদ্ভূত সমস্যাগুলি সনাক্ত করতে পারে। উদাহরণস্বরূপ, ইন্টিগ্রেশন টেস্ট [ইনহেরিটেন্স](https://docs.soliditylang.org/en/v0.8.12/contracts.html#inheritance) এবং ডিপেন্ডেন্সি ইনজেকশনের মতো জিনিসগুলি সঠিকভাবে কাজ করে কিনা তা পরীক্ষা করতে সাহায্য করতে পারে।

আপনার কন্ট্র্যাক্টটি যদি একটি মডুলার আর্কিটেকচার গ্রহণ করে বা এক্সিকিউশনের সময় অন্য অনচেইন কন্ট্র্যাক্টের সাথে ইন্টারফেস করে তবে ইন্টিগ্রেশন টেস্টিং কার্যকর। ইন্টিগ্রেশন টেস্ট চালানোর একটি উপায় হল একটি নির্দিষ্ট উচ্চতায় [ব্লকচেইন ফর্ক](/glossary/#fork) করা ([Forge](https://book.getfoundry.sh/forge/fork-testing) বা [Hardhat](https://hardhat.org/hardhat-network/docs/guides/forking-other-networks) এর মতো একটি টুল ব্যবহার করে) এবং আপনার কন্ট্র্যাক্ট এবং ডেপ্লয় করা কন্ট্র্যাক্টগুলির মধ্যে মিথস্ক্রিয়া অনুকরণ করা।

ফর্ক করা ব্লকচেইনটি Mainnet-এর মতোই আচরণ করবে এবং সংশ্লিষ্ট স্টেট এবং ব্যালেন্সসহ অ্যাকাউন্ট থাকবে। কিন্তু এটি শুধুমাত্র একটি স্যান্ডবক্সড লোকাল ডেভেলপমেন্ট এনভায়রনমেন্ট হিসেবে কাজ করে, যার মানে হল আপনার লেনদেনের জন্য প্রকৃত ETH-এর প্রয়োজন হবে না, উদাহরণস্বরূপ, বা আপনার পরিবর্তনগুলি প্রকৃত ইথেরিয়াম প্রোটোকলকে প্রভাবিত করবে না।

### প্রপার্টি-ভিত্তিক টেস্টিং {#property-based-testing-for-smart-contracts}

প্রপার্টি-ভিত্তিক টেস্টিং হল একটি স্মার্ট কন্ট্র্যাক্ট কোনো নির্দিষ্ট প্রপার্টি পূরণ করে কিনা তা পরীক্ষা করার প্রক্রিয়া। প্রপার্টিগুলি একটি কন্ট্র্যাক্টের আচরণ সম্পর্কে এমন তথ্য দাবি করে যা বিভিন্ন পরিস্থিতিতে সত্য থাকবে বলে আশা করা হয়—একটি স্মার্ট কন্ট্র্যাক্ট প্রপার্টির উদাহরণ হতে পারে "কন্ট্র্যাক্টে গাণিতিক ক্রিয়াকলাপগুলি কখনও ওভারফ্লো বা আন্ডারফ্লো হয় না।"

**স্ট্যাটিক বিশ্লেষণ** এবং **ডাইনামিক বিশ্লেষণ** হল প্রপার্টি-ভিত্তিক টেস্টিং সম্পাদনের দুটি সাধারণ কৌশল, এবং উভয়ই যাচাই করতে পারে যে একটি প্রোগ্রামের কোড (এই ক্ষেত্রে একটি স্মার্ট কন্ট্র্যাক্ট) কিছু পূর্বনির্ধারিত প্রপার্টি পূরণ করে। কিছু প্রপার্টি-ভিত্তিক টেস্টিং টুলস প্রত্যাশিত কন্ট্র্যাক্ট প্রপার্টি সম্পর্কে পূর্বনির্ধারিত নিয়ম নিয়ে আসে এবং সেই নিয়মগুলির বিরুদ্ধে কোডটি পরীক্ষা করে, অন্যগুলি আপনাকে একটি স্মার্ট কন্ট্র্যাক্টের জন্য কাস্টম প্রপার্টি তৈরি করতে দেয়।

#### স্ট্যাটিক বিশ্লেষণ {#static-analysis}

একটি স্ট্যাটিক অ্যানালাইজার একটি স্মার্ট কন্ট্র্যাক্টের সোর্স কোড ইনপুট হিসাবে নেয় এবং একটি কন্ট্র্যাক্ট একটি প্রপার্টি পূরণ করে কিনা তা ঘোষণা করে ফলাফল আউটপুট দেয়। ডাইনামিক বিশ্লেষণের বিপরীতে, স্ট্যাটিক বিশ্লেষণে সঠিকতার জন্য একটি কন্ট্র্যাক্ট এক্সিকিউট করা জড়িত থাকে না। স্ট্যাটিক বিশ্লেষণ বরং একটি স্মার্ট কন্ট্র্যাক্ট এক্সিকিউশনের সময় যে সমস্ত সম্ভাব্য পথ নিতে পারে সে সম্পর্কে যুক্তি দেয় (অর্থাৎ, রানটাইমে কন্ট্র্যাক্টের অপারেশনের জন্য এর অর্থ কী হবে তা নির্ধারণ করতে সোর্স কোডের কাঠামো পরীক্ষা করে)।

[লিন্টিং](https://www.perforce.com/blog/qac/what-is-linting) এবং [স্ট্যাটিক টেস্টিং](https://www.techtarget.com/whatis/definition/static-analysis-static-code-analysis) হল কন্ট্র্যাক্টে স্ট্যাটিক বিশ্লেষণ চালানোর সাধারণ পদ্ধতি। উভয়ের জন্যই কন্ট্র্যাক্টের এক্সিকিউশনের নিম্ন-স্তরের উপস্থাপনা যেমন কম্পাইলার দ্বারা আউটপুট করা [অ্যাবস্ট্রাক্ট সিনট্যাক্স ট্রি](https://en.m.wikipedia.org/wiki/Abstract_syntax_tree) এবং [কন্ট্রোল ফ্লো গ্রাফ](https://www.geeksforgeeks.org/software-engineering-control-flow-graph-cfg/amp/) বিশ্লেষণ করা প্রয়োজন।

বেশিরভাগ ক্ষেত্রে, স্ট্যাটিক বিশ্লেষণ একটি কন্ট্র্যাক্টের কোডে অনিরাপদ কনস্ট্রাক্টের ব্যবহার, সিনট্যাক্স ত্রুটি, বা কোডিং স্ট্যান্ডার্ড লঙ্ঘনের মতো নিরাপত্তা সমস্যা সনাক্ত করার জন্য উপযোগী। তবে, স্ট্যাটিক অ্যানালাইজারগুলি গভীরতর দুর্বলতা সনাক্ত করতে সাধারণত অসম্পূর্ণ বলে পরিচিত, এবং অতিরিক্ত ফলস পজিটিভ তৈরি করতে পারে।

#### ডাইনামিক বিশ্লেষণ {#dynamic-analysis}

ডাইনামিক বিশ্লেষণ একটি স্মার্ট কন্ট্র্যাক্টের ফাংশনগুলিতে সিম্বলিক ইনপুট (যেমন, [সিম্বলিক এক্সিকিউশনে](https://en.m.wikipedia.org/wiki/Symbolic_execution)) বা কংক্রিট ইনপুট (যেমন, [ফাজিং-এ](https://owasp.org/www-community/Fuzzing)) তৈরি করে তা দেখতে যে কোনো এক্সিকিউশন ট্রেস নির্দিষ্ট বৈশিষ্ট্য লঙ্ঘন করে কিনা। এই ধরনের প্রপার্টি-ভিত্তিক টেস্টিং ইউনিট টেস্ট থেকে ভিন্ন কারণ টেস্ট কেসগুলি একাধিক পরিস্থিতি কভার করে এবং একটি প্রোগ্রাম টেস্ট কেস তৈরির কাজ পরিচালনা করে।

[ফাজিং](https://www.halborn.com/blog/post/what-is-fuzz-testing-fuzzing) স্মার্ট কন্ট্র্যাক্টে নির্বিচারে প্রপার্টি যাচাই করার জন্য একটি ডাইনামিক বিশ্লেষণ কৌশলের উদাহরণ। একটি ফাজার একটি টার্গেট কন্ট্র্যাক্টে একটি সংজ্ঞায়িত ইনপুট মানের র‍্যান্ডম বা ত্রুটিপূর্ণ ভিন্নতা দিয়ে ফাংশনগুলিকে কল করে। যদি স্মার্ট কন্ট্র্যাক্টটি একটি ত্রুটিপূর্ণ স্টেটে প্রবেশ করে (যেমন, যেখানে একটি অ্যাসারশন ব্যর্থ হয়), সমস্যাটি ফ্ল্যাগ করা হয় এবং দুর্বল পাথের দিকে এক্সিকিউশন চালনাকারী ইনপুটগুলি একটি রিপোর্টে তৈরি করা হয়।

ফাজিং একটি স্মার্ট কন্ট্র্যাক্টের ইনপুট বৈধকরণ প্রক্রিয়া মূল্যায়নের জন্য উপযোগী কারণ অপ্রত্যাশিত ইনপুটগুলির অনুপযুক্ত হ্যান্ডলিংয়ের ফলে অনিচ্ছাকৃত এক্সিকিউশন হতে পারে এবং বিপজ্জনক প্রভাব তৈরি করতে পারে। এই ধরনের প্রপার্টি-ভিত্তিক টেস্টিং অনেক কারণে আদর্শ হতে পারে:

1. **অনেক পরিস্থিতি কভার করার জন্য টেস্ট কেস লেখা কঠিন।** একটি প্রপার্টি টেস্টে শুধুমাত্র একটি আচরণ এবং আচরণের সাথে পরীক্ষা করার জন্য ডেটার একটি পরিসীমা সংজ্ঞায়িত করতে হয়—প্রোগ্রামটি সংজ্ঞায়িত প্রপার্টির উপর ভিত্তি করে স্বয়ংক্রিয়ভাবে টেস্ট কেস তৈরি করে।

2. **আপনার টেস্ট স্যুট প্রোগ্রামের মধ্যে সমস্ত সম্ভাব্য পথ পর্যাপ্তভাবে কভার নাও করতে পারে।** এমনকি 100% কভারেজ সহ, এজ কেসগুলি মিস করা সম্ভব।

3. **ইউনিট টেস্ট প্রমাণ করে যে একটি কন্ট্র্যাক্ট নমুনা ডেটার জন্য সঠিকভাবে এক্সিকিউট হয়, কিন্তু কন্ট্র্যাক্টটি নমুনার বাইরের ইনপুটগুলির জন্য সঠিকভাবে এক্সিকিউট হয় কিনা তা অজানা থেকে যায়।** প্রপার্টি টেস্টগুলি একটি প্রদত্ত ইনপুট মানের একাধিক ভিন্নতা দিয়ে একটি টার্গেট কন্ট্র্যাক্ট এক্সিকিউট করে যা অ্যাসারশন ব্যর্থতার কারণ হয় এমন এক্সিকিউশন ট্রেস খুঁজে বের করতে। সুতরাং, একটি প্রপার্টি টেস্ট আরও বেশি গ্যারান্টি প্রদান করে যে একটি কন্ট্র্যাক্ট ইনপুট ডেটার একটি বিস্তৃত শ্রেণীর জন্য সঠিকভাবে এক্সিকিউট হয়।

### স্মার্ট কন্ট্র্যাক্টের জন্য প্রপার্টি-ভিত্তিক টেস্টিং চালানোর নির্দেশিকা {#running-property-based-tests}

প্রপার্টি-ভিত্তিক টেস্টিং সাধারণত একটি প্রপার্টি (যেমন, [পূর্ণসংখ্যা ওভারফ্লোর](https://github.com/ConsenSys/mythril/wiki/Integer-Overflow) অনুপস্থিতি) বা প্রপার্টিগুলির একটি সংগ্রহ সংজ্ঞায়িত করার মাধ্যমে শুরু হয় যা আপনি একটি স্মার্ট কন্ট্র্যাক্টে যাচাই করতে চান। প্রপার্টি টেস্ট লেখার সময় আপনাকে একটি মানের পরিসীমাও সংজ্ঞায়িত করতে হতে পারে যার মধ্যে প্রোগ্রামটি লেনদেন ইনপুটের জন্য ডেটা তৈরি করতে পারে।

সঠিকভাবে কনফিগার করার পরে, প্রপার্টি টেস্টিং টুল আপনার স্মার্ট কন্ট্র্যাক্টের ফাংশনগুলিকে র‍্যান্ডমভাবে তৈরি করা ইনপুট দিয়ে এক্সিকিউট করবে। যদি কোনো অ্যাসারশন লঙ্ঘন হয়, তাহলে আপনার মূল্যায়নের অধীনে থাকা প্রপার্টি লঙ্ঘনকারী কংক্রিট ইনপুট ডেটা সহ একটি রিপোর্ট পাওয়া উচিত। বিভিন্ন টুলস দিয়ে প্রপার্টি-ভিত্তিক টেস্টিং চালানো শুরু করতে নীচের কিছু গাইড দেখুন:

- **[Slither দিয়ে স্মার্ট কন্ট্র্যাক্টের স্ট্যাটিক বিশ্লেষণ](https://github.com/crytic/slither)**
- **[Wake দিয়ে স্মার্ট কন্ট্র্যাক্টের স্ট্যাটিক বিশ্লেষণ](https://ackeeblockchain.com/wake/docs/latest/static-analysis/using-detectors/)**
- **[Brownie দিয়ে প্রপার্টি-ভিত্তিক টেস্টিং](https://eth-brownie.readthedocs.io/en/stable/tests-hypothesis-property.html)**
- **[Foundry দিয়ে কন্ট্র্যাক্ট ফাজিং](https://book.getfoundry.sh/forge/fuzz-testing)**
- **[Echidna দিয়ে কন্ট্র্যাক্ট ফাজিং](https://github.com/crytic/building-secure-contracts/tree/master/program-analysis/echidna#echidna-tutorial)**
- **[Wake দিয়ে কন্ট্র্যাক্ট ফাজিং](https://ackeeblockchain.com/wake/docs/latest/testing-framework/fuzzing/)**
- **[Manticore দিয়ে স্মার্ট কন্ট্র্যাক্টের সিম্বলিক এক্সিকিউশন](https://github.com/crytic/building-secure-contracts/tree/master/program-analysis/manticore#manticore-tutorial)**
- **[Mythril দিয়ে স্মার্ট কন্ট্র্যাক্টের সিম্বলিক এক্সিকিউশন](https://mythril-classic.readthedocs.io/en/master/tutorial.html)**

## স্মার্ট কন্ট্র্যাক্টের জন্য ম্যানুয়াল টেস্টিং {#manual-testing-for-smart-contracts}

স্মার্ট কন্ট্র্যাক্টের ম্যানুয়াল টেস্টিং প্রায়শই স্বয়ংক্রিয় টেস্ট চালানোর পরে ডেভেলপমেন্ট সাইকেলের পরবর্তী পর্যায়ে আসে। এই ধরনের টেস্টিং স্মার্ট কন্ট্র্যাক্টকে একটি সম্পূর্ণ সমন্বিত পণ্য হিসাবে মূল্যায়ন করে তা দেখতে যে এটি প্রযুক্তিগত প্রয়োজনীয়তাগুলিতে নির্দিষ্ট হিসাবে কাজ করে কিনা।

### একটি স্থানীয় ব্লকচেইনে কন্ট্র্যাক্ট টেস্টিং {#testing-on-local-blockchain}

যদিও একটি স্থানীয় ডেভেলপমেন্ট পরিবেশে সঞ্চালিত স্বয়ংক্রিয় টেস্টিং দরকারী ডিবাগিং তথ্য সরবরাহ করতে পারে, আপনি জানতে চাইবেন আপনার স্মার্ট কন্ট্র্যাক্ট একটি প্রোডাকশন পরিবেশে কীভাবে আচরণ করে। তবে, মূল ইথেরিয়াম চেইনে ডেপ্লয় করতে গ্যাস ফি লাগে—এছাড়াও, আপনার স্মার্ট কন্ট্র্যাক্টে যদি এখনও বাগ থাকে তবে আপনি বা আপনার ব্যবহারকারীরা প্রকৃত অর্থ হারাতে পারেন।

Mainnet-এ টেস্টিং করার একটি প্রস্তাবিত বিকল্প হল আপনার কন্ট্র্যাক্টটিকে একটি স্থানীয় ব্লকচেইনে ([ডেভেলপমেন্ট নেটওয়ার্ক](/developers/docs/development-networks/) হিসাবেও পরিচিত) পরীক্ষা করা। একটি স্থানীয় ব্লকচেইন হল ইথেরিয়াম ব্লকচেইনের একটি অনুলিপি যা আপনার কম্পিউটারে স্থানীয়ভাবে চলে এবং যা ইথেরিয়ামের এক্সিকিউশন লেয়ারের আচরণকে অনুকরণ করে। যেমন, আপনি উল্লেখযোগ্য ওভারহেড ছাড়াই একটি কন্ট্র্যাক্টের সাথে ইন্টারঅ্যাক্ট করার জন্য লেনদেন প্রোগ্রাম করতে পারেন।

একটি স্থানীয় ব্লকচেইনে কন্ট্র্যাক্ট চালানো ম্যানুয়াল ইন্টিগ্রেশন টেস্টিংয়ের একটি রূপ হিসাবে কার্যকর হতে পারে। [স্মার্ট কন্ট্র্যাক্টগুলি অত্যন্ত কম্পোজেবল](/developers/docs/smart-contracts/composability/), যা আপনাকে বিদ্যমান প্রোটোকলগুলির সাথে একীভূত করার অনুমতি দেয়—কিন্তু আপনাকে এখনও নিশ্চিত করতে হবে যে এই ধরনের জটিল অনচেইন ইন্টারঅ্যাকশনগুলি সঠিক ফলাফল তৈরি করে।

[ডেভেলপমেন্ট নেটওয়ার্ক সম্পর্কে আরও।](/developers/docs/development-networks/)

### টেস্টনেটে কন্ট্র্যাক্ট টেস্টিং {#testing-contracts-on-testnets}

একটি টেস্ট নেটওয়ার্ক বা টেস্টনেট ঠিক ইথেরিয়াম Mainnet-এর মতো কাজ করে, তবে এটি এমন ইথার (ETH) ব্যবহার করে যার কোনো বাস্তব-বিশ্বের মূল্য নেই। একটি [টেস্টনেটে](/developers/docs/networks/#ethereum-testnets) আপনার কন্ট্র্যাক্ট ডেপ্লয় করার মানে হল যে কেউ এটির সাথে (যেমন, ডিএ্যাপ-এর ফ্রন্টএন্ডের মাধ্যমে) তহবিল ঝুঁকিতে না ফেলে ইন্টারঅ্যাক্ট করতে পারে।

এই ধরনের ম্যানুয়াল টেস্টিং একজন ব্যবহারকারীর দৃষ্টিকোণ থেকে আপনার অ্যাপ্লিকেশনের এন্ড-টু-এন্ড ফ্লো মূল্যায়নের জন্য উপযোগী। এখানে, বিটা টেস্টাররা ট্রায়াল রান করতে পারে এবং কন্ট্র্যাক্টের ব্যবসায়িক যুক্তি এবং সামগ্রিক কার্যকারিতার সাথে সম্পর্কিত যেকোনো সমস্যা রিপোর্ট করতে পারে।

একটি স্থানীয় ব্লকচেইনে পরীক্ষা করার পরে একটি টেস্টনেটে ডেপ্লয় করা আদর্শ কারণ পরেরটি ইথিরিয়াম ভার্চুয়াল মেশিনের আচরণের কাছাকাছি। অতএব, অনেক ইথেরিয়াম-নেটিভ প্রকল্পের জন্য বাস্তব-বিশ্বের পরিস্থিতিতে একটি স্মার্ট কন্ট্র্যাক্টের অপারেশন মূল্যায়ন করতে টেস্টনেটে ডিএ্যাপস ডেপ্লয় করা সাধারণ।

[ইথেরিয়াম টেস্টনেট সম্পর্কে আরও।](/developers/docs/development-networks/#public-beacon-testchains)

## টেস্টিং বনাম ফর্মাল ভেরিফিকেশন {#testing-vs-formal-verification}

যদিও টেস্টিং নিশ্চিত করতে সাহায্য করে যে একটি কন্ট্র্যাক্ট কিছু ডেটা ইনপুটের জন্য প্রত্যাশিত ফলাফল দেয়, এটি পরীক্ষার সময় ব্যবহৃত হয়নি এমন ইনপুটগুলির জন্য একই প্রমাণ চূড়ান্তভাবে করতে পারে না। অতএব, একটি স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করা "ফাংশনাল সঠিকতা"-র গ্যারান্টি দিতে পারে না (অর্থাৎ, এটি দেখাতে পারে না যে একটি প্রোগ্রাম _সমস্ত_ ইনপুট মানের সেটের জন্য প্রয়োজন অনুযায়ী আচরণ করে)।

ফর্মাল ভেরিফিকেশন হল একটি প্রোগ্রামের ফর্মাল মডেল একটি ফর্মাল স্পেসিফিকেশনের সাথে মেলে কিনা তা পরীক্ষা করে সফ্টওয়্যারের সঠিকতা মূল্যায়ন করার একটি পদ্ধতি। একটি ফর্মাল মডেল হল একটি প্রোগ্রামের একটি বিমূর্ত গাণিতিক উপস্থাপনা, যেখানে একটি ফর্মাল স্পেসিফিকেশন একটি প্রোগ্রামের বৈশিষ্ট্যগুলি (অর্থাৎ, প্রোগ্রামের এক্সিকিউশন সম্পর্কে যৌক্তিক দাবি) সংজ্ঞায়িত করে।

যেহেতু প্রপার্টিগুলি গাণিতিক পরিভাষায় লেখা হয়, তাই সিস্টেমের একটি ফর্মাল (গাণিতিক) মডেল যৌক্তিক অনুমানের নিয়ম ব্যবহার করে একটি স্পেসিফিকেশন পূরণ করে কিনা তা যাচাই করা সম্ভব হয়। এইভাবে, বলা হয় যে ফর্মাল ভেরিফিকেশন টুলস একটি সিস্টেমের সঠিকতার ‘গাণিতিক প্রমাণ’ তৈরি করে।

টেস্টিংয়ের বিপরীতে, ফর্মাল ভেরিফিকেশন একটি স্মার্ট কন্ট্র্যাক্টের এক্সিকিউশন _সমস্ত_ এক্সিকিউশনের জন্য একটি ফর্মাল স্পেসিফিকেশন পূরণ করে কিনা তা যাচাই করতে ব্যবহার করা যেতে পারে (অর্থাৎ, এতে কোনো বাগ নেই) নমুনা ডেটা দিয়ে এক্সিকিউট করার প্রয়োজন ছাড়াই। এটি কেবল কয়েক ডজন ইউনিট টেস্ট চালানোর সময় ব্যয় কমায় না, বরং এটি লুকানো দুর্বলতা ধরতে আরও কার্যকর। বলা বাহুল্য, ফর্মাল ভেরিফিকেশন কৌশলগুলি তাদের বাস্তবায়নের অসুবিধা এবং উপযোগিতার উপর নির্ভর করে একটি স্পেকট্রামে অবস্থান করে।

[স্মার্ট কন্ট্র্যাক্টের জন্য ফর্মাল ভেরিফিকেশন সম্পর্কে আরও।](/developers/docs/smart-contracts/formal-verification)

## টেস্টিং বনাম অডিট এবং বাগ বাউন্টি {#testing-vs-audits-bug-bounties}

যেমন উল্লেখ করা হয়েছে, কঠোর টেস্টিং খুব কমই একটি কন্ট্র্যাক্টে বাগের অনুপস্থিতির গ্যারান্টি দিতে পারে; ফর্মাল ভেরিফিকেশন পদ্ধতিগুলি সঠিকতার শক্তিশালী আশ্বাস দিতে পারে তবে বর্তমানে ব্যবহার করা কঠিন এবং যথেষ্ট ব্যয়সাপেক্ষ।

তবুও, আপনি একটি স্বাধীন কোড রিভিউ পেয়ে কন্ট্র্যাক্টের দুর্বলতা ধরার সম্ভাবনা আরও বাড়াতে পারেন। [স্মার্ট কন্ট্র্যাক্ট অডিট](https://www.immunebytes.com/blog/what-is-a-smart-contract-audit/) এবং [বাগ বাউন্টি](https://medium.com/immunefi/a-defi-security-standard-the-scaling-bug-bounty-9b83dfdc1ba7) হল আপনার কন্ট্র্যাক্টগুলি অন্যদের দ্বারা বিশ্লেষণ করানোর দুটি উপায়।

স্মার্ট কন্ট্র্যাক্টে নিরাপত্তা ত্রুটি এবং দুর্বল ডেভেলপমেন্ট অনুশীলনের ঘটনা খুঁজে বের করতে অভিজ্ঞ অডিটরদের দ্বারা অডিট করা হয়। একটি অডিটে সাধারণত টেস্টিং (এবং সম্ভবত ফর্মাল ভেরিফিকেশন) এবং সম্পূর্ণ কোডবেসের একটি ম্যানুয়াল রিভিউ অন্তর্ভুক্ত থাকে।

বিপরীতভাবে, একটি বাগ বাউন্টি প্রোগ্রামে সাধারণত একজন ব্যক্তিকে (সাধারণত [হোয়াইটহ্যাট হ্যাকার](https://en.wikipedia.org/wiki/White_hat_\(computer_security\)) হিসাবে বর্ণিত) আর্থিক পুরস্কার অফার করা হয় যিনি একটি স্মার্ট কন্ট্র্যাক্টে একটি দুর্বলতা আবিষ্কার করেন এবং ডেভেলপারদের কাছে তা প্রকাশ করেন। বাগ বাউন্টি অডিটের মতোই, কারণ এতে অন্যদের স্মার্ট কন্ট্র্যাক্টে ত্রুটি খুঁজে পেতে সাহায্য করার জন্য বলা হয়।

প্রধান পার্থক্য হল বাগ বাউন্টি প্রোগ্রামগুলি বৃহত্তর ডেভেলপার/হ্যাকার সম্প্রদায়ের জন্য উন্মুক্ত এবং অনন্য দক্ষতা এবং অভিজ্ঞতা সহ বিস্তৃত শ্রেণীর নৈতিক হ্যাকার এবং স্বাধীন নিরাপত্তা পেশাদারদের আকর্ষণ করে। এটি স্মার্ট কন্ট্র্যাক্ট অডিটের চেয়ে একটি সুবিধা হতে পারে যা মূলত এমন দলগুলির উপর নির্ভর করে যাদের সীমিত বা সংকীর্ণ দক্ষতা থাকতে পারে।

## টেস্টিং টুলস এবং লাইব্রেরি {#testing-tools-and-libraries}

### ইউনিট টেস্টিং টুলস {#unit-testing-tools}

- **[solidity-coverage](https://github.com/sc-forks/solidity-coverage)** - _Solidity-তে লেখা স্মার্ট কন্ট্র্যাক্টের জন্য কোড কভারেজ টুল।_

- **[Waffle](https://ethereum-waffle.readthedocs.io/en/latest/)** - _উন্নত স্মার্ট কন্ট্র্যাক্ট ডেভেলপমেন্ট এবং টেস্টিংয়ের জন্য ফ্রেমওয়ার্ক (ethers.js-এর উপর ভিত্তি করে)।_

- **[Remix Tests](https://github.com/ethereum/remix-project/tree/master/libs/remix-tests)** - _Solidity স্মার্ট কন্ট্র্যাক্ট টেস্টিং করার জন্য টুল। Remix IDE "Solidity Unit Testing" প্লাগইনের অধীনে কাজ করে যা একটি কন্ট্র্যাক্টের জন্য টেস্ট কেস লিখতে এবং চালাতে ব্যবহৃত হয়।_

- **[OpenZeppelin Test Helpers](https://github.com/OpenZeppelin/openzeppelin-test-helpers)** - _ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট টেস্টিংয়ের জন্য অ্যাসারশন লাইব্রেরি। নিশ্চিত করুন আপনার কন্ট্র্যাক্টগুলো প্রত্যাশা অনুযায়ী আচরণ করে!_

- **[Brownie unit testing framework](https://eth-brownie.readthedocs.io/en/v1.0.0_a/tests.html)** - _ব্রাউনি পাইটেস্ট ব্যবহার করে, যা একটি বৈশিষ্ট্য-সমৃদ্ধ টেস্ট ফ্রেমওয়ার্ক যা আপনাকে ন্যূনতম কোড সহ ছোট টেস্ট লিখতে দেয়, বড় প্রকল্পগুলির জন্য ভালভাবে স্কেল করে এবং অত্যন্ত প্রসারণযোগ্য।_

- **[Foundry Tests](https://github.com/foundry-rs/foundry/tree/master/crates/forge)** - _ফাউন্ড্রি ফোর্জ অফার করে, একটি দ্রুত এবং নমনীয় ইথেরিয়াম টেস্টিং ফ্রেমওয়ার্ক যা সাধারণ ইউনিট টেস্ট, গ্যাস অপ্টিমাইজেশন চেক এবং কন্ট্র্যাক্ট ফাজিং করতে সক্ষম।_

- **[Hardhat Tests](https://hardhat.org/hardhat-runner/docs/guides/test-contracts)** - _ethers.js, Mocha, এবং Chai-এর উপর ভিত্তি করে স্মার্ট কন্ট্র্যাক্ট টেস্টিংয়ের জন্য ফ্রেমওয়ার্ক।_

- **[ApeWorx](https://docs.apeworx.io/ape/stable/userguides/testing.html)** - _ইথিরিয়াম ভার্চুয়াল মেশিনকে টার্গেট করে স্মার্ট কন্ট্র্যাক্টের জন্য পাইথন-ভিত্তিক ডেভেলপমেন্ট এবং টেস্টিং ফ্রেমওয়ার্ক।_

- **[Wake](https://ackeeblockchain.com/wake/docs/latest/testing-framework/overview/)** - _ইউনিট টেস্টিং এবং ফাজিংয়ের জন্য পাইথন-ভিত্তিক ফ্রেমওয়ার্ক, যা শক্তিশালী ডিবাগিং ক্ষমতা এবং ক্রস-চেইন টেস্টিং সমর্থন করে, সেরা ব্যবহারকারী অভিজ্ঞতা এবং পারফরম্যান্সের জন্য পাইটেস্ট এবং আনভিল ব্যবহার করে।_

### প্রপার্টি-ভিত্তিক টেস্টিং টুলস {#property-based-testing-tools}

#### স্ট্যাটিক বিশ্লেষণ টুলস {#static-analysis-tools}

- **[Slither](https://github.com/crytic/slither)** - _দুর্বলতা খুঁজে বের করা, কোড বোঝা বাড়ানো এবং স্মার্ট কন্ট্র্যাক্টের জন্য কাস্টম বিশ্লেষণ লেখার জন্য পাইথন-ভিত্তিক সলিডিটি স্ট্যাটিক বিশ্লেষণ ফ্রেমওয়ার্ক।_

- **[Ethlint](https://ethlint.readthedocs.io/en/latest/)** - _Solidity স্মার্ট কন্ট্র্যাক্ট প্রোগ্রামিং ভাষার জন্য স্টাইল এবং নিরাপত্তা সেরা অনুশীলন প্রয়োগের জন্য লিন্টার।_

- **[Cyfrin Aderyn](https://cyfrin.io/tools/aderyn)** - _Rust-ভিত্তিক স্ট্যাটিক অ্যানালাইজার যা বিশেষভাবে Web3 স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা এবং ডেভেলপমেন্টের জন্য ডিজাইন করা হয়েছে।_

- **[Wake](https://ackeeblockchain.com/wake/docs/latest/static-analysis/using-detectors/)** - _দুর্বলতা এবং কোডের গুণমান ডিটেক্টর, কোড থেকে দরকারী তথ্য বের করার জন্য প্রিন্টার এবং কাস্টম সাবমডিউল লেখার সমর্থন সহ পাইথন-ভিত্তিক স্ট্যাটিক বিশ্লেষণ ফ্রেমওয়ার্ক।_

- **[Slippy](https://github.com/fvictorio/slippy)** - _Solidity-র জন্য একটি সহজ এবং শক্তিশালী লিন্টার।_

#### ডাইনামিক বিশ্লেষণ টুলস {#dynamic-analysis-tools}

- **[Echidna](https://github.com/crytic/echidna/)** - _প্রপার্টি-ভিত্তিক টেস্টিংয়ের মাধ্যমে স্মার্ট কন্ট্র্যাক্টে দুর্বলতা সনাক্ত করার জন্য দ্রুত কন্ট্র্যাক্ট ফাজার।_

- **[Diligence Fuzzing](https://consensys.net/diligence/fuzzing/)** - _স্মার্ট কন্ট্র্যাক্ট কোডে প্রপার্টি লঙ্ঘন সনাক্ত করার জন্য স্বয়ংক্রিয় ফাজিং টুল।_

- **[Manticore](https://manticore.readthedocs.io/en/latest/index.html)** - _EVM বাইটকোড বিশ্লেষণের জন্য ডাইনামিক সিম্বলিক এক্সিকিউশন ফ্রেমওয়ার্ক।_

- **[Mythril](https://github.com/ConsenSys/mythril-classic)** - _টেইন্ট বিশ্লেষণ, কনকোলিক বিশ্লেষণ এবং কন্ট্রোল ফ্লো চেকিং ব্যবহার করে কন্ট্র্যাক্টের দুর্বলতা সনাক্ত করার জন্য EVM বাইটকোড মূল্যায়ন টুল।_

- **[Diligence Scribble](https://consensys.net/diligence/scribble/)** - _স্ক্রিবল একটি স্পেসিফিকেশন ভাষা এবং রানটাইম ভেরিফিকেশন টুল যা আপনাকে স্মার্ট কন্ট্র্যাক্টগুলিকে এমন বৈশিষ্ট্যগুলির সাথে টীকা করতে দেয় যা আপনাকে ডিলিজেন্স ফাজিং বা মিথএক্স-এর মতো টুলস দিয়ে স্বয়ংক্রিয়ভাবে কন্ট্র্যাক্টগুলি পরীক্ষা করতে দেয়।_

## সম্পর্কিত টিউটোরিয়াল {#related-tutorials}

- [বিভিন্ন টেস্টিং পণ্যের একটি সংক্ষিপ্ত বিবরণ এবং তুলনা](/developers/tutorials/guide-to-smart-contract-security-tools/) \_
- [স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করার জন্য কীভাবে একিডনা ব্যবহার করবেন](/developers/tutorials/how-to-use-echidna-to-test-smart-contracts/)
- [স্মার্ট কন্ট্র্যাক্ট বাগ খুঁজে পেতে কিভাবে Manticore ব্যবহার করবেন](/developers/tutorials/how-to-use-manticore-to-find-smart-contract-bugs/)
- [স্মার্ট কন্ট্র্যাক্ট বাগ খুঁজে পেতে কিভাবে Slither ব্যবহার করবেন](/developers/tutorials/how-to-use-slither-to-find-smart-contract-bugs/)
- [টেস্টিংয়ের জন্য কীভাবে সলিডিটি কন্ট্র্যাক্ট মক করবেন](/developers/tutorials/how-to-mock-solidity-contracts-for-testing/)
- [ফাউন্ড্রি ব্যবহার করে সলিডিটিতে কীভাবে ইউনিট টেস্ট চালাবেন](https://www.rareskills.io/post/foundry-testing-solidity)

## আরও পড়ুন {#further-reading}

- [ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট টেস্টিংয়ের একটি গভীর নির্দেশিকা](https://iamdefinitelyahuman.medium.com/an-in-depth-guide-to-testing-ethereum-smart-contracts-2e41b2770297)
- [কীভাবে ইথেরিয়াম স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করবেন](https://betterprogramming.pub/how-to-test-ethereum-smart-contracts-35abc8fa199d)
- [ডেভেলপারদের জন্য MolochDAO-এর ইউনিট টেস্টিং নির্দেশিকা](https://github.com/MolochVentures/moloch/tree/4e786db8a4aa3158287e0935dcbc7b1e43416e38/test#moloch-testing-guide)
- [কীভাবে একজন রকস্টারের মতো স্মার্ট কন্ট্র্যাক্ট পরীক্ষা করবেন](https://forum.openzeppelin.com/t/test-smart-contracts-like-a-rockstar/1001)
