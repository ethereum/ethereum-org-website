---
title: "সেফটি রেলস সহ ERC-20"
description: "লোকেদের বোকার মতো ভুল এড়াতে কীভাবে সাহায্য করবেন"
author: Ori Pomerantz
lang: bn
tags: [ "erc-20" ]
skill: beginner
published: 2022-08-15
---

## ভূমিকা {#introduction}

ইথেরিয়াম সম্পর্কে একটি দুর্দান্ত জিনিস হলো যে কোনও কেন্দ্রীয় কর্তৃপক্ষ নেই যা আপনার লেনদেন পরিবর্তন বা বাতিল করতে পারে। ইথেরিয়ামের একটি বড় সমস্যা হলো যে কোনও কেন্দ্রীয় কর্তৃপক্ষ নেই যার ব্যবহারকারীর ভুল বা অবৈধ লেনদেন বাতিল করার ক্ষমতা রয়েছে। এই নিবন্ধে আপনি [ERC-20](/developers/docs/standards/tokens/erc-20/) টোকেনগুলির সাথে ব্যবহারকারীরা যে সাধারণ ভুলগুলি করে সে সম্পর্কে জানতে পারবেন, সেইসাথে কীভাবে ERC-20 কন্ট্র্যাক্ট তৈরি করতে হয় যা ব্যবহারকারীদের সেই ভুলগুলি এড়াতে সাহায্য করে, বা যা একটি কেন্দ্রীয় কর্তৃপক্ষকে কিছু ক্ষমতা দেয় (উদাহরণস্বরূপ অ্যাকাউন্ট ফ্রিজ করার জন্য)।

মনে রাখবেন যে আমরা [OpenZeppelin ERC-20 টোকেন কন্ট্র্যাক্ট](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) ব্যবহার করব, এই নিবন্ধটি এটিকে খুব বিশদভাবে ব্যাখ্যা করে না। আপনি এই তথ্যটি [এখানে](/developers/tutorials/erc20-annotated-code) খুঁজে পেতে পারেন।

আপনি যদি সম্পূর্ণ সোর্স কোড দেখতে চান:

1. [Remix IDE](https://remix.ethereum.org/) খুলুন।
2. ক্লোন গিটহাব আইকনে ক্লিক করুন (![clone github icon](icon-clone.png))।
3. গিটহাব রিপোজিটরিটি `https://github.com/qbzzt/20220815-erc20-safety-rails` ক্লোন করুন।
4. **contracts > erc20-safety-rails.sol** খুলুন।

## একটি ERC-20 কন্ট্র্যাক্ট তৈরি করা {#creating-an-erc-20-contract}

সেফটি রেল ফাংশনালিটি যোগ করার আগে আমাদের একটি ERC-20 কন্ট্র্যাক্ট প্রয়োজন। এই নিবন্ধে আমরা [OpenZeppelin Contracts Wizard](https://docs.openzeppelin.com/contracts/5.x/wizard) ব্যবহার করব। এটি অন্য ব্রাউজারে খুলুন এবং এই নির্দেশাবলী অনুসরণ করুন:

1. **ERC20** নির্বাচন করুন।

2. এই সেটিংসগুলি লিখুন:

   | প্যারামিটার        | মান                                                            |
   | ------------------ | -------------------------------------------------------------- |
   | নাম                | SafetyRailsToken                                               |
   | প্রতীক             | SAFE                                                           |
   | Premint            | আমরা প্রতি জোড়া টোকেনের জন্য একটির বেশি লিকুইডিটি পুল চাই না। |
   | বৈশিষ্ট্য          | কোনটি না                                                      |
   | অ্যাক্সেস কন্ট্রোল | Ownable                                                        |
   | আপগ্রেডিবিলিটি     | কোনটি না                                                      |

3. উপরে স্ক্রোল করুন এবং **Remix-এ খুলুন** (Remix-এর জন্য) অথবা একটি ভিন্ন এনভায়রনমেন্ট ব্যবহার করার জন্য **ডাউনলোড করুন**-এ ক্লিক করুন। আমি ধরে নিচ্ছি আপনি Remix ব্যবহার করছেন, যদি আপনি অন্য কিছু ব্যবহার করেন তবে শুধু উপযুক্ত পরিবর্তনগুলি করুন।

4. এখন আমাদের একটি সম্পূর্ণরূপে কার্যকরী ERC-20 কন্ট্র্যাক্ট আছে। আপনি ইম্পোর্ট করা কোড দেখতে `.deps` > `npm` விரிৃত করতে পারেন।

5. কন্ট্র্যাক্টটি একটি ERC-20 কন্ট্র্যাক্ট হিসাবে কাজ করে কিনা তা দেখার জন্য কম্পাইল করুন, ডিপ্লয় করুন এবং এর সাথে প্লে করুন। যদি আপনার Remix কীভাবে ব্যবহার করতে হয় তা শেখার প্রয়োজন হয়, [এই টিউটোরিয়ালটি ব্যবহার করুন](https://remix.ethereum.org/?#activate=udapp,solidity,LearnEth)।

## সাধারণ ভুল {#common-mistakes}

### ভুলগুলি {#the-mistakes}

ব্যবহারকারীরা কখনও কখনও ভুল ঠিকানায় টোকেন পাঠান। যদিও আমরা তাদের মন পড়ে জানতে পারি না যে তারা কী করতে চেয়েছিল, তবে দুই ধরণের ভুল রয়েছে যা অনেক ঘটে এবং সহজে সনাক্ত করা যায়:

1. কন্ট্র্যাক্টের নিজের ঠিকানায় টোকেন পাঠানো। উদাহরণস্বরূপ, [Optimism-এর OP টোকেন](https://optimism.mirror.xyz/qvd0WfuLKnePm1Gxb9dpGchPf5uDz5NSMEFdgirDS4c) দুই মাসেরও কম সময়ে [120,000 এর বেশি](https://optimism.blockscout.com/address/0x4200000000000000000000000000000000000042) OP টোকেন জমা করতে সক্ষম হয়েছে। এটি একটি উল্লেখযোগ্য পরিমাণ সম্পদকে প্রতিনিধিত্ব করে যা সম্ভবত মানুষ হারিয়েছে।

2. টোকেনগুলিকে একটি খালি ঠিকানায় পাঠানো, যা একটি [এক্সটার্নালি ওনড অ্যাকাউন্ট](/developers/docs/accounts/#externally-owned-accounts-and-key-pairs) বা একটি [স্মার্ট কন্ট্র্যাক্টের](/developers/docs/smart-contracts) সাথে সঙ্গতিপূর্ণ নয়। যদিও আমার কাছে এটি কত ঘন ঘন ঘটে তার পরিসংখ্যান নেই, [একটি ঘটনায় 20,000,000 টোকেনের ক্ষতি হতে পারত](https://gov.optimism.io/t/message-to-optimism-community-from-wintermute/2595)।

### ট্রান্সফার প্রতিরোধ করা {#preventing-transfers}

OpenZeppelin ERC-20 কন্ট্র্যাক্টে [একটি হুক, `_beforeTokenTransfer`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L364-L368) অন্তর্ভুক্ত রয়েছে, যা একটি টোকেন ট্রান্সফার করার আগে কল করা হয়। ডিফল্টরূপে এই হুকটি কিছুই করে না, কিন্তু আমরা এতে আমাদের নিজস্ব ফাংশনালিটি যোগ করতে পারি, যেমন চেক যা সমস্যা হলে রিভার্ট করে।

হুকটি ব্যবহার করতে, কনস্ট্রাক্টরের পরে এই ফাংশনটি যোগ করুন:

```solidity
    function _beforeTokenTransfer(address from, address to, uint256 amount)
        internal virtual
        override(ERC20)
    {
        super._beforeTokenTransfer(from, to, amount);
    }
```

আপনি যদি Solidity-এর সাথে খুব পরিচিত না হন তবে এই ফাংশনের কিছু অংশ নতুন হতে পারে:

```solidity
        internal virtual
```

`virtual` কীওয়ার্ডটির অর্থ হলো যে আমরা যেমন `ERC20` থেকে ফাংশনালিটি ইনহেরিট করেছি এবং এই ফাংশনটিকে ওভাররাইড করেছি, তেমনি অন্যান্য কন্ট্র্যাক্ট আমাদের কাছ থেকে ইনহেরিট করতে এবং এই ফাংশনটিকে ওভাররাইড করতে পারে।

```solidity
        override(ERC20)
```

আমাদেরকে স্পষ্টভাবে নির্দিষ্ট করতে হবে যে আমরা `_beforeTokenTransfer`-এর ERC20 টোকেন সংজ্ঞাটি [ওভাররাইড](https://docs.soliditylang.org/en/v0.8.15/contracts.html#function-overriding) করছি। সাধারণভাবে, নিরাপত্তার দৃষ্টিকোণ থেকে, স্পষ্ট সংজ্ঞাগুলি অন্তর্নিহিতগুলির চেয়ে অনেক ভালো - আপনি যদি কিছু করে থাকেন তবে তা আপনার সামনে থাকলে আপনি তা ভুলতে পারবেন না। এই কারণেই আমাদের নির্দিষ্ট করতে হবে যে আমরা কোন সুপারক্লাসের `_beforeTokenTransfer` ওভাররাইড করছি।

```solidity
        super._beforeTokenTransfer(from, to, amount);
```

এই লাইনটি সেই কন্ট্র্যাক্ট বা কন্ট্র্যাক্টগুলির `_beforeTokenTransfer` ফাংশনটিকে কল করে যা থেকে আমরা ইনহেরিট করেছি এবং যার মধ্যে এটি রয়েছে। এই ক্ষেত্রে, এটি শুধুমাত্র `ERC20`, `Ownable`-এর এই হুকটি নেই। যদিও বর্তমানে `ERC20._beforeTokenTransfer` কিছুই করে না, আমরা এটিকে কল করি যদি ভবিষ্যতে ফাংশনালিটি যোগ করা হয় (এবং আমরা তখন কন্ট্র্যাক্টটি পুনরায় ডিপ্লয় করার সিদ্ধান্ত নিই, কারণ ডিপ্লয়মেন্টের পরে কন্ট্র্যাক্ট পরিবর্তন হয় না)।

### রিকোয়ারমেন্টগুলি কোডিং করা {#coding-the-requirements}

আমরা ফাংশনে এই রিকোয়ারমেন্টগুলি যোগ করতে চাই:

- `to` ঠিকানাটি `address(this)`-এর সমান হতে পারে না, যা হলো ERC-20 কন্ট্র্যাক্টের নিজের ঠিকানা।
- `to` ঠিকানাটি খালি হতে পারে না, এটি অবশ্যই হবে:
  - একটি এক্সটার্নালি ওনড অ্যাকাউন্ট (EOA)। আমরা সরাসরি একটি ঠিকানা EOA কিনা তা পরীক্ষা করতে পারি না, তবে আমরা একটি ঠিকানার ETH ব্যালেন্স পরীক্ষা করতে পারি। EOA-গুলির প্রায় সবসময়ই একটি ব্যালেন্স থাকে, এমনকি যদি সেগুলি আর ব্যবহার না করা হয় - শেষ wei পর্যন্ত সেগুলি পরিষ্কার করা কঠিন।
  - একটি স্মার্ট কন্ট্র্যাক্ট। একটি ঠিকানা স্মার্ট কন্ট্র্যাক্ট কিনা তা পরীক্ষা করা একটু কঠিন। একটি অপকোড আছে যা এক্সটার্নাল কোডের দৈর্ঘ্য পরীক্ষা করে, যাকে [`EXTCODESIZE`](https://www.evm.codes/#3b) বলা হয়, কিন্তু এটি সরাসরি Solidity-তে উপলব্ধ নয়। এর জন্য আমাদের [Yul](https://docs.soliditylang.org/en/v0.8.15/yul.html) ব্যবহার করতে হবে, যা হলো EVM অ্যাসেম্বলি। Solidity থেকে আমরা ব্যবহার করতে পারতাম এমন অন্যান্য মানও আছে ([`<address>.code` এবং `<address>.codehash`](https://docs.soliditylang.org/en/v0.8.15/units-and-global-variables.html#members-of-address-types)), কিন্তু সেগুলোর খরচ বেশি।

আসুন নতুন কোডটি লাইন বাই লাইন দেখি:

```solidity
        require(to != address(this), "কন্ট্র্যাক্ট ঠিকানায় টোকেন পাঠানো যাবে না");
```

এটি হলো প্রথম রিকোয়ারমেন্ট, `to` এবং `this(address)` একই জিনিস নয় তা পরীক্ষা করুন।

```solidity
        bool isToContract;
        assembly {
           isToContract := gt(extcodesize(to), 0)
        }
```

এভাবে আমরা একটি ঠিকানা কন্ট্র্যাক্ট কিনা তা পরীক্ষা করি। আমরা সরাসরি Yul থেকে আউটপুট পেতে পারি না, তাই পরিবর্তে আমরা ফলাফল ধরে রাখার জন্য একটি ভেরিয়েবল সংজ্ঞায়িত করি (`isToContract` এই ক্ষেত্রে)। Yul যেভাবে কাজ করে তা হলো, প্রতিটি অপকোডকে একটি ফাংশন হিসাবে বিবেচনা করা হয়। তাই প্রথমে আমরা কন্ট্র্যাক্টের আকার পেতে [`EXTCODESIZE`](https://www.evm.codes/#3b) কল করি, এবং তারপর এটি শূন্য নয় তা পরীক্ষা করতে [`GT`](https://www.evm.codes/#11) ব্যবহার করি (আমরা আনসাইন্ড পূর্ণসংখ্যার সাথে কাজ করছি, তাই অবশ্যই এটি ঋণাত্মক হতে পারে না)। এরপর আমরা ফলাফলটি `isToContract`-এ লিখি।

```solidity
        require(to.balance != 0 || isToContract, "একটি খালি ঠিকানায় টোকেন পাঠানো যাবে না");
```

এবং অবশেষে, আমাদের কাছে খালি ঠিকানাগুলির জন্য আসল চেকটি রয়েছে।

## প্রশাসনিক অ্যাক্সেস {#admin-access}

কখনও কখনও একজন প্রশাসক থাকা দরকারি যিনি ভুল সংশোধন করতে পারেন। অপব্যবহারের সম্ভাবনা কমাতে, এই প্রশাসক একটি [মাল্টিসিগ](https://blog.logrocket.com/security-choices-multi-signature-wallets/) হতে পারে যাতে একাধিক ব্যক্তিকে একটি কাজের জন্য একমত হতে হয়। এই নিবন্ধে আমাদের দুটি প্রশাসনিক বৈশিষ্ট্য থাকবে:

1. অ্যাকাউন্ট ফ্রিজ এবং আনফ্রিজ করা। উদাহরণস্বরূপ, যখন একটি অ্যাকাউন্টের নিরাপত্তা বিঘ্নিত হতে পারে তখন এটি কার্যকর হতে পারে।
2. অ্যাসেট ক্লিনআপ।

   কখনও কখনও প্রতারকরা বৈধতা অর্জনের জন্য আসল টোকেনের কন্ট্র্যাক্টে জাল টোকেন পাঠায়। উদাহরণস্বরূপ, [এখানে দেখুন](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe?tab=holders)। বৈধ ERC-20 কন্ট্র্যাক্টটি হলো [0x4200....0042](https://optimism.blockscout.com/token/0x4200000000000000000000000000000000000042)। যে স্ক্যামটি এটি হওয়ার ভান করে তা হলো [0x234....bbe](https://optimism.blockscout.com/token/0x2348B1a1228DDCd2dB668c3d30207c3E1852fBbe)।

   এটাও সম্ভব যে লোকেরা ভুল করে আমাদের কন্ট্র্যাক্টে বৈধ ERC-20 টোকেন পাঠাতে পারে, যা সেগুলিকে বের করার একটি উপায় থাকার আরেকটি কারণ।

OpenZeppelin প্রশাসনিক অ্যাক্সেস সক্ষম করার জন্য দুটি প্রক্রিয়া প্রদান করে:

- [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/access-control#ownership-and-ownable) কন্ট্র্যাক্টগুলির একজন একক মালিক থাকে। যেসব ফাংশনে `onlyOwner` [মডিফায়ার](https://www.tutorialspoint.com/solidity/solidity_function_modifiers.htm) থাকে, সেগুলি শুধুমাত্র সেই মালিক দ্বারা কল করা যেতে পারে। মালিকরা অন্য কাউকে মালিকানা হস্তান্তর করতে বা এটি সম্পূর্ণরূপে ত্যাগ করতে পারে। অন্যান্য সমস্ত অ্যাকাউন্টের অধিকার সাধারণত অভিন্ন।
- [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/access-control#role-based-access-control) কন্ট্র্যাক্টগুলিতে [রোল বেসড অ্যাক্সেস কন্ট্রোল (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control) থাকে।

সরলতার জন্য, এই নিবন্ধে আমরা `Ownable` ব্যবহার করি।

### কন্ট্র্যাক্ট ফ্রিজ এবং আনফ্রিজ করা {#freezing-and-thawing-contracts}

কন্ট্র্যাক্ট ফ্রিজ এবং আনফ্রিজ করার জন্য কয়েকটি পরিবর্তন প্রয়োজন:

- কোন ঠিকানাগুলি ফ্রিজ করা হয়েছে তার হিসাব রাখার জন্য ঠিকানা থেকে [বুলিয়ানে](https://en.wikipedia.org/wiki/Boolean_data_type) একটি [ম্যাপিং](https://www.tutorialspoint.com/solidity/solidity_mappings.htm)। সমস্ত মান প্রাথমিকভাবে শূন্য থাকে, যা বুলিয়ান মানের জন্য মিথ্যা হিসাবে ব্যাখ্যা করা হয়। এটাই আমরা চাই কারণ ডিফল্টরূপে অ্যাকাউন্টগুলি ফ্রিজ করা হয় না।

  ```solidity
      mapping(address => bool) public frozenAccounts;
  ```

- যখন একটি অ্যাকাউন্ট ফ্রিজ বা আনফ্রিজ করা হয় তখন আগ্রহী যে কাউকে জানানোর জন্য [ইভেন্ট](https://www.tutorialspoint.com/solidity/solidity_events.htm)। টেকনিক্যালি বলতে গেলে, এই কাজগুলির জন্য ইভেন্টগুলির প্রয়োজন নেই, তবে এটি অফচেইন কোডকে এই ইভেন্টগুলি শুনতে এবং কী ঘটছে তা জানতে সাহায্য করে। যখন অন্য কারও জন্য প্রাসঙ্গিক কিছু ঘটে তখন একটি স্মার্ট কন্ট্র্যাক্টের জন্য সেগুলি নির্গত করাকে ভালো আচরণ বলে মনে করা হয়।

  ইভেন্টগুলি ইনডেক্স করা হয় তাই একটি অ্যাকাউন্ট কতবার ফ্রিজ বা আনফ্রিজ করা হয়েছে তা অনুসন্ধান করা সম্ভব হবে।

  ```solidity
    // যখন অ্যাকাউন্টগুলি ফ্রিজ বা আনফ্রিজ করা হয়
    event AccountFrozen(address indexed _addr);
    event AccountThawed(address indexed _addr);
  ```

- অ্যাকাউন্ট ফ্রিজ এবং আনফ্রিজ করার জন্য ফাংশন। এই দুটি ফাংশন প্রায় অভিন্ন, তাই আমরা শুধুমাত্র ফ্রিজ ফাংশনটি দেখব।

  ```solidity
      function freezeAccount(address addr)
        public
        onlyOwner
  ```

  [`public`](https://www.tutorialspoint.com/solidity/solidity_contracts.htm) হিসাবে চিহ্নিত ফাংশনগুলি অন্যান্য স্মার্ট কন্ট্র্যাক্ট থেকে বা সরাসরি একটি লেনদেনের মাধ্যমে কল করা যেতে পারে।

  ```solidity
    {
        require(!frozenAccounts[addr], "অ্যাকাউন্ট ইতিমধ্যে ফ্রিজ করা আছে");
        frozenAccounts[addr] = true;
        emit AccountFrozen(addr);
    }  // freezeAccount
  ```

  যদি অ্যাকাউন্টটি ইতিমধ্যে ফ্রিজ করা থাকে, তবে রিভার্ট করুন। অন্যথায়, এটি ফ্রিজ করুন এবং একটি ইভেন্ট `emit` করুন।

- একটি ফ্রিজ করা অ্যাকাউন্ট থেকে অর্থ সরানো প্রতিরোধ করতে `_beforeTokenTransfer` পরিবর্তন করুন। মনে রাখবেন যে ফ্রিজ করা অ্যাকাউন্টে এখনও অর্থ ট্রান্সফার করা যেতে পারে।

  ```solidity
       require(!frozenAccounts[from], "অ্যাকাউন্টটি ফ্রিজ করা আছে");
  ```

### অ্যাসেট ক্লিনআপ {#asset-cleanup}

এই কন্ট্র্যাক্ট দ্বারা ধারণ করা ERC-20 টোকেন রিলিজ করার জন্য আমাদের সেই টোকেন কন্ট্র্যাক্টে একটি ফাংশন কল করতে হবে, হয় [`transfer`](https://eips.ethereum.org/EIPS/eip-20#transfer) অথবা [`approve`](https://eips.ethereum.org/EIPS/eip-20#approve)। এই ক্ষেত্রে অ্যালাওয়েন্সের ওপর গ্যাস নষ্ট করার কোনো মানে নেই, আমরা সরাসরি ট্রান্সফার করতে পারি।

```solidity
    function cleanupERC20(
        address erc20,
        address dest
    )
        public
        onlyOwner
    {
        IERC20 token = IERC20(erc20);
```

যখন আমরা ঠিকানাটি পাই তখন একটি কন্ট্র্যাক্টের জন্য একটি অবজেক্ট তৈরি করার সিনট্যাক্স এটি। আমরা এটি করতে পারি কারণ আমাদের সোর্স কোডের অংশ হিসাবে ERC20 টোকেনের জন্য সংজ্ঞা রয়েছে (লাইন 4 দেখুন), এবং সেই ফাইলে [IERC20-এর জন্য সংজ্ঞা](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) অন্তর্ভুক্ত রয়েছে, যা একটি OpenZeppelin ERC-20 কন্ট্র্যাক্টের ইন্টারফেস।

```solidity
        uint balance = token.balanceOf(address(this));
        token.transfer(dest, balance);
    }
```

এটি একটি ক্লিনআপ ফাংশন, তাই সম্ভবত আমরা কোনো টোকেন রেখে যেতে চাই না। ব্যবহারকারীর কাছ থেকে ম্যানুয়ালি ব্যালেন্স পাওয়ার পরিবর্তে, আমরা প্রক্রিয়াটি স্বয়ংক্রিয় করতে পারি।

## উপসংহার {#conclusion}

এটি একটি নিখুঁত সমাধান নয় - "ব্যবহারকারী ভুল করেছে" সমস্যার কোনো নিখুঁত সমাধান নেই। তবে, এই ধরনের চেক ব্যবহার করে অন্তত কিছু ভুল প্রতিরোধ করা যেতে পারে। অ্যাকাউন্ট ফ্রিজ করার ক্ষমতা, যদিও বিপজ্জনক, হ্যাকারকে চুরি করা তহবিল থেকে বঞ্চিত করে নির্দিষ্ট হ্যাকের ক্ষতি সীমিত করতে ব্যবহার করা যেতে পারে।

[আমার আরও কাজের জন্য এখানে দেখুন](https://cryptodocguy.pro/)।
