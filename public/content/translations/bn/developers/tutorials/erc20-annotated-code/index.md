---
title: "ERC-20 কন্ট্র্যাক্ট ওয়াক-থ্রু"
description: OpenZeppelin ERC-20 কন্ট্র্যাক্টের ভিতরে কী আছে এবং কেন এটি সেখানে আছে?
author: Ori Pomerantz
lang: bn
tags: [ "সলিডিটি", "erc-20" ]
skill: beginner
published: 2021-03-09
---

## ভূমিকা {#introduction}

Ethereum-এর অন্যতম সাধারণ ব্যবহার হল একটি গোষ্ঠীর জন্য একটি ট্রেডযোগ্য টোকেন তৈরি করা, এক অর্থে তাদের নিজস্ব মুদ্রা। এই টোকেনগুলি সাধারণত একটি স্ট্যান্ডার্ড অনুসরণ করে,
[ERC-20](/developers/docs/standards/tokens/erc-20/)। এই স্ট্যান্ডার্ডটি লিকুইডিটি পুল এবং ওয়ালেটের মতো টুলস লেখা সম্ভব করে, যা সমস্ত ERC-20 টোকেনের সাথে কাজ করে। এই নিবন্ধে আমরা
[OpenZeppelin সলিডিটি ERC20 ইমপ্লিমেন্টেশন](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol), এবং
[ইন্টারফেস সংজ্ঞা](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol) বিশ্লেষণ করব।

এটি একটি টীকাযুক্ত সোর্স কোড। আপনি যদি ERC-20 ইমপ্লিমেন্ট করতে চান,
[এই টিউটোরিয়ালটি পড়ুন](https://docs.openzeppelin.com/contracts/2.x/erc20-supply)।

## ইন্টারফেস {#the-interface}

ERC-20-এর মতো একটি স্ট্যান্ডার্ডের উদ্দেশ্য হল অনেক টোকেন ইমপ্লিমেন্টেশনকে অনুমতি দেওয়া যা ওয়ালেট এবং ডিসেন্ট্রালাইজড এক্সচেঞ্জের মতো অ্যাপ্লিকেশন জুড়ে ইন্টারঅপারেবল। এটি অর্জন করার জন্য, আমরা একটি
[ইন্টারফেস](https://www.geeksforgeeks.org/solidity/solidity-basics-of-interface/) তৈরি করি। যেকোনো কোড যা টোকেন কন্ট্র্যাক্ট ব্যবহার করতে চায়, তা ইন্টারফেসের একই সংজ্ঞা ব্যবহার করতে পারে এবং এটি ব্যবহার করে এমন সমস্ত টোকেন কন্ট্র্যাক্টের সাথে সামঞ্জস্যপূর্ণ হতে পারে, তা MetaMask-এর মতো একটি ওয়ালেট হোক, etherscan.io-এর মতো একটি ডিএ্যাপ হোক বা লিকুইডিটি পুলের মতো ভিন্ন কোনো কন্ট্র্যাক্ট হোক।

![ERC-20 ইন্টারফেসের চিত্রণ](erc20_interface.png)

আপনি যদি একজন অভিজ্ঞ প্রোগ্রামার হন, আপনার সম্ভবত [Java](https://www.w3schools.com/java/java_interface.asp) বা এমনকি [C হেডার ফাইলগুলিতে](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html)-ও একই ধরনের গঠন দেখতে পাওয়ার কথা মনে আছে।

এটি OpenZeppelin থেকে প্রাপ্ত [ERC-20 ইন্টারফেস](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol)-এর একটি সংজ্ঞা। এটি [মানুষের পাঠযোগ্য স্ট্যান্ডার্ড](https://eips.ethereum.org/EIPS/eip-20)-কে সলিডিটি কোডে অনুবাদ। অবশ্যই,
ইন্টারফেসটি নিজে থেকে কিছু _কীভাবে_ করতে হয় তা নির্ধারণ করে না। সেটি নিচের কন্ট্র্যাক্ট সোর্স কোডে ব্যাখ্যা করা হয়েছে।

&nbsp;

```solidity
// SPDX-License-Identifier: MIT
```

সলিডিটি ফাইলগুলিতে একটি লাইসেন্স আইডেন্টিফায়ার অন্তর্ভুক্ত থাকার কথা। [আপনি এখানে লাইসেন্সের তালিকা দেখতে পারেন](https://spdx.org/licenses/)। আপনার যদি একটি ভিন্ন
লাইসেন্সের প্রয়োজন হয়, তবে কেবল কমেন্টে তা ব্যাখ্যা করুন।

&nbsp;

```solidity
pragma solidity >=0.6.0 <0.8.0;
```

সলিডিটি ভাষা এখনও দ্রুত বিকশিত হচ্ছে এবং নতুন সংস্করণগুলি পুরানো কোডের সাথে সামঞ্জস্যপূর্ণ নাও হতে পারে
([এখানে দেখুন](https://docs.soliditylang.org/en/v0.7.0/070-breaking-changes.html))। অতএব, শুধুমাত্র ভাষার একটি ন্যূনতম সংস্করণই নয়, বরং একটি সর্বোচ্চ সংস্করণও উল্লেখ করা একটি ভাল ধারণা, যেটির সাথে আপনি কোডটি পরীক্ষা করেছেন।

&nbsp;

```solidity
/**
 * @dev EIP-তে সংজ্ঞায়িত ERC20 স্ট্যান্ডার্ডের ইন্টারফেস।
 */
```

কমেন্টের মধ্যে `@dev` হল [NatSpec ফরম্যাটের](https://docs.soliditylang.org/en/develop/natspec-format.html) অংশ, যা সোর্স কোড থেকে
ডকুমেন্টেশন তৈরি করতে ব্যবহৃত হয়।

&nbsp;

```solidity
interface IERC20 {
```

প্রচলিত নিয়ম অনুযায়ী, ইন্টারফেসের নাম `I` দিয়ে শুরু হয়।

&nbsp;

```solidity
    /**
     * @dev অস্তিত্বে থাকা টোকেনের পরিমাণ ফেরত দেয়।
     */
    function totalSupply() external view returns (uint256);
```

এই ফাংশনটি `external`, যার অর্থ [এটি শুধুমাত্র কন্ট্র্যাক্টের বাইরে থেকে কল করা যেতে পারে](https://docs.soliditylang.org/en/v0.7.0/cheatsheet.html#index-2)।
এটি কন্ট্র্যাক্টে টোকেনের মোট সরবরাহ ফেরত দেয়। এই মানটি ইথেরিয়ামের সবচেয়ে সাধারণ টাইপ, আনসাইন্ড 256 বিট ব্যবহার করে ফেরত দেওয়া হয় (256 বিট হল EVM-এর
নেটিভ ওয়ার্ড সাইজ)। এই ফাংশনটি একটি `view`ও, যার অর্থ এটি স্টেট পরিবর্তন করে না, তাই এটি ব্লকচেইনের প্রতিটি নোডে চালানোর পরিবর্তে একটি একক নোডে এক্সিকিউট করা যেতে পারে। এই ধরনের ফাংশন কোনো লেনদেন তৈরি করে না এবং কোনো [গ্যাস](/developers/docs/gas/) খরচ করে না।

**দ্রষ্টব্য:** তত্ত্বগতভাবে এমনটা মনে হতে পারে যে কোনও কন্ট্র্যাক্টের নির্মাতা প্রকৃত মানের চেয়ে কম মোট সরবরাহ ফেরত দিয়ে প্রতারণা করতে পারে, যার ফলে প্রতিটি টোকেন তার প্রকৃত মূল্যের চেয়ে বেশি মূল্যবান বলে মনে হবে। যাইহোক, এই ভয় ব্লকচেইনের আসল প্রকৃতিকে উপেক্ষা করে। ব্লকচেইনে যা কিছু ঘটে তা প্রতিটি নোড দ্বারা যাচাই করা যেতে পারে। এটি অর্জন করার জন্য, প্রতিটি কন্ট্র্যাক্টের মেশিন ল্যাঙ্গুয়েজ কোড এবং স্টোরেজ প্রতিটি নোডে উপলব্ধ। যদিও আপনার কন্ট্র্যাক্টের জন্য সলিডিটি
কোড প্রকাশ করা আপনার জন্য আবশ্যক নয়, আপনি যদি সোর্স কোড এবং যে সলিডিটি সংস্করণ দিয়ে এটি কম্পাইল করা হয়েছিল তা প্রকাশ না করেন তবে কেউ আপনাকে গুরুত্ব সহকারে নেবে না, যাতে এটি আপনার দেওয়া মেশিন ল্যাঙ্গুয়েজ কোডের সাথে যাচাই করা যায়।
উদাহরণস্বরূপ, [এই কন্ট্র্যাক্টটি দেখুন](https://eth.blockscout.com/address/0xa530F85085C6FE2f866E7FdB716849714a89f4CD?tab=contract)।

&nbsp;

```solidity
    /**
     * @dev `account`-এর মালিকানাধীন টোকেনের পরিমাণ ফেরত দেয়।
     */
    function balanceOf(address account) external view returns (uint256);
```

নাম শুনেই বোঝা যাচ্ছে, `balanceOf` একটি অ্যাকাউন্টের ব্যালেন্স ফেরত দেয়। ইথেরিয়াম অ্যাকাউন্টগুলি সলিডিটিতে `address` টাইপ ব্যবহার করে চিহ্নিত করা হয়, যা 160 বিট ধারণ করে।
এটি `external` এবং `view`ও বটে।

&nbsp;

```solidity
    /**
     * @dev কলারের অ্যাকাউন্ট থেকে `recipient`-কে `amount` পরিমাণ টোকেন পাঠায়।
     *
     * অপারেশনটি সফল হয়েছে কিনা তা নির্দেশ করে একটি বুলিয়ান মান ফেরত দেয়।
     *
     * একটি {Transfer} ইভেন্ট নির্গত করে।
     */
    function transfer(address recipient, uint256 amount) external returns (bool);
```

`transfer` ফাংশন কলার থেকে একটি ভিন্ন অ্যাড্রেসে টোকেন স্থানান্তর করে। এতে স্টেটের পরিবর্তন জড়িত, তাই এটি একটি `view` নয়।
যখন একজন ব্যবহারকারী এই ফাংশনটি কল করেন, তখন এটি একটি লেনদেন তৈরি করে এবং গ্যাস খরচ হয়। এটি একটি ইভেন্ট, `Transfer`ও নির্গত করে, যাতে ব্লকচেইনের সবাইকে এই ইভেন্ট সম্পর্কে জানানো যায়।

ফাংশনটির দুটি ভিন্ন ধরনের কলারদের জন্য দুই ধরনের আউটপুট রয়েছে:

- যে ব্যবহারকারীরা সরাসরি একটি ইউজার ইন্টারফেস থেকে ফাংশনটি কল করে। সাধারণত ব্যবহারকারী একটি লেনদেন জমা দেয়
  এবং প্রতিক্রিয়ার জন্য অপেক্ষা করে না, যা একটি অনির্দিষ্ট পরিমাণ সময় নিতে পারে। ব্যবহারকারী লেনদেনের রসিদ (যা লেনদেনের হ্যাস দ্বারা চিহ্নিত করা হয়) বা
  `Transfer` ইভেন্টটি খুঁজে দেখতে পারে যে কী ঘটেছে।
- অন্যান্য কন্ট্র্যাক্ট, যা একটি সামগ্রিক লেনদেনের অংশ হিসাবে ফাংশনটি কল করে। সেই কন্ট্র্যাক্টগুলো অবিলম্বে ফলাফল পায়,
  কারণ তারা একই লেনদেনে চলে, তাই তারা ফাংশনের রিটার্ন মান ব্যবহার করতে পারে।

একই ধরনের আউটপুট অন্যান্য ফাংশন দ্বারা তৈরি করা হয় যা কন্ট্র্যাক্টের স্টেট পরিবর্তন করে।

&nbsp;

অ্যালাওয়েন্স একটি অ্যাকাউন্টকে ভিন্ন মালিকের কিছু টোকেন খরচ করার অনুমতি দেয়।
এটি দরকারী, উদাহরণস্বরূপ, বিক্রেতা হিসাবে কাজ করে এমন কন্ট্র্যাক্টের জন্য। কন্ট্র্যাক্টগুলো ইভেন্টের জন্য
পর্যবেক্ষণ করতে পারে না, তাই যদি কোনো ক্রেতা সরাসরি বিক্রেতা কন্ট্র্যাক্টে টোকেন স্থানান্তর করে তবে সেই কন্ট্র্যাক্ট জানবে না যে তাকে অর্থ প্রদান করা হয়েছে। পরিবর্তে, ক্রেতা বিক্রেতার
কন্ট্র্যাক্টকে একটি নির্দিষ্ট পরিমাণ খরচ করার অনুমতি দেয় এবং বিক্রেতা সেই পরিমাণ স্থানান্তর করে।
এটি বিক্রেতা কন্ট্র্যাক্টের কল করা একটি ফাংশনের মাধ্যমে করা হয়, যাতে বিক্রেতা কন্ট্র্যাক্ট জানতে পারে যে এটি সফল হয়েছে কিনা।

```solidity
    /**
     * @dev {transferFrom}-এর মাধ্যমে `spender` `owner`-এর পক্ষ থেকে যে পরিমাণ টোকেন খরচ করার অনুমতি পাবে তা ফেরত দেয়। এটি ডিফল্টরূপে শূন্য থাকে।
     *
     * এই মানটি {approve} বা {transferFrom} কল করা হলে পরিবর্তিত হয়।
     */
    function allowance(address owner, address spender) external view returns (uint256);
```

`allowance` ফাংশনটি যে কাউকে একটি
অ্যাড্রেস (`owner`) অন্য অ্যাড্রেসকে (`spender`) কতটা খরচ করতে দেয় তা দেখার জন্য কোয়েরি করার অনুমতি দেয়।

&nbsp;

```solidity
    /**
     * @dev কলারের টোকেনের উপর `spender`-এর জন্য `amount`-কে অ্যালাওয়েন্স হিসাবে সেট করে।
     *
     * অপারেশনটি সফল হয়েছে কিনা তা নির্দেশ করে একটি বুলিয়ান মান ফেরত দেয়।
     *
     * গুরুত্বপূর্ণ: সতর্ক থাকুন যে এই পদ্ধতি ব্যবহার করে একটি অ্যালাওয়েন্স পরিবর্তন করার ফলে একটি ঝুঁকি থাকে যে কেউ দুর্ভাগ্যজনক 
     * লেনদেনের ক্রম অনুসারে পুরানো এবং নতুন উভয় অ্যালাওয়েন্স ব্যবহার করতে পারে। এই রেস কন্ডিশনটি 
     * কমানোর একটি সম্ভাব্য সমাধান হল প্রথমে স্পেন্ডারের অ্যালাওয়েন্স 0-তে নামিয়ে আনা এবং তারপরে
     * কাঙ্খিত মান সেট করা:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * একটি {Approval} ইভেন্ট নির্গত করে।
     */
    function approve(address spender, uint256 amount) external returns (bool);
```

`approve` ফাংশনটি একটি অ্যালাওয়েন্স তৈরি করে। কীভাবে এটির অপব্যবহার করা যেতে পারে সে সম্পর্কে বার্তাটি পড়তে ভুলবেন না। ইথেরিয়ামে আপনি আপনার নিজের লেনদেনের ক্রম নিয়ন্ত্রণ করেন,
কিন্তু আপনি অন্য লোকেদের লেনদেন কোন ক্রমে কার্যকর হবে তা নিয়ন্ত্রণ করতে পারবেন না,
যদি না আপনি অন্য পক্ষের লেনদেন সম্পন্ন হয়েছে না দেখা পর্যন্ত আপনার নিজের লেনদেন জমা না দেন।

&nbsp;

```solidity
    /**
     * @dev অ্যালাওয়েন্স মেকানিজম ব্যবহার করে `sender` থেকে `recipient`-এর কাছে `amount` পরিমাণ টোকেন পাঠায়।
     * এরপর কলারের অ্যালাওয়েন্স থেকে `amount` কেটে নেওয়া হয়।
     *
     * অপারেশনটি সফল হয়েছে কিনা তা নির্দেশ করে একটি বুলিয়ান মান ফেরত দেয়।
     *
     * একটি {Transfer} ইভেন্ট নির্গত করে।
     */
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
```

অবশেষে, `transferFrom` স্পেন্ডার দ্বারা অ্যালাওয়েন্সটি খরচ করার জন্য ব্যবহৃত হয়।

&nbsp;

```solidity

    /**
     * @dev যখন `value` টোকেন এক অ্যাকাউন্ট (`from`) থেকে
     * অন্য অ্যাকাউন্টে (`to`) সরানো হয়, তখন নির্গত হয়।
     *
     * মনে রাখবেন `value` শূন্য হতে পারে।
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev যখন {approve}-এ একটি কলের মাধ্যমে `owner`-এর জন্য একটি `spender`-এর অ্যালাওয়েন্স সেট করা হয় তখন নির্গত হয়। `value` হল নতুন অ্যালাওয়েন্স।
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```

ERC-20 কন্ট্র্যাক্টের স্টেট পরিবর্তন হলে এই ইভেন্টগুলি নির্গত হয়।

## আসল কন্ট্র্যাক্ট {#the-actual-contract}

এটি হল আসল কন্ট্র্যাক্ট যা ERC-20 স্ট্যান্ডার্ড ইমপ্লিমেন্ট করে,
[এখান থেকে নেওয়া হয়েছে](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)।
এটি যেমন আছে তেমন ব্যবহারের জন্য নয়, তবে আপনি এটিকে ব্যবহারযোগ্য কিছুতে প্রসারিত করতে এটির থেকে
[ইনহেরিট](https://www.tutorialspoint.com/solidity/solidity_inheritance.htm) করতে পারেন।

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;
```

&nbsp;

### ইম্পোর্ট স্টেটমেন্ট {#import-statements}

উপরের ইন্টারফেস সংজ্ঞা ছাড়াও, কন্ট্র্যাক্ট সংজ্ঞাটি অন্য দুটি ফাইল ইম্পোর্ট করে:

```solidity

import "../../GSN/Context.sol";
import "./IERC20.sol";
import "../../math/SafeMath.sol";
```

- `GSN/Context.sol` হল [OpenGSN](https://www.opengsn.org/) ব্যবহার করার জন্য প্রয়োজনীয় সংজ্ঞা, এটি এমন একটি সিস্টেম যা ইথার ছাড়া ব্যবহারকারীদের ব্লকচেইন ব্যবহার করার অনুমতি দেয়। মনে রাখবেন এটি একটি পুরানো সংস্করণ, আপনি যদি OpenGSN-এর সাথে ইন্টিগ্রেট করতে চান তবে [এই টিউটোরিয়ালটি ব্যবহার করুন](https://docs.opengsn.org/javascript-client/tutorial.html)।
- [SafeMath লাইব্রেরি](https://ethereumdev.io/using-safe-math-library-to-prevent-from-overflows/), যা সলিডিটি সংস্করণ **&lt;0.8.0**-এর জন্য অ্যারিথমেটিক ওভারফ্লো/আন্ডারফ্লো প্রতিরোধ করে। সলিডিটি ≥0.8.0-তে, অ্যারিথমেটিক অপারেশনগুলি ওভারফ্লো/আন্ডারফ্লোতে স্বয়ংক্রিয়ভাবে রিভার্ট হয়, যা SafeMath-কে অপ্রয়োজনীয় করে তোলে। এই কন্ট্র্যাক্টটি পুরানো কম্পাইলার সংস্করণগুলির সাথে ব্যাকওয়ার্ড সামঞ্জস্যের জন্য SafeMath ব্যবহার করে।

&nbsp;

এই মন্তব্যটি কন্ট্র্যাক্টের উদ্দেশ্য ব্যাখ্যা করে।

```solidity
/**
 * @dev {IERC20} ইন্টারফেসের ইমপ্লিমেন্টেশন।
 *
 * এই ইমপ্লিমেন্টেশনটি টোকেনগুলি কীভাবে তৈরি হয় সে সম্পর্কে অ্যাগনস্টিক। এর মানে হল
 * যে একটি সাপ্লাই মেকানিজম একটি ডিরাইভড কন্ট্র্যাক্টে {_mint} ব্যবহার করে যোগ করতে হবে।
 * একটি জেনেরিক মেকানিজমের জন্য {ERC20PresetMinterPauser} দেখুন।
 *
 * টিপ: একটি বিস্তারিত লেখার জন্য আমাদের গাইড দেখুন
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[কীভাবে
 * সাপ্লাই মেকানিজম ইমপ্লিমেন্ট করবেন]।
 *
 * আমরা সাধারণ OpenZeppelin নির্দেশিকা অনুসরণ করেছি: ফাংশনগুলি ব্যর্থ হলে `false` ফেরত দেওয়ার পরিবর্তে রিভার্ট করে।
 * এই আচরণটি প্রচলিত এবং ERC20 অ্যাপ্লিকেশনগুলির প্রত্যাশার সাথে বিরোধ করে না।
 *
 * এছাড়াও, {transferFrom}-এ কল করার সময় একটি {Approval} ইভেন্ট নির্গত হয়।
 * এটি অ্যাপ্লিকেশনগুলিকে শুধুমাত্র উক্ত ইভেন্টগুলি শুনে সমস্ত অ্যাকাউন্টের জন্য অ্যালাওয়েন্স পুনর্গঠন করার অনুমতি দেয়।
 * EIP-এর অন্যান্য ইমপ্লিমেন্টেশন এই ইভেন্টগুলি নির্গত নাও করতে পারে, কারণ এটি স্পেসিফিকেশন দ্বারা প্রয়োজন হয় না।
 *
 * অবশেষে, অ্যালাওয়েন্স সেট করার আশেপাশে সুপরিচিত সমস্যাগুলি প্রশমিত করার জন্য নন-স্ট্যান্ডার্ড {decreaseAllowance} এবং {increaseAllowance} ফাংশনগুলি যোগ করা হয়েছে।
 * {IERC20-approve} দেখুন।
 */

```

### কন্ট্র্যাক্ট সংজ্ঞা {#contract-definition}

```solidity
contract ERC20 is Context, IERC20 {
```

এই লাইনটি ইনহেরিট্যান্স নির্দিষ্ট করে, এই ক্ষেত্রে উপরের `IERC20` থেকে এবং OpenGSN-এর জন্য `Context` থেকে।

&nbsp;

```solidity

    using SafeMath for uint256;

```

এই লাইনটি `uint256` টাইপের সাথে `SafeMath` লাইব্রেরি সংযুক্ত করে। আপনি এই লাইব্রেরিটি
[এখানে](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol) খুঁজে পেতে পারেন।

### ভেরিয়েবল সংজ্ঞা {#variable-definitions}

এই সংজ্ঞাগুলি কন্ট্র্যাক্টের স্টেট ভেরিয়েবলগুলি নির্দিষ্ট করে। এই ভেরিয়েবলগুলিকে `private` হিসাবে ঘোষণা করা হয়েছে, তবে এর মানে হল যে ব্লকচেইনের অন্যান্য কন্ট্র্যাক্টগুলি সেগুলি পড়তে পারে না। _ব্লকচেইনে কোনো গোপনীয়তা নেই_, প্রতিটি নোডের সফটওয়্যার প্রতিটি ব্লকে প্রতিটি কন্ট্র্যাক্টের স্টেট ধারণ করে। প্রচলিত নিয়ম অনুযায়ী, স্টেট ভেরিয়েবলগুলির নামকরণ করা হয় `_<something>`।

প্রথম দুটি ভেরিয়েবল হল [ম্যাপিং](https://www.tutorialspoint.com/solidity/solidity_mappings.htm), যার অর্থ তারা প্রায় [অ্যাসোসিয়েটিভ অ্যারে](https://wikipedia.org/wiki/Associative_array)-এর মতো আচরণ করে, তবে এখানে কীগুলো নিউমেরিক ভ্যালু। স্টোরেজ শুধুমাত্র সেই এন্ট্রিগুলির জন্য বরাদ্দ করা হয় যেগুলির মান ডিফল্ট (শূন্য) থেকে ভিন্ন।

```solidity
    mapping (address => uint256) private _balances;
```

প্রথম ম্যাপিং, `_balances`, হল অ্যাড্রেস এবং এই টোকেনে তাদের নিজ নিজ ব্যালেন্স। ব্যালেন্স অ্যাক্সেস করতে, এই সিনট্যাক্সটি ব্যবহার করুন: `_balances[<address>]`।

&nbsp;

```solidity
    mapping (address => mapping (address => uint256)) private _allowances;
```

এই ভেরিয়েবল, `_allowances`, আগে ব্যাখ্যা করা অ্যালাওয়েন্সগুলো সংরক্ষণ করে। প্রথম ইন্ডেক্স হল টোকেনের মালিক, এবং দ্বিতীয়টি হল অ্যালাওয়েন্স সহ কন্ট্র্যাক্ট। অ্যাড্রেস B-এর অ্যাকাউন্ট থেকে অ্যাড্রেস A কত খরচ করতে পারে তা অ্যাক্সেস করতে, `_allowances[B][A]` ব্যবহার করুন।

&nbsp;

```solidity
    uint256 private _totalSupply;
```

নাম থেকেই বোঝা যাচ্ছে, এই ভেরিয়েবলটি টোকেনের মোট সরবরাহের হিসাব রাখে।

&nbsp;

```solidity
    string private _name;
    string private _symbol;
    uint8 private _decimals;
```

এই তিনটি ভেরিয়েবল পঠনযোগ্যতা উন্নত করতে ব্যবহৃত হয়। প্রথম দুটি স্ব-ব্যাখ্যামূলক, কিন্তু `_decimals` নয়।

একদিকে, ইথেরিয়ামের কোনো ফ্লোটিং পয়েন্ট বা ভগ্নাংশ ভেরিয়েবল নেই। অন্যদিকে, মানুষ টোকেন ভাগ করতে পছন্দ করে। লোকেরা মুদ্রার জন্য সোনা বেছে নেওয়ার একটি কারণ হল, যখন কেউ একটি গরুর মূল্যের সমপরিমাণ হাঁস কিনতে চায়, তখন পরিবর্তন করা কঠিন ছিল।

সমাধান হল পূর্ণসংখ্যার হিসাব রাখা, কিন্তু আসল টোকেনের পরিবর্তে এমন একটি ভগ্নাংশ টোকেন গণনা করা যা প্রায় মূল্যহীন। ইথারের ক্ষেত্রে, ভগ্নাংশ টোকেনটিকে wei বলা হয়, এবং 10^18 wei এক ETH-এর সমান। লেখার সময়, 10,000,000,000,000 wei প্রায় এক মার্কিন বা ইউরো সেন্টের সমান।

অ্যাপ্লিকেশনগুলিকে জানতে হবে কীভাবে টোকেন ব্যালেন্স প্রদর্শন করতে হয়। যদি একজন ব্যবহারকারীর কাছে 3,141,000,000,000,000,000 wei থাকে, তাহলে সেটা কি 3.14 ETH? 31.41 ETH? 3,141 ETH? ইথারের ক্ষেত্রে এটি 10^18 wei প্রতি ETH হিসাবে সংজ্ঞায়িত, কিন্তু আপনার টোকেনের জন্য আপনি একটি ভিন্ন মান নির্বাচন করতে পারেন। যদি টোকেন ভাগ করার কোনো মানে না হয়, আপনি শূন্যের একটি `_decimals` মান ব্যবহার করতে পারেন। আপনি যদি ETH-এর মতো একই স্ট্যান্ডার্ড ব্যবহার করতে চান, তাহলে **18** মানটি ব্যবহার করুন।

### কনস্ট্রাক্টর {#the-constructor}

```solidity
    /**
     * @dev {name} এবং {symbol}-এর জন্য মান সেট করে, {decimals}-কে 18-এর একটি ডিফল্ট মান দিয়ে ইনিশিয়ালাইজ করে।
     *
     * {decimals}-এর জন্য একটি ভিন্ন মান নির্বাচন করতে, {_setupDecimals} ব্যবহার করুন।
     *
     * এই তিনটি মানই অপরিবর্তনীয়: এগুলি শুধুমাত্র নির্মাণের সময় একবার সেট করা যেতে পারে।
     */
    constructor (string memory name_, string memory symbol_) public {
        // সলিডিটি ≥0.7.0-তে, 'public' অন্তর্নিহিত এবং বাদ দেওয়া যেতে পারে।

        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
```

কনস্ট্রাক্টরটি প্রথমবার কন্ট্র্যাক্ট তৈরি করার সময় কল করা হয়। প্রচলিত নিয়ম অনুযায়ী, ফাংশন প্যারামিটারগুলির নামকরণ করা হয় `<something>_`।

### ইউজার ইন্টারফেস ফাংশন {#user-interface-functions}

```solidity
    /**
     * @dev টোকেনের নাম ফেরত দেয়।
     */
    function name() public view returns (string memory) {
        return _name;
    }

    /**
     * @dev টোকেনের প্রতীক ফেরত দেয়, সাধারণত নামের একটি সংক্ষিপ্ত সংস্করণ।
     */
    function symbol() public view returns (string memory) {
        return _symbol;
    }

    /**
     * @dev ব্যবহারকারীর কাছে এর উপস্থাপনা পেতে ব্যবহৃত দশমিকের সংখ্যা ফেরত দেয়।
     * উদাহরণস্বরূপ, যদি `decimals` `2` এর সমান হয়, তাহলে `505` টোকেনের একটি ব্যালেন্স
     * একজন ব্যবহারকারীকে `5,05` (`505 / 10 ** 2`) হিসাবে প্রদর্শন করা উচিত।
     *
     * টোকেনগুলি সাধারণত 18-এর একটি মান বেছে নেয়, যা ইথার এবং wei-এর মধ্যেকার সম্পর্কের অনুকরণ করে।
     * এটিই সেই মান যা {ERC20} ব্যবহার করে, যদি না {_setupDecimals} কল করা হয়।
     *
     * দ্রষ্টব্য: এই তথ্যটি শুধুমাত্র _প্রদর্শনের_ উদ্দেশ্যে ব্যবহৃত হয়: এটি কোনোভাবেই
     * কন্ট্র্যাক্টের কোনো গাণিতিক ক্রিয়াকলাপকে প্রভাবিত করে না, যার মধ্যে
     * {IERC20-balanceOf} এবং {IERC20-transfer} অন্তর্ভুক্ত।
     */
    function decimals() public view returns (uint8) {
        return _decimals;
    }
```

এই ফাংশনগুলি, `name`, `symbol`, এবং `decimals` ইউজার ইন্টারফেসগুলিকে আপনার কন্ট্র্যাক্ট সম্পর্কে জানতে সাহায্য করে যাতে তারা এটি সঠিকভাবে প্রদর্শন করতে পারে।

রিটার্ন টাইপ হল `string memory`, যার অর্থ মেমরিতে সংরক্ষিত একটি স্ট্রিং ফেরত দেওয়া। ভেরিয়েবল, যেমন স্ট্রিং, তিনটি স্থানে সংরক্ষণ করা যেতে পারে:

|            | জীবনকাল                   | কন্ট্র্যাক্ট অ্যাক্সেস | গ্যাস খরচ                                                                                              |
| ---------- | ------------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------ |
| মেমরি      | ফাংশন কল                  | পড়া/লেখা              | দশ বা শত (উচ্চতর অবস্থানের জন্য উচ্চতর)                                             |
| Calldata   | ফাংশন কল                  | শুধুমাত্র পঠনযোগ্য     | রিটার্ন টাইপ হিসাবে ব্যবহার করা যাবে না, শুধুমাত্র একটি ফাংশন প্যারামিটার টাইপ হিসাবে ব্যবহার করা যাবে |
| সংগ্রহস্থল | পরিবর্তন না হওয়া পর্যন্ত | পড়া/লেখা              | উচ্চ (পড়ার জন্য 800, লেখার জন্য 20k)                                               |

এই ক্ষেত্রে, `memory` হল সেরা পছন্দ।

### টোকেন তথ্য পড়ুন {#read-token-information}

এগুলি হল এমন ফাংশন যা টোকেন সম্পর্কে তথ্য প্রদান করে, হয় মোট সরবরাহ বা একটি অ্যাকাউন্টের ব্যালেন্স।

```solidity
    /**
     * @dev {IERC20-totalSupply} দেখুন।
     */
    function totalSupply() public view override returns (uint256) {
        return _totalSupply;
    }
```

`totalSupply` ফাংশনটি টোকেনের মোট সরবরাহ ফেরত দেয়।

&nbsp;

```solidity
    /**
     * @dev {IERC20-balanceOf} দেখুন।
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }
```

একটি অ্যাকাউন্টের ব্যালেন্স পড়ুন। মনে রাখবেন যে যে কেউ অন্য কারো অ্যাকাউন্টের ব্যালেন্স পেতে পারে। এই তথ্যটি লুকানোর চেষ্টা করার কোনো মানে নেই, কারণ এটি যাইহোক প্রতিটি নোডে উপলব্ধ। _ব্লকচেইনে কোনো গোপনীয়তা নেই।_

### টোকেন স্থানান্তর করুন {#transfer-tokens}

```solidity
    /**
     * @dev {IERC20-transfer} দেখুন।
     *
     * প্রয়োজনীয়তা:
     *
     * - `recipient` শূন্য অ্যাড্রেস হতে পারবে না।
     * - কলারের কাছে কমপক্ষে `amount` পরিমাণ ব্যালেন্স থাকতে হবে।
     */
    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
```

`transfer` ফাংশনটি প্রেরকের অ্যাকাউন্ট থেকে একটি ভিন্ন অ্যাকাউন্টে টোকেন স্থানান্তর করার জন্য কল করা হয়। মনে রাখবেন যে যদিও এটি একটি বুলিয়ান মান ফেরত দেয়, সেই মানটি সবসময় **সত্য**। যদি স্থানান্তর ব্যর্থ হয় তবে কন্ট্র্যাক্ট কলটি রিভার্ট করে।

&nbsp;

```solidity
        _transfer(_msgSender(), recipient, amount);
        return true;
    }
```

`_transfer` ফাংশনটি আসল কাজটি করে। এটি একটি প্রাইভেট ফাংশন যা শুধুমাত্র অন্যান্য কন্ট্র্যাক্ট ফাংশন দ্বারা কল করা যেতে পারে। প্রচলিত নিয়ম অনুযায়ী প্রাইভেট ফাংশনগুলির নামকরণ করা হয় `_<something>`, স্টেট ভেরিয়েবলগুলির মতোই।

সাধারণত সলিডিটিতে আমরা মেসেজ প্রেরকের জন্য `msg.sender` ব্যবহার করি। যাইহোক, এটি [OpenGSN](http://opengsn.org/)-কে ব্রেক করে। যদি আমরা আমাদের টোকেন দিয়ে ইথারবিহীন লেনদেনের অনুমতি দিতে চাই, তাহলে আমাদের `_msgSender()` ব্যবহার করতে হবে। এটি সাধারণ লেনদেনের জন্য `msg.sender` ফেরত দেয়, কিন্তু ইথারবিহীন লেনদেনের জন্য আসল সাইনারকে ফেরত দেয় এবং মেসেজ রিলে করা কন্ট্র্যাক্টকে নয়।

### অ্যালাওয়েন্স ফাংশন {#allowance-functions}

এগুলি হল সেই ফাংশন যা অ্যালাওয়েন্স কার্যকারিতা ইমপ্লিমেন্ট করে: `allowance`, `approve`, `transferFrom`, এবং `_approve`। এছাড়াও, OpenZeppelin ইমপ্লিমেন্টেশন মৌলিক স্ট্যান্ডার্ডের বাইরে গিয়ে কিছু বৈশিষ্ট্য অন্তর্ভুক্ত করে যা নিরাপত্তা উন্নত করে: `increaseAllowance`, এবং `decreaseAllowance`।

#### অ্যালাওয়েন্স ফাংশন {#allowance}

```solidity
    /**
     * @dev {IERC20-allowance} দেখুন।
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
```

`allowance` ফাংশনটি প্রত্যেককে যেকোনো অ্যালাওয়েন্স পরীক্ষা করার অনুমতি দেয়।

#### অ্যাপ্রুভ ফাংশন {#approve}

```solidity
    /**
     * @dev {IERC20-approve} দেখুন।
     *
     * প্রয়োজনীয়তা:
     *
     * - `spender` শূন্য অ্যাড্রেস হতে পারবে না।
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
```

এই ফাংশনটি একটি অ্যালাওয়েন্স তৈরি করার জন্য কল করা হয়। এটি উপরের `transfer` ফাংশনের অনুরূপ:

- ফাংশনটি শুধু একটি অভ্যন্তরীণ ফাংশন কল করে (এই ক্ষেত্রে, `_approve`) যা আসল কাজটি করে।
- ফাংশনটি হয় `true` ফেরত দেয় (যদি সফল হয়) অথবা রিভার্ট করে (যদি না হয়)।

&nbsp;

```solidity
        _approve(_msgSender(), spender, amount);
        return true;
    }
```

আমরা অভ্যন্তরীণ ফাংশন ব্যবহার করি যাতে স্টেট পরিবর্তনের স্থানগুলির সংখ্যা কমানো যায়। _যেকোনো_ ফাংশন যা স্টেট পরিবর্তন করে তা একটি সম্ভাব্য নিরাপত্তা ঝুঁকি যা নিরাপত্তার জন্য অডিট করা প্রয়োজন। এইভাবে আমাদের ভুল করার সম্ভাবনা কম থাকে।

#### transferFrom ফাংশন {#transferFrom}

এটি হল সেই ফাংশন যা একজন স্পেন্ডার একটি অ্যালাওয়েন্স খরচ করার জন্য কল করে। এর জন্য দুটি অপারেশন প্রয়োজন: খরচ করা পরিমাণ স্থানান্তর করা এবং সেই পরিমাণ দ্বারা অ্যালাওয়েন্স কমানো।

```solidity
    /**
     * @dev {IERC20-transferFrom} দেখুন।
     *
     * আপডেট করা অ্যালাওয়েন্স নির্দেশ করে একটি {Approval} ইভেন্ট নির্গত করে। এটি
     * EIP দ্বারা প্রয়োজন হয় না। {ERC20}-এর শুরুতে নোটটি দেখুন।
     *
     * প্রয়োজনীয়তা:
     *
     * - `sender` এবং `recipient` শূন্য অ্যাড্রেস হতে পারবে না।
     * - `sender`-এর কাছে কমপক্ষে `amount` পরিমাণ ব্যালেন্স থাকতে হবে।
     * - কলারের কাছে ``sender``-এর টোকেনের জন্য কমপক্ষে `amount` পরিমাণ
     * অ্যালাওয়েন্স থাকতে হবে।
     */
    function transferFrom(address sender, address recipient, uint256 amount) public virtual
                                                override returns (bool) {
        _transfer(sender, recipient, amount);
```

&nbsp;

`a.sub(b, "message")` ফাংশন কল দুটি কাজ করে। প্রথমত, এটি `a-b` গণনা করে, যা নতুন অ্যালাওয়েন্স।
দ্বিতীয়ত, এটি পরীক্ষা করে যে এই ফলাফলটি নেতিবাচক নয়। যদি এটি নেতিবাচক হয় তবে কলটি প্রদত্ত বার্তা সহ রিভার্ট করে। মনে রাখবেন যে যখন একটি কল রিভার্ট করে তখন সেই কলের সময় আগে করা যেকোনো প্রক্রিয়াকরণ উপেক্ষা করা হয় তাই আমাদের `_transfer` আনডু করার প্রয়োজন নেই।

```solidity
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount,
             "ERC20: transfer amount exceeds allowance"));
        return true;
    }
```

#### OpenZeppelin নিরাপত্তা সংযোজন {#openzeppelin-safety-additions}

একটি নন-জিরো অ্যালাওয়েন্সকে অন্য একটি নন-জিরো মানে সেট করা বিপজ্জনক, কারণ আপনি শুধুমাত্র আপনার নিজের লেনদেনের ক্রম নিয়ন্ত্রণ করেন, অন্য কারো নয়। কল্পনা করুন আপনার দুজন ব্যবহারকারী আছে, এলিস যে সাদাসিধে এবং বিল যে অসৎ। এলিস বিলের কাছ থেকে কিছু পরিষেবা চায়, যা তার মতে পাঁচ টোকেন মূল্যের - তাই সে বিলকে পাঁচ টোকেনের অ্যালাওয়েন্স দেয়।

তারপর কিছু পরিবর্তন হয় এবং বিলের দাম দশ টোকেনে বেড়ে যায়। এলিস, যে এখনও পরিষেবাটি চায়, একটি লেনদেন পাঠায় যা বিলের অ্যালাওয়েন্স দশ-এ সেট করে। বিল লেনদেন পুলে এই নতুন লেনদেনটি দেখার সাথে সাথে একটি লেনদেন পাঠায় যা এলিসের পাঁচ টোকেন খরচ করে এবং যার গ্যাস মূল্য অনেক বেশি যাতে এটি দ্রুত মাইনিং করা হয়। এইভাবে বিল প্রথমে পাঁচ টোকেন খরচ করতে পারে এবং তারপর, এলিসের নতুন অ্যালাওয়েন্স মাইনিং হয়ে গেলে, আরও দশ টোকেন খরচ করতে পারে, মোট পনেরো টোকেনের জন্য, যা এলিস অনুমোদন করতে চেয়েছিল তার চেয়ে বেশি। এই কৌশলটিকে
[ফ্রন্ট-রানিং](https://consensysdiligence.github.io/smart-contract-best-practices/attacks/#front-running) বলা হয়।

| এলিস লেনদেন                          | এলিস নন্স | বিল লেনদেন                                       | বিল নন্স | বিলের অ্যালাওয়েন্স | এলিসের কাছ থেকে বিলের মোট আয় |
| ------------------------------------ | --------- | ------------------------------------------------ | -------- | ------------------ | ----------------------------- |
| approve(Bill, 5)  | 10        |                                                  |          | 5                  | 0                             |
|                                      |           | transferFrom(Alice, Bill, 5)  | 10,123   | 0                  | 5                             |
| approve(Bill, 10) | 11        |                                                  |          | 10                 | 5                             |
|                                      |           | transferFrom(Alice, Bill, 10) | 10,124   | 0                  | 15                            |

এই সমস্যাটি এড়াতে, এই দুটি ফাংশন (`increaseAllowance` এবং `decreaseAllowance`) আপনাকে একটি নির্দিষ্ট পরিমাণ দ্বারা অ্যালাওয়েন্স পরিবর্তন করার অনুমতি দেয়। সুতরাং যদি বিল ইতিমধ্যে পাঁচ টোকেন খরচ করে ফেলে, সে কেবল আরও পাঁচ টোকেন খরচ করতে পারবে। সময়ের উপর নির্ভর করে, এটি দুটি উপায়ে কাজ করতে পারে, যার উভয়টিতেই বিল শুধুমাত্র দশটি টোকেন পায়:

A:

| এলিস লেনদেন                                   | এলিস নন্স | বিল লেনদেন                                      | বিল নন্স | বিলের অ্যালাওয়েন্স | এলিসের কাছ থেকে বিলের মোট আয় |
| --------------------------------------------- | --------: | ----------------------------------------------- | -------: | -----------------: | ----------------------------- |
| approve(Bill, 5)           |        10 |                                                 |          |                  5 | 0                             |
|                                               |           | transferFrom(Alice, Bill, 5) |   10,123 |                  0 | 5                             |
| increaseAllowance(Bill, 5) |        11 |                                                 |          |            0+5 = 5 | 5                             |
|                                               |           | transferFrom(Alice, Bill, 5) |   10,124 |                  0 | 10                            |

B:

| এলিস লেনদেন                                   | এলিস নন্স | বিল লেনদেন                                       | বিল নন্স | বিলের অ্যালাওয়েন্স | এলিসের কাছ থেকে বিলের মোট আয় |
| --------------------------------------------- | --------: | ------------------------------------------------ | -------: | -----------------: | ----------------------------: |
| approve(Bill, 5)           |        10 |                                                  |          |                  5 |                             0 |
| increaseAllowance(Bill, 5) |        11 |                                                  |          |           5+5 = 10 |                             0 |
|                                               |           | transferFrom(Alice, Bill, 10) |   10,124 |                  0 |                            10 |

```solidity
    /**
     * @dev কলার দ্বারা স্পেন্ডারকে প্রদত্ত অ্যালাওয়েন্স অ্যাটমিকভাবে বৃদ্ধি করে।
     *
     * এটি {approve}-এর একটি বিকল্প যা {IERC20-approve}-এ বর্ণিত সমস্যাগুলির জন্য একটি প্রশমন হিসাবে ব্যবহার করা যেতে পারে।
     *
     * আপডেট করা অ্যালাওয়েন্স নির্দেশ করে একটি {Approval} ইভেন্ট নির্গত করে।
     *
     * প্রয়োজনীয়তা:
     *
     * - `spender` শূন্য অ্যাড্রেস হতে পারবে না।
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }
```

`a.add(b)` ফাংশনটি একটি নিরাপদ যোগ। অসম্ভাব্য ক্ষেত্রে যে `a`+`b`>=`2^256` হয়, এটি সাধারণ যোগের মতো মোড়ানো হয় না।

```solidity

    /**
     * @dev কলার দ্বারা স্পেন্ডারকে প্রদত্ত অ্যালাওয়েন্স অ্যাটমিকভাবে হ্রাস করে।
     *
     * এটি {approve}-এর একটি বিকল্প যা {IERC20-approve}-এ বর্ণিত সমস্যাগুলির জন্য একটি প্রশমন হিসাবে ব্যবহার করা যেতে পারে।
     *
     * আপডেট করা অ্যালাওয়েন্স নির্দেশ করে একটি {Approval} ইভেন্ট নির্গত করে।
     *
     * প্রয়োজনীয়তা:
     *
     * - `spender` শূন্য অ্যাড্রেস হতে পারবে না।
     * - `spender`-এর কাছে কলারের জন্য কমপক্ষে
     * `subtractedValue` পরিমাণ অ্যালাওয়েন্স থাকতে হবে।
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue,
                "ERC20: decreased allowance below zero"));
        return true;
    }
```

### টোকেন তথ্য পরিবর্তনকারী ফাংশন {#functions-that-modify-token-information}

এগুলি হল সেই চারটি ফাংশন যা আসল কাজটি করে: `_transfer`, `_mint`, `_burn`, এবং `_approve`।

#### _transfer ফাংশন {#_transfer}

```solidity
    /**
     * @dev `sender` থেকে `recipient`-এর কাছে `amount` পরিমাণ টোকেন পাঠায়।
     *
     * এই ইন্টারনাল ফাংশনটি {transfer}-এর সমতুল্য, এবং এটি ব্যবহার করা যেতে পারে, উদাহরণস্বরূপ, 
     * স্বয়ংক্রিয় টোকেন ফি, স্ল্যাশিং মেকানিজম ইত্যাদি ইমপ্লিমেন্ট করার জন্য।
     *
     * একটি {Transfer} ইভেন্ট নির্গত করে।
     *
     * প্রয়োজনীয়তা:
     *
     * - `sender` শূন্য অ্যাড্রেস হতে পারবে না।
     * - `recipient` শূন্য অ্যাড্রেস হতে পারবে না।
     * - `sender`-এর কাছে কমপক্ষে `amount` পরিমাণ ব্যালেন্স থাকতে হবে।
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
```

এই ফাংশন, `_transfer`, এক অ্যাকাউন্ট থেকে অন্য অ্যাকাউন্টে টোকেন স্থানান্তর করে। এটি `transfer` (প্রেরকের নিজের অ্যাকাউন্ট থেকে স্থানান্তরের জন্য) এবং `transferFrom` (অন্য কারো অ্যাকাউন্ট থেকে স্থানান্তর করতে অ্যালাওয়েন্স ব্যবহার করার জন্য) উভয় দ্বারাই কল করা হয়।

&nbsp;

```solidity
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
```

ইথেরিয়ামে আসলে কেউ শূন্য অ্যাড্রেসের মালিক নয় (অর্থাৎ, কেউ এমন একটি ব্যক্তিগত কী জানে না যার ম্যাচিং পাবলিক কী শূন্য অ্যাড্রেসে রূপান্তরিত হয়)। লোকেরা যখন সেই অ্যাড্রেস ব্যবহার করে, তখন এটি সাধারণত একটি সফটওয়্যার বাগ - তাই প্রেরক বা প্রাপক হিসাবে শূন্য অ্যাড্রেস ব্যবহার করা হলে আমরা ব্যর্থ হই।

&nbsp;

```solidity
        _beforeTokenTransfer(sender, recipient, amount);

```

এই কন্ট্র্যাক্টটি ব্যবহার করার দুটি উপায় আছে:

1. আপনার নিজের কোডের জন্য এটি একটি টেমপ্লেট হিসাবে ব্যবহার করুন
2. [এটির থেকে ইনহেরিট করুন](https://www.bitdegree.org/learn/solidity-inheritance), এবং শুধুমাত্র সেই ফাংশনগুলি ওভাররাইড করুন যা আপনাকে পরিবর্তন করতে হবে

দ্বিতীয় পদ্ধতিটি অনেক ভালো কারণ OpenZeppelin ERC-20 কোডটি ইতিমধ্যে অডিট করা হয়েছে এবং নিরাপদ হিসাবে দেখানো হয়েছে। আপনি যখন ইনহেরিট্যান্স ব্যবহার করেন তখন এটি স্পষ্ট হয় যে আপনি কোন ফাংশনগুলি পরিবর্তন করছেন, এবং আপনার কন্ট্র্যাক্টকে বিশ্বাস করতে লোকেদের শুধুমাত্র সেই নির্দিষ্ট ফাংশনগুলি অডিট করতে হবে।

প্রতিবার টোকেন হাত বদলানোর সময় একটি ফাংশন সম্পাদন করা প্রায়শই দরকারী। যাইহোক, `_transfer` একটি অত্যন্ত গুরুত্বপূর্ণ ফাংশন এবং এটিকে অনিরাপদভাবে লেখা সম্ভব (নীচে দেখুন), তাই এটি ওভাররাইড না করাই ভাল। সমাধান হল `_beforeTokenTransfer`, একটি [হুক ফাংশন](https://wikipedia.org/wiki/Hooking)। আপনি এই ফাংশনটি ওভাররাইড করতে পারেন, এবং এটি প্রতিটি স্থানান্তরে কল করা হবে।

&nbsp;

```solidity
        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
```

এগুলি হল সেই লাইন যা আসলে স্থানান্তর করে। মনে রাখবেন যে তাদের মধ্যে **কিছুই** নেই, এবং আমরা প্রাপকের কাছে যোগ করার আগে প্রেরকের কাছ থেকে স্থানান্তরিত পরিমাণ বিয়োগ করি। এটি গুরুত্বপূর্ণ কারণ যদি মাঝখানে একটি ভিন্ন কন্ট্র্যাক্টে একটি কল থাকত, তবে এটি এই কন্ট্র্যাক্টকে প্রতারণা করতে ব্যবহার করা যেতে পারত। এইভাবে স্থানান্তরটি অ্যাটমিক, এর মাঝখানে কিছুই ঘটতে পারে না।

&nbsp;

```solidity
        emit Transfer(sender, recipient, amount);
    }
```

অবশেষে, একটি `Transfer` ইভেন্ট নির্গত করুন। ইভেন্টগুলি স্মার্ট কন্ট্র্যাক্টগুলিতে অ্যাক্সেসযোগ্য নয়, কিন্তু ব্লকচেইনের বাইরে চলমান কোড ইভেন্টগুলি শুনতে পারে এবং সেগুলিতে প্রতিক্রিয়া জানাতে পারে। উদাহরণস্বরূপ, একটি ওয়ালেট যখন মালিক আরও টোকেন পায় তখন তার হিসাব রাখতে পারে।

#### _mint এবং _burn ফাংশন {#_mint-and-_burn}

এই দুটি ফাংশন (`_mint` এবং `_burn`) টোকেনের মোট সরবরাহ পরিবর্তন করে।
এগুলি অভ্যন্তরীণ এবং এই কন্ট্র্যাক্টে তাদের কল করার জন্য কোনো ফাংশন নেই, তাই এগুলি শুধুমাত্র তখনই কার্যকর যখন আপনি কন্ট্র্যাক্ট থেকে ইনহেরিট করেন এবং নতুন টোকেন মিন্ট করার বা বিদ্যমান টোকেনগুলি বার্ন করার শর্তগুলি নির্ধারণের জন্য আপনার নিজস্ব লজিক যুক্ত করেন।

**দ্রষ্টব্য:** প্রতিটি ERC-20 টোকেনের নিজস্ব ব্যবসায়িক যুক্তি রয়েছে যা টোকেন ব্যবস্থাপনাকে নির্দেশ করে।
উদাহরণস্বরূপ, একটি নির্দিষ্ট সরবরাহ কন্ট্র্যাক্ট শুধুমাত্র কনস্ট্রাক্টরে `_mint` কল করতে পারে এবং `_burn` কল নাও করতে পারে। একটি কন্ট্র্যাক্ট যা টোকেন বিক্রি করে, তা `_mint` কল করবে যখন এটি অর্থ প্রদান করা হয়, এবং সম্ভবত `_burn` কল করবে কিছু সময়ে অনিয়ন্ত্রিত মুদ্রাস্ফীতি এড়াতে।

```solidity
    /** @dev `amount` পরিমাণ টোকেন তৈরি করে এবং সেগুলোকে `account`-কে অ্যাসাইন করে, যা মোট সরবরাহ বাড়ায়।
     *
     * `from`-কে শূন্য অ্যাড্রেসে সেট করে একটি {Transfer} ইভেন্ট নির্গত করে।
     *
     * প্রয়োজনীয়তা:
     *
     * - `to` শূন্য অ্যাড্রেস হতে পারবে না।
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");
        _beforeTokenTransfer(address(0), account, amount);
        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }
```

টোকেনের মোট সংখ্যা পরিবর্তন হলে `_totalSupply` আপডেট করতে ভুলবেন না।

&nbsp;

```solidity
    /**
     * @dev `account` থেকে `amount` পরিমাণ টোকেন নষ্ট করে, যা মোট সরবরাহ কমায়।
     *
     * `to`-কে শূন্য অ্যাড্রেসে সেট করে একটি {Transfer} ইভেন্ট নির্গত করে।
     *
     * প্রয়োজনীয়তা:
     *
     * - `account` শূন্য অ্যাড্রেস হতে পারবে না।
     * - `account`-এর কাছে কমপক্ষে `amount` পরিমাণ টোকেন থাকতে হবে।
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }
```

`_burn` ফাংশনটি প্রায় `_mint`-এর মতোই, তবে এটি বিপরীত দিকে যায়।

#### _approve ফাংশন {#_approve}

এটি হল সেই ফাংশন যা আসলে অ্যালাওয়েন্স নির্দিষ্ট করে। মনে রাখবেন যে এটি একজন মালিককে এমন একটি অ্যালাওয়েন্স নির্দিষ্ট করার অনুমতি দেয় যা মালিকের বর্তমান ব্যালেন্সের চেয়ে বেশি। এটি ঠিক আছে কারণ ব্যালেন্সটি স্থানান্তরের সময় পরীক্ষা করা হয়, যখন এটি অ্যালাওয়েন্স তৈরি করার সময়কার ব্যালেন্স থেকে ভিন্ন হতে পারে।

```solidity
    /**
     * @dev `spender`-এর `owner` টোকেনের উপর `amount`-কে অ্যালাওয়েন্স হিসাবে সেট করে।
     *
     * এই অভ্যন্তরীণ ফাংশনটি `approve`-এর সমতুল্য, এবং এটি ব্যবহার করা যেতে পারে,
     * যেমন, নির্দিষ্ট সাবসিস্টেমের জন্য স্বয়ংক্রিয় অ্যালাওয়েন্স সেট করতে ইত্যাদি।
     *
     * একটি {Approval} ইভেন্ট নির্গত করে।
     *
     * প্রয়োজনীয়তা:
     *
     * - `owner` শূন্য অ্যাড্রেস হতে পারবে না।
     * - `spender` শূন্য অ্যাড্রেস হতে পারবে না।
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
```

&nbsp;

একটি `Approval` ইভেন্ট নির্গত করুন। অ্যাপ্লিকেশনটি কীভাবে লেখা হয়েছে তার উপর নির্ভর করে, স্পেন্ডার কন্ট্র্যাক্টকে মালিক দ্বারা বা এই ইভেন্টগুলি শুনে এমন একটি সার্ভার দ্বারা অনুমোদনের বিষয়ে জানানো যেতে পারে।

```solidity
        emit Approval(owner, spender, amount);
    }

```

### ডেসিমাল ভেরিয়েবল পরিবর্তন করুন {#modify-the-decimals-variable}

```solidity


    /**
     * @dev {decimals}-কে 18-এর ডিফল্ট মানের চেয়ে অন্য একটি মানে সেট করে।
     *
     * সতর্কতা: এই ফাংশনটি শুধুমাত্র কনস্ট্রাক্টর থেকে কল করা উচিত। টোকেন কন্ট্র্যাক্টগুলির সাথে ইন্টারঅ্যাক্ট করা বেশিরভাগ
     * অ্যাপ্লিকেশন আশা করবে না যে {decimals} কখনো পরিবর্তন হবে, এবং যদি তা হয় তবে ভুলভাবে কাজ করতে পারে।
     */
    function _setupDecimals(uint8 decimals_) internal {
        _decimals = decimals_;
    }
```

এই ফাংশনটি `_decimals` ভেরিয়েবলটি পরিবর্তন করে যা ইউজার ইন্টারফেসগুলিকে পরিমাণটি কীভাবে ব্যাখ্যা করতে হবে তা জানাতে ব্যবহৃত হয়।
আপনার এটি কনস্ট্রাক্টর থেকে কল করা উচিত। পরবর্তী কোনো সময়ে এটি কল করা অসততা হবে এবং অ্যাপ্লিকেশনগুলি এটি পরিচালনা করার জন্য ডিজাইন করা হয়নি।

### হুকস {#hooks}

```solidity

    /**
     * @dev টোকেনের যেকোনো স্থানান্তরের আগে যে হুক কল করা হয়। এর মধ্যে মিন্টিং এবং বার্নিং অন্তর্ভুক্ত রয়েছে।
     *
     * কল করার শর্ত:
     *
     * - যখন `from` এবং `to` উভয়ই নন-জিরো হয়, তখন `from`-এর টোকেনের `amount` পরিমাণ `to`-কে স্থানান্তর করা হবে।
     * - যখন `from` শূন্য হয়, তখন `to`-এর জন্য `amount` পরিমাণ টোকেন মিন্ট করা হবে।
     * - যখন `to` শূন্য হয়, তখন `from`-এর টোকেনের `amount` পরিমাণ বার্ন করা হবে।
     * - `from` এবং `to` কখনোই উভয়ই শূন্য হয় না।
     *
     * হুক সম্পর্কে আরও জানতে, xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]-এ যান।
     */
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
```

এটি স্থানান্তরের সময় কল করার জন্য হুক ফাংশন। এটি এখানে খালি, কিন্তু যদি আপনার এটি কিছু করার প্রয়োজন হয় তবে আপনি শুধু এটি ওভাররাইড করুন।

## উপসংহার {#conclusion}

পর্যালোচনা করার জন্য, এখানে এই কন্ট্র্যাক্টের কিছু সবচেয়ে গুরুত্বপূর্ণ ধারণা দেওয়া হল (আমার মতে, আপনার মতামত ভিন্ন হতে পারে):

- _ব্লকচেইনে কোনো গোপনীয়তা নেই_। যেকোনো তথ্য যা একটি স্মার্ট কন্ট্র্যাক্ট অ্যাক্সেস করতে পারে তা সমগ্র বিশ্বের জন্য উপলব্ধ।
- আপনি আপনার নিজের লেনদেনের ক্রম নিয়ন্ত্রণ করতে পারেন, কিন্তু অন্য লোকের লেনদেন কখন ঘটবে তা নয়। এই কারণেই একটি অ্যালাওয়েন্স পরিবর্তন করা বিপজ্জনক হতে পারে, কারণ এটি স্পেন্ডারকে উভয় অ্যালাওয়েন্সের যোগফল খরচ করার অনুমতি দেয়।
- `uint256` টাইপের মানগুলি মোড়ানো হয়। অন্য কথায়, _0-1=2^256-1_। যদি এটি কাঙ্ক্ষিত আচরণ না হয়, তাহলে আপনাকে এটি পরীক্ষা করতে হবে (অথবা SafeMath লাইব্রেরি ব্যবহার করতে হবে যা আপনার জন্য এটি করে)। মনে রাখবেন যে এটি [সলিডিটি 0.8.0](https://docs.soliditylang.org/en/breaking/080-breaking-changes.html)-তে পরিবর্তিত হয়েছে।
- একটি নির্দিষ্ট ধরণের সমস্ত স্টেট পরিবর্তন একটি নির্দিষ্ট স্থানে করুন, কারণ এটি অডিটিং সহজ করে।
  এই কারণেই আমাদের কাছে, উদাহরণস্বরূপ, `_approve` রয়েছে, যা `approve`, `transferFrom`, `increaseAllowance`, এবং `decreaseAllowance` দ্বারা কল করা হয়।
- স্টেট পরিবর্তনগুলি অ্যাটমিক হওয়া উচিত, তাদের মাঝখানে অন্য কোনো অ্যাকশন ছাড়াই (যেমন আপনি `_transfer`-এ দেখতে পারেন)। এর কারণ হল স্টেট পরিবর্তনের সময় আপনার একটি অসামঞ্জস্যপূর্ণ স্টেট থাকে। উদাহরণস্বরূপ, প্রেরকের ব্যালেন্স থেকে কর্তন করার সময় এবং প্রাপকের ব্যালেন্সে যোগ করার সময়ের মধ্যে যত টোকেন থাকা উচিত তার চেয়ে কম টোকেন存在 করে। যদি তাদের মধ্যে অপারেশন থাকে, বিশেষ করে একটি ভিন্ন কন্ট্র্যাক্টে কল, তবে এর সম্ভাব্য অপব্যবহার করা যেতে পারে।

এখন যেহেতু আপনি দেখেছেন OpenZeppelin ERC-20 কন্ট্র্যাক্টটি কীভাবে লেখা হয়েছে, এবং বিশেষ করে কীভাবে এটি আরও নিরাপদ করা হয়েছে, যান এবং আপনার নিজের নিরাপদ কন্ট্র্যাক্ট এবং অ্যাপ্লিকেশনগুলি লিখুন।

[আমার আরও কাজের জন্য এখানে দেখুন](https://cryptodocguy.pro/)।
