---
title: "Uniswap-v2 চুক্তির ওয়াক-থ্রু"
description: "Uniswap-v2 চুক্তিটি কীভাবে কাজ করে? এটা কেন সেভাবে লেখা হয়েছে?"
author: Ori Pomerantz
tags: [ "সলিডিটি" ]
skill: intermediate
published: 2021-05-01
lang: bn
---

## ভূমিকা {#introduction}

[Uniswap v2](https://app.uniswap.org/whitepaper.pdf) যেকোনো দুটি ERC-20 টোকেনের মধ্যে একটি বিনিময় বাজার তৈরি করতে পারে। এই নিবন্ধে আমরা এই প্রোটোকলটি বাস্তবায়নকারী চুক্তিগুলির জন্য সোর্স কোডটি দেখব এবং দেখব কেন সেগুলি এইভাবে লেখা হয়েছে।

### Uniswap কী করে? {#what-does-uniswap-do}

মূলত, দুই ধরনের ব্যবহারকারী রয়েছে: লিকুইডিটি প্রদানকারী এবং ট্রেডার।

_লিকুইডিটি প্রদানকারীরা_ দুটি টোকেন দিয়ে পুলটি সরবরাহ করে যা বিনিময় করা যেতে পারে (আমরা তাদের **টোকেন0** এবং **টোকেন1** বলব)। বিনিময়ে, তারা একটি তৃতীয় টোকেন পায় যা পুলের আংশিক মালিকানার প্রতিনিধিত্ব করে যাকে _লিকুইডিটি টোকেন_ বলা হয়।

_ট্রেডাররা_ পুলে এক ধরনের টোকেন পাঠায় এবং লিকুইডিটি প্রদানকারীদের দ্বারা সরবরাহ করা পুল থেকে অন্যটি গ্রহণ করে (উদাহরণস্বরূপ, **টোকেন0** পাঠান এবং **টোকেন1** গ্রহণ করুন)। বিনিময় হার পুলে থাকা **টোকেন0** এবং **টোকেন1** এর আপেক্ষিক সংখ্যা দ্বারা নির্ধারিত হয়। এছাড়াও, পুলটি লিকুইডিটি পুলের জন্য পুরস্কার হিসাবে একটি ছোট শতাংশ নেয়।

যখন লিকুইডিটি প্রদানকারীরা তাদের সম্পদ ফেরত চায় তখন তারা পুল টোকেন পুড়িয়ে ফেলতে পারে এবং পুরস্কারে তাদের অংশ সহ তাদের টোকেনগুলি ফেরত পেতে পারে।

[সম্পূর্ণ বিবরণের জন্য এখানে ক্লিক করুন](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/swaps/)।

### কেন v2? কেন v3 নয়? {#why-v2}

[Uniswap v3](https://app.uniswap.org/whitepaper-v3.pdf) একটি আপগ্রেড যা v2 এর চেয়ে অনেক বেশি জটিল। প্রথমে v2 শেখা এবং তারপর v3 এ যাওয়া সহজ।

### কোর চুক্তি বনাম পেরিফেরি চুক্তি {#contract-types}

Uniswap v2 দুটি উপাদানে বিভক্ত, একটি কোর এবং একটি পেরিফেরি। এই বিভাজন মূল চুক্তিগুলিকে, যা সম্পদ ধারণ করে এবং তাই সুরক্ষিত _হতে_ হবে, সহজ এবং অডিট করা সহজ হতে দেয়। ট্রেডারদের জন্য প্রয়োজনীয় সমস্ত অতিরিক্ত কার্যকারিতা তখন পেরিফেরি চুক্তি দ্বারা সরবরাহ করা যেতে পারে।

## ডেটা এবং কন্ট্রোল ফ্লো {#flows}

এটি ডেটা এবং নিয়ন্ত্রণের প্রবাহ যা ঘটে যখন আপনি Uniswap-এর তিনটি প্রধান কাজ সম্পাদন করেন:

1. বিভিন্ন টোকেনের মধ্যে অদলবদল করুন
2. মার্কেটে লিকুইডিটি যোগ করুন এবং পেয়ার এক্সচেঞ্জ ERC-20 লিকুইডিটি টোকেন দিয়ে পুরস্কৃত হন
3. ERC-20 লিকুইডিটি টোকেন বার্ন করুন এবং ERC-20 টোকেনগুলি ফেরত পান যা পেয়ার এক্সচেঞ্জ ট্রেডারদের বিনিময় করতে দেয়

### অদলবদল {#swap-flow}

এটি ট্রেডারদের দ্বারা ব্যবহৃত সবচেয়ে সাধারণ প্রবাহ:

#### কলার {#caller}

1. অদলবদল করার জন্য পেরিফেরি অ্যাকাউন্টকে একটি অ্যালাওয়েন্স প্রদান করুন।
2. পেরিফেরি চুক্তির অনেক সোয়াপ ফাংশনের মধ্যে একটিকে কল করুন (কোনটি নির্ভর করে ETH জড়িত কিনা, ট্রেডার জমার জন্য টোকেনের পরিমাণ বা ফেরত পাওয়ার জন্য টোকেনের পরিমাণ নির্দিষ্ট করে কিনা ইত্যাদি)।
   প্রতিটি সোয়াপ ফাংশন একটি `path` গ্রহণ করে, যা হল বিনিময়ের একটি অ্যারে যার মাধ্যমে যেতে হবে।

#### পেরিফেরি চুক্তিতে (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02-sol}

3. পাথ বরাবর প্রতিটি এক্সচেঞ্জে ট্রেড করার জন্য প্রয়োজনীয় পরিমাণ শনাক্ত করুন।
4. পাথের উপর পুনরাবৃত্তি করে। পথ বরাবর প্রতিটি বিনিময়ের জন্য এটি ইনপুট টোকেন পাঠায় এবং তারপর বিনিময়ের `swap` ফাংশন কল করে।
   বেশিরভাগ ক্ষেত্রে টোকেনের জন্য গন্তব্য ঠিকানাটি পাথের পরবর্তী পেয়ার এক্সচেঞ্জ। চূড়ান্ত বিনিময়ে এটি ট্রেডারের দেওয়া ঠিকানা।

#### কোর চুক্তিতে (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

5. যাচাই করুন যে মূল চুক্তিটি প্রতারিত হচ্ছে না এবং সোয়াপের পরে পর্যাপ্ত তারল্য বজায় রাখতে পারে।
6. দেখুন পরিচিত রিজার্ভ ছাড়াও আমাদের কাছে কতগুলি অতিরিক্ত টোকেন আছে। সেই পরিমাণ হল ইনপুট টোকেনের সংখ্যা যা আমরা বিনিময়ের জন্য পেয়েছি।
7. গন্তব্যে আউটপুট টোকেন পাঠান।
8. রিজার্ভ পরিমাণ আপডেট করতে `_update` কল করুন

#### পেরিফেরি চুক্তিতে ফিরে যান (UniswapV2Router02.sol) {#back-in-the-periphery-contract-uniswapv2router02-sol}

9. যেকোনো প্রয়োজনীয় পরিষ্করণ সম্পাদন করুন (উদাহরণস্বরূপ, ট্রেডারকে পাঠানোর জন্য ETH ফেরত পেতে WETH টোকেন বার্ন করুন)

### লিকুইডিটি যোগ করুন {#add-liquidity-flow}

#### কলার {#caller-2}

1. লিকুইডিটি পুলে যোগ করার জন্য পেরিফেরি অ্যাকাউন্টকে একটি অ্যালাওয়েন্স প্রদান করুন।
2. পেরিফেরি চুক্তির `addLiquidity` ফাংশনগুলির মধ্যে একটিকে কল করুন।

#### পেরিফেরি চুক্তিতে (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-2}

3. প্রয়োজনে একটি নতুন পেয়ার এক্সচেঞ্জ তৈরি করুন
4. যদি একটি বিদ্যমান পেয়ার এক্সচেঞ্জ থাকে, তাহলে যোগ করার জন্য টোকেনের পরিমাণ গণনা করুন। এটি উভয় টোকেনের জন্য অভিন্ন মান হওয়ার কথা, তাই বিদ্যমান টোকেনের সাথে নতুন টোকেনের একই অনুপাত।
5. পরিমাণগুলি গ্রহণযোগ্য কিনা তা পরীক্ষা করুন (কলকারীরা একটি ন্যূনতম পরিমাণ নির্দিষ্ট করতে পারে যার নীচে তারা লিকুইডিটি যোগ করতে চায় না)
6. কোর চুক্তিকে কল করুন।

#### কোর চুক্তিতে (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-2}

7. লিকুইডিটি টোকেন মিন্ট করুন এবং কলারকে পাঠান
8. রিজার্ভ পরিমাণ আপডেট করতে `_update` কল করুন

### লিকুইডিটি সরান {#remove-liquidity-flow}

#### কলার {#caller-3}

1. আন্ডারলাইং টোকেনের বিনিময়ে বার্ন করার জন্য লিকুইডিটি টোকেনের একটি অ্যালাওয়েন্স সহ পেরিফেরি অ্যাকাউন্ট সরবরাহ করুন।
2. পেরিফেরি চুক্তির `removeLiquidity` ফাংশনগুলির একটিকে কল করুন।

#### পেরিফেরি চুক্তিতে (UniswapV2Router02.sol) {#in-the-periphery-contract-uniswapv2router02sol-3}

3. পেয়ার এক্সচেঞ্জে লিকুইডিটি টোকেন পাঠান

#### কোর চুক্তিতে (UniswapV2Pair.sol) {#in-the-core-contract-uniswapv2pairsol-3}

4. বার্ন করা টোকেনের অনুপাতে গন্তব্য ঠিকানায় আন্ডারলাইং টোকেন পাঠান। উদাহরণস্বরূপ, যদি পুলে 1000 A টোকেন, 500 B টোকেন এবং 90টি লিকুইডিটি টোকেন থাকে এবং আমরা বার্ন করার জন্য 9টি টোকেন পাই, তাহলে আমরা 10% লিকুইডিটি টোকেন বার্ন করছি তাই আমরা ব্যবহারকারীকে 100 A টোকেন এবং 50 B টোকেন ফেরত পাঠাই।
5. লিকুইডিটি টোকেন বার্ন করুন
6. রিজার্ভ পরিমাণ আপডেট করতে `_update` কল করুন

## কোর চুক্তি {#core-contracts}

এগুলি সুরক্ষিত চুক্তি যা লিকুইডিটি ধারণ করে।

### UniswapV2Pair.sol {#UniswapV2Pair}

[এই চুক্তিটি](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol) প্রকৃত পুলটি প্রয়োগ করে যা টোকেন বিনিময় করে। এটি মূল Uniswap কার্যকারিতা।

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Pair.sol';
import './UniswapV2ERC20.sol';
import './libraries/Math.sol';
import './libraries/UQ112x112.sol';
import './interfaces/IERC20.sol';
import './interfaces/IUniswapV2Factory.sol';
import './interfaces/IUniswapV2Callee.sol';
```

এইগুলি হল সেই সমস্ত ইন্টারফেস যা চুক্তিকে জানতে হবে, হয় কারণ চুক্তি সেগুলি প্রয়োগ করে (`IUniswapV2Pair` এবং `UniswapV2ERC20`) অথবা কারণ এটি এমন চুক্তিগুলিকে কল করে যা সেগুলি প্রয়োগ করে।

```solidity
contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
```

এই চুক্তিটি `UniswapV2ERC20` থেকে উত্তরাধিকার সূত্রে প্রাপ্ত, যা লিকুইডিটি টোকেনের জন্য ERC-20 ফাংশন সরবরাহ করে।

```solidity
    using SafeMath  for uint;
```

[SafeMath লাইব্রেরি](https://docs.openzeppelin.com/contracts/2.x/api/math) ওভারফ্লো এবং আন্ডারফ্লো এড়াতে ব্যবহৃত হয়। এটি গুরুত্বপূর্ণ কারণ অন্যথায় আমরা এমন একটি পরিস্থিতির মধ্যে পড়তে পারি যেখানে একটি মান `-1` হওয়া উচিত, কিন্তু পরিবর্তে `2^256-1`।

```solidity
    using UQ112x112 for uint224;
```

পুল চুক্তিতে অনেক গণনার জন্য ভগ্নাংশের প্রয়োজন হয়। তবে, EVM দ্বারা ভগ্নাংশ সমর্থিত নয়।
Uniswap যে সমাধানটি খুঁজে পেয়েছে তা হল 224 বিট মান ব্যবহার করা, যার মধ্যে 112 বিট পূর্ণসংখ্যার জন্য এবং 112 বিট ভগ্নাংশের জন্য। সুতরাং `1.0` কে `2^112` হিসাবে উপস্থাপন করা হয়, `1.5` কে `2^112 + 2^111` হিসাবে উপস্থাপন করা হয়, ইত্যাদি।

এই লাইব্রেরি সম্পর্কে আরও বিশদ বিবরণ [নথিতে পরে](#FixedPoint) পাওয়া যাবে।

#### ভেরিয়েবল {#pair-vars}

```solidity
    uint public constant MINIMUM_LIQUIDITY = 10**3;
```

শূন্য দ্বারা ভাগ করার ঘটনা এড়াতে, ন্যূনতম সংখ্যক লিকুইডিটি টোকেন রয়েছে যা সর্বদা বিদ্যমান থাকে (কিন্তু শূন্য অ্যাকাউন্টের মালিকানাধীন)। সেই সংখ্যাটি হল **MINIMUM_LIQUIDITY**, এক হাজার।

```solidity
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));
```

এটি ERC-20 ট্রান্সফার ফাংশনের জন্য ABI সিলেক্টর। এটি দুটি টোকেন অ্যাকাউন্টে ERC-20 টোকেন স্থানান্তর করতে ব্যবহৃত হয়।

```solidity
    address public factory;
```

এটি হল ফ্যাক্টরি চুক্তি যা এই পুলটি তৈরি করেছে। প্রতিটি পুল দুটি ERC-20 টোকেনের মধ্যে একটি বিনিময়, ফ্যাক্টরি হল একটি কেন্দ্রীয় বিন্দু যা এই সমস্ত পুলকে সংযুক্ত করে।

```solidity
    address public token0;
    address public token1;
```

এই পুল দ্বারা বিনিময় করা যেতে পারে এমন দুটি ধরণের ERC-20 টোকেনের জন্য চুক্তির ঠিকানা রয়েছে।

```solidity
    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
```

প্রতিটি টোকেন টাইপের জন্য পুলের রিজার্ভ রয়েছে। আমরা ধরে নিই যে দুটি একই পরিমাণ মূল্যের প্রতিনিধিত্ব করে এবং তাই প্রতিটি টোকেন0 এর মূল্য হল রিজার্ভ1/রিজার্ভ0 টোকেন1।

```solidity
    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves
```

শেষ ব্লকের টাইমস্ট্যাম্প যেখানে একটি বিনিময় ঘটেছে, যা সময়ের সাথে সাথে বিনিময় হার ট্র্যাক করতে ব্যবহৃত হয়।

Ethereum চুক্তির সবচেয়ে বড় গ্যাস খরচগুলির মধ্যে একটি হল স্টোরেজ, যা চুক্তির এক কল থেকে পরবর্তীতে টিকে থাকে। প্রতিটি স্টোরেজ সেল 256 বিট দীর্ঘ। সুতরাং তিনটি ভেরিয়েবল, `reserve0`, `reserve1`, এবং `blockTimestampLast`, এমনভাবে বরাদ্দ করা হয়েছে যে একটি একক স্টোরেজ মান তাদের তিনটিই অন্তর্ভুক্ত করতে পারে (112+112+32=256)।

```solidity
    uint public price0CumulativeLast;
    uint public price1CumulativeLast;
```

এই ভেরিয়েবলগুলি প্রতিটি টোকেনের জন্য ক্রমপুঞ্জিত খরচ ধারণ করে (প্রতিটি অন্যটির পরিপ্রেক্ষিতে)। এগুলি একটি নির্দিষ্ট সময়ের জন্য গড় বিনিময় হার গণনা করতে ব্যবহার করা যেতে পারে।

```solidity
    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
```

পেয়ার এক্সচেঞ্জ যেভাবে token0 এবং token1 এর মধ্যে বিনিময় হার নির্ধারণ করে তা হল ট্রেডের সময় দুটি রিজার্ভের গুণিতককে স্থির রাখা। `kLast` হল এই মান। যখন একজন লিকুইডিটি প্রদানকারী টোকেন জমা বা উত্তোলন করে তখন এটি পরিবর্তিত হয় এবং 0.3% বাজার ফি-এর কারণে এটি সামান্য বৃদ্ধি পায়।

এখানে একটি সহজ উদাহরণ দেওয়া হল। নোট করুন যে সরলতার জন্য টেবিলটিতে দশমিক বিন্দুর পরে মাত্র তিনটি সংখ্যা রয়েছে এবং আমরা 0.3% ট্রেডিং ফি উপেক্ষা করি তাই সংখ্যাগুলি সঠিক নয়।

| ঘটনা                                                                   |                  রিজার্ভ0 |                  রিজার্ভ1 | রিজার্ভ0 \* রিজার্ভ1 | গড় বিনিময় হার (টোকেন1 / টোকেন0) |
| ---------------------------------------------------------------------- | ------------------------: | ------------------------: | -------------------: | ---------------------------------------------------- |
| প্রাথমিক সেটআপ                                                         | 1,000.000 | 1,000.000 |            1,000,000 |                                                      |
| ট্রেডার A 50টি টোকেন0 এর জন্য 47.619 টোকেন1 অদলবদল করে | 1,050.000 |   952.381 |            1,000,000 | 0.952                                |
| ট্রেডার B 10টি টোকেন0 এর জন্য 8.984 টোকেন1 অদলবদল করে  | 1,060.000 |   943.396 |            1,000,000 | 0.898                                |
| ট্রেডার C 40টি টোকেন0 এর জন্য 34.305 টোকেন1 অদলবদল করে | 1,100.000 |   909.090 |            1,000,000 | 0.858                                |
| ট্রেডার D 100 টোকেন1 এর জন্য 109.01 টোকেন0 অদলবদল করে  |   990.990 | 1,009.090 |            1,000,000 | 0.917                                |
| ট্রেডার E 10 টোকেন0 এর জন্য 10.079 টোকেন1 অদলবদল করে   | 1,000.990 |   999.010 |            1,000,000 | 1.008                                |

চাহিদা এবং সরবরাহের উপর ভিত্তি করে ট্রেডাররা টোকেন0 বেশি সরবরাহ করার সাথে সাথে টোকেন1 এর আপেক্ষিক মান বৃদ্ধি পায় এবং এর বিপরীতও হয়।

#### লক {#pair-lock}

```solidity
    uint private unlocked = 1;
```

নিরাপত্তা দুর্বলতার একটি শ্রেণী রয়েছে যা [রিএন্ট্রেন্সি অ্যাবিউজ](https-এর উপর ভিত্তি করে তৈরি।medium.com/coinmonks/ethernaut-lvl-10-re-entrancy-walkthrough-how-to-abuse-execution-ordering-and-reproduce-the-dao-7ec88b912c14). Uniswap-কে নির্বিচারে ERC-20 টোকেন স্থানান্তর করতে হবে, যার অর্থ হল ERC-20 চুক্তিগুলিকে কল করা যা তাদের কল করা Uniswap বাজারকে অপব্যবহার করার চেষ্টা করতে পারে।
চুক্তির অংশ হিসাবে একটি `unlocked` ভেরিয়েবল থাকার মাধ্যমে, আমরা ফাংশনগুলি চলার সময় (একই লেনদেনের মধ্যে) কল হওয়া থেকে আটকাতে পারি।

```solidity
    modifier lock() {
```

এই ফাংশনটি একটি [modifier](https://docs.soliditylang.org/en/v0.8.3/contracts.html#function-modifiers), একটি ফাংশন যা একটি সাধারণ ফাংশনের চারপাশে মোড়ানো হয় যাতে এর আচরণ কোনোভাবে পরিবর্তন করা যায়।

```solidity
        require(unlocked == 1, 'UniswapV2: LOCKED');
        unlocked = 0;
```

যদি `unlocked` এক এর সমান হয়, তাহলে এটিকে শূন্যতে সেট করুন। যদি এটি ইতিমধ্যেই শূন্য হয় তবে কলটি বাতিল করুন, এটিকে ব্যর্থ করুন।

```solidity
        _;
```

একটি মডিফায়ারে _; হল আসল ফাংশন কল (সমস্ত প্যারামিটার সহ)। এখানে এর মানে হল যে ফাংশন কলটি শুধুমাত্র তখনই ঘটবে যদি কল করার সময় `unlocked` এর মান এক থাকে, এবং এটি চলার সময় `unlocked` এর মান শূন্য থাকবে।

```solidity
        unlocked = 1;
    }
```

মূল ফাংশনটি রিটার্ন করার পরে, লকটি ছেড়ে দিন।

#### বিবিধ ফাংশন {#pair-misc}

```solidity
    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }
```

এই ফাংশনটি কলারদের এক্সচেঞ্জের বর্তমান অবস্থা প্রদান করে। লক্ষ্য করুন যে সলিডিটি ফাংশন [একাধিক মান ফেরত দিতে পারে](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values)।

```solidity
    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
```

এই অভ্যন্তরীণ ফাংশনটি এক্সচেঞ্জ থেকে অন্য কারো কাছে একটি নির্দিষ্ট পরিমাণ ERC20 টোকেন স্থানান্তর করে। `SELECTOR` নির্দিষ্ট করে যে আমরা যে ফাংশনটি কল করছি তা হল `transfer(address,uint)` (উপরের সংজ্ঞা দেখুন)।

টোকেন ফাংশনের জন্য একটি ইন্টারফেস ইম্পোর্ট করা এড়াতে, আমরা "ম্যানুয়ালি" কলটি তৈরি করি [ABI ফাংশনগুলির](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions) মধ্যে একটি ব্যবহার করে।

```solidity
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }
```

একটি ERC-20 স্থানান্তর কল দুটি উপায়ে ব্যর্থতার রিপোর্ট করতে পারে:

1. রিভার্ট। যদি একটি বাহ্যিক চুক্তিতে করা একটি কল রিভার্ট হয়, তাহলে বুলিয়ান রিটার্ন মানটি `false` হয়
2. সাধারণভাবে শেষ করুন কিন্তু একটি ব্যর্থতার রিপোর্ট করুন। সেক্ষেত্রে রিটার্ন ভ্যালু বাফারের একটি নন-জিরো দৈর্ঘ্য থাকে, এবং যখন বুলিয়ান মান হিসাবে ডিকোড করা হয় তখন এটি `false` হয়

যদি এই শর্তগুলির কোনোটি ঘটে, তাহলে রিভার্ট করুন।

#### ইভেন্টস {#pair-events}

```solidity
    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
```

এই দুটি ইভেন্ট তখন নির্গত হয় যখন একজন লিকুইডিটি প্রদানকারী হয় লিকুইডিটি জমা করে (`Mint`) অথবা তা তুলে নেয় (`Burn`)। উভয় ক্ষেত্রেই, জমা করা বা তুলে নেওয়া token0 এবং token1-এর পরিমাণ ইভেন্টের অংশ, সেইসাথে আমাদের কল করা অ্যাকাউন্টের পরিচয় (`sender`)। একটি উত্তোলনের ক্ষেত্রে, ইভেন্টটিতে টোকেনগুলি গ্রহণকারী টার্গেটও (`to`) অন্তর্ভুক্ত থাকে, যা প্রেরকের সমান নাও হতে পারে।

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

এই ইভেন্টটি নির্গত হয় যখন একজন ব্যবসায়ী অন্য টোকেনের জন্য একটি টোকেন অদলবদল করে। আবারও, প্রেরক এবং গন্তব্য একই নাও হতে পারে।
প্রতিটি টোকেন হয় এক্সচেঞ্জে পাঠানো হতে পারে, বা সেখান থেকে গ্রহণ করা হতে পারে।

```solidity
    event Sync(uint112 reserve0, uint112 reserve1);
```

অবশেষে, `Sync` প্রতিবার টোকেন যোগ বা উত্তোলন করার সময় নির্গত হয়, কারণ নির্বিশেষে, সর্বশেষ রিজার্ভ তথ্য (এবং সেইজন্য বিনিময় হার) প্রদান করার জন্য।

#### সেটআপ ফাংশন {#pair-setup}

নতুন পেয়ার এক্সচেঞ্জ সেট আপ করার সময় এই ফাংশনগুলিকে একবার কল করার কথা।

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

কনস্ট্রাক্টর নিশ্চিত করে যে আমরা পেয়ারটি তৈরি করা ফ্যাক্টরির অ্যাড্রেসের ট্র্যাক রাখব। `initialize`-এর জন্য এবং ফ্যাক্টরি ফি-এর জন্য (যদি থাকে) এই তথ্যের প্রয়োজন।

```solidity
    // ডিপ্লয়মেন্টের সময় ফ্যাক্টরি দ্বারা একবার কল করা হয়
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // পর্যাপ্ত চেক
        token0 = _token0;
        token1 = _token1;
    }
```

এই ফাংশনটি ফ্যাক্টরিকে (এবং শুধুমাত্র ফ্যাক্টরিকে) দুটি ERC-20 টোকেন নির্দিষ্ট করার অনুমতি দেয় যা এই পেয়ারটি এক্সচেঞ্জ করবে।

#### অভ্যন্তরীণ আপডেট ফাংশন {#pair-update-internal}

##### \_update

```solidity
    // রিজার্ভ আপডেট করুন এবং, প্রতি ব্লকে প্রথম কলে, মূল্য সঞ্চয়কারী
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

এই ফাংশনটি প্রতিবার টোকেন জমা বা উত্তোলন করার সময় কল করা হয়।

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

যদি balance0 বা balance1 (uint256) এর মধ্যে যেকোনো একটি uint112(-1) (=2^112-1) এর থেকে বেশি হয় (ফলে এটি ওভারফ্লো হয় এবং uint112-এ রূপান্তরিত হলে 0-তে ফিরে আসে) তাহলে ওভারফ্লো রোধ করতে \_update চালিয়ে যেতে অস্বীকার করুন। একটি সাধারণ টোকেনের সাথে যা 10^18 ইউনিটে বিভক্ত করা যায়, এর মানে হল প্রতিটি এক্সচেঞ্জ প্রতিটি টোকেনের প্রায় 5.1\*10^15-এ সীমাবদ্ধ। এখনও পর্যন্ত এটি কোনো সমস্যা হয়নি।

```solidity
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // ওভারফ্লো কাম্য
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
```

যদি অতিবাহিত সময় শূন্য না হয়, তার মানে আমরা এই ব্লকের প্রথম এক্সচেঞ্জ লেনদেন। সেক্ষেত্রে, আমাদের মূল্য সঞ্চয়কারী আপডেট করতে হবে।

```solidity
            // * কখনও ওভারফ্লো হয় না, এবং + ওভারফ্লো কাম্য
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
```

প্রতিটি মূল্য সঞ্চয়কারী সর্বশেষ মূল্য (অন্যান্য টোকেনের রিজার্ভ/এই টোকেনের রিজার্ভ) দিয়ে সেকেন্ডে অতিবাহিত সময়ের সাথে গুণ করে আপডেট করা হয়। একটি গড় মূল্য পেতে, আপনি দুটি সময়ের বিন্দুতে ক্রমবর্ধমান মূল্য পড়ুন এবং তাদের মধ্যে সময়ের পার্থক্য দ্বারা ভাগ করুন। উদাহরণস্বরূপ, এই ঘটনাগুলির ক্রমটি ধরুন:

| ঘটনা                                                                      |                  রিজার্ভ0 |                  রিজার্ভ1 | টাইমস্ট্যাম্প | প্রান্তিক বিনিময় হার (reserve1 / reserve0) |                                                       price0CumulativeLast |
| ------------------------------------------------------------------------- | ------------------------: | ------------------------: | ------------- | -------------------------------------------------------------: | -------------------------------------------------------------------------: |
| প্রাথমিক সেটআপ                                                            | 1,000.000 | 1,000.000 | 5,000         |                                          1.000 |                                                                          0 |
| ট্রেডার A 50 token0 জমা দেয় এবং 47.619 token1 ফেরত পায়  | 1,050.000 |   952.381 | 5,020         |                                          0.907 |                                                                         20 |
| ট্রেডার B 10 token0 জমা দেয় এবং 8.984 token1 ফেরত পায়   | 1,060.000 |   943.396 | 5,030         |                                          0.890 |                       20+10\*0.907 = 29.07 |
| ট্রেডার C 40 token0 জমা দেয় এবং 34.305 token1 ফেরত পায়  | 1,100.000 |   909.090 | 5,100         |                                          0.826 |    29.07+70\*0.890 = 91.37 |
| ট্রেডার D 100 token1 জমা দেয় এবং 109.01 token0 ফেরত পায় |   990.990 | 1,009.090 | 5,110         |                                          1.018 |    91.37+10\*0.826 = 99.63 |
| ট্রেডার E 10 token0 জমা দেয় এবং 10.079 token1 ফেরত পায়  | 1,000.990 |   999.010 | 5,150         |                                          0.998 | 99.63+40\*1.1018 = 143.702 |

ধরুন আমরা 5,030 এবং 5,150 টাইমস্ট্যাম্পের মধ্যে **Token0**-এর গড় মূল্য গণনা করতে চাই। `price0Cumulative`-এর মানের পার্থক্য হল 143.702-29.07=114.632। এটি দুই মিনিটের (120 সেকেন্ড) গড়। সুতরাং গড় মূল্য হল 114.632/120 = 0.955।

এই মূল্য গণনার কারণেই আমাদের পুরানো রিজার্ভের আকার জানতে হবে।

```solidity
মূলত, একটি মোডিফায়ারে `_;` হল মূল ফাংশন কল (সমস্ত প্যারামিটার সহ)।
```

এখানে এর মানে হল যে ফাংশন কলটি কেবল তখনই ঘটবে যদি `unlocked` কল করার সময় এক ছিল এবং এটি চলার সময় `unlocked`-এর মান শূন্য।

##### ```
    unlocked = 1;
}
```

```solidity
প্রধান ফাংশনটি ফেরত আসার পরে, লকটি ছেড়ে দিন।
```

অন্যান্য ফাংশন {#pair-misc}     function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
_reserve0 = reserve0;
_reserve1 = reserve1;
_blockTimestampLast = blockTimestampLast;
}

এই ফাংশনটি কলারদের বিনিময়ের বর্তমান অবস্থা প্রদান করে।

```solidity
লক্ষ্য করুন যে Solidity ফাংশন [একাধিক মান ফেরত দিতে পারে](https://docs.soliditylang.org/en/v0.8.3/contracts.html#returning-multiple-values)।
```

```
function _safeTransfer(address token, address to, uint value) private {
    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value)); এই অভ্যন্তরীণ ফাংশনটি এক্সচেঞ্জ থেকে অন্য কারো কাছে ERC20 টোকেনের একটি পরিমাণ স্থানান্তর করে।
```

```solidity
`SELECTOR` নির্দিষ্ট করে যে আমরা যে ফাংশনটি কল করছি তা হল `transfer(address,uint)` (উপরের সংজ্ঞা দেখুন)।
```

টোকেন ফাংশনের জন্য একটি ইন্টারফেস আমদানি করা এড়াতে, আমরা "ম্যানুয়ালি" [ABI ফাংশনগুলির](https://docs.soliditylang.org/en/v0.8.3/units-and-global-variables.html#abi-encoding-and-decoding-functions) একটি ব্যবহার করে কলটি তৈরি করি।
require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
}

```solidity
ERC-20 ট্রান্সফার কল দুটি উপায়ে ব্যর্থতার রিপোর্ট করতে পারে:
```

রিভার্ট। যদি একটি বহিরাগত চুক্তিতে একটি কল রিভার্ট হয়, তাহলে বুলিয়ান রিটার্ন মান `false`

```solidity
সাধারণভাবে শেষ করুন কিন্তু একটি ব্যর্থতার রিপোর্ট করুন।
```

সেই ক্ষেত্রে রিটার্ন ভ্যালু বাফারের একটি অ-শূন্য দৈর্ঘ্য থাকে এবং যখন একটি বুলিয়ান মান হিসাবে ডিকোড করা হয় তখন এটি `false` হয় এই শর্তগুলির মধ্যে কোনোটি ঘটলে, রিভার্ট করুন।

```solidity
ইভেন্ট {#pair-events}
```

```
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); এই দুটি ইভেন্ট নির্গত হয় যখন একজন লিকুইডিটি প্রদানকারী হয় লিকুইডিটি জমা করে (`Mint`) বা তা উত্তোলন করে (`Burn`)।
```

```solidity
উভয় ক্ষেত্রেই, টোকেন0 এবং টোকেন1 এর পরিমাণ যা জমা বা উত্তোলন করা হয় তা ইভেন্টের অংশ, সেইসাথে আমাদের কল করা অ্যাকাউন্টের পরিচয় (`sender`)।
```

উত্তোলনের ক্ষেত্রে, ইভেন্টটিতে সেই টার্গেটটিও অন্তর্ভুক্ত থাকে যা টোকেনগুলি পেয়েছে (`to`), যা প্রেরকের মতো নাও হতে পারে।

```solidity
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
```

এই ইভেন্টটি নির্গত হয় যখন একজন ট্রেডার একটি টোকেন অন্যটির জন্য অদলবদল করে। আবার, প্রেরক এবং গন্তব্য একই নাও হতে পারে।
প্রতিটি টোকেন হয় এক্সচেঞ্জে পাঠানো যেতে পারে, অথবা এটি থেকে গ্রহণ করা যেতে পারে।

#### ```
event Sync(uint112 reserve0, uint112 reserve1);
```

অবশেষে, `Sync` প্রতিবার টোকেন যোগ বা উত্তোলন করা হলে নির্গত হয়, কারণ যাই হোক না কেন, সর্বশেষ রিজার্ভ তথ্য (এবং তাই বিনিময় হার) প্রদান করতে। সেটআপ ফাংশন {#pair-setup}

##### এই ফাংশনগুলি একবার কল করার কথা যখন নতুন পেয়ার এক্সচেঞ্জ সেট আপ করা হয়।

```solidity
    constructor() public {
        factory = msg.sender;
    }
```

কনস্ট্রাক্টর নিশ্চিত করে যে আমরা পেয়ারটি তৈরি করা ফ্যাক্টরির ঠিকানা ট্র্যাক রাখব। `initialize` এবং ফ্যাক্টরি ফি-এর জন্য এই তথ্যের প্রয়োজন (যদি থাকে)     // called once by the factory at time of deployment
function initialize(address _token0, address _token1) external {
require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
token0 = _token0;
token1 = _token1;
}

```solidity
এই ফাংশনটি ফ্যাক্টরিকে (এবং শুধুমাত্র ফ্যাক্টরিকে) দুটি ERC-20 টোকেন নির্দিষ্ট করার অনুমতি দেয় যা এই পেয়ারটি বিনিময় করবে।
```

অভ্যন্তরীণ আপডেট ফাংশন {#pair-update-internal} \_আপডেট

```solidity
    // update reserves and, on the first call per block, price accumulators
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
```

এই ফাংশনটি প্রতিবার টোকেন জমা বা উত্তোলন করা হলে কল করা হয়।

```solidity
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
```

যদি balance0 বা balance1 (uint256) uint112(-1) (=2^112-1) এর চেয়ে বেশি হয় (তাই এটি uint112 এ রূপান্তরিত হলে ওভারফ্লো হয় এবং 0 এ ফিরে আসে) ওভারফ্লো প্রতিরোধ করার জন্য \_update চালিয়ে যেতে অস্বীকার করুন। একটি সাধারণ টোকেন যা 10^18 ইউনিটে বিভক্ত করা যেতে পারে, এর মানে হল প্রতিটি বিনিময় প্রতিটি টোকেনের প্রায় 5.1\*10^15 এর মধ্যে সীমাবদ্ধ।

```solidity
এখন পর্যন্ত এটি কোনো সমস্যা হয়নি।
```

```
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) { যদি অতিবাহিত সময় শূন্য না হয়, এর মানে হল আমরা এই ব্লকে প্রথম বিনিময় লেনদেন। সেই ক্ষেত্রে, আমাদের খরচ সঞ্চয়কারী আপডেট করতে হবে।             // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    }
```

প্রতিটি খরচ সঞ্চয়কারী সর্বশেষ খরচ (অন্য টোকেনের রিজার্ভ/এই টোকেনের রিজার্ভ) দ্বারা সেকেন্ডে অতিবাহিত সময় দিয়ে আপডেট করা হয়।

গড় মূল্য পেতে, আপনি দুটি সময়ে ক্রমপুঞ্জিত মূল্য পড়েন এবং তাদের মধ্যে সময়ের পার্থক্য দ্বারা ভাগ করেন।
উদাহরণস্বরূপ, এই ঘটনাগুলির ক্রমটি ধরে নিন: একজন ট্রেডার এই বিষয়টি কাজে লাগাতে পারে যে পেয়ার এক্সচেঞ্জ মনে করে **Token0** আরও মূল্যবান, এবং সেখান থেকে ভ্যালু বের করে নিতে পারে।

| ঘটনা                                                            | রিজার্ভ0 | রিজার্ভ1 | রিজার্ভ0 \* রিজার্ভ1 | price0CumulativeLast |
| --------------------------------------------------------------- | -------: | -------: | -------------------: | -------------------: |
| প্রাথমিক সেটআপ                                                  |        8 |       32 |                5,000 |                   40 |
| ট্রেডার 8টি **Token0** টোকেন জমা করে, 16টি **Token1** ফেরত পায় |       16 |       16 |                5,000 |                   32 |

0.907

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
```

ট্রেডার B 10টি টোকেন0 জমা করে এবং 8.984 টোকেন1 ফেরত পায় যদি তারা তা না করে, আমরা তাদের শাস্তি হিসাবে তাদের দেওয়া কম মূল্যের উপর ভিত্তি করে লিকুইডিটি টোকেন দিই।

এটি প্রাথমিক আমানত হোক বা পরবর্তী কোনো আমানত হোক, আমরা যে পরিমাণ লিকুইডিটি টোকেন প্রদান করি তা `reserve0*reserve1`-এর পরিবর্তনের বর্গমূলের সমান এবং লিকুইডিটি টোকেনের মান পরিবর্তন হয় না (যদি না আমরা এমন কোনো আমানত পাই যেখানে উভয় প্রকারের সমান মান নেই, সেক্ষেত্রে "জরিমানা" বিতরণ করা হয়)। 5,030

| ঘটনা                                                                                                                                                        |                                                                                                                                                  রিজার্ভ0 |                                                                                                                                                  রিজার্ভ1 |                                                          রিজার্ভ0 \* রিজার্ভ1 |                                                                                                                          পুলের মান (reserve0 + reserve1) | 5,100 | 0.826 |                                                                                                                                                                                                                                                                                                29.07+70\*0.890 = 91.37 |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------: | ----------------------------------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ----: | --------------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| প্রাথমিক সেটআপ                                                                                                                                              |                                                                                                                                     8.000 |                                                                                                                                     8.000 |                                                                            64 |                                                                                                                                                       1.018 |     8 |                     8 |                                                                                                                                                                                                                                                                                                                                                  2.000 |
| প্রতি প্রকারের চারটি জমা দিন                                                                                                                                |                                                                                                                                                     5,150 |                                                                                                                                                     5,150 |    99.63+40\*1.1018 = 143.702 |                                                                                   ধরা যাক আমরা 5,030 এবং 5,150 টাইমস্ট্যাম্পের মধ্যে **টোকেন0** এর গড় মূল্য গণনা করতে চাই। |     4 |                    12 |                                                                                                                                                                                                                                                                                                                                                  2.000 |
| এই মূল্য গণনা হল সেই কারণ যার জন্য আমাদের পুরানো রিজার্ভ আকারগুলি জানতে হবে।                                                                                | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` |                                               \_mintFee | ```
// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
``` |     2 |                    14 |                                                                                                                                                                                                                                                                                                                                                  2.000 |
| গণনা (এবং তাই গ্যাস খরচ) কমাতে, এই ফি শুধুমাত্র তখন গণনা করা হয় যখন পুল থেকে লিকুইডিটি যোগ করা বা সরানো হয়, প্রতিটি লেনদেনের পরিবর্তে। |                                                          ```
    address feeTo = IUniswapV2Factory(factory).feeTo();
    feeOn = feeTo != address(0);
``` | ```
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
}
``` | যদি এটি শূন্য হয় তবে কোনো প্রোটোকল ফি নেই এবং সেই ফি গণনা করার প্রয়োজন নেই। |                                                                                                                             ```
    uint _kLast = kLast; // gas savings
``` |     0 |                    14 |                                                                                                                                                                                                                                                                                                                    ```
    if (feeOn) {
        if (_kLast != 0) {
``` |
| লিকুইডিটি প্রদানকারীরা তাদের লিকুইডিটি টোকেনের মূল্যায়নের মাধ্যমে তাদের অংশ পায়।                                                                          |                                                      কিন্তু প্রোটোকল ফি-এর জন্য নতুন লিকুইডিটি টোকেন মিন্ট করতে হবে এবং `feeTo` ঠিকানায় সরবরাহ করতে হবে। |                                                      কিন্তু প্রোটোকল ফি-এর জন্য নতুন লিকুইডিটি টোকেন মিন্ট করতে হবে এবং `feeTo` ঠিকানায় সরবরাহ করতে হবে। | যদি এটি শূন্য হয় তবে কোনো প্রোটোকল ফি নেই এবং সেই ফি গণনা করার প্রয়োজন নেই। |                                                                                                                   আপনি বর্গমূল ফাংশনটি [এই নিবন্ধের পরে](#Math) দেখতে পারেন |     0 |                    14 | আমরা জানি যে `kLast` গণনা করার সময় এবং বর্তমানের মধ্যে কোনো লিকুইডিটি যোগ বা অপসারণ করা হয়নি (কারণ আমরা এই গণনাটি প্রতিবার লিকুইডিটি যোগ বা অপসারণ করার সময় চালাই, এটি আসলে পরিবর্তন হওয়ার আগে), তাই `reserve0 * reserve1`-এ যেকোনো পরিবর্তন লেনদেন ফি থেকে আসতে হবে (সেগুলি ছাড়া আমরা `reserve0 * reserve1` স্থির রাখতাম)। |

```solidity
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
```

অতিরিক্ত লিকুইডিটি টোকেন তৈরি করতে এবং সেগুলিকে `feeTo`-তে বরাদ্দ করতে `UniswapV2ERC20._mint` ফাংশনটি ব্যবহার করুন।

```solidity
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }
```

যদি কোনো ফি না থাকে তবে `kLast` কে শূন্যতে সেট করুন (যদি এটি ইতিমধ্যে তা না হয়)।

##### এই চুক্তিটি যখন লেখা হয়েছিল তখন একটি [গ্যাস রিফান্ড বৈশিষ্ট্য](https://eips.ethereum.org/EIPS/eip-3298) ছিল যা চুক্তিগুলিকে তাদের প্রয়োজন নেই এমন স্টোরেজ শূন্য করে Ethereum স্টেটের সামগ্রিক আকার কমাতে উৎসাহিত করেছিল।

```solidity
এই কোডটি যখন সম্ভব তখন সেই রিফান্ড পায়।
```

বাহ্যিকভাবে অ্যাক্সেসযোগ্য ফাংশন {#pair-external}
নোট করুন যে যদিও কোনো লেনদেন বা চুক্তি এই ফাংশনগুলিকে কল _করতে পারে_, সেগুলি পেরিফেরি চুক্তি থেকে কল করার জন্য ডিজাইন করা হয়েছে।

```solidity
আপনি যদি সেগুলি সরাসরি কল করেন তবে আপনি পেয়ার এক্সচেঞ্জকে প্রতারণা করতে পারবেন না, তবে আপনি ভুলের মাধ্যমে মান হারাতে পারেন।
```

মিন্ট     // this low-level function should be called from a contract which performs important safety checks
function mint(address to) external lock returns (uint liquidity) {

```solidity
এই ফাংশনটি কল করা হয় যখন একজন লিকুইডিটি প্রদানকারী পুলে লিকুইডিটি যোগ করে।
```

এটি পুরস্কার হিসাবে অতিরিক্ত লিকুইডিটি টোকেন মিন্ট করে। এটি [একটি পেরিফেরি চুক্তি](#UniswapV2Router02) থেকে কল করা উচিত যা একই লেনদেনে লিকুইডিটি যোগ করার পরে এটিকে কল করে (যাতে অন্য কেউ বৈধ মালিকের আগে নতুন লিকুইডিটি দাবি করে একটি লেনদেন জমা দিতে না পারে)।

```solidity
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
```

এটি একটি Solidity ফাংশনের ফলাফল পড়ার উপায় যা একাধিক মান ফেরত দেয়।

##### আমরা শেষ ফেরত দেওয়া মানগুলি, ব্লক টাইমস্ট্যাম্প, বাতিল করি কারণ আমাদের এটির প্রয়োজন নেই।

```solidity
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0.sub(_reserve0);
        uint amount1 = balance1.sub(_reserve1);
```

বর্তমান ব্যালেন্সগুলি পান এবং দেখুন প্রতিটি টোকেন টাইপের কতটুকু যোগ করা হয়েছে।

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
```

সংগ্রহ করার জন্য প্রোটোকল ফি গণনা করুন, যদি থাকে, এবং সেই অনুযায়ী লিকুইডিটি টোকেন মিন্ট করুন।
যেহেতু `_mintFee`-এর প্যারামিটারগুলি পুরানো রিজার্ভ মান, তাই ফি শুধুমাত্র ফি-এর কারণে পুলের পরিবর্তনের উপর ভিত্তি করে সঠিকভাবে গণনা করা হয়।         uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
if (_totalSupply == 0) {
liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
_mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens

```solidity
যদি এটি প্রথম জমা হয়, `MINIMUM_LIQUIDITY` টোকেন তৈরি করুন এবং সেগুলিকে লক করার জন্য শূন্য ঠিকানায় পাঠান।
```

এগুলি কখনই রিডিম করা যাবে না, যার মানে পুলটি কখনই সম্পূর্ণরূপে খালি হবে না (এটি আমাদের কিছু জায়গায় শূন্য দ্বারা ভাগ করা থেকে বাঁচায়)। `MINIMUM_LIQUIDITY`-এর মান হল এক হাজার, যা বিবেচনা করে যে বেশিরভাগ ERC-20 একটি টোকেনের 10^-18 তম ইউনিটে বিভক্ত, যেমন ETH ওয়েইতে বিভক্ত, একটি একক টোকেনের মূল্যের 10^-15।

```solidity
উচ্চ খরচ নয়।
```

প্রথম জমার সময় আমরা দুটি টোকেনের আপেক্ষিক মান জানি না, তাই আমরা কেবল পরিমাণগুলি গুণ করি এবং একটি বর্গমূল নিই, ধরে নিই যে আমানত আমাদের উভয় টোকেনে সমান মান সরবরাহ করে।

```solidity
আমরা এটিকে বিশ্বাস করতে পারি কারণ এটি আমানতকারীর স্বার্থে সমান মান সরবরাহ করা, যাতে সালিসি থেকে মান হারানো এড়ানো যায়।
```

ধরা যাক দুটি টোকেনের মান অভিন্ন, কিন্তু আমাদের আমানতকারী **টোকেন0** এর চেয়ে চারগুণ বেশি **টোকেন1** জমা করেছে। একজন ট্রেডার এই সত্যটি ব্যবহার করতে পারে যে পেয়ার এক্সচেঞ্জ মনে করে যে **টোকেন0** এর থেকে মান বের করার জন্য আরও মূল্যবান। এটি কন্ট্র্যাক্টের জন্য এটি প্রতারিত হচ্ছে না তা পরীক্ষা করা সহজ করে তোলে, একটি পরীক্ষা যা কোর কন্ট্র্যাক্টে _হতেই হবে_ (কারণ আমাদের পেরিফেরি কন্ট্র্যাক্ট ছাড়া অন্য সত্তা দ্বারাও কল করা যেতে পারে)।

```solidity
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // reserve{0,1}Adjusted-এর জন্য স্কোপ, স্ট্যাক খুব গভীর ত্রুটি এড়ায়
            uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
            uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
            require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
```

এটি একটি স্যানিটি চেক যা নিশ্চিত করে যে আমরা সোয়াপ থেকে লোকসান করছি না। এমন কোন পরিস্থিতি নেই যেখানে একটি সোয়াপ `reserve0*reserve1` কমাতে পারে। পুলের মান (রিজার্ভ0 + রিজার্ভ1)

```solidity
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }
```

`reserve0` এবং `reserve1` আপডেট করুন, এবং প্রয়োজনে মূল্য সঞ্চয়কারী এবং টাইমস্ট্যাম্প আপডেট করুন এবং একটি ইভেন্ট নির্গত করুন।

##### সিঙ্ক বা স্কিম

256
কন্ট্র্যাক্টের সম্মতি ছাড়া টোকেন তোলার কোনো উপায় নেই, তবে ডিপোজিট একটি ভিন্ন বিষয়। ট্রেডার 8টি **টোকেন0** টোকেন জমা করে, 16টি **টোকেন1** ফেরত পায়

সেক্ষেত্রে দুটি সমাধান আছে:

- `sync`, রিজার্ভগুলিকে বর্তমান ব্যালেন্সে আপডেট করুন
- `skim`, অতিরিক্ত পরিমাণ তুলে নিন। লক্ষ্য করুন যে যেকোনো অ্যাকাউন্ট `skim` কল করার অনুমতিপ্রাপ্ত কারণ আমরা জানি না কে টোকেন জমা করেছে। যেমন আপনি দেখতে পাচ্ছেন, ট্রেডার একটি অতিরিক্ত 8 টোকেন উপার্জন করেছে, যা পুলের মান হ্রাসের কারণে আসে, যা এটির মালিক আমানতকারীকে ক্ষতিগ্রস্ত করে।

```solidity
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
```

### প্রতিটি পরবর্তী জমার সাথে আমরা ইতিমধ্যে দুটি সম্পদের মধ্যে বিনিময় হার জানি এবং আমরা আশা করি লিকুইডিটি প্রদানকারীরা উভয়েই সমান মান সরবরাহ করবে।

তারা যদি তা না করে, আমরা তাদের শাস্তি হিসাবে তারা যে কম মূল্য দিয়েছে তার উপর ভিত্তি করে লিকুইডিটি টোকেন দিই।

```solidity
এটি প্রাথমিক জমা হোক বা পরবর্তী একটি, আমরা যে সংখ্যক লিকুইডিটি টোকেন সরবরাহ করি তা `reserve0*reserve1`-এর পরিবর্তনের বর্গমূলের সমান এবং লিকুইডিটি টোকেনের মান পরিবর্তন হয় না (যদি না আমরা এমন একটি জমা পাই যাতে উভয় প্রকারের সমান মান না থাকে, যে ক্ষেত্রে "জরিমানা" বিতরণ করা হয়)।
```

এখানে একই মানের দুটি টোকেন সহ আরেকটি উদাহরণ দেওয়া হল, যার মধ্যে তিনটি ভাল জমা এবং একটি খারাপ (শুধুমাত্র একটি টোকেন প্রকারের জমা, তাই এটি কোনো লিকুইডিটি টোকেন তৈরি করে না)।
`feeTo` ঠিকানা প্রোটোকল ফি-এর জন্য লিকুইডিটি টোকেন সংগ্রহ করে এবং `feeToSetter` হল সেই ঠিকানা যাকে `feeTo` পরিবর্তন করে একটি ভিন্ন ঠিকানায় மாற்ற অনুমতি দেওয়া হয়েছে।

```solidity
    mapping(address => mapping(address => address)) public getPair;
    address[] public allPairs;
```

এই ভ্যারিয়েবলগুলি পেয়ারগুলির, অর্থাৎ দুটি টোকেন টাইপের মধ্যে এক্সচেঞ্জের ট্র্যাক রাখে।

প্রথমটি, `getPair`, একটি ম্যাপিং যা দুটি ERC-20 টোকেনের উপর ভিত্তি করে একটি পেয়ার এক্সচেঞ্জ কন্ট্র্যাক্ট শনাক্ত করে যা এটি এক্সচেঞ্জ করে। পুল মান (রিজার্ভ0 + রিজার্ভ1) এই জমার জন্য মিন্ট করা লিকুইডিটি টোকেন

মোট লিকুইডিটি টোকেন প্রতিটি লিকুইডিটি টোকেনের মান

দ্রষ্টব্য: আপনি একটি ম্যাপিংয়ের সমস্ত কী-এর উপর পুনরাবৃত্তি করতে না পারার কারণ হল কন্ট্র্যাক্ট ডেটা স্টোরেজ _ব্যয়বহুল_, তাই আমরা যত কম এটি ব্যবহার করি তত ভাল, এবং আমরা যত কম এটি পরিবর্তন করি
তত ভাল। 8.000 বেশিরভাগ অ্যাপ্লিকেশনে আপনার এটির প্রয়োজন নেই।

```solidity
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

16.000 এটিতে টোকেনগুলির ঠিকানা, পেয়ার এক্সচেঞ্জের ঠিকানা এবং ফ্যাক্টরি দ্বারা পরিচালিত এক্সচেঞ্জের মোট সংখ্যা অন্তর্ভুক্ত রয়েছে।

```solidity
    constructor(address _feeToSetter) public {
        feeToSetter = _feeToSetter;
    }
```

2.000 প্রতি প্রকারের চারটি জমা করুন

```solidity
12.000
```

এই ফাংশনটি এক্সচেঞ্জ পেয়ারের সংখ্যা প্রদান করে।

```solidity
144
```

24.000 লক্ষ্য করুন যে যে কেউ এই ফাংশনটি কল করতে পারে। একটি নতুন পেয়ার এক্সচেঞ্জ তৈরি করার জন্য আপনার Uniswap থেকে অনুমতির প্রয়োজন নেই।

```solidity
        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
```

প্রতি প্রকারের দুটি জমা করুন
14.000

```solidity
        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');
        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // একক চেকই যথেষ্ট
```

196 28.000 যদি ইতিমধ্যে একটি এক্সচেঞ্জ থাকে, তবে একই পেয়ারের জন্য আরেকটি তৈরি করার দরকার নেই।

```solidity
        bytes memory bytecode = type(UniswapV2Pair).creationCode;
```

একটি নতুন কন্ট্র্যাক্ট তৈরি করতে আমাদের সেই কোডটি প্রয়োজন যা এটি তৈরি করে (কনস্ট্রাক্টর ফাংশন এবং কোড উভয়ই যা প্রকৃত কন্ট্র্যাক্টের EVM বাইটকোড মেমরিতে লেখে)। অসমান মানের আমানত
18.000 এটি আর কোনো সমস্যা নয়, কারণ [সলিডিটি এখন CREATE2 সমর্থন করে](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2)।

```solidity
252
```

32.000

```solidity
        IUniswapV2Pair(pair).initialize(token0, token1);
```

নতুন এক্সচেঞ্জকে এটি কোন দুটি টোকেন এক্সচেঞ্জ করে তা জানাতে `initialize` ফাংশনটি কল করুন।

```solidity
~2.286
```

সালিসির পরে

```solidity
~15.874
```

এই দুটি ফাংশন `feeSetter`-কে ফি প্রাপককে (যদি থাকে) নিয়ন্ত্রণ করতে এবং `feeSetter`-কে একটি নতুন ঠিকানায় পরিবর্তন করতে অনুমতি দেয়।

### UniswapV2ERC20.sol {#UniswapV2ERC20}

~31.748 এটি [OpenZeppelin ERC-20 কন্ট্র্যাক্টের](/developers/tutorials/erc20-annotated-code) অনুরূপ, তাই আমি শুধুমাত্র ভিন্ন অংশটি ব্যাখ্যা করব, যা হলো `permit` কার্যকারিতা।

ইথেরিয়ামের লেনদেনে ইথার (ETH) খরচ হয়, যা আসল টাকার সমতুল্য। ~2.267         }
require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
_mint(to, liquidity);
অতিরিক্ত লিকুইডিটি টোকেন তৈরি করতে এবং সঠিক অ্যাকাউন্টে দেওয়ার জন্য `UniswapV2ERC20._mint` ফাংশনটি ব্যবহার করুন।
_update(balance0, balance1, _reserve0, _reserve1);
if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
emit Mint(msg.sender, amount0, amount1);
}

```solidity
স্টেট ভেরিয়েবলগুলি আপডেট করুন (`reserve0`, `reserve1`, এবং প্রয়োজনে `kLast`) এবং উপযুক্ত ইভেন্ট নির্গত করুন।
```

বার্ন     // this low-level function should be called from a contract which performs important safety checks
function burn(address to) external lock returns (uint amount0, uint amount1) {

```solidity
এই ফাংশনটি কল করা হয় যখন লিকুইডিটি উত্তোলন করা হয় এবং উপযুক্ত লিকুইডিটি টোকেনগুলি বার্ন করতে হয়।
```

এটিও [একটি পেরিফেরি অ্যাকাউন্ট](#UniswapV2Router02) থেকে কল করা উচিত।         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
address _token0 = token0;                                // gas savings
address _token1 = token1;                                // gas savings
uint balance0 = IERC20(_token0).balanceOf(address(this));
uint balance1 = IERC20(_token1).balanceOf(address(this));
uint liquidity = balanceOf[address(this)]; পেরিফেরি চুক্তিটি কলের আগে বার্ন করার জন্য লিকুইডিটি এই চুক্তিতে স্থানান্তর করেছে। এইভাবে আমরা জানি কতটা লিকুইডিটি বার্ন করতে হবে এবং আমরা নিশ্চিত করতে পারি যে এটি বার্ন হয়।

```solidity
        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
```

লিকুইডিটি প্রদানকারী উভয় টোকেনের সমান মূল্য পায়। এইভাবে আমরা বিনিময় হার পরিবর্তন করি না।         _burn(address(this), liquidity);
_safeTransfer(_token0, to, amount0);
_safeTransfer(_token1, to, amount1);
balance0 = IERC20(_token0).balanceOf(address(this));
balance1 = IERC20(_token1).balanceOf(address(this));```
    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
```

```solidity
বাকি `burn` ফাংশনটি উপরের `mint` ফাংশনের আয়না চিত্র।
```

অদলবদল

```solidity
    // this low-level function should be called from a contract which performs important safety checks
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
```

এই ফাংশনটিও [একটি পেরিফেরি চুক্তি](#UniswapV2Router02) থেকে কল করার কথা।         require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');```
    uint balance0;
    uint balance1;
    { // scope for _token{0,1}, avoids stack too deep errors
```

```solidity
স্থানীয় ভেরিয়েবলগুলি মেমরিতে বা, যদি সেগুলি খুব বেশি না হয়, সরাসরি স্ট্যাকে সংরক্ষণ করা যেতে পারে।
```

আমরা যদি সংখ্যাটি সীমাবদ্ধ করতে পারি যাতে আমরা স্ট্যাক ব্যবহার করি, আমরা কম গ্যাস ব্যবহার করি।

```solidity
আরও বিশদের জন্য [হলুদ কাগজ, আনুষ্ঠানিক Ethereum স্পেসিফিকেশন](https://ethereum.github.io/yellowpaper/paper.pdf), পৃ. 26, সমীকরণ 298 দেখুন।
```

```
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens এই স্থানান্তরটি আশাবাদী, কারণ আমরা নিশ্চিত হওয়ার আগে স্থানান্তর করি যে সমস্ত শর্ত পূরণ হয়েছে।
```

Ethereum-এ এটি ঠিক আছে কারণ যদি কলের পরে শর্তগুলি পূরণ না হয় তবে আমরা এটি থেকে এবং এটি দ্বারা তৈরি সমস্ত পরিবর্তনগুলি থেকে রিভার্ট করি।

```solidity
            if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
```

অনুরোধ করা হলে অদলবদল সম্পর্কে রিসিভারকে অবহিত করুন।

```solidity
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
```

বর্তমান ব্যালেন্সগুলি পান।

## পেরিফেরি চুক্তিটি আমাদের সোয়াপের জন্য কল করার আগে আমাদের টোকেনগুলি পাঠায়।

এটি চুক্তিটিকে এটি প্রতারিত হচ্ছে না তা পরীক্ষা করা সহজ করে তোলে, একটি পরীক্ষা যা _অবশ্যই_ মূল চুক্তিতে ঘটতে হবে (কারণ আমাদের পেরিফেরি চুক্তি ছাড়া অন্য সত্তা দ্বারা কল করা যেতে পারে)।         uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
{ // scope for reserve{0,1}Adjusted, avoids stack too deep errors
uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000\*\*2), 'UniswapV2: K'); অদলবদল থেকে আমরা যাতে হেরে না যাই তা নিশ্চিত করার জন্য এটি একটি স্যানিটি চেক। এমন কোনো পরিস্থিতি নেই যেখানে একটি অদলবদল `reserve0*reserve1` কমাতে পারে। এখানেই আমরা নিশ্চিত করি যে অদলবদলে 0.3% ফি পাঠানো হচ্ছে; K এর মান স্যানিটি চেক করার আগে, আমরা উভয় ব্যালেন্সকে 1000 দ্বারা গুণ করি এবং পরিমাণগুলিকে 3 দ্বারা গুণ করে বিয়োগ করি, এর মানে হল বর্তমান রিজার্ভের K মানের সাথে তার K মান তুলনা করার আগে ব্যালেন্স থেকে 0.3% (3/1000 = 0.003 = 0.3%) কেটে নেওয়া হচ্ছে।

### ```
    }

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

`reserve0` এবং `reserve1` আপডেট করুন, এবং প্রয়োজনে মূল্য সঞ্চয়কারী এবং টাইমস্ট্যাম্প এবং একটি ইভেন্ট নির্গত করুন। সিঙ্ক বা স্কিম

### প্রকৃত ব্যালেন্সগুলি পেয়ার এক্সচেঞ্জের রিজার্ভগুলির সাথে সিঙ্কের বাইরে চলে যাওয়া সম্ভব যা এটি মনে করে।

চুক্তির সম্মতি ছাড়া টোকেন উত্তোলনের কোনো উপায় নেই, তবে আমানত একটি ভিন্ন বিষয়।
একটি অ্যাকাউন্ট `mint` বা `swap` কল না করেই এক্সচেঞ্জে টোকেন স্থানান্তর করতে পারে।

```solidity
সেক্ষেত্রে দুটি সমাধান আছে:
```

`sync`, বর্তমান ব্যালেন্সে রিজার্ভ আপডেট করুন `skim`, অতিরিক্ত পরিমাণ উত্তোলন করুন। নোট করুন যে কোনো অ্যাকাউন্টকে `skim` কল করার অনুমতি দেওয়া হয়েছে কারণ আমরা জানি না কে টোকেন জমা করেছে। এই তথ্যটি একটি ইভেন্টে নির্গত হয়, তবে ইভেন্টগুলি ব্লকচেইন থেকে অ্যাক্সেসযোগ্য নয়।     // force balances to match reserves
function skim(address to) external lock {
address _token0 = token0; // gas savings
address _token1 = token1; // gas savings
_safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
_safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
}```
// force reserves to match balances
function sync() external lock {
    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
}
```} UniswapV2Factory.sol {#UniswapV2Factory} [এই চুক্তিটি](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Factory.sol) পেয়ার এক্সচেঞ্জ তৈরি করে।

```solidity
pragma solidity =0.5.16;

import './interfaces/IUniswapV2Factory.sol';
import './UniswapV2Pair.sol';

contract UniswapV2Factory is IUniswapV2Factory {
    address public feeTo;
    address public feeToSetter;
```

প্রোটোকল ফি বাস্তবায়নের জন্য এই স্টেট ভেরিয়েবলগুলি প্রয়োজনীয় ([হোয়াইটপেপার](https://app.uniswap.org/whitepaper.pdf), পৃ. 5 দেখুন)। `feeTo` ঠিকানাটি প্রোটোকল ফি-এর জন্য লিকুইডিটি টোকেন জমা করে এবং `feeToSetter` হল সেই ঠিকানা যা `feeTo`-কে একটি ভিন্ন ঠিকানায় পরিবর্তন করার অনুমতি দেয়।     mapping(address => mapping(address => address)) public getPair;
address[] public allPairs;

```solidity
এই ভেরিয়েবলগুলি পেয়ারগুলির ট্র্যাক রাখে, দুটি টোকেন প্রকারের মধ্যে বিনিময়।
```

প্রথমটি, `getPair`, একটি ম্যাপিং যা দুটি ERC-20 টোকেনের উপর ভিত্তি করে একটি পেয়ার এক্সচেঞ্জ চুক্তি শনাক্ত করে যা এটি বিনিময় করে।

```solidity
ERC-20 টোকেনগুলি তাদের প্রয়োগকারী চুক্তিগুলির ঠিকানা দ্বারা শনাক্ত করা হয়, তাই কী এবং মান সবই ঠিকানা।
```

`tokenA` থেকে `tokenB`-তে রূপান্তর করতে দেয় এমন পেয়ার এক্সচেঞ্জের ঠিকানা পেতে, আপনি `getPair[<tokenA address>][<tokenB address>]` (অথবা অন্যভাবে) ব্যবহার করেন।

```solidity
দ্বিতীয় ভেরিয়েবল, `allPairs`, একটি অ্যারে যা এই ফ্যাক্টরি দ্বারা তৈরি পেয়ার এক্সচেঞ্জের সমস্ত ঠিকানা অন্তর্ভুক্ত করে।
```

Ethereum-এ আপনি একটি ম্যাপিংয়ের বিষয়বস্তুর উপর পুনরাবৃত্তি করতে পারবেন না, বা সমস্ত কী-এর একটি তালিকা পেতে পারবেন না, তাই এই ভেরিয়েবলটিই একমাত্র উপায় যা জানতে পারে যে এই ফ্যাক্টরি কোন এক্সচেঞ্জগুলি পরিচালনা করে। নোট: আপনি একটি ম্যাপিংয়ের সমস্ত কী-এর উপর পুনরাবৃত্তি করতে না পারার কারণ হল চুক্তির ডেটা স্টোরেজ _ব্যয়বহুল_, তাই আমরা যত কম এটি ব্যবহার করি তত ভাল, এবং যত কম আমরা এটি পরিবর্তন করি তত ভাল।

#### আপনি [পুনরাবৃত্তি সমর্থন করে এমন ম্যাপিং তৈরি করতে পারেন](https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol), তবে তাদের কী-এর একটি তালিকার জন্য অতিরিক্ত স্টোরেজ প্রয়োজন।

বেশিরভাগ অ্যাপ্লিকেশনে আপনার এটির প্রয়োজন নেই।

```solidity
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);
```

এই ইভেন্টটি নির্গত হয় যখন একটি নতুন পেয়ার এক্সচেঞ্জ তৈরি হয়।

```solidity
এতে টোকেনের ঠিকানা, পেয়ার এক্সচেঞ্জের ঠিকানা এবং ফ্যাক্টরি দ্বারা পরিচালিত মোট এক্সচেঞ্জের সংখ্যা অন্তর্ভুক্ত রয়েছে।
```

```
constructor(address _feeToSetter) public {
    feeToSetter = _feeToSetter;
}
```

```solidity
কনস্ট্রাক্টর শুধুমাত্র `feeToSetter` নির্দিষ্ট করে।
```

ফ্যাক্টরিগুলি কোনো ফি ছাড়াই শুরু হয় এবং শুধুমাত্র `feeSetter` এটি পরিবর্তন করতে পারে।     function allPairsLength() external view returns (uint) {
return allPairs.length;
}

```solidity
এই ফাংশনটি এক্সচেঞ্জ পেয়ারের সংখ্যা ফেরত দেয়।
```

```
function createPair(address tokenA, address tokenB) external returns (address pair) { এটি ফ্যাক্টরির প্রধান কাজ, দুটি ERC-20 টোকেনের মধ্যে একটি পেয়ার এক্সচেঞ্জ তৈরি করা। নোট করুন যে যে কেউ এই ফাংশনটি কল করতে পারে।
```

একটি নতুন পেয়ার এক্সচেঞ্জ তৈরি করার জন্য আপনার Uniswap থেকে অনুমতির প্রয়োজন নেই।         require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');
(address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);

আমরা চাই নতুন এক্সচেঞ্জের ঠিকানাটি ডিটারমিনিস্টিক হোক, তাই এটি অফচেইনে আগে থেকে গণনা করা যেতে পারে (এটি [লেয়ার 2 লেনদেন](/developers/docs/scaling/)-এর জন্য দরকারী হতে পারে)।

| প্যারামিটার                                                                                                                                                            |                                                                                                                                                                                                                                                                              মান |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| বড় লিকুইডিটি পুলগুলি ছোটগুলির চেয়ে ভাল, কারণ তাদের দাম আরও স্থিতিশীল।                                                                                                |                                                                                                                                                                                                                   আমরা প্রতি জোড়া টোকেনের জন্য একটির বেশি লিকুইডিটি পুল চাই না। |
| যদি ইতিমধ্যে একটি এক্সচেঞ্জ থাকে, তবে একই পেয়ারের জন্য আরেকটি তৈরি করার দরকার নেই।                                                                                     |                                                                                                                                                                                                                   আমরা প্রতি জোড়া টোকেনের জন্য একটির বেশি লিকুইডিটি পুল চাই না। |
| একটি নতুন চুক্তি তৈরি করতে আমাদের সেই কোডটি প্রয়োজন যা এটি তৈরি করে (কনস্ট্রাক্টর ফাংশন এবং কোড উভয়ই যা প্রকৃত চুক্তির EVM বাইটকোড মেমরিতে লেখে)। | সাধারণত Solidity-তে আমরা কেবল `addr = new <name of contract>(<constructor parameters>)` ব্যবহার করি এবং কম্পাইলার আমাদের জন্য সবকিছু যত্ন নেয়, কিন্তু একটি ডিটারমিনিস্টিক চুক্তির ঠিকানা পেতে আমাদের [CREATE2 অপকোড](https://eips.ethereum.org/EIPS/eip-1014) ব্যবহার করতে হবে। |
| এই কোডটি যখন লেখা হয়েছিল তখন সেই অপকোডটি এখনও Solidity দ্বারা সমর্থিত ছিল না, তাই ম্যানুয়ালি কোডটি পেতে হয়েছিল।                                                     |                                                                                                               এটি আর কোনো সমস্যা নয়, কারণ [Solidity এখন CREATE2 সমর্থন করে](https://docs.soliditylang.org/en/v0.8.3/control-structures.html#salted-contract-creations-create2)। |

```
    bytes32 salt = keccak256(abi.encodePacked(token0, token1));
    assembly {
        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
    } যখন একটি অপকোড এখনও Solidity দ্বারা সমর্থিত নয় তখন আমরা এটিকে [ইনলাইন অ্যাসেম্বলি](https://docs.soliditylang.org/en/v0.8.3/assembly.html) ব্যবহার করে কল করতে পারি।
```

```
    IUniswapV2Pair(pair).initialize(token0, token1); নতুন এক্সচেঞ্জকে এটি কোন দুটি টোকেন বিনিময় করে তা বলার জন্য `initialize` ফাংশনটি কল করুন।
```

```solidity
        getPair[token0][token1] = pair;
        getPair[token1][token0] = pair; // populate mapping in the reverse direction
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }
```

স্টেট ভেরিয়েবলগুলিতে নতুন পেয়ারের তথ্য সংরক্ষণ করুন এবং নতুন পেয়ার এক্সচেঞ্জ সম্পর্কে বিশ্বকে অবহিত করার জন্য একটি ইভেন্ট নির্গত করুন।

```solidity
    function setFeeTo(address _feeTo) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeTo = _feeTo;
    }

    function setFeeToSetter(address _feeToSetter) external {
        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');
        feeToSetter = _feeToSetter;
    }
}
```

এই দুটি ফাংশন `feeSetter`-কে ফি প্রাপক (যদি থাকে) নিয়ন্ত্রণ করতে এবং `feeSetter`-কে একটি নতুন ঠিকানায় পরিবর্তন করতে দেয়।

```solidity
UniswapV2ERC20.sol {#UniswapV2ERC20}
```

[এই চুক্তিটি](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol) ERC-20 লিকুইডিটি টোকেন প্রয়োগ করে।

```solidity
এটি [OpenZeppelin ERC-20 চুক্তি](/developers/tutorials/erc20-annotated-code)-এর অনুরূপ, তাই আমি কেবল সেই অংশটি ব্যাখ্যা করব যা ভিন্ন, `permit` কার্যকারিতা।
```

Ethereum-এ লেনদেনের জন্য ইথার (ETH) খরচ হয়, যা প্রকৃত অর্থের সমতুল্য। আপনার কাছে যদি ERC-20 টোকেন থাকে কিন্তু ETH না থাকে, তাহলে আপনি লেনদেন পাঠাতে পারবেন না, তাই আপনি সেগুলি দিয়ে কিছুই করতে পারবেন না।

```solidity
এই সমস্যা এড়ানোর একটি সমাধান হল [মেটা-লেনদেন](https://docs.uniswap.org/contracts/v2/guides/smart-contract-integration/supporting-meta-transactions)।
```

টোকেনের মালিক একটি লেনদেনে স্বাক্ষর করেন যা অন্য কাউকে অফচেইনে টোকেন উত্তোলন করতে দেয় এবং এটি ইন্টারনেটের মাধ্যমে প্রাপকের কাছে পাঠায়। প্রাপক, যার কাছে ETH আছে, তারপর মালিকের পক্ষ থেকে পারমিট জমা দেয়।

```solidity
    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
```

এই হ্যাসটি [লেনদেনের প্রকারের জন্য শনাক্তকারী](https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash)।

```solidity
আমরা এখানে শুধুমাত্র `Permit` সমর্থন করি এই প্যারামিটারগুলির সাথে।
```

```
mapping(address => uint) public nonces; একজন প্রাপকের পক্ষে ডিজিটাল স্বাক্ষর জাল করা সম্ভব নয়। তবে, একই লেনদেন দুবার পাঠানো তুচ্ছ (এটি [রিপ্লে অ্যাটাক](https://wikipedia.org/wiki/Replay_attack)-এর একটি রূপ)।
```

এটি প্রতিরোধ করতে, আমরা একটি [নন্স](https://wikipedia.org/wiki/Cryptographic_nonce) ব্যবহার করি। যদি একটি নতুন `Permit`-এর নন্স শেষ ব্যবহৃতটির চেয়ে এক বেশি না হয়, আমরা ধরে নিই এটি অবৈধ।     constructor() public {
uint chainId;
assembly {
chainId := chainid
} এটি [চেইন শনাক্তকারী](https://chainid.network/) পুনরুদ্ধার করার কোড। এটি [Yul](https://docs.soliditylang.org/en/v0.8.4/yul.html) নামে একটি EVM অ্যাসেম্বলি উপভাষা ব্যবহার করে। নোট করুন যে Yul-এর বর্তমান সংস্করণে আপনাকে `chainid()` ব্যবহার করতে হবে, `chainid` নয়।

```
    DOMAIN_SEPARATOR = keccak256(
        abi.encode(
            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
            keccak256(bytes(name)),
            keccak256(bytes('1')),
            chainId,
            address(this)
        )
    );
}
```

EIP-712-এর জন্য [ডোমেন বিভাজক](https://eips.ethereum.org/EIPS/eip-712#rationale-for-domainseparator) গণনা করুন।     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {

```solidity
এই ফাংশনটি অনুমতিগুলি বাস্তবায়ন করে।
```

এটি প্যারামিটার হিসাবে প্রাসঙ্গিক ক্ষেত্রগুলি এবং [স্বাক্ষরের](https://yos.io/2018/11/16/ethereum-signatures/) জন্য তিনটি স্কেলার মান (v, r, এবং s) গ্রহণ করে।         require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');

।         bytes32 digest = keccak256(
abi.encodePacked(
'\x19\x01',
DOMAIN_SEPARATOR,
keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
)
); `abi.encodePacked(...)` হল সেই বার্তা যা আমরা পাওয়ার আশা করি।

```solidity
আমরা জানি নন্সটি কী হওয়া উচিত, তাই আমাদের এটি প্যারামিটার হিসাবে পাওয়ার প্রয়োজন নেই।
```

Ethereum স্বাক্ষর অ্যালগরিদম স্বাক্ষর করার জন্য 256 বিট পাওয়ার আশা করে, তাই আমরা `keccak256` হ্যাস ফাংশন ব্যবহার করি।         address recoveredAddress = ecrecover(digest, v, r, s);

```solidity
ডাইজেস্ট এবং স্বাক্ষর থেকে আমরা সেই ঠিকানাটি পেতে পারি যা এটি [ecrecover](https://coders-errand.com/ecrecover-signature-verification-ethereum/) ব্যবহার করে স্বাক্ষর করেছে।
```

```
    require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
    _approve(owner, spender, value);
}
```

```solidity
যদি সবকিছু ঠিক থাকে, এটিকে [একটি ERC-20 অনুমোদন](https://eips.ethereum.org/EIPS/eip-20#approve) হিসাবে বিবেচনা করুন।
```

পেরিফেরি চুক্তি {#periphery-contracts} পেরিফেরি চুক্তিগুলি হল Uniswap-এর জন্য API (অ্যাপ্লিকেশন প্রোগ্রাম ইন্টারফেস)।

```solidity
এগুলি অন্যান্য চুক্তি বা বিকেন্দ্রীভূত অ্যাপ্লিকেশন থেকে বাহ্যিক কলের জন্য উপলব্ধ।
```

আপনি সরাসরি মূল চুক্তিগুলিকে কল করতে পারেন, তবে এটি আরও জটিল এবং আপনি যদি ভুল করেন তবে আপনি মান হারাতে পারেন। মূল চুক্তিগুলিতে কেবল এটি নিশ্চিত করার জন্য পরীক্ষা রয়েছে যে সেগুলি প্রতারিত হচ্ছে না, অন্য কারো জন্য স্যানিটি চেক নয়। এগুলি পেরিফেরিতে রয়েছে যাতে প্রয়োজন অনুসারে সেগুলি আপডেট করা যায়।

```solidity
UniswapV2Router01.sol {#UniswapV2Router01}
```

[এই চুক্তিটিতে](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol) সমস্যা রয়েছে এবং [আর ব্যবহার করা উচিত নয়](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-01)। ভাগ্যক্রমে, পেরিফেরি চুক্তিগুলি স্টেটলেস এবং কোনো সম্পদ ধারণ করে না, তাই এটিকে অবমূল্যায়ন করা এবং লোকদের পরিবর্তে প্রতিস্থাপন, `UniswapV2Router02` ব্যবহার করার পরামর্শ দেওয়া সহজ। UniswapV2Router02.sol {#UniswapV2Router02}

```solidity
বেশিরভাগ ক্ষেত্রে আপনি [এই চুক্তির](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router02.sol) মাধ্যমে Uniswap ব্যবহার করবেন।
```

আপনি এটি কীভাবে ব্যবহার করবেন তা [এখানে](https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02) দেখতে পারেন।

#### pragma solidity =0.6.6;import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol';&#xA;import '@uniswap/lib/contracts/libraries/TransferHelper.sol';import './interfaces/IUniswapV2Router02.sol';&#xA;import './libraries/UniswapV2Library.sol';&#xA;import './libraries/SafeMath.sol';&#xA;import './interfaces/IERC20.sol';&#xA;import './interfaces/IWETH.sol';

এগুলির বেশিরভাগই আমরা হয় আগে সম্মুখীন হয়েছি, অথবা মোটামুটি স্পষ্ট।

```solidity
একমাত্র ব্যতিক্রম হল `IWETH.sol`।
```

Uniswap v2 যেকোনো জোড়া ERC-20 টোকেনের জন্য বিনিময় অনুমোদন করে, কিন্তু ইথার (ETH) নিজে একটি ERC-20 টোকেন নয়। এটি স্ট্যান্ডার্ডের পূর্ববর্তী এবং অনন্য প্রক্রিয়া দ্বারা স্থানান্তরিত হয়।

```solidity
ERC-20 টোকেনগুলিতে প্রযোজ্য চুক্তিগুলিতে ETH ব্যবহার সক্ষম করতে লোকেরা [র‍্যাপড ইথার (WETH)](https://weth.tkn.eth.limo/) চুক্তি নিয়ে এসেছিল।
```

আপনি এই চুক্তিতে ETH পাঠান এবং এটি আপনাকে সমপরিমাণ WETH মিন্ট করে দেয়।

```solidity
অথবা আপনি WETH বার্ন করে ETH ফেরত পেতে পারেন।
```

contract UniswapV2Router02 is IUniswapV2Router02 {
using SafeMath for uint;```
address public immutable override factory;
address public immutable override WETH; রাউটারকে জানতে হবে কোন ফ্যাক্টরি ব্যবহার করতে হবে, এবং WETH প্রয়োজন এমন লেনদেনের জন্য কোন WETH চুক্তি ব্যবহার করতে হবে।
```

```solidity
এই মানগুলি [অপরিবর্তনীয়](https://docs.soliditylang.org/en/v0.8.3/contracts.html#constant-and-immutable-state-variables), যার মানে হল সেগুলি কেবল কনস্ট্রাক্টরে সেট করা যেতে পারে।
```

এটি ব্যবহারকারীদের আত্মবিশ্বাস দেয় যে কেউ সেগুলি পরিবর্তন করে কম সৎ চুক্তিতে নির্দেশ করতে পারবে না।

```solidity
    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }
```

এই মোডিফায়ারটি নিশ্চিত করে যে সময়-সীমিত লেনদেনগুলি ("সময় Y-এর আগে X করুন যদি আপনি পারেন") তাদের সময়সীমার পরে না ঘটে।

```solidity
    constructor(address _factory, address _WETH) public {
        factory = _factory;
        WETH = _WETH;
    }
```

কনস্ট্রাক্টর কেবল অপরিবর্তনীয় স্টেট ভেরিয়েবল সেট করে।

```solidity
    receive() external payable {
        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
    }
```

এই ফাংশনটি কল করা হয় যখন আমরা WETH চুক্তি থেকে টোকেনগুলিকে ETH-এ রিডিম করি।

```solidity
শুধুমাত্র আমরা যে WETH চুক্তি ব্যবহার করি তা এটি করার জন্য অনুমোদিত।
```

লিকুইডিটি যোগ করুন {#add-liquidity} এই ফাংশনগুলি পেয়ার এক্সচেঞ্জে টোকেন যোগ করে, যা লিকুইডিটি পুল বাড়ায়।

```solidity

    // **** ADD LIQUIDITY ****
    function _addLiquidity(
```

এই ফাংশনটি A এবং B টোকেনের পরিমাণ গণনা করতে ব্যবহৃত হয় যা পেয়ার এক্সচেঞ্জে জমা করা উচিত।

#### ```
    address tokenA,
    address tokenB,
```

```solidity
এগুলি হল ERC-20 টোকেন চুক্তির ঠিকানা।
```

```
    uint amountADesired,
    uint amountBDesired,
```

```solidity
এগুলি হল সেই পরিমাণ যা লিকুইডিটি প্রদানকারী জমা করতে চায়।
```

এগুলি হল A এবং B-এর সর্বোচ্চ পরিমাণ যা জমা করা হবে।         uint amountAMin,
uint amountBMin এগুলি হল জমার জন্য ন্যূনতম গ্রহণযোগ্য পরিমাণ। যদি লেনদেন এই পরিমাণ বা তার বেশি দিয়ে না করা যায়, তাহলে এটি থেকে রিভার্ট করুন। আপনি যদি এই বৈশিষ্ট্যটি না চান, তবে কেবল শূন্য নির্দিষ্ট করুন।

লিকুইডিটি প্রদানকারীরা সাধারণত একটি ন্যূনতম নির্দিষ্ট করে, কারণ তারা লেনদেনটিকে বর্তমানের কাছাকাছি একটি বিনিময় হারে সীমাবদ্ধ করতে চায়। যদি বিনিময় হার খুব বেশি ওঠানামা করে তবে এর অর্থ হতে পারে এমন খবর যা অন্তর্নিহিত মানগুলিকে পরিবর্তন করে এবং তারা ম্যানুয়ালি সিদ্ধান্ত নিতে চায় কী করতে হবে।

1. উদাহরণস্বরূপ, এমন একটি ঘটনা কল্পনা করুন যেখানে বিনিময় হার এক-এক এবং লিকুইডিটি প্রদানকারী এই মানগুলি নির্দিষ্ট করে:
2. একজন ট্রেডার 24.695 A টোকেন বিক্রি করে এবং 25.305 B টোকেন পায়।
3. ট্রেডার 24.695 B টোকেন বিক্রি করে 25.305 C টোকেন পায়, এবং লাভ হিসাবে প্রায় 0.61 B টোকেন রাখে।
4. amountADesired 1000

| amountBDesired | A-B এক্সচেঞ্জ                                                                      | amountAMin                                                                                          | 900                                                                                                            |
| -------------- | ---------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| 1              | 800                                                                                | যতক্ষণ বিনিময় হার 0.9 এবং 1.25 এর মধ্যে থাকে, ততক্ষণ লেনদেন ঘটে।   | যদি বিনিময় হার সেই পরিসরের বাইরে চলে যায়, তাহলে লেনদেন বাতিল হয়ে যায়।                                      |
| 2              | জমা এবং অন্তর্ভুক্তির মধ্যবর্তী ব্যবধানে কী ঘটে তা আপনি নিয়ন্ত্রণ করতে পারবেন না। | যতক্ষণ বিনিময় হার 0.9 এবং 1.25 এর মধ্যে থাকে, ততক্ষণ লেনদেন ঘটে।   | যদি বিনিময় হার সেই পরিসরের বাইরে চলে যায়, তাহলে লেনদেন বাতিল হয়ে যায়।                                      |
| 3              | জমা এবং অন্তর্ভুক্তির মধ্যবর্তী ব্যবধানে কী ঘটে তা আপনি নিয়ন্ত্রণ করতে পারবেন না। | ```
    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
``` | যদি বিনিময় হার সেই পরিসরের বাইরে চলে যায়, তাহলে লেনদেন বাতিল হয়ে যায়।                                      |
| 4              | জমা এবং অন্তর্ভুক্তির মধ্যবর্তী ব্যবধানে কী ঘটে তা আপনি নিয়ন্ত্রণ করতে পারবেন না। | ```
    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
``` | ```
    } else {
        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
``` |

```solidity
যদি আমাদের দেখতে হয় কোন পরিমাণ হবে, আমরা [এই ফাংশনটি](https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol#L35) ব্যবহার করে সর্বোত্তম পরিমাণ পাই।
```

আমরা বর্তমান রিজার্ভের মতো একই অনুপাত চাই।

```solidity
            if (amountBOptimal <= amountBDesired) {
                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
                (amountA, amountB) = (amountADesired, amountBOptimal);
```

যদি `amountBOptimal` লিকুইডিটি প্রদানকারী যা জমা করতে চায় তার চেয়ে কম হয় তবে এর মানে হল টোকেন B বর্তমানে লিকুইডিটি আমানতকারীর ধারণার চেয়ে বেশি মূল্যবান, তাই কম পরিমাণ প্রয়োজন।

```solidity
            } else {
                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
                assert(amountAOptimal <= amountADesired);
                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
                (amountA, amountB) = (amountAOptimal, amountBDesired);
```

যদি সর্বোত্তম B পরিমাণ কাঙ্খিত B পরিমাণের চেয়ে বেশি হয় তবে এর মানে হল B টোকেনগুলি বর্তমানে লিকুইডিটি আমানতকারীর ধারণার চেয়ে কম মূল্যবান, তাই উচ্চ পরিমাণ প্রয়োজন। তবে, কাঙ্খিত পরিমাণ একটি সর্বোচ্চ, তাই আমরা তা করতে পারি না। পরিবর্তে আমরা B টোকেনের কাঙ্খিত পরিমাণের জন্য সর্বোত্তম সংখ্যক A টোকেন গণনা করি।

```solidity
সবকিছু একসাথে করে আমরা এই গ্রাফটি পাই।
```

ধরে নিন আপনি এক হাজার A টোকেন (নীল রেখা) এবং এক হাজার B টোকেন (লাল রেখা) জমা করার চেষ্টা করছেন। x অক্ষ হল বিনিময় হার, A/B।

```solidity
যদি x=1 হয়, তবে তারা মূল্যে সমান এবং আপনি প্রতিটির এক হাজার জমা করেন।
```

যদি x=2 হয়, A এর মান B এর দ্বিগুণ (আপনি প্রতিটি A টোকেনের জন্য দুটি B টোকেন পান) তাই আপনি এক হাজার B টোকেন জমা করেন, কিন্তু কেবল 500 A টোকেন।

```solidity
যদি x=0.5 হয়, পরিস্থিতি বিপরীত হয়, এক হাজার A টোকেন এবং পাঁচশত B টোকেন।
```

![Graph](liquidityProviderDeposit.png) আপনি সরাসরি মূল চুক্তিতে লিকুইডিটি জমা করতে পারেন ([UniswapV2Pair::mint](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2Pair.sol#L110) ব্যবহার করে), কিন্তু মূল চুক্তি কেবল এটি নিশ্চিত করে যে এটি নিজে প্রতারিত হচ্ছে না, তাই আপনি যদি আপনার লেনদেন জমা দেওয়ার সময় এবং এটি কার্যকর হওয়ার সময়ের মধ্যে বিনিময় হার পরিবর্তিত হয় তবে আপনি মান হারানোর ঝুঁকিতে থাকেন।

আপনি যদি পেরিফেরি চুক্তি ব্যবহার করেন, এটি আপনার জমা করার পরিমাণ নির্ধারণ করে এবং অবিলম্বে এটি জমা করে, তাই বিনিময় হার পরিবর্তিত হয় না এবং আপনি কিছুই হারান না।     function addLiquidity(
address tokenA,
address tokenB,
uint amountADesired,
uint amountBDesired,
uint amountAMin,
uint amountBMin,
address to,
uint deadline এই ফাংশনটি একটি লেনদেন দ্বারা লিকুইডিটি জমা করার জন্য কল করা যেতে পারে। বেশিরভাগ প্যারামিটার উপরের `_addLiquidity`-এর মতোই, দুটি ব্যতিক্রম ছাড়া:

`uint` বা `address`-এর মতো স্কেলার প্রকারের সাথে কম্পাইলার আমাদের জন্য সংগ্রহস্থলের পছন্দটি পরিচালনা করে, কিন্তু অ্যারেগুলির সাথে, যা দীর্ঘ এবং আরও ব্যয়বহুল, আমরা ব্যবহৃত সংগ্রহস্থলের ধরনটি নির্দিষ্ট করি।

```solidity
`to` হল সেই ঠিকানা যা পুলের লিকুইডিটি প্রদানকারীর অংশ দেখানোর জন্য মিন্ট করা নতুন লিকুইডিটি টোকেন পায়
।
```

`deadline` হল লেনদেনের উপর একটি সময়সীমা

```solidity
    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
```

আমরা প্রকৃতপক্ষে জমা করার পরিমাণ গণনা করি এবং তারপর লিকুইডিটি পুলের ঠিকানা খুঁজে বের করি। গ্যাস বাঁচাতে আমরা এটি ফ্যাক্টরিকে জিজ্ঞাসা করে করি না, বরং লাইব্রেরি ফাংশন `pairFor` (লাইব্রেরিতে নীচে দেখুন) ব্যবহার করি

```solidity
        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
```

ব্যবহারকারী থেকে পেয়ার এক্সচেঞ্জে টোকেনের সঠিক পরিমাণ স্থানান্তর করুন।         liquidity = IUniswapV2Pair(pair).mint(to);
}

```solidity
বিনিময়ে `to` ঠিকানাকে পুলের আংশিক মালিকানার জন্য লিকুইডিটি টোকেন দিন।
```

মূল চুক্তির `mint` ফাংশনটি দেখে যে তার কাছে কতগুলি অতিরিক্ত টোকেন রয়েছে (শেষবার লিকুইডিটি পরিবর্তিত হওয়ার সময়ের তুলনায়) এবং সেই অনুযায়ী লিকুইডিটি মিন্ট করে।     function addLiquidityETH(
address token,
uint amountTokenDesired,

যখন একজন লিকুইডিটি প্রদানকারী একটি টোকেন/ETH পেয়ার এক্সচেঞ্জে লিকুইডিটি সরবরাহ করতে চায়, তখন কয়েকটি পার্থক্য থাকে।

```solidity
চুক্তিটি লিকুইডিটি প্রদানকারীর জন্য ETH র‍্যাপ করার কাজটি করে।
```

ব্যবহারকারী কত ETH জমা করতে চায় তা নির্দিষ্ট করার প্রয়োজন নেই, কারণ ব্যবহারকারী কেবল লেনদেনের সাথে সেগুলি পাঠায় (`msg.value`-তে পরিমাণ উপলব্ধ)।         uint amountTokenMin,
uint amountETHMin,
address to,
uint deadline
) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
(amountToken, amountETH) = _addLiquidity(
token,
WETH,
amountTokenDesired,
msg.value,
amountTokenMin,
amountETHMin
);
address pair = UniswapV2Library.pairFor(factory, token, WETH);
TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
IWETH(WETH).deposit{value: amountETH}();
assert(IWETH(WETH).transfer(pair, amountETH));

```solidity
ETH জমা করার জন্য চুক্তিটি প্রথমে এটিকে WETH-এ র‍্যাপ করে এবং তারপর WETH-টিকে পেয়ারে স্থানান্তর করে।
```

লক্ষ্য করুন যে স্থানান্তরটি একটি `assert`-এ মোড়ানো আছে।

```solidity
এর মানে হল যদি স্থানান্তর ব্যর্থ হয় তবে এই চুক্তি কলটিও ব্যর্থ হয় এবং তাই র‍্যাপিংটি আসলে ঘটে না।
```

```
    liquidity = IUniswapV2Pair(pair).mint(to);
    // refund dust eth, if any
    if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
} ব্যবহারকারী ইতিমধ্যে আমাদের ETH পাঠিয়েছে, তাই যদি কোনো অতিরিক্ত বাকি থাকে (কারণ অন্য টোকেনটি ব্যবহারকারীর ধারণার চেয়ে কম মূল্যবান), আমাদের একটি ফেরত জারি করতে হবে।
```

লিকুইডিটি সরান {#remove-liquidity} এই ফাংশনগুলি লিকুইডিটি সরিয়ে ফেলবে এবং লিকুইডিটি প্রদানকারীকে ফেরত দেবে।

```solidity
    // **** REMOVE LIQUIDITY ****
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {
```

লিকুইডিটি সরানোর সবচেয়ে সহজ উপায়।

```solidity
লিকুইডিটি প্রদানকারী প্রতিটি টোকেনের একটি ন্যূনতম পরিমাণ গ্রহণ করতে সম্মত হয় এবং এটি সময়সীমার আগে ঘটতে হবে।
```

```
    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
```

### মূল চুক্তির `burn` ফাংশনটি ব্যবহারকারীকে টোকেন ফেরত দেওয়ার কাজটি করে।

```
    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB); যখন একটি ফাংশন একাধিক মান ফেরত দেয়, কিন্তু আমরা কেবল তাদের মধ্যে কয়েকটিতে আগ্রহী, তখন আমরা কেবল সেই মানগুলি পাই।
```

## এটি একটি মান পড়া এবং এটি কখনই ব্যবহার না করার চেয়ে গ্যাস খরচের দিক থেকে কিছুটা সস্তা।

```
    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
```

### মূল চুক্তি যেভাবে পরিমাণগুলি ফেরত দেয় (প্রথমে নিম্ন ঠিকানার টোকেন) তা থেকে ব্যবহারকারী যেভাবে সেগুলি আশা করে ( `tokenA` এবং `tokenB`-এর সাথে সঙ্গতিপূর্ণ) তা অনুবাদ করুন।

```
    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
}
```

```solidity
প্রথমে স্থানান্তর করা এবং তারপর এটি বৈধ কিনা তা যাচাই করা ঠিক আছে, কারণ যদি তা না হয় তবে আমরা সমস্ত স্টেট পরিবর্তনগুলি থেকে রিভার্ট করব।
```

```
function removeLiquidityETH(
    address token,
    uint liquidity,
    uint amountTokenMin,
    uint amountETHMin,
    address to,
    uint deadline
) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {
    (amountToken, amountETH) = removeLiquidity(
        token,
        WETH,
        liquidity,
        amountTokenMin,
        amountETHMin,
        address(this),
        deadline
    );
    TransferHelper.safeTransfer(token, to, amountToken);
    IWETH(WETH).withdraw(amountETH);
    TransferHelper.safeTransferETH(to, amountETH);
}
```

```solidity
ETH-এর জন্য লিকুইডিটি সরানো প্রায় একই, তবে আমরা WETH টোকেনগুলি গ্রহণ করি এবং তারপর সেগুলিকে ETH-এর জন্য রিডিম করে লিকুইডিটি প্রদানকারীকে ফেরত দিই।
```

```
function removeLiquidityWithPermit(
    address tokenA,
    address tokenB,
    uint liquidity,
    uint amountAMin,
    uint amountBMin,
    address to,
    uint deadline,
    bool approveMax, uint8 v, bytes32 r, bytes32 s
) external virtual override returns (uint amountA, uint amountB) {
    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
    uint value = approveMax ? uint(-1) : liquidity;
    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
    (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);
}


function removeLiquidityETHWithPermit(
    address token,
    uint liquidity,
    uint amountTokenMin,
    uint amountETHMin,
    address to,
    uint deadline,
    bool approveMax, uint8 v, bytes32 r, bytes32 s
) external virtual override returns (uint amountToken, uint amountETH) {
    address pair = UniswapV2Library.pairFor(factory, token, WETH);
    uint value = approveMax ? uint(-1) : liquidity;
    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
    (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);
} এই ফাংশনগুলি মেটা-লেনদেন রিলে করে যাতে ইথারবিহীন ব্যবহারকারীরা পুল থেকে উত্তোলন করতে পারে, [পারমিট মেকানিজম](#UniswapV2ERC20) ব্যবহার করে। 
// **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****
function removeLiquidityETHSupportingFeeOnTransferTokens(
    address token,
    uint liquidity,
    uint amountTokenMin,
    uint amountETHMin,
    address to,
    uint deadline
) public virtual override ensure(deadline) returns (uint amountETH) {
    (, amountETH) = removeLiquidity(
        token,
        WETH,
        liquidity,
        amountTokenMin,
        amountETHMin,
        address(this),
        deadline
    );
    TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
    IWETH(WETH).withdraw(amountETH);
    TransferHelper.safeTransferETH(to, amountETH);
}
```

```solidity
এই ফাংশনটি স্থানান্তর বা স্টোরেজ ফি সহ টোকেনগুলির জন্য ব্যবহার করা যেতে পারে।
```

যখন একটি টোকেনের এমন ফি থাকে তখন আমরা `removeLiquidity` ফাংশনের উপর নির্ভর করতে পারি না যে আমরা টোকেনটির কতটা ফেরত পাব, তাই আমাদের প্রথমে উত্তোলন করতে হবে এবং তারপর ব্যালেন্স পেতে হবে।```
function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
    address token,
    uint liquidity,
    uint amountTokenMin,
    uint amountETHMin,
    address to,
    uint deadline,
    bool approveMax, uint8 v, bytes32 r, bytes32 s
) external virtual override returns (uint amountETH) {
    address pair = UniswapV2Library.pairFor(factory, token, WETH);
    uint value = approveMax ? uint(-1) : liquidity;
    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(
        token, liquidity, amountTokenMin, amountETHMin, to, deadline
    );
}
```

```solidity
        }
    }
}
```

### ফিক্সড পয়েন্ট ফ্র্যাকশন (UQ112x112) {#FixedPoint}

এই লাইব্রেরি ভগ্নাংশ পরিচালনা করে, যা সাধারণত Ethereum গাণিতিকের অংশ নয়। এটি _x_ সংখ্যাটিকে _x\*2^112_ হিসাবে এনকোড করে এটি করে। এটি আমাদের কোনো পরিবর্তন ছাড়াই মূল সংযোজন এবং বিয়োগ অপকোড ব্যবহার করতে দেয়।

```solidity
pragma solidity =0.5.16;

// বাইনারি ফিক্সড পয়েন্ট নম্বর পরিচালনা করার জন্য একটি লাইব্রেরি (https://wikipedia.org/wiki/Q_(number_format))

// পরিসীমা: [0, 2**112 - 1]
// রেজোলিউশন: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;
```

`Q112` হল এক-এর জন্য এনকোডিং।

```solidity
    // একটি uint112 কে একটি UQ112x112 হিসাবে এনকোড করুন
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // কখনও ওভারফ্লো হয় না
    }
```

যেহেতু y হল `uint112`, তাই এটি সর্বোচ্চ 2^112-1 হতে পারে। সেই সংখ্যাটি এখনও একটি `UQ112x112` হিসাবে এনকোড করা যেতে পারে।

```solidity
    // একটি UQ112x112 কে একটি uint112 দ্বারা ভাগ করুন, একটি UQ112x112 ফেরত দিন
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}
```

যদি আমরা দুটি `UQ112x112` মান ভাগ করি, তবে ফলাফলটি আর 2^112 দ্বারা গুণিত হয় না। তাই এর পরিবর্তে আমরা ডিনোমিনেটরের জন্য একটি পূর্ণসংখ্যা নিই। আমাদের গুণ করার জন্য একটি অনুরূপ কৌশল ব্যবহার করতে হত, কিন্তু আমাদের `UQ112x112` মানগুলির গুণ করার প্রয়োজন নেই।

### UniswapV2Library {#uniswapV2library}

এই লাইব্রেরিটি শুধুমাত্র পেরিফেরি চুক্তি দ্বারা ব্যবহৃত হয়

```solidity
pragma solidity >=0.5.0;

import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';

import "./SafeMath.sol";

library UniswapV2Library {
    using SafeMath for uint;

    // সাজানো টোকেন ঠিকানা ফেরত দেয়, এই ক্রমে সাজানো জোড়া থেকে ফেরত মান পরিচালনা করতে ব্যবহৃত হয়
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }
```

দুটি টোকেনকে ঠিকানা অনুসারে সাজান, যাতে আমরা তাদের জন্য পেয়ার এক্সচেঞ্জের ঠিকানা পেতে পারি। এটি প্রয়োজনীয় কারণ অন্যথায় আমাদের দুটি সম্ভাবনা থাকত, একটি প্যারামিটার A, B-এর জন্য এবং অন্যটি প্যারামিটার B, A-এর জন্য, যার ফলে একটির পরিবর্তে দুটি এক্সচেঞ্জ হত।

```solidity
    // কোনো বহিরাগত কল না করেই একটি পেয়ারের জন্য CREATE2 ঠিকানা গণনা করে
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init কোড হ্যাশ
            ))));
    }
```

এই ফাংশনটি দুটি টোকেনের জন্য পেয়ার এক্সচেঞ্জের ঠিকানা গণনা করে। এই চুক্তিটি [CREATE2 অপকোড](https://eips.ethereum.org/EIPS/eip-1014) ব্যবহার করে তৈরি করা হয়েছে, তাই আমরা একই অ্যালগরিদম ব্যবহার করে ঠিকানাটি গণনা করতে পারি যদি আমরা এর ব্যবহৃত প্যারামিটারগুলি জানি। এটি ফ্যাক্টরিকে জিজ্ঞাসা করার চেয়ে অনেক সস্তা, এবং

```solidity
    // একটি পেয়ারের জন্য রিজার্ভ আনে এবং সাজায়
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
```

এই ফাংশনটি পেয়ার এক্সচেঞ্জের কাছে থাকা দুটি টোকেনের রিজার্ভ ফেরত দেয়। লক্ষ্য করুন যে এটি যেকোনো ক্রমে টোকেনগুলি গ্রহণ করতে পারে এবং অভ্যন্তরীণ ব্যবহারের জন্য সেগুলি সাজায়।

```solidity
    // একটি সম্পদের কিছু পরিমাণ এবং পেয়ারের রিজার্ভ দেওয়া হলে, অন্য সম্পদের সমতুল্য পরিমাণ ফেরত দেয়
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }
```

এই ফাংশনটি আপনাকে টোকেন B-এর পরিমাণ দেয় যা আপনি টোকেন A-এর বিনিময়ে পাবেন যদি কোনো ফি জড়িত না থাকে। এই গণনাটি বিবেচনায় নেয় যে স্থানান্তরটি বিনিময় হার পরিবর্তন করে।

```solidity
    // একটি সম্পদের ইনপুট পরিমাণ এবং পেয়ার রিজার্ভ দেওয়া হলে, অন্য সম্পদের সর্বোচ্চ আউটপুট পরিমাণ ফেরত দেয়
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
```

উপরের `quote` ফাংশনটি দুর্দান্ত কাজ করে যদি পেয়ার এক্সচেঞ্জ ব্যবহার করার জন্য কোনো ফি না থাকে। যাইহোক, যদি 0.3% এক্সচেঞ্জ ফি থাকে তবে আপনি আসলে যে পরিমাণ পান তা কম। এই ফাংশনটি এক্সচেঞ্জ ফি-এর পরে পরিমাণ গণনা করে।

```solidity

        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }
```

সলিডিটি স্থানীয়ভাবে ভগ্নাংশ পরিচালনা করে না, তাই আমরা শুধু পরিমাণটিকে 0.997 দ্বারা গুণ করতে পারি না। এর পরিবর্তে, আমরা নিউমেরেটরকে 997 এবং ডিনোমিনেটরকে 1000 দ্বারা গুণ করি, যা একই প্রভাব অর্জন করে।

```solidity
    // একটি সম্পদের আউটপুট পরিমাণ এবং পেয়ার রিজার্ভ দেওয়া হলে, অন্য সম্পদের প্রয়োজনীয় ইনপুট পরিমাণ ফেরত দেয়
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }
```

এই ফাংশনটি প্রায় একই কাজ করে, তবে এটি আউটপুট পরিমাণ পায় এবং ইনপুট প্রদান করে।

```solidity

    // যেকোনো সংখ্যক পেয়ারে শৃঙ্খলিত getAmountOut গণনা সম্পাদন করে
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // যেকোনো সংখ্যক পেয়ারে শৃঙ্খলিত getAmountIn গণনা সম্পাদন করে
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}
```

যখন একাধিক পেয়ার এক্সচেঞ্জের মধ্য দিয়ে যাওয়ার প্রয়োজন হয় তখন এই দুটি ফাংশন মানগুলি শনাক্ত করার কাজটি করে।

### ট্রান্সফার হেল্পার {#transfer-helper}

[এই লাইব্রেরিটি](https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol) ERC-20 এবং Ethereum স্থানান্তরের চারপাশে সফলতা পরীক্ষা যোগ করে যাতে একটি রিভার্ট এবং একটি `false` মান রিটার্নকে একই ভাবে বিবেচনা করা যায়।

```solidity
// SPDX-লাইসেন্স-আইডেন্টিফায়ার: GPL-3.0-বা-পরবর্তী

pragma solidity >=0.6.0;

// ERC20 টোকেনের সাথে ইন্টারঅ্যাক্ট করার এবং ETH পাঠানোর জন্য সহায়ক পদ্ধতি যা ধারাবাহিকভাবে ট্রু/ফলস রিটার্ন করে না
library TransferHelper {
    function safeApprove(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));

```

আমরা দুটি উপায়ের মধ্যে একটিতে একটি ভিন্ন চুক্তিকে কল করতে পারি:

- একটি ফাংশন কল তৈরি করতে একটি ইন্টারফেস সংজ্ঞা ব্যবহার করুন
- কলটি তৈরি করতে [অ্যাপ্লিকেশন বাইনারি ইন্টারফেস (ABI)](https://docs.soliditylang.org/en/v0.8.3/abi-spec.html) "ম্যানুয়ালি" ব্যবহার করুন। কোডের লেখক এটি করার সিদ্ধান্ত নিয়েছিলেন।

```solidity
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeApprove: approve failed'
        );
    }
```

ERC-20 স্ট্যান্ডার্ডের আগে তৈরি করা টোকেনের সাথে পশ্চাদগামী সামঞ্জস্যের জন্য, একটি ERC-20 কল হয় রিভার্টিং (যেখানে `success` হল `false`) দ্বারা বা সফল হয়ে একটি `false` মান রিটার্ন করে (যেখানে আউটপুট ডেটা থাকে, এবং যদি আপনি এটিকে বুলিয়ান হিসাবে ডিকোড করেন তবে আপনি `false` পাবেন) ব্যর্থ হতে পারে।

```solidity


    function safeTransfer(
        address token,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::safeTransfer: transfer failed'
        );
    }
```

এই ফাংশনটি [ERC-20-এর ট্রান্সফার কার্যকারিতা](https://eips.ethereum.org/EIPS/eip-20#transfer) বাস্তবায়ন করে, যা একটি অ্যাকাউন্টকে অন্য একটি অ্যাকাউন্ট দ্বারা প্রদত্ত অ্যালাওয়েন্স ব্যয় করার অনুমতি দেয়।

```solidity

    function safeTransferFrom(
        address token,
        address from,
        address to,
        uint256 value
    ) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            'TransferHelper::transferFrom: transferFrom failed'
        );
    }
```

এই ফাংশনটি [ERC-20-এর transferFrom কার্যকারিতা](https://eips.ethereum.org/EIPS/eip-20#transferfrom) বাস্তবায়ন করে, যা একটি অ্যাকাউন্টকে অন্য একটি অ্যাকাউন্ট দ্বারা প্রদত্ত অ্যালাওয়েন্স ব্যয় করার অনুমতি দেয়।

```solidity

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
    }
}
```

এই ফাংশনটি একটি অ্যাকাউন্টে ইথার স্থানান্তর করে। একটি ভিন্ন চুক্তিতে যেকোনো কল ইথার পাঠানোর চেষ্টা করতে পারে। কারণ আমাদের আসলে কোনো ফাংশন কল করার প্রয়োজন নেই, আমরা কলের সাথে কোনো ডেটা পাঠাই না।

## উপসংহার {#conclusion}

এটি প্রায় 50 পৃষ্ঠার একটি দীর্ঘ নিবন্ধ। আপনি যদি এখানে পৌঁছাতে পারেন, অভিনন্দন! আশা করি, এতক্ষণে আপনি একটি বাস্তব-জীবনের অ্যাপ্লিকেশন লেখার ক্ষেত্রে বিবেচ্য বিষয়গুলি বুঝতে পেরেছেন (ছোট নমুনা প্রোগ্রামের বিপরীতে) এবং আপনার নিজের ব্যবহারের ক্ষেত্রে চুক্তি লেখার জন্য আরও ভালোভাবে সক্ষম।

এখন যান এবং দরকারী কিছু লিখুন এবং আমাদের অবাক করে দিন।

[আমার আরও কাজের জন্য এখানে দেখুন](https://cryptodocguy.pro/)।
