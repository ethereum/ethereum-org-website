---
title: "কন্ট্র্যাক্টের আকারের সীমাবদ্ধতার বিরুদ্ধে লড়তে কন্ট্র্যাক্টের আকার কমানো"
description: আপনার স্মার্ট কন্ট্র্যাক্টগুলোকে খুব বড় হয়ে যাওয়া থেকে আটকাতে আপনি কি করতে পারেন?
author: Markus Waas
lang: bn
tags: [ "সলিডিটি", "স্মার্ট কন্ট্র্যাক্ট", "সংগ্রহস্থল" ]
skill: intermediate
published: 2020-06-26
source: soliditydeveloper.com
sourceUrl: https://soliditydeveloper.com/max-contract-size
---

## একটি সীমা কেন আছে? {#why-is-there-a-limit}

[নভেম্বর 22, 2016](https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon/) তারিখে Spurious Dragon হার্ড-ফর্ক [EIP-170](https://eips.ethereum.org/EIPS/eip-170) চালু করে, যা 24.576 kb এর একটি স্মার্ট কন্ট্র্যাক্ট আকারের সীমা যোগ করে। একজন Solidity ডেভেলপার হিসেবে আপনার জন্য এর মানে হল যে যখন আপনি আপনার কন্ট্র্যাক্টে আরও বেশি করে ফাংশনালিটি যোগ করবেন, কোনো এক সময়ে আপনি সীমাতে পৌঁছে যাবেন এবং ডিপ্লয় করার সময় এই ত্রুটিটি দেখতে পাবেন:

`সতর্কতা: কন্ট্র্যাক্টের কোডের আকার 24576 বাইট অতিক্রম করেছে (Spurious Dragon-এ একটি সীমা চালু করা হয়েছে)। এই কন্ট্র্যাক্টটি মেইননেটে ডিপ্লয়যোগ্য নাও হতে পারে। অপ্টিমাইজার সক্রিয় করার কথা বিবেচনা করুন (কম "রান" মান সহ!), রিভার্ট স্ট্রিংগুলি বন্ধ করুন, বা লাইব্রেরি ব্যবহার করুন।`

এই সীমাটি ডিনায়াল-অফ-সার্ভিস (DOS) আক্রমণ প্রতিরোধ করার জন্য চালু করা হয়েছিল। একটি কন্ট্র্যাক্টে যেকোনো কল গ্যাসের দিক থেকে তুলনামূলকভাবে সস্তা। তবে, Ethereum নোডগুলোর জন্য একটি কন্ট্র্যাক্ট কলের প্রভাব কল করা কন্ট্র্যাক্টের কোডের আকারের উপর নির্ভর করে অসামঞ্জস্যপূর্ণভাবে বৃদ্ধি পায় (ডিস্ক থেকে কোড পড়া, কোড প্রি-প্রসেস করা, Merkle প্রুফে ডেটা যোগ করা)। যখনই আপনার এমন পরিস্থিতি থাকে যেখানে আক্রমণকারীকে অন্যদের জন্য অনেক কাজ তৈরি করার জন্য অল্প রিসোর্স প্রয়োজন হয়, তখন DOS আক্রমণের সম্ভাবনা তৈরি হয়।

মূলত এটি তেমন কোনো সমস্যা ছিল না কারণ একটি স্বাভাবিক কন্ট্র্যাক্টের আকারের সীমা হলো ব্লক গ্যাস লিমিট। স্বাভাবিকভাবেই, একটি কন্ট্র্যাক্টকে এমন একটি ট্রানজ্যাকশনের মধ্যে ডিপ্লয় করতে হবে যা কন্ট্র্যাক্টের সমস্ত বাইটকোড ধারণ করে। আপনি যদি একটি ব্লকে শুধুমাত্র সেই একটি ট্রানজ্যাকশন অন্তর্ভুক্ত করেন, তবে আপনি সেই সমস্ত গ্যাস ব্যবহার করতে পারবেন, কিন্তু এটি অসীম নয়। [লন্ডন আপগ্রেডের](/ethereum-forks/#london) পর থেকে, ব্লক গ্যাস লিমিট নেটওয়ার্কের চাহিদার উপর নির্ভর করে 15M থেকে 30M ইউনিটের মধ্যে পরিবর্তিত হতে সক্ষম হয়েছে।

এর পরে আমরা তাদের সম্ভাব্য প্রভাব অনুসারে সাজানো কিছু পদ্ধতি দেখব। এটিকে ওজন কমানোর দিক থেকে ভাবুন। কারো জন্য তাদের লক্ষ্য ওজন (আমাদের ক্ষেত্রে 24kb) অর্জনের সেরা কৌশল হল প্রথমে বড় প্রভাবযুক্ত পদ্ধতিগুলিতে মনোযোগ দেওয়া। বেশিরভাগ ক্ষেত্রে শুধুমাত্র আপনার খাদ্যাভ্যাস ঠিক করলেই আপনি সেখানে পৌঁছে যাবেন, কিন্তু কখনও কখনও আপনার আরও কিছু প্রয়োজন হয়। তারপরে আপনি কিছু ব্যায়াম (মাঝারি প্রভাব) বা এমনকি পরিপূরক (ছোট প্রভাব) যোগ করতে পারেন।

## বড় প্রভাব {#big-impact}

### আপনার কন্ট্র্যাক্টগুলো আলাদা করুন {#separate-your-contracts}

এটি সর্বদা আপনার প্রথম পদক্ষেপ হওয়া উচিত। আপনি কীভাবে কন্ট্র্যাক্টটিকে একাধিক ছোট কন্ট্র্যাক্টে বিভক্ত করতে পারেন? এটি সাধারণত আপনাকে আপনার কন্ট্র্যাক্টগুলোর জন্য একটি ভাল আর্কিটেকচার তৈরি করতে বাধ্য করে। কোড পাঠযোগ্যতার দৃষ্টিকোণ থেকে ছোট কন্ট্র্যাক্টগুলো সর্বদা পছন্দনীয়। কন্ট্র্যাক্ট বিভক্ত করার জন্য, নিজেকে জিজ্ঞাসা করুন:

- কোন ফাংশনগুলো একসাথে সম্পর্কিত? প্রতিটি ফাংশন সেট তার নিজস্ব কন্ট্র্যাক্টে সবচেয়ে ভালো হতে পারে।
- কোন ফাংশনগুলোর জন্য কন্ট্র্যাক্টের স্টেট বা স্টেটের একটি নির্দিষ্ট সাবসেট পড়ার প্রয়োজন নেই?
- আপনি কি সংগ্রহস্থল এবং ফাংশনালিটি বিভক্ত করতে পারেন?

### লাইব্রেরি {#libraries}

সংগ্রহস্থল থেকে ফাংশনালিটি কোড সরানোর একটি সহজ উপায় হল একটি [লাইব্রেরি](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#libraries) ব্যবহার করা। লাইব্রেরি ফাংশনগুলিকে ইন্টারনাল হিসাবে ঘোষণা করবেন না কারণ সেগুলি কম্পাইলেশনের সময় সরাসরি [কন্ট্র্যাক্টে যোগ করা হবে](https://ethereum.stackexchange.com/questions/12975/are-internal-functions-in-libraries-not-covered-by-linking)। কিন্তু আপনি যদি পাবলিক ফাংশন ব্যবহার করেন, তবে সেগুলি আসলে একটি পৃথক লাইব্রেরি কন্ট্র্যাক্টে থাকবে। লাইব্রেরির ব্যবহার আরও সুবিধাজনক করতে [using for](https://solidity.readthedocs.io/en/v0.6.10/contracts.html#using-for) ব্যবহার করার কথা বিবেচনা করুন।

### প্রক্সি {#proxies}

একটি আরও উন্নত কৌশল হবে একটি প্রক্সি সিস্টেম। লাইব্রেরিগুলো ব্যাকগ্রাউন্ডে `DELEGATECALL` ব্যবহার করে যা কেবল কলিং কন্ট্র্যাক্টের স্টেট দিয়ে অন্য একটি কন্ট্র্যাক্টের ফাংশন কার্যকর করে। প্রক্সি সিস্টেম সম্পর্কে আরও জানতে [এই ব্লগ পোস্টটি](https://hackernoon.com/how-to-make-smart-contracts-upgradable-2612e771d5a2) দেখুন। তারা আপনাকে আরও ফাংশনালিটি দেয়, যেমন, তারা আপগ্রেডযোগ্যতা সক্ষম করে, কিন্তু তারা অনেক জটিলতাও যোগ করে। আমি কেবল কন্ট্র্যাক্টের আকার কমানোর জন্য এগুলি যোগ করব না যদি না এটি যেকোনো কারণেই আপনার একমাত্র বিকল্প হয়।

## মাঝারি প্রভাব {#medium-impact}

### ফাংশনগুলি সরান {#remove-functions}

এটি স্পষ্ট হওয়া উচিত। ফাংশন একটি কন্ট্র্যাক্টের আকার বেশ কিছুটা বাড়িয়ে দেয়।

- **এক্সটার্নাল**: প্রায়শই আমরা সুবিধার জন্য অনেক ভিউ ফাংশন যোগ করি। যতক্ষণ না আপনি আকারের সীমাতে পৌঁছান ততক্ষণ এটি ঠিক আছে। তখন আপনি একেবারে অপরিহার্য ফাংশনগুলো ছাড়া বাকি সবগুলি সরানোর কথা ভাবতে পারেন।
- **ইন্টারনাল**: আপনি ইন্টারনাল/প্রাইভেট ফাংশনগুলিও সরাতে পারেন এবং যতক্ষণ ফাংশনটি কেবল একবার কল করা হয় ততক্ষণ কোডটি কেবল ইনলাইন করতে পারেন।

### অতিরিক্ত ভেরিয়েবল এড়িয়ে চলুন {#avoid-additional-variables}

```solidity
function get(uint id) returns (address,address) {
    MyStruct memory myStruct = myStructs[id];
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns (address,address) {
    return (myStructs[id].addr1, myStructs[id].addr2);
}
```

এইরকম একটি সাধারণ পরিবর্তনে **0.28kb** এর পার্থক্য তৈরি হয়। সম্ভবত আপনি আপনার কন্ট্র্যাক্টগুলোতে অনেক একই রকম পরিস্থিতি খুঁজে পেতে পারেন এবং সেগুলি সত্যিই একটি উল্লেখযোগ্য পরিমাণে যোগ হতে পারে।

### ত্রুটির মেসেজ ছোট করুন {#shorten-error-message}

দীর্ঘ রিভার্ট মেসেজ এবং বিশেষ করে অনেক ভিন্ন রিভার্ট মেসেজ কন্ট্র্যাক্টকে ফুলিয়ে তুলতে পারে। এর পরিবর্তে সংক্ষিপ্ত ত্রুটির কোড ব্যবহার করুন এবং আপনার কন্ট্র্যাক্টে সেগুলি ডিকোড করুন। একটি দীর্ঘ মেসেজ অনেক ছোট হতে পারে:

```solidity
require(msg.sender == owner, "শুধুমাত্র এই কন্ট্র্যাক্টের মালিকই এই ফাংশনটি কল করতে পারবেন");
```

```solidity
require(msg.sender == owner, "OW1");
```

### ত্রুটির মেসেজের পরিবর্তে কাস্টম ত্রুটি ব্যবহার করুন

কাস্টম ত্রুটি [Solidity 0.8.4](https://blog.soliditylang.org/2021/04/21/custom-errors/)-এ চালু করা হয়েছে। এগুলি আপনার কন্ট্র্যাক্টের আকার কমানোর একটি দুর্দান্ত উপায়, কারণ এগুলি সিলেক্টর হিসাবে ABI-এনকোডেড (ঠিক যেমন ফাংশনগুলো হয়)।

```solidity
error Unauthorized();

if (msg.sender != owner) {
    revert Unauthorized();
}
```

### অপ্টিমাইজারে একটি কম রান ভ্যালু বিবেচনা করুন {#consider-a-low-run-value-in-the-optimizer}

আপনি অপ্টিমাইজার সেটিংসও পরিবর্তন করতে পারেন। 200 এর ডিফল্ট মানটির অর্থ হল এটি বাইটকোডকে এমনভাবে অপ্টিমাইজ করার চেষ্টা করছে যেন একটি ফাংশন 200 বার কল করা হয়েছে। আপনি যদি এটিকে 1-এ পরিবর্তন করেন, তবে আপনি মূলত অপ্টিমাইজারকে প্রতিটি ফাংশন শুধুমাত্র একবার চালানোর জন্য অপ্টিমাইজ করতে বলছেন। শুধুমাত্র একবার চালানোর জন্য একটি অপ্টিমাইজ করা ফাংশনের অর্থ হল এটি ডিপ্লয়মেন্টের জন্যই অপ্টিমাইজ করা হয়েছে। সচেতন থাকুন যে **এটি ফাংশনগুলি চালানোর জন্য [গ্যাসের খরচ](/developers/docs/gas/) বাড়িয়ে দেয়**, তাই আপনি এটি করতে নাও চাইতে পারেন।

## ছোট প্রভাব {#small-impact}

### ফাংশনে স্ট্রাকট পাস করা এড়িয়ে চলুন {#avoid-passing-structs-to-functions}

আপনি যদি [ABIEncoderV2](https://solidity.readthedocs.io/en/v0.6.10/layout-of-source-files.html#abiencoderv2) ব্যবহার করেন, তাহলে এটি একটি ফাংশনে স্ট্রাকট পাস না করতে সাহায্য করতে পারে। প্যারামিটারটিকে স্ট্রাকট হিসাবে পাস করার পরিবর্তে, প্রয়োজনীয় প্যারামিটারগুলি সরাসরি পাস করুন। এই উদাহরণে আমরা আরও **0.1kb** সাশ্রয় করেছি।

```solidity
function get(uint id) returns (address,address) {
    return _get(myStruct);
}

function _get(MyStruct memory myStruct) private view returns(address,address) {
    return (myStruct.addr1, myStruct.addr2);
}
```

```solidity
function get(uint id) returns(address,address) {
    return _get(myStructs[id].addr1, myStructs[id].addr2);
}

function _get(address addr1, address addr2) private view returns(address,address) {
    return (addr1, addr2);
}
```

### ফাংশন এবং ভেরিয়েবলের জন্য সঠিক ভিজিবিলিটি ঘোষণা করুন {#declare-correct-visibility-for-functions-and-variables}

- ফাংশন বা ভেরিয়েবল যা শুধুমাত্র বাইরে থেকে কল করা হয়? `public` এর পরিবর্তে সেগুলোকে `external` হিসাবে ঘোষণা করুন।
- ফাংশন বা ভেরিয়েবল যা শুধুমাত্র কন্ট্র্যাক্টের মধ্যে থেকে কল করা হয়? `public` এর পরিবর্তে সেগুলোকে `private` বা `internal` হিসাবে ঘোষণা করুন।

### মডিফায়ারগুলি সরান {#remove-modifiers}

মডিফায়ার, বিশেষ করে যখন নিবিড়ভাবে ব্যবহার করা হয়, তখন কন্ট্র্যাক্টের আকারে একটি উল্লেখযোগ্য প্রভাব ফেলতে পারে। সেগুলি সরানোর কথা বিবেচনা করুন এবং পরিবর্তে ফাংশন ব্যবহার করুন।

```solidity
modifier checkStuff() {}

function doSomething() checkStuff {}
```

```solidity
function checkStuff() private {}

function doSomething() { checkStuff(); }
```

এই টিপসগুলো আপনাকে কন্ট্র্যাক্টের আকার উল্লেখযোগ্যভাবে কমাতে সাহায্য করবে। আবারও, আমি যথেষ্ট জোর দিয়ে বলতে পারি না, সবচেয়ে বড় প্রভাবের জন্য সম্ভব হলে সর্বদা কন্ট্র্যাক্ট বিভক্ত করার দিকে মনোনিবেশ করুন।
