---
title: "Vyper ERC-721 কন্ট্র্যাক্ট ওয়াকথ্রু"
description: Ryuya Nakamura-এর ERC-721 কন্ট্র্যাক্ট এবং এটি কীভাবে কাজ করে
author: Ori Pomerantz
lang: bn
tags: [ "vyper", "erc-721", "python" ]
skill: beginner
published: 2021-04-01
---

## ভূমিকা {#introduction}

[ERC-721](/developers/docs/standards/tokens/erc-721/) স্ট্যান্ডার্ডটি নন-ফাঞ্জিবল টোকেনের (NFT) মালিকানা ধরে রাখতে ব্যবহৃত হয়।
[ERC-20](/developers/docs/standards/tokens/erc-20/) টোকেনগুলি একটি পণ্যের মতো আচরণ করে, কারণ পৃথক টোকেনগুলির মধ্যে কোনও পার্থক্য নেই।
এর বিপরীতে, ERC-721 টোকেনগুলি এমন অ্যাসেটের জন্য ডিজাইন করা হয়েছে যা একই রকম কিন্তু অভিন্ন নয়, যেমন বিভিন্ন বিড়ালের
কার্টুন বা বিভিন্ন রিয়েল এস্টেটের মালিকানা।

এই আর্টিকেলে আমরা [Ryuya Nakamura-এর ERC-721 কন্ট্র্যাক্ট](https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC721.vy) বিশ্লেষণ করব।
এই কন্ট্র্যাক্টটি [Vyper](https://vyper.readthedocs.io/en/latest/index.html) ভাষায় লেখা, এটি Python-এর মতো একটি কন্ট্র্যাক্ট ল্যাঙ্গুয়েজ যা Solidity-র চেয়ে নিরাপত্তাহীন কোড লেখাকে আরও কঠিন করে তোলার জন্য ডিজাইন করা হয়েছে।

## কন্ট্র্যাক্টটি {#contract}

```python
# @dev ERC-721 নন-ফাঞ্জিবল টোকেন স্ট্যান্ডার্ডের ইমপ্লিমেন্টেশন।
# @author Ryuya Nakamura (@nrryuya)
# থেকে সংশোধিত: https://github.com/vyperlang/vyper/blob/de74722bf2d8718cca46902be165f9fe0e3641dd/examples/tokens/ERC721.vy
```

Vyper-এ, Python-এর মতোই, কমেন্টগুলি একটি হ্যাশ (`#`) দিয়ে শুরু হয় এবং লাইনের শেষ পর্যন্ত চলতে থাকে। যে কমেন্টগুলিতে
`@<keyword>` থাকে সেগুলি [NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) দ্বারা মানুষের পাঠযোগ্য ডকুমেন্টেশন তৈরি করতে ব্যবহৃত হয়।

```python
from vyper.interfaces import ERC721

implements: ERC721
```

ERC-721 ইন্টারফেসটি Vyper ল্যাঙ্গুয়েজের মধ্যে অন্তর্নির্মিত।
[আপনি এখানে কোডের সংজ্ঞা দেখতে পারেন](https://github.com/vyperlang/vyper/blob/master/vyper/builtin_interfaces/ERC721.py)।
ইন্টারফেসের সংজ্ঞা Vyper-এর পরিবর্তে Python-এ লেখা হয়েছে, কারণ ইন্টারফেসগুলি শুধুমাত্র ব্লকচেইনের মধ্যেই ব্যবহৃত হয় না, বরং একটি বহিরাগত ক্লায়েন্ট থেকে ব্লকচেইনে লেনদেন পাঠানোর সময়ও ব্যবহৃত হয়, যা Python-এ লেখা হতে পারে।

প্রথম লাইনটি ইন্টারফেস ইম্পোর্ট করে, এবং দ্বিতীয়টি নির্দিষ্ট করে যে আমরা এখানে এটি ইমপ্লিমেন্ট করছি।

### ERC721Receiver ইন্টারফেস {#receiver-interface}

```python
# safeTransferFrom() দ্বারা কল করা কন্ট্র্যাক্টের জন্য ইন্টারফেস
interface ERC721Receiver:
    def onERC721Received(
```

ERC-721 দুই ধরনের ট্রান্সফার সমর্থন করে:

- `transferFrom`, যা সেন্ডারকে যেকোনো গন্তব্যের অ্যাড্রেস নির্দিষ্ট করতে দেয় এবং ট্রান্সফারের দায়িত্ব সেন্ডারের উপর রাখে। এর মানে হল আপনি একটি অবৈধ অ্যাড্রেসে ট্রান্সফার করতে পারেন, সেক্ষেত্রে NFT চিরতরে হারিয়ে যাবে।
- `safeTransferFrom`, যা গন্তব্যের অ্যাড্রেসটি একটি কন্ট্র্যাক্ট কিনা তা পরীক্ষা করে। যদি তাই হয়, ERC-721 কন্ট্র্যাক্টটি গ্রহণকারী কন্ট্র্যাক্টকে জিজ্ঞাসা করে যে এটি NFT গ্রহণ করতে চায় কিনা।

`safeTransferFrom` অনুরোধের উত্তর দিতে একটি গ্রহণকারী কন্ট্র্যাক্টকে `ERC721Receiver` ইমপ্লিমেন্ট করতে হবে।

```python
            _operator: address,
            _from: address,
```

`_from` অ্যাড্রেসটি টোকেনের বর্তমান মালিক। `_operator` অ্যাড্রেসটি হল সেই ব্যক্তি যে ট্রান্সফারের জন্য অনুরোধ করেছে (allowances-এর কারণে এই দুটি এক নাও হতে পারে)।

```python
            _tokenId: uint256,
```

ERC-721 টোকেন ID গুলি 256 বিটের হয়। সাধারণত টোকেনটি যা উপস্থাপন করে তার একটি বিবরণের হ্যাশিং করে এগুলি তৈরি করা হয়।

```python
            _data: Bytes[1024]
```

অনুরোধে 1024 বাইট পর্যন্ত ব্যবহারকারীর ডেটা থাকতে পারে।

```python
        ) -> bytes32: view
```

একটি কন্ট্র্যাক্ট যাতে ভুলবশত কোনো ট্রান্সফার গ্রহণ না করে, তা প্রতিরোধ করার জন্য রিটার্ন ভ্যালুটি বুলিয়ান নয়, বরং একটি নির্দিষ্ট মান সহ 256 বিটের হয়।

এই ফাংশনটি একটি `view`, যার মানে এটি ব্লকচেইনের স্টেট পড়তে পারে, কিন্তু এটি পরিবর্তন করতে পারে না।

### ইভেন্ট {#events}

[ইভেন্টগুলি](https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e) ব্লকচেইনের বাইরের ব্যবহারকারী এবং সার্ভারদের ইভেন্ট সম্পর্কে জানাতে নির্গত হয়। মনে রাখবেন যে ইভেন্টের বিষয়বস্তু ব্লকচেইনের কন্ট্র্যাক্টগুলির জন্য উপলব্ধ নয়।

```python
# @dev যেকোনো মেকানিজমের মাধ্যমে কোনো NFT-এর মালিকানা পরিবর্তন হলে এটি নির্গত হয়। এই ইভেন্টটি তখন নির্গত হয় যখন NFT
#      তৈরি হয় (`from` == 0) এবং ধ্বংস হয় (`to` == 0)। ব্যতিক্রম: কন্ট্র্যাক্ট তৈরির সময়, যেকোনো
#      সংখ্যক NFT ট্রান্সফার নির্গত না করে তৈরি এবং অ্যাসাইন করা যেতে পারে। যেকোনো
#      ট্রান্সফারের সময়, সেই NFT-এর জন্য অনুমোদিত অ্যাড্রেস (যদি থাকে) রিসেট করে কিছুই থাকে না।
# @param _from NFT-এর সেন্ডার (যদি অ্যাড্রেসটি জিরো অ্যাড্রেস হয় তবে এটি টোকেন তৈরি নির্দেশ করে)।
# @param _to NFT-এর প্রাপক (যদি অ্যাড্রেসটি জিরো অ্যাড্রেস হয় তবে এটি টোকেন ধ্বংস নির্দেশ করে)।
# @param _tokenId যে NFTটি ট্রান্সফার করা হয়েছে।
event Transfer:
    sender: indexed(address)
    receiver: indexed(address)
    tokenId: indexed(uint256)
```

এটি ERC-20 ট্রান্সফার ইভেন্টের মতো, তবে এখানে আমরা একটি পরিমাণের পরিবর্তে একটি `tokenId` রিপোর্ট করি।
জিরো অ্যাড্রেসের মালিক কেউ নয়, তাই প্রথা অনুযায়ী আমরা এটি টোকেন তৈরি এবং ধ্বংস রিপোর্ট করতে ব্যবহার করি।

```python
# @dev এটি নির্গত হয় যখন একটি NFT-এর জন্য অনুমোদিত অ্যাড্রেস পরিবর্তন বা পুনরায় নিশ্চিত করা হয়। জিরো
#      অ্যাড্রেস নির্দেশ করে যে কোনো অনুমোদিত অ্যাড্রেস নেই। যখন একটি ট্রান্সফার ইভেন্ট নির্গত হয়, এটিও
#      নির্দেশ করে যে সেই NFT-এর জন্য অনুমোদিত অ্যাড্রেস (যদি থাকে) রিসেট করে কিছুই থাকে না।
# @param _owner NFT-এর মালিক।
# @param _approved যে অ্যাড্রেসটি আমরা অনুমোদন করছি।
# @param _tokenId যে NFT-টি আমরা অনুমোদন করছি।
event Approval:
    owner: indexed(address)
    approved: indexed(address)
    tokenId: indexed(uint256)
```

একটি ERC-721 অনুমোদন একটি ERC-20 অ্যালাওয়েন্সের মতো। একটি নির্দিষ্ট অ্যাড্রেস একটি নির্দিষ্ট টোকেন ট্রান্সফার করার অনুমতিপ্রাপ্ত। এটি কন্ট্র্যাক্টগুলিকে একটি টোকেন গ্রহণ করার সময় প্রতিক্রিয়া জানানোর জন্য একটি মেকানিজম দেয়। কন্ট্র্যাক্টগুলি ইভেন্টের জন্য অপেক্ষা করতে পারে না, তাই যদি আপনি কেবল তাদের কাছে টোকেন ট্রান্সফার করেন তবে তারা এটি সম্পর্কে "জানতে" পারে না। এইভাবে মালিক প্রথমে একটি অনুমোদন জমা দেয় এবং তারপরে কন্ট্র্যাক্টে একটি অনুরোধ পাঠায়: "আমি আপনাকে টোকেন
X ট্রান্সফার করার জন্য অনুমোদন দিয়েছি, অনুগ্রহ করে করুন..."।

এটি ERC-721 স্ট্যান্ডার্ডকে ERC-20 স্ট্যান্ডার্ডের মতো করার জন্য একটি ডিজাইনের সিদ্ধান্ত। যেহেতু ERC-721 টোকেনগুলি নন-ফাঞ্জিবল, তাই একটি কন্ট্র্যাক্ট টোকেনের মালিকানা দেখেও শনাক্ত করতে পারে যে এটি একটি নির্দিষ্ট টোকেন পেয়েছে।

```python
# @dev এটি তখন নির্গত হয় যখন একজন মালিকের জন্য একজন অপারেটর সক্রিয় বা নিষ্ক্রিয় করা হয়। অপারেটর পরিচালনা করতে পারে
#      মালিকের সমস্ত NFT।
# @param _owner NFT-এর মালিক।
# @param _operator যে অ্যাড্রেসে আমরা অপারেটরের অধিকার সেট করছি।
# @param _approved অপারেটরের অধিকারের স্থিতি (সত্য যদি অপারেটরের অধিকার দেওয়া হয় এবং মিথ্যা যদি
# প্রত্যাহার করা হয়)।
event ApprovalForAll:
    owner: indexed(address)
    operator: indexed(address)
    approved: bool
```

কখনো কখনো একজন _অপারেটর_ থাকা দরকারী, যে একটি নির্দিষ্ট ধরনের একটি অ্যাকাউন্টের সমস্ত টোকেন পরিচালনা করতে পারে (যেগুলো একটি নির্দিষ্ট কন্ট্র্যাক্ট দ্বারা পরিচালিত হয়), যা পাওয়ার অফ অ্যাটর্নির মতো। উদাহরণস্বরূপ, আমি এমন একটি কন্ট্র্যাক্টকে এই ক্ষমতা দিতে চাইতে পারি যা পরীক্ষা করে দেখবে যে আমি ছয় মাস ধরে এর সাথে যোগাযোগ করেছি কিনা, এবং যদি না করে থাকি, তাহলে আমার সম্পদ আমার উত্তরাধিকারীদের মধ্যে বিতরণ করবে (যদি তাদের মধ্যে কেউ এর জন্য জিজ্ঞাসা করে, কন্ট্র্যাক্টগুলো কোনো লেনদেন দ্বারা কল না করা পর্যন্ত কিছুই করতে পারে না)। ERC-20-তে আমরা উত্তরাধিকার কন্ট্র্যাক্টকে একটি উচ্চ অ্যালাওয়েন্স দিতে পারি, কিন্তু এটি ERC-721-এর জন্য কাজ করে না কারণ টোকেনগুলি নন-ফাঞ্জিবল। এটি তার সমতুল্য।

`approved` মানটি আমাদের বলে যে ইভেন্টটি একটি অনুমোদনের জন্য, নাকি একটি অনুমোদন প্রত্যাহারের জন্য।

### স্টেট ভ্যারিয়েবল {#state-vars}

এই ভ্যারিয়েবলগুলিতে টোকেনগুলির বর্তমান স্টেট থাকে: কোনটি উপলব্ধ এবং কে তাদের মালিক। এগুলির বেশিরভাগই `HashMap` অবজেক্ট, [দুটি টাইপের মধ্যে বিদ্যমান একমুখী ম্যাপিং](https://vyper.readthedocs.io/en/latest/types.html#mappings)।

```python
# @dev NFT ID থেকে সেটির মালিকের অ্যাড্রেসের ম্যাপিং।
idToOwner: HashMap[uint256, address]

# @dev NFT ID থেকে অনুমোদিত অ্যাড্রেসের ম্যাপিং।
idToApprovals: HashMap[uint256, address]
```

Ethereum-এ ব্যবহারকারী এবং কন্ট্র্যাক্টের পরিচয় 160-বিটের অ্যাড্রেস দ্বারা উপস্থাপিত হয়। এই দুটি ভ্যারিয়েবল টোকেন ID থেকে তাদের মালিক এবং যারা তাদের ট্রান্সফার করার জন্য অনুমোদিত (প্রতিটির জন্য সর্বাধিক একজন) তাদের ম্যাপ করে। Ethereum-এ, ইনিশিয়ালাইজ না করা ডেটা সবসময় শূন্য থাকে, তাই যদি কোনো মালিক বা অনুমোদিত ট্রান্সফারকারী না থাকে তবে সেই টোকেনের মান শূন্য হয়।

```python
# @dev মালিকের অ্যাড্রেস থেকে তার টোকেন সংখ্যার ম্যাপিং।
ownerToNFTokenCount: HashMap[address, uint256]
```

এই ভ্যারিয়েবলটি প্রতিটি মালিকের টোকেনের সংখ্যা ধরে রাখে। মালিকদের থেকে টোকেনের কোনো ম্যাপিং নেই, তাই কোনো নির্দিষ্ট মালিকের মালিকানাধীন টোকেনগুলি শনাক্ত করার একমাত্র উপায় হলো ব্লকচেইনের ইভেন্ট ইতিহাসে ফিরে দেখা এবং উপযুক্ত `Transfer` ইভেন্টগুলি দেখা। আমরা এই ভ্যারিয়েবলটি ব্যবহার করে জানতে পারি যে কখন আমাদের কাছে সমস্ত NFT আছে এবং সময়ের আরও পিছনে দেখার প্রয়োজন নেই।

মনে রাখবেন যে এই অ্যালগরিদমটি শুধুমাত্র ব্যবহারকারী ইন্টারফেস এবং বহিরাগত সার্ভারের জন্য কাজ করে। ব্লকচেইনে চলমান কোড নিজে অতীতের ইভেন্টগুলি পড়তে পারে না।

```python
# @dev মালিকের অ্যাড্রেস থেকে অপারেটর অ্যাড্রেসের ম্যাপিং-এর ম্যাপিং।
ownerToOperators: HashMap[address, HashMap[address, bool]]
```

একটি অ্যাকাউন্টে একাধিক অপারেটর থাকতে পারে। একটি সাধারণ `HashMap` তাদের ট্র্যাক রাখার জন্য অপর্যাপ্ত, কারণ প্রতিটি কী একটি একক মানের দিকে নিয়ে যায়। এর পরিবর্তে, আপনি মান হিসাবে `HashMap[address, bool]` ব্যবহার করতে পারেন। ডিফল্টরূপে প্রতিটি অ্যাড্রেসের জন্য মান `False` থাকে, যার মানে এটি একজন অপারেটর নয়। প্রয়োজন অনুযায়ী আপনি মানগুলিকে `True` তে সেট করতে পারেন।

```python
# @dev মিন্টারের অ্যাড্রেস, যে একটি টোকেন মিন্ট করতে পারে
minter: address
```

নতুন টোকেন কোনো না কোনোভাবে তৈরি করতে হবে। এই কন্ট্র্যাক্টে একটি একক সত্তা রয়েছে যা এটি করার অনুমতিপ্রাপ্ত, সেটি হলো `minter`। উদাহরণস্বরূপ, একটি গেমের জন্য এটি যথেষ্ট হতে পারে। অন্যান্য উদ্দেশ্যে, একটি আরও জটিল ব্যবসায়িক যুক্তি তৈরি করা প্রয়োজন হতে পারে।

```python
# @dev ইন্টারফেস আইডি থেকে বুলিয়ানের ম্যাপিং, এটি সমর্থিত কিনা।
supportedInterfaces: HashMap[bytes32, bool]

# @dev ERC165 এর ERC165 ইন্টারফেস আইডি
ERC165_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000001ffc9a7

# @dev ERC721 এর ERC165 ইন্টারফেস আইডি
ERC721_INTERFACE_ID: constant(bytes32) = 0x0000000000000000000000000000000000000000000000000000000080ac58cd
```

[ERC-165](https://eips.ethereum.org/EIPS/eip-165) একটি কন্ট্র্যাক্টের জন্য একটি মেকানিজম নির্দিষ্ট করে যা প্রকাশ করে যে অ্যাপ্লিকেশনগুলি কীভাবে এর সাথে যোগাযোগ করতে পারে, এবং এটি কোন ERC গুলি মেনে চলে। এই ক্ষেত্রে, কন্ট্র্যাক্টটি ERC-165 এবং ERC-721 মেনে চলে।

### ফাংশন {#functions}

এগুলি হলো সেই ফাংশন যা আসলে ERC-721 ইমপ্লিমেন্ট করে।

#### কনস্ট্রাক্টর {#constructor}

```python
@external
def __init__():
```

Vyper-এ, Python-এর মতোই, কনস্ট্রাক্টর ফাংশনকে `__init__` বলা হয়।

```python
    """
    @dev কন্ট্র্যাক্ট কনস্ট্রাক্টর।
    """
```

Python এবং Vyper-এ, আপনি একটি মাল্টি-লাইন স্ট্রিং (যা `\"\"\"` দিয়ে শুরু এবং শেষ হয়) নির্দিষ্ট করে এবং এটিকে কোনোভাবে ব্যবহার না করেও একটি মন্তব্য তৈরি করতে পারেন। এই কমেন্টগুলিতে [NatSpec](https://vyper.readthedocs.io/en/latest/natspec.html) অন্তর্ভুক্ত থাকতে পারে।

```python
    self.supportedInterfaces[ERC165_INTERFACE_ID] = True
    self.supportedInterfaces[ERC721_INTERFACE_ID] = True
    self.minter = msg.sender
```

স্টেট ভ্যারিয়েবল অ্যাক্সেস করতে আপনি `self.<variable name>` ব্যবহার করেন\` (আবার, Python-এর মতোই)।

#### ভিউ ফাংশন {#views}

এগুলি এমন ফাংশন যা ব্লকচেইনের স্টেট পরিবর্তন করে না, এবং তাই যদি বাইরে থেকে কল করা হয় তবে বিনামূল্যে কার্যকর করা যেতে পারে। যদি ভিউ ফাংশনগুলি একটি কন্ট্র্যাক্ট দ্বারা কল করা হয় তবে সেগুলি এখনও প্রতিটি নোডে কার্যকর করতে হবে এবং তাই গ্যাসের খরচ হয়।

```python
@view
@external
```

একটি ফাংশন সংজ্ঞার আগে এই কীওয়ার্ডগুলি যা একটি অ্যাট সাইন (`@`) দিয়ে শুরু হয়, তাদের _ডেকোরেশন_ বলা হয়। তারা নির্দিষ্ট করে যে কোন পরিস্থিতিতে একটি ফাংশন কল করা যেতে পারে।

- `@view` নির্দিষ্ট করে যে এই ফাংশনটি একটি ভিউ।
- `@external` নির্দিষ্ট করে যে এই নির্দিষ্ট ফাংশনটি লেনদেন এবং অন্যান্য কন্ট্র্যাক্ট দ্বারা কল করা যেতে পারে।

```python
def supportsInterface(_interfaceID: bytes32) -> bool:
```

Python-এর বিপরীতে, Vyper একটি [স্ট্যাটিক টাইপড ল্যাঙ্গুয়েজ](https://wikipedia.org/wiki/Type_system#Static_type_checking)।
[ডেটা টাইপ](https://vyper.readthedocs.io/en/latest/types.html) শনাক্ত না করে আপনি কোনো ভ্যারিয়েবল বা ফাংশন প্যারামিটার ঘোষণা করতে পারবেন না। এই ক্ষেত্রে ইনপুট প্যারামিটার হল `bytes32`, একটি 256-বিটের মান (256 বিট হল [Ethereum Virtual Machine](/developers/docs/evm/)-এর নেটিভ ওয়ার্ড সাইজ)। আউটপুটটি একটি বুলিয়ান মান। প্রথা অনুযায়ী, ফাংশন প্যারামিটারের নাম একটি আন্ডারস্কোর (`_`) দিয়ে শুরু হয়।

```python
    """
    @dev ইন্টারফেস শনাক্তকরণ ERC-165-এ নির্দিষ্ট করা আছে।
    @param _interfaceID ইন্টারফেসের আইডি
    """
    return self.supportedInterfaces[_interfaceID]
```

`self.supportedInterfaces` HashMap থেকে মানটি রিটার্ন করুন, যা কনস্ট্রাক্টরে (`__init__`) সেট করা হয়েছে।

```python
### VIEW FUNCTIONS ###
```

এগুলি এমন ভিউ ফাংশন যা ব্যবহারকারী এবং অন্যান্য কন্ট্র্যাক্টের জন্য টোকেন সম্পর্কে তথ্য উপলব্ধ করে।

```python
@view
@external
def balanceOf(_owner: address) -> uint256:
    """
    @dev `_owner`-এর মালিকানাধীন NFT-এর সংখ্যা ফেরত দেয়।
         `_owner` যদি শূন্য অ্যাড্রেস হয় তবে থ্রো করে। শূন্য অ্যাড্রেসে অ্যাসাইন করা NFT গুলিকে অবৈধ বলে মনে করা হয়।
    @param _owner যে অ্যাড্রেসের জন্য ব্যালেন্স জিজ্ঞাসা করতে হবে।
    """
    assert _owner != ZERO_ADDRESS
```

এই লাইনটি [অ্যাসার্ট করে](https://vyper.readthedocs.io/en/latest/statements.html#assert) যে `_owner` শূন্য নয়। যদি এটি হয়, তাহলে একটি ত্রুটি হয় এবং অপারেশনটি প্রত্যাবর্তন করা হয়।

```python
    return self.ownerToNFTokenCount[_owner]

@view
@external
def ownerOf(_tokenId: uint256) -> address:
    """
    @dev NFT-এর মালিকের অ্যাড্রেস ফেরত দেয়।
         `_tokenId` যদি একটি বৈধ NFT না হয় তবে থ্রো করে।
    @param _tokenId একটি NFT-এর জন্য আইডেন্টিফায়ার।
    """
    owner: address = self.idToOwner[_tokenId]
    # `_tokenId` যদি একটি বৈধ NFT না হয় তবে থ্রো করে
    assert owner != ZERO_ADDRESS
    return owner
```

Ethereum Virtual Machine (evm)-এ যে কোনও স্টোরেজ যেখানে কোনও মান সংরক্ষণ করা হয়নি তা শূন্য থাকে।
যদি `_tokenId`-তে কোনো টোকেন না থাকে তাহলে `self.idToOwner[_tokenId]`-এর মান শূন্য। সেক্ষেত্রে ফাংশনটি রিভার্ট করে।

```python
@view
@external
def getApproved(_tokenId: uint256) -> address:
    """
    @dev একটি একক NFT-এর জন্য অনুমোদিত অ্যাড্রেস পান।
         `_tokenId` যদি একটি বৈধ NFT না হয় তবে থ্রো করে।
    @param _tokenId যে NFT-এর অনুমোদন জিজ্ঞাসা করতে হবে তার আইডি।
    """
    # `_tokenId` যদি একটি বৈধ NFT না হয় তবে থ্রো করে
    assert self.idToOwner[_tokenId] != ZERO_ADDRESS
    return self.idToApprovals[_tokenId]
```

মনে রাখবেন যে `getApproved` শূন্য ফেরত দিতে _পারে_। যদি টোকেনটি বৈধ হয় তবে এটি `self.idToApprovals[_tokenId]` ফেরত দেয়।
যদি কোনো অনুমোদনকারী না থাকে তবে সেই মান শূন্য।

```python
@view
@external
def isApprovedForAll(_owner: address, _operator: address) -> bool:
    """
    @dev পরীক্ষা করে যে `_operator` `_owner`-এর জন্য একজন অনুমোদিত অপারেটর কিনা।
    @param _owner যে অ্যাড্রেসটি NFT-এর মালিক।
    @param _operator যে অ্যাড্রেসটি মালিকের পক্ষে কাজ করে।
    """
    return (self.ownerToOperators[_owner])[_operator]
```

এই ফাংশনটি পরীক্ষা করে যে `_operator`-কে এই কন্ট্র্যাক্টে `_owner`-এর সমস্ত টোকেন পরিচালনা করার অনুমতি আছে কিনা।
যেহেতু একাধিক অপারেটর থাকতে পারে, এটি একটি দুই-স্তরের HashMap।

#### ট্রান্সফার হেল্পার ফাংশন {#transfer-helpers}

এই ফাংশনগুলি টোকেন ট্রান্সফার বা পরিচালনার অংশ এমন অপারেশনগুলি ইমপ্লিমেন্ট করে।

```python

### TRANSFER FUNCTION HELPERS ###

@view
@internal
```

এই ডেকোরেশন, `@internal` এর মানে হল যে ফাংশনটি শুধুমাত্র একই কন্ট্র্যাক্টের মধ্যে অন্যান্য ফাংশন থেকে অ্যাক্সেসযোগ্য। প্রথা অনুযায়ী, এই ফাংশনের নামগুলিও একটি আন্ডারস্কোর (`_`) দিয়ে শুরু হয়।

```python
def _isApprovedOrOwner(_spender: address, _tokenId: uint256) -> bool:
    """
    @dev প্রদত্ত স্পেন্ডার একটি প্রদত্ত টোকেন আইডি ট্রান্সফার করতে পারে কিনা তা ফেরত দেয়
    @param spender যে স্পেন্ডারের অ্যাড্রেসটি জিজ্ঞাসা করা হবে
    @param tokenId uint256 ট্রান্সফার করা হবে এমন টোকেনের আইডি
    @return bool msg.sender প্রদত্ত টোকেন আইডির জন্য অনুমোদিত কিনা,
        মালিকের একজন অপারেটর, বা টোকেনের মালিক কিনা
    """
    owner: address = self.idToOwner[_tokenId]
    spenderIsOwner: bool = owner == _spender
    spenderIsApproved: bool = _spender == self.idToApprovals[_tokenId]
    spenderIsApprovedForAll: bool = (self.ownerToOperators[owner])[_spender]
    return (spenderIsOwner or spenderIsApproved) or spenderIsApprovedForAll
```

একটি অ্যাড্রেসকে টোকেন ট্রান্সফার করার অনুমতি দেওয়ার তিনটি উপায় আছে:

1. অ্যাড্রেসটি টোকেনের মালিক
2. অ্যাড্রেসটি সেই টোকেনটি খরচ করার জন্য অনুমোদিত
3. অ্যাড্রেসটি টোকেনের মালিকের জন্য একজন অপারেটর

উপরের ফাংশনটি একটি ভিউ হতে পারে কারণ এটি স্টেট পরিবর্তন করে না। অপারেটিং খরচ কমাতে, যেকোনো ফাংশন যা ভিউ হতে পারে তা ভিউ _হওয়া উচিত_।

```python
@internal
def _addTokenTo(_to: address, _tokenId: uint256):
    """
    @dev একটি প্রদত্ত অ্যাড্রেসে একটি NFT যোগ করুন
         যদি `_tokenId` কারও মালিকানাধীন থাকে তবে থ্রো করে।
    """
    # যদি `_tokenId` কারও মালিকানাধীন থাকে তবে থ্রো করে
    assert self.idToOwner[_tokenId] == ZERO_ADDRESS
    # মালিক পরিবর্তন করুন
    self.idToOwner[_tokenId] = _to
    # গণনা ট্র্যাকিং পরিবর্তন করুন
    self.ownerToNFTokenCount[_to] += 1


@internal
def _removeTokenFrom(_from: address, _tokenId: uint256):
    """
    @dev একটি প্রদত্ত অ্যাড্রেস থেকে একটি NFT সরান
         যদি `_from` বর্তমান মালিক না হয় তবে থ্রো করে।
    """
    # যদি `_from` বর্তমান মালিক না হয় তবে থ্রো করে
    assert self.idToOwner[_tokenId] == _from
    # মালিক পরিবর্তন করুন
    self.idToOwner[_tokenId] = ZERO_ADDRESS
    # গণনা ট্র্যাকিং পরিবর্তন করুন
    self.ownerToNFTokenCount[_from] -= 1
```

ট্রান্সফারে সমস্যা হলে আমরা কলটি রিভার্ট করি।

```python
@internal
def _clearApproval(_owner: address, _tokenId: uint256):
    """
    @dev একটি প্রদত্ত অ্যাড্রেসের একটি অনুমোদন পরিষ্কার করুন
         যদি `_owner` বর্তমান মালিক না হয় তবে থ্রো করে।
    """
    # যদি `_owner` বর্তমান মালিক না হয় তবে থ্রো করে
    assert self.idToOwner[_tokenId] == _owner
    if self.idToApprovals[_tokenId] != ZERO_ADDRESS:
        # অনুমোদন রিসেট করুন
        self.idToApprovals[_tokenId] = ZERO_ADDRESS
```

প্রয়োজন হলেই কেবল মান পরিবর্তন করুন। স্টেট ভ্যারিয়েবলগুলি স্টোরেজে থাকে। স্টোরেজে লেখা EVM (Ethereum Virtual Machine) এর অন্যতম ব্যয়বহুল অপারেশন ([গ্যাস](/developers/docs/gas/) এর পরিপ্রেক্ষিতে)। সুতরাং, এটি কমানো একটি ভাল ধারণা, এমনকি বিদ্যমান মান লেখারও একটি উচ্চ খরচ আছে।

```python
@internal
def _transferFrom(_from: address, _to: address, _tokenId: uint256, _sender: address):
    """
    @dev একটি NFT-এর ট্রান্সফার কার্যকর করুন।
         `msg.sender` যদি বর্তমান মালিক, একজন অনুমোদিত অপারেটর, বা এই NFT-এর জন্য অনুমোদিত
         অ্যাড্রেস না হয় তবে থ্রো করে। (দ্রষ্টব্য: `msg.sender` ব্যক্তিগত ফাংশনে অনুমোদিত নয় তাই `_sender` পাস করুন।)
         যদি `_to` শূন্য অ্যাড্রেস হয় তবে থ্রো করে।
         যদি `_from` বর্তমান মালিক না হয় তবে থ্রো করে।
         যদি `_tokenId` একটি বৈধ NFT না হয় তবে থ্রো করে।
    """
```

আমাদের এই অভ্যন্তরীণ ফাংশনটি আছে কারণ টোকেন ট্রান্সফার করার দুটি উপায় আছে (নিয়মিত এবং নিরাপদ), কিন্তু অডিটিং সহজ করার জন্য আমরা কোডের শুধুমাত্র একটি স্থানে এটি করতে চাই।

```python
    # প্রয়োজনীয়তা পরীক্ষা করুন
    assert self._isApprovedOrOwner(_sender, _tokenId)
    # `_to` যদি শূন্য ঠিকানা হয় তবে থ্রো করে
    assert _to != ZERO_ADDRESS
    # অনুমোদন সাফ করুন। `_from` যদি বর্তমান মালিক না হয় তবে থ্রো করে
    self._clearApproval(_from, _tokenId)
    # NFT সরান। `_tokenId` যদি একটি বৈধ NFT না হয় তবে থ্রো করে
    self._removeTokenFrom(_from, _tokenId)
    # NFT যোগ করুন
    self._addTokenTo(_to, _tokenId)
    # স্থানান্তরটি লগ করুন
    log Transfer(_from, _to, _tokenId)
```

Vyper-এ একটি ইভেন্ট নির্গত করতে আপনি একটি `log` স্টেটমেন্ট ব্যবহার করেন ([আরো বিস্তারিত জানার জন্য এখানে দেখুন](https://vyper.readthedocs.io/en/latest/event-logging.html#event-logging))।

#### ট্রান্সফার ফাংশন {#transfer-funs}

```python

### TRANSFER FUNCTIONS ###

@external
def transferFrom(_from: address, _to: address, _tokenId: uint256):
    """
    @dev `msg.sender` যদি বর্তমান মালিক, একজন অনুমোদিত অপারেটর বা এই NFT-এর জন্য অনুমোদিত ঠিকানা না হয় তবে থ্রো করে।
         যদি `_from` বর্তমান মালিক না হয় তবে থ্রো করে।
         যদি `_to` শূন্য ঠিকানা হয় তবে থ্রো করে।
         যদি `_tokenId` একটি বৈধ NFT না হয় তবে থ্রো করে।
    @notice `_to` NFT গ্রহণ করতে সক্ষম কিনা তা নিশ্চিত করার জন্য কলার দায়ী, অন্যথায় সেগুলি স্থায়ীভাবে হারিয়ে যেতে পারে।
    @param _from NFT-এর বর্তমান মালিক।
    @param _to নতুন মালিক।
    @param _tokenId যে NFTটি স্থানান্তর করতে হবে।
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

এই ফাংশনটি আপনাকে একটি নির্বিচারী ঠিকানায় স্থানান্তর করতে দেয়। যদি না ঠিকানাটি একজন ব্যবহারকারী, বা একটি চুক্তি যা টোকেন স্থানান্তর করতে জানে, তবে আপনি যে কোনও টোকেন স্থানান্তর করবেন তা সেই ঠিকানায় আটকে যাবে এবং অকেজো হয়ে যাবে।

```python
@external
def safeTransferFrom(
        _from: address,
        _to: address,
        _tokenId: uint256,
        _data: Bytes[1024]=b""
    ):
    """
    @dev একটি NFT-এর মালিকানা এক ঠিকানা থেকে অন্য ঠিকানায় স্থানান্তর করে।
         `msg.sender` যদি বর্তমান মালিক, একজন অনুমোদিত অপারেটর, বা এই NFT-এর জন্য অনুমোদিত ঠিকানা না হয় তবে থ্রো করে।
         যদি `_from` বর্তমান মালিক না হয় তবে থ্রো করে।
         যদি `_to` শূন্য ঠিকানা হয় তবে থ্রো করে।
         যদি `_tokenId` একটি বৈধ NFT না হয় তবে থ্রো করে।
         যদি `_to` একটি স্মার্ট চুক্তি হয়, তবে এটি `_to`-তে `onERC721Received` কল করে এবং রিটার্ন মান `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` না হলে থ্রো করে।
         দ্রষ্টব্য: bytes4 প্যাডিং সহ bytes32 দ্বারা প্রতিনিধিত্ব করা হয়
    @param _from NFT-এর বর্তমান মালিক।
    @param _to নতুন মালিক।
    @param _tokenId যে NFTটি স্থানান্তর করতে হবে।
    @param _data কোনও নির্দিষ্ট বিন্যাস ছাড়াই অতিরিক্ত ডেটা, যা `_to`-তে কলে পাঠানো হয়।
    """
    self._transferFrom(_from, _to, _tokenId, msg.sender)
```

প্রথমে স্থানান্তর করা ঠিক আছে কারণ যদি কোনও সমস্যা হয় তবে আমরা যাইহোক রিভার্ট করব, তাই কলে করা সবকিছু বাতিল হয়ে যাবে।

```python
    if _to.is_contract: # `_to` একটি চুক্তি ঠিকানা কিনা তা পরীক্ষা করুন
```

প্রথমে ঠিকানাটি একটি চুক্তি কিনা তা পরীক্ষা করুন (যদি এতে কোড থাকে)। যদি না হয়, তবে ধরে নিন এটি একটি ব্যবহারকারীর ঠিকানা এবং ব্যবহারকারী টোকেনটি ব্যবহার করতে বা স্থানান্তর করতে পারবে। কিন্তু এটি আপনাকে একটি মিথ্যা নিরাপত্তার অনুভূতিতে ঘুম পাড়িয়ে দেবেন না। আপনি `safeTransferFrom` দিয়েও টোকেন হারাতে পারেন, যদি আপনি সেগুলি এমন একটি ঠিকানায় স্থানান্তর করেন যার ব্যক্তিগত কী কেউ জানে না।

```python
        returnValue: bytes32 = ERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data)
```

লক্ষ্য চুক্তিটি ERC-721 টোকেন গ্রহণ করতে পারে কিনা তা দেখতে কল করুন।

```python
        # যদি স্থানান্তর গন্তব্য এমন একটি চুক্তি হয় যা 'onERC721Received' প্রয়োগ করে না তবে থ্রো করে
        assert returnValue == method_id("onERC721Received(address,address,uint256,bytes)", output_type=bytes32)
```

যদি গন্তব্য একটি চুক্তি হয়, কিন্তু এমন একটি যা ERC-721 টোকেন গ্রহণ করে না (বা যা এই বিশেষ স্থানান্তরটি গ্রহণ না করার সিদ্ধান্ত নিয়েছে), তবে রিভার্ট করুন।

```python
@external
def approve(_approved: address, _tokenId: uint256):
    """
    @dev একটি NFT-এর জন্য অনুমোদিত ঠিকানা সেট করুন বা পুনরায় নিশ্চিত করুন। শূন্য ঠিকানা নির্দেশ করে যে কোনও অনুমোদিত ঠিকানা নেই।
         `msg.sender` যদি বর্তমান NFT মালিক বা বর্তমান মালিকের একজন অনুমোদিত অপারেটর না হয় তবে থ্রো করে।
         যদি `_tokenId` একটি বৈধ NFT না হয় তবে থ্রো করে। (দ্রষ্টব্য: এটি EIP-তে লেখা নেই)
         যদি `_approved` বর্তমান মালিক হয় তবে থ্রো করে। (দ্রষ্টব্য: এটি EIP-তে লেখা নেই)
    @param _approved প্রদত্ত NFT আইডির জন্য অনুমোদিত হতে যাওয়া ঠিকানা।
    @param _tokenId অনুমোদিত হতে যাওয়া টোকেনের আইডি।
    """
    owner: address = self.idToOwner[_tokenId]
    # `_tokenId` যদি একটি বৈধ NFT না হয় তবে থ্রো করে
    assert owner != ZERO_ADDRESS
    # `_approved` যদি বর্তমান মালিক হয় তবে থ্রো করে
    assert _approved != owner
```

প্রথা অনুযায়ী যদি আপনি কোনও অনুমোদনকারী না রাখতে চান তবে আপনি শূন্য ঠিকানা নিয়োগ করেন, নিজেকে নয়।

```python
    # প্রয়োজনীয়তা পরীক্ষা করুন
    senderIsOwner: bool = self.idToOwner[_tokenId] == msg.sender
    senderIsApprovedForAll: bool = (self.ownerToOperators[owner])[msg.sender]
    assert (senderIsOwner or senderIsApprovedForAll)
```

একটি অনুমোদন সেট করতে আপনি হয় মালিক হতে পারেন, অথবা মালিক দ্বারা অনুমোদিত একজন অপারেটর হতে পারেন।

```python
    # অনুমোদন সেট করুন
    self.idToApprovals[_tokenId] = _approved
    log Approval(owner, _approved, _tokenId)


@external
def setApprovalForAll(_operator: address, _approved: bool):
    """
    @dev `msg.sender`-এর সমস্ত সম্পদ পরিচালনার জন্য একটি তৃতীয় পক্ষের ("অপারেটর") জন্য অনুমোদন সক্ষম বা অক্ষম করে। এটি ApprovalForAll ইভেন্টও নির্গত করে।
         যদি `_operator` `msg.sender` হয় তবে থ্রো করে। (দ্রষ্টব্য: এটি EIP-তে লেখা নেই)
    @notice এটি কাজ করে এমনকি যদি প্রেরক সেই সময়ে কোনও টোকেনের মালিক নাও হন।
    @param _operator অনুমোদিত অপারেটরদের সেটে যোগ করার জন্য ঠিকানা।
    @param _approved অপারেটর অনুমোদিত হলে সত্য, অনুমোদন প্রত্যাহার করতে মিথ্যা।
    """
    # `_operator` যদি `msg.sender` হয় তবে থ্রো করে
    assert _operator != msg.sender
    self.ownerToOperators[msg.sender][_operator] = _approved
    log ApprovalForAll(msg.sender, _operator, _approved)
```

#### নতুন টোকেন মিন্ট করুন এবং বিদ্যমানগুলি ধ্বংস করুন {#mint-burn}

যে অ্যাকাউন্টটি চুক্তিটি তৈরি করেছে সেটি হল `মিন্টার`, সুপার ব্যবহারকারী যা নতুন এনএফটি মিন্ট করার জন্য অনুমোদিত। তবে, এমনকি এটিও বিদ্যমান টোকেনগুলি পোড়াতে অনুমোদিত নয়। কেবল মালিক, বা মালিক দ্বারা অনুমোদিত একটি সত্তা এটি করতে পারে।

```python
### MINT & BURN FUNCTIONS ###

@external
def mint(_to: address, _tokenId: uint256) -> bool:
```

এই ফাংশনটি সর্বদা `সত্য` প্রদান করে, কারণ অপারেশন ব্যর্থ হলে এটি প্রত্যাবর্তন করা হয়।

```python
    """
    @dev টোকেন মিন্ট করার ফাংশন
         `msg.sender` যদি মিন্টার না হয় তবে থ্রো করে।
         যদি `_to` শূন্য ঠিকানা হয় তবে থ্রো করে।
         যদি `_tokenId` কারও মালিকানাধীন থাকে তবে থ্রো করে।
    @param _to যে ঠিকানাটি মিন্ট করা টোকেনগুলি গ্রহণ করবে।
    @param _tokenId মিন্ট করার জন্য টোকেন আইডি।
    @return একটি বুলিয়ান যা নির্দেশ করে যে অপারেশনটি সফল হয়েছে কিনা।
    """
    # `msg.sender` যদি মিন্টার না হয় তবে থ্রো করে
    assert msg.sender == self.minter
```

শুধুমাত্র মিন্টার (যে অ্যাকাউন্টটি ERC-721 চুক্তিটি তৈরি করেছে) নতুন টোকেন মিন্ট করতে পারে। ভবিষ্যতে যদি আমরা মিন্টারের পরিচয় পরিবর্তন করতে চাই তবে এটি একটি সমস্যা হতে পারে। একটি প্রোডাকশন চুক্তিতে আপনি সম্ভবত এমন একটি ফাংশন চাইবেন যা মিন্টারকে মিন্টার সুবিধা অন্য কাউকে স্থানান্তর করতে দেয়।

```python
    # `_to` যদি শূন্য ঠিকানা হয় তবে থ্রো করে
    assert _to != ZERO_ADDRESS
    # NFT যোগ করুন। `_tokenId` যদি কারও মালিকানাধীন থাকে তবে থ্রো করে
    self._addTokenTo(_to, _tokenId)
    log Transfer(ZERO_ADDRESS, _to, _tokenId)
    return True
```

প্রথা অনুযায়ী, নতুন টোকেন মিন্ট করা শূন্য ঠিকানা থেকে একটি স্থানান্তর হিসাবে গণ্য হয়।

```python

@external
def burn(_tokenId: uint256):
    """
    @dev একটি নির্দিষ্ট ERC721 টোকেন পোড়ায়।
         `msg.sender` যদি বর্তমান মালিক, একজন অনুমোদিত অপারেটর, বা এই NFT-এর জন্য অনুমোদিত ঠিকানা না হয় তবে থ্রো করে।
         যদি `_tokenId` একটি বৈধ NFT না হয় তবে থ্রো করে।
    @param _tokenId পোড়ানোর জন্য ERC721 টোকেনের uint256 আইডি।
    """
    # প্রয়োজনীয়তা পরীক্ষা করুন
    assert self._isApprovedOrOwner(msg.sender, _tokenId)
    owner: address = self.idToOwner[_tokenId]
    # `_tokenId` যদি একটি বৈধ NFT না হয় তবে থ্রো করে
    assert owner != ZERO_ADDRESS
    self._clearApproval(owner, _tokenId)
    self._removeTokenFrom(owner, _tokenId)
    log Transfer(owner, ZERO_ADDRESS, _tokenId)
```

যেকেউ যে একটি টোকেন স্থানান্তর করতে অনুমোদিত, সে এটি পোড়াতেও অনুমোদিত। যদিও একটি পোড়ানো শূন্য ঠিকানায় স্থানান্তরের সমতুল্য বলে মনে হয়, শূন্য ঠিকানা আসলে টোকেনটি গ্রহণ করে না। এটি আমাদের টোকেনের জন্য ব্যবহৃত সমস্ত স্টোরেজ মুক্ত করতে দেয়, যা লেনদেনের গ্যাস খরচ কমাতে পারে।

## এই চুক্তিটি ব্যবহার করা {#using-contract}

Solidity-এর বিপরীতে, Vyper-এর ইনহেরিটেন্স নেই। এটি একটি ইচ্ছাকৃত ডিজাইনের সিদ্ধান্ত যা কোডকে আরও স্পষ্ট এবং সুরক্ষিত করা সহজ করে তোলে। তাই আপনার নিজের Vyper ERC-721 চুক্তি তৈরি করতে আপনি [এই চুক্তিটি](https://github.com/vyperlang/vyper/blob/master/examples/tokens/ERC721.vy) নিন এবং আপনার কাঙ্খিত ব্যবসায়িক যুক্তি প্রয়োগ করতে এটি পরিবর্তন করুন।

## উপসংহার {#conclusion}

পর্যালোচনার জন্য, এই চুক্তির কয়েকটি সবচেয়ে গুরুত্বপূর্ণ ধারণা এখানে দেওয়া হল:

- নিরাপদ ট্রান্সফারের মাধ্যমে ERC-721 টোকেন পেতে, কন্ট্র্যাক্টগুলিকে `ERC721Receiver` ইন্টারফেসটি ইমপ্লিমেন্ট করতে হবে।
- এমনকি যদি আপনি নিরাপদ ট্রান্সফার ব্যবহার করেন, তবুও টোকেনগুলি আটকে যেতে পারে যদি আপনি সেগুলিকে এমন একটি অ্যাড্রেসে পাঠান যার প্রাইভেট কি অজানা।
- যখন কোনও অপারেশনে সমস্যা হয় তখন কেবল একটি ব্যর্থতার মান ফেরত দেওয়ার পরিবর্তে কলটি `রিভার্ট` করা একটি ভাল ধারণা।
- ERC-721 টোকেনগুলির অস্তিত্ব থাকে যখন তাদের একজন মালিক থাকে।
- একটি NFT স্থানান্তর করার জন্য অনুমোদিত হওয়ার তিনটি উপায় আছে। আপনি মালিক হতে পারেন, একটি নির্দিষ্ট টোকেনের জন্য অনুমোদিত হতে পারেন, অথবা মালিকের সমস্ত টোকেনের জন্য একজন অপারেটর হতে পারেন।
- অতীতের ইভেন্টগুলি কেবল ব্লকচেইনের বাইরে দৃশ্যমান। ব্লকচেইনের ভিতরে চলমান কোড সেগুলি দেখতে পারে না।

এখন যান এবং সুরক্ষিত Vyper চুক্তিগুলি প্রয়োগ করুন।

[আমার আরও কাজের জন্য এখানে দেখুন](https://cryptodocguy.pro/)।

