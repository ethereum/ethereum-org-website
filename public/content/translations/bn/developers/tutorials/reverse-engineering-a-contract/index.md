---
title: "একটি চুক্তির রিভার্স ইঞ্জিনিয়ারিং"
description: "আপনার কাছে সোর্স কোড না থাকলে কীভাবে একটি চুক্তি বুঝবেন"
author: Ori Pomerantz
lang: bn
tags: [ "evm", "অপকোডস" ]
skill: advanced
published: 2021-12-30
---

## ভূমিকা {#introduction}

_ব্লকচেইনে কোনো গোপনীয়তা নেই_, যা কিছু ঘটে তা সামঞ্জস্যপূর্ণ, যাচাইযোগ্য এবং সর্বজনীনভাবে উপলব্ধ। বিশেষত, [চুক্তিগুলির সোর্স কোড Etherscan-এ প্রকাশিত এবং যাচাই করা উচিত](https://etherscan.io/address/0xb8901acb165ed027e32754e0ffe830802919727f#code)। তবে, [সব সময় এমনটা হয় না](https://etherscan.io/address/0x2510c039cc3b061d79e564b38836da87e31b342f#code)। এই নিবন্ধে আপনি সোর্স কোড ছাড়াই একটি চুক্তির দিকে তাকিয়ে কীভাবে চুক্তিগুলি বিপরীত প্রকৌশলী করতে হয় তা শিখবেন, [`0x2510c039cc3b061d79e564b38836da87e31b342f`](https://etherscan.io/address/0x2510c039cc3b061d79e564b38836da87e31b342f)।

রিভার্স কম্পাইলার আছে, কিন্তু তারা সবসময় [ব্যবহারযোগ্য ফলাফল](https://etherscan.io/bytecode-decompiler?a=0x2510c039cc3b061d79e564b38836da87e31b342f) তৈরি করে না। এই নিবন্ধে আপনি কীভাবে ম্যানুয়ালি রিভার্স ইঞ্জিনিয়ারিং করতে হয় এবং [অপকোড](https://github.com/wolflo/evm-opcodes) থেকে একটি চুক্তি বুঝতে হয়, সেইসাথে একটি ডিকম্পাইলারের ফলাফল কীভাবে ব্যাখ্যা করতে হয় তা শিখবেন।

এই নিবন্ধটি বোঝার জন্য আপনার আগে থেকেই EVM-এর মূল বিষয়গুলি জানা উচিত এবং EVM অ্যাসেম্বলারের সাথে কিছুটা পরিচিত হওয়া উচিত। [আপনি এখানে এই বিষয়গুলি সম্পর্কে পড়তে পারেন](https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e)।

## এক্সিকিউটেবল কোড প্রস্তুত করুন {#prepare-the-executable-code}

আপনি চুক্তির জন্য Etherscan-এ গিয়ে, **চুক্তি** ট্যাবে ক্লিক করে এবং তারপর **অপকোড ভিউতে স্যুইচ করুন** ক্লিক করে অপকোডগুলি পেতে পারেন। আপনি একটি ভিউ পাবেন যা প্রতি লাইনে একটি অপকোড।

![Etherscan থেকে অপকোড ভিউ](opcode-view.png)

জাম্প বুঝতে সক্ষম হওয়ার জন্য, তবে, আপনাকে জানতে হবে কোডের মধ্যে প্রতিটি অপকোড কোথায় অবস্থিত। এটি করার জন্য, একটি উপায় হল একটি Google স্প্রেডশীট খোলা এবং কলাম C-তে অপকোডগুলি পেস্ট করা। [আপনি এই ইতিমধ্যে প্রস্তুত করা স্প্রেডশীটের একটি অনুলিপি তৈরি করে নিম্নলিখিত ধাপগুলি এড়িয়ে যেতে পারেন](https://docs.google.com/spreadsheets/d/1tKmTJiNjUwHbW64wCKOSJxHjmh0bAUapt6btUYE7kDA/edit?usp=sharing)।

পরবর্তী ধাপ হল সঠিক কোড অবস্থানগুলি পাওয়া যাতে আমরা জাম্প বুঝতে সক্ষম হব। আমরা কলাম B-তে অপকোডের আকার এবং কলাম A-তে অবস্থান (হেক্সাডেসিমেলে) রাখব। সেল `B1`-এ এই ফাংশনটি টাইপ করুন এবং তারপরে কোডের শেষ পর্যন্ত কলাম B-এর বাকি অংশের জন্য এটি কপি এবং পেস্ট করুন। আপনি এটি করার পরে আপনি কলাম B লুকাতে পারেন।

```
=1+IF(REGEXMATCH(C1,"PUSH"),REGEXEXTRACT(C1,"PUSH(\d+)"),0)
```

প্রথমে এই ফাংশনটি অপকোডের জন্য এক বাইট যোগ করে, এবং তারপর `PUSH`-এর জন্য সন্ধান করে। পুশ অপকোডগুলি বিশেষ কারণ তাদের পুশ করা মানের জন্য অতিরিক্ত বাইটের প্রয়োজন। যদি অপকোডটি একটি `PUSH` হয়, আমরা বাইটের সংখ্যা বের করে এবং তা যোগ করি।

`A1`-এ প্রথম অফসেট, শূন্য রাখুন। তারপর, `A2`-এ, এই ফাংশনটি রাখুন এবং আবার কলাম A-এর বাকি অংশের জন্য এটি কপি এবং পেস্ট করুন:

```
=dec2hex(hex2dec(A1)+B1)
```

আমাদের এই ফাংশনটি হেক্সাডেসিমেল মান দেওয়ার জন্য প্রয়োজন কারণ জাম্প (`JUMP` এবং `JUMPI`) এর আগে যে মানগুলি পুশ করা হয় তা আমাদের হেক্সাডেসিমেলে দেওয়া হয়।

## এন্ট্রি পয়েন্ট (0x00) {#the-entry-point-0x00}

চুক্তি সবসময় প্রথম বাইট থেকে কার্যকর করা হয়। এটি কোডের প্রাথমিক অংশ:

| অফসেট | অপকোড        | স্ট্যাক (অপকোডের পরে)     |
| ----: | ------------ | -------------------------------------------- |
|     0 | PUSH1 0x80   | 0x80                                         |
|     2 | PUSH1 0x40   | 0x40, 0x80                                   |
|     4 | MSTORE       | খালি                                         |
|     5 | PUSH1 0x04   | 0x04                                         |
|     7 | CALLDATASIZE | CALLDATASIZE 0x04                            |
|     8 | LT           | CALLDATASIZE<4      |
|     9 | PUSH2 0x005e | 0x5E CALLDATASIZE<4 |
|     C | JUMPI        | খালি                                         |

এই কোডটি দুটি কাজ করে:

1. মেমরি অবস্থান 0x40-0x5F-এ 32 বাইট মান হিসাবে 0x80 লিখুন (0x80 0x5F-এ সংরক্ষিত হয়, এবং 0x40-0x5E সবই শূন্য)।
2. কলডেটা আকার পড়ুন। সাধারণত একটি Ethereum চুক্তির জন্য কল ডেটা [ABI (অ্যাপ্লিকেশন বাইনারি ইন্টারফেস)](https://docs.soliditylang.org/en/v0.8.10/abi-spec.html) অনুসরণ করে, যার জন্য ফাংশন নির্বাচকের জন্য ন্যূনতম চার বাইটের প্রয়োজন হয়। কল ডেটার আকার চারের কম হলে, 0x5E-এ যান।

![এই অংশের জন্য ফ্লোচার্ট](flowchart-entry.png)

### 0x5E-তে হ্যান্ডলার (নন-ABI কল ডেটার জন্য) {#the-handler-at-0x5e-for-non-abi-call-data}

| অফসেট | অপকোড        |
| ----: | ------------ |
|    5E | JUMPDEST     |
|    5F | CALLDATASIZE |
|    60 | PUSH2 0x007c |
|    63 | JUMPI        |

এই স্নিপেটটি একটি `JUMPDEST` দিয়ে শুরু হয়। EVM (ইথিরিয়াম ভার্চুয়াল মেশিন) প্রোগ্রাম একটি ব্যতিক্রম ছুড়ে দেয় যদি আপনি এমন একটি অপকোডে লাফ দেন যা `JUMPDEST` নয়। তারপর এটি CALLDATASIZE-এর দিকে তাকায়, এবং যদি এটি "সত্য" হয় (অর্থাৎ, শূন্য নয়) 0x7C-তে চলে যায়। আমরা নিচে সেই ব্যাপারে আসব।

| অফসেট | অপকোড      | স্ট্যাক (অপকোডের পরে)                                                  |
| ----: | ---------- | ----------------------------------------------------------------------------------------- |
|    64 | CALLVALUE  | কল দ্বারা প্রদত্ত [Wei](/glossary/#wei)। Solidity-তে `msg.value` বলা হয়।                 |
|    65 | PUSH1 0x06 | 6 CALLVALUE                                                                               |
|    67 | PUSH1 0x00 | 0 6 CALLVALUE                                                                             |
|    69 | DUP3       | CALLVALUE 0 6 CALLVALUE                                                                   |
|    6A | DUP3       | 6 CALLVALUE 0 6 CALLVALUE                                                                 |
|    6B | SLOAD      | সংগ্রহস্থল[6] CALLVALUE 0 6 CALLVALUE |

সুতরাং যখন কোন কল ডেটা থাকে না তখন আমরা Storage[6] এর মান পড়ি। আমরা এখনও জানি না এই মানটি কী, কিন্তু আমরা এমন লেনদেনগুলি দেখতে পারি যা চুক্তিটি কোনও কল ডেটা ছাড়াই পেয়েছে। যে লেনদেনগুলি শুধুমাত্র কোনও কল ডেটা ছাড়াই ETH স্থানান্তর করে (এবং তাই কোনও পদ্ধতি নেই) Etherscan-এ `Transfer` পদ্ধতি রয়েছে। প্রকৃতপক্ষে, [চুক্তিটি প্রাপ্ত প্রথম লেনদেন](https://etherscan.io/tx/0xeec75287a583c36bcc7ca87685ab41603494516a0f5986d18de96c8e630762e7) একটি স্থানান্তর।

আমরা যদি সেই লেনদেনটি দেখি এবং **আরও দেখতে ক্লিক করুন** ক্লিক করি, আমরা দেখতে পাই যে কল ডেটা, যাকে ইনপুট ডেটা বলা হয়, তা সত্যিই খালি (`0x`)। এও লক্ষ্য করুন যে মানটি 1.559 ETH, যা পরে প্রাসঙ্গিক হবে।

![কল ডেটা খালি](calldata-empty.png)

এরপরে, **অবস্থা** ট্যাবে ক্লিক করুন এবং আমরা যে চুক্তিটি বিপরীত প্রকৌশলী করছি তা প্রসারিত করুন (0x2510...)। আপনি দেখতে পারেন যে লেনদেনের সময় `Storage[6]` পরিবর্তিত হয়েছে, এবং আপনি যদি হেক্সকে **সংখ্যা**-তে পরিবর্তন করেন, আপনি দেখতে পাবেন এটি 1,559,000,000,000,000,000 হয়ে গেছে, wei-তে স্থানান্তরিত মান (আমি স্পষ্টতার জন্য কমা যোগ করেছি), যা পরবর্তী চুক্তির মানের সাথে সঙ্গতিপূর্ণ।

![Storage[6]-এর পরিবর্তন](storage6.png)

যদি আমরা [একই সময়কালের অন্যান্য `Transfer` লেনদেনের](https://etherscan.io/tx/0xf708d306de39c422472f43cb975d97b66fd5d6a6863db627067167cbf93d84d1#statechange) দ্বারা সৃষ্ট অবস্থার পরিবর্তনগুলি দেখি, আমরা দেখতে পাই যে `Storage[6]` কিছু সময়ের জন্য চুক্তির মান ট্র্যাক করেছে। আপাতত আমরা এটিকে `Value*` বলব। তারকাচিহ্ন (`*`) আমাদের মনে করিয়ে দেয় যে আমরা এখনও _জানি_ না এই ভেরিয়েবলটি কী করে, কিন্তু এটি শুধুমাত্র চুক্তির মান ট্র্যাক করার জন্য হতে পারে না কারণ স্টোরেজ ব্যবহার করার কোন প্রয়োজন নেই, যা খুব ব্যয়বহুল, যখন আপনি `ADDRESS BALANCE` ব্যবহার করে আপনার অ্যাকাউন্টের ব্যালেন্স পেতে পারেন। প্রথম অপকোডটি চুক্তির নিজস্ব ঠিকানা পুশ করে। দ্বিতীয়টি স্ট্যাকের শীর্ষে থাকা ঠিকানাটি পড়ে এবং সেই ঠিকানার ব্যালেন্স দিয়ে এটি প্রতিস্থাপন করে।

| অফসেট | অপকোড        | স্ট্যাক                                     |
| ----: | ------------ | ------------------------------------------- |
|    6C | PUSH2 0x0075 | 0x75 Value\* CALLVALUE 0 6 CALLVALUE        |
|    6F | SWAP2        | CALLVALUE Value\* 0x75 0 6 CALLVALUE        |
|    70 | SWAP1        | Value\* CALLVALUE 0x75 0 6 CALLVALUE        |
|    71 | PUSH2 0x01a7 | 0x01A7 Value\* CALLVALUE 0x75 0 6 CALLVALUE |
|    74 | JUMP         |                                             |

আমরা জাম্প ডেস্টিনেশনে এই কোডটি ট্রেস করতে থাকব।

| অফসেট | অপকোড      | স্ট্যাক                                                     |
| ----: | ---------- | ----------------------------------------------------------- |
|   1A7 | JUMPDEST   | Value\* CALLVALUE 0x75 0 6 CALLVALUE                        |
|   1A8 | PUSH1 0x00 | 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE                   |
|   1AA | DUP3       | CALLVALUE 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE         |
|   1AB | NOT        | 2^256-CALLVALUE-1 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE |

`NOT` বিটওয়াইজ, তাই এটি কল মানের প্রতিটি বিটের মান বিপরীত করে।

| অফসেট | অপকোড        | স্ট্যাক                                                                                              |
| ----: | ------------ | ---------------------------------------------------------------------------------------------------- |
|   1AC | DUP3         | Value\* 2^256-CALLVALUE-1 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE                                  |
|   1AD | GT           | Value\*>2^256-CALLVALUE-1 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE                                  |
|   1AE | ISZERO       | Value\*<=2^256-CALLVALUE-1 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE        |
|   1AF | PUSH2 0x01df | 0x01DF Value\*<=2^256-CALLVALUE-1 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE |
|   1B2 | JUMPI        |                                                                                                      |

আমরা লাফ দিই যদি `Value*` 2^256-CALLVALUE-1 এর থেকে ছোট বা এর সমান হয়। এটি ওভারফ্লো প্রতিরোধের জন্য যুক্তি বলে মনে হচ্ছে। এবং প্রকৃতপক্ষে, আমরা দেখতে পাই যে কয়েকটি অর্থহীন ক্রিয়াকলাপের পরে (উদাহরণস্বরূপ, মেমরিতে লেখা মুছে ফেলা হবে) অফসেট 0x01DE-তে চুক্তিটি বিপরীত হয় যদি ওভারফ্লো সনাক্ত করা হয়, যা স্বাভাবিক আচরণ।

লক্ষ্য করুন যে এই ধরনের একটি ওভারফ্লো অত্যন্ত অসম্ভাব্য, কারণ এটির জন্য কল মান এবং `Value*` এর যোগফল 2^256 wei-এর সাথে তুলনীয় হতে হবে, যা প্রায় 10^59 ETH। [লেখার সময়, মোট ETH সরবরাহ দুইশ মিলিয়নেরও কম](https://etherscan.io/stat/supply)।

| অফসেট | অপকোড    | স্ট্যাক                                   |
| ----: | -------- | ----------------------------------------- |
|   1DF | JUMPDEST | 0x00 Value\* CALLVALUE 0x75 0 6 CALLVALUE |
|   1E0 | POP      | Value\* CALLVALUE 0x75 0 6 CALLVALUE      |
|   1E1 | ADD      | Value\*+CALLVALUE 0x75 0 6 CALLVALUE      |
|   1E2 | SWAP1    | 0x75 Value\*+CALLVALUE 0 6 CALLVALUE      |
|   1E3 | JUMP     |                                           |

আমরা যদি এখানে আসি, তাহলে `Value* + CALLVALUE` নিন এবং অফসেট 0x75-এ যান।

| অফসেট | অপকোড    | স্ট্যাক                         |
| ----: | -------- | ------------------------------- |
|    75 | JUMPDEST | Value\*+CALLVALUE 0 6 CALLVALUE |
|    76 | SWAP1    | 0 Value\*+CALLVALUE 6 CALLVALUE |
|    77 | SWAP2    | 6 Value\*+CALLVALUE 0 CALLVALUE |
|    78 | SSTORE   | 0 CALLVALUE                     |

যদি আমরা এখানে আসি (যার জন্য কল ডেটা খালি হতে হবে) আমরা `Value*`-এর সাথে কল মান যোগ করি। এটি `Transfer` লেনদেনগুলি যা করে তার সাথে সামঞ্জস্যপূর্ণ।

| অফসেট | অপকোড |
| ----: | ----- |
|    79 | POP   |
|    7A | POP   |
|    7B | STOP  |

অবশেষে, স্ট্যাকটি পরিষ্কার করুন (যা প্রয়োজনীয় নয়) এবং লেনদেনের সফল সমাপ্তির সংকেত দিন।

সবকিছু সংক্ষেপে বলতে গেলে, এখানে প্রাথমিক কোডের জন্য একটি ফ্লোচার্ট রয়েছে।

![এন্ট্রি পয়েন্ট ফ্লোচার্ট](flowchart-entry.png)

## 0x7C-তে হ্যান্ডলার {#the-handler-at-0x7c}

আমি ইচ্ছাকৃতভাবে শিরোনামে রাখিনি যে এই হ্যান্ডলারটি কী করে। মূল বিষয় হল আপনাকে এই নির্দিষ্ট চুক্তিটি কীভাবে কাজ করে তা শেখানো নয়, বরং কীভাবে চুক্তিগুলির রিভার্স ইঞ্জিনিয়ারিং করতে হয় তা শেখানো। আপনি কোড অনুসরণ করে শিখবেন এটি কী করে, ঠিক যেমন আমি শিখেছি।

আমরা এখানে বেশ কয়েকটি জায়গা থেকে আসি:

- যদি 1, 2, বা 3 বাইটের কল ডেটা থাকে (অফসেট 0x63 থেকে)
- যদি পদ্ধতির স্বাক্ষর অজানা থাকে (অফসেট 0x42 এবং 0x5D থেকে)

| অফসেট | অপকোড        | স্ট্যাক                                                                     |
| ----: | ------------ | --------------------------------------------------------------------------- |
|    7C | JUMPDEST     |                                                                             |
|    7D | PUSH1 0x00   | 0x00                                                                        |
|    7F | PUSH2 0x009d | 0x9D 0x00                                                                   |
|    82 | PUSH1 0x03   | 0x03 0x9D 0x00                                                              |
|    84 | SLOAD        | সংগ্রহস্থল[3] 0x9D 0x00 |

এটি আরেকটি স্টোরেজ সেল, যা আমি কোনও লেনদেনে খুঁজে পাইনি তাই এর অর্থ কী তা জানা কঠিন। নীচের কোডটি এটিকে আরও স্পষ্ট করবে।

| অফসেট | অপকোড                                             | স্ট্যাক                                                                                                                                                |
| ----: | ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
|    85 | PUSH20 0xffffffffffffffffffffffffffffffffffffffff | 0xff....ff সংগ্রহস্থল[3] 0x9D 0x00 |
|    9A | AND                                               | সংগ্রহস্থল[3]-ঠিকানা-হিসাবে 0x9D 0x00                                                              |

এই অপকোডগুলি আমরা Storage[3] থেকে পড়া মানটিকে 160 বিটে ছোট করে দেয়, যা একটি Ethereum ঠিকানার দৈর্ঘ্য।

| অফসেট | অপকোড | স্ট্যাক                                                                                   |
| ----: | ----- | ----------------------------------------------------------------------------------------- |
|    9B | SWAP1 | 0x9D সংগ্রহস্থল[3]-ঠিকানা-হিসাবে 0x00 |
|    9C | JUMP  | সংগ্রহস্থল[3]-ঠিকানা-হিসাবে 0x00      |

এই জাম্পটি অপ্রয়োজনীয়, কারণ আমরা পরবর্তী অপকোডে যাচ্ছি। এই কোডটি যতটা গ্যাস-দক্ষ হতে পারত ততটা নয়।

| অফসেট | অপকোড      | স্ট্যাক                                                                                                                                       |
| ----: | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
|    9D | JUMPDEST   | সংগ্রহস্থল[3]-ঠিকানা-হিসাবে 0x00                                                          |
|    9E | SWAP1      | 0x00 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                          |
|    9F | POP        | সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                               |
|    A0 | PUSH1 0x40 | 0x40 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                          |
|    A2 | MLOAD      | Mem[0x40] সংগ্রহস্থল[3]-ঠিকানা-হিসাবে |

কোডের একেবারে শুরুতে আমরা Mem[0x40] কে 0x80 তে সেট করি। যদি আমরা পরে 0x40 খুঁজি, আমরা দেখতে পাই যে আমরা এটি পরিবর্তন করি না - তাই আমরা ধরে নিতে পারি এটি 0x80।

| অফসেট | অপকোড        | স্ট্যাক                                                                                                     |
| ----: | ------------ | ----------------------------------------------------------------------------------------------------------- |
|    A3 | CALLDATASIZE | CALLDATASIZE 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে           |
|    A4 | PUSH1 0x00   | 0x00 CALLDATASIZE 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে      |
|    A6 | DUP3         | 0x80 0x00 CALLDATASIZE 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে |
|    A7 | CALLDATACOPY | 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                        |

সমস্ত কল ডেটা মেমরিতে অনুলিপি করুন, 0x80 থেকে শুরু করে।

| অফসেট | অপকোড                              | স্ট্যাক                                                                                                                                                                                              |
| ----: | ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    A8 | PUSH1 0x00                         | 0x00 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                                                            |
|    AA | DUP1                               | 0x00 0x00 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                                                       |
|    AB | CALLDATASIZE                       | CALLDATASIZE 0x00 0x00 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                                          |
|    AC | DUP4                               | 0x80 CALLDATASIZE 0x00 0x00 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                                     |
|    AD | DUP6                               | সংগ্রহস্থল[3]-ঠিকানা-হিসাবে 0x80 CALLDATASIZE 0x00 0x00 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে     |
|    AE | GAS                                | GAS সংগ্রহস্থল[3]-ঠিকানা-হিসাবে 0x80 CALLDATASIZE 0x00 0x00 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে |
|    AF | DELEGATE_CALL |                                                                                                                                                                                                      |

এখন জিনিসগুলি অনেক পরিষ্কার। এই চুক্তিটি একটি [প্রক্সি](https://blog.openzeppelin.com/proxy-patterns/) হিসাবে কাজ করতে পারে, আসল কাজটি করার জন্য Storage[3]-এর ঠিকানায় কল করে। `DELEGATE_CALL` একটি পৃথক চুক্তিকে কল করে, কিন্তু একই স্টোরেজে থাকে। এর মানে হল যে অর্পিত চুক্তি, যার জন্য আমরা একটি প্রক্সি, একই স্টোরেজ স্পেস অ্যাক্সেস করে। কলের জন্য প্যারামিটারগুলি হল:

- _গ্যাস_: বাকি সব গ্যাস
- _কল করা ঠিকানা_: সংগ্রহস্থল[3]-ঠিকানা-হিসাবে
- _কল ডেটা_: CALLDATASIZE বাইট 0x80 থেকে শুরু, যেখানে আমরা আসল কল ডেটা রাখি।
- _রিটার্ন ডেটা_: কোনোটিই নয় (0x00 - 0x00) আমরা অন্য উপায়ে রিটার্ন ডেটা পাব (নীচে দেখুন)

| অফসেট | অপকোড          | স্ট্যাক                                                                                                                                                                                                       |
| ----: | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    B0 | RETURNDATASIZE | RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                          |
|    B1 | DUP1           | RETURNDATASIZE RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে           |
|    B2 | PUSH1 0x00     | 0x00 RETURNDATASIZE RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে      |
|    B4 | DUP5           | 0x80 0x00 RETURNDATASIZE RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে |
|    B5 | RETURNDATACOPY | RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                          |

এখানে আমরা 0x80 থেকে শুরু করে মেমরি বাফারে সমস্ত রিটার্ন ডেটা কপি করি।

| অফসেট | অপকোড        | স্ট্যাক                                                                                                                                                                                                                                                                                                                                                          |
| ----: | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    B6 | DUP2         | (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                                            |
|    B7 | DUP1         | (((কল সফলতা/ব্যর্থতা))) (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে           |
|    B8 | ISZERO       | (((কলটি কি ব্যর্থ হয়েছিল))) (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে      |
|    B9 | PUSH2 0x00c0 | 0xC0 (((কলটি কি ব্যর্থ হয়েছিল))) (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে |
|    BC | JUMPI        | (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                                            |
|    BD | DUP2         | RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                             |
|    BE | DUP5         | 0x80 RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                                                                        |
|    BF | RETURN       |                                                                                                                                                                                                                                                                                                                                                                  |

সুতরাং কলের পরে আমরা রিটার্ন ডেটা বাফার 0x80 - 0x80+RETURNDATASIZE-এ অনুলিপি করি, এবং যদি কল সফল হয় তবে আমরা ঠিক সেই বাফার দিয়ে `RETURN` করি।

### DELEGATECALL ব্যর্থ হয়েছে {#delegatecall-failed}

আমরা যদি এখানে 0xC0-তে পৌঁছাই, তার মানে আমরা যে চুক্তিটি কল করেছি তা উল্টে গেছে। যেহেতু আমরা সেই চুক্তির জন্য শুধুমাত্র একটি প্রক্সি, তাই আমরা একই ডেটা ফেরত দিতে এবং রিভার্ট করতে চাই।

| অফসেট | অপকোড    | স্ট্যাক                                                                                                                                                                                                                                                                                   |
| ----: | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    C0 | JUMPDEST | (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে                     |
|    C1 | DUP2     | RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে      |
|    C2 | DUP5     | 0x80 RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) RETURNDATASIZE (((কল সফলতা/ব্যর্থতা))) 0x80 সংগ্রহস্থল[3]-ঠিকানা-হিসাবে |
|    C3 | REVERT   |                                                                                                                                                                                                                                                                                           |

সুতরাং আমরা আগে `RETURN`-এর জন্য যে বাফার ব্যবহার করেছি তার সাথে `REVERT` করি: 0x80 - 0x80+RETURNDATASIZE

![প্রক্সিতে কল ফ্লোচার্ট](flowchart-proxy.png)

## ABI কল {#abi-calls}

কল ডেটার আকার চার বাইট বা তার বেশি হলে এটি একটি বৈধ ABI কল হতে পারে।

| অফসেট | অপকোড        | স্ট্যাক                                                                                                              |
| ----: | ------------ | -------------------------------------------------------------------------------------------------------------------- |
|     D | PUSH1 0x00   | 0x00                                                                                                                 |
|     F | CALLDATALOAD | (((কল ডেটার প্রথম শব্দ (256 বিট))))      |
|    10 | PUSH1 0xe0   | 0xE0 (((কল ডেটার প্রথম শব্দ (256 বিট)))) |
|    12 | SHR          | (((কল ডেটার প্রথম 32 বিট (4 বাইট))))     |

Etherscan আমাদের জানায় যে `1C` একটি অজানা অপকোড, কারণ [Etherscan এই ফিচারটি লেখার পরে এটি যোগ করা হয়েছিল](https://eips.ethereum.org/EIPS/eip-145) এবং তারা এটি আপডেট করেনি। একটি [আপ-টু-ডেট অপকোড টেবিল](https://github.com/wolflo/evm-opcodes) আমাদের দেখায় যে এটি শিফট রাইট।

| অফসেট | অপকোড            | স্ট্যাক                                                                                                                                                                                                                                      |
| ----: | ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|    13 | DUP1             | (((কল ডেটার প্রথম 32 বিট (4 বাইট)))) (((কল ডেটার প্রথম 32 বিট (4 বাইট))))            |
|    14 | PUSH4 0x3cd8045e | 0x3CD8045E (((কল ডেটার প্রথম 32 বিট (4 বাইট)))) (((কল ডেটার প্রথম 32 বিট (4 বাইট)))) |
|    19 | GT               | 0x3CD8045E>কল-ডেটার-প্রথম-32-বিট (((কল ডেটার প্রথম 32 বিট (4 বাইট))))                                                                                            |
|    1A | PUSH2 0x0043     | 0x43 0x3CD8045E>কল-ডেটার-প্রথম-32-বিট (((কল ডেটার প্রথম 32 বিট (4 বাইট))))                                                                                       |
|    1D | JUMPI            | (((কল ডেটার প্রথম 32 বিট (4 বাইট))))                                                                                                                             |

মেথড সিগনেচার ম্যাচিং টেস্টকে এভাবে দুই ভাগে ভাগ করলে গড়ে অর্ধেক টেস্ট সাশ্রয় হয়। এর ঠিক পরের কোড এবং 0x43-এর কোড একই প্যাটার্ন অনুসরণ করে: কল ডেটার প্রথম 32 বিট `DUP1` করুন, `PUSH4 (((মেথড সিগনেচার))`, সমতার জন্য পরীক্ষা করতে `EQ` চালান, এবং তারপর `JUMPI` যদি মেথড সিগনেচার মিলে যায়। এখানে মেথড সিগনেচার, তাদের ঠিকানা এবং যদি জানা থাকে [সংশ্লিষ্ট মেথড সংজ্ঞা](https://www.4byte.directory/):

| পদ্ধতি                                                                                                    | মেথড সিগনেচার | ভিতরে ঝাঁপ দেওয়ার জন্য অফসেট |
| --------------------------------------------------------------------------------------------------------- | ------------- | ----------------------------- |
| [splitter()](https://www.4byte.directory/signatures/?bytes4_signature=0x3cd8045e)      | 0x3cd8045e    | 0x0103                        |
| ???                                                                                                       | 0x81e580d3    | 0x0138                        |
| [currentWindow()](https://www.4byte.directory/signatures/?bytes4_signature=0xba0bafb4) | 0xba0bafb4    | 0x0158                        |
| ???                                                                                                       | 0x1f135823    | 0x00C4                        |
| [merkleRoot()](https://www.4byte.directory/signatures/?bytes4_signature=0x2eb4a7ab)    | 0x2eb4a7ab    | 0x00ED                        |

যদি কোনও মিল খুঁজে না পাওয়া যায়, কোডটি [0x7C-এ প্রক্সি হ্যান্ডলারে](#the-handler-at-0x7c) ঝাঁপিয়ে পড়ে, এই আশায় যে আমরা যে চুক্তির জন্য প্রক্সি, তার একটি মিল রয়েছে।

![ABI কল ফ্লোচার্ট](flowchart-abi.png)

## splitter() {#splitter}

| অফসেট | অপকোড        | স্ট্যাক                       |
| ----: | ------------ | ----------------------------- |
|   103 | JUMPDEST     |                               |
|   104 | CALLVALUE    | CALLVALUE                     |
|   105 | DUP1         | CALLVALUE CALLVALUE           |
|   106 | ISZERO       | CALLVALUE==0 CALLVALUE        |
|   107 | PUSH2 0x010f | 0x010F CALLVALUE==0 CALLVALUE |
|   10A | JUMPI        | CALLVALUE                     |
|   10B | PUSH1 0x00   | 0x00 CALLVALUE                |
|   10D | DUP1         | 0x00 0x00 CALLVALUE           |
|   10E | REVERT       |                               |

এই ফাংশনটির প্রথম কাজ হল পরীক্ষা করা যে কলটি কোনো ETH পাঠিয়েছে কিনা। এই ফাংশনটি [`payable`](https://solidity-by-example.org/payable/) নয়। যদি কেউ আমাদের ETH পাঠায় তবে এটি অবশ্যই একটি ভুল এবং আমরা `REVERT` করতে চাই যাতে সেই ETH তারা ফেরত পেতে না পারে এমন জায়গায় না থাকে।

| অফসেট | অপকোড                                             | স্ট্যাক                                                                                                                                                                                                                                                                                   |
| ----: | ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   10F | JUMPDEST                                          |                                                                                                                                                                                                                                                                                           |
|   110 | POP                                               |                                                                                                                                                                                                                                                                                           |
|   111 | PUSH1 0x03                                        | 0x03                                                                                                                                                                                                                                                                                      |
|   113 | SLOAD                                             | (((সংগ্রহস্থল[3] এ.কে.এ. যে চুক্তির জন্য আমরা একটি প্রক্সি)))                                                                |
|   114 | PUSH1 0x40                                        | 0x40 (((সংগ্রহস্থল[3] এ.কে.এ. যে চুক্তির জন্য আমরা একটি প্রক্সি)))                                                           |
|   116 | MLOAD                                             | 0x80 (((সংগ্রহস্থল[3] এ.কে.এ. যে চুক্তির জন্য আমরা একটি প্রক্সি)))                                                           |
|   117 | PUSH20 0xffffffffffffffffffffffffffffffffffffffff | 0xFF...FF 0x80 (((সংগ্রহস্থল[3] এ.কে.এ. যে চুক্তির জন্য আমরা একটি প্রক্সি))) |
|   12C | SWAP1                                             | 0x80 0xFF...FF (((সংগ্রহস্থল[3] এ.কে.এ. যে চুক্তির জন্য আমরা একটি প্রক্সি))) |
|   12D | SWAP2                                             | (((সংগ্রহস্থল[3] এ.কে.এ. যে চুক্তির জন্য আমরা একটি প্রক্সি))) 0xFF...FF 0x80 |
|   12E | AND                                               | প্রক্সি ঠিকানা 0x80                                                                                                                                                                                                                                                                       |
|   12F | DUP2                                              | 0x80 প্রক্সি ঠিকানা 0x80                                                                                                                                                                                                                                                                  |
|   130 | MSTORE                                            | 0x80                                                                                                                                                                                                                                                                                      |

এবং 0x80 এখন প্রক্সি ঠিকানা ধারণ করে

| অফসেট | অপকোড        | স্ট্যাক   |
| ----: | ------------ | --------- |
|   131 | PUSH1 0x20   | 0x20 0x80 |
|   133 | ADD          | 0xA0      |
|   134 | PUSH2 0x00e4 | 0xE4 0xA0 |
|   137 | JUMP         | 0xA0      |

### E4 কোড {#the-e4-code}

এই লাইনগুলি আমরা প্রথমবার দেখছি, তবে সেগুলি অন্যান্য পদ্ধতির সাথে ভাগ করা হয়েছে (নীচে দেখুন)। তাই আমরা স্ট্যাকের মানটিকে X বলব, এবং শুধু মনে রাখব যে `splitter()` এ এই X-এর মান হল 0xA0।

| অফসেট | অপকোড      | স্ট্যাক     |
| ----: | ---------- | ----------- |
|    E4 | JUMPDEST   | X           |
|    E5 | PUSH1 0x40 | 0x40 X      |
|    E7 | MLOAD      | 0x80 X      |
|    E8 | DUP1       | 0x80 0x80 X |
|    E9 | SWAP2      | X 0x80 0x80 |
|    EA | SUB        | X-0x80 0x80 |
|    EB | SWAP1      | 0x80 X-0x80 |
|    EC | RETURN     |             |

সুতরাং এই কোডটি স্ট্যাকে একটি মেমরি পয়েন্টার (X) গ্রহণ করে এবং চুক্তিটিকে 0x80 - X বাফার দিয়ে `RETURN` করতে বাধ্য করে।

`splitter()`-এর ক্ষেত্রে, এটি সেই ঠিকানাটি ফেরত দেয় যার জন্য আমরা একটি প্রক্সি। `RETURN` বাফারটি 0x80-0x9F এ ফেরত দেয়, যেখানে আমরা এই ডেটাটি লিখেছি (উপরে অফসেট 0x130)।

## currentWindow() {#currentwindow}

অফসেট 0x158-0x163 এর কোডটি `splitter()`-এ 0x103-0x10E-এ যা দেখেছিলাম তার অনুরূপ (`JUMPI` গন্তব্য ছাড়া), তাই আমরা জানি `currentWindow()`ও `payable` নয়।

| অফসেট | অপকোড        | স্ট্যাক                                                                     |
| ----: | ------------ | --------------------------------------------------------------------------- |
|   164 | JUMPDEST     |                                                                             |
|   165 | POP          |                                                                             |
|   166 | PUSH2 0x00da | 0xDA                                                                        |
|   169 | PUSH1 0x01   | 0x01 0xDA                                                                   |
|   16B | SLOAD        | সংগ্রহস্থল[1] 0xDA      |
|   16C | DUP2         | 0xDA সংগ্রহস্থল[1] 0xDA |
|   16D | JUMP         | সংগ্রহস্থল[1] 0xDA      |

### DA কোড {#the-da-code}

এই কোডটি অন্যান্য পদ্ধতির সাথেও ভাগ করা হয়েছে। সুতরাং আমরা স্ট্যাকের মানটিকে Y বলব, এবং শুধু মনে রাখব যে `currentWindow()`-এ এই Y-এর মান হল সংগ্রহস্থল[1]।

| অফসেট | অপকোড      | স্ট্যাক          |
| ----: | ---------- | ---------------- |
|    DA | JUMPDEST   | Y 0xDA           |
|    DB | PUSH1 0x40 | 0x40 Y 0xDA      |
|    DD | MLOAD      | 0x80 Y 0xDA      |
|    DE | SWAP1      | Y 0x80 0xDA      |
|    DF | DUP2       | 0x80 Y 0x80 0xDA |
|    E0 | MSTORE     | 0x80 0xDA        |

Y কে 0x80-0x9F এ লিখুন।

| অফসেট | অপকোড      | স্ট্যাক        |
| ----: | ---------- | -------------- |
|    E1 | PUSH1 0x20 | 0x20 0x80 0xDA |
|    E3 | ADD        | 0xA0 0xDA      |

এবং বাকিটা ইতিমধ্যে [উপরে](#the-e4-code) ব্যাখ্যা করা হয়েছে। সুতরাং 0xDA-তে জাম্প করলে স্ট্যাকের শীর্ষ (Y) 0x80-0x9F-এ লেখা হয়, এবং সেই মানটি ফেরত দেওয়া হয়। `currentWindow()`-এর ক্ষেত্রে, এটি Storage[1] ফেরত দেয়।

## merkleRoot() {#merkleroot}

অফসেট 0xED-0xF8 এর কোডটি `splitter()`-এ 0x103-0x10E-এ যা দেখেছিলাম তার অনুরূপ (`JUMPI` গন্তব্য ছাড়া), তাই আমরা জানি `merkleRoot()`ও `payable` নয়।

| অফসেট | অপকোড        | স্ট্যাক                                                                     |
| ----: | ------------ | --------------------------------------------------------------------------- |
|    F9 | JUMPDEST     |                                                                             |
|    FA | POP          |                                                                             |
|    FB | PUSH2 0x00da | 0xDA                                                                        |
|    FE | PUSH1 0x00   | 0x00 0xDA                                                                   |
|   100 | SLOAD        | সংগ্রহস্থল[0] 0xDA      |
|   101 | DUP2         | 0xDA সংগ্রহস্থল[0] 0xDA |
|   102 | JUMP         | সংগ্রহস্থল[0] 0xDA      |

জাম্পের পরে যা ঘটে তা [আমরা ইতিমধ্যে বের করেছি](#the-da-code)। সুতরাং `merkleRoot()` সংগ্রহস্থল[0] প্রদান করে।

## 0x81e580d3 {#0x81e580d3}

অফসেট 0x138-0x143 এর কোডটি `splitter()`-এ 0x103-0x10E-এ যা দেখেছিলাম তার অনুরূপ (`JUMPI` গন্তব্য ছাড়া), তাই আমরা জানি এই ফাংশনটিও `payable` নয়।

|                                                                      অফসেট | অপকোড        | স্ট্যাক                                                                       |
| -------------------------------------------------------------------------: | ------------ | ----------------------------------------------------------------------------- |
| 99.63+40\*1.1018 = 143.702 | JUMPDEST     |                                                                               |
|                                                                        145 | POP          |                                                                               |
|                                                                        146 | PUSH2 0x00da | 0xDA                                                                          |
|                                                                        149 | PUSH2 0x0153 | 0x0153 0xDA                                                                   |
|                                                                        14C | CALLDATASIZE | CALLDATASIZE 0x0153 0xDA                                                      |
|                                                                        14D | PUSH1 0x04   | 0x04 CALLDATASIZE 0x0153 0xDA                                                 |
|                                                                        14F | PUSH2 0x018f | 0x018F 0x04 CALLDATASIZE 0x0153 0xDA                                          |
|                                                                        152 | JUMP         | 0x04 CALLDATASIZE 0x0153 0xDA                                                 |
|                                                                        18F | JUMPDEST     | 0x04 CALLDATASIZE 0x0153 0xDA                                                 |
|                                                                        190 | PUSH1 0x00   | 0x00 0x04 CALLDATASIZE 0x0153 0xDA                                            |
|                                                                        192 | PUSH1 0x20   | 0x20 0x00 0x04 CALLDATASIZE 0x0153 0xDA                                       |
|                                                                        194 | DUP3         | 0x04 0x20 0x00 0x04 CALLDATASIZE 0x0153 0xDA                                  |
|                                                                        195 | DUP5         | CALLDATASIZE 0x04 0x20 0x00 0x04 CALLDATASIZE 0x0153 0xDA                     |
|                                            \_mintFee | SUB          | CALLDATASIZE-4 0x20 0x00 0x04 CALLDATASIZE 0x0153 0xDA                        |
|                                                                        197 | SLT          | CALLDATASIZE-4<32 0x00 0x04 CALLDATASIZE 0x0153 0xDA |
|                                                                        198 | ISZERO       | CALLDATASIZE-4>=32 0x00 0x04 CALLDATASIZE 0x0153 0xDA                         |
|                                                                        199 | PUSH2 0x01a0 | 0x01A0 CALLDATASIZE-4>=32 0x00 0x04 CALLDATASIZE 0x0153 0xDA                  |
|                                                                        19C | JUMPI        | 0x00 0x04 CALLDATASIZE 0x0153 0xDA                                            |

মনে হচ্ছে এই ফাংশনটি কমপক্ষে 32 বাইট (এক শব্দ) কল ডেটা নেয়।

| অফসেট | অপকোড  | স্ট্যাক                                      |
| ----: | ------ | -------------------------------------------- |
|   19D | DUP1   | 0x00 0x00 0x04 CALLDATASIZE 0x0153 0xDA      |
|   19E | DUP2   | 0x00 0x00 0x00 0x04 CALLDATASIZE 0x0153 0xDA |
|   19F | REVERT |                                              |

যদি এটি কল ডেটা না পায় তবে লেনদেনটি কোনো রিটার্ন ডেটা ছাড়াই বাতিল হয়ে যায়।

আসুন দেখি ফাংশনটি যদি প্রয়োজনীয় কল ডেটা পায় তবে কী ঘটে।

| অফসেট | অপকোড        | স্ট্যাক                                                     |
| ----: | ------------ | ----------------------------------------------------------- |
|   1A0 | JUMPDEST     | 0x00 0x04 CALLDATASIZE 0x0153 0xDA                          |
|   1A1 | POP          | 0x04 CALLDATASIZE 0x0153 0xDA                               |
|   1A2 | CALLDATALOAD | calldataload(4) CALLDATASIZE 0x0153 0xDA |

`calldataload(4)` হল কল ডেটার প্রথম শব্দ মেথড সিগনেচারের _পরে_

| অফসেট | অপকোড        | স্ট্যাক                                                                                                                                                                                                               |
| ----: | ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   1A3 | SWAP2        | 0x0153 CALLDATASIZE calldataload(4) 0xDA                                                                                                                                                           |
|   1A4 | SWAP1        | CALLDATASIZE 0x0153 calldataload(4) 0xDA                                                                                                                                                           |
|   1A5 | POP          | 0x0153 calldataload(4) 0xDA                                                                                                                                                                        |
|   1A6 | JUMP         | calldataload(4) 0xDA                                                                                                                                                                               |
|   153 | JUMPDEST     | calldataload(4) 0xDA                                                                                                                                                                               |
|   154 | PUSH2 0x016e | 0x016E calldataload(4) 0xDA                                                                                                                                                                        |
|   157 | JUMP         | calldataload(4) 0xDA                                                                                                                                                                               |
|   16E | JUMPDEST     | calldataload(4) 0xDA                                                                                                                                                                               |
|   16F | PUSH1 0x04   | 0x04 calldataload(4) 0xDA                                                                                                                                                                          |
|   171 | DUP2         | calldataload(4) 0x04 calldataload(4) 0xDA                                                                                                                                       |
|   172 | DUP2         | 0x04 calldataload(4) 0x04 calldataload(4) 0xDA                                                                                                                                  |
|   173 | SLOAD        | সংগ্রহস্থল[4] calldataload(4) 0x04 calldataload(4) 0xDA                                                                     |
|   174 | DUP2         | calldataload(4) সংগ্রহস্থল[4] calldataload(4) 0x04 calldataload(4) 0xDA                                  |
|   175 | LT           | calldataload(4)<সংগ্রহস্থল[4] calldataload(4) 0x04 calldataload(4) 0xDA         |
|   176 | PUSH2 0x017e | 0x017EC calldataload(4)<সংগ্রহস্থল[4] calldataload(4) 0x04 calldataload(4) 0xDA |
|   179 | JUMPI        | calldataload(4) 0x04 calldataload(4) 0xDA                                                                                                                                       |

যদি প্রথম শব্দটি সংগ্রহস্থল[4] এর থেকে কম না হয়, তাহলে ফাংশনটি ব্যর্থ হয়। এটি কোনো রিটার্ন মান ছাড়াই বাতিল হয়ে যায়:

| অফসেট | অপকোড      | স্ট্যাক                                                       |
| ----: | ---------- | ------------------------------------------------------------- |
|   17A | PUSH1 0x00 | 0x00 ...      |
|   17C | DUP1       | 0x00 0x00 ... |
|   17D | REVERT     |                                                               |

যদি calldataload(4) Storage[4]-এর থেকে কম হয়, তাহলে আমরা এই কোডটি পাই:

| অফসেট | অপকোড      | স্ট্যাক                                                                                   |
| ----: | ---------- | ----------------------------------------------------------------------------------------- |
|   17E | JUMPDEST   | calldataload(4) 0x04 calldataload(4) 0xDA           |
|   17F | PUSH1 0x00 | 0x00 calldataload(4) 0x04 calldataload(4) 0xDA      |
|   181 | SWAP2      | 0x04 calldataload(4) 0x00 calldataload(4) 0xDA      |
|   182 | DUP3       | 0x00 0x04 calldataload(4) 0x00 calldataload(4) 0xDA |
|   183 | MSTORE     | calldataload(4) 0x00 calldataload(4) 0xDA           |

এবং মেমরি অবস্থান 0x00-0x1F এখন ডেটা 0x04 ধারণ করে (0x00-0x1E সবই শূন্য, 0x1F হল চার)

| অফসেট | অপকোড      | স্ট্যাক                                                                                                                                                                                                                       |
| ----: | ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   184 | PUSH1 0x20 | 0x20 calldataload(4) 0x00 calldataload(4) 0xDA                                                                                                                                          |
|   186 | SWAP1      | calldataload(4) 0x20 0x00 calldataload(4) 0xDA                                                                                                                                          |
|   187 | SWAP2      | 0x00 0x20 calldataload(4) calldataload(4) 0xDA                                                                                                                                          |
|   188 | SHA3       | (((0x00-0x1F এর SHA3))) calldataload(4) calldataload(4) 0xDA                                                                   |
|   189 | ADD        | (((0x00-0x1F এর SHA3)))+calldataload(4) calldataload(4) 0xDA                                                                   |
|   18A | SLOAD      | সংগ্রহস্থল[(((0x00-0x1F এর SHA3))) + calldataload(4)] calldataload(4) 0xDA |

সুতরাং স্টোরেজে একটি লুকআপ টেবিল রয়েছে, যা 0x000...0004-এর SHA3 থেকে শুরু হয় এবং প্রতিটি বৈধ কল ডেটা মানের জন্য একটি এন্ট্রি রয়েছে (সংগ্রহস্থল[4] এর নীচের মান)।

| অফসেট | অপকোড | স্ট্যাক                                                                                                                                                                                                                       |
| ----: | ----- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   18B | SWAP1 | calldataload(4) সংগ্রহস্থল[(((0x00-0x1F এর SHA3))) + calldataload(4)] 0xDA |
|   18C | POP   | সংগ্রহস্থল[(((0x00-0x1F এর SHA3))) + calldataload(4)] 0xDA                                    |
|   18D | DUP2  | 0xDA সংগ্রহস্থল[(((0x00-0x1F এর SHA3))) + calldataload(4)] 0xDA                               |
|   18E | JUMP  | সংগ্রহস্থল[(((0x00-0x1F এর SHA3))) + calldataload(4)] 0xDA                                    |

আমরা ইতিমধ্যে জানি [অফসেট 0xDA-এর কোডটি](#the-da-code) কী করে, এটি স্ট্যাক টপ ভ্যালু কলারকে ফেরত দেয়। সুতরাং এই ফাংশনটি লুকআপ টেবিল থেকে মানটি কলারকে ফেরত দেয়।

## 0x1f135823 {#0x1f135823}

অফসেট 0xC4-0xCF এর কোডটি `splitter()`-এ 0x103-0x10E-এ যা দেখেছিলাম তার অনুরূপ (`JUMPI` গন্তব্য ছাড়া), তাই আমরা জানি এই ফাংশনটিও `payable` নয়।

| অফসেট | অপকোড        | স্ট্যাক           |
| ----: | ------------ | ----------------- |
|    D0 | JUMPDEST     |                   |
|    D1 | POP          |                   |
|    D2 | PUSH2 0x00da | 0xDA              |
|    D5 | PUSH1 0x06   | 0x06 0xDA         |
|    D7 | SLOAD        | Value\* 0xDA      |
|    D8 | DUP2         | 0xDA Value\* 0xDA |
|    D9 | JUMP         | Value\* 0xDA      |

আমরা ইতিমধ্যে জানি [অফসেট 0xDA-এর কোডটি](#the-da-code) কী করে, এটি স্ট্যাক টপ ভ্যালু কলারকে ফেরত দেয়। সুতরাং এই ফাংশনটি `Value*` ফেরত দেয়।

### পদ্ধতির সারাংশ {#method-summary}

আপনি কি মনে করেন এই মুহূর্তে চুক্তিটি বুঝতে পারছেন? আমি না। এখন পর্যন্ত আমাদের এই পদ্ধতিগুলি রয়েছে:

| পদ্ধতি                                               | অর্থ                                                                                                                                        |
| ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| স্থানান্তর                                           | কল দ্বারা প্রদত্ত মান গ্রহণ করুন এবং `Value*` কে সেই পরিমাণ দ্বারা বৃদ্ধি করুন                                                              |
| [splitter()](#splitter)           | সংগ্রহস্থল[3] ফেরত দিন, প্রক্সি ঠিকানা                                                  |
| [currentWindow()](#currentwindow) | সংগ্রহস্থল[1] ফেরত দিন                                                                  |
| [merkleRoot()](#merkeroot)        | সংগ্রহস্থল[0] ফেরত দিন                                                                  |
| [0x81e580d3](#0x81e580d3)                            | একটি লুকআপ টেবিল থেকে মান ফেরত দিন, যদি প্যারামিটারটি সংগ্রহস্থল[4] থেকে কম হয়         |
| [0x1f135823](#0x1f135823)                            | সংগ্রহস্থল[6] ফেরত দিন, এ.কে.এ. Value\* |

কিন্তু আমরা জানি যে অন্য কোনো কার্যকারিতা Storage[3]-এর চুক্তি দ্বারা প্রদান করা হয়। হয়তো যদি আমরা জানতাম যে সেই চুক্তিটি কী তবে এটি আমাদের একটি সূত্র দেবে। সৌভাগ্যবশত, এটি ব্লকচেইন এবং সবকিছুই জানা, অন্তত তত্ত্বগতভাবে। আমরা এমন কোনো পদ্ধতি দেখিনি যা সংগ্রহস্থল[3] সেট করে, তাই এটি অবশ্যই কন্সট্রাক্টর দ্বারা সেট করা হয়েছে।

## কনস্ট্রাক্টর {#the-constructor}

যখন আমরা [একটি চুক্তি দেখি](https://etherscan.io/address/0x2510c039cc3b061d79e564b38836da87e31b342f) আমরা এটি তৈরির লেনদেনও দেখতে পারি।

![তৈরির লেনদেন ক্লিক করুন](create-tx.png)

আমরা যদি সেই লেনদেনে ক্লিক করি এবং তারপরে **অবস্থা** ট্যাবে ক্লিক করি, তাহলে আমরা প্যারামিটারগুলির প্রাথমিক মান দেখতে পারি। বিশেষ করে, আমরা দেখতে পারি যে সংগ্রহস্থল[3]-এ [0x2f81e57ff4f4d83b40a9f719fd892d8e806e0761](https://etherscan.io/address/0x2f81e57ff4f4d83b40a9f719fd892d8e806e0761) রয়েছে। সেই চুক্তিতে অবশ্যই অনুপস্থিত কার্যকারিতা রয়েছে। আমরা যে চুক্তিটি তদন্ত করছি তার জন্য আমরা যে টুলস ব্যবহার করেছি, সেগুলি ব্যবহার করে আমরা এটি বুঝতে পারি।

## প্রক্সি চুক্তি {#the-proxy-contract}

উপরে মূল চুক্তির জন্য আমরা যে কৌশলগুলি ব্যবহার করেছি, সেগুলি ব্যবহার করে আমরা দেখতে পারি যে চুক্তিটি উল্টে যায় যদি:

- কলের সাথে কোনো ETH সংযুক্ত থাকে (0x05-0x0F)
- কল ডেটার আকার চারের কম (0x10-0x19 এবং 0xBE-0xC2)

এবং এটি যে পদ্ধতিগুলিকে সমর্থন করে সেগুলি হল:

| পদ্ধতি                                                                                                                                                                                 | মেথড সিগনেচার                | ভিতরে ঝাঁপ দেওয়ার জন্য অফসেট |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------- | ----------------------------- |
| [scaleAmountByPercentage(uint256,uint256)](https://www.4byte.directory/signatures/?bytes4_signature=0x8ffb5c97)                                                     | 0x8ffb5c97                   | 0x0135                        |
| [isClaimed(uint256,address)](https://www.4byte.directory/signatures/?bytes4_signature=0xd2ef0795)                                                                   | 0xd2ef0795                   | 0x0151                        |
| [claim(uint256,address,uint256,bytes32[])](https://www.4byte.directory/signatures/?bytes4_signature=0x2e7ba6ef) | 0x2e7ba6ef                   | 0x00F4                        |
| [incrementWindow()](https://www.4byte.directory/signatures/?bytes4_signature=0x338b1d31)                                                                            | 0x338b1d31                   | 0x0110                        |
| ???                                                                                                                                                                                    | 0x3f26479e                   | 0x0118                        |
| ???                                                                                                                                                                                    | 0x1e7df9d3                   | 0x00C3                        |
| [currentWindow()](https://www.4byte.directory/signatures/?bytes4_signature=0xba0bafb4)                                                                              | [0xba0bafb4](#currentwindow) | 0x0148                        |
| [merkleRoot()](https://www.4byte.directory/signatures/?bytes4_signature=0x2eb4a7ab)                                                                                 | [0x2eb4a7ab](#merkleroot)    | 0x0107                        |
| ???                                                                                                                                                                                    | [0x81e580d3](#0x81e580d3)    | 0x0122                        |
| ???                                                                                                                                                                                    | [0x1f135823](#0x1f135823)    | 0x00D8                        |

আমরা নীচের চারটি পদ্ধতি উপেক্ষা করতে পারি কারণ আমরা কখনই তাদের কাছে পৌঁছাব না। তাদের সিগনেচার এমন যে আমাদের মূল চুক্তি নিজেই তাদের যত্ন নেয় (আপনি উপরের বিবরণ দেখতে সিগনেচারগুলিতে ক্লিক করতে পারেন), তাই সেগুলি অবশ্যই [ওভাররাইড করা পদ্ধতি](https://medium.com/upstate-interactive/solidity-override-vs-virtual-functions-c0a5dfb83aaf) হতে হবে।

অবশিষ্ট পদ্ধতিগুলির মধ্যে একটি হল `claim(<params>)`, এবং অন্যটি হল `isClaimed(<params>)`, তাই এটি একটি এয়ারড্রপ চুক্তির মতো দেখাচ্ছে। বাকিটা অপকোড ধরে ধরে না দেখে, আমরা [ডিকম্পাইলার চেষ্টা করতে পারি](https://etherscan.io/bytecode-decompiler?a=0x2f81e57ff4f4d83b40a9f719fd892d8e806e0761), যা এই চুক্তি থেকে তিনটি ফাংশনের জন্য ব্যবহারযোগ্য ফলাফল তৈরি করে। অন্যদের রিভার্স ইঞ্জিনিয়ারিং পাঠকের জন্য একটি অনুশীলন হিসাবে ছেড়ে দেওয়া হয়েছে।

### scaleAmountByPercentage {#scaleamountbypercentage}

এই ফাংশনের জন্য ডিকম্পাইলার আমাদের যা দেয় তা হল:

```python
def unknown8ffb5c97(uint256 _param1, uint256 _param2) payable:
  require calldata.size - 4 >=′ 64
  if _param1 and _param2 > -1 / _param1:
      revert with 0, 17
  return (_param1 * _param2 / 100 * 10^6)
```

প্রথম `require` পরীক্ষা করে যে কল ডেটাতে, ফাংশন সিগনেচারের চার বাইট ছাড়াও, কমপক্ষে 64 বাইট রয়েছে, যা দুটি প্যারামিটারের জন্য যথেষ্ট। যদি না হয় তবে অবশ্যই কিছু ভুল আছে।

`if` স্টেটমেন্টটি দেখে মনে হচ্ছে এটি পরীক্ষা করে যে `_param1` শূন্য নয়, এবং `_param1 * _param2` ঋণাত্মক নয়। এটি সম্ভবত র‍্যাপ অ্যারাউন্ডের ঘটনাগুলি প্রতিরোধ করার জন্য।

অবশেষে, ফাংশনটি একটি স্কেল করা মান প্রদান করে।

### দাবি {#claim}

ডিকম্পাইলার যে কোড তৈরি করে তা জটিল, এবং এর সবটাই আমাদের জন্য প্রাসঙ্গিক নয়। আমি এর কিছু অংশ এড়িয়ে যাচ্ছি সেই লাইনগুলিতে ফোকাস করার জন্য যা আমার মতে দরকারী তথ্য সরবরাহ করে।

```python
def unknown2e7ba6ef(uint256 _param1, uint256 _param2, uint256 _param3, array _param4) payable:
  ...
  require _param2 == addr(_param2)
  ...
  if currentWindow <= _param1:
      revert with 0, 'cannot claim for a future window'
```

আমরা এখানে দুটি গুরুত্বপূর্ণ জিনিস দেখতে পাই:

- `_param2`, যদিও এটিকে `uint256` হিসাবে ঘোষণা করা হয়েছে, এটি আসলে একটি ঠিকানা।
- `_param1` হল দাবি করা উইন্ডো, যা `currentWindow` বা তার আগের হতে হবে।

```python
  ...
  if stor5[_claimWindow][addr(_claimFor)]:
      revert with 0, 'Account already claimed the given window'
```

সুতরাং এখন আমরা জানি যে Storage[5] হল উইন্ডো এবং ঠিকানার একটি অ্যারে, এবং ঠিকানাটি সেই উইন্ডোর জন্য পুরস্কার দাবি করেছে কিনা।

```python
  ...
  idx = 0
  s = 0
  while idx < _param4.length:
  ...
      if s + sha3(mem[(32 * _param4.length) + 328 len mem[(32 * _param4.length) + 296]]) > mem[(32 * idx) + 296]:
          mem[mem[64] + 32] = mem[(32 * idx) + 296]
          ...
          s = sha3(mem[_62 + 32 len mem[_62]])
          continue
      ...
      s = sha3(mem[_66 + 32 len mem[_66]])
      continue
  if unknown2eb4a7ab != s:
      revert with 0, 'Invalid proof'
```

আমরা জানি যে `unknown2eb4a7ab` আসলে `merkleRoot()` ফাংশন, তাই এই কোডটি দেখে মনে হচ্ছে এটি একটি [মার্কল প্রমাণ](https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5) যাচাই করছে। এর মানে হল `_param4` একটি মার্কল প্রমাণ।

```python
  call addr(_param2) with:
     value unknown81e580d3[_param1] * _param3 / 100 * 10^6 wei
       gas 30000 wei
```

এভাবেই একটি চুক্তি তার নিজস্ব ETH অন্য ঠিকানায় (চুক্তি বা বাহ্যিকভাবে মালিকানাধীন) স্থানান্তর করে। এটি একটি মান দিয়ে কল করে যা স্থানান্তরিত হওয়ার পরিমাণ। সুতরাং দেখে মনে হচ্ছে এটি ETH-এর একটি এয়ারড্রপ।

```python
  if not return_data.size:
      if not ext_call.success:
          require ext_code.size(stor2)
          call stor2.deposit() with:
             value unknown81e580d3[_param1] * _param3 / 100 * 10^6 wei
```

নীচের দুটি লাইন আমাদের জানায় যে সংগ্রহস্থল[2]ও একটি চুক্তি যা আমরা কল করি। যদি আমরা [কন্সট্রাক্টর লেনদেন দেখি](https://etherscan.io/tx/0xa1ea0549fb349eb7d3aff90e1d6ce7469fdfdcd59a2fd9b8d1f5e420c0d05b58#statechange) আমরা দেখতে পাই যে এই চুক্তিটি [0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2), একটি র‍্যাপড ইথার চুক্তি [যার সোর্স কোড Etherscan-এ আপলোড করা হয়েছে](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code)।

সুতরাং দেখে মনে হচ্ছে চুক্তিগুলি `_param2`-এ ETH পাঠানোর চেষ্টা করে। যদি এটি করতে পারে, দারুণ। যদি না পারে, তবে এটি [WETH](https://weth.tkn.eth.limo/) পাঠানোর চেষ্টা করে। যদি `_param2` একটি এক্সটার্নালি ওনড অ্যাকাউন্ট (EOA) হয় তবে এটি সর্বদা ETH গ্রহণ করতে পারে, কিন্তু চুক্তিগুলি ETH গ্রহণ করতে অস্বীকার করতে পারে। তবে, WETH হল ERC-20 এবং চুক্তিগুলি তা গ্রহণ করতে অস্বীকার করতে পারে না।

```python
  ...
  log 0xdbd5389f: addr(_param2), unknown81e580d3[_param1] * _param3 / 100 * 10^6, bool(ext_call.success)
```

ফাংশনের শেষে আমরা একটি লগ এন্ট্রি তৈরি হতে দেখি। [তৈরি করা লগ এন্ট্রিগুলি দেখুন](https://etherscan.io/address/0x2510c039cc3b061d79e564b38836da87e31b342f#events) এবং `0xdbd5...` দিয়ে শুরু হওয়া টপিকে ফিল্টার করুন। যদি আমরা [এমন একটি লেনদেনে ক্লিক করি যা এই ধরনের একটি এন্ট্রি তৈরি করেছে](https://etherscan.io/tx/0xe7d3b7e00f645af17dfbbd010478ef4af235896c65b6548def1fe95b3b7d2274) আমরা দেখতে পাই যে এটি সত্যিই একটি দাবির মতো দেখাচ্ছে - অ্যাকাউন্টটি আমরা যে চুক্তিটি বিপরীত প্রকৌশলী করছি তাতে একটি বার্তা পাঠিয়েছে, এবং বিনিময়ে ETH পেয়েছে।

![একটি দাবি লেনদেন](claim-tx.png)

### 1e7df9d3 {#1e7df9d3}

এই ফাংশনটি উপরের [`claim`](#claim)-এর সাথে খুব অনুরূপ। এটি একটি মার্কল প্রমাণও পরীক্ষা করে, প্রথমে ETH স্থানান্তর করার চেষ্টা করে এবং একই ধরনের লগ এন্ট্রি তৈরি করে।

```python
def unknown1e7df9d3(uint256 _param1, uint256 _param2, array _param3) payable:
  ...
  idx = 0
  s = 0
  while idx < _param3.length:
      if idx >= mem[96]:
          revert with 0, 50
      _55 = mem[(32 * idx) + 128]
      if s + sha3(mem[(32 * _param3.length) + 160 len mem[(32 * _param3.length) + 128]]) > mem[(32 * idx) + 128]:
          ...
          s = sha3(mem[_58 + 32 len mem[_58]])
          continue
      mem[mem[64] + 32] = s + sha3(mem[(32 * _param3.length) + 160 len mem[(32 * _param3.length) + 128]])
  ...
  if unknown2eb4a7ab != s:
      revert with 0, 'Invalid proof'
  ...
  call addr(_param1) with:
     value s wei
       gas 30000 wei
  if not return_data.size:
      if not ext_call.success:
          require ext_code.size(stor2)
          call stor2.deposit() with:
             value s wei
               gas gas_remaining wei
  ...
  log 0xdbd5389f: addr(_param1), s, bool(ext_call.success)
```

প্রধান পার্থক্য হল যে প্রথম প্যারামিটার, যে উইন্ডোটি উত্তোলন করা হবে, তা সেখানে নেই। পরিবর্তে, দাবি করা যেতে পারে এমন সমস্ত উইন্ডোর উপর একটি লুপ রয়েছে।

```python
  idx = 0
  s = 0
  while idx < currentWindow:
      ...
      if stor5[mem[0]]:
          if idx == -1:
              revert with 0, 17
          idx = idx + 1
          s = s
          continue
      ...
      stor5[idx][addr(_param1)] = 1
      if idx >= unknown81e580d3.length:
          revert with 0, 50
      mem[0] = 4
      if unknown81e580d3[idx] and _param2 > -1 / unknown81e580d3[idx]:
          revert with 0, 17
      if s > !(unknown81e580d3[idx] * _param2 / 100 * 10^6):
          revert with 0, 17
      if idx == -1:
          revert with 0, 17
      idx = idx + 1
      s = s + (unknown81e580d3[idx] * _param2 / 100 * 10^6)
      continue
```

সুতরাং এটি `claim`-এর একটি ভ্যারিয়েন্টের মতো দেখাচ্ছে যা সমস্ত উইন্ডো দাবি করে।

## উপসংহার {#conclusion}

এখন পর্যন্ত আপনার জানা উচিত কিভাবে সেইসব চুক্তি বুঝতে হয় যাদের সোর্স কোড উপলব্ধ নেই, হয় অপকোড ব্যবহার করে অথবা (যখন এটি কাজ করে) ডিকম্পাইলার ব্যবহার করে। এই নিবন্ধের দৈর্ঘ্য থেকে স্পষ্ট যে, একটি চুক্তির রিভার্স ইঞ্জিনিয়ারিং তুচ্ছ নয়, তবে এমন একটি সিস্টেমে যেখানে নিরাপত্তা অপরিহার্য, সেখানে চুক্তিগুলি প্রতিশ্রুত হিসাবে কাজ করে কিনা তা যাচাই করতে সক্ষম হওয়া একটি গুরুত্বপূর্ণ দক্ষতা।

[আমার আরও কাজের জন্য এখানে দেখুন](https://cryptodocguy.pro/)।
