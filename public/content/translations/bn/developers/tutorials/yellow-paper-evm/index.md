---
title: "ইয়েলো পেপারের EVM স্পেসিফিকেশন বোঝা"
description: "ইয়েলো পেপারের সেই অংশটি বোঝা, যা Ethereum-এর জন্য আনুষ্ঠানিক স্পেসিফিকেশন, যা Ethereum ভার্চুয়াল মেশিন (EVM) ব্যাখ্যা করে।"
author: "qbzzt"
tags: [ "evm" ]
skill: intermediate
lang: bn
published: 2022-05-15
---

[The Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) হল Ethereum-এর জন্য আনুষ্ঠানিক স্পেসিফিকেশন। [EIP প্রক্রিয়া](/eips/) দ্বারা সংশোধিত স্থানগুলি ছাড়া, এতে সবকিছু কীভাবে কাজ করে তার সঠিক বর্ণনা রয়েছে। এটি একটি গাণিতিক পেপার হিসাবে লেখা, যাতে এমন পরিভাষা অন্তর্ভুক্ত রয়েছে যা প্রোগ্রামারদের কাছে পরিচিত নাও হতে পারে। এই পেপারে আপনি শিখবেন কিভাবে এটি পড়তে হয় এবং এর মাধ্যমে অন্যান্য সম্পর্কিত গাণিতিক পেপারও পড়তে পারবেন।

## কোন ইয়েলো পেপার? {#which-yellow-paper}

Ethereum-এর প্রায় সবকিছুর মতোই, ইয়েলো পেপারও সময়ের সাথে সাথে বিকশিত হয়। একটি নির্দিষ্ট সংস্করণের উল্লেখ করার জন্য, আমি [লেখার সময়কার বর্তমান সংস্করণটি](yellow-paper-berlin.pdf) আপলোড করেছি। আমি যে বিভাগ, পৃষ্ঠা এবং সমীকরণ নম্বরগুলি ব্যবহার করব তা সেই সংস্করণকে নির্দেশ করবে। এই ডকুমেন্টটি পড়ার সময় এটি একটি ভিন্ন উইন্ডোতে খুলে রাখা একটি ভাল ধারণা।

### EVM কেন? {#why-the-evm}

আসল ইয়েলো পেপারটি Ethereum-এর বিকাশের একেবারে শুরুতে লেখা হয়েছিল। এটি আসল প্রুফ-অফ-ওয়ার্ক ভিত্তিক কনসেন্সাস মেকানিজম বর্ণনা করে যা মূলত নেটওয়ার্ক সুরক্ষিত করতে ব্যবহৃত হয়েছিল। তবে, Ethereum প্রুফ-অফ-ওয়ার্ক বন্ধ করে দিয়েছে এবং 2022 সালের সেপ্টেম্বরে প্রুফ-অফ-স্টেক ভিত্তিক কনসেন্সাস ব্যবহার করা শুরু করেছে। এই টিউটোরিয়ালটি ইয়েলো পেপারের সেই অংশগুলির উপর মনোযোগ দেবে যা Ethereum ভার্চুয়াল মেশিনকে সংজ্ঞায়িত করে। প্রুফ-অফ-স্টেকে স্থানান্তরের দ্বারা EVM অপরিবর্তিত ছিল (DIFFICULTY অপকোডের রিটার্ন ভ্যালু ছাড়া)।

## 9 এক্সিকিউশন মডেল {#9-execution-model}

এই বিভাগে (পৃ. 12-14) EVM-এর বেশিরভাগ সংজ্ঞা অন্তর্ভুক্ত রয়েছে।

_সিস্টেম স্টেট_ শব্দটি সিস্টেম চালানোর জন্য আপনার যা যা জানা দরকার তার সবকিছু অন্তর্ভুক্ত করে। একটি সাধারণ কম্পিউটারে, এর অর্থ হল মেমরি, রেজিস্টারের বিষয়বস্তু ইত্যাদি।

একটি [টুরিং মেশিন](https://en.wikipedia.org/wiki/Turing_machine) একটি কম্পিউটেশনাল মডেল। মূলত, এটি একটি কম্পিউটারের একটি সরলীকৃত সংস্করণ, যা একটি সাধারণ কম্পিউটারের মতো গণনা চালানোর একই ক্ষমতা রাখে বলে প্রমাণিত (একটি কম্পিউটার যা কিছু গণনা করতে পারে, একটি টুরিং মেশিনও তা করতে পারে এবং এর বিপরীতও সত্য)। এই মডেলটি কী গণনাযোগ্য এবং কী নয় সে সম্পর্কে বিভিন্ন উপপাদ্য প্রমাণ করা সহজ করে তোলে।

[টুরিং-কমপ্লিট](https://en.wikipedia.org/wiki/Turing_completeness) শব্দটি এমন একটি কম্পিউটারকে বোঝায় যা একটি টুরিং মেশিনের মতো একই গণনা চালাতে পারে। টুরিং মেশিনগুলি অসীম লুপে পড়তে পারে, এবং EVM তা পারে না কারণ এর গ্যাস ফুরিয়ে যাবে, তাই এটি কেবল কোয়াসি-টুরিং-কমপ্লিট।

## 9.1 বেসিকস {#91-basics}

এই বিভাগে EVM-এর মূল বিষয়গুলি এবং এটি অন্যান্য কম্পিউটেশনাল মডেলের সাথে কীভাবে তুলনা করে তা দেওয়া হয়েছে।

একটি [স্ট্যাক মেশিন](https://en.wikipedia.org/wiki/Stack_machine) হল একটি কম্পিউটার যা রেজিস্টারে নয়, বরং একটি [**স্ট্যাকে**](https://en.wikipedia.org/wiki/Stack_\(abstract_data_type\)) মধ্যবর্তী ডেটা সঞ্চয় করে। এটি ভার্চুয়াল মেশিনের জন্য পছন্দের আর্কিটেকচার কারণ এটি প্রয়োগ করা সহজ যার অর্থ হল বাগ এবং নিরাপত্তা দুর্বলতার সম্ভাবনা অনেক কম। স্ট্যাকের মেমরি 256-বিট শব্দে বিভক্ত। এটি বেছে নেওয়া হয়েছিল কারণ এটি Ethereum-এর মূল ক্রিপ্টোগ্রাফিক অপারেশন যেমন Keccak-256 হ্যাশিং এবং ইলিপটিক কার্ভ গণনার জন্য সুবিধাজনক। স্ট্যাকের সর্বোচ্চ আকার হল 1024টি আইটেম (1024 x 256 বিট)। যখন অপকোডগুলি কার্যকর করা হয় তখন তারা সাধারণত স্ট্যাক থেকে তাদের প্যারামিটারগুলি পায়। স্ট্যাকের উপাদানগুলিকে পুনর্গঠন করার জন্য নির্দিষ্ট অপকোড রয়েছে যেমন `POP` (স্ট্যাকের শীর্ষ থেকে আইটেম সরিয়ে দেয়), `DUP_N` (স্ট্যাকের N'তম আইটেম ডুপ্লিকেট করে) ইত্যাদি।

EVM-এর একটি ভোলাটাইল স্থানও রয়েছে যাকে **মেমরি** বলা হয় যা এক্সিকিউশনের সময় ডেটা সঞ্চয় করতে ব্যবহৃত হয়। এই মেমরিটি 32-বাইট শব্দে সংগঠিত। সমস্ত মেমরি অবস্থান শূন্যতে ইনিশিয়ালাইজ করা হয়। আপনি যদি মেমরিতে একটি শব্দ যোগ করতে এই [Yul](https://docs.soliditylang.org/en/latest/yul.html) কোডটি চালান, তাহলে এটি শব্দের খালি জায়গাটি শূন্য দিয়ে প্যাডিং করে 32 বাইট মেমরি পূরণ করবে, অর্থাৎ, এটি একটি শব্দ তৈরি করে - যেখানে অবস্থান 0-29-এ শূন্য, 30-এ 0x60, এবং 31-এ 0xA7 থাকবে।

```yul
mstore(0, 0x60A7)
```

`mstore` হল মেমরির সাথে ইন্টারঅ্যাক্ট করার জন্য EVM দ্বারা প্রদত্ত তিনটি অপকোডের মধ্যে একটি - এটি মেমরিতে একটি শব্দ লোড করে। অন্য দুটি হল `mstore8` যা মেমরিতে একটি একক বাইট লোড করে, এবং `mload` যা মেমরি থেকে স্ট্যাকে একটি শব্দ স্থানান্তরিত করে।

EVM-এর একটি পৃথক নন-ভোলাটাইল **স্টোরেজ** মডেলও রয়েছে যা সিস্টেম স্টেটের অংশ হিসাবে রক্ষণাবেক্ষণ করা হয় - এই মেমরিটি শব্দ অ্যারেতে সংগঠিত হয় (স্ট্যাকের শব্দ-অ্যাড্রেসেবল বাইট অ্যারের বিপরীতে)। এই স্টোরেজ হল যেখানে চুক্তিগুলি স্থায়ী ডেটা রাখে - একটি চুক্তি কেবল তার নিজের স্টোরেজের সাথে ইন্টারঅ্যাক্ট করতে পারে। স্টোরেজ কী-ভ্যালু ম্যাপিং-এ সংগঠিত হয়।

যদিও ইয়েলো পেপারের এই বিভাগে এটি উল্লেখ করা হয়নি, তবে এটিও জানা দরকারী যে চতুর্থ ধরণের মেমরি রয়েছে। **Calldata** হল বাইট-অ্যাড্রেসেবল রিড-অনলি মেমরি যা একটি লেনদেনের `data` প্যারামিটারের সাথে পাস করা মান সংরক্ষণ করতে ব্যবহৃত হয়। EVM-এর `calldata` পরিচালনা করার জন্য নির্দিষ্ট অপকোড রয়েছে। `calldatasize` ডেটার আকার ফিরিয়ে দেয়। `calldataload` ডেটা স্ট্যাকে লোড করে। `calldatacopy` ডেটা মেমরিতে কপি করে।

স্ট্যান্ডার্ড [Von Neumann আর্কিটেকচার](https://en.wikipedia.org/wiki/Von_Neumann_architecture) একই মেমরিতে কোড এবং ডেটা সঞ্চয় করে। নিরাপত্তার কারণে EVM এই স্ট্যান্ডার্ড অনুসরণ করে না - ভোলাটাইল মেমরি শেয়ার করা প্রোগ্রাম কোড পরিবর্তন করা সম্ভব করে তোলে। পরিবর্তে, কোড স্টোরেজে সেভ করা হয়।

মাত্র দুটি ক্ষেত্রে মেমরি থেকে কোড চালানো হয়:

- যখন একটি চুক্তি অন্য একটি চুক্তি তৈরি করে ([`CREATE`](https://www.evm.codes/#f0) বা [`CREATE2`](https://www.evm.codes/#f5) ব্যবহার করে), তখন চুক্তি কন্সট্রাক্টরের জন্য কোডটি মেমরি থেকে আসে।
- _যেকোন_ চুক্তি তৈরির সময়, কন্সট্রাক্টর কোডটি চলে এবং তারপর প্রকৃত চুক্তির কোডসহ ফিরে আসে, যা মেমরি থেকেও আসে।

ব্যতিক্রমী এক্সিকিউশন শব্দটি এমন একটি ব্যতিক্রমকে বোঝায় যা বর্তমান চুক্তির এক্সিকিউশনকে থামিয়ে দেয়।

## 9.2 ফি ওভারভিউ {#92-fees-overview}

এই বিভাগে গ্যাস ফি কীভাবে গণনা করা হয় তা ব্যাখ্যা করা হয়েছে। তিনটি খরচ আছে:

### অপকোড খরচ {#opcode-cost}

নির্দিষ্ট অপকোডের অন্তর্নিহিত খরচ। এই মান পেতে, Appendix H-এ (পৃ. 28, সমীকরণ (327)-এর অধীনে) অপকোডের খরচ গ্রুপটি খুঁজুন, এবং সমীকরণ (324)-এ খরচ গ্রুপটি খুঁজুন। এটি আপনাকে একটি কস্ট ফাংশন দেয়, যা বেশিরভাগ ক্ষেত্রে Appendix G (পৃ. 27) থেকে প্যারামিটার ব্যবহার করে।

উদাহরণস্বরূপ, অপকোড [`CALLDATACOPY`](https://www.evm.codes/#37) _W<sub>copy</sub>_ গ্রুপের সদস্য। সেই গ্রুপের জন্য অপকোড খরচ হল _G<sub>verylow</sub>+G<sub>copy</sub>×⌈μ<sub>s</sub>[2]÷32⌉_। Appendix G দেখলে, আমরা দেখতে পাই যে উভয় ধ্রুবকই 3, যা আমাদের _3+3×⌈μ<sub>s</sub>[2]÷32⌉_ দেয়।

আমাদের এখনও _⌈μ<sub>s</sub>[2]÷32⌉_ এক্সপ্রেশনটির পাঠোদ্ধার করতে হবে। বাইরের অংশ, _⌈ \<value\> ⌉_ হল সিলিং ফাংশন, একটি ফাংশন যা একটি মান দেওয়া হলে সেই ক্ষুদ্রতম পূর্ণসংখ্যাটি ফিরিয়ে দেয় যা এখনও মানের চেয়ে ছোট নয়। উদাহরণস্বরূপ, _⌈2.5⌉ = ⌈3⌉ = 3_। ভিতরের অংশটি হল _μ<sub>s</sub>[2]÷32_। পৃষ্ঠা 3-এর বিভাগ 3 (কনভেনশন)-এ দেখলে, _μ_ হল মেশিন স্টেট। মেশিন স্টেট পৃষ্ঠা 13-এর বিভাগ 9.4.1-এ সংজ্ঞায়িত করা হয়েছে। সেই বিভাগ অনুসারে, মেশিন স্টেট প্যারামিটারগুলির মধ্যে একটি হল স্ট্যাকের জন্য _s_। সবকিছু একসাথে রাখলে, মনে হয় _μ<sub>s</sub>[2]_ হল স্ট্যাকের #2 অবস্থান। [অপকোড](https://www.evm.codes/#37) দেখলে, স্ট্যাকের #2 অবস্থানটি হল বাইটে ডেটার আকার। W<sub>copy</sub> গ্রুপের অন্যান্য অপকোড, [`CODECOPY`](https://www.evm.codes/#39) এবং [`RETURNDATACOPY`](https://www.evm.codes/#3e) দেখলে, তাদেরও একই অবস্থানে ডেটার আকার রয়েছে। সুতরাং _⌈μ<sub>s</sub>[2]÷32⌉_ হল কপি করা ডেটা সঞ্চয় করার জন্য প্রয়োজনীয় 32 বাইট শব্দের সংখ্যা। সবকিছু একসাথে রাখলে, [`CALLDATACOPY`](https://www.evm.codes/#37)-এর অন্তর্নিহিত খরচ হল 3 গ্যাস এবং কপি করা ডেটার প্রতিটি শব্দের জন্য অতিরিক্ত 3।

### রানিং খরচ {#running-cost}

আমরা যে কোডটি কল করছি তা চালানোর খরচ।

- [`CREATE`](https://www.evm.codes/#f0) এবং [`CREATE2`](https://www.evm.codes/#f5)-এর ক্ষেত্রে, নতুন চুক্তির জন্য কন্সট্রাক্টর।
- [`CALL`](https://www.evm.codes/#f1), [`CALLCODE`](https://www.evm.codes/#f2), [`STATICCALL`](https://www.evm.codes/#fa), বা [`DELEGATECALL`](https://www.evm.codes/#f4)-এর ক্ষেত্রে, আমরা যে চুক্তিটি কল করি।

### মেমরি সম্প্রসারণের খরচ {#expanding-memory-cost}

মেমরি সম্প্রসারণের খরচ (যদি প্রয়োজন হয়)।

সমীকরণ 324-এ, এই মানটি _C<sub>mem</sub>(μ<sub>i</sub>')-C<sub>mem</sub>(μ<sub>i</sub>)_ হিসাবে লেখা হয়েছে। বিভাগ 9.4.1 আবার দেখলে, আমরা দেখতে পাই যে _μ<sub>i</sub>_ হল মেমরিতে শব্দের সংখ্যা। সুতরাং _μ<sub>i</sub>_ হল অপকোডের আগে মেমরিতে শব্দের সংখ্যা এবং _μ<sub>i</sub>'_ হল অপকোডের পরে মেমরিতে শব্দের সংখ্যা।

_C<sub>mem</sub>_ ফাংশনটি সমীকরণ 326-এ সংজ্ঞায়িত করা হয়েছে: _C<sub>mem</sub>(a) = G<sub>memory</sub> × a + ⌊a<sup>2</sup> ÷ 512⌋_। <em>⌊x⌋</em> হল ফ্লোর ফাংশন, একটি ফাংশন যা একটি মান দেওয়া হলে সেই বৃহত্তম পূর্ণসংখ্যাটি ফিরিয়ে দেয় যা এখনও মানের চেয়ে বড় নয়। উদাহরণস্বরূপ, _⌊2.5⌋ = ⌊2⌋ = 2।_ যখন _a < √512_ হয়, তখন _a<sup>2</sup> < 512_ হয় এবং ফ্লোর ফাংশনের ফলাফল শূন্য হয়। সুতরাং প্রথম 22টি শব্দের জন্য (704 বাইট), খরচ প্রয়োজনীয় মেমরি শব্দের সংখ্যার সাথে রৈখিকভাবে বৃদ্ধি পায়। সেই বিন্দুর পরে _⌊a<sup>2</sup> ÷ 512⌋_ ধনাত্মক হয়। যখন প্রয়োজনীয় মেমরি যথেষ্ট বেশি হয় তখন গ্যাস খরচ মেমরির পরিমাণের বর্গের সমানুপাতিক হয়।

**দ্রষ্টব্য** যে এই কারণগুলি শুধুমাত্র _অন্তর্নিহিত_ গ্যাস খরচকে প্রভাবিত করে - এটি ফি মার্কেট বা ভ্যালিডেটরদের দেওয়া টিপসকে বিবেচনায় নেয় না যা নির্ধারণ করে যে একজন শেষ ব্যবহারকারীকে কত টাকা দিতে হবে - এটি শুধুমাত্র EVM-এ একটি নির্দিষ্ট অপারেশন চালানোর কাঁচা খরচ।

[গ্যাস সম্পর্কে আরও পড়ুন](/developers/docs/gas/)।

## 9.3 এক্সিকিউশন এনভায়রনমেন্ট {#93-execution-env}

এক্সিকিউশন এনভায়রনমেন্ট হল একটি টাপল, _I_, যা এমন তথ্য অন্তর্ভুক্ত করে যা ব্লকচেইন স্টেট বা EVM-এর অংশ নয়।

| প্যারামিটার     | ডেটা অ্যাক্সেস করার জন্য অপকোড                                                                             | ডেটা অ্যাক্সেস করার জন্য Solidity কোড        |
| --------------- | ---------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
| _I<sub>a</sub>_ | [`ADDRESS`](https://www.evm.codes/#30)                                                                     | `address(this)`                              |
| _I<sub>o</sub>_ | [`ORIGIN`](https://www.evm.codes/#32)                                                                      | `tx.origin`                                  |
| _I<sub>p</sub>_ | [`GASPRICE`](https://www.evm.codes/#3a)                                                                    | `tx.gasprice`                                |
| _I<sub>d</sub>_ | [`CALLDATALOAD`](https://www.evm.codes/#35), ইত্যাদি।                                                      | `msg.data`                                   |
| _I<sub>s</sub>_ | [`CALLER`](https://www.evm.codes/#33)                                                                      | `msg.sender`                                 |
| _I<sub>v</sub>_ | [`CALLVALUE`](https://www.evm.codes/#34)                                                                   | `msg.value`                                  |
| _I<sub>b</sub>_ | [`CODECOPY`](https://www.evm.codes/#39)                                                                    | `address(this).code`                         |
| _I<sub>H</sub>_ | ব্লক হেডার ফিল্ড, যেমন [`NUMBER`](https://www.evm.codes/#43) এবং [`DIFFICULTY`](https://www.evm.codes/#44) | `block.number`, `block.difficulty`, ইত্যাদি। |
| _I<sub>e</sub>_ | চুক্তিগুলির মধ্যে কলের জন্য কল স্ট্যাকের গভীরতা (চুক্তি তৈরি সহ)                        |                                              |
| _I<sub>w</sub>_ | EVM কি স্টেট পরিবর্তন করার অনুমতিপ্রাপ্ত, নাকি এটি স্ট্যাটিক্যালি চলছে                                     |                                              |

বিভাগ 9-এর বাকি অংশ বোঝার জন্য আরও কয়েকটি প্যারামিটার প্রয়োজনীয়:

| প্যারামিটার | বিভাগে সংজ্ঞায়িত                                               | অর্থ                                                                                                                                                                                                                            |
| ----------- | --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _σ_         | 2 (পৃ. 2, সমীকরণ 1)          | ব্লকচেইনের স্টেট                                                                                                                                                                                                                |
| _g_         | 9.3 (পৃ. 13) | অবশিষ্ট গ্যাস                                                                                                                                                                                                                   |
| _A_         | 6.1 (পৃ. 8)  | অ্যাক্রুড সাবস্টেট (লেনদেন শেষ হওয়ার সময় নির্ধারিত পরিবর্তন)                                                                                                                                               |
| _o_         | 9.3 (পৃ. 13) | আউটপুট - অভ্যন্তরীণ লেনদেনের ক্ষেত্রে (যখন একটি চুক্তি অন্যটিকে কল করে) এবং ভিউ ফাংশনে কলের ক্ষেত্রে (যখন আপনি কেবল তথ্য চাইছেন, তাই লেনদেনের জন্য অপেক্ষা করার দরকার নেই) ফেরত আসা ফলাফল |

## 9.4 এক্সিকিউশন ওভারভিউ {#94-execution-overview}

এখন যেহেতু আমাদের সমস্ত প্রাথমিক বিষয়গুলি জানা হয়ে গেছে, আমরা অবশেষে EVM কীভাবে কাজ করে তা নিয়ে কাজ শুরু করতে পারি।

সমীকরণ 137-142 আমাদের EVM চালানোর জন্য প্রাথমিক শর্তগুলি দেয়:

| প্রতীক           | প্রাথমিক মান                                                                     | অর্থ                                                                                                                                                                                                                                                                                        |
| ---------------- | -------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| _μ<sub>g</sub>_  | _g_                                                                              | গ্যাস অবশিষ্ট                                                                                                                                                                                                                                                                               |
| _μ<sub>pc</sub>_ | _0_                                                                              | প্রোগ্রাম কাউন্টার, পরবর্তী নির্দেশ কার্যকর করার অ্যাড্রেস                                                                                                                                                                                                                                  |
| _μ<sub>m</sub>_  | _(0, 0, ...)_ | মেমরি, সব শূন্যতে ইনিশিয়ালাইজ করা                                                                                                                                                                                                                                                           |
| _μ<sub>i</sub>_  | _0_                                                                              | ব্যবহৃত সর্বোচ্চ মেমরি অবস্থান                                                                                                                                                                                                                                                              |
| _μ<sub>s</sub>_  | _()_                                                          | স্ট্যাক, প্রাথমিকভাবে খালি                                                                                                                                                                                                                                                                  |
| _μ<sub>o</sub>_  | _∅_                                                                              | আউটপুট, খালি সেট যতক্ষণ না এবং যদি না আমরা রিটার্ন ডেটা সহ ([`RETURN`](https://www.evm.codes/#f3) বা [`REVERT`](https://www.evm.codes/#fd)) অথবা এটি ছাড়া ([`STOP`](https://www.evm.codes/#00) বা [`SELFDESTRUCT`](https://www.evm.codes/#ff)) থামি। |

সমীকরণ 143 আমাদের বলে যে এক্সিকিউশনের সময় প্রতিটি মুহূর্তে চারটি সম্ভাব্য শর্ত রয়েছে, এবং সেগুলির সাথে কী করতে হবে:

1. `Z(σ,μ,A,I)`। Z একটি ফাংশন প্রতিনিধিত্ব করে যা পরীক্ষা করে যে কোনো অপারেশন একটি অবৈধ স্টেট ট্রানজিশন তৈরি করে কিনা (দেখুন [ব্যতিক্রমী থামা](#942-exceptional-halting))। যদি এটি True হিসাবে মূল্যায়ন করা হয়, তবে নতুন স্টেটটি পুরানোটির মতোই থাকে (ব্যতিক্রম গ্যাস পুড়ে যাওয়া) কারণ পরিবর্তনগুলি প্রয়োগ করা হয়নি।
2. যদি কার্যকর করা অপকোডটি [`REVERT`](https://www.evm.codes/#fd) হয়, তবে নতুন স্টেট পুরানো স্টেটের মতোই থাকে, কিছু গ্যাস নষ্ট হয়।
3. যদি অপারেশনের ক্রম শেষ হয়ে যায়, যেমনটি একটি [`RETURN`](https://www.evm.codes/#f3) দ্বারা নির্দেশিত হয়, তবে স্টেটটি নতুন স্টেটে আপডেট করা হয়।
4. যদি আমরা 1-3 শেষ শর্তগুলির মধ্যে একটিতে না থাকি, তবে চলতে থাকুন।

## 9.4.1 মেশিন স্টেট {#941-machine-state}

এই বিভাগটি মেশিন স্টেটকে আরও বিস্তারিতভাবে ব্যাখ্যা করে। এটি নির্দিষ্ট করে যে _w_ হল বর্তমান অপকোড। যদি _μ<sub>pc</sub>_ কোডের দৈর্ঘ্য _||I<sub>b</sub>||_ থেকে কম হয়, তবে সেই বাইট (_I<sub>b</sub>[μ<sub>pc</sub>]_) হল অপকোড। অন্যথায়, অপকোডটি [`STOP`](https://www.evm.codes/#00) হিসাবে সংজ্ঞায়িত করা হয়।

যেহেতু এটি একটি [স্ট্যাক মেশিন](https://en.wikipedia.org/wiki/Stack_machine), আমাদের প্রতিটি অপকোড দ্বারা পপ আউট করা (_δ_) এবং পুশ ইন করা (_α_) আইটেমের সংখ্যা ট্র্যাক রাখতে হবে।

## 9.4.2 ব্যতিক্রমী থামা {#942-exceptional-halt}

এই বিভাগটি _Z_ ফাংশনটিকে সংজ্ঞায়িত করে, যা নির্দিষ্ট করে কখন আমাদের একটি অস্বাভাবিক সমাপ্তি হয়। এটি একটি [বুলিয়ান](https://en.wikipedia.org/wiki/Boolean_data_type) ফাংশন, তাই এটি একটি [লজিক্যাল or এর জন্য _∨_](https://en.wikipedia.org/wiki/Logical_disjunction) এবং একটি [লজিক্যাল and এর জন্য _∧_](https://en.wikipedia.org/wiki/Logical_conjunction) ব্যবহার করে।

আমাদের একটি ব্যতিক্রমী থামা ঘটে যদি এই শর্তগুলির যেকোনো একটি সত্য হয়:

- **_μ<sub>g</sub> < C(σ,μ,A,I)_**
  যেমন আমরা বিভাগ 9.2-এ দেখেছি, _C_ হল সেই ফাংশন যা গ্যাস খরচ নির্দিষ্ট করে। পরবর্তী অপকোড কভার করার জন্য যথেষ্ট গ্যাস অবশিষ্ট নেই।

- **_δ<sub>w</sub>=∅_**
  যদি একটি অপকোডের জন্য পপ করা আইটেমের সংখ্যা অনির্ধারিত হয়, তবে অপকোডটি নিজেই অনির্ধারিত।

- **_|| μ<sub>s</sub> || < δ<sub>w</sub>_**
  স্ট্যাক আন্ডারফ্লো, বর্তমান অপকোডের জন্য স্ট্যাকে যথেষ্ট আইটেম নেই।

- **_w = JUMP ∧ μ<sub>s</sub>[0]∉D(I<sub>b</sub>)_**
  অপকোডটি হল [`JUMP`](https://www.evm.codes/#56) এবং অ্যাড্রেসটি একটি [`JUMPDEST`](https://www.evm.codes/#5b) নয়। জাম্পগুলি _কেবলমাত্র_ তখনই বৈধ যখন গন্তব্যটি একটি [`JUMPDEST`](https://www.evm.codes/#5b) হয়।

- **_w = JUMPI ∧ μ<sub>s</sub>[1]≠0 ∧ μ<sub>s</sub>[0] ∉ D(I<sub>b</sub>)_**
  অপকোডটি হল [`JUMPI`](https://www.evm.codes/#57), শর্তটি সত্য (অ-শূন্য) তাই জাম্প হওয়া উচিত, এবং অ্যাড্রেসটি একটি [`JUMPDEST`](https://www.evm.codes/#5b) নয়। জাম্পগুলি _কেবলমাত্র_ তখনই বৈধ যখন গন্তব্যটি একটি [`JUMPDEST`](https://www.evm.codes/#5b) হয়।

- **_w = RETURNDATACOPY ∧ μ<sub>s</sub>[1]+μ<sub>s</sub>[2]>|| μ<sub>o</sub> ||_**
  অপকোডটি হল [`RETURNDATACOPY`](https://www.evm.codes/#3e)। এই অপকোডে স্ট্যাক এলিমেন্ট _μ<sub>s</sub>[1]_ হল রিটার্ন ডেটা বাফারে পড়ার জন্য অফসেট, এবং স্ট্যাক এলিমেন্ট _μ<sub>s</sub>[2]_ হল ডেটার দৈর্ঘ্য। এই শর্তটি ঘটে যখন আপনি রিটার্ন ডেটা বাফারের শেষের বাইরে পড়ার চেষ্টা করেন। মনে রাখবেন যে calldata বা কোডের জন্য কোনো অনুরূপ শর্ত নেই। যখন আপনি সেই বাফারগুলির শেষের বাইরে পড়ার চেষ্টা করেন তখন আপনি কেবল শূন্য পান।

- **_|| μ<sub>s</sub> || - δ<sub>w</sub> + α<sub>w</sub> > 1024_**

  স্ট্যাক ওভারফ্লো। যদি অপকোডটি চালানোর ফলে 1024টিরও বেশি আইটেমের স্ট্যাক হয়, তবে বাতিল করুন।

- **_¬I<sub>w</sub> ∧ W(w,μ)_**
  আমরা কি স্ট্যাটিক্যালি চালাচ্ছি ([¬ হল নেগেশন](https://en.wikipedia.org/wiki/Negation) এবং _I<sub>w</sub>_ সত্য যখন আমাদের ব্লকচেইন স্টেট পরিবর্তন করার অনুমতি দেওয়া হয়)? যদি তাই হয়, এবং আমরা একটি স্টেট পরিবর্তনকারী অপারেশন চেষ্টা করি, তবে তা হতে পারে না।

  _W(w,μ)_ ফাংশনটি পরে সমীকরণ 150-এ সংজ্ঞায়িত করা হয়েছে। _W(w,μ)_ সত্য যদি এই শর্তগুলির মধ্যে একটি সত্য হয়:

  - **_w ∈ \{CREATE, CREATE2, SSTORE, SELFDESTRUCT}_**
    এই অপকোডগুলি স্টেট পরিবর্তন করে, হয় একটি নতুন চুক্তি তৈরি করে, একটি মান সঞ্চয় করে, অথবা বর্তমান চুক্তিটি ধ্বংস করে।

  - **_LOG0≤w ∧ w≤LOG4_**
    যদি আমাদের স্ট্যাটিক্যালি কল করা হয় তবে আমরা লগ এন্ট্রি নির্গত করতে পারি না।
    লগ অপকোডগুলি সবই [`LOG0` (A0)](https://www.evm.codes/#a0) এবং [`LOG4` (A4)](https://www.evm.codes/#a4)-এর মধ্যে পরিসরে রয়েছে।
    লগ অপকোডের পরের সংখ্যাটি নির্দিষ্ট করে যে লগ এন্ট্রিতে কতগুলি বিষয় রয়েছে।

  - **_w=CALL ∧ μ<sub>s</sub>[2]≠0_**
    আপনি স্ট্যাটিক থাকাকালীন অন্য চুক্তিকে কল করতে পারেন, কিন্তু যদি তা করেন তবে আপনি এতে ETH স্থানান্তর করতে পারবেন না।

- **_w = SSTORE ∧ μ<sub>g</sub> ≤ G<sub>callstipend</sub>_**
  আপনার কাছে G<sub>callstipend</sub> (Appendix G-এ 2300 হিসাবে সংজ্ঞায়িত) গ্যাসের চেয়ে বেশি না থাকলে আপনি [`SSTORE`](https://www.evm.codes/#55) চালাতে পারবেন না।

## 9.4.3 জাম্প ডেস্টিনেশন ভ্যালিডিটি {#943-jump-dest-valid}

এখানে আমরা আনুষ্ঠানিকভাবে সংজ্ঞায়িত করি যে [`JUMPDEST`](https://www.evm.codes/#5b) অপকোডগুলি কী। আমরা কেবল 0x5B বাইট মান খুঁজতে পারি না, কারণ এটি একটি PUSH-এর ভিতরে থাকতে পারে (এবং তাই ডেটা, অপকোড নয়)।

সমীকরণ (153)-এ আমরা একটি ফাংশন, _N(i,w)_ সংজ্ঞায়িত করি। প্রথম প্যারামিটার, _i_, হল অপকোডের অবস্থান। দ্বিতীয়টি, _w_, হল অপকোড নিজেই। যদি _w∈[PUSH1, PUSH32]_ হয় তার মানে হল অপকোডটি একটি PUSH (বর্গাকার বন্ধনী একটি পরিসর সংজ্ঞায়িত করে যা শেষবিন্দুগুলি অন্তর্ভুক্ত করে)। যদি সেই ক্ষেত্রে পরবর্তী অপকোডটি _i+2+(w−PUSH1)_ এ থাকে। [`PUSH1`](https://www.evm.codes/#60)-এর জন্য আমাদের দুটি বাইট (PUSH নিজেই এবং এক বাইটের মান), [`PUSH2`](https://www.evm.codes/#61)-এর জন্য আমাদের তিনটি বাইট এগোতে হবে কারণ এটি একটি দুই বাইটের মান, ইত্যাদি। অন্যান্য সমস্ত EVM অপকোড মাত্র এক বাইট দীর্ঘ, তাই অন্যান্য সমস্ত ক্ষেত্রে _N(i,w)=i+1_।

এই ফাংশনটি সমীকরণ (152)-এ _D<sub>J</sub>(c,i)_ সংজ্ঞায়িত করতে ব্যবহৃত হয়, যা কোড _c_-তে সমস্ত বৈধ জাম্প গন্তব্যের [সেট](https://en.wikipedia.org/wiki/Set_\(mathematics\)), যা অপকোড অবস্থান _i_ থেকে শুরু হয়। এই ফাংশনটি পুনরাবৃত্তিমূলকভাবে সংজ্ঞায়িত করা হয়েছে। যদি _i≥||c||_ হয়, তার মানে আমরা কোডের শেষে বা তার পরে আছি। আমরা আর কোনো জাম্প গন্তব্য খুঁজে পাব না, তাই কেবল খালি সেটটি ফিরিয়ে দিন।

অন্যান্য সমস্ত ক্ষেত্রে আমরা পরবর্তী অপকোডে গিয়ে এবং সেখান থেকে শুরু হওয়া সেটটি পেয়ে কোডের বাকি অংশ দেখি। _c[i]_ হল বর্তমান অপকোড, তাই _N(i,c[i])_ হল পরবর্তী অপকোডের অবস্থান। _D<sub>J</sub>(c,N(i,c[i]))_ হল তাই বৈধ জাম্প গন্তব্যের সেট যা পরবর্তী অপকোড থেকে শুরু হয়। যদি বর্তমান অপকোডটি `JUMPDEST` না হয়, তবে কেবল সেই সেটটি ফিরিয়ে দিন। যদি এটি `JUMPDEST` হয়, তবে এটি ফলাফল সেটে অন্তর্ভুক্ত করুন এবং সেটি ফিরিয়ে দিন।

## 9.4.4 স্বাভাবিক থামা {#944-normal-halt}

থামার ফাংশন _H_, তিন ধরনের মান ফিরিয়ে দিতে পারে।

- যদি আমরা একটি হল্ট অপকোডে না থাকি, তবে _∅_, খালি সেটটি ফিরিয়ে দিন। প্রচলিত রীতি অনুসারে, এই মানটি বুলিয়ান false হিসাবে ব্যাখ্যা করা হয়।
- যদি আমাদের একটি হল্ট অপকোড থাকে যা আউটপুট তৈরি করে না (হয় [`STOP`](https://www.evm.codes/#00) অথবা [`SELFDESTRUCT`](https://www.evm.codes/#ff)), তবে রিটার্ন মান হিসাবে শূন্য আকারের বাইটের একটি ক্রম ফিরিয়ে দিন। মনে রাখবেন যে এটি খালি সেট থেকে খুব আলাদা। এই মানের অর্থ হল যে EVM সত্যিই থেমে গেছে, শুধু পড়ার জন্য কোনো রিটার্ন ডেটা নেই।
- যদি আমাদের একটি হল্ট অপকোড থাকে যা আউটপুট তৈরি করে (হয় [`RETURN`](https://www.evm.codes/#f3) অথবা [`REVERT`](https://www.evm.codes/#fd)), তবে সেই অপকোড দ্বারা নির্দিষ্ট বাইটের ক্রমটি ফিরিয়ে দিন। এই ক্রমটি মেমরি থেকে নেওয়া হয়, স্ট্যাকের শীর্ষে থাকা মান (_μ<sub>s</sub>[0]_) হল প্রথম বাইট, এবং এর পরের মান (_μ<sub>s</sub>[1]_) হল দৈর্ঘ্য।

## H.2 ইন্সট্রাকশন সেট {#h2-instruction-set}

EVM-এর চূড়ান্ত উপবিভাগ, 9.5-এ যাওয়ার আগে, আসুন ইন্সট্রাকশনগুলিই দেখে নেওয়া যাক। সেগুলি Appendix H.2-এ সংজ্ঞায়িত করা হয়েছে যা পৃষ্ঠা 29 থেকে শুরু হয়। যে কোনো কিছু যা সেই নির্দিষ্ট অপকোডের সাথে পরিবর্তনশীল হিসাবে নির্দিষ্ট করা হয়নি তা একই থাকবে বলে আশা করা হয়। যে ভেরিয়েবলগুলি পরিবর্তন হয় সেগুলি \<something\>′ হিসাবে নির্দিষ্ট করা হয়।

উদাহরণস্বরূপ, আসুন [`ADD`](https://www.evm.codes/#01) অপকোডটি দেখি।

|  মান | নেমোনিক | δ | α | বিবরণ                                                                                                                                                                                                                 |
| ---: | ------- | - | - | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 0x01 | ADD     | 2 | 1 | যোগ অপারেশন।                                                                                                                                                                                                          |
|      |         |   |   | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[0] + μ<sub>s</sub>[1]_ |

_δ_ হল স্ট্যাক থেকে আমরা যে মানগুলি পপ করি তার সংখ্যা। এই ক্ষেত্রে দুটি, কারণ আমরা শীর্ষ দুটি মান যোগ করছি।

_α_ হল আমরা যে মানগুলি আবার পুশ করি তার সংখ্যা। এই ক্ষেত্রে একটি, যোগফল।

সুতরাং নতুন স্ট্যাক টপ (_μ′<sub>s</sub>[0]_) হল পুরানো স্ট্যাক টপ (_μ<sub>s</sub>[0]_) এবং এর নীচের পুরানো মান (_μ<sub>s</sub>[1]_)-এর যোগফল।

"চোখ ধাঁধানো তালিকা" দিয়ে সমস্ত অপকোডগুলি দেখার পরিবর্তে, এই নিবন্ধটি কেবল সেই অপকোডগুলি ব্যাখ্যা করে যা নতুন কিছু প্রবর্তন করে।

|  মান | নেমোনিক   | δ | α | বিবরণ                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ---: | --------- | - | - | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 0x20 | KECCAK256 | 2 | 1 | Keccak-256 হ্যাশ গণনা করুন।                                                                                                                                                                                                                                                                                                                                                                                                          |
|      |           |   |   | _μ′<sub>s</sub>[0] ≡ KEC(μ<sub>m</sub>[μ<sub>s</sub>[0] . । । (μ<sub>s</sub>[0] + μ<sub>s</sub>[1] − 1)])_ |
|      |           |   |   | _μ′<sub>i</sub> ≡ M(μ<sub>i</sub>,μ<sub>s</sub>[0],μ<sub>s</sub>[1])_                                                                                                                                                                                                                                     |

এটি প্রথম অপকোড যা মেমরি অ্যাক্সেস করে (এই ক্ষেত্রে, শুধুমাত্র পঠনযোগ্য)। তবে, এটি মেমরির বর্তমান সীমার বাইরে প্রসারিত হতে পারে, তাই আমাদের _μ<sub>i</sub>_ আপডেট করতে হবে। আমরা এটি পৃষ্ঠা 29-এর সমীকরণ 328-এ সংজ্ঞায়িত _M_ ফাংশন ব্যবহার করে করি।

|  মান | নেমোনিক | δ | α | বিবরণ                                               |
| ---: | ------- | - | - | --------------------------------------------------- |
| 0x31 | BALANCE | 1 | 1 | প্রদত্ত অ্যাকাউন্টের ব্যালেন্স পান।                 |
|      |         |   |   | ... |

যে অ্যাড্রেসের ব্যালেন্স আমাদের খুঁজে বের করতে হবে তা হল _μ<sub>s</sub>[0] mod 2<sup>160</sup>_। স্ট্যাকের শীর্ষটি হল অ্যাড্রেস, কিন্তু যেহেতু অ্যাড্রেসগুলি কেবল 160 বিট, আমরা মানটি [মডুলো](https://en.wikipedia.org/wiki/Modulo_operation) 2<sup>160</sup> গণনা করি।

যদি _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] ≠ ∅_ হয়, তার মানে এই অ্যাড্রেস সম্পর্কে তথ্য রয়েছে। সেই ক্ষেত্রে, _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>]<sub>b</sub>_ হল সেই অ্যাড্রেসের ব্যালেন্স। যদি _σ[μ<sub>s</sub>[0] mod 2<sup>160</sup>] = ∅_ হয়, তার মানে এই অ্যাড্রেসটি ইনিশিয়ালাইজ করা হয়নি এবং ব্যালেন্স শূন্য। আপনি পৃষ্ঠা 4-এর বিভাগ 4.1-এ অ্যাকাউন্ট তথ্যের ফিল্ডগুলির তালিকা দেখতে পারেন।

দ্বিতীয় সমীকরণ, _A'<sub>a</sub> ≡ A<sub>a</sub> ∪ \{μ<sub>s</sub>[0] mod 2<sup>160</sup>}_, ওয়ার্ম স্টোরেজ (সম্প্রতি অ্যাক্সেস করা এবং ক্যাশ হওয়ার সম্ভাবনাময় স্টোরেজ) এবং কোল্ড স্টোরেজ (অ্যাক্সেস করা হয়নি এবং ধীরগতির স্টোরেজে থাকার সম্ভাবনাময় যা পুনরুদ্ধার করা আরও ব্যয়বহুল) অ্যাক্সেসের মধ্যে খরচের পার্থক্যের সাথে সম্পর্কিত। _A<sub>a</sub>_ হল লেনদেন দ্বারা পূর্বে অ্যাক্সেস করা অ্যাড্রেসের তালিকা, যা তাই অ্যাক্সেস করা সস্তা হওয়া উচিত, যেমনটি পৃষ্ঠা 8-এর বিভাগ 6.1-এ সংজ্ঞায়িত করা হয়েছে। আপনি [EIP-2929](https://eips.ethereum.org/EIPS/eip-2929)-এ এই বিষয়ে আরও পড়তে পারেন।

|  মান | নেমোনিক | δ  | α  | বিবরণ                                                                                                                                           |
| ---: | ------- | -- | -- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 0x8F | DUP16   | 16 | 17 | 16তম স্ট্যাক আইটেম ডুপ্লিকেট করুন।                                                                                                              |
|      |         |    |    | _μ′<sub>s</sub>[0] ≡ μ<sub>s</sub>[15]_ |

মনে রাখবেন যে কোনো স্ট্যাক আইটেম ব্যবহার করার জন্য, আমাদের এটি পপ করতে হবে, যার মানে হল আমাদের এর উপরে থাকা সমস্ত স্ট্যাক আইটেমও পপ করতে হবে। [`DUP<n>`](https://www.evm.codes/#8f) এবং [`SWAP<n>`](https://www.evm.codes/#9f)-এর ক্ষেত্রে, এর মানে হল ষোলটি পর্যন্ত মান পপ করে তারপর পুশ করতে হবে।

## 9.5 এক্সিকিউশন চক্র {#95-exec-cycle}

এখন যেহেতু আমাদের সমস্ত অংশ জানা আছে, আমরা অবশেষে বুঝতে পারি EVM-এর এক্সিকিউশন চক্র কীভাবে নথিভুক্ত করা হয়েছে।

সমীকরণ (155) বলে যে স্টেট দেওয়া হলে:

- _σ_ (গ্লোবাল ব্লকচেইন স্টেট)
- _μ_ (EVM স্টেট)
- _A_ (সাবস্টেট, লেনদেন শেষ হলে যে পরিবর্তনগুলি ঘটবে)
- _I_ (এক্সিকিউশন এনভায়রনমেন্ট)

নতুন স্টেট হল _(σ', μ', A', I')_।

সমীকরণ (156)-(158) স্ট্যাক এবং একটি অপকোডের কারণে এতে পরিবর্তন (_μ<sub>s</sub>_) সংজ্ঞায়িত করে। সমীকরণ (159) হল গ্যাসের পরিবর্তন (_μ<sub>g</sub>_)। সমীকরণ (160) হল প্রোগ্রাম কাউন্টারের পরিবর্তন (_μ<sub>pc</sub>_)। অবশেষে, সমীকরণ (161)-(164) নির্দিষ্ট করে যে অন্যান্য প্যারামিটারগুলি একই থাকে, যদি না অপকোড দ্বারা স্পষ্টভাবে পরিবর্তন করা হয়।

এর মাধ্যমে EVM সম্পূর্ণরূপে সংজ্ঞায়িত।

## উপসংহার {#conclusion}

গাণিতিক নোটেশন সুনির্দিষ্ট এবং ইয়েলো পেপারকে Ethereum-এর প্রতিটি বিবরণ নির্দিষ্ট করতে দিয়েছে। তবে, এর কিছু অসুবিধাও রয়েছে:

- এটি কেবল মানুষই বুঝতে পারে, যার মানে হল [কমপ্লায়েন্স পরীক্ষা](https://github.com/ethereum/tests) ম্যানুয়ালি লিখতে হবে।
- প্রোগ্রামাররা কম্পিউটার কোড বোঝেন।
  তারা গাণিতিক নোটেশন বুঝতেও পারে বা নাও বুঝতে পারে।

সম্ভবত এই কারণগুলির জন্য, নতুন [কনসেন্সাস লেয়ার স্পেকস](https://github.com/ethereum/consensus-specs/blob/dev/tests/core/pyspec/README.md) Python-এ লেখা হয়েছে। Python-এ [এক্সিকিউশন লেয়ার স্পেকস](https://ethereum.github.io/execution-specs) রয়েছে, কিন্তু সেগুলি সম্পূর্ণ নয়। যতক্ষণ না এবং যদি না সম্পূর্ণ ইয়েলো পেপারটি Python বা অনুরূপ কোনো ভাষায় অনুবাদ করা হয়, ততক্ষণ ইয়েলো পেপারটি পরিষেবাতে থাকবে, এবং এটি পড়তে পারা সহায়ক।
