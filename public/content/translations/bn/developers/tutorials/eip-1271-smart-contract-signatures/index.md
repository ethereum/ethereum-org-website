---
title: "EIP-1271: স্মার্ট কন্ট্র্যাক্ট স্বাক্ষর করা এবং যাচাই করা"
description: EIP-1271 সহ স্মার্ট কন্ট্র্যাক্ট স্বাক্ষর তৈরি এবং যাচাইকরণের একটি সংক্ষিপ্ত বিবরণ। আমরা Safe (পূর্বে Gnosis Safe) এ ব্যবহৃত EIP-1271 ইমপ্লিমেন্টেশন নিয়েও আলোচনা করব যাতে স্মার্ট কন্ট্র্যাক্ট ডেভেলপারদের জন্য একটি সুনির্দিষ্ট উদাহরণ দেওয়া যায়।
author: Nathan H. Leung
lang: bn
tags:
  [
    "eip-1271",
    "স্মার্ট কন্ট্র্যাক্ট",
    "যাচাইকরণ",
    "স্বাক্ষর করা"
  ]
skill: intermediate
published: 2023-01-12
---

[EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) স্ট্যান্ডার্ড স্মার্ট কন্ট্র্যাক্টকে স্বাক্ষর যাচাই করার অনুমতি দেয়।

এই টিউটোরিয়ালে, আমরা ডিজিটাল স্বাক্ষর, EIP-1271-এর প্রেক্ষাপট এবং [Safe](https://safe.global/) (পূর্বে Gnosis Safe) দ্বারা ব্যবহৃত EIP-1271-এর নির্দিষ্ট ইমপ্লিমেন্টেশন সম্পর্কে একটি সংক্ষিপ্ত বিবরণ দেব। সব মিলিয়ে, এটি আপনার নিজের কন্ট্র্যাক্টে EIP-1271 প্রয়োগ করার জন্য একটি সূচনা বিন্দু হিসাবে কাজ করতে পারে।

## স্বাক্ষর কী?

এই প্রসঙ্গে, একটি স্বাক্ষর (আরও স্পষ্টভাবে, একটি “ডিজিটাল স্বাক্ষর”) হল একটি বার্তা এবং তার সাথে এক ধরনের প্রমাণ যে বার্তাটি একটি নির্দিষ্ট ব্যক্তি/প্রেরক/অ্যাড্রেস থেকে এসেছে।

উদাহরণস্বরূপ, একটি ডিজিটাল স্বাক্ষর এইরকম দেখতে হতে পারে:

1. বার্তা: “আমি আমার ইথেরিয়াম ওয়ালেট দিয়ে এই ওয়েবসাইটে লগ ইন করতে চাই।”
2. স্বাক্ষরকারী: আমার অ্যাড্রেস হল `0x000…`
3. প্রমাণ: এখানে কিছু প্রমাণ দেওয়া হল যে আমি, `0x000…`, আসলে এই সম্পূর্ণ বার্তাটি তৈরি করেছি (এটি সাধারণত ক্রিপ্টোগ্রাফিক কিছু)।

এটা মনে রাখা জরুরি যে একটি ডিজিটাল স্বাক্ষরের মধ্যে একটি “বার্তা” এবং একটি “স্বাক্ষর” দুটোই থাকে।

কেন? উদাহরণস্বরূপ, যদি আপনি আমাকে স্বাক্ষর করার জন্য একটি চুক্তি দেন, এবং তারপর আমি স্বাক্ষরের পৃষ্ঠাটি কেটে ফেলি এবং চুক্তির বাকি অংশ ছাড়া শুধুমাত্র আমার স্বাক্ষরগুলি আপনাকে ফিরিয়ে দিই, তবে চুক্তিটি বৈধ হবে না।

একইভাবে, একটি সংশ্লিষ্ট বার্তা ছাড়া একটি ডিজিটাল স্বাক্ষরের কোনো অর্থ হয় না!

## EIP-1271 কেন বিদ্যমান?

Ethereum-ভিত্তিক ব্লকচেইনে ব্যবহারের জন্য একটি ডিজিটাল স্বাক্ষর তৈরি করতে, আপনার সাধারণত একটি গোপন প্রাইভেট কী প্রয়োজন যা অন্য কেউ জানে না। এটাই আপনার স্বাক্ষরকে, আপনার করে তোলে (গোপন কী না জেনে অন্য কেউ একই স্বাক্ষর তৈরি করতে পারে না)।

আপনার ইথেরিয়াম অ্যাকাউন্টের (অর্থাৎ, আপনার এক্সটারনালি-ওনড অ্যাকাউন্ট/EOA) সাথে একটি প্রাইভেট কী যুক্ত আছে এবং এই প্রাইভেট কী সাধারণত তখনই ব্যবহৃত হয় যখন কোনো ওয়েবসাইট বা ডিএ্যাপ আপনাকে স্বাক্ষরের জন্য জিজ্ঞাসা করে (যেমন, “ইথেরিয়াম দিয়ে লগইন করুন”)।

একটি অ্যাপ ethers.js-এর মতো একটি থার্ড-পার্টি লাইব্রেরি ব্যবহার করে আপনার তৈরি করা [একটি স্বাক্ষর যাচাই করতে পারে](https://www.alchemy.com/docs/how-to-verify-a-message-signature-on-ethereum) [আপনার প্রাইভেট কী না জেনেই](https://en.wikipedia.org/wiki/Public-key_cryptography) এবং নিশ্চিত হতে পারে যে _আপনিই_ সেই স্বাক্ষরটি তৈরি করেছেন।

> আসলে, যেহেতু EOA ডিজিটাল স্বাক্ষর পাবলিক-কী ক্রিপ্টোগ্রাফি ব্যবহার করে, তাই সেগুলি **অফচেইন** তৈরি এবং যাচাই করা যেতে পারে! এইভাবেই গ্যাস-বিহীন DAO ভোটিং কাজ করে — অনচেইনে ভোট জমা দেওয়ার পরিবর্তে, ক্রিপ্টোগ্রাফিক লাইব্রেরি ব্যবহার করে ডিজিটাল স্বাক্ষর অফচেইনে তৈরি এবং যাচাই করা যেতে পারে।

যেখানে EOA অ্যাকাউন্টে একটি প্রাইভেট কী থাকে, সেখানে স্মার্ট কন্ট্র্যাক্ট অ্যাকাউন্টে কোনো ধরনের প্রাইভেট বা গোপন কী থাকে না (তাই "ইথেরিয়াম দিয়ে লগইন করুন", ইত্যাদি স্মার্ট কন্ট্র্যাক্ট অ্যাকাউন্টের সাথে স্বাভাবিকভাবে কাজ করতে পারে না)।

EIP-1271 যে সমস্যার সমাধান করার লক্ষ্য রাখে: আমরা কীভাবে বলতে পারি যে একটি স্মার্ট কন্ট্র্যাক্ট স্বাক্ষর বৈধ যদি স্মার্ট কন্ট্র্যাক্টের এমন কোনো “গোপন” তথ্য না থাকে যা এটি স্বাক্ষরে অন্তর্ভুক্ত করতে পারে?

## EIP-1271 কীভাবে কাজ করে?

স্মার্ট কন্ট্র্যাক্টে এমন কোনো প্রাইভেট কী নেই যা বার্তা স্বাক্ষর করতে ব্যবহার করা যেতে পারে। তাহলে আমরা কীভাবে বলতে পারি যে একটি স্বাক্ষর আসল কিনা?

আচ্ছা, একটি ধারণা হল যে আমরা শুধু স্মার্ট কন্ট্র্যাক্টকেই _জিজ্ঞাসা_ করতে পারি যে একটি স্বাক্ষর আসল কিনা!

EIP-1271 যা করে তা হল, একটি প্রদত্ত স্বাক্ষর বৈধ কিনা তা একটি স্মার্ট কন্ট্র্যাক্টকে “জিজ্ঞাসা” করার এই ধারণাটিকে এটি মানসম্মত করে।

EIP-1271 প্রয়োগকারী একটি কন্ট্র্যাক্টে `isValidSignature` নামে একটি ফাংশন থাকতে হবে যা একটি বার্তা এবং একটি স্বাক্ষর ইনপুট হিসেবে নেয়। কন্ট্র্যাক্টটি তখন কিছু যাচাইকরণ লজিক চালাতে পারে (স্পেক এখানে নির্দিষ্ট কিছু প্রয়োগ করে না) এবং তারপর স্বাক্ষরটি বৈধ কিনা তা নির্দেশ করে একটি মান ফিরিয়ে দিতে পারে।

যদি `isValidSignature` একটি বৈধ ফলাফল প্রদান করে, তবে সেটা অনেকটা কন্ট্র্যাক্টের বলার মতোই, “হ্যাঁ, আমি এই স্বাক্ষর + বার্তা অনুমোদন করছি!”

### ইন্টারফেস

EIP-1271 স্পেকে সঠিক ইন্টারফেসটি এখানে দেওয়া হলো (আমরা নীচে `_hash` প্যারামিটার সম্পর্কে কথা বলব, কিন্তু আপাতত, এটিকে সেই বার্তা হিসাবে ভাবুন যা যাচাই করা হচ্ছে):

```jsx
pragma solidity ^0.5.0;\n\ncontract ERC1271 {\n\n  // বাইট4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n  bytes4 constant internal MAGICVALUE = 0x1626ba7e;\n\n  /**\n   * @dev প্রদত্ত হ্যাশের জন্য প্রদত্ত স্বাক্ষরটি বৈধ কিনা তা ফেরানো উচিত\n   * @param _hash      স্বাক্ষর করার ডেটার হ্যাস\n   * @param _signature _hash-এর সাথে যুক্ত স্বাক্ষর বাইট অ্যারে\n   *\n   * ফাংশন পাস হলে অবশ্যই বাইট4 ম্যাজিক ভ্যালু 0x1626ba7e ফেরাতে হবে।\n   * অবশ্যই স্টেট পরিবর্তন করা যাবে না (solc < 0.5 এর জন্য STATICCALL ব্যবহার করে, solc > 0.5 এর জন্য view মডিফায়ার ব্যবহার করে)\n   * এক্সটারনাল কলের অনুমতি দিতে হবে\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes memory _signature)\n    public\n    view\n    returns (bytes4 magicValue);\n}
```

## উদাহরণ EIP-1271 ইমপ্লিমেন্টেশন: Safe

কন্ট্র্যাক্টগুলি অনেক উপায়ে `isValidSignature` প্রয়োগ করতে পারে — স্পেকটি সঠিক ইমপ্লিমেন্টেশন সম্পর্কে খুব বেশি কিছু বলে না।

EIP-1271 প্রয়োগকারী একটি উল্লেখযোগ্য কন্ট্র্যাক্ট হল Safe (পূর্বে Gnosis Safe)।

Safe-এর কোডে, `isValidSignature` [বাস্তবায়ন করা হয়েছে](https://github.com/safe-global/safe-contracts/blob/main/contracts/handler/CompatibilityFallbackHandler.sol) যাতে [দুটি উপায়ে](https://ethereum.stackexchange.com/questions/122635/signing-messages-as-a-gnosis-safe-eip1271-support) স্বাক্ষর তৈরি এবং যাচাই করা যায়:

1. অনচেইন বার্তা
   1. তৈরি: একজন সেফ মালিক একটি বার্তাকে “স্বাক্ষর” করার জন্য একটি নতুন সেফ লেনদেন তৈরি করেন, এবং লেনদেনে ডেটা হিসাবে বার্তাটি পাস করেন। মাল্টিসিগ থ্রেশহোল্ডে পৌঁছানোর জন্য পর্যাপ্ত মালিকরা লেনদেনটিতে স্বাক্ষর করার পরে, লেনদেনটি ব্রডকাস্ট এবং রান করা হয়। লেনদেনটিতে, (`signMessage(bytes calldata _data)`) নামে একটি সেফ ফাংশন রয়েছে যা বার্তাটিকে “অনুমোদিত” বার্তার তালিকায় যুক্ত করে।
   2. যাচাইকরণ: Safe কন্ট্র্যাক্টে `isValidSignature` কল করুন, এবং বার্তা প্যারামিটার হিসেবে যাচাই করার জন্য বার্তাটি পাস করুন এবং [স্বাক্ষর প্যারামিটারের জন্য একটি খালি মান](https://github.com/safe-global/safe-contracts/blob/main/contracts/handler/CompatibilityFallbackHandler.sol#L32) (অর্থাৎ, `0x`) পাস করুন। Safe দেখবে যে স্বাক্ষর প্যারামিটারটি খালি এবং স্বাক্ষরটি ক্রিপ্টোগ্রাফিকভাবে যাচাই করার পরিবর্তে, এটি কেবল এগিয়ে গিয়ে পরীক্ষা করবে যে বার্তাটি “অনুমোদিত” বার্তার তালিকায় আছে কিনা।
2. অফচেইন বার্তা:
   1. তৈরি: একজন সেফ মালিক অফচেইনে একটি বার্তা তৈরি করে, তারপর অন্য সেফ মালিকদের দিয়ে বার্তাটি পৃথকভাবে স্বাক্ষর করায় যতক্ষণ না মাল্টিসিগ অনুমোদনের থ্রেশহোল্ড অতিক্রম করার জন্য পর্যাপ্ত স্বাক্ষর হয়।
   2. যাচাইকরণ: `isValidSignature` কল করুন। বার্তা প্যারামিটারে, যাচাই করার জন্য বার্তাটি পাস করুন। স্বাক্ষর প্যারামিটারে, প্রতিটি সেফ মালিকের স্বতন্ত্র স্বাক্ষরগুলি পরপর একসাথে সংযুক্ত করে পাস করুন। Safe পরীক্ষা করবে যে থ্রেশহোল্ড পূরণ করার জন্য পর্যাপ্ত স্বাক্ষর আছে কিনা **এবং** প্রতিটি স্বাক্ষর বৈধ কিনা। যদি তাই হয়, এটি সফল স্বাক্ষর যাচাইকরণ নির্দেশ করে একটি মান ফিরিয়ে দেবে।

## `_hash` প্যারামিটারটি আসলে কী? পুরো বার্তাটি কেন পাস করা হয় না?

আপনি হয়তো লক্ষ্য করেছেন যে [EIP-1271 ইন্টারফেস](https://eips.ethereum.org/EIPS/eip-1271)-এর `isValidSignature` ফাংশনটি সরাসরি বার্তাটি নেয় না, বরং একটি `_hash` প্যারামিটার নেয়। এর মানে হল `isValidSignature`-এ সম্পূর্ণ ইচ্ছামতো দৈর্ঘ্যের বার্তা পাস করার পরিবর্তে, আমরা বার্তার একটি 32-বাইট হ্যাস (সাধারণত keccak256) পাস করি।

কলডেটার প্রতিটি বাইট — অর্থাৎ, একটি স্মার্ট কন্ট্র্যাক্ট ফাংশনে পাস করা ফাংশন প্যারামিটার ডেটা — [খরচ 16 গ্যাস (শূন্য বাইট হলে 4 গ্যাস)](https://eips.ethereum.org/EIPS/eip-2028), তাই বার্তাটি দীর্ঘ হলে এটি অনেক গ্যাস সাশ্রয় করতে পারে।

### পূর্ববর্তী EIP-1271 স্পেসিফিকেশন

এমন কিছু EIP-1271 স্পেসিফিকেশন প্রচলিত আছে যেগুলিতে `isValidSignature` ফাংশনের প্রথম প্যারামিটারের ধরন `bytes` (নির্দিষ্ট দৈর্ঘ্যের `bytes32` এর পরিবর্তে ইচ্ছামতো দৈর্ঘ্য) এবং প্যারামিটারের নাম `message`। এটি EIP-1271 স্ট্যান্ডার্ডের একটি [পুরানো সংস্করণ](https://github.com/safe-global/safe-contracts/issues/391#issuecomment-1075427206)।

## আমার নিজের কন্ট্র্যাক্টে EIP-1271 কীভাবে প্রয়োগ করা উচিত?

এই বিষয়ে স্পেকটি খুবই উন্মুক্ত। Safe ইমপ্লিমেন্টেশনে কিছু ভাল ধারণা রয়েছে:

- আপনি কন্ট্র্যাক্টের "মালিক"-এর কাছ থেকে আসা EOA স্বাক্ষরগুলিকে বৈধ বলে বিবেচনা করতে পারেন।
- আপনি অনুমোদিত বার্তার একটি তালিকা সংরক্ষণ করতে পারেন এবং শুধুমাত্র সেগুলিকে বৈধ বলে বিবেচনা করতে পারেন।

শেষ পর্যন্ত, কন্ট্র্যাক্ট ডেভেলপার হিসেবে এটি আপনার উপরই নির্ভর করে!

## উপসংহার

[EIP-1271](https://eips.ethereum.org/EIPS/eip-1271) একটি বহুমুখী স্ট্যান্ডার্ড যা স্মার্ট কন্ট্র্যাক্টকে স্বাক্ষর যাচাই করার অনুমতি দেয়। এটি স্মার্ট কন্ট্র্যাক্টগুলিকে EOA-এর মতো আরও বেশি কাজ করার সুযোগ করে দেয় — উদাহরণস্বরূপ "ইথেরিয়াম দিয়ে লগইন করুন" পদ্ধতিটিকে স্মার্ট কন্ট্র্যাক্টের সাথে কাজ করার একটি উপায় প্রদান করে — এবং এটি অনেক উপায়ে প্রয়োগ করা যেতে পারে (Safe-এর একটি গুরুত্বপূর্ণ, আকর্ষণীয় ইমপ্লিমেন্টেশন রয়েছে যা বিবেচনা করার মতো)।
