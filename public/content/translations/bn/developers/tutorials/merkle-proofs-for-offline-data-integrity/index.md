---
title: অফলাইন ডেটা ইন্টিগ্রিটির জন্য মেরকেল প্রুফস
description: যে ডেটা বেশিরভাগই অফচেইনে স্টোর করা থাকে, সেই ডেটার ইন্টিগ্রিটি অনচেইনে নিশ্চিত করা
author: Ori Pomerantz
tags: [ "সংগ্রহস্থল" ]
skill: advanced
lang: bn
published: 2021-12-30
---

## ভূমিকা {#introduction}

আদর্শগতভাবে আমরা ইথেরিয়াম সংগ্রহস্থলে সবকিছু স্টোর করতে চাই, যা হাজার হাজার কম্পিউটার জুড়ে স্টোর করা থাকে এবং এর
অত্যন্ত উচ্চ প্রাপ্যতা (ডেটা সেন্সর করা যায় না) এবং ইন্টিগ্রিটি (ডেটা অননুমোদিত উপায়ে পরিবর্তন করা যায় না) রয়েছে, তবে একটি 32-বাইট শব্দ স্টোর করতে সাধারণত 20,000 গ্যাস খরচ হয়। আমি যখন এটি লিখছি, তখন সেই খরচ
$6.60 এর সমতুল্য। প্রতি বাইটে 21 সেন্টে এটি অনেক ব্যবহারের জন্য খুবই ব্যয়বহুল।

এই সমস্যার সমাধান করার জন্য ইথেরিয়াম ইকোসিস্টেম বিকেন্দ্রীভূত উপায়ে ডেটা স্টোর করার জন্য [অনেক বিকল্প উপায় তৈরি করেছে](/developers/docs/storage/)। সাধারণত এগুলিতে প্রাপ্যতা
এবং মূল্যের মধ্যে একটি ট্রেডঅফ জড়িত থাকে। তবে, ইন্টিগ্রিটি সাধারণত নিশ্চিত করা হয়।

এই নিবন্ধে আপনি শিখবেন **কিভাবে** ব্লকচেইনে ডেটা স্টোর না করে ডেটা ইন্টিগ্রিটি নিশ্চিত করতে হয়, [Merkle proofs](https://computersciencewiki.org/index.php/Merkle_proof) ব্যবহার করে।

## এটি কিভাবে কাজ করে? {#how-does-it-work}

তাত্ত্বিকভাবে আমরা ডেটার হ্যাস অনচেইনে স্টোর করতে পারি, এবং লেনদেনে প্রয়োজনীয় সমস্ত ডেটা পাঠাতে পারি। তবে, এটি এখনও খুব ব্যয়বহুল। একটি লেনদেনে এক বাইট ডেটার জন্য প্রায় 16 গ্যাস খরচ হয়, বর্তমানে প্রায় অর্ধেক সেন্ট, বা প্রতি কিলোবাইটে প্রায় $5। প্রতি মেগাবাইটে $5000 হলে, এটি অনেক ব্যবহারের জন্য এখনও খুব ব্যয়বহুল, এমনকি ডেটা হ্যাস করার অতিরিক্ত খরচ ছাড়াই।

এর সমাধান হল ডেটার বিভিন্ন উপসেটকে বারবার হ্যাস করা, যাতে আপনার যে ডেটা পাঠাতে হবে না তার জন্য আপনি কেবল একটি হ্যাস পাঠাতে পারেন। আপনি এটি একটি Merkle tree ব্যবহার করে করেন, এটি একটি ট্রি ডেটা স্ট্রাকচার যেখানে প্রতিটি নোড তার নীচের নোডগুলির একটি হ্যাস:

![মেরকেল ট্রি](tree.png)

রুট হ্যাস হল একমাত্র অংশ যা অনচেইনে স্টোর করা প্রয়োজন। একটি নির্দিষ্ট মান প্রমাণ করতে, আপনি সমস্ত হ্যাস সরবরাহ করেন যা রুটে পৌঁছানোর জন্য এর সাথে একত্রিত করা প্রয়োজন। উদাহরণস্বরূপ, `C` প্রমাণ করতে আপনি `D`, `H(A-B)`, এবং `H(E-H)` সরবরাহ করেন।

![C-এর মানের প্রমাণ](proof-c.png)

## বাস্তবায়ন {#implementation}

[নমুনা কোডটি এখানে সরবরাহ করা হয়েছে](https://github.com/qbzzt/merkle-proofs-for-offline-data-integrity)।

### অফচেইন কোড {#offchain-code}

এই নিবন্ধে আমরা অফচেইন গণনার জন্য JavaScript ব্যবহার করি। বেশিরভাগ ডিসেন্ট্রালাইজড এপ্লিকেশনগুলির অফচেইন কম্পোনেন্ট JavaScript-এ থাকে।

#### Merkle রুট তৈরি করা {#creating-the-merkle-root}

প্রথমে আমাদের চেইনে Merkle রুট সরবরাহ করতে হবে।

```javascript
const ethers = require("ethers")
```

[আমরা ethers প্যাকেজ থেকে হ্যাস ফাংশনটি ব্যবহার করি](https://docs.ethers.io/v5/api/utils/hashing/#utils-keccak256)।

```javascript
// কাঁচা ডেটা যার ইন্টিগ্রিটি আমাদের যাচাই করতে হবে। প্রথম দুটি বাইট একটি
// ব্যবহারকারী শনাক্তকারী, এবং শেষ দুটি বাইট ব্যবহারকারীর বর্তমানে মালিকানাধীন টোকেনের পরিমাণ।
const dataArray = [
  0x0bad0010, 0x60a70020, 0xbeef0030, 0xdead0040, 0xca110050, 0x0e660060,
  0xface0070, 0xbad00080, 0x060d0091,
]
```

প্রতিটি এন্ট্রিকে একটি একক 256-বিট পূর্ণসংখ্যাতে এনকোড করার ফলে, উদাহরণস্বরূপ, JSON ব্যবহারের চেয়ে কম পঠনযোগ্য কোড তৈরি হয়। তবে, এর অর্থ হল চুক্তিতে ডেটা পুনরুদ্ধারের জন্য উল্লেখযোগ্যভাবে কম প্রক্রিয়াকরণ, তাই অনেক কম গ্যাস খরচ হয়। [আপনি অনচেইনে JSON পড়তে পারেন](https://github.com/chrisdotn/jsmnSol), এটি যদি এড়ানো যায় তবে এটি একটি খারাপ ধারণা।

```javascript
// হ্যাস মানের অ্যারে, BigInts হিসাবে
const hashArray = dataArray
```

এই ক্ষেত্রে আমাদের ডেটা শুরু করার জন্য 256-বিট মান, তাই কোনও প্রক্রিয়াকরণের প্রয়োজন নেই। আমরা যদি স্ট্রিংয়ের মতো আরও জটিল ডেটা স্ট্রাকচার ব্যবহার করি, তবে আমাদের নিশ্চিত করতে হবে যে আমরা প্রথমে ডেটা হ্যাস করে হ্যাসের একটি অ্যারে পেয়েছি। মনে রাখবেন যে এটিও কারণ ব্যবহারকারীরা অন্যান্য ব্যবহারকারীদের তথ্য জানলে আমাদের কিছু যায় আসে না। অন্যথায় আমাদের হ্যাস করতে হতো যাতে ব্যবহারকারী 1 ব্যবহারকারী 0-এর মান জানতে না পারে, ব্যবহারকারী 2 ব্যবহারকারী 3-এর মান জানতে না পারে ইত্যাদি।

```javascript
// হ্যাস ফাংশন যে স্ট্রিং আশা করে এবং আমরা অন্য সব জায়গায় যে BigInt ব্যবহার করি তার মধ্যে রূপান্তর করুন।
const hash = (x) =>
  BigInt(ethers.utils.keccak256("0x" + x.toString(16).padStart(64, 0)))
```

ethers হ্যাস ফাংশনটি একটি হেক্সাডেসিমেল সংখ্যা সহ একটি জাভাস্ক্রিপ্ট স্ট্রিং পাওয়ার আশা করে, যেমন `0x60A7`, এবং একই কাঠামো সহ অন্য একটি স্ট্রিং দিয়ে প্রতিক্রিয়া জানায়। তবে, বাকি কোডের জন্য `BigInt` ব্যবহার করা সহজ, তাই আমরা একটি হেক্সাডেসিমেল স্ট্রিংয়ে রূপান্তর করি এবং আবার ফিরে আসি।

```javascript
// একটি জোড়ার প্রতিসম হ্যাস যাতে ক্রমটি বিপরীত হলে আমাদের কিছু যায় আসে না।
const pairHash = (a, b) => hash(hash(a) ^ hash(b))
```

এই ফাংশনটি প্রতিসম (a [xor](https://en.wikipedia.org/wiki/Exclusive_or) b-এর হ্যাস)। এর মানে হল যে যখন আমরা Merkle প্রমাণটি পরীক্ষা করি তখন আমাদের প্রমাণের মানটি গণনাকৃত মানের আগে বা পরে রাখতে হবে কিনা তা নিয়ে চিন্তা করার দরকার নেই। Merkle প্রুফ চেকিং অনচেইনে করা হয়, তাই সেখানে আমাদের যত কম কাজ করতে হবে ততই ভালো।

সতর্কতা:
ক্রিপ্টোগ্রাফি দেখতে যতটা সহজ মনে হয় তার চেয়ে কঠিন।
এই নিবন্ধটির প্রাথমিক সংস্করণে `hash(a^b)` হ্যাস ফাংশন ছিল।
এটি একটি **খারাপ** ধারণা ছিল কারণ এর মানে হল যে আপনি যদি `a` এবং `b`-এর বৈধ মানগুলি জানতেন তবে আপনি যে কোনও পছন্দসই `a'` মান প্রমাণ করতে `b' = a^b^a'` ব্যবহার করতে পারতেন।
এই ফাংশনটির সাথে আপনাকে `b'` গণনা করতে হবে যাতে `hash(a') ^ hash(b')` একটি পরিচিত মানের সমান হয় (রুটে যাওয়ার পথে পরবর্তী শাখা), যা অনেক কঠিন।

```javascript
// একটি নির্দিষ্ট শাখা খালি, এর কোনো মান নেই বোঝানোর জন্য মান
// এর কোনো মান নেই
const empty = 0n
```

যখন মানের সংখ্যা দুইয়ের পূর্ণসংখ্যার ঘাত নয় তখন আমাদের খালি শাখাগুলি পরিচালনা করতে হবে। এই প্রোগ্রামটি যেভাবে এটি করে তা হল একটি স্থানধারক হিসাবে শূন্য রাখা।

![শাখা ছাড়া Merkle ট্রি](merkle-empty-hash.png)

```javascript
// ক্রমানুসারে প্রতিটি জোড়ার হ্যাস নিয়ে হ্যাস অ্যারের ট্রির এক স্তর উপরে গণনা করুন
// প্রতিটি জোড়ার পর্যায়ক্রমে
const oneLevelUp = (inputArray) => {
  var result = []
  var inp = [...inputArray] // ইনপুট ওভাররাইট করা এড়াতে // প্রয়োজনে একটি খালি মান যোগ করুন (আমাদের সব লিফকে // জোড়া করতে হবে)

  if (inp.length % 2 === 1) inp.push(empty)

  for (var i = 0; i < inp.length; i += 2)
    result.push(pairHash(inp[i], inp[i + 1]))

  return result
} // oneLevelUp
```

এই ফাংশনটি বর্তমান স্তরের মানগুলির জোড়া হ্যাস করে Merkle ট্রিতে এক স্তর "উপরে ওঠে"। মনে রাখবেন যে এটি সবচেয়ে কার্যকর বাস্তবায়ন নয়, আমরা ইনপুট অনুলিপি করা এড়াতে পারতাম এবং লুপে উপযুক্ত সময়ে `hashEmpty` যোগ করতে পারতাম, কিন্তু এই কোডটি পঠনযোগ্যতার জন্য অপ্টিমাইজ করা হয়েছে।

```javascript
const getMerkleRoot = (inputArray) => {
  var result

  result = [...inputArray] // ট্রি-এর উপরে উঠুন যতক্ষণ না কেবল একটি মান থাকে, যা // রুট। // // যদি একটি স্তরে বিজোড় সংখ্যক এন্ট্রি থাকে তবে // oneLevelUp-এর কোড একটি খালি মান যোগ করে, তাই যদি আমাদের কাছে থাকে, উদাহরণস্বরূপ, // ১০টি লিফ তাহলে দ্বিতীয় স্তরে আমাদের ৫টি শাখা থাকবে, তৃতীয় স্তরে ৩টি // শাখা, চতুর্থটিতে ২টি এবং রুটটি পঞ্চম

  while (result.length > 1) result = oneLevelUp(result)

  return result[0]
}
```

রুট পেতে, একটি মাত্র মান অবশিষ্ট থাকা পর্যন্ত উপরে উঠুন।

#### একটি Merkle প্রুফ তৈরি করা {#creating-a-merkle-proof}

একটি Merkle প্রুফ হল Merkle রুটে ফিরে যাওয়ার জন্য প্রমাণিত মানের সাথে একসাথে হ্যাস করার মান। প্রমাণ করার মানটি প্রায়শই অন্যান্য ডেটা থেকে পাওয়া যায়, তাই আমি এটিকে কোডের অংশ হিসাবে না দিয়ে আলাদাভাবে প্রদান করতে পছন্দ করি।

```javascript
// একটি মেরকেল প্রুফ এন্ট্রিগুলির তালিকার মান নিয়ে গঠিত যার সাথে
// হ্যাস করা হবে। কারণ আমরা একটি প্রতিসম হ্যাস ফাংশন ব্যবহার করি, আমাদের
// প্রুফ যাচাই করার জন্য আইটেমটির অবস্থানের প্রয়োজন নেই, শুধুমাত্র এটি তৈরি করার জন্য প্রয়োজন
const getMerkleProof = (inputArray, n) => {
    var result = [], currentLayer = [...inputArray], currentN = n

    // আমরা শীর্ষে না পৌঁছানো পর্যন্ত
    while (currentLayer.length > 1) {
        // বিজোড় দৈর্ঘ্যের স্তর নেই
        if (currentLayer.length % 2)
            currentLayer.push(empty)

        result.push(currentN % 2
               // যদি currentN বিজোড় হয়, তবে প্রুফের আগের মানটির সাথে যোগ করুন
            ? currentLayer[currentN-1]
               // যদি এটি জোড় হয়, তবে এর পরের মানটি যোগ করুন
            : currentLayer[currentN+1])

```

আমরা `(v[0],v[1])`, `(v[2],v[3])` ইত্যাদি হ্যাস করি। সুতরাং জোড় মানের জন্য আমাদের পরেরটি প্রয়োজন, বিজোড় মানের জন্য আগেরটি।

```javascript
        // পরবর্তী স্তরে যান
        currentN = Math.floor(currentN/2)
        currentLayer = oneLevelUp(currentLayer)
    }   // while currentLayer.length > 1

    return result
}   // getMerkleProof
```

### অনচেইন কোড {#onchain-code}

অবশেষে আমাদের কাছে কোড আছে যা প্রুফ পরীক্ষা করে। অনচেইন কোডটি [Solidity](https://docs.soliditylang.org/en/v0.8.11/) তে লেখা হয়েছে। এখানে অপ্টিমাইজেশন অনেক বেশি গুরুত্বপূর্ণ কারণ গ্যাস তুলনামূলকভাবে ব্যয়বহুল।

```solidity
//SPDX-License-Identifier: Public Domain
pragma solidity ^0.8.0;

import "hardhat/console.sol";
```

আমি এটি [Hardhat ডেভেলপমেন্ট এনভায়রনমেন্ট](https://hardhat.org/) ব্যবহার করে লিখেছি, যা আমাদের ডেভেলপ করার সময় [Solidity থেকে কনসোল আউটপুট](https://hardhat.org/docs/cookbook/debug-logs) পেতে দেয়।

```solidity

contract MerkleProof {
    uint merkleRoot;

    function getRoot() public view returns (uint) {
      return merkleRoot;
    }

    // অত্যন্ত নিরাপত্তাহীন, প্রোডাকশন কোডে অ্যাক্সেস
    // এই ফাংশনটি অবশ্যই কঠোরভাবে সীমিত হতে হবে, সম্ভবত একজন
    // মালিকের জন্য
    function setRoot(uint _merkleRoot) external {
      merkleRoot = _merkleRoot;
    }   // setRoot
```

Merkle রুটের জন্য সেট এবং গেট ফাংশন। সবাইকে Merkle রুট আপডেট করতে দেওয়া একটি প্রোডাকশন সিস্টেমে একটি _অত্যন্ত খারাপ ধারণা_। নমুনা কোডের জন্য সরলতার খাতিরে আমি এখানে এটি করি। **এমন সিস্টেমে এটি করবেন না যেখানে ডেটা ইন্টিগ্রিটি সত্যিই গুরুত্বপূর্ণ**।

```solidity
    function hash(uint _a) internal pure returns(uint) {
      return uint(keccak256(abi.encode(_a)));
    }

    function pairHash(uint _a, uint _b) internal pure returns(uint) {
      return hash(hash(_a) ^ hash(_b));
    }
```

এই ফাংশনটি একটি জোড়া হ্যাস তৈরি করে। এটি `hash` এবং `pairHash`-এর জন্য জাভাস্ক্রিপ্ট কোডের সলিডিটি অনুবাদ।

**দ্রষ্টব্য:** এটি পঠনযোগ্যতার জন্য অপ্টিমাইজেশনের আরেকটি ক্ষেত্র। [ফাংশন সংজ্ঞা](https://www.tutorialspoint.com/solidity/solidity_cryptographic_functions.htm)-এর উপর ভিত্তি করে, ডেটা একটি [`bytes32`](https://docs.soliditylang.org/en/v0.5.3/types.html#fixed-size-byte-arrays) মান হিসাবে স্টোর করা এবং রূপান্তরগুলি এড়ানো সম্ভব হতে পারে।

```solidity
    // একটি Merkle প্রুফ যাচাই করুন
    function verifyProof(uint _value, uint[] calldata _proof)
        public view returns (bool) {
      uint temp = _value;
      uint i;

      for(i=0; i<_proof.length; i++) {
        temp = pairHash(temp, _proof[i]);
      }

      return temp == merkleRoot;
    }

}  // MarkleProof
```

গাণিতিক স্বরলিপিতে Merkle প্রুফ যাচাইকরণ দেখতে এইরকম: `H(proof_n, H(proof_n-1, H(proof_n-2, ...` H(proof_1, H(proof_0, value))...)))\`। এই কোডটি এটি বাস্তবায়ন করে।

## Merkle প্রুফ এবং রোলআপগুলি মেশে না {#merkle-proofs-and-rollups}

Merkle প্রুফ [রোলআপ](/developers/docs/scaling/#rollups)-এর সাথে ভালো কাজ করে না। এর কারণ হল রোলআপগুলি L1-এ সমস্ত লেনদেনের ডেটা লেখে, কিন্তু L2-তে প্রক্রিয়া করে। একটি লেনদেনের সাথে একটি Merkle প্রুফ পাঠানোর খরচ প্রতি স্তরে গড়ে 638 গ্যাস (বর্তমানে কল ডেটাতে একটি বাইটের খরচ 16 গ্যাস যদি এটি শূন্য না হয়, এবং 4 যদি এটি শূন্য হয়)। যদি আমাদের কাছে 1024 শব্দের ডেটা থাকে, একটি Merkle প্রুফের জন্য দশটি স্তর বা মোট 6380 গ্যাস প্রয়োজন।

উদাহরণস্বরূপ [Optimism](https://public-grafana.optimism.io/d/9hkhMxn7z/public-dashboard?orgId=1&refresh=5m)-এ, L1 গ্যাস লেখার খরচ প্রায় 100 gwei এবং L2 গ্যাস খরচ 0.001 gwei (এটি স্বাভাবিক মূল্য, এটি কনজেশনের সাথে বাড়তে পারে)। সুতরাং একটি L1 গ্যাসের খরচে আমরা L2 প্রক্রিয়াকরণে এক লক্ষ গ্যাস ব্যয় করতে পারি। ধরে নিচ্ছি আমরা সংগ্রহস্থল ওভাররাইট করি না, এর মানে হল যে আমরা একটি L1 গ্যাসের দামে L2-তে সংগ্রহস্থলে প্রায় পাঁচটি শব্দ লিখতে পারি। একটি একক Merkle প্রুফের জন্য আমরা সম্পূর্ণ 1024 শব্দ সংগ্রহস্থলে লিখতে পারি (ধরে নিচ্ছি সেগুলি লেনদেনে সরবরাহ করার পরিবর্তে অনচেইনে গণনা করা যেতে পারে) এবং তারপরেও বেশিরভাগ গ্যাস অবশিষ্ট থাকে।

## উপসংহার {#conclusion}

বাস্তব জীবনে আপনি নিজে থেকে Merkle ট্রি বাস্তবায়ন নাও করতে পারেন। সুপরিচিত এবং নিরীক্ষিত লাইব্রেরি রয়েছে যা আপনি ব্যবহার করতে পারেন এবং সাধারণভাবে বলতে গেলে, নিজের থেকে ক্রিপ্টোগ্রাফিক প্রিমিটিভগুলি বাস্তবায়ন না করাই ভাল। কিন্তু আমি আশা করি যে এখন আপনি Merkle প্রুফগুলি আরও ভালভাবে বুঝতে পারবেন এবং সিদ্ধান্ত নিতে পারবেন যে কখন সেগুলি ব্যবহার করা মূল্যবান।

মনে রাখবেন যে Merkle প্রুফগুলি _ইন্টিগ্রিটি_ সংরক্ষণ করে, তারা _প্রাপ্যতা_ সংরক্ষণ করে না। অন্য কেউ আপনার সম্পদ নিতে পারবে না এটা জেনে সামান্য সান্ত্বনা হয় যদি ডেটা সংগ্রহস্থল অ্যাক্সেস নিষিদ্ধ করার সিদ্ধান্ত নেয় এবং আপনি সেগুলি অ্যাক্সেস করার জন্য একটি Merkle ট্রি তৈরি করতে না পারেন। সুতরাং Merkle ট্রি বিকেন্দ্রীভূত সংগ্রহস্থলের সাথে সবচেয়ে ভাল ব্যবহার করা হয়, যেমন IPFS।

[আমার আরও কাজের জন্য এখানে দেখুন](https://cryptodocguy.pro/)।
