---
title: "স্মার্ট কন্ট্র্যাক্ট নিরাপত্তা নির্দেশিকা"
description: "আপনার ডিএ্যাপ তৈরি করার সময় বিবেচনা করার জন্য নিরাপত্তা নির্দেশিকাগুলির একটি চেকলিস্ট"
author: "Trailofbits"
tags: [ "সলিডিটি", "স্মার্ট কন্ট্র্যাক্ট", "নিরাপত্তা" ]
skill: intermediate
lang: bn
published: 2020-09-06
source: Building secure contracts
sourceUrl: https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/guidelines.md
---

আরও সুরক্ষিত স্মার্ট কন্ট্র্যাক্ট তৈরি করতে এই উচ্চ-স্তরের সুপারিশগুলি অনুসরণ করুন।

## ডিজাইন নির্দেশিকা {#design-guidelines}

কোডের কোনো লাইন লেখার আগে, কন্ট্র্যাক্টটির ডিজাইন আগে থেকেই আলোচনা করা উচিত।

### নথিপত্র এবং স্পেসিফিকেশন {#documentation-and-specifications}

নথিপত্র বিভিন্ন স্তরে লেখা যেতে পারে এবং কন্ট্র্যাক্টগুলি বাস্তবায়ন করার সময় আপডেট করা উচিত:

- **সিস্টেমটির একটি সহজবোধ্য ইংরেজি বর্ণনা**, যেখানে কন্ট্র্যাক্টগুলি কী করে এবং কোডবেসের ওপর যেকোনো অনুমান তার বর্ণনা থাকবে।
- **স্কিমা এবং আর্কিটেকচারাল ডায়াগ্রাম**, কন্ট্র্যাক্টের ইন্টার‍্যাকশন এবং সিস্টেমের স্টেট মেশিন সহ। [Slither প্রিন্টার](https://github.com/crytic/slither/wiki/Printer-documentation) এই স্কিমাগুলি তৈরি করতে সাহায্য করতে পারে।
- **পুঙ্খানুপুঙ্খ কোড নথিপত্র**, Solidity-র জন্য [Natspec ফর্ম্যাট](https://docs.soliditylang.org/en/develop/natspec-format.html) ব্যবহার করা যেতে পারে।

### অনচেইন বনাম অফচেইন গণনা {#onchain-vs-offchain-computation}

- **যতটা সম্ভব কোড অফচেইন রাখুন।** অনচেইন লেয়ার ছোট রাখুন। অফচেইন কোড দিয়ে এমনভাবে ডেটা প্রি-প্রসেস করুন যাতে অনচেইনে যাচাইকরণ সহজ হয়। আপনার কি একটি অর্ডার করা তালিকা প্রয়োজন? তালিকাটি অফচেইনে সাজান, তারপর শুধু অনচেইনে তার ক্রম পরীক্ষা করুন।

### আপগ্রেডযোগ্যতা {#upgradeability}

আমরা [আমাদের ব্লগপোস্টে](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/) বিভিন্ন আপগ্রেডযোগ্যতার সমাধান নিয়ে আলোচনা করেছি। কোনো কোড লেখার আগে আপগ্রেডযোগ্যতা সমর্থন করবেন কি না সে বিষয়ে সজ্ঞানে একটি সিদ্ধান্ত নিন। এই সিদ্ধান্তটি আপনি কীভাবে আপনার কোড গঠন করেন তাকে প্রভাবিত করবে। সাধারণত, আমরা সুপারিশ করি:

- **আপগ্রেডযোগ্যতার চেয়ে [কন্ট্র্যাক্ট মাইগ্রেশনকে](https://blog.trailofbits.com/2018/10/29/how-contract-migration-works/) বেশি গুরুত্ব দিন।** মাইগ্রেশন সিস্টেমে আপগ্রেডযোগ্য সিস্টেমের মতো অনেক সুবিধা রয়েছে, তাদের অসুবিধাগুলো ছাড়াই।
- **delegatecallproxy প্যাটার্নের চেয়ে ডেটা সেপারেশন প্যাটার্ন ব্যবহার করুন।** যদি আপনার প্রোজেক্টে একটি স্পষ্ট অ্যাবস্ট্রাকশন সেপারেশন থাকে, তাহলে ডেটা সেপারেশন ব্যবহার করে আপগ্রেডযোগ্যতার জন্য শুধুমাত্র কয়েকটি সামঞ্জস্যের প্রয়োজন হবে। delegatecallproxy-এর জন্য EVM দক্ষতার প্রয়োজন এবং এটিতে ভুল হওয়ার সম্ভাবনা অনেক বেশি।
- **ডিপ্লয়মেন্টের আগে মাইগ্রেশন/আপগ্রেড পদ্ধতি নথিভুক্ত করুন।** যদি আপনাকে কোনো নির্দেশিকা ছাড়াই চাপের মধ্যে প্রতিক্রিয়া দেখাতে হয়, তাহলে আপনি ভুল করবেন। অনুসরণ করার পদ্ধতি আগে থেকেই লিখে রাখুন। এতে অন্তর্ভুক্ত করা উচিত:
  - যে কলগুলি নতুন কন্ট্র্যাক্ট শুরু করে
  - কি-গুলি কোথায় সংরক্ষণ করা হয়েছে এবং কীভাবে সেগুলি অ্যাক্সেস করতে হয়
  - কীভাবে ডিপ্লয়মেন্ট পরীক্ষা করবেন! একটি পোস্ট-ডিপ্লয়মেন্ট স্ক্রিপ্ট তৈরি করুন এবং পরীক্ষা করুন।

## বাস্তবায়ন নির্দেশিকা {#implementation-guidelines}

**সরলতার জন্য চেষ্টা করুন।** সর্বদা আপনার উদ্দেশ্যের সাথে মানানসই সহজতম সমাধানটি ব্যবহার করুন। আপনার দলের যেকোনো সদস্যের আপনার সমাধানটি বুঝতে পারা উচিত।

### ফাংশন কম্পোজিশন {#function-composition}

আপনার কোডবেসের আর্কিটেকচার আপনার কোডকে পর্যালোচনা করা সহজ করে তুলবে। এমন আর্কিটেকচারাল পছন্দগুলি এড়িয়ে চলুন যা এর সঠিকতা সম্পর্কে যুক্তি দেওয়ার ক্ষমতা হ্রাস করে।

- **আপনার সিস্টেমের লজিককে বিভক্ত করুন**, একাধিক কন্ট্র্যাক্টের মাধ্যমে অথবা একই ধরনের ফাংশনগুলিকে একসাথে গ্রুপ করে (উদাহরণস্বরূপ, অথেন্টিকেশন, অ্যারিথমেটিক, ...)।
- **ছোট ছোট ফাংশন লিখুন, একটি স্পষ্ট উদ্দেশ্য সহ।** এটি পর্যালোচনা সহজতর করবে এবং স্বতন্ত্র উপাদানগুলির পরীক্ষা করার অনুমতি দেবে।

### ইনহেরিটেন্স {#inheritance}

- **ইনহেরিটেন্স পরিচালনাযোগ্য রাখুন।** লজিক বিভক্ত করার জন্য ইনহেরিটেন্স ব্যবহার করা উচিত, তবে, আপনার প্রোজেক্টের লক্ষ্য হওয়া উচিত ইনহেরিটেন্স ট্রি-এর গভীরতা এবং প্রস্থ কমানো।
- **কন্ট্র্যাক্টগুলির হায়ারার্কি পরীক্ষা করতে Slither-এর [ইনহেরিটেন্স প্রিন্টার](https://github.com/crytic/slither/wiki/Printer-documentation#inheritance-graph) ব্যবহার করুন।** ইনহেরিটেন্স প্রিন্টার আপনাকে হায়ারার্কির আকার পর্যালোচনা করতে সাহায্য করবে।

### ইভেন্ট {#events}

- **সমস্ত গুরুত্বপূর্ণ অপারেশন লগ করুন।** ডেভেলপমেন্টের সময় কন্ট্র্যাক্ট ডিবাগ করতে এবং ডিপ্লয়মেন্টের পরে এটি নিরীক্ষণ করতে ইভেন্টগুলি সাহায্য করবে।

### পরিচিত ফাঁদগুলি এড়িয়ে চলুন {#avoid-known-pitfalls}

- **সবচেয়ে সাধারণ নিরাপত্তা সমস্যা সম্পর্কে সচেতন থাকুন।** সাধারণ সমস্যাগুলি সম্পর্কে জানার জন্য অনেক অনলাইন রিসোর্স রয়েছে, যেমন [Ethernaut CTF](https://ethernaut.openzeppelin.com/), [Capture the Ether](https://capturetheether.com/), অথবা [Not so smart contracts](https://github.com/crytic/not-so-smart-contracts/)।
- **[Solidity নথিপত্রের](https://docs.soliditylang.org/en/latest/) সতর্কতা বিভাগগুলি সম্পর্কে সচেতন থাকুন।** সতর্কতা বিভাগগুলি আপনাকে ভাষার অ-স্পষ্ট আচরণ সম্পর্কে অবহিত করবে।

### ডিপেন্ডেন্সি {#dependencies}

- **সু-পরীক্ষিত লাইব্রেরি ব্যবহার করুন।** সু-পরীক্ষিত লাইব্রেরি থেকে কোড ইম্পোর্ট করলে আপনার ত্রুটিপূর্ণ কোড লেখার সম্ভাবনা কমে যাবে। আপনি যদি একটি ERC20 কন্ট্র্যাক্ট লিখতে চান, তাহলে [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20) ব্যবহার করুন।
- **একটি ডিপেন্ডেন্সি ম্যানেজার ব্যবহার করুন; কোড কপি-পেস্ট করা এড়িয়ে চলুন।** আপনি যদি কোনো বাহ্যিক উৎসের ওপর নির্ভর করেন, তবে আপনাকে অবশ্যই এটিকে মূল উৎসের সাথে আপ-টু-ডেট রাখতে হবে।

### পরীক্ষা এবং যাচাইকরণ {#testing-and-verification}

- **পুঙ্খানুপুঙ্খ ইউনিট-টেস্ট লিখুন।** উচ্চ-মানের সফ্টওয়্যার তৈরি করতে একটি বিস্তৃত টেস্ট স্যুট অত্যন্ত গুরুত্বপূর্ণ।
- **[Slither](https://github.com/crytic/slither), [Echidna](https://github.com/crytic/echidna) এবং [Manticore](https://github.com/trailofbits/manticore)-এর কাস্টম চেক এবং প্রপার্টি লিখুন।** স্বয়ংক্রিয় টুলস আপনার কন্ট্র্যাক্ট সুরক্ষিত কিনা তা নিশ্চিত করতে সাহায্য করবে। দক্ষ চেক এবং প্রপার্টি কীভাবে লিখতে হয় তা শিখতে এই গাইডের বাকি অংশ পর্যালোচনা করুন।
- **[crytic.io](https://crytic.io/) ব্যবহার করুন।** Crytic GitHub-এর সাথে ইন্টিগ্রেট করে, প্রাইভেট Slither ডিটেক্টরে অ্যাক্সেস দেয়, এবং Echidna থেকে কাস্টম প্রপার্টি চেক চালায়।

### Solidity {#solidity}

- **0.4 এবং 0.6-এর চেয়ে Solidity 0.5-কে প্রাধান্য দিন।** আমাদের মতে, Solidity 0.5 আরও সুরক্ষিত এবং 0.4-এর তুলনায় এতে আরও ভালো বিল্ট-ইন প্র্যাকটিস রয়েছে। Solidity 0.6 প্রোডাকশনের জন্য অত্যন্ত অস্থিতিশীল প্রমাণিত হয়েছে এবং পরিপক্ক হওয়ার জন্য সময়ের প্রয়োজন।
- **কম্পাইল করার জন্য একটি স্থিতিশীল রিলিজ ব্যবহার করুন; সতর্কবার্তা পরীক্ষা করার জন্য সর্বশেষ রিলিজ ব্যবহার করুন।** সর্বশেষ কম্পাইলার সংস্করণে আপনার কোডে কোনো রিপোর্ট করা সমস্যা নেই তা পরীক্ষা করুন। তবে, Solidity-র একটি দ্রুত রিলিজ চক্র রয়েছে এবং কম্পাইলার বাগের একটি ইতিহাস রয়েছে, তাই আমরা ডিপ্লয়মেন্টের জন্য সর্বশেষ সংস্করণ সুপারিশ করি না (Slither-এর [solc সংস্করণ সুপারিশ](https://github.com/crytic/slither/wiki/Detector-Documentation#recommendation-33) দেখুন)।
- **ইনলাইন অ্যাসেম্বলি ব্যবহার করবেন না।** অ্যাসেম্বলির জন্য EVM দক্ষতার প্রয়োজন। যদি আপনি ইয়েলো পেপার _দক্ষতার সাথে আয়ত্ত_ না করে থাকেন তবে EVM কোড লিখবেন না।

## ডিপ্লয়মেন্ট নির্দেশিকা {#deployment-guidelines}

একবার কন্ট্র্যাক্টটি তৈরি এবং ডিপ্লয় করা হয়ে গেলে:

- **আপনার কন্ট্র্যাক্টগুলি নিরীক্ষণ করুন।** লগগুলি দেখুন, এবং কন্ট্র্যাক্ট বা ওয়ালেট কম্প্রোমাইজ হলে প্রতিক্রিয়া জানাতে প্রস্তুত থাকুন।
- **[blockchain-security-contacts](https://github.com/crytic/blockchain-security-contacts)-এ আপনার যোগাযোগের তথ্য যোগ করুন।** এই তালিকাটি তৃতীয় পক্ষকে আপনার সাথে যোগাযোগ করতে সাহায্য করে যদি কোনো নিরাপত্তা ত্রুটি আবিষ্কৃত হয়।
- **বিশেষ সুবিধাপ্রাপ্ত ব্যবহারকারীদের ওয়ালেট সুরক্ষিত করুন।** আপনি যদি হার্ডওয়্যার ওয়ালেটে কি সংরক্ষণ করেন তবে আমাদের [সেরা অভ্যাসগুলি](https://blog.trailofbits.com/2018/11/27/10-rules-for-the-secure-use-of-cryptocurrency-hardware-wallets/) অনুসরণ করুন।
- **ঘটনার প্রতিক্রিয়ার জন্য একটি পরিকল্পনা রাখুন।** বিবেচনা করুন যে আপনার স্মার্ট কন্ট্র্যাক্টগুলি কম্প্রোমাইজ হতে পারে। এমনকি যদি আপনার কন্ট্র্যাক্টগুলি বাগ-মুক্ত হয়, একজন আক্রমণকারী কন্ট্র্যাক্টের মালিকের কি-এর নিয়ন্ত্রণ নিতে পারে।
