---
title: Înregistrarea datelor din contractele inteligente cu evenimente
description: O introducere în evenimente de contracte inteligente și cum să le utilizezi pentru a înregistra date
author: "jdourlens"
tags:
  - "contracte inteligente"
  - "remix"
  - "solidity"
  - "evenimente"
skill: intermediate
lang: ro
published: 2020-04-03
source: EthereumDev
sourceUrl: https://ethereumdev.io/logging-data-with-events/
address: "0x19dE91Af973F404EDF5B4c093983a7c6E3EC8ccE"
---

În Solidity, [evenimentele](/developers/docs/smart-contracts/anatomy/#events-and-logs) sunt semnalele expediate pe care contractele inteligente le pot declanșa. Aplicațiile dapp sau orice conectat la Ethereum JSON-RPC API, pot asculta aceste evenimente și pot acționa în consecință. An event can also be indexed so that the event history is searchable later.

## Evenimente {#events}

The most common event on the Ethereum blockchain at the time of writing this article is the Transfer event that is emitted by ERC20 tokens when someone transfers tokens.

```solidity
event Transfer(address indexed from, address indexed to, uint256 value);
```

The event signature is declared inside of the contract code and can be emitted with the emit keyword. For example, the transfer event logs who sent the transfer (_from_), to who (_to_) and how much tokens were transferred (_value_).

If we get back to our Counter smart contract and decide to log every time the value is changed. Deoarece acest contract nu este destinat să fie implementat, ci servește drept bază pentru construirea unui alt contract prin extinderea acestuia: se numește contract abstract. In the case of our counter example, it would look like this:

```solidity
pragma solidity 0.5.17;

contract Counter {

    event ValueChanged(uint oldValue, uint256 newValue);

    // Variabilă privată de tip int nesemnat pentru a păstra numărul de contorizări
    uint256 private count = 0;

    // Funcție care incrementează contorul nostru
    function increment() public {
        count += 1;
        emit ValueChanged(count - 1, count);
    }

    // Getter pentru a obține valoarea contorizării
    function getCount() public view returns (uint256) {
        return count;
    }

}
```

Observă că:

- **linia 5**: Declarăm evenimentul nostru și ce conține, vechea valoare și noua valoare.

- **linia 13**: Când incrementăm variabila noastră „count”, „emit”-em evenimentul.

Dacă implementăm acum contractul și apelăm funcția increment, vom vedea că Remix îl va afișa automat când faci clic pe noua tranzacție din interiorul unei matrice numite „logs".

![Captură ecran Remix](./remix-screenshot.png)

Jurnalele sunt foarte utile pentru depanarea contractelor inteligente, dar sunt, de asemenea, importante atunci când construiești aplicații utilizate de diferite persoane și faci mai ușoară analiza pentru a urmări și a înțelege modul în care este utilizat contractul inteligent. The logs generated by transactions are displayed in popular block explorers and you can also for example use them to create off chain scripts for listening to specific events and taking action when they occur.
