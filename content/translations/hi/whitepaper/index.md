---
title: इथेरियम व्हाइटपैपर
description: एथेरियम का एक परिचयात्मक पत्र, जो इसके लॉन्च से पहले 2013 में प्रकाशित हुआ था।
lang: hi
sidebarDepth: 2
hideEditButton: true
---

# इथेरियम व्हाइटपैपर {#ethereum-whitepaper}

_यह परिचयात्मक पत्र मूल रूप से 2014 में [एथेरियम](/what-is-ethereum/) के संस्थापक विटालिक ब्यूटिरिन द्वारा 2015 में प्रोजेक्ट के लॉन्च से पहले प्रकाशित किया गया था। यह ध्यान देने योग्य है कि एथेरियम, कई समुदाय-संचालित, ओपन-सोर्स सॉफ़्टवेयर प्रोजेक्ट्स की तरह, अपनी प्रारंभिक स्थापना के बाद से विकसित हुआ है।_

_हालांकि यह कई साल पुराना है, हम इस पेपर को बनाए रखते हैं, क्योंकि यह एक उपयोगी संदर्भ और एथेरियम और इसकी दृष्टि के सटीक प्रतिनिधित्व के रूप में काम करना जारी रखता है। एथेरियम के नवीनतम विकास और प्रोटोकॉल में परिवर्तन कैसे किए जाते हैं, इसके बारे में जानने के लिए, हम [इस गाइड](/learn/) की अनुशंसा करते हैं।_

[[दिसंबर 2014 से] सफेद कागज के ऐतिहासिक या विहित संस्करण की मांग करने वाले शोधकर्ताओं और शिक्षाविदों को इस PDF का उपयोग करना चाहिए।](./whitepaper-pdf/Ethereum_Whitepaper_-_Buterin_2014.pdf)

## एक अगली पीढ़ी का स्मार्ट अनुबंध और विकेंद्रीकृत एप्लिकेशन प्लेटफ़ार्म {#a-next-generation-smart-contract-and-decentralized-application-platform}

2009 में सतोशी नाकामोतो के Bitcoin के विकास को अक्सर मुद्रा और मुद्रा में एक कट्टरपंथी विकास के रूप में सराहा गया है, जो एक डिजिटल संपत्ति का पहला उदाहरण है जिसका एक साथ कोई समर्थन या  "[आंतरिक मूल्य](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/)" नहीं है और कोई केंद्रीकृत जारीकर्ता या नियंत्रक नहीं है। हालांकि, एक और, यकीनन अधिक महत्वपूर्ण, Bitcoin प्रयोग का हिस्सा अंतर्निहित ब्लॉकचेन तकनीक है जो वितरित सहमति के एक उपकरण के रूप में है, और ध्यान तेजी से Bitcoin के इस अन्य पहलू पर स्थानांतरित होने लगा है। ब्लॉकचेन तकनीक के आम तौर पर उद्धृत वैकल्पिक अनुप्रयोगों में कस्टम मुद्राओं और वित्तीय उपकरणों ("[रंगीन सिक्के](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)") का प्रतिनिधित्व करने के लिए ऑन-ब्लॉकचेन डिजिटल संपत्ति का उपयोग करना शामिल है, एक अंतर्निहित भौतिक उपकरण का स्वामित्व ("[स्मार्ट संपत्ति ](https://en.bitcoin.it/wiki/Smart_Property)") अपूरणीय संपत्ति जैसे डोमेन नाम ("[Namecoin](http://namecoin.org)") के साथ-साथ अधिक जटिल अनुप्रयोगों में डिजिटल संपत्ति को सीधे मनमाने नियमों ("[स्मार्ट अनुबंध](http://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/idea.html)") को लागू करने वाले कोड के एक हिस्से या यहां तक कि ब्लॉकचेन-आधारित "[विकेंद्रीकृत स्वायत्त संगठन](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/)" (डीएओ) द्वारा नियंत्रित किया जा रहा है। एथेरियम जो प्रदान करने का इरादा रखता है वह एक अंतर्निहित पूरी तरह से ट्यूरिंग वाली प्रोग्रामिंग भाषा के साथ एक ब्लॉकचेन है जिसका उपयोग "अनुबंध" बनाने और मनमाने ढंग से स्टेट ट्रांजिशन फ़ंक्शन को एन्कोड करने के लिए किया जा सकता है, जिससे यूज़र ऊपर वर्णित किसी भी सिस्टम को बना सकते हैं, साथ ही कई अन्य जिनकी हमने अभी तक कल्पना नहीं की है, ऐसा वे बस कोड की कुछ पंक्तियों में तर्क लिखकर कर सकते हैं।

## Bitcoin और मौजूदा अवधारणाओं का परिचय {#introduction-to-bitcoin-and-existing-concepts}

### इतिहास {#history}

विकेंद्रीकृत डिजिटल मुद्रा की अवधारणा के साथ-साथ संपत्ति रजिस्ट्रियों जैसे वैकल्पिक एप्लिकेशन दशकों से हैं। 1980 और 1990 के दशक के अनाम ई-कैश प्रोटोकॉल, जो ज़्यादातर एक क्रिप्टोग्राफिक प्रीमिटिव पर निर्भर थे, जिन्हें चौमियन ब्लाइंडिंग के रूप में जाना जाता था, उन्होंने उच्च स्तर की गोपनीयता के साथ एक मुद्रा प्रदान की, लेकिन प्रोटोकॉल काफी हद तक एक केंद्रीकृत मध्यस्थ पर उनकी निर्भरता के कारण कर्षण प्राप्त करने में विफल रहे। 1998 में, Wei Dai का [बी-मनी](http://www.weidai.com/bmoney.txt) कम्प्यूटेशनल पहेलियों को हल करने के साथ-साथ विकेंद्रीकृत सर्वसम्मति के माध्यम से धन बनाने के विचार को पेश करने वाला पहला प्रस्ताव बन गया, लेकिन प्रस्ताव इस विवरण पर बहुत कम था कि विकेंद्रीकृत सर्वसम्मति को असल में कैसे लागू किया जा सकता है। 2005 में, हेल फ़िन्नी ने "[काम का सबूत प्रयोज्य प्रमाण](https://nakamotoinstitute.org/finney/rpow/)" की एक अवधारणा पेश की, एक ऐसा सिस्टम जो क्रिप्टोक्यूरेंसी के लिए एक अवधारणा बनाने के लिए एडम बैक की कम्प्यूटेशनल रूप से कठिन हैशकैश पहेलियों के साथ बी-मनी से विचारों का उपयोग करता है, लेकिन एक बार फिर बैकएंड के रूप में विश्वसनीय कंप्यूटिंग पर भरोसा करके आदर्श से कम हो गया। 2009 में, एक विकेंद्रीकृत मुद्रा को पहली बार सतोशी नाकामोतो द्वारा व्यवहार में लागू किया गया था, जिसमें सिक्कों के मालिक कौन हैं, इस पर नज़र रखने के लिए एक सर्वसम्मत एल्गोरिथ्म के साथ सार्वजनिक कुंजी क्रिप्टोग्राफ़ी के माध्यम से स्वामित्व के प्रबंधन के लिए स्थापित प्रीमिटिव को जोड़ा गया था, जिसे "काम का सबूत" के रूप में जाना जाता है।

काम के सबूत के पीछे की प्रणाली इस क्षेत्र में एक बड़ी सफलता थी, क्योंकि इससे एक साथ दो समस्याएँ हल हुईं। सबसे पहले, इसने एक सरल और मध्यम रूप से प्रभावी सर्वसम्मति एल्गोरिथ्म प्रदान किया, जिससे नेटवर्क में नोड्स को Bitcoin खाता बही की स्थिति के लिए कैनॉनिकल अपडेट के एक सेट पर सामूहिक रूप से सहमत होने की अनुमति मिली। दूसरा, इसने सर्वसम्मति प्रक्रिया में स्वतंत्र प्रवेश की अनुमति देने के लिए एक तरीका उपलब्ध कराया, यह तय करने की राजनीतिक समस्या को हल किया कि कौन सर्वसम्मति को प्रभावित करता है, साथ ही साथ सिबिल हमलों को रोकता है। यह भागीदारी के लिए एक औपचारिक समस्या को प्रतिस्थापित करके ऐसा करता है, जैसे कि एक विशेष सूची में एक अद्वितीय इकाई के रूप में पंजीकृत होने की आवश्यकता, एक आर्थिक रुकावट के साथ-सर्वसम्मति मतदान प्रक्रिया में एक सिंगल नोड का वज़न सीधे कंप्यूटिंग क्षमता के समानुपाती होता है जो नोड लाता है। तब से, एक वैकल्पिक दृष्टिकोण प्रस्तावित किया गया है जिसे _हिस्सेदारी का सबूत_ कहा जाता है, एक नोड के वज़न की गणना इसके करेंसी होल्डिंग्स के समानुपाती होने के रूप में और कम्प्यूटेशनल संसाधनों के रूप में नहीं; दोनों दृष्टिकोणों के सापेक्ष गुणों की चर्चा इस पेपर के दायरे से परे है, लेकिन यह ध्यान दिया जाना चाहिए कि दोनों दृष्टिकोण का उपयोग क्रिप्टोकरेंसी के अहम हिस्से के रूप में किया जा सकता है।

### एक राज्य संक्रमण सिस्टम के रूप में Bitcoin {#bitcoin-as-a-state-transition-system}

![एथेरियम राज्य संक्रमण](./ethereum-state-transition.png)

तकनीकी दृष्टिकोण से, Bitcoin जैसी क्रिप्टोकरेंसी के खाता बही को एक स्टेट ट्रांज़िशन सिस्टम के रूप में समझा जा सकता है, जहां एक "स्टेट" होता है जिसमें सभी मौजूदा Bitcoin के स्वामित्व वाली स्थिति और एक "स्टेट ट्रांज़िशन फ़ंक्शन" होता है जो एक राज्य और एक लेनदेन लेता है और एक नई स्थिति पेश करता है जो परिणाम है। एक मानक बैंकिंग सिस्टम में, उदाहरण के लिए, राज्य एक बैलेंस शीट है, लेनदेन $X को A से B तक स्थानांतरित करने का अनुरोध है, और स्टेट ट्रांज़िशन फ़ंक्शन A के खाते में मूल्य को $X कम कर देता है और B के खाते में मूल्य को $X से बढ़ जाता है। अगर A के खाते में पहले से ही $X से कम राशि है, तो राज्य संक्रमण फ़ंक्शन एक गड़बड़ी देता है। इसलिए, कोई औपचारिक रूप से परिभाषित कर सकता है:

```
लागू करें (एस, TX) -> एस 'या त्रुटि
```

ऊपर परिभाषित बैंकिंग सिस्टम में:

```js
लागू करें ({ Alice: $50, Bob: $50 },"एलिस से बॉब को $20 भेजें") = { Alice: $30, Bob: $70 }
```

परंतु:

```js
लागू करें "({ Alice: $50, Bob: $50 }","एलिस से बॉब को $70 भेजें") = त्रुटि
```

Bitcoin में "स्टेट" सभी सिक्कों (तकनीकी रूप से, "खर्च न किए गए लेनदेन आउटपुट" या UTXO) का संग्रह है, जिन्हें ढाला गया है और अभी तक खर्च नहीं किया गया है, प्रत्येक UTXO के पास एक मूल्यवर्ग और एक मालिक है (20-बाइट पते द्वारा परिभाषित किया गया है जो अनिवार्य रूप से एक क्रिप्टोग्राफिक सार्वजनिक कुंजी है<sup> [fn1] (#notes) </sup>)। एक लेन-देन में एक या अधिक इनपुट होते हैं, जिनमें हर इनपुट में मौजूदा UTXO का संदर्भ होता है और मालिक के पते से जुड़ी निजी कुंजी द्वारा जेनरेट किया गया एक क्रिप्टोग्राफ़िक हस्ताक्षर होता है, और एक या अधिक आउटपुट होते हैं, जिसमें हर आउटपुट में एक नया UTXO होता है जिसे स्टेट में जोड़ा जाना है।

स्टेट संक्रमण फ़ंक्शन `APPLY(S,TX) -> S'` इसे मोटे तौर पर निम्नानुसार परिभाषित किया जा सकता हैं:

<ol>
  <li>
    <code>TX</code> में प्रत्येक इनपुट के लिए:
    <ul>
    <li>
        अगर संदर्भित UTXO <code>S</code> में नहीं है, तो एक गड़बड़ी लौटाएं।
    </li>
    <li>
        अगर दिए गए हस्ताक्षर UTXO के मालिक से मेल नहीं खाते हैं, तो एक गड़बड़ी वापस करें।
    </li>
    </ul>
  </li>
  <li>
    अगर सभी इनपुट UTXO के मूल्यवर्गों का योग सभी आउटपुट UTXO के मूल्यवर्गों के योग से कम है, एक गड़बड़ी लौटाएं।
  </li>
  <li>
    सभी इनपुट UTXO हटाए जाने और सभी आउटपुट UTXO जोड़े जाने के साथ <code>S</code> वापस करें।
  </li>
</ol>

पहले चरण का पहला भाग लेन-देन प्रेषकों को उन सिक्कों को खर्च करने से रोकता है जो मौजूद नहीं हैं, पहले चरण का दूसरा भाग लेन-देन प्रेषकों को अन्य लोगों के सिक्के खर्च करने से रोकता है, और दूसरा चरण मूल्य के संरक्षण को लागू करता है। इसका उपयोग करने के लिए भुगतान, प्रोटोकॉल इस प्रकार है। मान लीजिए ऐलिस, बॉब को 11.7 BTC भेजना चाहता है। सबसे पहले, ऐलिस उपलब्ध UTXO के एक सेट की तलाश करेगी जिसे वह जिसके पास कम से कम 11.7 BTC है। वास्तविक रूप से, ऐलिस ठीक 11.7 BTC प्राप्त करने में सक्षम नहीं होगी; मान लीजिए कि वह सबसे कम 6+4+2=12 प्राप्त कर सकती है। फिर वह उन तीन इनपुट और दो आउटपुट के साथ एक लेनदेन बनाती है। पहला आउटपुट 11.7 BTC होगा जिसमें बॉब का पता होगा मालिक, और दूसरा आउटपुट शेष 0.3 BTC "बदलाव" होगा, जिसकी मालिक खुद ऐलिस होगी।

### खुदाई {#mining}

![एथेरियम ब्लॉक](./ethereum-blocks.png)

अगर हमारे पास एक भरोसेमंद केंद्रीकृत सेवा तक पहुंच होती, तो यह सिस्टम लागू करने के लिए तुच्छ हो; इसे बिल्कुल वर्णित के रूप में कोडित किया जा सकता है, राज्य पर नज़र रखने के लिए एक केंद्रीकृत सर्वर की हार्ड ड्राइव का उपयोग करना। हालांकि, Bitcoin के साथ हम एक विकेन्द्रीकृत मुद्रा प्रणाली बनाने की कोशिश कर रहे हैं, इसलिए हमें स्टेट ट्रांज़िशन सिस्टम को सर्वसम्मति प्रणाली के साथ संयोजित करने की आवश्यकता होगी, ताकि यह सुनिश्चित किया जा सके कि सभी लोग लेनदेन के क्रम से सहमत हों। Bitcoin की विकेन्द्रीकृत सर्वसम्मति प्रक्रिया के लिए नेटवर्क में नोड्स को लगातार "ब्लॉक" नाम के लेनदेन के पैकेज बनाने की कोशिश करना आवश्यक होता है। नेटवर्क का उद्देश्य लगभग हर दस मिनट में एक ब्लॉक तैयार करना है, जिसमें से हर ब्लॉक में एक टाइमस्टैम्प, एक नॉन्स, पिछले ब्लॉक का संदर्भ (मतलब उसका हैश) और पिछले ब्लॉक के बाद से हुए सभी लेन-देन की सूची शामिल होगी। समय के साथ, यह एक स्थायी, निरंतर बढ़ने वाला "ब्लॉकचेन" बनाता है जो Bitcoin खाता बही की हाल ही की स्थिति को दिखाने के लिए लगातार अपडेट होता रहता है।

इस प्रतिमान में दिय़ा गया, किसी ब्लॉक के मान्य होने की जांच करने का एल्गोरिथ्म इस प्रकार है:

1. जाँचें कि ब्लॉक द्वारा संदर्भित पिछला ब्लॉक मौजूद है या नहीं और मान्य है या नहीं।
2. जाँचें कि ब्लॉक का टाइमस्टैम्प पिछले ब्लॉक<sup>[fn2](#notes)</sup> से बड़ा है और आने वाले समय में 2 घंटे से कम है
3. जाँचें कि ब्लॉक पर काम का सबूत मान्य है या नहीं।
4. मान लें कि `S[0]` पिछले ब्लॉक के आखिर में स्टेट है।
5. मान लें कि `TX` ब्लॉक की लेनदेन सूची है जिसमें `n` लेन-देन है। `0...n-1` में सभी `i` के लिए, `S[i+1] = APPLY(S[i],TX[i])` सेट करें अगर कोई भी एप्लिकेशन गड़बड़ी लौटाता है, तो बाहर निकलें और गलत लौटाएं।
6. सत्य लौटाएँ, और इस ब्लॉक के आखिर में स्थिति के रूप में `S[n]` रजिस्टर करें।

अनिवार्य रूप से, ब्लॉक में हर लेनदेन को लेनदेन के निष्पादन से पहले की प्रामाणिक स्थिति से लेकर किसी नई स्थिति तक एक मान्य स्टेट ट्रांज़िशन प्रदान करना होगा। ध्यान दें कि स्टेट को किसी भी तरह से ब्लॉक में एनकोड नहीं किया गया है; यह पूरी तरह से एक अमूर्तता है जिसे सत्यापन नोड द्वारा याद रखा जाना चाहिए और इसे किसी भी ब्लॉक के लिए केवल उत्पत्ति स्थिति से शुरू करके और प्रत्येक ब्लॉक में प्रत्येक लेनदेन को क्रम के हिसाब से लागू करके (सुरक्षित रूप से) गणना की जा सकती है। इसके अतिरिक्त, ध्यान दें कि जिस क्रम में माइनर ब्लॉक में लेनदेन शामिल करता है वह मायने रखता है; अगर किसी ब्लॉक में दो लेनदेन A और B हैं, जिससे B, A द्वारा बनाए गए UTXO को खर्च करता है, तो ब्लॉक तभी मान्य होगा जब A, B से पहले आएगा और किसी मामले में नहीं।

उपरोक्त सूची में एक वैधता शर्त मौजूद है जो अन्य सिस्टम में नहीं पाई जाती है, वह है "काम का सबूत" की आवश्यकता। सटीक शर्त यह है कि हर ब्लॉक का डबल-SHA256 हैश, जिसे 256-बिट संख्या माना जाता है, गतिशील रूप से एडजस्ट किए गए लक्ष्य से कम होना चाहिए, जो इस लेखन के समय लगभग 2<sup>187</sup> है। इसका उद्देश्य ब्लॉक बनाने की प्रोसेस को कम्प्यूटेशनल रूप से "मुश्किल" बनाना है, जिससे सिबिल हमलावरों को पूरे ब्लॉकचेन को अपने पक्ष में बनाने से रोका जा सके। चूँकि SHA256 को पूरी तरह से अप्रत्याशित सियूडोरैंडम फ़ंक्शन के रूप में डिज़ाइन किया गया है, इसलिए मान्य ब्लॉक बनाने का एकमात्र तरीका केवल परीक्षण और गड़बड़ी है, बार-बार नॉन्स को बढ़ाना और देखना कि क्या नया हैश मेल खाता है।

वर्तमान लक्ष्य ~2<sup>187</sup> पर, मान्य ब्लॉक मिलने से पहले नेटवर्क को औसतन ~2<sup>69</sup> प्रयास करने होंगे; सामान्य तौर पर, नेटवर्क द्वारा हर 2016 ब्लॉक पर लक्ष्य का पुनर्निर्धारण किया जाता है, ताकि औसतन हर दस मिनट में नेटवर्क में किसी नोड द्वारा एक नया ब्लॉक तैयार किया जा सके। इस कम्प्यूटेशनल काम के लिए खनिकों को मुआवज़ा देने के लिए, हर ब्लॉक के खनिक को एक लेनदेन शामिल करने का अधिकार है, जिससे उन्हें कहीं से भी 25 BTC हासिल हो। इसके अलावा, अगर किसी लेनदेन में इनपुट का कुल मूल्य उसके आउटपुट की तुलना में अधिक है, तो यह अंतर भी "लेनदेन शुल्क" के रूप में खनिक को जाता है। संयोग से, यह इकलौता तरीका है जिसकी मदद से BTC जारी किया जाता है; उत्पत्ति अवस्था में कोई भी सिक्का नहीं था।

खनन के उद्देश्य को बेहतर ढंग से समझने के लिए, आइए देखें कि दुर्भावनापूर्ण हमलावर की स्थिति में क्या होता है। चूंकि Bitcoin में शामिल क्रिप्टोग्राफ़ी सुरक्षित मानी जाती है, इसलिए हमलावर Bitcoin सिस्टम के उस हिस्से को सीधे निशाना बनाएगा जो क्रिप्टोग्राफ़ी द्वारा सुरक्षित नहीं है: लेनदेन का क्रम। हमलावर की रणनीति सरल है:

1. किसी उत्पाद (अधिमान के हिसाब से तेज़ डिलीवरी वाला डिजिटल सामान) के बदले में किसी व्यापारी को 100 BTC भेजें
2. उत्पाद की डिलीवरी का इंतज़ार करें
3. खुद को वही 100 BTC भेजकर दूसरा लेनदेन करें
4. नेटवर्क को यह समझाने की कोशिश करें कि उसका लेन-देन खुद के लिए था एक जो पहले आया था।

एक बार चरण (1) हो जाने के बाद, कुछ मिनटों के बाद कुछ खनिक एक ब्लॉक में लेनदेन को शामिल करेंगे, जैसे ब्लॉक संख्या 270000। लगभग एक घंटे के बाद, उस ब्लॉक के बाद चेन में पाँच और ब्लॉक जुड़ जाएँगे, जिनमें से हर ब्लॉक सीधे तौर पर लेन-देन की ओर इशारा करेगा और इस प्रकार इसकी "पुष्टि" करेगा। इस बिंदु पर, व्यापारी भुगतान को अंतिम रूप से स्वीकार कर लेगा और उत्पाद वितरित कर देगा; चूंकि हम यह मान रहे हैं कि यह एक डिजिटल चीज़ है, इसलिए वितरण तत्काल होगा। अब, हमलावर 100 BTC को खुद को भेजते हुए एक और लेनदेन बनाता है। अगर हमलावर इसे खुले में छोड़ देता है, तो लेनदेन प्रोसेस नहीं होगा; खनिक `APPLY(S,TX)` चलाने की कोशिश करेंगे और देखेंगे कि `TX` एक UTXO का उपभोग करता है जो अब स्टेट में नहीं है। इसलिए इसके बजाय, हमलावर ब्लॉकचेन का एक "फ़ोर्क" बनाता है, जो ब्लॉक 270000 के दूसरे वर्जन की माईनिंग करके शुरू होता है और मूल ब्लॉक 269999 को दर्शाता है, लेकिन पुराने के स्थान पर नया लेनदेन होता है। चूँकि ब्लॉक डेटा अलग है, इसलिए इसके लिए काम के सबूत को दोबारा करने की आवश्यकता होती है। इसके अलावा, हमलावर के ब्लॉक 270000 के नए वर्जन का हैश अलग है, इसलिए मूल ब्लॉक 270001 से 270005 इसकी ओर "इशारा" नहीं करते हैं; इस प्रकार, मूल चेन और हमलावर की नई चेन पूरी तरह से अलग हैं। नियम यह है कि किसी फ़ोर्क में सबसे लंबे ब्लॉकचेन को सत्य माना जाता है, और इसलिए मान्य माईनर 270005 चेन पर काम करेंगे, जबकि हमलावर अकेले 270000 चेन पर काम कर रहा होगा। हमलावर को अपनी ब्लॉकचेन को सबसे लंबा बनाने के लिए, उसे शेष नेटवर्क की तुलना में अधिक कम्प्यूटेशनल क्षमता की आवश्यकता होगी (इसलिए, "51% हमला")।

### मर्कल ट्री {#merkle-trees}

![Bitcoin में SPV](./spv-bitcoin.png)

_बायां: किसी शाखा की वैधता का प्रमाण देने के लिए मर्कले ट्री में केवल कुछ ही नोड्स पेश करना काफ़ी है।_

_दायां: मर्कल ट्री के किसी भी हिस्से को बदलने की कोई भी कोशिश आखिर में चेन में कहीं न कहीं एक असंगति की ओर ले जाती है।_

Bitcoin की एक महत्वपूर्ण स्केलेबिलिटी विशेषता यह है कि ब्लॉक को कई लेवल के हिसाब से डेटा संरचना में स्टोर किया जाता है। किसी ब्लॉक का "हैश" असल में केवल ब्लॉक हेडर का हैश होता है, जो लगभग 200-बाइट का डेटा होता है, जिसमें टाइमस्टैम्प, नॉन्स, पिछले ब्लॉक का हैश और मर्कल ट्री नाम के डेटा स्ट्रक्चर का रूट हैश शामिल होता है, जो ब्लॉक में सभी लेनदेन को स्टोर करता है। मर्कल ट्री एक तरह का बाइनरी ट्री है, जो नोड्स के एक ग्रुप से बना होता है, जिसमें ट्री के निचले भाग में बड़ी संख्या में लीफ़ नोड्स होते हैं, जिनमें शामिल डेटा होता है, मध्यवर्ती नोड्स का एक ग्रुप होता है, जहां हर नोड अपने दो संतानों का हैश होता है, तथा आखिर में एक सिंगल रूट नोड होता है, जो अपने दो संतानों के हैश से बना होता है, और ट्री के "शीर्ष" को दर्शाता है। मर्कल ट्री का उद्देश्य एक ब्लॉक में डेटा को अलग-अलग हिस्सों में वितरित करने की अनुमति देना है: एक नोड एक स्रोत से केवल ब्लॉक के हेडर को डाउनलोड कर सकता है, दूसरे स्रोत से उनके लिए प्रासंगिक ट्री का छोटा हिस्सा, और फिर भी आश्वस्त हो सकता है कि सारा डेटा सही है। यह इसलिए काम करता है, क्योंकि हैश ऊपर की ओर फैलता है: अगर कोई दुर्भावनापूर्ण यूज़र मर्कल ट्री के निचले भाग में नकली लेनदेन को स्वैप करने की कोशिश करता है, तो यह बदलाव ऊपर के नोड में बदलाव का कारण बनेगा, और फिर उसके ऊपर के नोड में बदलाव करेगा, आखिर में वृक्ष के मूल में बदलाव करेगा और इस प्रकार ब्लॉक के हैश में भी बदलाव करेगा, जिसके कारण प्रोटोकॉल इसे पूरी तरह से अलग ब्लॉक के रूप में पंजीकृत करेगा (लगभग पक्के तौर पर अमान्य काम के सबूत के साथ)।

मर्कल ट्री प्रोटोकॉल दीर्घकालिक स्थिरता के लिए निश्चित रूप से आवश्यक है। Bitcoin नेटवर्क में एक "फ़ुल नोड", जो हर ब्लॉक की संपूर्णता को स्टोर और प्रोसेस करता है, अप्रैल 2014 तक Bitcoin नेटवर्क में लगभग 15 GB डिस्क स्थान लेता है, और हर माह एक गीगाबाइट से अधिक बढ़ रहा है। वर्तमान में, यह कुछ डेस्कटॉप कम्प्यूटरों के लिए ही योग्य है, न कि फ़ोन के लिए, और बाद में भविष्य में केवल व्यवसाय और शौकिया लोग ही इसमें भाग ले पाएंगे। "आसान बनाया गया भुगतान सत्यापन" (SPV) के रूप में जाना जाने वाला एक प्रोटोकॉल नोड्स के एक अन्य वर्ग की मौजूदगी की अनुमति देता है, जिसे "लाइट नोड्स" कहा जाता है, जो ब्लॉक हेडर को डाउनलोड करते हैं, ब्लॉक हेडर पर काम के सबूत को सत्यापित करते हैं, और फिर केवल उन लेनदेन से जुड़ी "शाखाओं" को डाउनलोड करते हैं जो उनके लिए प्रासंगिक हैं। इससे लाइट नोड्स को सुरक्षा की मज़बूत गारंटी के साथ यह पता लगाने की अनुमति मिलती है कि किसी भी Bitcoin लेनदेन की स्थिति क्या है, और उनका मौजूदा शेष क्या है, जबकि वे पूरी ब्लॉकचेन का केवल एक बहुत छोटा हिस्सा ही डाउनलोड करते हैं।

### वैकल्पिक ब्लॉकचेन एप्लिकेशन {#alternative-blockchain-applications}

ब्लॉकचेन से संबंधित विचार को अन्य अवधारणाओं पर लागू करने के विचार का भी एक लंबा इतिहास है। 2005 में, निक स्जाबो ने "[मालिकाना हक के साथ सुरक्षित संपत्ति वाला शीर्षक](https://nakamotoinstitute.org/secure-property-titles/)" की अवधारणा पेश की, जो एक दस्तावेज़ था, जिसमें बताया गया था कि किस प्रकार "कॉपी किए गए डाटाबेस संबंधी टेक्नोलॉजी में नई प्रगति" ब्लॉकचेन-आधारित सिस्टम के माध्यम से यह रजिस्ट्री स्टोर करने की अनुमति देगी कि कौन किस भूमि का मालिक है, तथा इसमें होमस्टेडिंग, प्रतिकूल कब्जे और जॉर्जियाई भूमि कर जैसी अवधारणाओं के साथ एक बड़ी रूपरेखा तैयार की जाएगी। हालाँकि, दुर्भाग्य से उस समय कोई प्रभावी कॉपी किया गया या डाटाबेस सिस्टम उपलब्ध नहीं था, और इसलिए प्रोटोकॉल को व्यवहार में कभी लागू नहीं किया गया। हालाँकि, 2009 के बाद, जब Bitcoin की विकेन्द्रीकृत सर्वसम्मति विकसित हो गई, तो कई वैकल्पिक एप्लिकेशन तेजी से सामने आने लगे।

- **Namecoin** - 2010 में निर्मित, [Namecoin](https://namecoin.org/) का वर्णन एक विकेन्द्रीकृत नाम पंजीकरण डेटाबेस के रूप में किया जा सकता है। Tor, Bitcoin और BitMessage जैसे विकेन्द्रीकृत प्रोटोकॉल में खातों की पहचान करने का कोई तरीका होना चाहिए, ताकि अन्य लोग उनके साथ इंटरैक्ट कर सकें, लेकिन सभी मौजूदा समाधानों में उपलब्ध एकमात्र पहचानकर्ता स्यूडोरैंडम हैश है जैसे `1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy`। आदर्श रूप से, कोई "जॉर्ज" जैसे नाम के साथ एक खाता रखने में सक्षम होना चाहेगा। हालांकि, समस्या यह है कि अगर एक व्यक्ति "जॉर्ज" नाम से अकाउंट बना सकता है, तो कोई अन्य व्यक्ति उसी प्रक्रिया का उपयोग करके अपने लिए भी "जॉर्ज" को पंजीकृत कर सकता है और उसकी नकल कर सकता है। इसका इकलौता समाधान फ़र्स्ट-टू-फ़ाइल प्रतिमान है, जहां पहला रजिस्टर सफल होता है और दूसरा विफल - यह समस्या Bitcoin सर्वसम्मति प्रोटोकॉल के लिए बिल्कुल उपयुक्त है। Namecoin इस तरह के विचार का उपयोग करते हुए नाम पंजीकरण सिस्टम का सबसे पुराना और सबसे सफल कार्यान्वयन है।
- **रंगीन सिक्के**[रंगीन सिक्कों](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit) का उद्देश्य एक प्रोटोकॉल के रूप में काम करना है, जिससे लोगों को अपनी खुद की डिजिटल मुद्राएं बनाने की अनुमति मिल सके - या, Bitcoin ब्लॉकचेन पर एक इकाई वाली मुद्रा, डिजिटल टोकन के अहम मामले में। रंगीन सिक्कों के प्रोटोकॉल में, एक खास Bitcoin UTXO को सार्वजनिक रूप से रंग प्रदान करके एक नई मुद्रा "जारी" की जाती है, और प्रोटोकॉल पुनरावर्ती रूप से अन्य UTXO के रंग को उन इनपुट के रंग के समान परिभाषित करता है, जो उन्हें बनाने वाले लेनदेन ने खर्च किए हैं (मिश्रित-रंग इनपुट के मामले में कुछ खास नियम लागू होते हैं)। इससे उपयोगकर्ताओं को केवल एक खास रंग के UTXO वाले वॉलेट को बनाए रखने और उन्हें नियमित bitcoin की तरह भेजने की अनुमति मिलती है, जो उन्हें प्राप्त होने वाले किसी भी UTXO का रंग निर्धारित करने के लिए ब्लॉकचेन के माध्यम से बैकट्रैकिंग करता है।
- **Metacoins** - metacoin के पीछे विचार यह है कि एक प्रोटोकॉल हो जो Bitcoin के शीर्ष पर हो, जो मेटाकॉइन लेनदेन को स्टोर करने के लिए Bitcoin लेनदेन का उपयोग करता हो, लेकिन इसमें एक अलग स्टेट ट्रांज़िशन फ़ंक्शन हो, `APPLY'`। चूँकि मेटाकॉइन प्रोटोकॉल अमान्य मेटाकॉइन लेनदेन को Bitcoin ब्लॉकचेन में दिखने से नहीं रोक सकता है, इसलिए एक नियम जोड़ा गया है कि अगर `APPLY'(S,TX)` कोई गड़बड़ी लौटाता है, तो प्रोटोकॉल डिफ़ॉल्ट रूप से `APPLY'(S,TX) = S` हो जाता है। यह एक मनमाना क्रिप्टोकरेंसी प्रोटोकॉल बनाने के लिए एक आसान सिस्टम उपलब्ध कराता है, जिसमें शायद बेहतरीन विशेषताएं होंगी जिन्हें Bitcoin के अंदर लागू नहीं किया जा सकता है, लेकिन बहुत कम विकास की लागत के साथ क्योंकि खनन और नेटवर्किंग की समस्याओं को पहले से ही Bitcoin प्रोटोकॉल द्वारा नियंत्रित किया जाता है। Metacoin का उपयोग कुछ प्रकार के वित्तीय अनुबंधों, नाम पंजीकरण और विकेन्द्रीकृत विनिमयों को लागू करने के लिए किया गया है।

इस प्रकार, सामान्य तौर पर, सर्वसम्मति प्रोटोकॉल को तौयार करने के लिए दो दृष्टिकोण हैं: एक स्वतंत्र नेटवर्क को तैयार करना, और Bitcoin के सबसे ऊपर एक प्रोटोकॉल तैयार करना। पहला दृष्टिकोण, Namecoin जैसे एप्लिकेशन के मामले में उचित तरीके से सफल होते हुए भी, लागू करने में समस्या होती है; हर व्यक्तिगत कार्यान्वयन के लिए एक स्वतंत्र ब्लॉकचेन को बूटस्ट्रैप करने की आवश्यकता होती है, साथ ही सभी आवश्यक स्टेट ट्रांज़िशन और नेटवर्किंग कोड का निर्माण और परीक्षण भी करना होता है। इसके अतिरिक्त, हम भविष्यवाणी करते हैं कि विकेन्द्रीकृत सर्वसम्मति प्रौद्योगिकी के लिए एप्लिकेशन का ग्रुप एक शक्ति कानून वितरण का पालन करेगा, जहां ज़्यादातर अनुप्रयोग अपने स्वयं के ब्लॉकचेन की गारंटी देने के लिए बहुत छोटे होंगे, और हम देखते हैं कि विकेन्द्रीकृत एप्लिकेशन के बड़े वर्ग मौजूद हैं, विशेष रूप से विकेन्द्रीकृत स्वायत्त संगठन, जिन्हें एक दूसरे के साथ बातचीत करने की आवश्यकता है।

दूसरी ओर, Bitcoin-आधारित दृष्टिकोण में यह गड़बड़ी है कि इसमें Bitcoin की सरलीकृत भुगतान सत्यापन सुविधाएं नहीं हैं। SPV, Bitcoin के लिए काम करता है, क्योंकि यह वैधता के लिए प्रॉक्सी के रूप में ब्लॉकचेन की गहराई का उपयोग कर सकता है; किसी बिंदु पर, जब पिछले लेनदेन किए हुए काफी समय हो जाता है, तो यह कहना सुरक्षित है कि वे मान्य रूप से स्टेट का हिस्सा थे। दूसरी ओर, ब्लॉकचेन-आधारित मेटा-प्रोटोकॉल ब्लॉकचेन को उन लेनदेन को शामिल न करने के लिए बाध्य नहीं कर सकते जो उनके अपने प्रोटोकॉल के मामले में मान्य नहीं हैं। इसलिए, एक पूरी तरह सुरक्षित SPV मेटा-प्रोटोकॉल कार्यान्वयन को Bitcoin ब्लॉकचेन की शुरुआत तक पीछे की ओर स्कैन करने की आवश्यकता होगी, ताकि यह निर्धारित किया जा सके कि कुछ लेनदेन वैध हैं या नहीं। वर्तमान में, Bitcoin-आधारित मेटा-प्रोटोकॉल के सभी "हल्के" कार्यान्वयन डेटा प्रदान करने के लिए एक विश्वसनीय सर्वर पर निर्भर करते हैं, जो यकीनन एक अत्यधिक उप-इष्टतम परिणाम है, खासकर जब क्रिप्टोकरेंसी का एक प्राथमिक उद्देश्य विश्वास की आवश्यकता को समाप्त करना है।

### स्क्रिप्टिंग {#scripting}

किसी भी विस्तार के बिना भी, Bitcoin प्रोटोकॉल असल में "स्मार्ट कॉन्ट्रैक्ट्स" की अवधारणा के एक कमजोर वर्जन को सुविधाजनक बनाता है। Bitcoin में UTXO का मालिकाना हक न केवल सार्वजनिक कुंजी के द्वारा हो सकता है, बल्कि एक सरल स्टैक-आधारित प्रोग्रामिंग भाषा में व्यक्त एक अधिक जटिल स्क्रिप्ट द्वारा भी हो सकता है। इस प्रतिमान में, लेनदेन से जुड़े व्यय जो UTXO को स्क्रिप्ट को संतुष्ट करने वाला डेटा प्रदान करना चाहिए। असल में, यहां तक ​​कि बुनियादी सार्वजनिक कुंजी के मालिकाना हक वाले सिस्टम को भी एक स्क्रिप्ट के माध्यम से लागू किया जाता है: स्क्रिप्ट एक दीर्घवृत्तीय वक्र हस्ताक्षर को इनपुट के रूप में लेती है, उसे लेनदेन और UTXO के मालिकाना हक वाले पते के विरुद्ध सत्यापित करती है, और सत्यापन सफल होने पर 1 और अन्यथा 0 लौटाती है। अलग-अलग अतिरिक्त उपयोग मामलों के लिए अन्य, अधिक जटिल, स्क्रिप्ट मौजूद हैं। उदाहरण के लिए, कोई ऐसी स्क्रिप्ट बना सकता है जिसमें सत्यापन के लिए दिए गए तीन निजी कुंजियों में से दो के हस्ताक्षर की आवश्यकता होती है ("मल्टीसिग"), यह सेटअप कॉर्पोरेट खातों, सुरक्षित बचत खातों और कुछ व्यापारी एस्क्रो स्टेट के लिए उपयोगी है। स्क्रिप्ट का उपयोग कम्प्यूटेशनल समस्याओं के समाधान के लिए इनाम का भुगतान करने के लिए भी किया जा सकता है, और यहां तक ​​कि एक स्क्रिप्ट भी बनाई जा सकती है जो कुछ इस तरह कहती है "यह Bitcoin UTXO आपका है अगर आप एक SPV प्रमाण प्रदान कर सकते हैं कि आपने इस मूल्यवर्ग का एक डॉगकॉइन लेनदेन मुझे भेजा है", अनिवार्य रूप से विकेन्द्रीकृत क्रॉस-क्रिप्टोकरेंसी एक्सचेंज की अनुमति देता है।

हालाँकि, Bitcoin में लागू की गई स्क्रिप्टिंग भाषा में कई महत्वपूर्ण सीमाएं हैं:

- **ट्यूरिंग की पूर्णता का अभाव** - मतलब, हालांकि Bitcoin स्क्रिप्टिंग भाषा द्वारा समर्थित संगणना का एक बड़ा उपसमूह है, फिर भी यह लगभग सभी चीज़ों का समर्थन नहीं करता है। मुख्य श्रेणी जो गायब है वह है लूप्स। यह लेन-देन सत्यापन के दौरान अनंत लूप से बचने के लिए किया जाता है; सैद्धांतिक रूप से यह स्क्रिप्ट प्रोग्रामरों के लिए एक पार करने योग्य बाधा है, क्योंकि किसी भी लूप को केवल एक if स्टेटमेंट के साथ अंतर्निहित कोड को कई बार दोहराकर अनुकरण किया जा सकता है, लेकिन यह उन स्क्रिप्टों की ओर ले जाता है जो बहुत जगह-अपर्याप्त हैं। उदाहरण के लिए, एक वैकल्पिक अण्डाकार वक्र हस्ताक्षर एल्गोरिथ्म को लागू करने के लिए संभवतः 256 बार-बार गुणा दौर की आवश्यकता होगी, जो सभी व्यक्तिगत रूप से कोड में शामिल हैं।
- **वैल्यू-ब्लाइंडनेस** - वापस ली जा सकने वाली राशि पर ठीक-ठाक नियंत्रण प्रदान करने के लिए UTXO स्क्रिप्ट का कोई तरीका नहीं है। उदाहरण के लिए, एक ओरैकल कॉन्ट्रैक्ट का उपयोग का एक बेहतरीन मामला एक हेजिंग कॉन्ट्रैक्ट होगा, जहाँ A और B $1000 मूल्य के BTC जमा करते हैं और 30 दिनों के बाद स्क्रिप्ट $1000 मूल्य के BTC को A को भेजती है और शेष राशि को B को भेजती है। इसके लिए 1 BTC का USD में मूल्य निर्धारित करने के लिए एक ओरैकल की आवश्यकता होगी, लेकिन तब भी यह वर्तमान में उपलब्ध पूरी तरह से केंद्रीकृत समाधानों की तुलना में विश्वास और बुनियादी ढांचे की आवश्यकता के मामले में एक बहुत बड़ा सुधार है। हालांकि, क्योंकि UTXO सभी या कुछ भी नहीं होते हैं, इसे हासिल करने का एकमात्र तरीका बहुत ही अप्रभावी हैक के माध्यम से होता है जिसमें अलग-अलग मूल्यवर्ग के कई UTXO होते हैं (उदाहरण के लिए, 2 के हर <sup>k</sup> तक 30 तक का एक UTXO) और ओरेकल यह चुनता है कि किस UTXO को A को भेजना है और किसे B को।
- **स्टेट की कमी** - UTXO या तो खर्च किया जा सकता है या खर्च नहीं किया जा सकता है; बहु-चरण अनुबंध या स्क्रिप्ट के लिए कोई अवसर नहीं है जो किसी अन्य आंतरिक स्थिति को इससे परे रखता है। यह बहु-स्तरीय विकल्प अनुबंध, विकेंद्रीकृत विनिमय प्रस्ताव या दो-चरण क्रिप्टोग्राफ़िक प्रतिबद्धता प्रोटोकॉल (सुरक्षित गणना पुरस्कारों के लिए आवश्यक) बनाना मुश्किल बना देता है। इसका मतलब यह भी है कि UTXO का उपयोग केवल साधारण, एकमुश्त अनुबंध बनाने के लिए किया जा सकता है और अधिक जटिल "स्टेटफ़ुल" अनुबंध, जैसे विकेंद्रीकृत संगठन, नहीं बनाए जा सकते हैं, और मेटा-प्रोटोकॉल्स को लागू करना कठिन बना देता है। बाइनरी स्टेट और वैल्यू-ब्लाइंडनेस का संयोजन यह भी दर्शाता है कि एक और महत्वपूर्ण एप्लिकेशन, निकासी सीमाएं, असंभव हैं।
- **ब्लॉकचेन-ब्लाइंडनेस** - UTXO ब्लॉकचेन डेटा, जैसे नॉन्स, टाइमस्टैम्प और पिछले ब्लॉक हैश को समझ नहीं पाते हैं। इससे जुए तथा कई अन्य श्रेणियों में अनुप्रयोगों की संख्या गंभीर रूप से सीमित हो जाती है, क्योंकि इससे स्क्रिप्टिंग भाषा को सियुडोरैंडम के संभावित मूल्यवान स्रोत से वंचित कर दिया जाता है।

इस प्रकार, हम शीर्ष पर उन्नत एप्लिकेशन के निर्माण के लिए तीन दृष्टिकोण देखते हैं क्रिप्टोक्यूरेंसी का: शीर्ष पर स्क्रिप्टिंग का उपयोग करके एक नया ब्लॉकचेन बनाना Bitcoin, और Bitcoin के शीर्ष पर एक मेटा-प्रोटोकॉल का निर्माण। एक नया निर्माण ब्लॉकचेन फीचर सेट के निर्माण में असीमित स्वतंत्रता की अनुमति देता है, लेकिन विकास के समय, बूटस्ट्रैपिंग प्रयास और सुरक्षा की कीमत पर। स्क्रिप्टिंग का उपयोग करना कार्यान्वयन और मानकीकरण के लिए आसान है, लेकिन इसकी क्षमताएं बहुत सीमित हैं, और मेटा-प्रोटोकॉल, आसान होते हुए भी, मापनीयता से जुड़ी सम्सयाओं से प्रभावित हैं। एथेरियम के साथ, हम एक वैकल्पिक ढांचा बनाने का इरादा रखते हैं जो विकास की आसानी के साथ-साथ और भी मजबूत लाइट क्लाइंट गुणों में और भी अधिक लाभ प्रदान करता है, जबकि एक ही समय में एप्लिकेशन को आर्थिक वातावरण और ब्लॉकचेन सुरक्षा साझा करने की अनुमति देता है।

## इथेरियम {#ethereum}

एथेरियम का उद्देश्य विकेन्द्रीकृत एप्लिकेशन के निर्माण के लिए एक वैकल्पिक प्रोटोकॉल बनाना है, जो विभिन्न प्रकार के समझौतों को उपलब्ध कराता है, जिनके बारे में हमारा मानना ​​है कि वे विकेन्द्रीकृत एप्लिकेशन के एक बड़े वर्ग के लिए बहुत उपयोगी होंगे, तथा उन स्थितियों पर विशेष जोर दिया जाएगा जहां तेजी से विकास का समय, छोटे और कम उपयोग किए जाने वाले एप्लिकेशन के लिए सुरक्षा, तथा विभिन्न एप्लिकेशन की बहुत कुशलतापूर्वक मिलकर काम करने की क्षमता महत्वपूर्ण है। एथेरियम ऐसा एक अमूर्त आधारभूत परत का निर्माण करके करता है: एक ब्लॉकचेन जिसमें ट्यूरिंग-पूर्ण प्रोग्रामिंग भाषा अंतर्निहित होती है, जो किसी को भी स्मार्ट अनुबंध और विकेन्द्रीकृत एप्लिकेशन लिखने की अनुमति देती है, जहां वे स्वामित्व, लेनदेन प्रारूप और स्टेट ट्रांज़िशन संबंधी कामों के लिए अपने स्वयं के मनमाने नियम बना सकते हैं। Namecoin का एक बुनियादी वर्जन दो पंक्तियों के कोड में लिखा जा सकता है, और अन्य प्रोटोकॉल जैसे मुद्राएं और प्रतिष्ठा वाले सिस्टम बीस पंक्तियों से कम मे बनाए जा सकते है। स्मार्ट अनुबंध, क्रिप्टोग्राफ़िक "बॉक्स" जिसमें मूल्य शामिल होता है तथा जो केवल कुछ निश्चित शर्तों के पूरा होने पर ही खुलता है, उसे भी प्लेटफॉर्म के शीर्ष पर बनाया जा सकता है, तथा इसमें Bitcoin स्क्रिप्टिंग की तुलना में कहीं अधिक शक्ति होती है, क्योंकि इसमें ट्यूरिंग-पूर्णता, मूल्य-जागरूकता, ब्लॉकचेन-जागरूकता और स्थिति की अतिरिक्त शक्तियां होती हैं।

### एथेरियम खाता {#ethereum-accounts}

एथेरियम में, स्थिति "खातों" नामक वस्तुओं से बनी होती है, प्रत्येक खाते का 20-बाइट पता होता है और स्थिति परिवर्तन सीधे खातों के बीच मूल्य और जानकारी के स्थानांतरण होते हैं। एक एथेरियम खाता चार क्षेत्रों में बाँटा गया होता है:

- **नॉन्स**, एक काउंटर जो यह सुनिश्चित करता है कि प्रत्येक लेनदेन केवल एक बार ही संसाधित किया जा सके
- खाते का वर्तमान **एथर बैलेंस**
- खाते का **अनुबंध कोड**, यदि मौजूद हो
- खाते का **स्टोरेज** (डिफ़ॉल्ट रूप से खाली)

"एथर" एथेरियम का मुख्य आंतरिक क्रिप्टो-ईंधन है, और इसका उपयोग लेनदेन शुल्क चुकाने के लिए किया जाता है। सामान्य रूप से, दो प्रकार के खाते होते हैं: **बाहरी रूप से स्वामित्व वाले खाते**, जो निजी कुंजी द्वारा नियंत्रित होते हैं, और **अनुबंध खाते**, जो अपने अनुबंध कोड द्वारा नियंत्रित होते हैं। बाहरी रूप से स्वामित्व वाले खाते में कोई कोड नहीं होता है, तथा कोई व्यक्ति लेनदेन बनाकर और उस पर हस्ताक्षर करके बाहरी स्वामित्व वाले खाते से संदेश भेज सकता है; अनुबंध खाते में, जब भी अनुबंध खाते को कोई संदेश प्राप्त होता है, तो उसका कोड चालू हो जाता है, जिससे वह आंतरिक स्टोरेज को पढ़ और लिख सकता है तथा अन्य संदेश भेज सकता है या बदले में अनुबंध बना सकता है।

ध्यान दें कि एथेरियम में "अनुबंधों" को ऐसी चीज़ के रूप में नहीं देखा जाना चाहिए जिसे "पूरा" किया जाना चाहिए या "अनुपालन" किया जाना चाहिए; बल्कि, वे "स्वायत्त एजेंट" की तरह हैं जो एथेरियम निष्पादन वातावरण के अंदर रहते हैं, हमेशा एक संदेश या लेनदेन द्वारा "पोक" किए जाने पर कोड के एक विशिष्ट टुकड़े को निष्पादित करते हैं, और अपने खुद के ईथर बैलेंस और अपने खुद के कुंजी/मूल्य स्टोर पर सीधा नियंत्रण रखते हैं ताकि लगातार चर का ट्रैक रखा जा सके।

### संदेश और लेन-देन {#messages-and-transactions}

"लेन-देन" शब्द का उपयोग एथेरियम में हस्ताक्षरित डेटा पैकेज को संदर्भित करने के लिए किया जाता है जो बाहरी स्वामित्व वाले खाते से भेजे जाने वाले संदेश को संग्रहीत करता है। लेन-देन में शामिल है:

- संदेश का प्राप्तकर्ता
- प्रेषक की पहचान करने वाला एक हस्ताक्षर
- प्रेषक से प्राप्तकर्ता को स्थानांतरित करने के लिए एथर की मात्रा
- एक वैकल्पिक डेटा फ़ील्ड
- `STARTGAS` मान, जो अधिकतम कम्प्यूटेशनल स्टेप की संख्या को दर्शाता है जिसे लेनदेन निष्पादन के लिए अनुमति दी जाती है
- `GASPRICE` मान, जो प्रेषक द्वारा हर कम्प्यूटेशनल स्टेप भुगतान किए जाने वाले शुल्क को दर्शाता है

पहले तीन किसी भी क्रिप्टोकरेंसी में अपेक्षित मानक क्षेत्र हैं। डेटा फ़ील्ड में डिफ़ॉल्ट रूप से कोई काम नहीं होता है, लेकिन वर्चुअल मशीन में एक ऑपकोड होता है जिसका उपयोग करके एक अनुबंध डेटा तक पहुंच सकता है; एक उदाहरण के उपयोग के मामले के रूप में, अगर कोई अनुबंध एक ऑन-ब्लॉकचेन डोमेन पंजीकरण सेवा के रूप में काम कर रहा है, तो यह दो "फ़ील्ड" वाले डेटा के बारे में जानकारी देना चाह सकता है, पहला फ़ील्ड पंजीकरण के लिए एक डोमेन है और दूसरा फ़ील्ड इसे पंजीकृत करने के लिए IP एड्रेस है। अनुबंध संदेश डेटा से इन मूल्यों को पढ़ेगा और उन्हें उचित रूप से स्टोरेज में रखेगा।

एथेरियम के सेवा-विरोधी मॉडल के लिए `STARTGAS` और `GASPRICE` फ़ील्ड महत्वपूर्ण हैं। कोड में आकस्मिक या शत्रुतापूर्ण लंबे समय तक रहने वाले लूप या अन्य कम्प्यूटेशनल अपव्यय को रोकने के लिए, हर लेनदेन को एक सीमा निर्धारित करने की आवश्यकता होती है कि वह कोड निष्पादन के कितने कम्प्यूटेशनल स्टेप का उपयोग कर सकता है। गणना की मौलिक इकाई "गैस" है; आमतौर पर, एक कम्प्यूटेशनल स्टेप की लागत 1 गैस होती है, लेकिन कुछ संचालनों में गैस की मात्रा अधिक होती है क्योंकि वे अधिक कम्प्यूटेशनल रूप से महंगे होते हैं, या डेटा की मात्रा को बढ़ाते हैं जिसे स्टेट के हिस्से के रूप में स्टोर किया जाना चाहिए। लेन-देन डेटा में प्रत्येक बाइट के लिए 5 गैस का शुल्क भी है। शुल्क वाले सिस्टम का उद्देश्य हमलावर को उनके द्वारा उपभोग किए जाने वाले प्रत्येक संसाधन के लिए आनुपातिक रूप से भुगतान करने के लिए बाध्य करना है, जिसमें संगणन, बैंडविड्थ और स्टोरेज शामिल हैं; इसलिए, कोई भी लेनदेन जिसके कारण नेटवर्क इन संसाधनों में से किसी की भी अधिक मात्रा का उपभोग करता है, उस पर गैस शुल्क लगभग बढ़ोतरी के समानुपातिक होना चाहिए।

### संदेश {#messages}

अनुबंधों में अन्य अनुबंधों को "संदेश" भेजने की क्षमता होती है। संदेश आभासी वस्तुएँ हैं जो कभी क्रमबद्ध नहीं होती हैं और केवल एथेरियम निष्पादन वातावरण में मौजूद होती हैं। एक संदेश में शामिल है:

- संदेश भेजने वाला (अनिहित)
- संदेश का प्राप्तकर्ता
- संदेश के साथ स्थानांतरित करने के लिए ईथर की मात्रा
- एक वैकल्पिक डेटा फ़ील्ड
- `STARTGAS` मान

मूल रूप से, संदेश एक लेन-देन की तरह होता है, सिवाय इसके कि यह किसी बाहरी कर्ता द्वारा नहीं बल्कि एक अनुबंध द्वारा तैयार किया जाता है। एक संदेश तब मिलता है, जब वर्तमान में कोड निष्पादित करने वाला अनुबंध, `CALL` ओपकोड को निष्पादित करता है, जो एक संदेश का उत्पादन और निष्पादन करता है। लेन-देन की तरह, एक संदेश प्राप्तकर्ता के खाते में अपना कोड चलाता है। इस प्रकार, अनुबंधों के अन्य अनुबंधों के साथ ठीक उसी तरह संबंध हो सकते हैं जैसे बाहरी कर्ता के होते हैं।

ध्यान दें कि किसी लेन-देन या अनुबंध द्वारा आवंटित गैस भत्ता उस लेन-देन द्वारा खपत की गई कुल गैस और सभी उप-निष्पादनों पर लागू होता है। उदाहरण के लिए, अगर एक बाहरी कर्ता A, B को 1000 गैस के साथ एक लेनदेन भेजता है, और B C को संदेश भेजने से पहले 600 गैस का उपयोग करता है, और C का आंतरिक निष्पादन वापस लौटने से पहले 300 गैस का उपयोग करता है, तो B गैस समाप्त होने से पहले और 100 गैस खर्च कर सकता है।

### एथेरियम स्टेट ट्रांजिशन फ़ंक्शन {#ethereum-state-transition-function}

![ईथर स्टेट ट्रांजिशन](./ether-state-transition.png)

एथेरियम स्टेट ट्रांजिशन फ़ंक्शन, `APPLY(S,TX) -> S'` को निम्नानुसार परिभाषित किया जा सकता हैं:

1. जाँच करें कि क्या लेन-देन अच्छी तरह से तैयार है (मतलब मूल्यों की सही संख्या है) हस्ताक्षर मान्य है, और नोन्स प्रेषक के खाते में नोन्स से मेल खाता है। अगर नहीं, तो एक गड़बड़ी वापस करें।
2. लेन-देन शुल्क की गणना `STARTGAS * GASPRICE` के रूप में करें, और हस्ताक्षर से भेजने का पता तय करें। प्रेषक के खाते की शेष राशि से शुल्क घटाएं और प्रेषक की राशि बढ़ाएं। अगर खर्च करने के लिए पर्याप्त शेष राशि नहीं है, तो एक गड़बड़ी वापस करें।
3. `GAS = STARTGAS` आरंभ करें, और लेन-देन में बाइट्स के लिए भुगतान करने के लिए प्रति बाइट गैस की एक निश्चित मात्रा लें।
4. लेन-देन मूल्य को प्रेषक के खाते से प्राप्तकर्ता खाते में स्थानांतरित करें। अगर प्राप्तकर्ता खाता अभी तक मौजूद नहीं है, तो उसे बनाएँ। अगर प्राप्तकर्ता खाता एक अनुबंध है, तो अनुबंध का कोड या तो पूरा होने तक या जब तक निष्पादन गैस समाप्त नहीं हो जाता, तब तक चलाएं।
5. अगर मूल्य अंतरण विफल हो जाता है, क्योंकि प्रेषक के पास पर्याप्त पैसा नहीं था, या कोड निष्पादन गैस से बाहर हो गया, तो शुल्क के भुगतान को छोड़कर स्टेट से जुड़े सभी बदलावों को वापस करें, और शुल्क को माईनर के खाते में जोड़ें।
6. नहीं तो, शेष गैस के लिए शुल्क भेजने वाले को वापस कर दें और गैस की खपत के लिए भुगतान शुल्क माईनर को भेज दें।

उदाहरण के लिए, मान लीजिए कि अनुबंध का कोड है:

```py
if !self.storage[calldataload(0)]:
  self.storage[calldataload(0)] = calldataload(32)
```

ध्यान दें कि असल में अनुबंध कोड निम्न-स्तरीय EVM कोड में लिखा जाता है; यह उदाहरण स्पष्टता के लिए हमारी उच्च-स्तरीय भाषाओं में से एक, सर्पेंट में लिखा गया है, और इसे EVM कोड में इकट्ठा किया जा सकता है। मान लीजिए कि अनुबंध का स्टोरेज खाली शुरू होता है, और 10 ईथर मूल्य, 2000 गैस, 0.001 ईथर गैस मूल्य, और 64 बाइट डेटा के साथ एक लेनदेन भेजा जाता है, जिसमें बाइट 0-31 संख्या `2` का प्रतिनिधित्व करते हैं और बाइट 32-63 स्ट्रिंग `CHARLIE` का प्रतिनिधित्व करते हैं। इस मामले में स्टेट ट्रांज़िशन फ़ंक्शन के लिए प्रक्रिया निम्नानुसार है:

1. जाँच करें कि लेनदेन मान्य और सही तरीके से बनाया गया है।
2. जाँच करें कि लेनदेन भेजने वाले के पास कम से कम 2000 \* 0.001 = 2 ईथर है। अगर ऐसा है, तो भेजने वाले के खाते से 2 ईथर घटा दें।
3. गैस = 2000 शुरू करें; यह मानते हुए कि लेनदेन 170 बाइट लंबा है और बाइट-शुल्क 5 है, 850 घटाएं ताकि 1150 गैस बचा रहे।
4. भेजने वाले के खाते से 10 और ईथर घटाएं, और इसे अनुबंध के खाते में जोड़ें।
5. कोड चलाएं। इस मामले में, यह सरल है: यह जाँचता है कि क्या अनुबंध का संग्रहण इंडेक्स `2` पर उपयोग किया जाता है, देखता है कि ऐसा नहीं है, और इसलिए यह इंडेक्स `2` पर संग्रहण को मूल्य `CHARLIE` पर सेट करता है। मान लीजिए कि इसमें 187 गैस लगता है, तो शेष गैस की मात्रा 1150 - 187 = 963 है
6. भेजने वाले के खाते में 963 \* 0.001 = 0.963 ईथर वापस जोड़ें, और परिणामी स्थिति लौटाएं।

अगर लेनदेन के प्राप्त करने वाले छोर पर कोई अनुबंध नहीं था, तो कुल लेनदेन शुल्क बस प्रदान किए गए `GASPRICE` को लेनदेन की बाइट में लंबाई से गुणा किया जाएगा, और लेनदेन के साथ भेजा गया डेटा अप्रासंगिक होगा।

ध्यान दें कि संदेश वापसी के संदर्भ में लेनदेन के समान काम करते हैं: अगर कोई संदेश निष्पादन गैस से बाहर हो जाता है, तो उस संदेश का निष्पादन, और उस निष्पादन द्वारा ट्रिगर किए गए अन्य सभी निष्पादन वापस हो जाते हैं, लेकिन मूल निष्पादन को वापस होने की आवश्यकता नहीं होती। इसका मतलब है कि एक अनुबंध के लिए दूसरे अनुबंध को कॉल करना "सुरक्षित" है, क्योंकि अगर A, B को G गैस के साथ कॉल करता है तो A के निष्पादन को अधिकतम G गैस खोने की गारंटी है। अंत में, ध्यान दें कि एक ऑपकोड है, `CREATE`, जो एक अनुबंध बनाता है; इसकी निष्पादन तंत्र आम तौर पर `CALL` के समान होता है, अपवाद के साथ कि निष्पादन का आउटपुट नए तैयार किए गए अनुबंध के कोड को निर्धारित करता है।

### कोड निष्पादन {#code-execution}

एथेरियम अनुबंधों में कोड एक निम्न-स्तरीय, स्टैक-आधारित बाइटकोड भाषा में लिखा जाता है, जिसे "एथेरियम वर्चुअल मशीन कोड" या "EVM कोड" के रूप में जाना जाता है। कोड बाइट्स की एक सीरीज़ से बना होता है, जहां प्रत्येक बाइट एक ऑपरेशन का प्रतिनिधित्व करता है। सामान्य तौर पर, कोड निष्पादन एक हमेशा चलने वाला लूप है जो वर्तमान प्रोग्राम काउंटर पर ऑपरेशन को बार-बार करने से बना होता है (जो शून्य से शुरू होता है) और फिर प्रोग्राम काउंटर को एक से बढ़ाता है, जब तक कि कोड का अंत न हो जाए या कोई गड़बड़ी या `STOP` या `RETURN` निर्देश का पता न चल जाए। ऑपरेशंस के पास डेटा स्टोर करने के लिए तीन प्रकार के स्थान तक पहुंच होती है:

- **स्टैक**, एक लास्ट-इन-फ़र्स्ट-आउट कंटेनर जिसमें मान पुश और पॉप किए जा सकते हैं
- **मेमोरी**, एक अनंत विस्तार योग्य बाइट ऐरे
- अनुबंध का लंबे समय के लिए **स्टोरेज**, एक की/मूल्य स्टोर। स्टैक और मेमोरी के विपरीत, जो कंप्यूटेशन समाप्त होने के बाद रीसेट हो जाते हैं, स्टोरेज लंबे समय तक बना रहता है।

कोड आने वाले संदेश के मूल्य, भेजने वाले और डेटा के साथ-साथ ब्लॉक हेडर डेटा तक भी पहुंच सकता है, और कोड आउटपुट के रूप में डेटा की एक बाइट ऐरे भी लौटा सकता है।

EVM कोड के औपचारिक निष्पादन मॉडल आश्चर्यजनक रूप से सरल है। जब एथेरियम वर्चुअल मशीन चल रही होती है, तो इसकी पूरी कम्प्यूटेशनल स्थिति को ट्यूपल `(block_state, transaction, message, code, memory, stack, pc, gas)` द्वारा परिभाषित किया जा सकता है, जहां `block_state` वैश्विक स्थिति है जिसमें सभी खाते शामिल हैं और इसमें शेष राशि और स्टोरेज शामिल हैं। निष्पादन के हर दौर की शुरुआत में, वर्तमान निर्देश `code` के `pc` वें बाइट को लेकर पाया जाता है (या 0 अगर `pc >= len(code)`), और प्रत्येक निर्देश की अपनी परिभाषा होती है कि यह ट्यूपल को कैसे प्रभावित करता है। उदाहरण के लिए, `ADD` स्टैक से दो आइटम पॉप करता है और उनका योग पुश करता है, `गैस` को 1 से कम करता है और `pc` को 1 से बढ़ाता है, और `SSTORE` स्टैक से शीर्ष दो आइटम पॉप करता है और दूसरे आइटम को अनुबंध के स्टोरेज में पहले आइटम द्वारा निर्दिष्ट इंडेक्स पर डालता है। हालांकि, जस्ट-इन-टाइम कंपाइलेशन की मदद से एथेरियम वर्चुअल मशीन निष्पादन को अनुकूलित करने के कई तरीके हैं, एथेरियम का एक बुनियादी कार्यान्वयन कोड की कुछ सौ पंक्तियों में किया जा सकता है।

### ब्लॉकचेन और माइनिंग {#blockchain-and-mining}

![एथेरियम ब्लॉक एप्लाई डायग्राम](./ethereum-apply-block-diagram.png)

एथेरियम ब्लॉकचेन कई मायनों में Bitcoin ब्लॉकचेन के समान है, हालांकि इसमें कुछ अंतर हैं। ब्लॉकचेन आर्किटेक्चर के संबंध में एथेरियम और Bitcoin के बीच मुख्य अंतर यह है कि Bitcoin के विपरीत, एथेरियम ब्लॉक में लेनदेन सूची और सबसे हाल की स्थिति दोनों की एक कॉपी होती है। इसके अलावा, दो अन्य मूल्य, ब्लॉक संख्या और कठिनाई, भी ब्लॉक में संग्रहीत किए जाते हैं। एथेरियम में बुनियादी ब्लॉक सत्यापन एल्गोरिथ्म निम्नानुसार है:

1. जांचें कि संदर्भित पिछला ब्लॉक मौजूद है और मान्य है।
2. जांचें कि ब्लॉक का टाइमस्टैम्प संदर्भित पिछले ब्लॉक से अधिक है और भविष्य में 15 मिनट से कम है
3. जांचें कि ब्लॉक संख्या, कठिनाई, लेनदेन रूट, अंकल रूट और गैस सीमा (अलग-अलग निम्न-स्तरीय एथेरियम-विशिष्ट अवधारणाएं) मान्य हैं।
4. जाँचें कि ब्लॉक पर काम का सबूत मान्य है या नहीं।
5. पिछले ब्लॉक के अंत में `S[0]` स्टेट होने दें।
6. मान लें कि `TX` ब्लॉक की लेनदेन सूची है, जिसमें `n` लेनदेन हैं। सभी `i` के लिए `0...n-1` में, `S[i+1] = APPLY(S[i],TX[i]) सेट करें`। अगर कोई भी एप्लिकेशन गड़बड़ी लौटाता है, या इस बिंदु तक ब्लॉक में खपत की गई कुल गैस `GASLIMIT` से अधिक हो जाती है, तो गड़बड़ी लौटाएं।
7. मान लें कि `S_FINAL` `S[n]` है, लेकिन माईनर को भुगतान किए गए ब्लॉक पुरस्कार को जोड़कर।
8. जांचें कि स्थिति `S_FINAL` का मर्कल ट्री रूट ब्लॉक हेडर में प्रदान किए गए अंतिम स्टेट रूट के बराबर है। अगर ऐसा है, तो ब्लॉक मान्य है; नहीं तो, यह मान्य नहीं है।

पहली नज़र में दृष्टिकोण बहुत ज़्यादा अक्षम लग सकता है, क्योंकि इसे प्रत्येक ब्लॉक के साथ पूरी स्थिति को संग्रहीत करने की आवश्यकता होती है, लेकिन वास्तविकता में दक्षता Bitcoin के समान होनी चाहिए। कारण यह है कि स्थिति ट्री संरचना में संग्रहीत की जाती है, और प्रत्येक ब्लॉक के बाद ट्री का केवल एक छोटा हिस्सा बदलने की आवश्यकता होती है। इस प्रकार, सामान्य रूप से, दो बगल वाले ब्लॉकों के बीच पेड़ का विशाल बहुमत समान होना चाहिए, और इसलिए डेटा को एक बार संग्रहीत किया जा सकता है और संकेतों का उपयोग करके दो बार संदर्भित किया जा सकता है (अर्थात्, सबट्री के हैश)। इस काम को पूरा करने के लिए एक विशेष प्रकार के ट्री "पेट्रिसिया ट्री" का उपयोग किया जाता है, जिसमें मेरकल वृक्ष की अवधारणा में बदलाव किया गया है, जिससे नोड्स को कुशलता से जोड़ा और हटाया जा सके, न केवल बदला जा सके। इसके अतिरिक्त, क्योंकि स्टेट की सभी जानकारी अंतिम ब्लॉक का हिस्सा है, इसलिए पूरे ब्लॉकचेन इतिहास को संग्रहीत करने की कोई आवश्यकता नहीं है - एक रणनीति जो, अगर इसे Bitcoin पर लागू किया जा सकता है, तो अंतरिक्ष में 5-20x बचत प्रदान करने के लिए गणना की जा सकती है।

एक आम तौर पर पूछा जाने वाला प्रश्न भौतिक हार्डवेयर के संदर्भ में अनुबंध कोड को "कहाँ" निष्पादित किया जाता है। इसका एक सरल जवाब हैः अनुबंध कोड को निष्पादित करने की प्रक्रिया स्टेट ट्रांज़िशन फ़ंक्शन की परिभाषा का हिस्सा है, जो ब्लॉक सत्यापन एल्गोरिथ्म का हिस्सा है, इसलिए अगर कोई लेनदेन ब्लॉक `B` में जोड़ा जाता है, तो उस लेनदेन द्वारा उत्पन्न कोड निष्पादन सभी नोड्स द्वारा निष्पादित किया जाएगा, अब और भविष्य में, जो ब्लॉक `B` को डाउनलोड और मान्य करता है।

## एप्लिकेशन {#applications}

आम तौर पर, एथेरियम के तीन प्रकार के एप्लिकेशन होते हैं। पहली श्रेणी वित्तीय एप्लिकेशन है, जिससे उपयोगकर्ताओं को अपने पैसे का उपयोग करके अनुबंधों का प्रबंधन करने और उनमें प्रवेश करने के लिए अधिक बेहतरीन तरीके प्रदान करती है। इसमें उप-मुद्राएं, वित्तीय डेरिवेटिव, हेजिंग अनुबंध, बचत वॉलेट, वसीयत और अंततः पूर्ण पैमाने के रोज़गार संबंधी अनुबंधों के कुछ वर्ग भी शामिल हैं। दूसरी श्रेणी अर्ध-वित्तीय अनुप्रयोगों की है, जहां पैसा शामिल है लेकिन जो किया जा रहा है उसका एक भारी गैर-मौद्रिक पक्ष भी है; एक सही उदाहरण कम्प्यूटेशनल समस्याओं के समाधान के लिए खुद लागू होने वाले इनाम हैं। आखिर में, ऐसे एप्लिकेशन हैं जैसे ऑनलाइन मतदान और विकेंद्रीकृत शासन जो बिल्कुल भी वित्तीय नहीं हैं।

### टोकन सिस्टम {#token-systems}

ऑन-ब्लॉकचेन टोकन सिस्टम के कई एप्लिकेशन हैं जो USD या सोने जैसी संपत्तियों का प्रतिनिधित्व करने वाली उप-मुद्राओं से लेकर कंपनी के स्टॉक, स्मार्ट संपत्ति को दर्शाने वाले व्यक्तिगत टोकन, सुरक्षित अप्रतिकृत कूपन, और यहां तक कि पारंपरिक मूल्य से बिना किसी संबंध के टोकन सिस्टम तक फैले हुए हैं, जिनका उपयोग प्रोत्साहन के लिए पॉइंट सिस्टम के रूप में किया जाता है। एथेरियम में टोकन सिस्टम को लागू करना आश्चर्यजनक रूप से आसान है। समझने वाली मुख्य बात यह है कि एक मुद्रा, या टोकन सिस्टम, मूल रूप से एक डेटाबेस है जिसमें एक ऑपरेशन है: A से X इकाइयाँ घटाएँ और B को X इकाइयाँ दें, इस शर्त के साथ कि (i) लेनदेन से पहले A के पास कम से कम X इकाइयाँ थीं और (2) लेनदेन A द्वारा स्वीकृत है। एक टोकन सिस्टम को लागू करने के लिए इस तर्क को एक अनुबंध में लागू करना ही काफ़ी है।

सर्पेंट में एक टोकन सिस्टम को लागू करने का बुनियादी कोड इस प्रकार दिखता है:

```py
def send(to, value):
  if self.storage[msg.sender] >= value:
    self.storage[msg.sender] = self.storage[msg.sender] - value
    self.storage[to] = self.storage[to] + value
```

यह अनिवार्य रूप से इस दस्तावेज़ में ऊपर वर्णित "बैंकिंग सिस्टम" स्टेट ट्रांजीशन फंक्शन का एक शाब्दिक कार्यान्वयन है। कोड की कुछ अतिरिक्त पंक्तियाँ जोड़ने की आवश्यकता है, ताकि पहले स्थान पर मुद्रा इकाइयों के वितरण के प्रारंभिक चरण और कुछ अन्य सीमांत मामलों के लिए प्रावधान किया जा सके, और आदर्श रूप से एक फ़ंक्शन जोड़ा जाएगा जो अन्य अनुबंधों को किसी पते के शेष की जांच करने की अनुमति देगा। हालांकि, बस इतना ही है। सैद्धांतिक रूप से, उप-मुद्राओं के रूप में कार्य करने वाले एथेरियम-आधारित टोकन सिस्टम में संभावित रूप से एक अन्य महत्वपूर्ण विशेषता हो सकती है जो ऑन-चेन Bitcoin-आधारित मेटा-मुद्राओं में नहीं है: उस मुद्रा में सीधे लेनदेन शुल्क का भुगतान करने की क्षमता। इसे इस तरह से लागू किया जाएगा कि अनुबंध एक ईथर शेष बनाए रखेगा जिससे वह शुल्क का भुगतान करने के लिए उपयोग किए गए ईथर को प्रेषक को वापस कर देगा, और यह शुल्क में ली जाने वाली आंतरिक मुद्रा इकाइयों को एकत्र करके और उन्हें एक निरंतर चलने वाली नीलामी में फिर से बेचकर इस शेष को दोबारा भर देगा। इस प्रकार उपयोगकर्ताओं को अपने खातों को ईथर के साथ "सक्रिय" करने की आवश्यकता होगी, लेकिन एक बार ईथर वहां होने के बाद यह फिर से उपयोग योग्य होगा, क्योंकि अनुबंध हर बार इसे वापस कर देगा।

### वित्तीय डेरिवेटिव और स्थिर-मूल्य मुद्राएं {#financial-derivatives-and-stable-value-currencies}

वित्तीय डेरिवेटिव "स्मार्ट अनुबंध" के सबसे आम एप्लिकेशन हैं, और कोड में लागू करने के लिए सबसे सरल में से एक हैं। वित्तीय अनुबंधों को लागू करने में मुख्य चुनौती यह है कि उनमें से ज़्यादातर को एक बाहरी मूल्य टिकर के संदर्भ की आवश्यकता होती है; उदाहरण के लिए, एक बहुत वांछनीय एप्लिकेशन एक स्मार्ट अनुबंध है जो अमेरिकी डॉलर के संबंध में ईथर (या किसी अन्य क्रिप्टोकरेंसी) की अस्थिरता के खिलाफ बचाव करता है, लेकिन ऐसा करने के लिए अनुबंध को यह जानने की आवश्यकता होती है कि ETH/USD का मूल्य क्या है। ऐसा करने का सबसे सरल तरीका एक खास पार्टी (जैसे NASDAQ) द्वारा बनाए रखे गए एक "डेटा फीड" अनुबंध के माध्यम से है जिसे इस तरह से डिज़ाइन किया गया है कि उस पार्टी के पास आवश्यकतानुसार अनुबंध को अपडेट करने की क्षमता है, और एक इंटरफ़ेस प्रदान करता है जो अन्य अनुबंधों को उस अनुबंध को एक संदेश भेजने और एक प्रतिक्रिया प्राप्त करने की अनुमति देता है जो कीमत प्रदान करता है।

उस महत्वपूर्ण घटक को देखते हुए, हेजिंग अनुबंध इस प्रकार दिखेगा:

1. पार्टी A के 1000 ईथर इनपुट करने की प्रतीक्षा करें।
2. पार्टी B के 1000 ईथर इनपुट करने की प्रतीक्षा करें।
3. डेटा फीड अनुबंध से पूछताछ करके गणना किए गए 1000 ईथर के USD मूल्य को स्टोरेज में रिकॉर्ड करें, मान लें कि यह $x है।
4. 30 दिनों के बाद, A या B को अनुबंध को "फिर से चालू" करने की अनुमति दें ताकि A को $x मूल्य का ईथर (नई कीमत प्राप्त करने के लिए डेटा फ़ीड अनुबंध से फिर से पूछताछ करके गणना की गई) और शेष B को भेजा जा सके।

ऐसे अनुबंध की क्रिप्टो-वाणिज्य में महत्वपूर्ण संभावना होगी। क्रिप्टोकरेंसी के बारे में बताई जाने वाली मुख्य समस्याओं में से एक यह तथ्य है कि यह अस्थिर है; हालांकि, कई उपयोगकर्ता और व्यापारी क्रिप्टोग्राफिक संपत्तियों के साथ व्यवहार करने की सुरक्षा और सुविधा चाहते हैं, वे एक ही दिन में अपने फ़ंड के मूल्य का 23% खोने की संभावना का सामना नहीं करना चाहते। अब तक, सबसे अधिक प्रस्तावित समाधान जारीकर्ता-समर्थित संपत्तियां रहा है; विचार यह है कि एक जारीकर्ता एक उप-मुद्रा बनाता है जिसमें उनके पास इकाइयों को जारी करने और रद्द करने का अधिकार होता है, और किसी भी व्यक्ति को मुद्रा की एक इकाई प्रदान करता है जो उन्हें (ऑफ़लाइन) एक निर्दिष्ट अंतर्निहित संपत्ति (जैसे सोना, USD) की एक इकाई प्रदान करता है। फिर जारीकर्ता किसी भी व्यक्ति को अंतर्निहित संपत्ति की एक इकाई प्रदान करने का वादा करता है जो क्रिप्टो-संपत्ति की एक इकाई वापस भेजता है। यह तरीका किसी भी गैर-क्रिप्टोग्राफिक संपत्ति को एक क्रिप्टोग्राफिक संपत्ति में "बेहतरीन" करने की अनुमति देता है, बशर्ते कि जारीकर्ता पर भरोसा किया जा सके।

व्यवहार में, हालांकि, जारीकर्ता हमेशा विश्वसनीय नहीं होते हैं, और कुछ मामलों में बैंकिंग बुनियादी ढांचा बहुत कमजोर है, या ऐसी सेवाओं के मौजूद होने के लिए बहुत प्रतिकूल है। वित्तीय डेरिवेटिव एक विकल्प प्रदान करते हैं। यहां एक एकल जारीकर्ता के बजाय जो एक संपत्ति को सपोर्ट करने के लिए धन प्रदान करता है, सट्टेबाजों का एक विकेंद्रीकृत बाज़ार, जो यह शर्त लगाता है कि एक क्रिप्टोग्राफिक संदर्भ संपत्ति (जैसे ETH) की कीमत बढ़ेगी, वह भूमिका निभाता है। जारीकर्ताओं के विपरीत, सट्टेबाजों के पास सौदे के अपने हिस्से पर चूक करने का कोई विकल्प नहीं होता है, क्योंकि हेजिंग अनुबंध उनके फ़ंड को एस्क्रो में रखता है। ध्यान दें कि यह दृष्टिकोण पूरी तरह से विकेंद्रीकृत नहीं है, क्योंकि मूल्य टिकर प्रदान करने के लिए अब भी एक विश्वसनीय स्रोत की आवश्यकता होती है, हालांकि तर्क दिया जा सकता है कि यह अब भी बुनियादी ढांचे की आवश्यकताओं को कम करने के मामले में एक बड़ा सुधार है (जारीकर्ता होने के विपरीत, मूल्य फ़ीड जारी करने के लिए किसी लाइसेंस की आवश्यकता नहीं होती है और इसे शायद मुक्त भाषण के रूप में वर्गीकृत किया जा सकता है) और धोखाधड़ी की संभावना को कम करता है।

### पहचान और प्रतिष्ठा प्रणालियाँ {#identity-and-reputation-systems}

सबसे पुरानी वैकल्पिक क्रिप्टोकरेंसी, [Namecoin](http://namecoin.org/), ने एक नाम पंजीकरण प्रणाली प्रदान करने के लिए Bitcoin जैसी ब्लॉकचेन का उपयोग करने का प्रयास किया, जहां उपयोगकर्ता अपने नाम को अन्य डेटा के साथ एक सार्वजनिक डेटाबेस में पंजीकृत कर सकते हैं। प्रमुख उद्धृत उपयोग मामला एक [DNS](https://wikipedia.org/wiki/Domain_Name_System) प्रणाली के लिए है, जो डोमेन नामों जैसे "bitcoin.org" (या, Namecoin के मामले में, "bitcoin.bit") को एक IP पते से मैप करता है। अन्य उपयोग मामलों में ईमेल प्रमाणीकरण और संभावित रूप से अधिक उन्नत प्रतिष्ठा प्रणालियाँ शामिल हैं। यहाँ एथेरियम पर Namecoin जैसी नाम पंजीकरण प्रणाली प्रदान करने के लिए बुनियादी अनुबंध है:

```py
def register(name, value):
  if !self.storage[name]:
    self.storage[name] = value
```

अनुबंध बहुत सरल है; यह एथेरियम नेटवर्क के अंदर एक डेटाबेस है जिसमें कुछ जोड़ा तो जा सकता है, लेकिन संशोधित किया या हटाया नहीं जा सकता। कोई भी किसी मूल्य वाला एक नाम पंजीकृत कर सकता है, और वह पंजीकरण तब हमेशा के लिए रहता है। एक अधिक परिष्कृत नाम पंजीकरण अनुबंध में एक "फंक्शन क्लॉज" भी होगा जो अन्य अनुबंधों को इसकी पूछताछ करने देता है, साथ ही नाम के "मालिक" (यानी पहले पंजीकरणकर्ता) के लिए डेटा बदलने या स्वामित्व हस्तांतरित करने का एक तंत्र भी होगा। कोई भी इसके ऊपर प्रतिष्ठा और विश्वास-का-वेब कार्यक्षमता जोड़ सकता है।

### विकेंद्रीकृत फ़ाइल भंडारण {#decentralized-file-storage}

पिछले कुछ वर्षों में, कई लोकप्रिय ऑनलाइन फ़ाइल भंडारण स्टार्टअप सामने आए हैं, जिनमें सबसे प्रमुख ड्रॉपबॉक्स है, जो यूज़र को अपनी हार्ड ड्राइव का बैकअप अपलोड करने और सेवा को बैकअप संग्रहित करने और यूज़र को मासिक शुल्क के बदले में इसे एक्सेस करने की अनुमति देता है। हालांकि, इस बिंदु पर फ़ाइल संग्रहण बाजार कभी-कभी अपेक्षाकृत अकुशल होता है; विभिन्न मौजूदा समाधानों पर एक सरसरी नज़र से पता चलता है कि, विशेष रूप से "अनकैनी वैली" 20-200 GB स्तर पर जहां न तो मुफ्त कोटा और न ही उद्यम-स्तरीय छूट लागू होती है, मुख्यधारा के फ़ाइल स्टोरेज लागत के लिए मासिक कीमतें ऐसी हैं कि आप एक महीने में पूरी हार्ड ड्राइव की लागत से अधिक का भुगतान कर रहे हैं। एथेरियम अनुबंध एक विकेंद्रीकृत फ़ाइल भंडारण पारिस्थितिकी तंत्र के विकास की अनुमति दे सकते हैं, जहां व्यक्तिगत यूज़र अपनी खुद की हार्ड ड्राइव को किराए पर देकर कम मात्रा में पैसे कमा सकते हैं और अप्रयुक्त स्थान का उपयोग फ़ाइल भंडारण की लागत को और कम करने के लिए किया जा सकता है।

ऐसे उपकरण का मुख्य आधार टुकड़ा वह होगा जिसे हमने "विकेंद्रीकृत ड्रॉपबॉक्स अनुबंध" कहा है। यह अनुबंध इस प्रकार काम करता है। सबसे पहले, वांछित डेटा को ब्लॉकों में विभाजित किया जाता है, निजता के लिए प्रत्येक ब्लॉक को एन्क्रिप्ट किया जाता है और उसमें से एक मर्कल ट्री बनाया जाता है। फिर एक अनुबंध बनाया जाता है जिसमें नियम यह है कि, हर N ब्लॉक के बाद, अनुबंध मर्कल ट्री में एक रैंडम इंडेक्स चुनेगा (पिछले ब्लॉक हैश का उपयोग करके, जिसे अनुबंध कोड से एक्सेस किया जा सकता है, रैंडमनेस के स्रोत के रूप में), और ट्री में उस विशेष इंडेक्स पर ब्लॉक के स्वामित्व के सरलीकृत भुगतान सत्यापन जैसे प्रमाण के साथ लेनदेन की आपूर्ति करने वाली पहली इकाई को X ईथर देगा। जब कोई यूज़र अपनी फ़ाइल को फिर से डाउनलोड करना चाहता है, तो वे फ़ाइल को पुनः प्राप्त करने के लिए एक माइक्रोपेमेंट चैनल प्रोटोकॉल का उपयोग कर सकते हैं (उदाहरण के लिए, 32 किलोबाइट प्रति 1 स्ज़ाबो का भुगतान करें); सबसे शुल्क-कुशल दृष्टिकोण यह है कि भुगतानकर्ता अंत तक लेनदेन प्रकाशित न करे, इसके बजाय हर 32 किलोबाइट के बाद समान नोंस वाले थोड़े अधिक लाभदायक लेनदेन के साथ लेनदेन को बदल दे।

प्रोटोकॉल की एक महत्वपूर्ण विशेषता यह है कि, हालांकि ऐसा लग सकता है कि कोई कई रैंडम नोड्स पर भरोसा कर रहा है कि वे फ़ाइल को भूलने का निर्णय नहीं लेंगे, कोई भी इस जोखिम को गुप्त साझाकरण के माध्यम से फ़ाइल को कई टुकड़ों में विभाजित करके और अनुबंधों पर नज़र रखकर इस जोखिम को लगभग शून्य तक कम किया जा सकता है कि प्रत्येक टुकड़ा अभी भी किसी नोड के कब्जे में है। यदि कोई अनुबंध अभी भी पैसे का भुगतान कर रहा है, तो यह एक क्रिप्टोग्राफिक प्रमाण प्रदान करता है कि कोई अभी भी फ़ाइल को संग्रहित कर रहा है।

### विकेंद्रीकृत स्वायत्त संगठन {#decentralized-autonomous-organizations}

एक "विकेंद्रीकृत स्वायत्त संगठन" की सामान्य अवधारणा एक आभासी इकाई की है जिसमें सदस्यों या शेयरधारकों का एक निश्चित समूह होता है, जो शायद 67% बहुमत के साथ, इकाई के फंड खर्च करने और उसके कोड को संशोधित करने का अधिकार रखता है। सदस्य सामूहिक रूप से यह तय करेंगे कि संगठन को अपने फंड का आवंटन कैसे करना चाहिए। एक डीएओ के फंड आवंटित करने के तरीके इनाम, वेतन से लेकर काम को पुरस्कृत करने के लिए आंतरिक मुद्रा जैसे अधिक अजीब तंत्रों तक हो सकते हैं। यह अनिवार्य रूप से एक पारंपरिक कंपनी या गैर-लाभकारी संस्था के कानूनी पहलुओं को दोहराता है लेकिन केवल प्रवर्तन के लिए क्रिप्टोग्राफिक ब्लॉकचेन तकनीक का उपयोग करता है। अब तक डीएओ के बारे में बहुत सी बातें लाभांश प्राप्त करने वाले शेयरधारकों और व्यापार योग्य शेयरों वाले "विकेंद्रीकृत स्वायत्त निगम" (DAC) के "पूंजीवादी" मॉडल के बारे में रही हैं; एक विकल्प, जिसे शायद "विकेंद्रीकृत स्वायत्त समुदाय" के रूप में वर्णित किया जा सकता है, में सभी सदस्यों की निर्णय लेने में समान भागीदारी होगी और किसी सदस्य को जोड़ने या हटाने के लिए 67% मौजूदा सदस्यों की सहमति की आवश्यकता होगी। यह आवश्यकता कि एक व्यक्ति की केवल एक सदस्यता हो सकती है, तब समूह द्वारा सामूहिक रूप से लागू की जानी होगी।

एक DAO को कोड करने के लिए एक सामान्य रूपरेखा इस प्रकार है। सबसे सरल डिज़ाइन बस एक स्व-संशोधित कोड का टुकड़ा है जो बदल जाता है यदि दो-तिहाई सदस्य एक परिवर्तन पर सहमत होते हैं। हालांकि सैद्धांतिक रूप से कोड अपरिवर्तनीय होता है, कोई भी इससे आसानी से बच सकता है और कोड के टुकड़ों को अलग-अलग अनुबंधों में रखकर, और जिन अनुबंधों को कॉल करना है उनके पते को संशोधन योग्य स्टोरेज में संग्रहित करके वास्तविक परिवर्तनशीलता प्राप्त कर सकता है। ऐसे DAO अनुबंध के एक सरल कार्यान्वयन में, तीन प्रकार के लेनदेन होंगे, जो लेनदेन में प्रदान किए गए डेटा द्वारा अलग किए जाते हैं:

- `[0,i,K,V]` भंडारण इंडेक्स `K` पर पते को मूल्य `V` में बदलने के लिए इंडेक्स `i` के साथ एक प्रस्ताव पंजीकृत करने के लिए
- `[1,i]` प्रस्ताव `i` के पक्ष में एक वोट पंजीकृत करने के लिए
- `[2,i]` यदि पर्याप्त वोट किए गए हैं तो प्रस्ताव `i` को अंतिम रूप देने के लिए

अनुबंध में तब इनमें से प्रत्येक के लिए खंड होंगे। यह सभी खुले भंडारण परिवर्तनों का एक रिकॉर्ड बनाए रखेगा, साथ ही इसकी एक सूची भी रखेगा कि उनके लिए किसने वोट दिया। इसमें सभी सदस्यों की एक सूची भी होगी। जब कोई भी भंडारण परिवर्तन दो-तिहाई सदस्यों के वोट तक पहुंच जाता है, तो एक अंतिम लेनदेन परिवर्तन को निष्पादित कर सकता है। एक अधिक परिष्कृत ढांचे में लेनदेन भेजने, सदस्यों को जोड़ने और हटाने जैसी सुविधाओं के लिए बिल्ट-इन मतदान क्षमता भी होगी, और यहां तक कि [लिक्विड डेमोक्रेसी](https://wikipedia.org/wiki/Liquid_democracy)-शैली के वोट प्रतिनिधिमंडल के लिए भी प्रावधान हो सकता है (यानी कोई भी किसी को अपने लिए वोट करने के लिए असाइन कर सकता है, और असाइनमेंट संक्रामक है इसलिए यदि A, B को असाइन करता है और B, C को असाइन करता है तो C, A का वोट निर्धारित करता है)। यह डिज़ाइन डीएओ को एक विकेंद्रीकृत समुदाय के रूप में जैविक रूप से विकसित होने देगा, लोगों को अंततः यह फ़िल्टर करने का कार्य विशेषज्ञों को सौंपने देगा कि कौन सदस्य है, हालांकि "वर्तमान प्रणाली" के विपरीत विशेषज्ञ समय के साथ आसानी से अस्तित्व में आ और जा सकते हैं क्योंकि व्यक्तिगत समुदाय के सदस्य अपने संरेखण बदलते हैं।

एक वैकल्पिक मॉडल विकेंद्रीकृत निगम के लिए है, जहां किसी भी खाते के पास शून्य या उससे अधिक शेयर हो सकते हैं, और निर्णय लेने के लिए दो तिहाई शेयरों की आवश्यकता होती है। एक पूर्ण ढांचे में परिसंपत्ति प्रबंधन कार्यक्षमता, शेयर खरीदने या बेचने का प्रस्ताव देने की क्षमता और प्रस्तावों को स्वीकार करने की क्षमता शामिल होगी (अनुबंध के अंदर एक आदेश-मिलान तंत्र के साथ, यदि संभव हो)। प्रतिनिधि का अस्तित्व भी लिक्विड डेमोक्रेसी-शैली में होगा, "बोर्ड ऑफ डायरेक्टर्स" की अवधारणा का सामान्यीकरण करते हुए।

### आगे के अनुप्रयोग {#further-applications}

**1. बचत वॉलेट**। मान लीजिए कि एलिस अपने फंड को सुरक्षित रखना चाहती है, लेकिन चिंतित है कि वह अपनी निजी चाबी खो देगी या कोई उसे हैक कर लेगा। वह ईथर को बॉब, एक बैंक के साथ एक अनुबंध में डालती है, जो इस प्रकार है:

- एलिस अकेले प्रतिदिन अधिकतम 1% फंड निकाल सकती है।
- बॉब अकेले प्रतिदिन अधिकतम 1% फंड निकाल सकता है, लेकिन एलिस के पास अपनी चाबी से एक लेनदेन करने की क्षमता है जो इस क्षमता को बंद कर देती है।
- एलिस और बॉब मिलकर कुछ भी निकाल सकते हैं।

सामान्यतः, एलिस के लिए प्रतिदिन 1% पर्याप्त है, और यदि एलिस अधिक निकालना चाहती है तो वह मदद के लिए बॉब से संपर्क कर सकती है। अगर एलिस की चाबी हैक हो जाती है, तो वह धनराशि को नए अनुबंध में स्थानांतरित करने के लिए बॉब के पास जाती है। यदि वह अपनी चाबी खो देती है, तो बॉब अंततः फंड निकाल लेगा। यदि बॉब दुर्भावनापूर्ण साबित होता है, तो वह उसकी निकासी की क्षमता को बंद कर सकती है।

**2. क्रॉप इंश्योरेंस**। कोई भी किसी भी मूल्य सूचकांक के बजाय मौसम के डेटा फीड का उपयोग करके आसानी से एक वित्तीय डेरिवेटिव अनुबंध बना सकता है। यदि आयोवा में एक किसान एक डेरिवेटिव खरीदता है जो आयोवा में वर्षा के आधार पर विपरीत रूप से भुगतान करता है, तो यदि सूखा पड़ता है, तो किसान को स्वचालित रूप से पैसा मिलेगा और यदि पर्याप्त बारिश होती है तो किसान खुश होगा क्योंकि उनकी फसलें अच्छी होंगी। इसे सामान्य रूप से प्राकृतिक आपदा बीमा में विस्तारित किया जा सकता है।

**3. एक विकेंद्रीकृत डेटा फीड**। वित्तीय अंतर अनुबंधों के लिए, ["SchellingCoin"](http://blog.ethereum.org/2014/03/28/schellingcoin-a-minimal-trust-universal-data-feed/) नामक एक प्रोटोकॉल के माध्यम से डेटा फीड को विकेंद्रीकृत करना वास्तव में संभव हो सकता है। SchellingCoin मूल रूप से इस प्रकार काम करता है: N पक्ष सभी सिस्टम में एक दिए गए डेटम का मूल्य डालते हैं (उदाहरण के लिए ETH/USD मूल्य), मूल्यों को क्रमबद्ध किया जाता है, और 25वें और 75वें प्रतिशतक के बीच सभी को पुरस्कार के रूप में एक टोकन मिलता है। हर किसी के पास वह उत्तर प्रदान करने का प्रोत्साहन होता है जो हर कोई प्रदान करेगा, और एकमात्र मूल्य जिस पर बड़ी संख्या में खिलाड़ी वास्तव में सहमत हो सकते हैं वह स्पष्ट डिफ़ॉल्ट है: सत्य। यह एक विकेंद्रीकृत प्रोटोकॉल बनाता है जो सैद्धांतिक रूप से किसी भी संख्या में मूल्य प्रदान कर सकता है, जिसमें ETH/USD मूल्य, बर्लिन में तापमान या यहां तक कि किसी विशेष कठिन गणना का परिणाम भी शामिल है।

**4. स्मार्ट मल्टीसिग्नेचर एस्क्रो**। Bitcoin मल्टीसिग्नेचर लेनदेन अनुबंधों की अनुमति देता है जहां, उदाहरण के लिए, दी गई पांच चाबियों में से तीन फंड खर्च कर सकती हैं। एथेरियम अधिक परिष्कार की अनुमति देता है; उदाहरण के लिए, पांच में से चार सब कुछ खर्च कर सकते हैं, पांच में से तीन प्रतिदिन 10% तक खर्च कर सकते हैं, और पांच में से दो प्रतिदिन 0.5% तक खर्च कर सकते हैं। इसके अतिरिक्त, एथेरियम मल्टीसिग असिंक्रोनस है - दो पक्ष अलग-अलग समय पर ब्लॉकचेन पर अपने हस्ताक्षर पंजीकृत कर सकते हैं और अंतिम हस्ताक्षर स्वचालित रूप से लेनदेन भेज देगा।

**5. क्लाउड कंप्यूटिंग**। EVM तकनीक का उपयोग एक सत्यापन योग्य कंप्यूटिंग वातावरण बनाने के लिए भी किया जा सकता है, जो उपयोगकर्ताओं को दूसरों से गणना करने के लिए कहने और फिर वैकल्पिक रूप से कुछ यादृच्छिक रूप से चुने गए चेकपॉइंट्स पर गणना सही ढंग से की गई थी, इसके प्रमाण मांगने की अनुमति देता है। इससे एक क्लाउड कंप्यूटिंग बाजार बनाया जा सकता है जहां कोई भी यूज़र अपने डेस्कटॉप, लैपटॉप या विशेष सर्वर के साथ भाग ले सकता है और स्पॉट-चेकिंग और सुरक्षा जमा का उपयोग करके यह सुनिश्चित किया जा सकता है कि सिस्टम भरोसेमंद है (अर्थात्, नोड्स लाभप्रद रूप से धोखा नहीं दे सकते)। हालांकि यह सिस्टम सभी कार्यों के लिए उपयुक्त नहीं हो सकता है। उदाहरण के लिए, जिन कार्यों में उच्च स्तर की अंतर-प्रक्रिया संचार की आवश्यकता होती है, उन्हें नोड्स के बड़े क्लाउड पर आसानी से नहीं किया जा सकता। हालांकि, दूसरे टास्क को समानांतर करना बहुत आसान है; SETI@home, folding@home और जेनेटिक एल्गोरिदम जैसे प्रोजेक्ट ऐसे किसी प्लेटफ़ॉर्म पर आसानी से लागू किए जा सकते हैं।

**6. पीयर-टू-पीयर जुआ**। कई पीयर-टू-पीयर जुआ प्रोटोकॉल, जैसे फ्रैंक स्टजानो और रिचर्ड क्लेटन के [साइबरडाइस](http://www.cl.cam.ac.uk/~fms27/papers/2008-StajanoCla-cyberdice.pdf), को एथेरियम ब्लॉकचेन पर लागू किया जा सकता है। सबसे सरल जुआ प्रोटोकॉल वास्तव में अगले ब्लॉक हैश पर एक अंतर का अनुबंध है और इससे आगे और उन्नत प्रोटोकॉल बनाए जा सकते हैं, इससे लगभग शून्य शुल्क वाली जुआ सेवाएं बनाई जा सकती हैं जिनमें धोखा देने की क्षमता नहीं होती।

**7. भविष्यवाणी बाजार**। एक ओरेकल या SchellingCoin की मदद से, भविष्यवाणी बाजारों को भी आसानी से लागू किया जा सकता है और भविष्यवाणी बाजार और SchellingCoin मिलकर विकेंद्रीकृत संगठनों के लिए शासन प्रणाली के रूप में [फ्यूटार्की](http://hanson.gmu.edu/futarchy.html) का पहला मुख्यधारा का एप्लिकेशन साबित हो सकते हैं।

**8. ऑन-चेन पर आधारित विकेंद्रीकृत बाजार**, जो पहचान और प्रतिष्ठा प्रणाली का उपयोग आधार के रूप में करते हैं।

## विविध मुद्दे और चिंताएं {#miscellanea-and-concerns}

### संशोधित GHOST कार्यान्वयन {#modified-ghost-implementation}

"ग्रीडी हेवीएस्ट ऑब्जर्व्ड सबट्री" (GHOST) प्रोटोकॉल एक नवाचार है जिसे [दिसंबर 2013](https://eprint.iacr.org/2013/881.pdf) में योनातन सोम्पोलिन्स्की और अवीव ज़ोहर ने पेश किया था। GHOST के पीछे का विचार यह है कि तेज पुष्टि समय वाली ब्लॉकचेन वर्तमान में उच्च पुराने दर के कारण कम सुरक्षा से पीड़ित हैं, ऐसा इसलिए है क्योंकि ब्लॉक को नेटवर्क में फैलने में कुछ समय लगता है, अगर माईनर A एक ब्लॉक खोदता है और फिर माईनर B दूसरा ब्लॉक खोद लेता है, इससे पहले कि A का ब्लॉक B तक पहुंचे, तो B का ब्लॉक बेकार हो जाएगा और नेटवर्क सुरक्षा में योगदान नहीं देगा। इसके अलावा, एक केंद्रीकरण मुद्दा है: यदि माईनर A 30% हैशपावर वाला एक खनन पूल है और B में 10% हैशपावर है, तो A के लिए 70% समय पुराने ब्लॉक का उत्पादन करने का जोखिम होगा (क्योंकि अन्य 30% समय A ने अंतिम ब्लॉक का उत्पादन किया और इसलिए तुरंत खनन डेटा प्राप्त होगा) जबकि B के लिए 90% समय में पुराने ब्लॉक का उत्पादन करने का जोखिम होगा। इसलिए, अगर ब्लॉक अंतराल इतना छोटा है कि पुरानी दर उच्च हो, तो A अपने आकार के कारण काफी अधिक कुशल होगा। इन दोनों प्रभावों के मिलने से, जो ब्लॉकचेन जल्दी ब्लॉक बनाती हैं, उनमें एक माईनिंग पूल के पास नेटवर्क हैशपावर का बड़ा हिस्सा होने की संभावना अधिक होती है, जिससे वह माईनिंग प्रक्रिया पर वास्तविक नियंत्रण रख सकता है।

सोम्पोलिन्स्की और ज़ोहर के अनुसार, GHOST नेटवर्क सुरक्षा के नुकसान की पहली समस्या को हल करता है, यह पुराने ब्लॉकों को भी शामिल करके यह गणना करता है कि कौन सी श्रृंखला "सबसे लंबी" है, यानी, न केवल एक ब्लॉक के पैरेंट और पूर्वज, बल्कि ब्लॉक के पूर्वज के पुराने वंशज (एथेरियम की भाषा में, "अंकल") भी इस गणना में जोड़े जाते हैं कि किस ब्लॉक के पीछे सबसे बड़ा कुल काम का सबूत है। केंद्रीकरण पूर्वाग्रह की दूसरी समस्या को हल करने के लिए, हम सोम्पोलिन्स्की और ज़ोहर द्वारा वर्णित प्रोटोकॉल से आगे बढ़ते हैं, और हम पुराने को भी ब्लॉक इनाम देते हैं: एक पुराना ब्लॉक अपने मूल इनाम का 87.5% प्राप्त करता है, और जो भतीजा पुराने ब्लॉक को शामिल करता है वह शेष 12.5% प्राप्त करता है। हालांकि, लेनदेन शुल्क अंकल को नहीं दिया जाता है।

एथेरियम GHOST का एक सरलीकृत संस्करण लागू करता है जो केवल सात स्तर तक जाता है। विशेष रूप से, इसे इस प्रकार परिभाषित किया गया है:

- एक ब्लॉक को एक पैरेंट निर्दिष्ट करना चाहिए, और यह 0 या अधिक अंकल निर्दिष्ट कर सकता है
- ब्लॉक B में शामिल एक अंकल के पास निम्नलिखित गुण होने चाहिए:
  - यह B के kth पीढ़ी के पूर्वज का प्रत्यक्ष बच्चा होना चाहिए, जहां `2 <= k <= 7`।
  - यह B का पूर्वज नहीं हो सकता
  - अंकल एक वैध ब्लॉक हेडर होना चाहिए, लेकिन पहले से सत्यापित या वैध ब्लॉक होने की आवश्यकता नहीं है
  - अंकल को पिछले ब्लॉकों में शामिल सभी अंकल और एक ही ब्लॉक में शामिल अन्य सभी अंकल (गैर-डबल-समावेशन) से अलग होना चाहिए
- ब्लॉक B में प्रत्येक अंकल U के लिए, B के माईनर को अपने कॉइनबेस इनाम में अतिरिक्त 3.125% मिलता है और U के माईनर को मानक कॉइनबेस इनाम का 93.75% मिलता है।

GHOST का यह सीमित वर्जन, जिसमें केवल 7 पीढ़ियों तक अंकल शामिल किए जा सकते हैं, दो कारणों से उपयोग किया गया था। पहला, असीमित GHOST किसी दिए गए ब्लॉक के लिए वैध अंकल की गणना में बहुत सारी जटिलताएं शामिल करेगा। दूसरा, एथेरियम में उपयोग किए जाने वाले मुआवजे के साथ असीमित GHOST मुख्य श्रृंखला पर माइन करने के लिए एक माईनर के लिए प्रोत्साहन को हटा देता है न कि किसी सार्वजनिक हमलावर की श्रृंखला पर।

### शुल्क {#fees}

क्योंकि ब्लॉकचेन में प्रकाशित हर लेनदेन नेटवर्क पर डाउनलोड और सत्यापित करने की लागत लगाता है, दुरुपयोग को रोकने के लिए कुछ नियामक मैकेनिज्म की आवश्यकता होती है, जिसमें आमतौर पर लेनदेन शुल्क शामिल होता है। Bitcoin में उपयोग किया जाने वाला डिफ़ॉल्ट दृष्टिकोण पूरी तरह से स्वैच्छिक शुल्क रखना है, जो माईनर पर गेटकीपर के रूप में कार्य करने और डायनामिक न्यूनतम निर्धारित करने पर निर्भर करता है। इस दृष्टिकोण को Bitcoin समुदाय में बहुत पसंद किया गया है, विशेष रूप से क्योंकि यह "बाजार-आधारित" है, जो माईनर और लेनदेन भेजने वालों के बीच आपूर्ति और मांग को कीमत निर्धारित करने की अनुमति देता है। हालांकि, इस तर्क की समस्या यह है कि लेनदेन की प्रोसेसिंग एक बाजार नहीं है; यह आकर्षक लगता है कि लेनदेन की प्रोसेसिंग को एक सेवा के रूप में देखा जाए जो माईनर प्रेषक को प्रदान कर रहा है, वास्तविकता में एक माईनर द्वारा शामिल किए गए प्रत्येक लेनदेन को नेटवर्क में हर नोड द्वारा प्रोसेस किया जाना होगा, इसलिए, लेनदेन प्रोसेसिंग की अधिकांश लागत तृतीय पक्षों द्वारा वहन की जाती है, न कि उस माईनर द्वारा जो इसे शामिल करने या न करने का निर्णय ले रहा है। इसलिए, आम लोगों की त्रासदी की समस्याएं होने की बहुत संभावना है।

हालांकि, जैसा कि पता चलता है, बाजार-आधारित तंत्र में यह खामी, जब एक विशेष अनुचित सरलीकरण मान्यता दी जाती है, तो जादुई रूप से खुद को रद्द कर देती है। तर्क इस प्रकार है। मान लीजिए कि:

1. लेनदेन से `k` ऑपरेशन होते हैं, जो किसी भी माईनर को `kR` इनाम की पेशकश करते हैं जो इसे शामिल करता है जहां `R` भेजने वाले द्वारा निर्धारित किया जाता है और `k` और `R` पहले से ही माईनर को (लगभग) दिखाई देते हैं।
2. एक ऑपरेशन की किसी भी नोड के लिए प्रोसेसिंग लागत `C` है (यानी सभी नोड्स की समान दक्षता है)
3. `N` माईनिंग नोड्स हैं, प्रत्येक के पास बिल्कुल समान प्रोसेसिंग पावर है (यानी कुल का `1/N`)
4. कोई नॉन-माईनिंग फुल नोड मौजूद नहीं है।

एक माईनर लेनदेन को तब प्रोसेस करने के लिए तैयार होगा अगर अपेक्षित इनाम लागत से अधिक है। इस प्रकार, अपेक्षित इनाम `kR/N` है क्योंकि माईनर के पास अगले ब्लॉक को प्रोसेस करने की संभावना `1/N` है, और माईनर के लिए प्रोसेसिंग लागत मात्र `kC` है। इसलिए, माईनर उन लेनदेन को शामिल करेंगे जहां `kR/N > kC`, या `R > NC` है। ध्यान दें कि `R` भेजने वाले द्वारा प्रदान किया गया प्रति-ऑपरेशन शुल्क है, और इसलिए यह लाभ की निचली सीमा है जो भेजने वाला लेनदेन से प्राप्त करता है, और `NC` एक ऑपरेशन को प्रोसेस करने के लिए पूरे नेटवर्क की कुल लागत है। इसलिए, माईनरों के पास केवल उन लेनदेन को शामिल करने का प्रोत्साहन है जिनके लिए कुल उपयोगितावादी लाभ लागत से अधिक है।

हालांकि, वास्तविकता में उन मान्यताओं से कई महत्वपूर्ण विचलन हैं:

1. माईनर लेनदेन को प्रोसेस करने के लिए अन्य सत्यापन नोड्स की तुलना में अधिक लागत चुकाता है, क्योंकि अतिरिक्त सत्यापन समय ब्लॉक प्रसार में देरी करता है और इस प्रकार ब्लॉक के पुराना होने की संभावना बढ़ जाती है।
2. नॉन-माईनिंग फुल नोड्स मौजूद हैं।
3. माईनिंग पावर वितरण व्यवहार में बहुत असमान हो सकता है।
4. सट्टेबाज, राजनीतिक दुश्मन और सनकी लोग जिनके उपयोगिता फंक्शन में नेटवर्क को नुकसान पहुंचाना शामिल है, मौजूद हैं और वे चतुराई से ऐसे अनुबंध स्थापित कर सकते हैं जहां उनकी लागत अन्य सत्यापन नोड्स द्वारा भुगतान की गई लागत से बहुत कम है।

(1) माईनर को कम लेनदेन शामिल करने की प्रवृत्ति प्रदान करता है, और (2) `NC` को बढ़ाता है; इसलिए, ये दो प्रभाव कम से कम आंशिक रूप से एक दूसरे को रद्द कर देते हैं।<sup>[कैसे?](https://github.com/ethereum/wiki/issues/447#issuecomment-316972260)</sup> (3) और (4) प्रमुख मुद्दा है; उन्हें हल करने के लिए हम बस एक फ्लोटिंग कैप स्थापित करते हैं: किसी भी ब्लॉक में `BLK_LIMIT_FACTOR` गुना दीर्घकालिक एक्सपोनेंशियल मूविंग एवरेज से अधिक ऑपरेशन नहीं हो सकते। विशेष रूप से:

```js
blk.oplimit = floor((blk.parent.oplimit \* (EMAFACTOR - 1) +
floor(parent.opcount \* BLK\_LIMIT\_FACTOR)) / EMA\_FACTOR)
```

`BLK_LIMIT_FACTOR` और `EMA_FACTOR` स्थिरांक हैं जो फिलहाल 65536 और 1.5 पर सेट किए जाएंगे, लेकिन आगे के विश्लेषण के बाद बदले जाने की संभावना है।

Bitcoin में बड़े ब्लॉक आकारों को हतोत्साहित करने वाला एक और कारक है: बड़े ब्लॉक को प्रसारित करने में अधिक समय लगेगा, और इस प्रकार पुराना बनने की संभावना अधिक होती है। एथेरियम में, उच्च गैस खपत वाले ब्लॉक भी प्रसारित होने में अधिक समय ले सकते हैं क्योंकि वे भौतिक रूप से बड़े होते हैं और लेनदेन स्थिति परिवर्तनों को मान्य करने के लिए प्रोसेस करने में अधिक समय लगता है। यह देरी का हतोत्साहन Bitcoin में एक महत्वपूर्ण विचार है, लेकिन GHOST प्रोटोकॉल के कारण एथेरियम में कम है; इसलिए, नियंत्रित ब्लॉक सीमाओं पर निर्भर रहना एक अधिक स्थिर आधार रेखा प्रदान करता है।

### कम्प्यूटेशन और ट्यूरिंग-कम्प्लीटनेस {#computation-and-turing-completeness}

एक महत्वपूर्ण नोट यह है कि एथेरियम वर्चुअल मशीन ट्यूरिंग-कम्प्लीट है; इसका मतलब है कि EVM कोड किसी भी गणना को एनकोड कर सकता है जो संभवतः की जा सकती है, जिसमें अनंत लूप भी शामिल हैं। EVM कोड दो तरीकों से लूपिंग की अनुमति देता है। पहला, एक `JUMP` निर्देश है जो प्रोग्राम को कोड में पिछले स्पॉट पर वापस जाने की अनुमति देता है और एक `JUMPI` निर्देश सशर्त जम्पिंग के लिए है, जो `while x > 27: x = x * 2` जैसे स्टेटमेंट्स की अनुमति देता है। दूसरा, अनुबंध अन्य अनुबंधों को कॉल कर सकते हैं, संभवतः रिकर्शन के माध्यम से लूपिंग की अनुमति देते हैं। यह स्वाभाविक रूप से एक समस्या की ओर ले जाता है: क्या दुर्भावनापूर्ण उपयोगकर्ता माईनरों और पूर्ण नोड्स को एक अनंत लूप में प्रवेश करने के लिए मजबूर करके अनिवार्य रूप से बंद कर सकते हैं? यह मुद्दा कंप्यूटर विज्ञान में ज्ञात हाल्टिंग समस्या के कारण उत्पन्न होता है: सामान्य मामले में यह बताने का कोई तरीका नहीं है कि क्या कोई दिया गया प्रोग्राम कभी रुकेगा या नहीं।

जैसा कि स्टेट ट्रांजिशन सेक्शन में वर्णित है, हमारा समाधान एक लेनदेन को अनुमति प्राप्त अधिकतम कम्प्यूटेशनल चरणों की संख्या निर्धारित करने की आवश्यकता के द्वारा काम करता है, और यदि निष्पादन लंबे समय तक चलता है तो कम्प्यूटेशन वापस कर दिया जाता है लेकिन शुल्क का भुगतान अभी भी किया जाता है। संदेश उसी तरह काम करते हैं। हमारे समाधान के पीछे की प्रेरणा दिखाने के लिए, निम्नलिखित उदाहरणों पर विचार करें:

- एक हमलावर एक अनुबंध बनाता है जो एक अनंत लूप चलाता है, और फिर उस लूप को सक्रिय करने वाला एक लेनदेन माईनर को भेजता है। माईनर लेनदेन को प्रोसेस करेगा, अनंत लूप चलाएगा और इसकी गैस समाप्त होने का इंतजार करेगा। हालांकि निष्पादन गैस से बाहर हो जाता है और बीच में रुक जाता है, लेनदेन अभी भी मान्य है और माईनर अभी भी हमलावर से प्रत्येक कम्प्यूटेशनल चरण के लिए शुल्क का दावा करता है।
- एक हमलावर एक बहुत लंबा अनंत लूप बनाता है जिसका उद्देश्य माईनर को इतने लंबे समय तक कम्प्यूटिंग करने के लिए मजबूर करना है कि जब तक कम्प्यूटेशन समाप्त होगा तब तक कुछ और ब्लॉक आ चुके होंगे और माईनर के लिए शुल्क का दावा करने के लिए लेनदेन को शामिल करना संभव नहीं होगा। हालांकि, हमलावर को `STARTGAS` के लिए एक मूल्य प्रस्तुत करने की आवश्यकता होगी जो निष्पादन द्वारा ली जा सकने वाली कम्प्यूटेशनल चरणों की संख्या को सीमित करता है, इसलिए माईनर पहले से ही जानेगा कि कम्प्यूटेशन अत्यधिक बड़ी संख्या में चरण लेगा।
- एक हमलावर `send(A,contract.storage[A]); contract.storage[A] = 0` जैसे किसी रूप के कोड वाले अनुबंध को देखता है, और बस पहले चरण को चलाने के लिए पर्याप्त गैस वाला एक लेनदेन भेजता है लेकिन दूसरे को नहीं (यानी निकासी करना लेकिन शेष राशि को कम नहीं होने देना)। अनुबंध लेखक को ऐसे हमलों से बचाव करने की चिंता करने की आवश्यकता नहीं है, क्योंकि यदि निष्पादन बीच में रुक जाता है तो परिवर्तन वापस कर दिए जाते हैं।
- एक वित्तीय अनुबंध जोखिम को कम करने के लिए नौ स्वामित्व डेटा फीड के मध्यमान को लेकर काम करता है। एक हमलावर एक डेटा फीड पर कब्जा कर लेता है, जो डीएओ के खंड में वर्णित वेरिएबल-एड्रेस-कॉल मैकेनिज्म के माध्यम से संशोधन योग्य होने के लिए डिजाइन किया गया है, और इसे एक अनंत लूप चलाने के लिए परिवर्तित करता है, इस प्रकार वित्तीय अनुबंध से धन का दावा करने के किसी भी प्रयास की गैस खत्म करने के लिए मजबूर करने का प्रयास करता है। हालांकि, वित्तीय अनुबंध इस समस्या को रोकने के लिए संदेश पर एक गैस सीमा सेट कर सकता है।

ट्यूरिंग-कम्प्लीटनेस का विकल्प ट्यूरिंग-इनकम्प्लीटनेस है, जहां `JUMP` और `JUMPI` मौजूद नहीं हैं और किसी भी समय कॉल स्टैक में प्रत्येक अनुबंध की केवल एक प्रति की अनुमति है। इस प्रणाली के साथ, वर्णित शुल्क प्रणाली और हमारे समाधान की प्रभावशीलता के बारे में अनिश्चितताएं आवश्यक नहीं हो सकती हैं, क्योंकि एक अनुबंध को निष्पादित करने की लागत उसके आकार से ऊपर सीमित होगी। इसके अलावा, ट्यूरिंग-इनकम्प्लीटनेस इतनी बड़ी सीमा भी नहीं है; हमने आंतरिक रूप से अनुबंध के सभी उदाहरणों की कल्पना की है, अब तक केवल एक के लिए लूप की आवश्यकता थी और उस लूप को भी एक पंक्ति के कोड को 26 बार दोहराने से हटाया जा सकता था। ट्यूरिंग-कम्प्लीटनेस के गंभीर निहितार्थ और सीमित लाभ को देखते हुए, बस एक ट्यूरिंग-इनकम्प्लीट भाषा क्यों न रखें? वास्तविकता में, ट्यूरिंग-इनकम्प्लीटनेस समस्या के एक स्वच्छ समाधान से बहुत दूर है। यह समझने के लिए, निम्नलिखित अनुबंधों पर विचार करें:

```sh
C0: call(C1); call(C1);
C1: call(C2); call(C2);
C2: call(C3); call(C3);
...
C49: call(C50); call(C50);
C50: (run one step of a program and record the change in storage)
```

अब, A को एक लेनदेन भेजें। इस प्रकार, 51 लेनदेनों में, हमारे पास एक अनुबंध है जो 2<sup>50</sup> कम्प्यूटेशनल चरण लेता है। माईनर प्रत्येक अनुबंध के साथ एक मूल्य बनाए रखकर समय से पहले ऐसे तर्क बमों का पता लगाने की कोशिश कर सकते हैं, जिसमें अधिकतम कम्प्यूटेशनल चरणों की संख्या निर्दिष्ट की जा सकती है, और अन्य अनुबंधों को पुनरावर्ती रूप से कॉल करने वाले अनुबंधों के लिए इसकी गणना की जा सके, लेकिन इसके लिए माईनरों को ऐसे अनुबंधों को प्रतिबंधित करना होगा जो अन्य अनुबंध बनाते हैं (क्योंकि उपरोक्त सभी 26 अनुबंधों का निर्माण और निष्पादन आसानी से एक ही अनुबंध में समेटा जा सकता है)। एक और समस्याग्रस्त बिंदु यह है कि किसी संदेश का पता फ़ील्ड एक वेरिएबल है, इसलिए सामान्य तौर पर यह बताना भी संभव नहीं हो सकता है कि किसी दिए गए अनुबंध को समय से पहले कौन से अन्य अनुबंध कॉल करेंगे। इसलिए, परिणाम आश्‍चर्यजनक है: ट्यूरिंग-पूर्णता को प्रबंधित करना आश्चर्यजनक रूप से आसान है, और ट्यूरिंग-पूर्णता की कमी को प्रबंधित करना भी आश्चर्यजनक रूप से उतना ही कठिन है, जब तक कि वही सटीक नियंत्रण मौजूद न हों - लेकिन उस मामले में प्रोटोकॉल को ट्यूरिंग-पूर्ण क्यों न होने दें?

### मुद्रा और जारी करना {#currency-and-issuance}

एथेरियम नेटवर्क में अपनी खुद की बिल्ट-इन मुद्रा, ईथर शामिल है, जो दोहरे उद्देश्य की पूर्ति करती है, विभिन्न प्रकार की डिजिटल संपत्तियों के बीच कुशल विनिमय की अनुमति देने के लिए एक प्राथमिक तरलता परत प्रदान करती है और अधिक महत्वपूर्ण रूप से लेनदेन शुल्क का भुगतान करने के लिए एक मैकेनिज्म प्रदान करती है। सुविधा के लिए और भविष्य के तर्क से बचने के लिए (Bitcoin में वर्तमान mBTC/uBTC/सातोशी बहस देखें), मूल्यवर्ग पहले से लेबल किए जाएंगे:

- 1: wei
- 10<sup>12</sup>: स्जाबो
- 10<sup>15</sup>: फिन्नी
- 10<sup>18</sup>: ईथर

इसे "डॉलर" और "सेंट" या "BTC" और "सातोशी" की अवधारणा का विस्तारित संस्करण माना जाना चाहिए। निकट भविष्य में, हम उम्मीद करते हैं कि सामान्य लेनदेन के लिए "ईथर", सूक्ष्म लेनदेन के लिए "फिन्नी" और शुल्क और प्रोटोकॉल कार्यान्वयन के आसपास तकनीकी चर्चाओं के लिए "स्जाबो" और "वेई" का उपयोग किया जाएगा; शेष मूल्यवर्ग बाद में उपयोगी हो सकते हैं और इस बिंदु पर क्लाइंट में शामिल नहीं किए जाने चाहिए।

जारी करने का मॉडल निम्नानुसार होगा:

- ईथर को एक मुद्रा बिक्री में 1000-2000 ईथर प्रति BTC की कीमत पर जारी किया जाएगा, एक मैकेनिज्म जिसका उद्देश्य एथेरियम संगठन को वित्त पोषित करना और विकास के लिए भुगतान करना है जो अन्य प्लेटफार्मों जैसे मास्टरकॉइन और NXT द्वारा सफलतापूर्वक उपयोग किया गया है। पहले के खरीदारों को बड़े छूट से लाभ होगा। बिक्री से प्राप्त BTC का उपयोग पूरी तरह से डेवलपर को वेतन और बाउंटी का भुगतान करने और एथेरियम और क्रिप्टोकरेंसी पारिस्थितिकी तंत्र में विभिन्न लाभकारी और गैर-लाभकारी प्रोजेक्ट में निवेश करने के लिए किया जाएगा।
- कुल बेची गई राशि का 0.099x (60102216 ETH) संगठन को आवंटित किया जाएगा ताकि शुरुआती योगदानकर्ताओं को मुआवजा दिया जा सके और जेनेसिस ब्लॉक से पहले ETH-मूल्यवर्ग वाले खर्चों का भुगतान किया जा सके।
- कुल बेची गई राशि का 0.099x एक दीर्घकालिक रिजर्व के रूप में बनाए रखा जाएगा।
- कुल बेची गई राशि का 0.26x उस बिंदु के बाद हमेशा के लिए प्रति वर्ष माइनरों को आवंटित किया जाएगा।

| समूह                                   | लॉन्च के समय | 1 साल बाद | 5 साल बाद |
| -------------------------------------- | ------------ | --------- | --------- |
| मुद्रा इकाइयाँ                         | 1.198X       | 1.458X    | 2.498X    |
| खरीदार                                 | 83.5%        | 68.6%     | 40.0%     |
| बिक्री से पहले खर्च किया रिजर्व        | 8.26%        | 6.79%     | 3.96%     |
| बिक्री के बाद इस्तेमाल किया गया रिजर्व | 8.26%        | 6.79%     | 3.96%     |
| माईनर                                  | 0%           | 17.8%     | 52.0%     |

#### दीर्घकालिक आपूर्ति वृद्धि दर (प्रतिशत में)

![एथेरियम इन्फ्लेशन](./ethereum-inflation.png)

_रैखिक मुद्रा प्रसार के बावजूद, Bitcoin की तरह ही समय के साथ आपूर्ति वृद्धि दर शून्य की ओर प्रवृत्त होती है।_

उपरोक्त मॉडल में दो मुख्य विकल्प हैं (1) एंडोमेंट पूल का अस्तित्व और आकार, और (2) Bitcoin की तरह सीमित आपूर्ति के विपरीत एक स्थायी रूप से बढ़ती रैखिक आपूर्ति का होना। एंडोमेंट पूल का औचित्य इस प्रकार है। यदि एंडोमेंट पूल मौजूद नहीं होता, और रैखिक निर्गम को समान इन्फ्लेशन दर प्रदान करने के लिए 0.217x तक कम कर दिया जाता, तो ईथर की कुल मात्रा 16.5% कम होती और इसलिए प्रत्येक इकाई 19.8% अधिक मूल्यवान होती। अतः, संतुलन में 19.8% अधिक ईथर की सेल में खरीद होती, इसलिए प्रत्येक इकाई फिर से पहले की तरह ठीक उतनी ही मूल्यवान होती। संगठन के पास भी 1.198x अधिक BTC होता, जिसे दो हिस्सों में विभाजित माना जा सकता है: मूल BTC और अतिरिक्त 0.198x। इसलिए, यह स्थिति एंडोमेंट के _बिल्कुल समान_ है, लेकिन एक महत्वपूर्ण अंतर के साथ: संगठन केवल BTC रखता है, और इसलिए ईथर इकाई के मूल्य का समर्थन करने के लिए प्रोत्साहित नहीं किया जाता है।

स्थायी रैखिक आपूर्ति वृद्धि मॉडल Bitcoin में कुछ लोगों द्वारा देखे जाने वाले अत्यधिक धन केंद्रीकरण के जोखिम को कम करता है और वर्तमान और भविष्य के युगों में रहने वाले व्यक्तियों को मुद्रा इकाइयाँ प्राप्त करने का उचित अवसर देता है, जबकि साथ ही ईथर प्राप्त करने और रखने के लिए एक मजबूत प्रोत्साहन बनाए रखता है क्योंकि "आपूर्ति वृद्धि दर" प्रतिशत के रूप में समय के साथ शून्य की ओर प्रवृत्त होती है। हम यह भी सिद्धांत देते हैं कि चूंकि कॉइन हमेशा लापरवाही, मृत्यु आदि के कारण समय के साथ खो जाते हैं, और कॉइन के नुकसान को प्रति वर्ष कुल आपूर्ति के प्रतिशत के रूप में मॉडल किया जा सकता है, इसलिए प्रचलन में कुल मुद्रा आपूर्ति वास्तव में अंततः वार्षिक निर्गम को नुकसान दर से विभाजित करने पर प्राप्त मूल्य पर स्थिर हो जाएगी (उदाहरण के लिए, 1% की नुकसान दर पर, जब आपूर्ति 26X तक पहुंच जाती है, तब 0.26X माइन किया जाएगा और 0.26X का नुकसान हर साल होगा, जो एक संतुलन बनाएगा)।

ध्यान दें कि भविष्य में, एथेरियम सुरक्षा के लिए एक प्रूफ-ऑफ-स्टेक मॉडल पर स्विच करने की संभावना है, जो निर्गम आवश्यकता को प्रति वर्ष शून्य से 0.05X के बीच कहीं कम कर देगा। यदि एथेरियम संगठन फंडिंग खो देता है या किसी अन्य कारण से गायब हो जाता है, तो हम एक "सामाजिक अनुबंध" खुला छोड़ते हैं: किसी को भी भविष्य के उम्मीदवार संस्करण के एथेरियम बनाने का अधिकार है, जिसमें एकमात्र शर्त यह है कि ईथर की मात्रा अधिकतम `60102216 * (1.198 + 0.26 * n)` के बराबर होनी चाहिए, जहां `n` जेनेसिस ब्लॉक के बाद वर्षों की संख्या है। निर्माता विकास के लिए भुगतान करने के लिए PoS-संचालित आपूर्ति विस्तार और अधिकतम अनुमेय आपूर्ति विस्तार के बीच के अंतर के कुछ या सभी को क्राउड-सेल या अन्यथा असाइन करने के लिए स्वतंत्र हैं। सामाजिक अनुबंध का पालन न करने वाले उम्मीदवार अपग्रेड को न्यायोचित रूप से अनुपालन वाले संस्करणों में फोर्क किया जा सकता है।

### माईनिंग केंद्रीकरण {#mining-centralization}

Bitcoin माईनिंग एल्गोरिथम, माईनर द्वारा ब्लॉक हेडर के थोड़े संशोधित संस्करणों पर SHA256 की गणना बार-बार लाखों बार करने के द्वारा काम करता है, जब तक कि अंततः एक नोड एक ऐसा संस्करण नहीं निकाल लेता जिसका हैश लक्ष्य (वर्तमान में लगभग 2<sup>192</sup>) से कम होता है। हालांकि, यह माईनिंग एल्गोरिथम, केंद्रीकरण के दो रूपों के प्रति कमजोर है। पहला, माईनिंग पारिस्थितिकी तंत्र ASIC (एप्लिकेशन-स्पेसिफिक इंटीग्रेटेड सर्किट) द्वारा प्रभुत्व में आ गया है, जो Bitcoin माईनिंग के विशिष्ट कार्य के लिए डिज़ाइन किए गए कंप्यूटर चिप हैं, और इसलिए हजारों गुना अधिक कुशल हैं। इसका मतलब है कि Bitcoin माईनिंग अब एक अत्यधिक विकेंद्रीकृत और समतावादी गतिविधि नहीं रह गई है, प्रभावी ढंग से भाग लेने के लिए लाखों डॉलर की पूंजी की आवश्यकता होती है। दूसरा, अधिकांश Bitcoin माईनर वास्तव में स्थानीय स्तर पर ब्लॉक सत्यापन नहीं करते हैं; इसके बजाय, वे ब्लॉक हेडर प्रदान करने के लिए एक केंद्रीकृत माईनिंग पूल पर निर्भर करते हैं। यह समस्या शायद और भी बदतर है: इस लेख के समय तक, शीर्ष तीन माईनिंग पूल अप्रत्यक्ष रूप से Bitcoin नेटवर्क में लगभग 50% प्रोसेसिंग पावर को नियंत्रित करते हैं, हालांकि यह इस तथ्य से कम हो जाता है कि यदि कोई पूल या गठबंधन 51% हमले का प्रयास करता है तो माईनर अन्य माईनिंग पूलों में स्विच कर सकते हैं।

एथेरियम में वर्तमान इरादा एक ऐसे माईनिंग एल्गोरिथम का उपयोग करने का है जहां माईनर को राज्य से रैंडम डेटा प्राप्त करना आवश्यक है, ब्लॉकचेन में पिछले N ब्लॉकों से कुछ रैंडम रूप से चयनित लेनदेन की गणना करना और परिणाम का हैश वापस करना होता है। इसके दो महत्वपूर्ण लाभ हैं। पहला, एथेरियम अनुबंधों में किसी भी प्रकार की गणना शामिल हो सकती है, इसलिए एक एथेरियम ASIC अनिवार्य रूप से सामान्य गणना के लिए एक ASIC होगा - यानी एक बेहतर CPU। दूसरा, माईनिंग के लिए पूरे ब्लॉकचेन तक पहुंच की आवश्यकता होती है, जो माईनर को पूरे ब्लॉकचेन को संग्रहित करने और कम से कम प्रत्येक लेनदेन को सत्यापित करने में सक्षम होने के लिए मजबूर करता है। यह केंद्रीकृत माईनिंग पूलों की आवश्यकता को समाप्त कर देता है; हालांकि माईनिंग पूल अभी भी पुरस्कार वितरण की रैंडमनेस को समान करने की वैध भूमिका निभा सकते हैं, यह कार्य बिना किसी केंद्रीय नियंत्रण के पीयर-टू-पीयर पूलों द्वारा समान रूप से किया जा सकता है।

इस मॉडल की जांच नहीं की गई है और माईनिंग एल्गोरिथम के रूप में अनुबंध निष्पादन का उपयोग करते समय कुछ चतुर अनुकूलन से बचने में कठिनाइयाँ हो सकती हैं। हालांकि, इस एल्गोरिथम की विशेष रूप से दिलचस्प एक विशेषता यह है कि यह किसी को भी "प्रतिष्ठा को नुकसान पहुंचाने" की अनुमति देता है, जिसमें ब्लॉकचेन में बड़ी संख्या में अनुबंधों को शामिल किया जाता है जो विशेष रूप से कुछ ASIC को बाधित करने के लिए डिजाइन किए गए हैं। ASIC निर्माताओं के लिए एक-दूसरे पर हमला करने के लिए ऐसी चाल का उपयोग करने के लिए आर्थिक प्रोत्साहन मौजूद हैं। इसलिए, हम जिस समाधान का विकास कर रहे हैं, वह अंततः एक अनुकूलजन मानवीय आर्थिक समाधान है, पूरी तरह से तकनीकी नहीं।

### स्केलेबिलिटी {#scalability}

एथेरियम के बारे में एक सामान्य चिंता मापनीयता का मुद्दा है। Bitcoin की तरह, एथेरियम भी उस दोष से पीड़ित है कि प्रत्येक लेनदेन को नेटवर्क में प्रत्येक नोड द्वारा प्रोसेस किया जाना चाहिए। Bitcoin के साथ, वर्तमान ब्लॉकचेन का आकार लगभग 15 GB पर है, जो प्रति घंटे लगभग 1 MB बढ़ रहा है। यदि Bitcoin नेटवर्क, वीज़ा के 2000 लेनदेन प्रति सेकंड को प्रोसेस करता, तो यह प्रति तीन सेकंड में 1 MB (प्रति घंटे 1 GB, प्रति वर्ष 8 TB) से बढ़ता। एथेरियम को भी इसी तरह के विकास पैटर्न का सामना करना पड़ सकता है, जो इस तथ्य से बदतर हो जाता है कि Bitcoin की तरह एथेरियम ब्लॉकचेन के शीर्ष पर केवल एक मुद्रा के बजाय कई एप्लिकेशन होंगे, लेकिन इस तथ्य से भी स्थिति बेहतर हो जाएगी कि एथेरियम के पूर्ण नोड्स को संपूर्ण ब्लॉकचेन इतिहास के बजाय केवल राज्य को संग्रहित करने की आवश्यकता होगी।

इतने बड़े ब्लॉकचेन आकार की समस्या केंद्रीकरण का जोखिम है। यदि ब्लॉकचेन का आकार बढ़कर, मान लीजिए, 100 TB हो जाता है, तो संभावित परिदृश्य यह होगा कि केवल बहुत कम संख्या में बड़े व्यवसाय पूर्ण नोड चलाएंगे, जबकि सभी नियमित उपयोगकर्ता हल्के SPV नोड का उपयोग करेंगे। ऐसी स्थिति में, संभावित चिंता उत्पन्न होती है कि पूर्ण नोड एक साथ मिलकर किसी लाभदायक तरीके से धोखा देने के लिए सहमत हो सकते हैं (जैसे, ब्लॉक पुरस्कार बदलना, खुद को BTC देना)। हल्के नोड इसका तुरंत पता नहीं लगा पाएंगे। बेशक, कम से कम एक ईमानदार पूर्ण नोड की संभावना होगी, और कुछ घंटों के बाद धोखाधड़ी की जानकारी रेडिट जैसे चैनलों के माध्यम से बाहर आ जाएगी, लेकिन उस समय तक बहुत देर हो चुकी होगी: यह साधारण उपयोगकर्ताओं पर निर्भर होगा कि वे दिए गए ब्लॉकों को ब्लैकलिस्ट करने का प्रयास करें, जो एक विशाल और संभवतः अव्यवहार्य समन्वय संबंधी समस्या होगी, जो एक सफल 51% हमले को अंजाम देने के समान स्तर पर होगी। Bitcoin के मामले में, यह वर्तमान में एक समस्या है, लेकिन [पीटर टॉड द्वारा सुझाया गया](https://web.archive.org/web/20140623061815/http://sourceforge.net/p/bitcoin/mailman/message/31709140/) एक ब्लॉकचेन संशोधन मौजूद है जो इस मुद्दे को कम करेगा।

निकट भविष्य में, इस समस्या से निपटने के लिए एथेरियम दो अतिरिक्त रणनीतियों का उपयोग करेगा। पहला, ब्लॉकचेन-आधारित माईनिंग एल्गोरिथम के कारण, कम से कम प्रत्येक माईनर को एक पूर्ण नोड होने के लिए मजबूर किया जाएगा, जो पूर्ण नोड्स की संख्या पर एक निचली सीमा बनाएगा। दूसरा और अधिक महत्वपूर्ण, हालांकि, हम प्रत्येक लेनदेन को प्रोसेस करने के बाद ब्लॉकचेन में एक मध्यवर्ती स्थिति ट्री रूट शामिल करेंगे। यहां तक कि अगर ब्लॉक सत्यापन केंद्रीकृत है, जब तक एक ईमानदार सत्यापन नोड मौजूद है, केंद्रीकरण की समस्या को एक सत्यापन प्रोटोकॉल के माध्यम से दरकिनार किया जा सकता है। यदि कोई माईनर एक अमान्य ब्लॉक प्रकाशित करता है, तो वह ब्लॉक या तो बुरी तरह से प्रारूपित होना चाहिए, या स्थिति `S[n]` गलत होगी। चूंकि `S[0]` के सही होने की जानकारी है, इसलिए कोई पहली स्थिति `S[i]` होनी चाहिए जो गलत है जहां `S[i-1]` सही है। सत्यापन नोड इंडेक्स `i` प्रदान करेगा, साथ ही "अमान्यता का प्रमाण" जो `APPLY(S[i-1],TX[i]) -> S[i]` को प्रोसेस करने के लिए आवश्यक पैट्रिशिया ट्री नोड्स के सबसेट से मिलकर बना होगा। नोड्स गणना के उस भाग को चलाने के लिए उन नोड्स का उपयोग कर सकेंगे, और देख सकेंगे कि उत्पन्न `S[i]` प्रदान किए गए `S[i]` से मेल नहीं खाता।

एक और, अधिक परिष्कृत हमला, दुर्भावनापूर्ण माईनरों द्वारा अपूर्ण ब्लॉक प्रकाशित करने से संबंधित होगा, ताकि यह निर्धारित करने के लिए पूरी जानकारी भी मौजूद न हो कि ब्लॉक मान्य हैं या नहीं। इसका समाधान एक चुनौती-प्रतिक्रिया प्रोटोकॉल है: सत्यापन नोड्स लक्षित लेनदेन सूचकांकों के रूप में "चुनौतियाँ" जारी करते हैं, और एक नोड प्राप्त करने पर एक हल्का नोड ब्लॉक को अविश्वसनीय मानता है जब तक कि कोई अन्य नोड, चाहे वह माईनर हो या कोई अन्य सत्यापनकर्ता, वैधता के प्रमाण के रूप में पैट्रिशिया नोड्स का एक सबसेट प्रदान नहीं करता।

## निष्कर्ष {#conclusion}

एथेरियम प्रोटोकॉल को मूल रूप से एक क्रिप्टोकरेंसी के उन्नत संस्करण के रूप में माना गया था, जो एक अत्यधिक सामान्यीकृत प्रोग्रामिंग भाषा के माध्यम से ब्लॉकचेन पर एस्क्रो, निकासी सीमा, वित्तीय अनुबंध, जुआ बाजार और इसी तरह की उन्नत सुविधाएं प्रदान करता है। एथेरियम प्रोटोकॉल किसी भी एप्लिकेशन का सीधे "समर्थन" नहीं करेगा, लेकिन एक ट्यूरिंग-कंप्लीट प्रोग्रामिंग भाषा का अस्तित्व का मतलब है कि सैद्धांतिक रूप से किसी भी लेनदेन प्रकार या एप्लिकेशन के लिए मनमाने अनुबंध बनाए जा सकते हैं। हालांकि, एथेरियम के बारे में जो अधिक दिलचस्प है, वह यह है कि एथेरियम प्रोटोकॉल केवल मुद्रा से कहीं आगे निकल जाता है। विकेंद्रीकृत फ़ाइल भंडारण, विकेंद्रीकृत गणना और विकेंद्रीकृत भविष्यवाणी बाजारों के आसपास के प्रोटोकॉल, दर्जनों अन्य ऐसी अवधारणाओं के बीच, कम्प्यूटेशनल उद्योग की दक्षता को काफी बढ़ाने की क्षमता रखते हैं, और पहली बार एक आर्थिक परत जोड़कर अन्य पीयर-टू-पीयर प्रोटोकॉल को बड़ा बढ़ावा देते हैं। अंत में, ऐसे एप्लिकेशन की एक पर्याप्त श्रृंखला भी है जिनका पैसे से कोई लेना-देना नहीं है।

एथेरियम प्रोटोकॉल द्वारा लागू किए गए एक मनमाने राज्य संक्रमण फंक्शन की अवधारणा एक अद्वितीय क्षमता वाला प्लेटफॉर्म प्रदान करती है; डेटा भंडारण, जुआ या वित्त में अनुप्रयोगों की एक विशिष्ट श्रृंखला के लिए अभिप्रेत एक बंद-सिरे वाला, एकल-उद्देश्य प्रोटोकॉल होने के बजाय, एथेरियम डिजाइन से खुले-सिरे वाला है, और हमारा मानना है कि यह आने वाले वर्षों में बहुत बड़ी संख्या में वित्तीय और गैर-वित्तीय प्रोटोकॉल के लिए एक आधारभूत परत के रूप में सेवा करने के लिए बेहद उपयुक्त है।

## नोट्स और आगे पढ़ने के लिए {#notes-and-further-reading}

### नोट्स {#notes}

1. एक परिष्कृत पाठक यह ध्यान दे सकता है कि वास्तव में एक Bitcoin पता दीर्घवृत्ताकार वक्र सार्वजनिक कुंजी का हैश है, न कि स्वयं सार्वजनिक कुंजी। हालांकि, वास्तव में पबकी हैश को स्वयं एक सार्वजनिक कुंजी के रूप में संदर्भित करना पूरी तरह से वैध क्रिप्टोग्राफिक शब्दावली है। ऐसा इसलिए है क्योंकि Bitcoin की क्रिप्टोग्राफी को एक कस्टम डिजिटल हस्ताक्षर एल्गोरिथम माना जा सकता है, जहां सार्वजनिक कुंजी ECC पबकी के हैश से बनी होती है, हस्ताक्षर ECC पबकी और ECC हस्ताक्षर के संयोजन से बना होता है, और सत्यापन एल्गोरिथम में सार्वजनिक कुंजी के रूप में प्रदान किए गए ECC पबकी हैश के खिलाफ हस्ताक्षर में ECC पबकी की जांच करना और फिर ECC पबकी के खिलाफ ECC हस्ताक्षर का सत्यापन करना शामिल है।
2. तकनीकी रूप से, पिछले 11 ब्लॉकों का मध्यमान।
3. आंतरिक रूप से, 2 और "CHARLIE" दोनों संख्याएँ हैं <sup>[fn3](#notes)</sup>, जहाँ बाद वाला बड़े-एंडियन आधार 256 प्रतिनिधित्व में है। संख्याएँ कम से कम 0 और अधिकतम 2<sup>256</sup>-1 हो सकती हैं।

### अग्रिम पठन {#further-reading}

1. [आंतरिक मूल्य](http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/)
2. [स्मार्ट प्रॉपर्टी](https://en.bitcoin.it/wiki/Smart_Property)
3. [स्मार्ट अनुबंध](https://en.bitcoin.it/wiki/Contracts)
4. [B-मनी](http://www.weidai.com/bmoney.txt)
5. [पुन: प्रयोज्य कार्य के प्रमाण](https://nakamotoinstitute.org/finney/rpow/)
6. [मालिक प्राधिकरण के साथ सुरक्षित संपत्ति शीर्षक](https://nakamotoinstitute.org/secure-property-titles/)
7. [Bitcoin वाइट पेपर](http://bitcoin.org/bitcoin.pdf)
8. [Namecoin](https://namecoin.org/)
9. [ज़ूको का त्रिकोण](https://wikipedia.org/wiki/Zooko's_triangle)
10. [रंगीन कॉइन वाइट पेपर](https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit)
11. [मास्टरकॉइन वाइट पेपर](https://github.com/mastercoin-MSC/spec)
12. [विकेंद्रीकृत स्वायत्त निगम, Bitcoin पत्रिका](http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/)
13. [सरलीकृत भुगतान सत्यापन](https://en.bitcoin.it/wiki/Scalability#Simplified_payment_verification)
14. [मर्कल ट्री](https://wikipedia.org/wiki/Merkle_tree)
15. [पैट्रिशिया ट्री](https://wikipedia.org/wiki/Patricia_tree)
16. [GHOST](https://eprint.iacr.org/2013/881.pdf)
17. [StorJ और स्वायत्त एजेंट, जेफ गार्ज़िक](http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html)
18. [ट्यूरिंग फेस्टिवल में माइक हर्न, स्मार्ट प्रॉपर्टी पर](https://www.youtube.com/watch?v=MVyv4t0OKe4)
19. [एथेरियम RLP](https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP)
20. [एथेरियम मर्कल पैट्रिशिया ट्री](https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree)
21. [मर्कल सम ट्री पर पीटर टॉड](https://web.archive.org/web/20140623061815/http://sourceforge.net/p/bitcoin/mailman/message/31709140/)

_वाइट पेपर के इतिहास के लिए, [इस विकि](https://github.com/ethereum/wiki/blob/old-before-deleting-all-files-go-to-wiki-wiki-instead/old-whitepaper-for-historical-reference.md) को देखें।_

_एथेरियम, कई समुदाय-संचालित, ओपन-सोर्स सॉफ़्टवेयर प्रोजेक्ट की तरह, अपनी प्रारंभिक स्थापना के बाद से विकसित हुआ है। एथेरियम के नवीनतम विकास और प्रोटोकॉल में परिवर्तन कैसे किए जाते हैं, इसके बारे में जानने के लिए, हम [इस गाइड](/learn/) की अनुशंसा करते हैं।_
